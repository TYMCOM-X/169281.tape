
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source  code  listing  constitutes  the proprietary   **
: **  property of MDC-TYMNET.  The recipient, by receiving this   **
: **  program listing, agrees that neither this listing nor the   **
: **  information disclosed herein nor any part thereof shall be  **
: **  reproduced or transferred to other documents or used or dis-**
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by MDC-TYMNET. **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     :  2.01         Release Date : 12/18/86  **
: **                                                              **
: **  File Name          :  SNA02.R01                             **
: **                                                              **
: **  File Description   :  SNA interface R file                  **
: **                                                              **
: **  File Abstract      :                                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **  2.01 12/18/86 MIA  PIR-1825  NEW DEVELOPMENT FOR SNA VHR    **
: **  2.01 12/18/86 YLH  PIR-2307  NEW DEVELOPMENT FOR UNBIND     **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************

	SUBTTL	(SNA-SYGN) System Generation Parameters  --  MAIN
:SYGN02.F01

:	:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


:
:
:	THIS FILE CONTAINS THE SYSTEM GENERATION PARAMETERS
:
:

	RA	0

:	FILE INDETIFIRE
:	---------------
RSBREV	EQ	0081186			:SUB-REV 0 ON DATE 08/11/86

:	KILL SYMBOLS 
:	-------------
	KILL	LINE,RTSCTS,DTRDSR

:	GLOBAL THE NLINES SYMBOL
:	------------------------
NLINES	EQ	NSLINE

:	DEFINE MAXHST, NPORT, NPORTT ETC
:	---------------------------------
	GL	MAXHST,NPORT,MAXPRT
QX	EQ	0
QQ	EQ	0
Q	EQ	0
	RE	NLINES

	IF	\MSTN|Q|
QX	EQ	QX+MSTN|Q|
QR	EQ	0

	RE	MSTN|Q|
QQ	EQ	QQ+MLU|Q||QR|
QR	EQ	QR+1
	ER

	EI	(\MSTN|Q|)
Q	EQ	Q+1
	ER

MAXPUN 	EQ	QX
MAXLUN	EQ	QQ
NGSPU	EQ	(MAXPUN+$A15)/$A16
NGSLU	EQ	(MAXLUN+$A15)/$A16

	IF	MONTOR
MAXPRT	EQ	MAXLUN+HPRT0
	ELSE
MAXPRT	EQ	MAXLUN
	EI	(MONTOR)

:	CALUCATE NBBFLT, NCMDLK
:	----------------------
	GL	NCMDLK
NBBFLT	EQ	MAXLUN*20+MAXPUN*0A
NCMDLK	EQ	MAXLUN*40+MAXPUN*20

:	COMPUTE MAXHST
:	-------------------
:	FIRST DEFINE RH ZERO FOR ALL LINES.
MAXHST	EQ	0			:INITIALIZE
NRPT	EQ	NLINES

	IF	MONTOR
RH|MAXHST|	EQ	HOST0
RHDP|MAXHST|	EQ	MONPRT
RHMP|MAXHST|	EQ	MONPRT
RHTYP|MAXHST|	EQ	MONTYP
MAXHST	EQ	1
NRPT	EQ	NLINES+1
Q	EQ	0
	ELSE
Q	EQ	-1
	EI	(MONTOR)

	RE	NLINES
RH|Q+1|	EQ	0
RHMP|Q+1|	EQ	0
RHDP|Q+1|	EQ	0
RHTYP|Q+1|	EQ	0
Q	EQ	Q+1
	ER

Q	EQ	0
	RE	NLINES
	IF	\SHOS|Q|
Z	EQ	SHOS|Q|
Y	EQ	SNAHST
YZ	EQ	0
ZY	EQ	0
P	EQ	0
	RE	MSTN|Q|
YZ	EQ	YZ+MLU|Q||P|-1
ZY	EQ	ZY+MLU|Q||P|-1
P	EQ	P+1
	ER
QQ	EQ	0
Z2	EQ	1

	RE	NRPT
	IF	(Z-RH|QQ|)
	ELSE	(RH|QQ|-Z)
	ELSE
Z2	EQ	0
LRH|Q|	EQ	QQ			:RELATIVE HOST # FOR THIS LINE
RHDP|QQ|	EQ	RHDP|QQ|+YZ
RHMP|QQ|	EQ	RHMP|QQ|+ZY
	EI
QQ	EQ	QQ+1
	ER

	IF	Z2
LRH|Q|	EQ	MAXHST			:RELATIVE HOST # FOR THIS LINE
HOST|MAXHST|	EQ	Z
RH|MAXHST|	EQ	Z
RHTYP|MAXHST|	EQ	Y
RHDP|MAXHST|	EQ	YZ
RHMP|MAXHST|	EQ	ZY
HPRT|MAXHST|	EQ	ZY
MAXHST	EQ	MAXHST+1
	EI	(Z2)
	EI	(\SHOS|Q|)
Q	EQ	Q+1
	ER

:	COMPUTE NPORT, NPORTT
:	---------------------
NPORT	EQ	MAXPRT+1
NPORTT	EQ	NPORT
NGRP	EQ	$A (NPORT+15)/16

:	DEFINE FWBBF
:	------------
:	IF FWBBF IS UNDEFINED, SET AUTOMATICALLY IF NEEDED.
	IF	\FWBBF
	GL	FWBBF

	IF	NBBFLT*BBFLSZ-0FFFF
Q	EQ	1
	ELSE
Q	EQ	0
	EI	(NBBFLT*BBFLSZ-0FFFF)

	IF	(FWBBF-Q)&1
	REMARK %***  FWBBF NOT CORRECTLY DEFINED !!!!!
	EI	(FWBBF-Q)

	ELSE
	IF	NBBFLT*BBFLSZ-0FFFF
	GL	FWBBF
FWBBF	EQ	1
	ELSE
	GL	FWBBF
FWBBF	EQ	0
	EI	(NBBFLT*BBFLSZ-0FFFF)

	EI	(\FWBBF)

:	MAKE SURE BUFFER SPACE NOT OVERFLOW INTO SEG 14
:	-----------------------------------------------
	IF	(NBBFLT*BBFLSZ-0E0000)
	REMARK	%***  BUFFER SPACE REQUIRED IS TOO LARGE AND OVERFLOW INTO SEG. 14 !!!
	EI

:	DEFINE FOREGROUND ASSEMBLY SWITCH
:	----------------------------------
DLCPHD	EQ	0
DLCSHD	EQ	0
DLCPFD	EQ	0
DLCSFD	EQ	0
Q	EQ	0
	RE	NLINES
QS	EQ	MODE|Q|*2+LINK|Q|
	IF	QS-2
DLCPHD	EQ	1
	ELSE	QS-1
DLCSHD	EQ	1
	ELSE	QS
DLCPFD	EQ	1
	ELSE
DLCSFD	EQ	1
	EI
Q	EQ	Q+1
	ER

:	COMPUTE THE NUMBERS OF CONTROL BLOCKS REQUIRED
:	------------------------------------------------
:	NVRCBK= VRCBK0+VRCBK1+......VRCBK|N|
:	NTGCBK= TGCBK0+TGCBK1+......TGCBK|N|
NVRCBK	EQ	10		:NUMBER OF VR CONTROL BLOCK FOR ALL THE NODES
NTGCBK	EQ	10		:NUMBER OF TG CONTROL BLOCK FOR ALL THE NODES
NSCCBK	EQ	MAXLUN*2	:# OF SCB FOR ALL NODES

	IF	NSCCBK/4-$A64
FWSCB	EQ	1
	ELSE
FWSCB	EQ	0
	EI

:	(06/01/84 NCS)
:	CHECK THE SWITCH FOR SNA HOST DSP SUPPORT
:	-----------------------------------------
:	IF HDPSUP IS UNDEFINED, SET AUTOMATICALLY TO DEFAULT (0)
	IF	\HDPSUP
	ELSE
	GL	HDPSUP
HDPSUP	EQ	0
	EI
:	IF IG2RSP IS UNDEFINED, SET AUTOMATICALLY TO DEFAULT (0)
	IF	\IG2RSP
	ELSE
	GL	IG2RSP
IG2RSP	EQ	0
	EI

:	7/16/84 (MIA)
:	CHECK RSHUTD/TERM-SELF SWITCH
:	-----------------------------
:	IF RSHTSW IS NOT DEFINED, SET IT TO 0 (SEND TERM-SELF)
	GL	RSHTSW
	IF	\RSHTSW
	ELSE
RSHTSW	EQ	0
	EI

:	10/17/84 MIA
:	CHECK SIGNSW - SEND OR NOT SEND A SIGNAL IN VIRTUAL MODE IF
:	SNA HFF IS IN RECEIVE STATE AND WE HAVE A MESSAGE TO SEND.
	GL	SIGNSW
	IF	\SIGNSW
	ELSE
SIGNSW	EQ	0
	EI

:	02/12/85 MIA
:	CHECK RMDALL - PERFORM OR NOT PERFORM EMULATION FOR
:	READ MODIFIED ALL 3270 COMMAND (IBM INCONPATIBILITY).
	GL	RMDALL
	IF	\RMDALL
	ELSE
RMDALL	EQ	1
	EI

:SPECIAL SWITCHES.
	GL	FIRN,PHTIMO
	IF	\FIRN			:(01/15/85 MIA)
	ELSE
FIRN	EQ	0
	EI
	IF	\PHTIMO			:TIMEOUT (01/15/85 MIA)
	ELSE
PHTIMO	EQ	1			:BY PHYSICAL TERMINAL
	EI

:	(03/25/85 MIA)
:	LABLSW - TO SPECIFY USAGE OF PU AND LU LABELS FOR SPECIFIC CRM'S
	IF	\LABLSW
	ELSE
LABLSW	EQ	0
	EI

:	(03/30/85 MIA)
:	EWALSW	- TO SPECIFY REPLACEMENT OF ERASE/WRITE ALT BY E/W
	IF	\EWALSW
	ELSE
EWALSW	EQ	0
	EI

:	(4/29/85/CHS)
:	BNDNTF - TO SPECIFY THAT NNOTIFY WILL BE SENT TO HOST IF THERE IS
:			NO CIRCUIT
	IF	\BNDNTF
	ELSE
BNDNTF	EQ	0
	EI


:	(07/01/85 MIA)
:	FCNGRP - TO SPECIFY THAT PRINTER SUPPORT FLOW CONTROL IS PERFORMED
:			BY ISSUING -RSP TO THE HOST. OTHERWISE THE FLOW
:			CONTROL IS PERFORMED BY DELAYING +RSP.
	IF	\FCNGRP
	ELSE
FCNGRP	EQ	0
	EI


:	(02/27/86/CHS)
:	CRMGSW - TO SPECIFY THAT ERROR MESSAGE GENERATED DURING
:		CRM STAGE IS SENT TO REMOTE TERMINAL INTERFACE.
	IF	\CRMGSW
	ELSE
CRMGSW	EQ	1
	EI


:	(03/21/86/CHS)
:	WSFQRP - TO ENABLE THE LOGIC TO LOCALLY REPLY THE
:		OUTBOUND (HOST TO 3270) QUERY WSF COMMAND
	IF	\WSFQRP
	ELSE
WSFQRP	EQ	0
	EI


:	(03/26/86/CHS)
:	JAPANESE - TO ENABLE THE KATAKANA AND KANJI LANGUAGE
	IF	\JAPANESE
	ELSE
JAPANESE	EQ	0
	EI

:	(02/11/86 MIA)
:	VHRSUP - TO SPECIFY VIRTUAL HOST REFLECT MODE SUPPORT.
	IF	\VHRSUP
	ELSE
VHRSUP	EQ	0
	EI

:	(03/24/86 MIA)
:	VTISUP - TO SPECIFY VIRTUAL TERMINAL INTERFACE SUPPORT.
	IF	\VTISUP
	ELSE
VTISUP	EQ	0
	EI

:	(03/27/86 MIA)
:	KBRTSW - TO SPECIFY THE NEED TO CHECK KEYBOARD RESTORE BIT
:	IN 3270 WCC BEFORE CHANGING DIRECTION (VHR AND VTI ONLY).
	IF	\KBRTSW
	ELSE
KBRTSW	EQ	0
	EI
:
:	(05/20/86 YLH)
:	BSC503 - TO INDICATE BSC VERSION 503.
:
	IF	\BSC503
	ELSE
BSC503	EQ	0
	EI

:
:	(02/12/87 MIA)
:	BRKTSW - TO INDICATE ONE-BRACKET PRIMARY LU-LU SESSIONS ONLY
:(HALF DUPLEX SESSION IF BRKTSW = 1, FULL-DUPLEX SESSION IF BRKTSW = 0)
	IF	\BRKWSW
	ELSE
BRKTSW	EQ	0
	EI

	EM
    : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : STRT01.R00                             **
: **                                                              **
: **  File Description   : ISIS START.LIB                         **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************

	SUBTTL	ISIS Assembly Switch Definitions	- STRT01.R00
:*******************************************************************
	REMARK	%Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	06;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing k node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	SUP.SP	Supervisor-state indicator
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL,SUP.SP
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs
SUP.SP	EQ	0F0139		:byte...0 if no Supervisor (ISIS V9.0++)
:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	\MAXPRT
  ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT	EQ	NPORTT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
    : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : TRAC01.R00                             **
: **                                                              **
: **  File Description   : ISIS TRACE.LIB                         **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	Engine hardware trace trapping routine	TRAC01.R00
:*******************************************************************
	RA	0		:	TRACE.LIB

:	This file provides the necessary backbone for using the TYMNET-ENGINE
:	harware-trace feature.  It should be assembled IMMEDIATELY AFTER the
:	START.LIB file.  The file may be assembled directly from the library
:	version, in which case it is necessary to patch the appropriate test
:	into the assembled code, OR it may be copied and the test hard-coded.

	GL	ENTRY,CRASH	:TWO LIKELY CANDIDATES FOR SYMBOLS REQUIRED

	MO	.,TRACE
	SEG	0		:IN SEGMENT 0
	ORG	10		:AT LOCATION 10
TRPSD	WC	1000,ENTRY	:FORCE A TRANSFER TO "ENTRY"
	WC	TRACE		:ON TRAP, GO TO "TRACE"
TRSAVE	HS	22		:USEFUL AREA TO SAVE REGS, ETC

	SEG	A.CODE		:IN CODE AREA
TRACE	HS	0		:ENTRY TO TRACE LOGIC
	ST	R15,TRSAVE+4	:SAVE A REGISTER
	L	R15,TRPSD+4	:GET ADDRESS WE JUST JUMPED TO
	ST	R15,TRSAVE
	L	R15,TRSAVE+4	:RESTORE REGISTER
	UPSW	TRPSD		:INSTRUCTION TO RE-ENABLE TRACE
	HS	40		:ADDITIONAL AREA TO PATCH IN REQUIRED TEST

:	TRANSFER TO HERE TO TURN ON TRACE INITIALLY
TRBGN	UPSW	IPSD		:THIS WILL TAKE US TO "ENTRY" WITH TRACE ON
IPSD	WC	1000,ENTRY	:TRACE BIT ON, GO TO "ENTRY"
	EM

  : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : TOUT01.R00                             **
: **                                                              **
: **  File Description   : ISIS TIMOUT.LIB                        **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	Standard Timeout Routine Library	- TOUT01.R00
:*******************************************************************
	RA	0		:	TIMOUT.LIB

:	This package contains the standard timeout routines
:	The following parameters MUST be defined on entry:
:	NTOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	six symbols are declared:
:	IZT	called at initilization, link on R0
:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced:
:		R0 = routine address
:		R1 = current fast-clock time.
:	TORET	routines called by TIMOUT should exit to here
:	TOPUT	any code may call this to place an entry on timeout list:
:		link on R5...R6--R15 preserved
:		R0 = address to transfer to
:		R1 = next time to call routine
:	TOGET	called to delete an entry already on timout list
:		link on R5...R6--R15 preserved
:		R0 = routine address...entry with this address will be deleted
:	TONOW	called to flush an entry, and execute it NOW!
:		link on R5...NO registers preserved! NOW!
:		routine address in R0
:	NOTE...when a routine is called from timeout list, it is removed from list,
:	and must call TOPUT to be called again.
:	ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

	GL	IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
	MO	.,TIMOUT

	SEG	A.DATA		:PLACE IN DATA AREA

  IF	6-.
	BS	6-.		:UNUSED 
  EI
TO9	HS	2		:link for timeout processor
LSIZ	EQ	$A 10		:number of bytes in list entry
TLIST	BS	(NTOUT+1)*LSIZ	:timeout list
:				active list entry = halfword chain pointer
:				word routine address
:				word time of next activiation

:		free list pointer is at TLIST
:		active list chain pointer is at TLIST+2
:	CODE SEGMENT
	SEG	A.CODE

TORET	L	R0,TO9		:TIMEOUT ROUTINES EXIT HERE
:	CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT	LHL	R2,TLIST+2	:GET ACTIVE LIST POINTER
	JER	R0		:EXIT IF NO ACTIVE ENTRIES
	L	R1,FASTC,,	:GET CURRENT CLOCK TIME
	CL	R1,TLIST+6,R2	:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0		:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9		:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2	:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R4,TLIST,R2	:SPLICE INTO HEAD OF FREE CHAIN
	STH	R2,TLIST
	L	R0,TLIST+2,R2
	JR	R0		:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2		:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2	:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2		:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2	:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGBS	TPT1		:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH,,	:FREE LIST EXHAUSTED
	BC	0,0,4*R5,0F	:FLAG--LINK R5, TYPE 15d CRASH
TPT3	STH	R4,TLIST,R3	:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	LHL	R3,TLIST,R4
	STH	R3,TLIST	:SHORTEN FREE LIST
	STH	R2,TLIST,R4	:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4
	ST	R1,TLIST+6,R4
	JR	R5		:STORE ARGUMENTS AND RETURN

TONOW	LIS	R1,2		:SEARCH ACTIVE LIST
TONOW1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TONOW1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	ST	R5,TO9		:SAVE RETURN ADDRESS
	JR	R0		:AND GO TO ROUTINE

TOGET	LIS	R1,2		:SEARCH ACTIVE LIST
TOGET1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TOGET1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	JR	R5		:AND EXIT

IZT	LHI	R1,NTOUT*LSIZ	:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0		:0 TERMINATES LIST
	STH	R2,TLIST+2	:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1	:TERMINATE FREE LIST
	STH	R1,TLIST-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	.-6
	JR	R0
	EM
    : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : BIDX01.R00                             **
: **                                                              **
: **  File Description   : ISIS BID.LIB                           **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	Library Package for BID and BIDH	- BIDX01.R00

:*******************************************************************
	RA	0		:	BID.LIB
:	Library package for BID, BIDH

:	either routine called with bit pattern in R1, link on R3
:	returns number of a non-zero bit in R2
	GL	BID,BIDH
	SEG	A.CODE		:PLACE IN CODE AREA
	MO	.,BID
:

:	HALFWORD Bit identifier
:	left half of R1 must be zero if bit 16 is zero
:	returns original word in R1
:	number of leftmost bit of right half or R1 in R2
  IF	ENGINE
BIDH	JFFOH	R1,BIDH1	:FIND FIRST NON-ZERO BIT
	LHI	R2,10	:RETURN 10 IF NO BIT IS FOUND
BIDH1	JR	R3	:AND RETURN
  ELSE
BIDH1	LB	R2,BIDTAB,R1	:LEFT HALF IS EMPTY
	JR	R3		:GET ID OF FIRST BIT IN RIGHT HALF
BIDH	THI	R1,0FF00	:TEST IF FIRST BIT IS IN LEFT OR RIGHT BYTE OF HALFWORD
	JEBS	BIDH1		:RIGHT HALF
	EXBR	R2,R1		:LEFT HALF
	LBR	R2,R2		:COPY LEFT BYTE
	LB	R2,BIDTAB,R2	:USE IT TO INDEX INTO ID TABLE
	SIS	R2,8		:ADJUST NUMBER TO CORRESPOND TO LEFT BYTE
	JR	R3		:AND RETURN
  EI	ENGINE

:	FULLWORD Bit identifier
:	returns original word in R1
:	number of leftmost non-zero bit in R2
  IF	ENGINE
BID	JFFO	R1,BID1		:TEST FULLWORD FOR FIRST NON-ZERO BIT
	LHI	R2,20		:RETURN 20 IF NO BIT FOUND
BID1	JR	R3		:AND RETURN
  ELSE
BID1	LB	R2,BIDTAB,R1	:IN BYTE 4
	AHI	R2,10		:GET BIT ID FOR BYTE AND ADJUST FOR BYTE 4
	JR	R3
BID2	THI	R1,0FF00	:BYTE 1 AND 2 = 0
	JEBS	BID1		:IF BYTE 3 IS 0, LOOK UP BYTE 4
	EXBR	R2,R1		:ELSE COPY OUT BYTE 3
	LBR	R2,R2
	LB	R2,BIDTAB,R2	:PICK UP INDEX FOR THAT BYTE
	AIS	R2,8		:ADJUST FOR BYTE 3
	JR	R3
BID	THI	R1,8000		:TEST IF IN LEFT 17 BITS
	JEBS	BID2		:IF NOT, MUST BE IN BYTE 3 OR 4
	EXHR	R2,R1		:BIT IS IN BYTE 1 OR 2 (OR BIT 16)
	TI	R2,0FF00	:TEST IF BYTE 1
	JEFS	BID3		:SKIP IF NOT
	EXBR	R2,R2		:BIT IS IN BYTE 1, SO COPY BYTE 1
	LBR	R2,R2		:TO USE AS INDEX
	LB	R2,BIDTAB,R2	:LOOK UP ID WITHIN THIS BYTE
	SIS	R2,8		:ADJUST FOR REALLY BEING IN BYTE 1
	JR	R3
BID3	LBR	R2,R2		:HERE WITH BIT IN BYTE 2 (OR BIT 16)
	LB	R2,BIDTAB,R2	:LOOK UP ID WITHIN THIS BYTE
	JR	R3		:IF FIRST BIT WAS BIT 16, USE ENTRY 0 IN TABLE
BIDTAB	HS	0		:TABLE OF BIT NUMBERS IN A BYTE, BIASED BY 8
	NOLIST
	XC	100F0E0E0D0D0D0D0C0C0C0C0C0C0C0C0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B
	XC	0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A
	RE	2
	XC	0909090909090909090909090909090909090909090909090909090909090909
	ER
	RE	4
	XC	0808080808080808080808080808080808080808080808080808080808080808
	ER
	LIST
  EI	ENGINE
	EM
    : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : FRNG01.R00                             **
: **                                                              **
: **  File Description   : ISIS FRING.LIB                         **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	ISIS Ring Handling Routines	- FRNG01.R00
:*******************************************************************
	RA	0		:	FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:	DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	 HS	0;	ELSE;LOOK	 HS	0;	EI
	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2		:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
    	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRSH02.R00
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 2.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : CRSH02.R00                             **
: **                                                              **
: **  File Description   : ISIS CRASH.LIB                         **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************

	RA	0

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the PRODID.
:	Sep. 20, 1982 SCY.
:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT
        GL      CRSTOP,PRODID,NCRSAV,CTIME,CRTIME,EXCRSH,SETMAC,HIMEG
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRXREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:	The symbol EXCRSH, if set to 1, allows a JAL to label
:	CRSH.P out of the crash routine for extended crash processing.
:	The link is R5.  EXCRSH is defaulted to 0.
:
:	The symbol HIMEG, if set to 1, causes a switch to MAC
:	register set 0 on background start-up and subroutine SETMAC
:	to be defined for switching to reg set 0 in foreground and
:	DDT.  The default is 0.
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI

  IF	\EXCRSH			:DEFAULT TO NO EXTENDED CRASH HANDLING
  ELSE
EXCRSH	EQ	0
  EI

  IF	\HIMEG			:MULTI-MEG SUPPORT
  ELSE
HIMEG	EQ	0
  EI

: CRASH TABLE LAYOUT

CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT	HS	1		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HS	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HS	2		:WHERE CRASH OCCURED
CFROM	HS	2    		:WHERE CRASH WAS CALLED FROM
CRXREG	HS	20		:CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

: CRASH TABLE STORAGE

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
CRREG   EQ      CRAT+CRXREG
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL	HS	1		:FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK
	BC	16	:WATCH FROG TIMER - - TIME OUT

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF,,        :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL,,	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRXREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRXREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
	LCS	R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF,,        :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRXREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
        L       R1,CRAT+CRXREG,R2,, :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
  IF	HIMEG
	JAL	R10,SETMAC	:SET TO MAC REG SET 0
  EI
ENTRY1	LIS	R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
        LM      R0,CRAT+CRXREG,, :RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL,,	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
  IF	CRSTOP
  ELSE
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
  EI	CRSTOP
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL,,	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300
	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRAT+CRSHCT,,
	JAL	R4,PUTCH,,	:HW4 LOW = CRASH COUNT
	LIS	R0,0
	JAL	R4,PUTCH,,	:RESERVED BYTE
	LIS	R0,1
	JAL	R4,PUTCH,,	:REPORT TYPE = 1
	LHL	R0,CRAT+CRASHC,,
	JAL	R4,PUTCH,,	:HW3 HIGH = CRASH CODE
	LHI	R0,PRODID
	JAL	R4,PUTCH,,	:HW2 LOW IS PRODUCT ID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV,,          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN


PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1,,    :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1,,
        LM      R6,CRAT+CRTLEN/2,R1,,
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1,
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
         
: SUBROUTINE TO SWITCH TO MAC REG SET 0 FOR EXTENDED MEMORY
:	CALLED IN ENTRY FOR BACKGROUND, MUST BE CALLED BY
:	USER FOR FOREGROUND AND DDT
:	LINK ON R10

SETMAC	HS	0
  IF	HIMEG
	SVC	5,0		:SWITCH TO MAC SET 0
  EI
STMRET	JR	R10		:RETURN

  IF	HIMEG
	GL	MACPSD
MACPSD	WC	0,STMRET	:PSW/PC FOR NEW MAC SET
  EI

	EM
 : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : CVRT01.R00                             **
: **                                                              **
: **  File Description   : ISIS CONVRT.LIB                        **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	Data Conversion Routines	- CVRT01.R00

:*******************************************************************
:
	RA	0
:
	MO	.,CONVRT
:
	GL	BINDEC,BINHEX
:
:*****************************************************************
:
:	BINDEC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII DECIMAL CHARACTERS.
:
:	ARGUMENTS: R9 CONTAINS THE BINARY NUMBER
:	           R10 CONTAINS NUMBER OF DIGITS OF OUTPUT
:	           R11 POINTS TO OUTPUT AREA
:	LINK ON R4
:
:****************************************************************
:
	SEG	A.DATA
:
RSAVE	HS	10	:REGISTER SAVE AREA
:
	SEG	A.CODE
:
DIGIT	AC	/0123456789ABCDEF/
:
:	FIRST CHECK FOR A NEGATIVE NUMBER
:		IF FOUND, PUT A LEADING '-' (MINUS SIGN) IN FIELD
BINDEC	STM	R8,RSAVE	:PRESERVE REGISTERS
	LR	R9,R9		: TEST FOR NEGATIVE NUMBER
	JGEFS	NOTNEG		:JUMP IF NOT NEGATIVE
	LHI	R12,$0 00AD	:'ASCII '-'
	STB	R12,0,R11
	SIS	R10,1		: ROOM FOR ONE LESS DIGIT
	AIS	R11,1		: DITTO
	JLE	RTRN		:NO ROOM FOR DIGIT AFTER MINUS SINE
:	COMPLEMENT THE NUMBER TO POSITIVE
	XI	R9,-1
	AIS	R9,1
NOTNEG	SIS	R11,1
	LIS	R12,$A 10	: DIVISOR
DIVIDE	SR	R8,R8		: CLEAR HI ORDER BITS OF DIVIDEND
	DR	R8,R12		:GET LOW DIGIT IN R9
	LB	R13,DIGIT,R8	:GET ASCII EQUIVALENT OF DEC NUMBER
	STB	R13,0,R10,R11	:STORE IN REVERSE ORDER
	SIS	R10,1		:DECREMENT COUNTER
	JGBS	DIVIDE		: KEEP LOOPING
RTRN	LM	R8,RSAVE	:RESTORE THE REGISTERS
	JR	R4		:AND RETURN
:
:******************************************************************
:
:	BINHEX IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII HEX CHARACTERS. A SPACE CHARACTER IS APPENDED ON THE
:	END OF THE HEX CHARACTER STRING.
:	ARGUMENTS: R8 - ADDRESS OF WHERE TO PUT ASCII CHARACTERS
:			   THIS REGISTER IS RETURNED UPDATED TO NEXT AVAIL
:				LOCATION
:	           R9 - BYTE COUNT
:		   R10 - START ADDRESS OF MEMORY TO BE PROCESSED
:	LINKS R4
:
:******************************************************************
BINHEX	STM	R9,RSAVE	:PRESERVE REGISTERS
LOOP	LB	R11,0,R10	:LOAD BYTE
	LBR	R12,R11		:COPY THE BYTE
	SRHLS	R12,4		:GET FIRST DIGIT
	LB	R13,DIGIT,R12	:GET ASCII CHARACTER
	STB	R13,0,R8	:STORE THE CHARACTER
	LIS	R12,0F		:LOAD MASK
	NR	R12,R11		:MASK OFF HIGH DIGIT
	LB	R13,DIGIT,R12	:GET ASCII CHAR
	STB	R13,1,R8	:STORE THE CHARACTER
	SIS	R9,1		:DECREMENT LOOP COUNT
	JGFS	REPEAT		:MORE TO DO?
	LHI	R13,$0 0A0	:LOAD SPACE CHARACTER
	STB	R13,2,R8	:STORE IT
	AIS	R8,3		:INCREMENT STRING POINTER
	LM	R9,RSAVE	:RESTORE THE REGISTERS
	JR	R4		:AND RETURN
:
REPEAT	AIS	R8,2		:INCREMENT STRING POINTER
	AIS	R10,1		:INCREMENT BYTE ADDRESS
	J	LOOP		:REPEAT

	EM
:
  : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : DATM01.R00                             **
: **                                                              **
: **  File Description   : ISIS DATIME.LIB                        **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	GMT Clock Conversion Routines	- DATM01.R00

:*******************************************************************
:
	RA	$0 0A
:
	MO	.,DATIME
:
	GL	DATIME,TMSTMP,DATE
:
:***************************************************************
:
:	THIS PROCEDURE CONVERTS THE GMT CLOCK
:	RELATIVE TO 1/1/74 FROM SECONDS TO
:	DDMMMYY HH:MM (GMT) OR
:	DDMMMYY HH:MM:SS (GMT)
:
:	PARMS
:		R3 = # OF SECONDS SINCE 1/1/74 (BEYOND1/1/76)
:		R4 = CHARACTERS OF OUTPUT (13 OR 16)
:		R5 = ADDRESS OF OUTPUT STRING
:		R6 = LINK REGISTER
:	ALL REGISTERS ARE PRESERVED
:
:**************************************************************
:
	SEG	A.DATA
:
RSAVE	HS	$020	:REGISTER SAVE AREA
:
	SEG	A.CODE
DATIME	STM	R0,RSAVE	:PRESERVE THE REGISTERS
	S	R3,SEC745	
:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULAR YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2		: CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	LR	R14,R2		:COPY TIME OF DAY
	SR	R2,R2		:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
	LHI	R8,76		:BASE YEAR
	SLLS	R3,2		:QUAD YEAR * 4
	AR	R8,R3		:ADD TO BASE YEAR
	LA	R7,LEPYEA	:POINT TO DAYS IN MONTH
	C	R2,W366		:IS IT IN CURRENT YEAR?
	JL	MONTHD		:JUMP IF SO
	S	R2,W366		:SUBTRACT DAYS IN YEAR
	AIS	R8,1		:ADD 1 TO YEAR
	LR	R11,R2		:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	LR	R2,10
	AR	R8,R11
	LI	R7,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R2
:	YEAR IN R8
MONTHD	SR	R6,R6		:MONTH COUNTER
	AIS	R2,1		:MAKE 1/1/76 = DAY 1
MONLOP	LR	R9,R2		:SAVE DAYS
	LB	R3,0,R6,R7	:GET DAYS IN MONTH
	SR	R2,R3		:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE		:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1		:INCREMENT INDEX
	JBS	MONLOP
:
:	DAYS IN R3
:	MONTH NUMBER - 1 IN R6
:	YEAR IN R8
:
:	SAVE R4 AND R5
DAZE	SIS	R4,8		:SUBTRACT OUT DATE LENGTH
	LR	R13,R4		:PRESERVE IT
	LR	R11,R5		:COPY OUPUT AREA POINTER
:
:	CONVERT DAY
	LIS	R10,2		:# OF OUTPUT CHARACTERS
	JAL	R4,BINDEC	:CONVERT TO DECIMAL ASCII
:
:	MOVE IN MONTH
	AIS	R11,2
	SLHLS	R6,2		:MULTIPLY MONTH NUMBER BY 4
	L	R4,MONTHS,R6	:GET THE NAME IN R4
	STB	R4,2,R11
	SRLS	R4,8
	STB	R4,1,R11
	SRLS	R4,8
	STB	R4,0,R11
	AIS	R11,3
:
:	CONVERT YEAR
	LR	R9,R8
	LIS	R10,2
	JAL	R4,BINDEC	:CONVERT TO CHARACTERS
	LHI	R3,$00A0	:ASCII SPACE
	STB	R3,2,R11	:PUT IT AFTER DATE
	LHI	R5,3,R11	:SET UP OUTPUT POINTER
	LR	R4,R13		:COPY LENGTH ARGUEMENT
	LR	R3,R14		:COPY TIME OF DAY
	JFS	TIME1		:JUMP
:*************************************************************
:
:	GET THE TIME STAMP
:
:	TIME STAMP ROUTINE
:		THIS ROUTINE CONVERTS THE FULLWORD GMT TIME OF DAY
:	TO HH:MM OR HH:MM:SS
:
:	PARAMETERS:
:		R3 = FULLWORD TIME OF DAY (GMT CLOCK)
:		R4 = 5 OR 8 (# OF CHARACTERS TO OUTPUT)
:		R5 = FULLWORD ADDRESS OF OUTPUT
:		R6 = LINK REGISTER
:
:	DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:	IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:	ROUTINE IS ALL ABOUT
:
:****************************************************************
TMSTMP	STM	R0,RSAVE	:PRESERVE THE REGISTERS
  IF \TIMZON
	AHI	R3,TIMZON*$A3600	:TIME ZONE CONVERSION
  EI
TIME1	SR	R8,R8		:INDEX FOR OUTPUT AREA
:
	SR	R2,R2		:CLEAR HI-ORDER BITS
	D	R2,SECDAY
:		SECONDS NOW IN R2
	LR	R3,R2		:GET READY FOR
	SR	R2,R2		:ANOTHER DIVIDE
	D	R2,TENOUR	:GET TENS OF HOURS
	JAL	R6,ASCOUT	:PRINT IT OUT IN ASCII
	DH	R2,OURS		:GET HOURS
:		R2 HAS REMAINDER, R3 HAS QUOTIENT
	JAL	R6,ASCOUT	:PRINT IT OUT
	LHI	R3,$00BA	:COLON
	JAL	R6,PRTOUT
	DH	R2,TENMIN
	JAL	R6,ASCOUT
	DH	R2,MIN
	JAL	R6,ASCOUT
:	THE CONDITION CODE HAS BEEN SET -
:	SET IF ANY MORE CHARACTER WANTED
	JE	RETRN		:JUMP IF ONLY 5 CHAR
:
:	PUT IN COLON BEFORE SECONDS
	LHI	R3,$00BA
	JAL	R6,PRTOUT
	DH	R2,TENSEC
	JAL	R6,ASCOUT
	LR	R3,R2		:GET SECONDS IN R3
	JAL	R6,ASCOUT
RETRN	LM	R0,RSAVE	:RESTORE THE REGISTERS
	JR	R6		:RETURN
:
:
ASCOUT	AHI	R3,$00B0
PRTOUT	STB	R3,0,R8,R5
	AIS	R8,1	: UPDATE INDEX
	SIS	R4,1
	JR	R6
:
:****************************************************************
:
:	THIS ROUTINE RETURNS A FULLWORD REPRESENTATION OF THE DATE
:	AND TIME. THE FORMAT OF THE RESULT IS MMDDHHMM WHERE
:	MM, DD, HH, & MM REPRESENT MONTH, DAY, HOUR, & MINUTES RESPECTIVELY
:	ALL IN DECIMAL FORMAT. I.E. DEC 12 13:41 WOULD BE 12121341.
:
:	IF THE SYMBOL TIMEZON IS DEFINED IT SHOULD BE THE TIME-ZONE
:	CORRECTION FACTOR FROM CUT (COORDINATED UNIVERSAL TIME)
:	I.E. PST IS -8.
:
:	PARMS
:		R3 = GMT CLOCK VALUE
:		R6 = RESULT FULLWORD
:
:	LINKS R5
:
:	PRESERVES REGISTERS R7 - R15
:
:******************************************************************
DATE	STM	R7,RSAVE	:PRESERVE THE REGISTERS
	S	R3,SEC745
:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULAR YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2		: CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	LR	R14,R2		:COPY TIME OF DAY
	SR	R2,R2		:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
	LHI	R8,76		:BASE YEAR
	SLLS	R3,2		:QUAD YEAR * 4
	AR	R8,R3		:ADD TO BASE YEAR
	LA	R7,LEPYEA	:POINT TO DAYS IN MONTH
	C	R2,W366		:IS IT IN CURRENT YEAR?
	JL	MNTHD		:JUMP IF SO
	S	R2,W366		:SUBTRACT DAYS IN YEAR
	AIS	R8,1		:ADD 1 TO YEAR
	LR	R11,R2		:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	LR	R2,10
	AR	R8,R11
	LI	R7,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R2
:	YEAR IN R8
MNTHD	SR	R6,R6		:MONTH COUNTER
	AIS	R2,1		:MAKE 1/1/76 = DAY 1
MLOOP	LR	R9,R2		:SAVE DAYS
	LB	R3,0,R6,R7	:GET DAYS IN MONTH
	SR	R2,R3		:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE1		:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1		:INCREMENT INDEX
	JBS	MLOOP
:
:	DAYS IN R9
:	MONTH NUMBER - 1 IN R6
:	YEAR IN R8
:
DAZE1	AIS	R6,1		:CONVERT TO MONTH NUMBER
	LB	R6,DECMAL,R6	:CONVERT TO DECIMAL REPRESENTATION
	SLLS	R6,8		:MOVE IT OVER
	LB	R9,DECMAL,R9	:CONVERT DAY TO DECIMAL
	OR	R6,R9		:OR IT IN
	SLLS	R6,8		:SHIFT IT OVER
	LR	R2,R14		:COPY SECONDS IN THE DAY
	DH	R2,OURS		:R3 HAS NUMBER OF HOURS
	LB	R3,DECMAL,R3	:CONVERT TO DECIMAL
	OR	R6,R3		:OR IT IN
	SLLS	R6,4		:SHIFT IT OVER
	DH	R2,TENMIN	:R3 HAS TENS OF MINUTES
	OR	R6,R3		:OR IT IN
	SLLS	R6,4		:SHIFT IT OVER
	DH	R2,MIN		:R3 HAS MINUTES
	OR	R6,R3		:OR IT IN
:
	LM	R7,RSAVE	:RESTORE REGISTERS
	JR	R5		:RETURN
:
DECMAL	XC	0001020304050607080910111213141516171819202122232425262728293031
SECDAY	WC	24*60*60	:SECONDS IN A DAY
TENOUR	WC	10*60*60	:TENS OF HOURS
OURS	HC	60*60		:HOURS
TENMIN	HC	10*60		:TENS OF MINS
MIN	HC	60		:MIN
TENSEC	HC	10		:TENS OF SECS
  IF	\TIMZON
SEC745	WC	24*60*60*365*2-TIMZON*60*60	:SECONDS IN 74 & 75 PLUS 
						:TIME-ZONE CORRECTION
  ELSE
SEC745	WC	24*60*60*365*2	:SECONDS IN 74 AND 75
  EI
W365	WC	365
W366	WC	366
QUADAY	WC	4*365+1
LEPYEA	BC	31,29,31,30,31,30,31,31,30,31,30,31
REGYER	BC	31,28,31,30,31,30,31,31,30,31,30,31
	WS	0
MONTHS	AC	/ Jan/
	AC	/ Feb/
	AC	/ Mar/
	AC	/ Apr/
	AC	/ May/
	AC	/ Jun/
	AC	/ Jul/
	AC	/ Aug/
	AC	/ Sep/
	AC	/ Oct/
	AC	/ Nov/
	AC	/ Dec/
	EM

	RA	0	:RADIX TO HEX

	SUBTTL	(SNA-CTBK) Templates of System Data STRUCTURES - GBLDEF
:CTBK00.Z00

	MO	.,GBLDEF
	RA	0			:RADIX IS HEX

:	:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	06/06/84 (NCS) -- ADD NEW STORAGE FOR SNA HOST DSP 
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	LO	MAIN
	GL	ACTIVD,ACTIVC,ACTIVO,ACTIVT,PORTAB,DCBLKS

:	GLOBAL SYMBOLS
:	--------------
	GL	PSEG
PSEG	EQ	SEG|A.CODE|

:	CRASH CODES
:	-----------
CRIPOM	EQ	20			:INVALID PORT 0 MESSAGE
CRNAR	EQ	21			:NO ACTIVATION ROUTINE FOUND
CRINVN	EQ	22			:INVALID NEEDLE RECEIVED
CRINVM	EQ	23			:INVALID MESSAGE RECEIVED
CRDCB	EQ	24			:DCB TABLE PROBLEM
CRIHST	EQ	25			:INVALID HOST NUMBER
CRNDA	EQ	26			:NO DEVICES ADDRESSES
CRINVO	EQ	27			:INVALID OUTPUT REQUEST
CRNOBF	EQ	28			:NO BUFFERLETS AVAILABLE
CRMONT	EQ	29			:MONITOR TABLE OVERFLOW
CRNCMD	EQ	2A			:NO COMMAND LINK FOUND
CRDALP	EQ	2B			:DEVICE ADDRESS LIST PROBLEM
CRIRS	EQ	2C			:IMPOSSIBLE RECEIVE STATE
CRINVC	EQ	2D			:lINVALID OUTPUT COMMAND
CRIXMT	EQ	2E			:INVALID XMT REQUEST
CRINVX	EQ	2F			:INVALID IIX DIALECT/GLOBAL CODE
CRBCMD	EQ	30			:BAD COMMAND LIST ADVANCE
CRBFMH	EQ	31			:(F00/02/23/87/DB)
					:FMH NOT ALLOWED BY BIND 

:	DEFINE HOST STATUS
:	------------------
HSTANS	EQ	0			:HOST ANSWER
HSTDWN	EQ	1			:HOST DOWN
HSTSHT	EQ	2			:HOST SHUT
HSTOUT	EQ	2			:HOST OUT OF PORTS

:
:	SDLC COMMAND AND RESPONSE FRAMES
:

:	SUPERVISORY FORMAT
:	------------------
RR	EQ	1			:RECEIVE READY
REJ	EQ	9			:REJECT
RNR	EQ	5			:RECEIVE NOT READY

:	U (UNNUMBERED) FORMAT
:	----------------------
SNRM	EQ	83			:SET NORMAL RESPONSE MODE
UA	EQ	63			:UNNUMBERED ACKNOWLEDGEMENT
DISC	EQ	43			:DISCONNECT
RD	EQ	43			:REQUEST DISCONNECT
DM	EQ	0F			:DISCONNECT MODE
RIM	EQ	07			:REQUEST INITIALIZATION MODE
SIM	EQ	07			:SET INITIALIZATION MODE
FRMR	EQ	87			:FRAME REJECT
XID	EQ	0AF			:EXCHANGE STATION IDENTIFICATION
TEST	EQ	0E3			:TEST
:UI	EQ	03			:UNNUMBERED INFORMATION FRAME
:CFGR	EQ	0C7			:CONFIGURE
:UP	EQ	23			:UNNUMBERED POLL
:BCN	EQ	0EF			:SIGNAL LOSS OF INPUT

:	ACCESS LINK TYPE
:	----------------
FDPP	EQ	00			:FULL DUPLEX POINT TO POINT
HDPP	EQ	01			:HALF DUPLEX POINT TO POINT
FDMP	EQ	02			:FULL DUPLEX MULTI-POINT
HDMP	EQ	03			:HALF DUPLEX MULTI-POINT

:	MASKS FOR ACCESS LINKS
:	----------------------
HDMASK	EQ	01			:HALF DUPLEX MASK

:	PRIMARY/SECONDARY
:	-----------------
PRIMRY	EQ	01			:PRIMARY STATION
SECDRY	EQ	00			:PRIMARY STATION

:	MASK FOR PRIMARY/SECONDARY
:	--------------------------
PSMASK	EQ	01			:MASK FOR PRIMARY/SECONDAR

:	COMMANDS/RESPONSES - LINK LEVEL
:	-------------------------------
:	COMMAND :	MAIN COMMAND, SUB COMMAND
:			CCCCCCCC	SSSSSSSS
:	CC = 	00	- EMPTY CMD ELEMENT


:	CCC BETWEEN IFC AND SNA
:	-----------------------
XINIT	EQ	01			:OPEN(INIT) CMD/RSP FOR ACTPU/ACTLU
XCLOSE	EQ	02			:CELAR(CLOSE) CMD/RSP FOR DACTPU/DACTLU
XLNKDW	EQ	03			:DOWN CMD/RSP FOR PHYSICAL/DLC BROKEN
XCDOWN	EQ	03			:DOWN CMD/RSP FOR PHYSICAL/DLC BROKEN
XCKTDW	EQ	04			:RESET CMD/RSP FOR CIRCUIT ZAPPED
MXSNNW	EQ	04			:MAXI CMD VALUE

:	SCC - ERROR CODE FOR RSP CCC
:	----------------------------
E.POSR	EQ	0			:POSITIVE RESPONSE
E.NEGR	EQ	1			:NEGATIVE RESPONSE
E.REST	EQ	2			:FOR RESET STATUS
E.STAT	EQ	3			:LU/PU STATE ERROR
E.POFF	EQ	4			:POWER OFF

:	CCC TO/FROM DLC LAYER
:	---------------------
DLCCTL	EQ	01			:DLC CONTROL CMD/RSP
DLCLNK	EQ	02			:DLC LINK FRAMES
IFCDLC	EQ	DLCCTL			:DLC<->IFC CMD/RSP


:*************************************************************
:	COMMAND AND SUBCOMMAND CODES IN NTW ->SNA QUEUE
:*************************************************************

:	COMMANDS FROM NTW TO SNA QUEUE
:	------------------------------
NSSTLG	EQ	0FF			:START LOGON
NSSTAT	EQ	0FF			:STATUS COMMAND
NSFNLG	EQ	0FE			:FINISH LOGON
NSCMMX	EQ	0FE			:MAXIMUM COMMAND TYPE

:	SUBCOMMANDS FOR START LOGON
:	------------------------------
NSSTTR	EQ	01			:LOGON INITIATED IN RESPONSE TO REQUEST
					:LOGON COMMAND
NSSTNW	EQ	02			:UNSOLICITED START LOGON
NSUBRP	EQ	03			:REQUEST FOR RSP(UNBIND) FOR VHR

:	SUBCOMMANDS FOR STATUS COMMAND (HOST DSP)
:	------------------------------
NSTRST	EQ	01			:TERMINAL STATUS (STATUS CODE IN LENGTH
					: BYTES)
NSFRER	EQ	02			:FORCE ERROR RECOVERY

:	SUBCOMMANDS FOR START LOGON/STATUS COMMAND (VTI)
:	------------------------------------
NSTDMN	EQ	NSSTTR			:MINIMUM SUBCOMMAND FOR VTI
:NSSTTR	EQ	1			:SAME AS BEFORE
:NSSTNW	EQ	2			:SAME AS BEFORE
NSTDUB	EQ	3			:SEND UNBIND
NSTDBD	EQ	4			:SEND BIND
NSTDST	EQ	5			:SEND SDT
NSTDNE	EQ	6			:GENERATE ERROR CMD TO NIO
NSTDBI	EQ	7			:SEND BID
NSTDMX	EQ	NSTDBI			:MAXIMUM SUBCOMMAND FOR VTI

:	SUBCOMMANDS FOR FINISH LOGON
:	--------------------------
NSFNTR	EQ	01			:GO TO TRANSPARENT MODE
NSFNDP	EQ	02			:GO TO DSP MODE
NSBDRP	EQ	03			:REQUEST RSP(BIND) FOR VHR

:****************************************************************
:	COMMANDS REPRESENTING DATA TYPES IN NTW ->SNA QUEUE	:
:****************************************************************

:	COMMANDS REPRESENTING DATA TYPE FROM NTW TO SNA QUEUE
:	------------------------------------------------------
NSETEM	EQ	01			:TRANSPARENT DATA (DSP,SNA)
NSINTM	EQ	02			:LOGON DATA
NSDTMX	EQ	02			:MAXIMUM DATA TYPE CURRENTLY DEFINED

:	SUBCOMMANDS FOR DATA MESSAGES 
:	-------------------------------------------------------
:	NOTE: (ALL SUBCOMMANDS ARE MANDATORY ONLY IN LOCAL OR DSP MODE.
:	CURRENT LU_SVC DISREGARDS THE SUBCOMMAND BYTE IN TRANSPARENT MODE
:	TAKING ALL INFORMATION FROM DATA).
:	BIT 6,7 - SEGMENTATION (INVERSE CODING COMPARED TO IBM/SNA)
:		00 - SINGLE ELEMENT (NOT SEGMENTED)
:		01 - 1ST BUT NOT LAST SEGMENT
:		10 - LAST BUT NOT 1ST SEGMENT
:		11 - INTERMEDIATE SEGMENT
:	BIT 4,5 - CHAINING INDICATOR (INVERSE CODING)
:		(EVERY CHAIN CAN CONTAIN ONLY ONE 3270 COMMAND OR AID - EXCEPT
:		 FOR STRUCTURED FIELDS - AND IT MUST BE THE FIRST RU BYTE OF
:		 CHAIN)
:		00 - SINGLE-ELEMENT CHAIN
:		01 - 1ST BUT NOT LAST ELEMENT OF CHAIN
:		10 - LAST BUT NOT 1ST ELEMENT OF CHAIN
:		11 - INTERMEDIATE ELEMENT OF CHAIN
:	BIT 3	- CANCEL (DSP MODE ONLY).
:		(ONLY THE CURRENT CHAIN CAN BE CANCELLED).
:	BIT 2	- END-TO-END ACK (DSP MODE ONLY).
:	BIT 1   - BRACKET TERMINATION ALLOWED INDICATOR
:		(DEFAULT IS 0 - END OF BRAKET IS ALLOWED. END OF BRACKET WILL
:		 PUT BRACKETING PROTOCOL MACHINES IN CONTENTION MODE ALLOWING
:		 BOTH SIDE TO SPEAK.
:		 LU_SVC IN LOCAL MODE WILL TERMINATE BRACKET - IF ALLOWED, IF 
:		 CHANGE DIRECTION IS SPECIFIED.
:		 BEGIN BRACKET IS CONTROLLED ONLY BY INTERNAL LU_SVC LOGIC.)
:	BIT 0   - CHANGE DIRECTION INDICATOR
:		(THIS INDICATOR CAN BE SET ONLY AT THE 1ST ELEMENT OF A CHAIN
:		 IN LOCAL MODE OR LAST ELEMENT OF A CHAIN IN DSP MODE.
:		 IN LOCAL MODE, WHEN THE "WHOLE" SCREEN DATA HAS BEEN SENT TO
:		 LU_SVC AND A REPLY FROM TERMINAL OPERATOR IS WAITING, THE
:		 LOGON MODULE WILL SET THE CHANGE DIRECTION INDICATOR.
:		 ERROR RECOVERY WILL BE PERFORMED BY RE-DISPLAY THE 'SCREEN'
:		 BY FOLLOWING THE ABOVE CONVENTIONS.)

:	BIT 6,7 - SEGMENTING INDICATOR
NSDTFS	EQ	01			:1ST BUT NOT THE LAST SEGMENT
NSDTLS	EQ	02			:LAST BUT NOT THE FIRST SEGMENT
NSDTIS	EQ	03			:INTERMEDIATE SEGMENT

:	BIT 4,5 - CHAINING INDICATOR
NSDTFC	EQ	04			:1ST BUT NOT THE LAST ELEMENT OF CHAIN
NSDTIC	EQ	0C			:INTERMEDIATE ELEMENT OF CHAIN
NSDTLC	EQ	08			:LAST BUT NOT THE 1ST ELEMENT OF CHAIN

:	BIT 3 - CANCEL INDICATOR
NSDTCN	EQ	10			:CANCEL CURRENT CHAIN

:	BIT 2 - END-TO-END ACK INDICATORN
NSDTAK	EQ	20			:ACKNOLEDGE BACK THE NEXT CHAIN

:	BIT 1 - BRACKET TERMINATION NOT ALLOWED INDICATOR
NSDTEB	EQ	40			:BRACKET TEMINATION IS NOT ALLOWED

:	BIT 0 - CHANGE DIRECTION INDICATOR
NSDTCD	EQ	80			:CHANGE OF DIRECTION IS REQUIRED

:*************************************************************
:	COMMAND AND SUBCOMMAND CODES IN SNA -> NTW DATA QUEUE
:*************************************************************

:	COMMANDS FROM SNA TO NTW DATA QUEUE
:	-----------------------------------
SNPOSR	EQ	0FF			:POSITIVE RSP (REASON IN SUBCOMMAND)
SNERR	EQ	0FE			:ERROR (LENGTH FIELD MAY HAVE SNA
					:	SENSE CODE)
SNRQLG	EQ	0FD			:RQ TO ENTER LOCAL MODE (POSSIBLE RSPS:
					:FROM NIO - START LOGON OR FINISH LOGON
					:IF START LOGON ANSWER,ALL END-TO-END
					:DATA MESSAGES BETWEEN THIS MESSAGE AND
					:POSITIVE RESPONSE TO FINISH LOCAL MODE
					:WILL NOT BE SENT THRU THE NETWORK BY
					:NIO.
					:FINISH LOGON RIGHT AFTER THIS COMMAND
					:WILL NOT HAVE ANY DISCARDED MESSAGES.
SNCMMX	EQ	0FD			:MAXIMUM COMMAND TYPE CURRENTLY DEFINED

:	SUBCOMMANDS FOR COMMAND-- POSITIVE RESPONSE
:	------------------------------------------
SNSTLG	EQ	00			:POSITIVE RESPONSE FOR START LOGON
					:LENGTH FIELD HAS THE FOLLOWING
					:STRUCTURE. HIGH BIT 1 - ONLY
					:SINGLE CHAIN ELEMENTS ARE ALLOWED.
					:THE REMAINING 31 BITS - MAX RU SIZE

SNFNLG	EQ	01			:POSITIVE RESPONSE FOR FINISH LOGON
					:ALL END-TO-END MSGS WILL NOT BE SENT
					:THRU THE NETWORK UNTIL SNFNLG
					:IF FINISH WAS SENT AFTER START LOGON.

SNSCRN	EQ	02			:SCREEN TRANSMISSION SUCCESSFUL
					:LOGON MODULE WILL NOT SEND THE NEXT
					:SCREEN (SET OF LOCAL CHAINS
					:WHICH ENDS WITH
					:CHANGE DIRECTION) UNTIL EITHER
					:THIS COMMAND OR END-TO-END DATA
					:MESSAGE WAS RECEIVED

SNDPAK	EQ	03			:END-TO-END ACK FOR DSP

:	SUBCOMMANDS FOR REQEST LOGON/LOGOFF (VHR ONLY)
SNRQBD	EQ	01			:REQUEST FOR LOGON (BIND)
SNRQUB	EQ	02			:REQUEST FOR LOGOFF (UNBIND)

:	SUBCOMMANDS FOR COMMAND-- ERROR COMMAND
:	------------------------------------------
	IF	HDPSUP
SNERRD	EQ	0			:RESERVED
SNERPO	EQ	1			:UNBIND
SNERBD	EQ	2			:BAD BIND
	ELSE
SNERRD	EQ	0			:REDISPLAY THE SCREEN
SNERPO	EQ	1			:POWER OFF (BIND FAILURE)
SNERBD	EQ	2			:BIND FAILURE (OTHER THEN POWER OFF)
	EI
SNERTO	EQ	3			:TIMEOUT IN LU_SVC
SNERST	EQ	4			:UNABLE TO CONTINUE BECAUSE OF TERMINAL
					:STATUS
SNERLU	EQ	5			:UNABLE TO CONTINUE BECAUSE OF SNA
					:INTERFACE STATUS
SNERNT	EQ	6			:RECEIVED NON-EXECUTABLE FOR GIVEN
					:LU_SVC STATUS COMMAND

:*************************************************************
:	DATA MESSAGE TYPES IN SNA-> NTW DATA QUEUE
:*************************************************************

SNETEM	EQ	01			:END-TO-END DATA MESSAGE (SNA,DSP)
SNINTM	EQ	02			:INTERNALLY GENERATED DATA MESSAGE
SNDTMX	EQ	02			:MAXIMUM DATA TYPE CURRENTLY DEFINED

:	SUBCOMMANDS FOR DATA MESSAGES (VALID BOTH FOR
:	TRANSPARENT AND LOCAL MODE)
:	----------------------------------------------------
:	BIT 6,7 - SEGMENTING INFORMATION (INVERSE CODE COMPARED
:		TO SNA,00 MEANS ONE-SEGMENT PIU)
:
:	BIT 4,5 - CHAINING INDICATOR (INVERSE CODING)
:		(EVERY CHAIN CAN CONTAIN ONLY ONE 3270 COMMAND OR AID - EXCEPT
:		 FOR STRUCTURED FIELDS - AND IT MUST BE THE FIRST RU BYTE OF
:		 CHAIN)
:		00 - SINGLE-ELEMENT CHAIN
:		01 - 1ST BUT NOT LAST ELEMENT OF CHAIN
:		10 - LAST BUT NOT 1ST ELEMENT OF CHAIN
:		11 - INTERMEDIATE ELEMENT OF CHAIN
:	BIT 3	- CANCEL (DSP MODE ONLY).
:		(ONLY THE CURRENT CHAIN CAN BE CANCELLED).
:	BIT 2	- END-TO-END ACK (DSP MODE ONLY).
:
:	BIT 0   - CHANGE DIRECTION INDICATOR
:		THIS INDICATOR CAN BE SET ONLY AT THE LAST ELEMENT OF CHAIN.

SNDTFS	EQ	01			:FIRST BUT NOT THE LAST SEGMENT
SNDTLS	EQ	02			:LAST BUT NOT THE FIRST SEGMENT
					:CHAINING AND CHANGE DIRECTION
					:INFORMATION IS NOT CURRENTLY
					:IMPLEMENTED EXCEPT FOR DSP MODE.
					:IN LOCAL MODE, ONLY SINGLE
					:ELEMENT CHAINS WILL BE PASSED TO
					:LOGON MODULE AS VALID TERMINAL RSPS.
					:THE REST WILL BE REPLACED BY
					:REDISPLAY SCRREN COMMAND.
SNDTIS	EQ	03			:INTERMEDIATE SEGMENT

SNDTFC	EQ	04			:1ST BUT NOT THE LAST ELEMENT OF CHAIN
SNDTIC	EQ	0C			:INTERMEDIATE ELEMENT OF CHAIN
SNDTLC	EQ	08			:LAST BUT NOT THE 1ST ELEMENT OF CHAIN

:	BIT 3 - CANCEL INDICATOR
SNDTCN	EQ	10			:CANCEL CURRENT CHAIN

:	BIT 2 - END-TO-END ACK INDICATOR
SNDTAK	EQ	20			:REQUEST FOR ACK-BIT SET

					:(F00/02/23/87/DB/START) LU_T1
:	BIT 1 - BRACKET TERMINATION NOT ALLOWED INDICATOR
:SNDTEB	EQ	40			:BRACKET TEMINATION IS NOT ALLOWED

:	BIT 1 - MESSAGE OFFSET
SNDOFF	EQ	40			:SEND MESSAGE OFFSET IN BUFFER
					:(F00/02/23/87/DB/END)

:	BIT 0 - CHANGE DIRECTION INDICATOR
SNDTCD	EQ	80			:CHANGE DIRECTION IS REQUIRED

:	QLLC DIALECT SUB COMMAND CODES
:	------------------------------
CDATA	EQ	1			:DATA COMMAND
CSNRM	EQ	2			:SNRM COMMAND
CUA	EQ	3			:UA RESPONSE
CDISC	EQ	4			:DISC COMMAND
CRD	EQ	CDISC			:RD RESPONSE
CDM	EQ	5			:DM RESPONSE
CRIM	EQ	6			:RIM RESPONSE
CSIM	EQ	CRIM			:SIM COMMAND
CXID	EQ	7			:XID COMMAND/RESPONSE
CTEST	EQ	8			:TEST COMMAND/RESPONSE
CFRMR	EQ	9			:FRMR RESPONE
CSTATE	EQ	0A			:STATUS COMMAND/REPONSE

:	RESPONSE ISSUED FROM DLC LAYER TO NIF LAYER
:	--------------------------------------------
CLRRSP	EQ	0			:CONTROL<CLEAR>
TRMRSP	EQ	1			:CONTROL<TERMINATE>
DISRSP	EQ	2			:CONTROL<DISCONNECT>
ERRRSP	EQ	3			:CONTROL<ERROR>
INIRSP	EQ	4			:CONTROL<INIT>

:	COMMANDS ISSUED FROM NIF LAYER TO DLC LAYER
:	--------------------------------------------
CLRCD	EQ	0			:CONTROL<CLEAR>
TRMCD	EQ	1			:CONTROL<TERMINATE>
INITCD	EQ	2			:CONTROL<INIT>

:	STATUS REPORTED FROM FOREGROUND TO BACKGROUND
:	---------------------------------------------

:	FOR PRIMARY
:	-----------
UPCLRD	EQ	0			:PRIMARY CLEARP EXECUTED
UPTRMD	EQ	1			:PRIMARY TERMP EXECUTED
UPDISC	EQ	2			:PRIMARY ENTER NDM STATE
UPXMT	EQ	3			:PRIMARY XMT ERROR
UPNEF	EQ	4			:PRIMARY RCV'ED NEF FRAME
UPINOP	EQ	5			:PRIMARY INOPERABLE
UPBUSY	EQ	6			:PRIMARY DETECTED REMOTE BUSY

:	FOR SECONADY
:	-------------
USCLRD	EQ	0			:SECONDARY CLEARP EXECUTED
USTRMD	EQ	1			:SECONDARY TERMP EXECUTED
USDISC	EQ	2			:SECONDARY ENTER NDM STATE
USXMT	EQ	3			:SECONDARY XMT ERROR
USFRMR	EQ	4			:SECONDARY SENT FRMR TO NEF
USINOP	EQ	5			:SECONDARY INOPERABLE (5/10/85/CHS)

:	DEFINE LOG CODES FOR LOG MEESAGES ENTERED INTO LOG TABLE
:	OR FOR LOG DATA REPORTED TO SUPERSIVOR
:	-----------------------------------------------------
:	HW2low	= LOG CODE
:	HW3	= LINE, STATION
:		  LINE, 0FF (FOR A WHOLE LINE)
:		  0FFFF (FOR A WHOLE SLOT)
:	HW4	= NOT USED
LGSINS	EQ	0			:SLOT INITIAL START
LGREST	EQ	1			:SLOT RESTART
LGCKBT	EQ	2			:CIRCUIT BUILT
LGCKZP	EQ	3			:CIRCUIT ZAPPED
LGSHUT	EQ	4			:CKT/STN OR LINE SHUT
LGRSHT	EQ	5			:CKT/STN OR LINE REMOVE FROM SHUT
LGLNUP	EQ	6			:LINE UP
LGLNDN	EQ	7			:LINE DOWN
LGSULF	EQ	8			:STN/CKT OR LINE SHUT DUE TO EXCESSIVE
					:LOGON RETRY
LGLGFL	EQ	9			:STN/CKT OR LINE LOGON FAILED
LGINOP	EQ	0A			:STN/CKT OR LINE INOPERABLE
LGBLAK	EQ	0B			:CIRCUIT RECEIVE BLACK BALL
LGDOVF	EQ	0C			:INPUT DATA PACKET OVERFLOW

:	LOGON STATE DEFINITION
:	----------------------
L.IDLE	EQ	0			:00 - IDLE
L.NSMN	EQ	L.IDLE+1		:01 - WAITING FOR NS SELECTION
L.MENU	EQ	L.NSMN+1		:02 - WAITING FOR MENU SELECTION
L.LSTR	EQ	L.MENU+1		:03 - WAITING FOR LOGON STRING
L.PDNL	EQ	L.LSTR+1		:04 - WAITING FOR PSEUDO-NEEDLE
L.USER	EQ	L.PDNL+1		:05 - WAITING FOR USERNAME
L.USNT	EQ	L.USER+1		:06 - USERNAME SENT
L.PSWD	EQ	L.USNT+1		:07 - WAITING FOR PASSWORD
L.PSNT	EQ	L.PSWD+1		:08 - PASSWORD SENT
L.LGOK	EQ	L.PSNT+1		:09 - LOGON STRING SENT
L.DIAL	EQ	L.LGOK+1		:0A - WAITING FOR DIALECTS
L.TIIX	EQ	L.DIAL+1		:0B - RECEIVED TIIX
L.LDSP	EQ	L.TIIX+1		:0C - WAITING FOR LOGON DSP
L.DASC	EQ	L.LDSP+1		:0D - WAITING FOR LOGON DSP & ASCII DATA
L.TRKL	EQ	L.DASC+1		:0E - WAITING FOR TURKEY LEVEL
L.CACP	EQ	L.TRKL+1		:0F - WAITING FOR CALL ACCEPT
L.CENA	EQ	L.CACP+1		:10 - WAITING FOR CIRCUIT ENABLE
L.ERCK	EQ	L.CENA+1		:11 - DSP ERROR WAIT FOR ANY KEY
L.GTWY	EQ	L.ERCK+1		:12 - WAITING FOR GATEWAY INTERLINK MSG
					:(F00/02/05/87/DB/START)
					: FOR CRM 4 IMPLEMENTATION
L.WAIT	EQ	L.GTWY+1		:13 - WAITING FOR CRM 4
L.BUSY	EQ	L.WAIT+1		:14 - LU IS ASSOCIATED WITH ANOTHER LU
					:(F00/02/05/87/DB/END)

L.DRSP	EQ	20			:20 - WAITING FOR SELECTED DIALECT
L.TURK	EQ	L.DRSP+1		:21 - HOST WAITING FOR TURKEY LEVEL
L.CDAD	EQ	L.TURK+1		:22 - HOST WAITING FOR CALLED ADDRESS
L.CNAD	EQ	L.CDAD+1		:23 - HOST WAITING FOR CALLING ADDRESS
L.FACL	EQ	L.CNAD+1		:24 - HOST WAITING FOR FACILITY DATA
L.CUDA	EQ	L.FACL+1		:25 - HOST WAITING FOR CALL USER DATA
L.STAT	EQ	L.CUDA+1		:26 - HOST WAITING FOR 1ST STATUS
L.PJCD	EQ	L.STAT+1		:27 - HOST WAITING FOR PROJECT CODE

L.NATV	EQ	30			:30 - NATIVE MODE
L.BDSP	EQ	31			:31 - BSC/DSP MODE
L.ASCI	EQ	32			:32 - ASCII MODE

:	CIRCUIT MODE
:	------------
D.STOR	EQ	0			:BIT 0 = STORED LOGON
D.GATE	EQ	1			:BIT 1 = GATWAY LOGON
D.LERR	EQ	2			:BIT 2 = GET LOGON HOST ERROR
D.ACTV	EQ	3			:BIT 3 = CIRCUIT UP
D.PVC	EQ	4			:BIT 4 = PVC LOGON
D.INLK	EQ	5			:BIT 5 = WAIT FOR INTERLINK MESSAGE
D.ASCD	EQ	6			:BIT 6 = ASCII DATA
D.BDSP	EQ	7			:BIT 7 = BSC/DSP

:	DEVICE CONTROL BLOCKS
:	----------------------
OLDORG	EQ	.			:PRESERVE THE LOCATION COUNTER
	ORG	0
DCBIPR	HS	1			:ISIS 'RING' PORT NUMBER
DCBUTY	BS	1			:USER TYPE (MONITOR, SNA)
DCBNTY	BS	1			:NETWORK SERVICE TYPE (STORED, MANUAL)
DCBDIA	BS	1			:DIALECT
DCBUSR	BS	0D			:USERNAME
	BND	2
DCBMOD	BS	1			:DCB CIRCUIT MODE
DCBSTA	BS	1			:DCB CIRCUIT STATE
DCBZAP	BS	1			:CIRCUIT ZAP REASON
DCBSCC	BS	1			:SCC CODE
DCBSYS	BS	1			:VENDOR (IBM, FUJITSU, HITACHI, ETC.)
DCBFST	BS	1			:THIS DEVICE FORMAT, SIZE & TYPE
DCBDIF	BS	1			:THIS DEVICE'S ATTRIBUTES
DCBAPI	BS	1			:THIS DEVICE'S APPL. ID
DCBLIN	BS	1			:THIS DEVICE'S LINE #
DCBCUA	BS	1			:THIS DEVICE'S CU ADDR
DCBLUA	BS	1			:THIS DEVICE'S LU ADDR
DCBCRM	BS	1			:THIS DEVICE'S CRM
DCBRFS	BS	1			:REMOTE DEVICE'S FORMAT, SIZE & TYPE
DCBRIF	BS	1			:REMOTE DEVICE'S ATTRIBUTES
DCBRAP	BS	1			:REMOTE DEVICE'S APPL ID
DCBRLN	BS	1			:REMOTE DEVICE'S LINE #
DCBRCU	BS	1			:REMOTE DEVICE'S CU ADDR
DCBRLU	BS	1			:REMOTE DEVICE'S LU ADDR
DCBRSY	BS	1			:REQUESTED VENDOR SYSTEM
:DCBCRD	BS	5			:CRM 4 ADDITIONAL INFOR
	BND	2
DCBCRD	HS	1			:CRM4 ADDITIONAL INFO. (F00/03/09/87/DB)
DCBADR	HS	1			:ADDR. FOR CRM4 ADDI (F02/10/02/87/DB
DCBCDA	BS	8			:CALLED ADDRESS
DCBCNA	BS	8			:CALLING ADDRESS
DCBRHT	HS	1			:REMOTE HOST NUMBER
DCBHST	HS	1			:INTERFACE HOST TABLE POINTER
DCBAHS	HS	1			:INTERFACE HOST NUMBER
DCBLNC	HS	1			:LNCTAB
DCBPUC	HS	1			:PUCTAB
DCBLUC	HS	1			:OWN LUCTAB
DCBALU	HS	1			:ASSOCIATED LUCTAB
DCBRUL	HS	1			:MUX RU LENGTH FOR SECONDARY
DCBRUS	HS	1			:CURRENT RU LENGTH FOR SECONDARY
DCBIAT	HS	1			:BSC/DSP INACTIVE TIMEOUT HANDLER
DCBIA1	HS	1			:BSC/DSP INACTIVE TIMEOUT VALUE
DCBLAT	HS	1			:BSC/DSP LOGOFF TIMEOUT HANDLER
DCBLA1	HS	1			:BSC/DSP LOGOFF TIMEOUT VALUE
DCBOCT	BS	1			:CONVERT SNA TO BSC/DSP TRAILER STATE
DCBICT	BS	1			:BSC/DSP HEADER CONTROL BYTE
DCBDSH	BS	1			:CONVERT BSC/DSP TO SNA HEADER STATE
DCBDST	BS	1			:BSC/DSP WORKING AND CONTROL BYTE
DCBTSG	BS	1			:BSC/DSP TRAILER SYSGEN SELECTION
	IF	FWBBF
	BND	4
DCBIBH	WS	1			:BUFFERLET HEAD POINTER
DCBIBA	WS	1			:BUFFERLET BASE ADDRESS
	ELSE
	BND	2
DCBIBH	HS	1			:BUFFERLET HEAD POINTER
DCBIBA	HS	1			:BUFFERLET BASE ADDRESS
	EI
DCBIBX	HS	1			:BUFFERLET CURRENT OFFSET
DCBICC	HS	1			:INPUT CHARACTER COUNT
DCBISQ	HS	1			:INPUT MSG SEQ NUMBER
DCBIPL	HS	1			:DATA PACKET DATA LENGTH
DCBDFG	BS	1			:DATA PACKET FLAG
DCBTMP	BS	1			:DCB TEMPORARY STORAGE
	IF	FWBBF
DCBOBA	WS	1			:OUTPUT BUFFERLET BASE ADDRESS
	ELSE
DCBOBA	HS	1			:OUTPUT BUFFERLET BASE ADDRESS
	EI
DCBOBX	HS	1			:OUTPUT BUFFERLET CURRENT OFFSET
DCBOCC	HS	1			:OUTPUT CHARACTER COUNT
DCBOSQ	HS	1			:OUTPUT MSG SEQ NUMBER
	IF	FWBBF
DCBLBA	WS	1			:LOGON STRING BB BASE ADDRESS
	ELSE
DCBLBA	HS	1			:LOGON STRING BB BASE ADDRESS
	EI
DCBLBX	HS	1			:LOGON STRING BB INDEX
DCBLLV	BS	1			:LOGON STRING LEVEL
DCBLLS	BS	1			:LAST LOGON STRING LEVEL
DCBLGT	HS	1			:LOGON DATA GET PROC.
DCBOQU	HS	1			:OUTPUT DATA Q
DCBTMO	HS	1			:TIMOUT VALUE DURING LOGIN
DCBATO	HS	1			:TIMOUT ACTIVATION ROUTINE 
DCBASC	HS	1			:ASCII INPUT PROCESSING ROUTINE
DCBLIX	HS	1			:IIX LOCAL DIALECT PROC TABLE
DCBGIX	HS	1			:IIX GLOBAL PROC TABLE
DCBDSP	HS	1			:DSP MSG PROC TABLE
DCBINP	HS	1			:INPUT PROC ENTRY POINT
DCBOUT	HS	1			:OUTPUT PROC ENTRY POINT
DCBRET	WS	1			:FRNTND R5 SAVE AREA (HW ONLY)
ACTIVD	HS	1			:DATA ACTIVATION ROUTINE
ACTIVT	HS	1			:TIMEOUT ACTIVATION ROUTINE
ACTIVC	HS	1			:CONTROL MESSAGE ACTIVATION TABLE
ACTIVO	HS	1			:OUTPUT ACTIVATION ROUTINE
:DCBIA1	WS	1			:INACTIVITY TIMER(3.f01/07/14/87/db)
:
	IF	VTISUP!VHRSUP
DCBSGL	HS	1			:MAX SNA SEGM LENGTH
DCBSGS	HS	1			:CURRENT SNA SEGM LENGTH
	EI
DCBPID	HS	1			:PID OF THE OTHER END OF INTERFACE
DCBVER	HS	1			:VERSION # OF THE OTHER END OF INTERFACE
DCBCHN	HS	1			:DCB CHAIN POINTER
	BND	10			:MAKE IT FULLWORD BOUNDARY
DCBLEN	EQ	.

:	EVENT LOG TABLE
:	----------------
	ORG	0
ELGDA2	BS	2			:DATA2 (HALFWORD)
ELGTYP	BS	1			:REPORT TYPE (BYTE)
ELGDA1	BS	1			:DATA1 (BYTE)
ELGPID	BS	1			:PRODUCT ID
ELGDA3	BS	1			:DATA BYTE
ELGGMT	BS	4			:GMT
ELGLEN	EQ	.

:	HOST TABLE FOR MULTIPLE HOST SUPPORT
:	------------------------------------
	ORG	0
HSTNUM	HS	1			:HOST NUMBER
HSTRID	BS	1			:HOST REL #
HSTUSR	BS	1			:HOST USER TYPE (SEE USER TYPES ABOVE)
HSTIIX	BS	1			:HOST IIX IQ
HSTSTS	BS	1			:HOST STATUS
	BND	2
HSTMPT	HS	1			:HOST MAXMUM PORTS
HSTSPT	HS	1			:HOST PORTS SHUT
HSTPRT	HS	1			:NUMBER OF DCB CONNECT TO THIS HOST
HSTACT	HS	1			:NUMBER OF ACTIVE PORTS FOR HOST
HSTFPT	HS	1			:HOST FREE PORTS
HCOST	HS	1			:CURRENT HOST COST
	BND	10			:MAKE IT FULLWORD BOUNDARY
HSTLEN	EQ	.

:	LINE CONTROL BLOCK
:	------------------------
	ORG	0
LNHOST	HS	1			:THIS LINE'S HOST NUMBER
LNRHST	BS	1			:RELATIVE HOST THIS LINE BELONG
LNMXPU	BS	1			:MAXIMUM PU'S SUPPORTED
LNSHPU	BS	1			:CURRENT # OF PU'S SHUT
LNACPU	BS	1			:CURRENT # OF PU'S ACTIVE
LNASLK	BS	1			:ACCESS LINK (HD,FD,PTP,MP)
:LNSNA	BS	1			:INTERFACE LEVEL (SNA OR SDLC)
LNCNFG	BS	1			:(F3.02/8/20/87/ACH)
LN.DLC	EQ	01			:(3.F02/8/24/87/ACH)SNA/SDLC ITF
LN.SRU	EQ	02			:(3.F02/8/24/87/ACH)SINGLE RU OR NOT
LN.CLR	EQ	04			:(3.F02/8/24/87/ACH)CLEAR RSP

LNPUTY	BS	1			:NODE PU TYPE (PU 1, 2, 4, ETC)
LNMXWD	BS	1			:MAX. WINDOW SIZE
:LNXBTH	BS	1			:BB XMT THRESHOLD FOR THIS LINK
LNSTAN	BS	1			:LINE STATE IN NUMBER
	BND	2
LNSFLG	BS	1			:LINE STATUS FLAGS
	BND	2
LNMXFM	HS	1			:MAX. FRAME SIZE
LNRBQA	HS	1			:BB RCV QUOTA FOR THIS LINK
LNXBQA	HS	1			:BB XMT QUOTA FOR THIS LINK
LNRBUS	HS	1			:BB RCV QUOTA USAGE
LNXBUS	HS	1			:BB XMT QUOTA USAGE
LNPUTB	HS	1			:1ST PU CONTROL TABLE ON THIS LINK
LNSTAT	HS	1			:LINE STATE
LNIACT	HS	1			:LINE LINK INACTIVITY INTERVAL
LNDSCT	HS	1			:LINE LINK DISC (DTR DROP) DURATION
	BND	4
LNTIME	WS	1			:LINE TIMER
LNITME	WS	1			:LINE LINK INAVTIVITY TIMER
	BND	10			:MAKE IT QUADWORD BOUNDARY
LNCLEN	EQ	.			:LINE CONTROL BLOCK LENGTH

:	PU CONTROL BLOCK DEFINITION
:	---------------------------
:	PU (I.E. NODE) INFORMATION SHARED BY SNA, NWK, AND DLC.
	ORG	0
PUCT.N	BS	1			:THIS PU'S # REL TO ALL PU'S
PUPLAD	BS	1			:THIS PU'S POLLING ADDRESS
PULNKN	BS	1			:THIS PU'S LINK #
PUCRID	BS	1			:THIS PU'S # REL TO PU'S ON SAME LINK
PUMLUN	BS	1			:MAX. LU'S ON THIS PU
PUMLID	BS	1			:MAX. LU'S ON THIS PU (BASED ON ID)
PUALUN	BS	1			:CURRENT ACTIVE LU'S ON THIS PU
PULSTA	BS	1			:THIS PU'S LINK STATE NUMBER
	BND	2
PUCLNC	HS	1			:THIS PU'S LNCTAB ADDR
PUCLSC	HS	1			:THIS PU'S LSC POINTER
PUCLUC	HS	1			:THIS PU'S 1ST LU TABLE POINTER
PULSNM	HS	1			:THIS PU'S STATE NAME (LINK)
PUDLCG	HS	1			:NWK TO DLC Q GET PTR
PUDLCR	HS	1			:NWK TO DLC Q RELEASE PTR
PUDLCP	HS	1			:NWK TO DLC Q PUT PTR
PUNWCG	HS	1			:DLC TO NWK Q GET PTR
PUNWCR	HS	1			:DLC TO NWK Q RELEASE PTR
PUNWCP	HS	1			:DLC TO NWK Q PUT PTR
PUIFNC	HS	1			:DLC->NWK PROC
PUCTIM	HS	1			:PU TIMER FOR IFNC
PUCATO	HS	1			:TIMEOUT ACTIVATION PROC. FOR IFNC
PURBQA	HS	1			:BB RCV QUOTA FOR THIS PU
PUXBQA	HS	1			:BB XMT QUOTA FOR THIS PU
PURBUS	HS	1			:BB RCV USAGE FOR THIS PU
PUXBUS	HS	1			:BB XMT USAGE FOR THIS PU
PUCLAB	BS	1			:PU LABEL
	BND	10			:MAKE IT QUADWORD BOUNDARY
PUCLEN	EQ	.			:LENGTH OF THIS ENTRY

:	LU CONTROL BLOCK TABLE
:	-----------------------
:	ACCESSED PRIMARILY BY SNA.SVC AND NWK.SCAN
	ORG	0
LUCT.D	HS	1			:THIS LU'S ID REL TO ALL LU'S
LUCT.N	HS	1			:THIS LU'S # REL TO ALL LU'S
LUCRID	BS	1			:THIS LU'S # REL TO LU'S ON THIS PU
LUCADR	BS	1			:THIS LU'S ADDR
LUPRIL	BS	1			:THIS LU'S LOCAL SESSION OAF
LUCTYP	BS	1			:THIS LUCTAB TYPE =PU.LUC/LU.LUC
LUCMOD	BS	1			:LU MODE (0=HOST,1=NSM,2=PVC)
LUCSYS	BS	1			:VENDOR SYSTEM (IBM, FUJITSU, HITACHI, ETC.)
LUCFST	BS	1			:THIS LU (DEVICE) FORMAT,SIZE & TYPE
LUCDIF	BS	1			:THIS LU (DEVICE) & INFORM.
LUCPUN	BS	1			:THIS LU'S PU #
LUNSTA	BS	1			:THIS LU'S NETWORK CIRCUIT STATE
LUSSTA	BS	1			:THIS LU'S SNA SSCP-LU STATE
LULSTA	BS	1			:THIS LU'S SNA PLU-SLU STATE
LULUST	BS	1			:THIS LU'S LU-SVC STATE
LULUWK	BS	1			:THIS LU'S LU-SVC WORK STORAGE
LULUW1	BS	1			:THIS LU'S LU-SVC WORK STORAGE
LULUW2	BS	1			:THIS LU'S LU-SVC WORK STORAGE
LULUW3	BS	1			:THIS LU'S LU-SVC WORK STORAGE(5/15/85/CHS)
LUPSTA	BS	1			:THIS LU'S ACT/NON-ACT STATE
LUCSCC	BS	1			:THIS LU'S SCC WORKING AREA
	BND	2
LUPRIA	HS	1			:LU PRI ADDR
LUSECA	HS	1			:LU SEC ADDR
LUSQID	HS	1			:PLU-SLU SQ ID
LUSQNP	HS	1			:SSCP-LU SQ ID
LUCDCB	HS	1			:THIS LU'S OWN DCB
LUADCB	HS	1			:THIS LU'S ASSOCAITED DCB
	IF	FWSCB
LULSCB	WS	1			:THIS LU'S PLU-SLU SCB
LUOSES	WS	1			:THIS LU'S OLD PLU-SLU SCB
LUSSCB	WS	1			:THIS LU'S SSCP-SLU SCB
	ELSE
LULSCB	HS	1			:THIS LU'S PLU-SLU SCB
LUOSES	HS	1			:THIS LU'S OLD PLU-SLU SCB
LUSSCB	HS	1			:THIS LU'S SSCP-SLU SCB
	EI
LUCLNC	HS	1			:THIS LU'S LNCTAB
LUCPUC	HS	1			:THIS LU'S PUCTAB
LUBNDP	HS	1			:THIS LU'S CANNED BIND RU
LUAPLP	HS	1			:THIS LU'S CANNED ACTIVATE RU
LUDPLP	HS	1			:THIS LU'S CANNED DE-ACTIVATE RU
LUODPR	HS	1			:SNA->NWKC DATA-Q PROC ROUTINE
LUOCPR	HS	1			:SNA->NWKC CMD-Q PROC ROUTINE
LUNWCG	HS	1			:SNA TO NWK CMD Q GET PTR
LUNWCR	HS	1			:SNA TO NWK CMD Q RELEASE PTR
LUNWCP	HS	1			:SNA TO NWK CMD Q PUT PTR
LUNWDG	HS	1			:SNA TO NWK DATA Q GET PTR
LUNWDR	HS	1			:SNA TO NWK DATA Q RELEASE PTR
LUNWDP	HS	1			:SNA TO NWK DATA Q PUT PTR
LUSNCG	HS	1			:NWK TO SNA CMD Q GET PTR
LUSNCR	HS	1			:NWK TO SNA CMD Q RELEASE PTR
LUSNCP	HS	1			:NWK TO SNA CMD Q PUT PTR
LUSNDG	HS	1			:NWK TO SNA DATA Q GET PTR
LUSNDR	HS	1			:NWK TO SNA DATA Q RELEASE PTR
LUSNDP	HS	1			:NWK TO SNA DATA Q PUT PTR
LUCTIM	HS	1			:TIMER
LUCATO	HS	1			:TIMEOUT PROC.
LUIATO	HS	1			:INACTIVITY TIME DURATION
LULATO	HS	1			:APPLICATION LOGOFF
	IF	FWBBF
LUCIBH	WS	1			:LOCAL BB HEAD PTR
	ELSE
LUCIBH	HS	1			:LOCAL BB HEAD PTR
	EI
LUBPSG	BS	1			:FOR DSP TRAILER SGN INF.
LUCLAB	BS	1			:LU LABEL
LUCSCN	BS	1			:SCREEN STATUS (FOR CMT SYS/REQ KEY)
	IF	VHRSUP!VTISUP
LUCVHR	BS	1			:VHR STATE BYTE
LUCVTI	EQ	LUCVHR			:OR VTI STATE BYTE
	EI
	BND	10			:MAKE IT AT QUAD WORD BOUNDARY
LUCLEN	EQ	.			:LENGTH OF THIS TABLE

:	LINK CONTROL BLOCKS    
:	-------------------
	ORG	0
LCBALK	BS	1			:ACCESS LINK
LCBP.S	BS	1			:PRIMARY OR SECONDARY
LCBRTY	BS	1			:LINE RETRY COUNT
LCBMWD	BS	1			:LINE MAXIMUM FRAMES WINDOW
LCBMFM	HS	1			:MAXIMUM FRAME SIZE ALLOWED
LCBS.R	BS	1			:LINE RECEIVING STATE
LCBS.X	BS	1			:LINE TRANSMIT STATE
LCBXRC	BS	1			:TRANSMIT RETURN CODE
LCBCTL	BS	1			:RCV'ED C-FIELD
	BND	2
LCBC.R	HS	1			:CURRENT RECEIVING PU'S LSC ADDR
LCBC.X	HS	1			:CURRENT TRANSMITTING PU'S LSC ADDR
LCBRCN	HS	1			:SIO RCV FRAME LENGTH
	BND	4
	IF	FWBBF
LCBRHP	WS	1			:SIO RCV BB HEAD
	ELSE
LCBRHP	HS	1			:SIO RCV BB HEAD
	EI
LCBN.R	WS	1			:TOTAL RECEIVE FRAMES #
LCBN.J	WS	1			:LINE TOTAL REJ CNT
LCBN.X	WS	1			:TOTAL XMT FRAMES #
LCBN.T	HS	1			:TOTAL LINE XMT TIMEOUT
LCBN.N	HS	1			:TOTAL XMT NOROOM ERROR
LCBN.C	HS	1			:TOTAL XMT CTS ERROR
LCBN.H	HS	1			:TOTAL XMT SIO RR STATUS ERROR
LDARCV	WS	1			:DATA PRESENT DLC->FG DATA Q
LDAXMT	WS	1			:DATA PRESENT FG->DLC DATA Q
LCBRCV	WS	1			:IN RCV STATE (FOR DISPATCHER)
LCBXMT	WS	1			:IN XMT STATE (FOR DISPATCHER)
LCBPRO	WS	1			:WORKING BIT ARRAY FOR DISPATCHER
LCBXPF	WS	1			:STATION IN XPF STATE
LCBXTM	WS	1			:SIO RCV-XMT TURN AROUND TIMER (HDX)
LCBBSY	WS	1			:STATION BUSY SET BY B.G.
LCBNOP	WS	1			:STATION INOPERABLE
LDACMD	WS	1			:DATA PRESENT FOR DLC->FG CMD Q
	BND	10			:MAKE IT QUADWORD BOUNDARY
LCBLEN	EQ	.			:LENGTH OF LCB

:	LINK STATION CONTROL BLOCK DEFINITION
:	-------------------------------------
	ORG	0
LSCSAD	BS	1			:STATION ADDRESS ( A FIELD )
LSCT.N	BS	1			:STATION REL. # TO TOTAL
LSCRID	BS	1			:STATION RELATIVE #
LSCCXC	BS	1			:STATION CURRENT XMT OP CODE
LSCVRX	BS	1			:V(R) SAVE CELL
LSCNPX	BS	1			:NP FOR LAST V(S) WITH P=1
LSCVSX	BS	1			:V(S) SAVE CELL
LSCNRR	BS	1			:NR LOCATION
LSCNSR	BS	1			:N(S) STORAGE AREA
LSCVSU	BS	1			:SEQUENCE # FOR LOWEST UNACK I COMMAND
LSCRXC	BS	1			:RETRANSMISSIONB COUNTER
LSCSRC	BS	1			:RETRY COUNT
LSCPAU	BS	1			:RETRY PAUSE BETWEEN SEQUENCE
LSCSEQ	BS	1			:RETRY SEQUENCE
LSCRCB	BS	1			:INDICATES RECEIVE FRAME BUSY <RNR,F=1>
LSCXST	BS	1			:XMT STATUS (RETURN CODE)
LSCRST	BS	1			:RCV STATUS (RETURN CODE)
LSCCTL	BS	1			:RCV'ED C-FIELD
	BND	2			:HALF-WORD BOUNDARY
LSCBIT	HS	1			:BIT FLAGS
LSCIFC	HS	1			:INFORMATION FRAME COUNTER
LSCN.R	HS	1			:RCV FRAMES #
LSCN.X	HS	1			:XMT FRAMES #
SGPSIO	HS	1			:SIO RCV GET PTR (RCV->PTP)
SRPSIO	HS	1			:SIO RCV REL PTR (RCV->PTP)
SPPSIO	HS	1			:SIO RCV PUT PTR (RCV->PTP)
SGPRCV	HS	1			:RCV GET PTR (FG->DLC)
SRPRCV	HS	1			:RCV RELEASE PTR (FG->DLC)
SPPRCV	HS	1			:RCV PUT PTR (FG->DLC)
SGPXMT	HS	1			:XMT GET PTR (DLC->FG)
SRPXMT	HS	1			:XMT RELEASE PTR (DLC->FG)
SPPXMT	HS	1			:XMT PUT PTR (DLC->FG)
SGPCMD	HS	1			:CMD GET PTR (DLC->FG)
SRPCMD	HS	1			:CMD RELEASE PTR (DLC->FG)
SPPCMD	HS	1			:CMD PUT PTR (DLC->FG)
LSCRCN	HS	1			:RECEIVE BYTE COUNT
LSCXCN	HS	1			:XMT BYTE COUNT
LSCRHL	HS	1			:RCV PROTOCOL STATE
LSCXHL	HS	1			:XMT PROTOCOL STATE
LSCCLR	HS	1			:CLEARP CMD PROCESSING ROUTINE
LSCTRM	HS	1			:TERMP CMD PROCESSING ROUTINE
	BND	4			:MAKE FULLWORD BOUNDARY
LSCRT1	WS	1			:STATION RECEIVE RESPONSE TIMER (T1)
LSCXTT	WS	1			:STATION O.K. TO XMT NEXT FRAME TIMER
	IF	FWBBF
LSCRHP	WS	1			:RECEIVE BUFFER CHAIN ADDRESS
LSCXHP	WS	1			:XMT BUFFER CHAIN ADDRESS
	ELSE
LSCRHP	HS	1			:RECEIVE BUFFER CHAIN ADDRESS
LSCXHP	HS	1			:XMT BUFFER CHAIN ADDRESS
	EI	(FWBBF)	
LSCPUC	HS	1			:THIS LSC'S PUC
	BND	10			:MAKE QUAD WORD BOUNDARY
LSCLEN	EQ	.

	ORG	OLDORG			:RESTORE LOACTION COUNTER

	EM
	SUBTTL	(SNA) SYSTEM GENERATED CANNED STRINGS
:CAND00.Z00


:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:
:	THIS FILE ALLOCATES/CREATES THE ACTPU, DACTPU, BIND, UNBIND 
:	SNA RQ/RSP RU STRINGS.
:	THE PVC LOGON INFORMATION/DATA ARE ALSO ALLOCATED/CREATED.
:	THE PRESET LOGON INFORMATION/DATA ARE ALSO INCLUDED IN HERE.
:	THE NETWORK SERVICE MODE STUFF IS ALSO GENERATED.
:
:	ALL THE ABOVE INFORMATION/DATA ARE DERIVED FROM THE TYMFILE
:	CORRESPODING SYSTEM GENERATION MACRO.
:
:	NOTE: DUE TO THE LIMITATION OF THE NAD'S "REPEAT" FUNCTION,
:	THERE ARE NO ROOMS FOR THE COMMENTS AFTER EACH STATEMENT.
:	THEREFORE, IF YOU HAVE TROUBLE UNDESTANDING THE CODES, BLAME
:	NAD INSTEAD.
:

	RA	0			:RAIX HEXADECIMAL

	MO	.,MAIN
	LO	MAIN

	SUBTTL	(SNA) PVC/PRESET LOGON DATA TABLE DEFINITION


:	PVDTBL:	PVC LOGON DATA TABLE DEFINITION
:	------
OLDORG	EQ	.
	ORG	0
PVDBAS	HS	0			:BASE
PVDSTR	HS	1			:PVC LOGON STRING PTR
PVDLVL	BS	1			:PVC LOGON STRINGS LEVEL
PVDDLN	BS	1			:PVC LOGON DESTI. LINE
PVDDPU	BS	1			:PVC LOGON DESTI. PU ADDR
PVDDLU	BS	1			:PVC LOGON DESTI. LU ADDR
PVDDTY	BS	1			:PVC LOGON DESTI. LU TYPE
PVDDCO	BS	1			:PVC LOGON DESTI. LU COLOR
PVDDSZ	BS	1			:PVC LOGON DESTI. LU SIZE
PVDCRM	BS	1			:PVC LOGON CRM#
	BND	10
PVDLEN	EQ	.
	ORG	OLDORG

:	PSTTBL:	PRESET LOGON DATA TABLE DEFINITION
:	------
OLDORG	EQ	.
	ORG	0
PSTBAS	HS	0			:BASE
PSTENT	BS	1			:PRESET LOGON ENTRY
PSTMOD	BS	1			:PRESET LOGON MODE
PSTAEC	HS	1			:PRESET LOGON PROPT STRINGS CODE
PSTPRM	HS	1			:PRESET LOGON PROPT STRINGS PTR
PSTSTR	HS	1			:PRESET LOGON STRING PTR
PSTLVL	BS	1			:PRESET LOGON STRINGS LEVEL
PSTDLN	BS	1			:PRESET LOGON DESTI. LINE
PSTDPU	BS	1			:PRESET LOGON DESTI. PU ADDR
PSTDLU	BS	1			:PRESET LOGON DESTI. LU ADDR
PSTDTY	BS	1			:PRESET LOGON DESTI. LU TYPE
PSTDCO	BS	1			:PRESET LOGON DESTI. LU COLOR
PSTDSZ	BS	1			:PRESET LOGON DESTI. LU SIZE
PSTCRM	BS	1			:PRESET LOGON CRM#
	BND	10
PSTLEN	EQ	.
	ORG	OLDORG

:	NSMTBL:	NETWORK SERVICE SCREEN DATA TABLE
:	------
OLDORG	EQ	.
	ORG	0
NSMBAS	HS	0			:BASE
NSMHAE	HS	1			:NSM HEADER STRING CODE
NSMHDR	HS	1			:NSM HEADER STRING PTR
NSMKAE	HS	1			:NSM KEYWORK STRING CODE
NSMKWD	HS	1			:NSM KEYWORK STRING PTR
NSMKEY	BS	1			:NSM SERVICE KEY
	BND	2
NSMLEN	EQ	.
	ORG	OLDORG

:	DSSPOT(LINES,PUNS,LUNS,ENTRIE)
:	------------------------
:	TO DISPLAY WHICH LINE,PUN,LUN HAS CONFIGURATION/SYSGEN ERROR
:	ARGS:	LINES	- LINE #
:		PUNS	- PUN #
:		LUNS	- LUN #
:		ENTRIE	- ENTRY #
DSSPOT	MACRO(LINES,PUNS,LUNS,ENTRIE)[
	NOLIST
	REMARK	For Line#:
	NUMBER	$A LINES
	REMARK	 ,PU#:
	NUMBER	$A PUNS
QL	EQ	LUNS -1
	IF	.GT.(QL,-1)
	REMARK	 ,LU#:
	NUMBER	$A LUNS
	EI
QE	EQ	ENTRIE -1
	IF	.GT.(QE,-1)
	REMARK	 ,ENTRY#:
	NUMBER	$A ENTRIE
	EI
	LIST
	]

	SUBTTL	(SNA) CANNED SNA RQ/RSP RU'S


:	CREATE ACTPU STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	IF	\F.ACPU
GACPU	G.ACPU				:GENERAL DEFAULT ACTPU STRINGS.
	EI
QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
	IF	\FQAP|QN||QP|
QAP|QN||QP|	QAPU|QN||QP|
	ELSE
	IF	1-\GACPU
	ERROR(TYPERR,ERR15,No ACTPU Specified Nor Default ACTPU Provided,1)
	ERRNXT(TYPERR,,1)
	DSSPOT(QN,QP)
	ERREND(TYPERR)
	ELSE
QAP|QN||QP|	EQ	GACPU
	EI
	EI
QP	EQ	QP+1
	ER
	EI	(LINK|QN|)
QN	EQ	QN+1
	ER
	LIST
	NOLIST
	IF	\P.ACPU
RACPU	R.ACPU				:GENERAL DEFAULT ACTPU STRINGS.
	EI
QN	EQ	0
	RE	NLINES
	IF	1-LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
	IF	\PAPU|QN||QP|
QAP|QN||QP|	RAPU|QN||QP|
	ELSE
	IF	1-\RACPU
	ERROR(TYPERR,ERR15,No RSP(ACTPU) Specified Nor Default Provided,1)
	ERRNXT(TYPERR,,1)
	DSSPOT(QN,QP)
	ERREND(TYPERR)
	ELSE
QAP|QN||QP|	EQ	RACPU
	EI
	EI
QP	EQ	QP+1
	ER
	EI	(LINK|QN|)
QN	EQ	QN+1
	ER
	LIST


:	CREATE DACTPU STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	IF	\F.DACPU
GDACPU	G.DACPU				:GENERAL DEFAULT DACTPU STRINGS.
	EI
QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
	IF	\FQDP|QN||QP|
QDP|QN||QP|	QDPU|QN||QP|
	ELSE
	IF	1-\GDACPU
	ERROR(TYPERR,ERR15,No DACTPU Specified Nor Default DACTPU Provided,1)
	ERRNXT(TYPERR,,1)
	DSSPOT(QN,QP)
	ERREND(TYPERR)
	ELSE
QDP|QN||QP|	EQ	GDACPU
	EI
	EI
QP	EQ	QP+1
	ER
	EI	(LINK|QN|)
QN	EQ	QN+1
	ER
	LIST

:	CREATE ACTLU STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	IF	\F.ACLU
GACLU	G.ACLU				:GENERAL DEFAULT ACTLU STRINGS.
	EI
N	EQ	0
	RE	NLINES
	IF	LINK|N|
QP	EQ	0
	RE	MSTN|N|
AM|N||QP|0	EQ	QAP|N||QP|
QL	EQ	1
	RE	MLU|N||QP|-1
	IF	\FA|N||QP||QL|
AM|N||QP||QL|	AL|N||QP||QL|
	ELSE
	IF	1-\GACLU
	ERROR(TYPERR,ERR15,No ACTLU Defined Nor Default ACTLU Provided,1)
	ERRNXT(TYPERR,,1)
	DSSPOT(N,QP,QL)
	ERREND(TYPERR)
	ELSE
AM|N||QP||QL|	EQ	GACLU
	EI
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI
N	EQ	N+1
	ER
	LIST
	NOLIST
	IF	\P.ACLU
RACLU	R.ACLU				:GENERAL DEFAULT ACTLU STRINGS.
	EI
N	EQ	0
	RE	NLINES
	IF	1-LINK|N|
QP	EQ	0
	RE	MSTN|N|
AM|N||QP|0	EQ	QAP|N||QP|
QL	EQ	1
	RE	MLU|N||QP|-1
	IF	\PA|N||QP||QL|
AM|N||QP||QL|	RA|N||QP||QL|
	ELSE
	IF	1-\RACLU
	ERROR(TYPERR,ERR15,No RSP(ACTLU) Defined Nor Default Provided,1)
	ERRNXT(TYPERR,,1)
	DSSPOT(N,QP,QL)
	ERREND(TYPERR)
	ELSE
AM|N||QP||QL|	EQ	RACLU
	EI
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI
N	EQ	N+1
	ER
	LIST

:	CREATE DACTLU STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	IF	\F.DACLU
GDACLU	G.DACLU				:GENERAL DEFAULT DACTLU STRINGS.
	EI
QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
DM|QN||QP|0	EQ	QDP|QN||QP|
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	\FD|QN||QP||QL|
DM|QN||QP||QL|	DL|QN||QP||QL|
	ELSE
	IF	1-\GDACLU
	ERROR(TYPERR,ERR15,No DACTLU Defined Nor Default DACTLU Provided,1)
	ERRNXT(TYPERR,,1)
	DSSPOT(QN,QP,QL)
	ERREND(TYPERR)
	ELSE
DM|QN||QP||QL|	EQ	GDACLU
	EI
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI	(LINK|QN|)
QN	EQ	QN+1
	ER
	LIST

:	CREATE BIND STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	IF	\F.BIND
GBIND	G.BIND				:GENERAL DEFAULT BIND STRINGS.
	EI

QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	\FB|QN||QP||QL|
BM|QN||QP||QL|	BN|QN||QP||QL|
	ELSE
	IF	1-\GBIND
	ERROR(TYPERR,ERR15,No BIND Defined Nor Default BIND Provided,1)
	ERRNXT(TYPERR,,1)
	DSSPOT(QN,QP,QL)
	ERREND(TYPERR)
	ELSE
BM|QN||QP||QL|	EQ	GBIND
	EI
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI	(LINK|QN|)
QN	EQ	QN+1
	ER
	LIST

:	CREATE UNBIND STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	IF	\F.UNBIND
GUNBIND	G.UNBIND			:GENERAL DEFAULT UNBIND STRINGS.
	EI

QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	\FU|QN||QP||QL|
UM|QN||QP||QL|	UB|QN||QP||QL|
	ELSE
	IF	1-\GUNBIND
	ERROR(TYPERR,ERR15,Nor UNBIND Defined Nor Default UNBIND Provided,1)
	ERRNXT(TYPERR,,1)
	DSSPOT(QN,QP,QL)
	ERREND(TYPERR)
	ELSE
UM|QN||QP||QL|	EQ	GUNBIND
	EI
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI	(LINK|Q|)
QN	EQ	QN+1
	ER
        LIST

	SUBTTL	(SNA)	PVC LOGON DATA/INFORMATION


:	CREATE PVC LOGON STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	IF	\G.PVLV
QV	EQ	0
	RE	G.PVLV
	IF	\F.PVL|QV|
GPVCL|QV|	G.PVC|QV|		:GENERAL PVC LOGON STRINGS.
	EI
QV	EQ	QV+1
	ER
	EI	(\G.PVLV)

QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	LP|QN||QP||QL|
	IF	\GV|QN||QP||QL|
PG|QN||QP||QL|
QV	EQ	0
	RE	GV|QN||QP||QL|
	G|QN||QP||QL||QV|
QV	EQ	QV+1
	ER
	ELSE
	RE	G.PVLV
PG|QN||QP||QL|	EQ	GPVCL|QV|
QV	EQ	QV+1
	ER
	EI
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI	(LINK|Q|)
QN	EQ	QN+1
	ER
	LIST

:	DEFINE SYMBOL FIRST
:	---------------------
:	THIS IS NECESSARY BECAUSE THE CHARACTERS WITHIN A REPEAT
:	RANGE CAN NOT HAVE MORE THAN 640CHARACTERS.

	NOLIST
N	EQ	0
	RE	NLINES
	IF	LINK|N|
P	EQ	0
	RE	MSTN|N|
L	EQ	1
	RE	MLU|N||P|-1
	IF	\PG|N||P||L|
	IF	1-\GV|N||P||L|
GV|N||P||L|	EQ	G.LGLV
	EI
	IF	1-\PL|N||P||L|
PL|N||P||L|	EQ	G.PVDL
	EI
	IF	1-\PP|N||P||L|
PP|N||P||L|	EQ	G.PVPU
	EI
	IF	1-\PD|N||P||L|
PD|N||P||L|	EQ	G.PVLU
	EI
	IF	1-\PT|N||P||L|
PT|N||P||L|	EQ	G.PVLT
	EI
	IF	1-\PC|N||P||L|
PC|N||P||L|	EQ	G.PVCO
	EI
	IF	1-\PS|N||P||L|
PS|N||P||L|	EQ	G.PVSZ
	EI
	IF	1-\PR|N||P||L|
PR|N||P||L|	EQ	G.CRM
	EI
	EI
L	EQ	L+1
	ER
P	EQ	P+1
	ER
	EI
N	EQ	N+1
	ER
	LIST

:	CREATE PVC LOGON DATA TABLE
:	---------------------------
	SEG	A.CODE

	BND	10

	NOLIST
PVDTBL	HS	0
N	EQ	0
	RE	NLINES
	IF	LINK|N|
P	EQ	0
	RE	MSTN|N|
L	EQ	1
	RE	MLU|N||P|-1
	IF	\PG|N||P||L|
PX|N||P||L|	HC	PG|N||P||L|-PSEG
	BC	GV|N||P||L|
	BC	PL|N||P||L|
	BC	PP|N||P||L|
	BC	PD|N||P||L|
	BC	PT|N||P||L|
	BC	PC|N||P||L|
	BC	PS|N||P||L|
	BC	PR|N||P||L|
	EI
	BND	10
L	EQ	L+1
	ER
P	EQ	P+1
	ER
	EI
N	EQ	N+1
	ER
	LIST

:	CREATE PVC LOGON INDEX TABLE
:	-----------------------------
:	INDEX BY REL LU #, (I.E. LUCT.N)
	SEG	A.CODE

	NOLIST
PVCTBL	HS	0
QN	EQ	0
	RE	NLINES
QP	EQ	0
	RE	MSTN|QN|
	HC	-1
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	\PX|QN||QP||QL|
	HC	PX|QN||QP||QL|-PSEG
	ELSE
	HC	-1
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
QN	EQ	QN+1
	ER
	LIST

	SUBTTL	(SNA)	PRESET LOGON DATA/INFORMATION


:	CREATE LG.SELE STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	HS	0
GLGSL	G.SELC				:GENERAL DEFAULT STRINGS.

QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	1-LP|QN||QP||QL|
	IF	\SF|QN||QP||QL|
	HS	0
SE|QN||QP||QL|	SL|QN||QP||QL|(QN,QP,QL)
	ELSE
SE|QN||QP||QL|	EQ	GLGSL
ST|QN||QP||QL|	EQ	G.SELT
	EI
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI	(LINK|QN|)
QN	EQ	QN+1
	ER
	LIST

:	CREATE PRESET LOGON STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	IF	\G.MENT
QE	EQ	0
	RE	G.MENT+1
	IF	\LGMOD|QE|
	IF	.EQ.(LGMOD|QE|,PRESET)
QV	EQ	0
	RE	G.LGV|QE|
	IF	\F.LG|QE||QV|
GLOG|QE||QV|	G.LG|QE||QV|		:GENERAL DEFAULT PRESET LOGON STRINGS.
	EI
QV	EQ	QV+1
	ER
	EI
	EI
QE	EQ	QE+1
	ER
	EI	(\G.MENT)

N	EQ	0
	RE	NLINES
	IF	LINK|N|
P	EQ	0
	RE	MSTN|N|
L	EQ	1
	RE	MLU|N||P|-1
	IF	1-LP|N||P||L|
E	EQ	0
	RE	ME|N||P||L|+1
	IF	1-\M|N||P||L||E|
M|N||P||L||E|	EQ	LGMOD|E|
	EI
	IF	M|N||P||L||E|
	IF	\E|N||P||L||E|&\V|N||P||L||E|
Q|N||P||L||E|
	A|N||P||L||E|
	IF	V|N||P||L||E|-1
	B|N||P||L||E|
	EI
	IF	V|N||P||L||E|-2
	C|N||P||L||E|
	EI
	IF	V|N||P||L||E|-3
	D|N||P||L||E|
	EI
	IF	V|N||P||L||E|-4
	F|N||P||L||E|
	EI
	ELSE
Q|N||P||L||E|	EQ	GLOG|E|0
	EI
	EI
E	EQ	E+1
	ER
	EI
L	EQ	L+1
	ER
P	EQ	P+1
	ER
	EI
N	EQ	N+1
	ER
	LIST

:	CREATE LOGON SELECTION PROMPT STRINGS
:	---------------------------------------
	SEG	A.CODE

	NOLIST
	IF	\G.MENT
QE	EQ	0
	RE	G.MENT+1
	IF	\FLGPM|QE|
	HS	0
GPRMT|QE|	LGPMP|QE|(QE)		:PROMPT MESSAGE
	EI
QE	EQ	QE+1
	ER
	EI	(\G.MENT)

QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
QL	EQ	1
	RE	MLU|QN||QP|-1
QE	EQ	0
	RE	ME|QN||QP||QL|+1
	IF	\N|QN||QP||QL||QE|
	HS	0
J|QN||QP||QL||QE|	R|QN||QP||QL||QE|(QN,QP,QL,QE)
	ELSE
J|QN||QP||QL||QE|	EQ	GPRMT|QE|
I|QN||QP||QL||QE|	EQ	PRMT|QE|
	EI
QE	EQ	QE+1
	ER
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI	(LINK|QN|)
QN	EQ	QN+1
	ER
	LIST

:	DEFINE SYBMBOL FIRST
:	-----------------------
:	THIS IS NECESSARY BECAUSE THE CHARACTERS WITHIN A REPEAT RANGE 
:	CAN NOT GREATER THAT 640 CHARS.

	NOLIST
N	EQ	0
	RE	NLINES
	IF	LINK|N|
P	EQ	0
	RE	MSTN|N|
L	EQ	1
	RE	MLU|N||P|-1
	IF	1-LP|N||P||L|
E	EQ	0
	RE	ME|N||P||L|+1
	IF	1-\M|N||P||L||E|
M|N||P||L||E|	EQ	LGMOD|E|
	EI
	IF	.EQ.(M|N||P||L||E|,PRESET)
	IF	1-\V|N||P||L||E|
V|N||P||L||E|	EQ	G.LGV|E|
	EI
	IF	1-\L|N||P||L||E|
L|N||P||L||E|	EQ	DLN|E|
	EI
	IF	1-\P|N||P||L||E|
P|N||P||L||E|	EQ	DCU|E|
	EI
	IF	1-\U|N||P||L||E|
U|N||P||L||E|	EQ	DLU|E|
	EI
	IF	1-\T|N||P||L||E|
T|N||P||L||E|	EQ	DTP|E|
	EI
	IF	1-\O|N||P||L||E|
O|N||P||L||E|	EQ	DCO|E|
	EI
	IF	1-\Z|N||P||L||E|
Z|N||P||L||E|	EQ	DSZ|E|
	EI
	EI
E	EQ	E+1
	ER
	EI
L	EQ	L+1
	ER
P	EQ	P+1
	ER
	EI
N	EQ	N+1
	ER
	LIST

:	DEFINE SYBMBOL SECOND
:	-----------------------
:	THIS IS NECESSARY BECAUSE THE CHARACTERS WITHIN A REPEAT RANGE 
:	CAN NOT GREATER THAT 640 CHARS.

	NOLIST
N	EQ	0
	RE	NLINES
	IF	LINK|N|
P	EQ	0
	RE	MSTN|N|
L	EQ	1
	RE	MLU|N||P|-1
	IF	1-LP|N||P||L|
E	EQ	0
	RE	ME|N||P||L|+1
	IF	.EQ.(M|N||P||L||E|,PRESET)
	IF	1-\W|N||P||L||E|
W|N||P||L||E|	EQ	DCR|E|
	EI
	EI
E	EQ	E+1
	ER
	EI
L	EQ	L+1
	ER
P	EQ	P+1
	ER
	EI
N	EQ	N+1
	ER
	LIST

:	CREATE LOGON SELECTION DATA TABLE
:	---------------------------
	SEG	A.CODE

	BND	10

	NOLIST
PSDTBL	HS	0
N	EQ	0
	RE	NLINES
	IF	LINK|N|
P	EQ	0
	RE	MSTN|N|
L	EQ	1
	RE	MLU|N||P|-1
	IF	1-LP|N||P||L|
PE|N||P||L|
E	EQ	0
	RE	ME|N||P||L|+1
	BC	E
	BC	M|N||P||L||E|
MOD	EQ	M|N||P||L||E|
	HC	I|N||P||L||E|
	HC	J|N||P||L||E|-PSEG
	IF	.EQ.(MOD,PRESET)
	HC	Q|N||P||L||E|-PSEG
	BC	V|N||P||L||E|
	BC	L|N||P||L||E|
	BC	P|N||P||L||E|
	BC	U|N||P||L||E|
	BC	T|N||P||L||E|
	BC	O|N||P||L||E|
	BC	Z|N||P||L||E|
	BC	W|N||P||L||E|
	EI
	BND	10
E	EQ	E+1
	ER
	EI
L	EQ	L+1
	ER
P	EQ	P+1
	ER
	EI
N	EQ	N+1
	ER
	LIST

:	CREATE LOGON SELECTION INDEX TABLE
:	-----------------------------
:	INDEXED BY REL LU #, (I.E. LUCT.N)
	SEG	A.CODE

	NOLIST
PSTTBL	HS	0
QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
	HC	-1
	HC	-1
	HC	-1
	BC	-1
	BND	2
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	1-LP|QN||QP||QL|
	HC	ST|QN||QP||QL|
	HC	SE|QN||QP||QL|-PSEG
	HC	PE|QN||QP||QL|-PSEG
	BC	ME|QN||QP||QL|+1
	ELSE
	HC	-1
	HC	-1
	HC	-1
	BC	-1
	EI
	BND	2
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI
QN	EQ	QN+1
	ER
	LIST

	SUBTTL	(SNA)	NETWORK SERVICE SCREEN DATA/INFORMATION


:	CREATE NS.MENU STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	HS	0			:ALIGN (12/19/86/CHS)
GNSMU	G.NSMENU			:GENERAL DEFAULT STRINGS.

QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	1-LP|QN||QP||QL|
	IF	\MF|QN||QP||QL|
NU|QN||QP||QL|	MU|QN||QP||QL|
	ELSE
NU|QN||QP||QL|	EQ	GNSMU
MT|QN||QP||QL|	EQ	G.NSMT
	EI
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI	(LINK|QN|)
QN	EQ	QN+1
	ER
	LIST

:	CREATE NS.KWRD STRINGS AND ASSIGN SYMBOLS TO THEM
:	---------------------------------------------
	SEG	A.CODE

	NOLIST
	HS	0
GNSKW	G.KWRD				:GENERAL DEFAULT STRINGS.

QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	1-LP|QN||QP||QL|
	IF	\FW|QN||QP||QL|
WD|QN||QP||QL|	KW|QN||QP||QL|
	ELSE
WD|QN||QP||QL|	EQ	GNSKW
KT|QN||QP||QL|	EQ	G.KWDT
	EI
	EI
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI	(LINK|QN|)
QN	EQ	QN+1
	ER
	LIST

:	CREATE NETWORK SERVICE SCREEN INFORMATION INDEX TABLE
:	-----------------------------------------------------
:	INDEXED BY REL LU # (I.E. LUCT.N)
	NOLIST
NSMTBL	HS	0
QN	EQ	0
	RE	NLINES
	IF	LINK|QN|
QP	EQ	0
	RE	MSTN|QN|
	HC	-1
	HC	-1
	HC	-1
	HC	-1
	BC	-1
	BND	2
QL	EQ	1
	RE	MLU|QN||QP|-1
	IF	1-LP|QN||QP||QL|
	HC	MT|QN||QP||QL|
	HC	NU|QN||QP||QL|-PSEG
	HC	KT|QN||QP||QL|-PSEG
	HC	WD|QN||QP||QL|-PSEG
	IF	\NK|QN||QP||QL|
	BC	NK|QN||QP||QL|
	ELSE
	BC	G.NSKY
	EI
	ELSE
	HC	-1
	HC	-1
	HC	-1
	HC	-1
	BC	-1
	EI
	BND	2
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
	EI
QN	EQ	QN+1
	ER
	LIST

	EM
   	SUBTTL	(SNA) DATA STORAGES ALLOCATION - GBLDEF
:STOR00.G00

	MO	.,GBLDEF

:	**************************************************
:	REVISION HISTORY --
:	06/06/84 (NCS) -- ADD STORAGE ALLOCATION IN LUCTAB FOR DSP
:			  AND UPDATE 
:	************************************************************

	RA	0			:RADIX IS HEX

	LO	MAIN
	LO	GBLDEF


:	HOST TABLE FOR MULTIPLE HOST SUPPORT
:	------------------------------------
	SEG	A.DATA

	BND	10
HOSTAB	EQ	.-2
	BS	HSTLEN*MAXHST
OLDORG	EQ	.

Q	EQ	0			:TEMP COUNTER
	RE	MAXHST			:REPEAT FOR ALL HOSTS
	ORG	HOSTAB+2+Q*HSTLEN
	HC	RH|Q|			:HOST NUMBER
	BC	Q			:HOST REL#
	BC	RHTYP|Q|		:HOST TYPE (SNA, MONITOR, ETC.)
	IF	RHTYP|Q|
	BC	80			:SNA HOST WITH IIX IQ
	ELSE
	BC	00			:SNA MONITOR NO IIX IQ
	EI	(RHTYP|Q|)
	BC	0			:HOST STATUS
	HS	0
	HC	RHMP|Q|			:HOST MAXIMUM PORTS
Q	EQ	Q+1
	ER
	ORG	OLDORG


:	HOST TABLE POINTER, INDEX BY RELATIVE HOST NUMBER
:	-------------------------------------------------
:	SEG	A.BDAT			:(01/20/87 YLH)
	SEG	A.DATA			:(01/20/87 YLH)

HSTPTR	BND	2
Q	EQ	0
	RE	MAXHST
	HC	Q*HSTLEN+2
Q	EQ	Q+1
	ER


:	ALLOCATE PORTAB
:	----------------
	SEG	A.DATA

PORTAB	HS	NPORT			:PORT TABLE, INDEXED BY 2*ISIS PORT#


:	ALLOCATE DCB CONTROL BLOCKS 
:	---------------------------
	SEG	A.BDAT			:BASED DATA AREA

Q	EQ	.-(./10)*10
	IF	10-Q-4
	BS	10-Q-4			:MAKE SURE DCB1ST START FROM QUAD WORD
	ELSE
	BS	Q-4
	EI	(10-Q-4)
DCBLKS	BND	2			:DEVICE CONTROL BLOCKS TABLE
DCBACT	HS	1			:DCB ACTIVE POINTER
DCBFRE	HS	1			:DCB FREE CHAIN POINTER
DCB1ST	BS	DCBLEN*(NPORT+1)	:ALLOCATE DCB'S

:	FLAGS INDEXED BY TOTAL REL LU#
:	---------------------------------
:	INDEXED BY LUCT.N
	SEG	A.DATA
	HS	0
LUTFLG	HS	(MAXLUN+0F)/10		:TIMEOUT FLAG
CPNWSN	HS	(MAXLUN+0F)/10		:CMD-Q NWK TO SNA DATA PRESENT
DPNWSN	HS	(MAXLUN+0F)/10		:DATA-Q NWK TO SNA DATA PRESENT
CPSNNW	HS	(MAXLUN+0F)/10		:CMD-Q SNA TO NWK DATA PRESENT
DPSNNW	HS	(MAXLUN+0F)/10		:DATA-Q SNA TO NWK DATA PRESENT


:	FLAGS INDEXED BY TOTAL REL PU#
:	----------------------------
	SEG	A.DATA
	HS	0
PUTFLG	HS	(MAXPUN+0F)/10		:TIMEOUT FLAG
DPPCDL	HS	(MAXPUN+0F)/10		:DATA-Q PC TO DLC DATA PRESENT
DPDLPC	HS	(MAXPUN+0F)/10		:DATA-Q DLC TO PC DATA PRESENT
CPNWDL	HS	(MAXPUN+0F)/10		:CMD-Q NWK TO DLC, DATA PRESENT
CPDLNW	HS	(MAXPUN+0F)/10		:CMD-Q DLC TO NWK, DATA PRESENT
INNWDL	HS	(MAXPUN+0F)/10		:NWC TO DLC, INIT ISSUED
CLNWDL	HS	(MAXPUN+0F)/10		:NWC TO DLC, CLR ISSUED
TMNWDL	HS	(MAXPUN+0F)/10		:NWC TO DLC, TRM ISSUED
	LIST
:	LU CONTROL TABLE ENTRY POINTER
:	---------------------------
:	INDEXED BY ALL REL LU ID (I.E. LUCT.D)
	SEG	A.DATA

LUCPTR	BND	2
QL	EQ	0
QN	EQ	0
	RE	NLINES
QP	EQ	0
	RE	MSTN|QN|
QD	EQ	0
	RE	MLID|QN||QP|+1
	IF	\LY|QN||QP||QD|
	HC	QL*LUCLEN+2
QL	EQ	QL+1
	ELSE
	HC	-1
	EI
QD	EQ	QD+1
	ER
QP	EQ	QP+1
	ER
QN	EQ	QN+1
	ER

:	LU CONTROL TABLE ENTRY POINTER 2
:	--------------------------------
:	INDEXED BY ALL REL LU# (I.E. LUCT.N)
	SEG	A.DATA
LUBPTR	BND	2
QL	EQ	0
QN	EQ	0
	RE	NLINES
QP	EQ	0
	RE	MSTN|QN|
	RE	MLU|QN||QP|
	HC	QL*LUCLEN+2
QL	EQ	QL+1
	ER
QP	EQ	QP+1
	ER
QN	EQ	QN+1
	ER



:	PU CONTROL TABLE ENTRY POINTER
:	-----------------------------
:	INDEXED BY REL PU#
	SEG	A.DATA

PUCPTR	BND	2
Q	EQ	0
	RE	MAXPUN
	HC	Q*PUCLEN+2
Q	EQ	Q+1
	ER


:	ALLOCATE LINE CONTROL BLOCK TABLE
:	---------------------------------
:	SEG	A.BDAT			:(01/20/87 YLH)
	SEG	A.DATA			:(01/20/87 YLH)

        BND     10
LNCTAB	EQ	.-2
	BS	LNCLEN*NLINES		:LINE CONTROL BLOCK TABLE
OLDORG	EQ	.
Q       EQ      0
QQ      EQ      0			:(01/29/87 YLH)
	RE	NLINES
	ORG	LNCTAB+2+Q*LNCLEN+LNHOST
	IF	\SHOS|Q|
	HC	SHOS|Q|			
	BC	LRH|Q|			
	ELSE
	HC	-1
	BC	-1
	EI	(\SHOS|Q|)
	BC	MSTN|Q|			
	BC	0			
	BC	0			
	BC	MODE|Q|*2+LINK|Q|	
	BC	RUCHN|Q|*4+RSPCL|Q|*2+SNADL|Q|
	IF	LINK|Q|
	IF	\EPTY|Q|0
	BC	EPTY|Q|0		
	ELSE
	BC	G.EPTY
	EI
	ELSE
	IF	\IPTY|Q|0
	BC	IPTY|Q|0
	ELSE
	BC	G.IPTY
	EI
	EI
	BC	WDWS|Q|
:	BC	0
	BC	0			:STATE #
	BND	2
	BC	0			:STAT FLGS
	BND	2
	HC	FRMS|Q|
	HC	40 BBXQA|Q|
	HC	40 BBRQA|Q|
	HC	40,40			:BB USAGE **
	HC	QQ*PUCLEN+2		:1ST PUC
	HC	0			:STAT
	HC	LIAC|Q|*$A60		:INACT TIMER
	HC	LDSC|Q|
	BND	4
	WC	0,0
QQ	EQ	QQ+MSTN|Q|		
Q	EQ	Q+1
	ER
	ORG	OLDORG


:	LINE CONTROL TABLE ENTRY POINTER
:	--------------------------------
:	INDEXED BY LINE NUMBER
	SEG	A.DATA

LNCPTR	BND	2
Q	EQ	0
	RE	NLINES
	HC	Q*LNCLEN+2
Q	EQ	Q+1
	ER


:	ALLOCATED LINK STATION CONTROL BLOCK AREA
:	-----------------------------------------
	SEG	A.BDAT

	BND	10
LSCLKS	EQ	.-2
LSC1ST	BS	LSCLEN*MAXPUN		:ALLOCATE LSC'S


:	LSC TABLE ENTRY POINTER
:	-------------------------------
:	INDEXED BY RELATIVE LSC NUMBER
	SEG	A.DATA

LSCPTR	BND	2
Q	EQ	0
	RE	MAXPUN
	HC	Q*LSCLEN+2
Q	EQ	Q+1
	ER


:	ALLOCATED LINK CONTROL BLOCK AREA
:	--------------------------------
:	SEG	A.BDAT			:(01/20/87 YLH)
	SEG	A.DATA			:(01/20/87 YLH)

        BND     10
LCBTAB	EQ	.-2
	BS	LCBLEN*NLINES		:LINK CONTROL BLOCK
OLDORG	EQ	.

:	NOLIST
Q	EQ	0
	RE	NLINES
	ORG	LCBTAB+2+Q*LCBLEN
	BC	MODE|Q|
	BC	LINK|Q|
	BC	RTYM|Q|
	BC	WDWS|Q|
	HC	FRMS|Q|
Q	EQ	Q+1
	ER
	LIST
	ORG	OLDORG

:	LCBTAB ENTRY POINTER
:	--------------------------
:	INDEXED BY THE LINE NUMBER
	SEG	A.DATA

LCBPTR	BND	2
Q	EQ	0
	RE	NLINES
	HC	Q*LCBLEN+2
Q	EQ	Q+1
	ER


:	EVENT LOG TABLE
:	---------------
:	SEG	A.BDAT			:(01/20/87 YLH)
	SEG	A.DATA			:(01/20/87 YLH)

	IF	MLOGEN
	BND	2
ELGLST	HC	0
ELGNXT	HC	0
ELGTBL	BND	2
	BS	MLOGEN*ELGLEN
ELGTBE	EQ	.
	EI	(MLOGEN)

	IF	BTRACE
:	ISIS INPUT AND OUTPUT DAT TRACE BUFFER
:	---------------------------------------
:	EACH ENTRY HAS 8 BYTES
:	EACH ENTRY ALWAYS TIME-STAMPED
:		BS - ISIS PORT NUMBER
:		BS - LU NUMBER
:		HS - BIT 0 = INPUT OR OUPTUT TRACE
:		     BIT 1 = START OR END OF A DATA PACKET IF 0
:		     BIT 2-15 = BYTE COUNT
:		WS - GMT/FASTC

BTRINP	EQ	0000			: 0000 - ISIS/INPUT
BTROUT	EQ	8000			: 8000 - ISIS/OUTPUT
BTRBEG	EQ	0000			: 0000 - ISIS I/O BEGIN
BTREND	EQ	4000			: 4000 - ISIS I/O END

BTRIOF	HC	0			:INPUT/OUTPUT TRACE FLAG
BTRIBT	EQ	0			:BIT 0  - INPUT TRACE
BTROBT	EQ	1			:BIT 1  - OUTPUT TRACE

BTRBFL	EQ	400			:MUST BE LENGTH OF  4

BTRSIX	HC	0			:TRACE INDEX
BTRSBF
	RE	BTRACE
	BS	BTRBFL			:TRACE BUFFER = 1K * BTRACE
	ER
	BS	10			:GAP
	EI	(BTRACE)

	FO	MAIN
	EM
    
	SUBTTL	DEFINITION FILE FOR SNA PACKAGE
:	MODULE NAME IN COMMAND FILE -- SDEF02.F00

:	THIS IS A DEFINITION PACKAGE FOR ALL THE FSM ENTRY POINTS,
:	DATA STRUCTURE RELATED CONSTANTS AND REGISTERS DEFINITION.
:	(THE INFORMATION WHICH ARE REQUIRED BY SCHEDULER ARE INCLUDED)
:	------------------------------------------------------------
:
:	*********************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	***************************************************

	MO	.,CBKDEF

	LO	MAIN

	RA	0

:	INTERFACE SUPPORT FEATURES SWITCH
:	-----------------------------------------
FN.BND	EQ	0			:NOT SUPPORT BOUNDARY FOUNCTION
FN.T1S	EQ	0			:NOT SUPPORT T1 NODE
FN.FSM	EQ	0			:NOT CRASH IN FSM

:	THE PROCEDURE NUMBERS WHICH ARE ASSIGNED FOR THE DQE
:	-----------------------------------------------------
SCHEDL	EQ	00		:SCHEDULER PROCEDURE
PCDQBR	EQ	01		:PC.DEQ_Q_BTU_RCV
PCT2RV	EQ	02		:PC_T2.RCV
PCT1RV	EQ	03		:PC_T1.RCV
PCT1SD	EQ	04		:PC_T1.SEND
PCT2SD	EQ	05		:PC_T2.SEND
PCTGCR	EQ	06		:PC.TGC.RCV
PCBFRV	EQ	07		:BF.PC.RCV
PCVRSD	EQ	08		:PC.VR_SEND
PTDQBR	EQ	09		:PC_SA.TGC.DEQ_Q_BTU_RCV PROCEDURE #
PCTGQR	EQ	0A		:PC.TGC.DEQ_Q_BTU_RCV
PVDQVP	EQ	0B		:PC_SA.VRC.DEQ_Q_VR_PAC PROC. #
PVVRSD	EQ	0C		:PC_SA.VRC.VRPRS_SEND PROC. #
TCDQPG	EQ	0D		:TC_OR_BF_TC.DEQUEUE.Q_PAC PROC. #
TCIPSD	EQ	0E		:TC_OR_BF_TC.IPR_SEND PROC. #
TCCMRV	EQ	0F		:TC.CPMGR.RCV
TCCMSD	EQ	10		:TC.CPMGR.SEND
TCSCRV	EQ	11		:TC.SC.RCV
TCSCSD	EQ	12		:TC.SC.SEND
TCBFSD	EQ	13		:BF.TC.SEND
TCBFRV	EQ	14		:BF.TC.RCV
DQTCDC	EQ	15		:DEQUEUE.Q_TC_TO_DFC PROC. #
DFCRCV	EQ	16		:DFC.RCV
DFCSND	EQ	17		:DFC.SEND
FCNSRV	EQ	18		:FMD.SNS.RCV
FCNSSD	EQ	19		:FMD.SNS.SEND
FCPSRV	EQ	1A		:FMD.SPS.RCV
FCPSSD	EQ	1B		:FMD.SPS.SEND
PMCSMR	EQ	1C		:PU.SVC_MGR.CSC_MGR.RCV
PMCSMS	EQ	1D		:PU.SVC_MGR.CSC_MGR.SEND
PMCSSO	EQ	1E		:PU.SVC_MGR.CSC_MGR.SON
PMNSMR	EQ	1F		:PU.SVC_MGR.NS.RCV
PMNSMS	EQ	20		:PU.SVC_MGR.NS.SEND
PMPRMR	EQ	21		:PU.SVC_MGR.PC_ROUTE_MGR.RCV PROC. #
PMCSBR	EQ	22		:PU.SVC_MGR.CS_MGR.BF_RCV
SMCSMS	EQ	23		:SSCP.SVC_MGR.CS.SEND
SMCSMR	EQ	24		:SSCP.SVC_MGR.CS.RCV
NMDQCR	EQ	25		:NM.Q_CMD_RCV (NETWORK MONITOR)
LUSEND	EQ	26		:NM.Q_DATA_RCV (NETWORK MONITOR)
LURCV	EQ	27		:LU.SVC.PS (SAME AS FCPSRV)
LMSSMR	EQ	LURCV		:LU.SVC_MGR.SS.RCV
LMSSMS	EQ	LUSEND		:LU.SVC_MGR.SS.SEND

:	THE INPUT SIGNAL NUMBERS WHICH ARE ASSIGNED FOR DQE
:	---------------------------------------------------
SG.NOS	EQ	0		:NO SIGNAL
SG.RES	EQ	1		:HIERARCHICAL_RESET SIGNAL
				:RQ-FROM SON_MGR TO CSC_MGR,CSC_MGR TO SVC_MGR
				:RSP (FROM SVC_MGR TO SCS_MGR)
SG.SGO	EQ	2		:SSCP_GONE
SG.OPQ	EQ	3		:OPEN_QUEUE SIGNAL
SG.BTU	EQ	4		:BTU SIGNAL
SG.ERR	EQ	5		:ABNORMAL CONDITION (SUCH AS ACTPU IN LU_LU)
SG.ZAP	EQ	6		:ZAPPER SIGNAL
SG.LDW	EQ	7		:SIGNAL FOR LINK DOWN
SG.UNB	EQ	8		:REQUEST UNBIND SIGNAL
SG.BTB	EQ	9		:BETB SIGNAL
SG.VRP	EQ	0A		:SEND_VRPRS
SG.VRF	EQ	0B		:SEND_DACTVR_F SIGNAL
SG.IPR	EQ	0C		:SEND_IPR SIGNAL
SG.RTN	EQ	0D		:RETURN TO E-T-E MODE (10/6/84 MIA)
SG.MAX	EQ	SG.IPR+1	:MAX # OF SIGNALS

:	REGISTERS CONVENTION FOR THE SNA PACKAGE
:	----------------------------------------
:	THE FOLLOWING REGISTERS ARE SPECIALLY RECOMMENTED
:	R13 -- NODE CONTROL BLOCK TABLE POINT
:	R10 -- SESSION CONTROL BLOCK TABLE POINT
:	R12 -- PATH CONTROL BLOCK AND OTHER BLOCKS PTR
RNODE	EQ	R11		:FOR RELATIVE NODE NUMBER

:	THE INDEX FOR THE FSM IN PATH CONTROL BLOCK
:	------------------------------
FSMNOP	EQ	0		:INDEX NO_OP FOR ALL THE FSMS
FPCSBA	EQ	1		:FSM_STATION_BIU_ASSEMBLY
NPCFSM	EQ	FPCSBA+1

:	THE INDEX FOR THE FSM IN NODE RESOURCE CONTROL BLOCK
:	------------------------------
FNRAPL	EQ	1		:FSM_ADJ_PU_LOAD
FNRACR	EQ	2		:FSM_ALS_CONNECTED_RES
FNRACD	EQ	3		:FSM_ALS_CONTACT_DISCONNECT_RES
FNRADR	EQ	4		:FSM_ALS_SEC_DUMP_RES
FNRAIR	EQ	5		:FSM_ALS_SEC_IPL_RES
FNRARR	EQ	6		:FSM_ALS_SEC_RPO_RES
FNRATR	EQ	7		:FSM_ALS_TEST_RES
FNRAXR	EQ	8		:FSM_ALS_SEC_XID_RES
FNRLAR	EQ	9		:FSM_LINK_ACT_RES
FNRLCR	EQ	0A		:FSM_LINK_CONNIN_RES
FNRLOR	EQ	0B		:FSM_LINK_CONNOUT_RES
FNRLTR	EQ	0C		:FSM_LINK_TRACE_RES
FNRPAR	EQ	0D		:FSM_PU_ACT_RES
FNRP2L	EQ	0E		:FSM_PU_T2_LOAD
NNRFSM	EQ	FNRP2L+1

:	THE INDEX FOR THE FSM IN CONTROL POINT CONTROL BLOCK
:	------------------------------
FCPCSS	EQ	1		:FSM_CP_SESS_SDT
NCPFSM	EQ	FCPCSS+1

:	THE INDEX FOR THE FSM IN DOMAIN RESOURCE CONTROL BLOCK
:	------------------------------
FDRACT	EQ	1		:FSM_ALS_CONNECTED_DOM_RES
FDRATD	EQ	2		:FSM_ALS_CONTACT_DOM_RES
FDRADD	EQ	3		:FSM_ALS_DUMP_DOM_RES
FDRAID	EQ	4		:FSM_ALS_IPL_DOM_RES
FDRARD	EQ	5		:FSM_ALS_RPO_DOM_RES
FDRNAD	EQ	6		:FSM_LINK_ACT_DOM_RES
FDRNID	EQ	7		:FSM_LINK_CONNIN_DOM_RES
FDRNOD	EQ	8		:FSM_LINK_CONNOUT_DOM_RES
FDRLAD	EQ	9		:FSM_LU_ACT_DOM_RES
FDRRDR	EQ	0A		:FSM_PROC_DOM_RES
FDRPAD	EQ	0B		:FSM_PU_ACT_DOM_RES
NDRFSM	EQ	FDRPAD+1

:	THE INDEX FOR THE FSM IN VIRTUAL ROUTE CONTROL BLOCK
:	------------------------------
FVCDVD	EQ	1		:FSM_DACTVR_DIRECTION
FVCSCW	EQ	2		:FSM_SET_CWRI
FVCVVR	EQ	3		:FSM_VR
FVCVQS	EQ	4		:FSM_VRPRQ_SEND
FVCVQR	EQ	5		:FSM_VRPRQ_RCV
NVCFSM	EQ	FVCVQR+1

:	THE INDEX FOR THE FSM IN EXPLICIT ROUTE CONTROL BLOCK
:	------------------------------
FECERN	EQ	1		:FSM_ERN
NECFSM	EQ	FECERN+1

:	THE INDEX FOR THE FSM IN PATH CONTROL BLOCK LIST
:	------------------------------
FPLPAH	EQ	1		:FSM_PATH
NPLFSM	EQ	FPLPAH+1

:	THE INDEX FOR THE FSM IN TRANSMISSION GROUP CONTROL
:	------------------------------
FTGSTS	EQ	1		:FSM_SUSPEND_TG_SEND
FTGTGS	EQ	2		:FSM_TG_SWEEP
FTGVWZ	EQ	3		:FSM_VR_WINDOW_SIZE
NTGFSM	EQ	FTGVWZ+1

:	THE INDEX FOR THE FSM IN LINK STATION CONTROL BLOCK
:	------------------------------
FLSTGN	EQ	1		:FSM_TGN
FLSXF2	EQ	2		:FSM_XID_FORMAT_2
NLSFSM	EQ	FLSXF2+1

:	THE INDEX FOR THE FSM IN TCCB
:	------------------------------
FTCPRS	EQ	1		:FSM_PAC_RQ_SEND
FTCPRR	EQ	2		:FSM_PAC_RQ_RCV
NTCFSM	EQ	FTCPRR+1

:	THE INDEX FOR THE FSMS IN SCCB
:	------------------------------
FSCBBI	EQ	1		:FSM_BSM_BIDDER
FSCBFP	EQ	2		:FSM_BSM_FSP
FSCCRV	EQ	3		:FSM_CHAIN_RCV
FSCCSD	EQ	4		:FSM_CHAIN_SEND
FSCCIE	EQ	5		:FSM_CNTL_IMMED_EXP
FSCCBR	EQ	6		:FSM_CONTROL_BSM_RSP_RCV
FSCCBS	EQ	7		:FSM_CONTROL_BSM_RSP_SEND
FSCHRV	EQ	8		:FSM_CONTROL_HDX_RSP_RCV
FSCHRD	EQ	9		:FSM_CONTROL_HDX_RSP_RCV_ERP_DL
FSCHRI	EQ	0A		:FSM_CONTROL_HDX_RSP_RCV_ERP_IM
FSCHSN	EQ	0B		:FSM_CONTROL_HDX_RSP_SEND
FSCHSD	EQ	0C		:FSM_CONTROL_HDX_RSP_SEND_ERP_DL
FSCHSI	EQ	0D		:FSM_CONTROL_HDX_RSP_SEND_ERP_IM
FSCCVR	EQ	0E		:FSM_CRV_RCV
FSCCVS	EQ	0F		:FSM_CRV_SEND
FSCDRC	EQ	10		:FSM_DT_RCV_CLEAR
FSCDRS	EQ	11		:FSM_DT_RCV_SDT
FSCDRA	EQ	12		:FSM_DT_RCV_SDT_AND_CLEAR
FSCDSC	EQ	13		:FSM_DT_SEND_CLEAR
FSCDSS	EQ	14		:FSM_DT_SEND_SDT
FSCDSA	EQ	15		:FSM_DT_SEND_SDT_AND_CLEAR
FSCERV	EQ	16		:FSM_EBCD_RCV
FSCESD	EQ	17		:FSM_EBCD_SEND
FSCHCL	EQ	18		:FSM_HDX_CONT_LOSER
FSCHCW	EQ	19		:FSM_HDX_CONT_WINNER
FSCHFF	EQ	1A		:FSM_HDX_FF
FSCIRR	EQ	1B		:FSM_IMM_RQ_MODE_RCV
FSCIRS	EQ	1C		:FSM_IMM_RQ_MODE_SEND
FSCQRV	EQ	1D		:FSM_QEC_RCV
FSCQSD	EQ	1E		:FSM_QEC_SEND
FSCQCS	EQ	1F		:FSM_QRI_CHECK_SEND
FSCQNR	EQ	20		:FSM_QRI_CHAIN_RCV
FSCQNS	EQ	21		:FSM_QRI_CHAIN_SEND
FSCRES	EQ	22		:FSM_RES
FSCRQR	EQ	23		:FSM_RQR_RCV
FSCRQS	EQ	24		:FSM_RQR_SEND
FSCRTB	EQ	25		:FSM_RTR_BIDDER
FSCRTF	EQ	26		:FSM_RTR_FSP
FSCSIR	EQ	27		:FSM_SBI_RCV
FSCSIS	EQ	28		:FSM_SBI_SEND
FSCBSL	EQ	29		:FSM_SESS_BF_SSCP_LU
FSCBS1	EQ	2A		:FSM_SESS_BF_SSCP_PU_T1
FSCBS2	EQ	2B		:FSM_SESS_BF_SSCP_PU_T2
FSCBLL	EQ	2C		:FSM_SESS_BF_LU_LU
FSCLLP	EQ	2D		:FSM_SESS_LU_LU_PRI
FSCLLS	EQ	2E		:FSM_SESS_LU_LU_SEC
FSCSLP	EQ	2F		:FSM_SESS_SSCP_LU_PRI
FSCSLS	EQ	30		:FSM_SESS_SSCP_LU_SEC
FSCSPP	EQ	31		:FSM_SESS_SSCP_PU_PRI
FSCSPS	EQ	32		:FSM_SESS_SSCP_PU_SEC
FSCSSP	EQ	33		:FSM_SESS_SSCP_SSCP_PRI_OR_SEC
FSCBUA	EQ	34		:FSM_SESSION_BIU_ASSEMBLY
FSCSHR	EQ	35		:FSM_SHUTD_RCV
FSCSHS	EQ	36		:FSM_SHUTD_SEND
FSCSNR	EQ	37		:FSM_STSN_RCV
FSCSNS	EQ	38		:FSM_STSN_SEN
NSCFSM	EQ	FSCSNS+1	:DEFINE THE TOTAL # OF FSMS IN SCB

:	LIST STRUCTURE FOR THE LIST PTRS IN NODE CONTROL BLOCK
:	------------------------------------------------------
:	----------------------------
:	| CURRENT CONTROL BLOCK PTR |
:	-----------------------------
:	| PREVIOUS PTR | NEXT PTR   |
:	-----------------------------
:	THE CONTAINTS ARE INITIALIZED DURING INIT TIME,AND NEED TWO
:	ROUTINES TO MAINTAIN THOSE PTRS.
VRLCPT	EQ	0		
VRLPPT	EQ	4		:OFFSET TO PTR OF PREVIOUS LIST
VRLNPT	EQ	VRLPPT+2	:OFFSET TO PTR OF NEXT LIST
TGLCPT	EQ	0		
TGLPPT	EQ	4		:OFFSET TO PTR OF PREVIOUS LIST
TGLNPT	EQ	TGLPPT+2	:OFFSET TO PTR OF NEXT LIST
LSTLEN	EQ	TGLNPT-TGLCPT+2	:LENGTH OF LIST

:	CORRELATION TABLE FIELD DEFINTION FOR NORM (RSP,RQ) MODE
:	========================================================
CLARG0	EQ	0			:OFFSET OF CT_BEG_SNF
NXQPTR	EQ	CLARG0+2		:OFFSET OF CMD LIST LINK PTR
CLARG1	EQ	NXQPTR+2		:OFFSET OF CT_EXR_SENSE_FOR_NOT_CANCEL
CLARG2	EQ	CLARG1+4		:OFFSET OF CT_EXR_SENSE_FOR_CANCEL
CLARG3	EQ	CLARG2+4		:OFFSET OF CT_END_SNF
CLARG5	EQ	CLARG3+2		:OFFSET OF CT_RH_RU_INFO
					:BIT 00 -- CT_BBI
					:BIT 01 -- CT_EBI
					:BIT 02 -- CT_CDI
					:BIT 8 -- CT_DR1I
					:BIT 10 -- CT_DR2I
					:BIT 11 -- CT_RTI
					:BIT 14 -- CT_QRI
CLARG4	EQ	CLARG5+2		:OFFSET OF CT_DFC_RQ_CODE
CLARG6	EQ	CLARG4+1		:OFFSET OF CT_ENTRY_TYPE & CONTROL
					:BIT 1-2 -- CT_RU_CTGY
					:BIT 5 -- CT_RSP_TO_NOT_CANCEL
					:BIT 6-7 -- CT_ENTRY_TYPE
CLARG7	EQ	CLARG6+1		:FOR TIME SLICE
CT.ENT	EQ	03			:CT_ENTRY_TYPE POSITION
CT.RNC	EQ	04			:CT_RSP_TO_NOT_CANCEL
CT.ERI	EQ	10			:CT_ERI INDICATOR
:CT.CTG	EQ	MU.CTG

:	CORRELATION TABLE FIELD DEFINTION FOR EXP (SEND,RCV) MODE
:	========================================================
:	COMMAND LIST STRUCTURE FOR CT_RCV_RQ_EXP IS
:	---------------------------------------------
:	CLCMD CONTAINS CT_RCV_RQ_EXP_DFC_RQ_CODE (1 BYTE)
:	CLLNG CONTAINS CT_RCV_RQ_EXP_ID (2 BYTES)
:	CLARG CONTAINS CT_RCV_RQ_EXP_EXR_SENSE (2 BYTES)

:	COMMAND LIST STRUCTURE FOR CT_SEND_RQ_EXP IS
:	---------------------------------------------
:	CLCMD CONTAINS CT_SEND_RQ_EXP_DFC_RQ_CODE (1 BYTE)
:	CLLNG CONTAINS CT_SEND_RQ_EXP_ID (2 BYTES)

:	STATE INFORMATION FOR THE LU IN NODE NETWORK CONTROL (LUCB)
:	------------------------------------------------------------
NN.RES	EQ	00		:RESET STATE
NN.PDP	EQ	01		:PENDING FOR DACTPU
NN.PAP	EQ	02		:PENDING FOR ACTPU
NN.APU	EQ	03		:ACTIVE PU
NN.PDL	EQ	04		:PENDING FOR DACTLU
NN.PAL	EQ	05		:PENDING FOR ACTLU
NN.ALU	EQ	06		:ACTIVE LU
NN.ASE	EQ	07		:LU_LU SESSION BEGIN
NN.PLW	EQ	08		:PENDING FOR LINK DOWN RSP

:	CRASH CODE FOR SNA PACKAGES
:	---------------------------
CRQDSP	EQ	50		:CRASH FOR DISPATCHER
CRQSVC	EQ	51		:CRASH FOR SSCP.SVC_MGR MODULES
CRQPVC	EQ	52		:CRASH FOR PU.SVC_MGR MODULES
CRQLVC	EQ	53		:CRASH FOR LU.SVC_MGR MODULES
CRQDFC	EQ	54		:CRASH FOR DFC LAYERS
CRQTCC	EQ	55		:CRASH FOR TC LAYERS
CRQPCC	EQ	56		:CRASH FOR PC LAYERS
CRQSCH	EQ	57		:CRASH FOR SCHEDULER
CRQRES	EQ	58		:CRASH FOR RESOURCE (SCB,BUFFER,CMDLST)
CRQFOM	EQ	59		:CRASH FOR SNA FORMATES ERROR
CRQNSN	EQ	5A		:CRASH FOR INTERFACE BETWEEN SNA AND NIO
CRQFSM	EQ	5B		:CRASH FOR INVALID FSM STATE
CRQFMD	EQ	5C		:CRASH FOR FMD LAYERS

:	SUB-CRASH CODE FOR EACH CRASH CODE IN SNA PACKAGES
:	--------------------------------------------------
:	CRQDSP
:	======
:	CRQSVC
:	======
:	CRQPVC
:	======
:	CRQLVC
:	======
:	CRQDFC
:	======
:	CRQTCC
:	======
:	CRQPCC
:	======
:	CRQSCH
:	======
:	CRQRES
:	======

	IF	VHRSUP!VTISUP
::::::::::::::::::::::::::::::
:: VHR DEFINITIONS.
::::::::::::::::::::::::::::::
:: VTI STATE BYTE DEFINITIONS.
::::::::::::::::::::::::::::::
:: STRUCTURE OF VHR STATE BYTE.
LUVTIF	EQ	80			:VTI FUNCTION FOR THE LU
LUVHRF	EQ	40			:VHR FUNCTION FOR THE LU
	EI
	IF	VTISUP
LUSRQF	EQ	20			:SYS/RQ IS SUPPORTED BY LU
	EI
	IF	VHRSUP
LURPVC	EQ	20			:PVC REQUESTED FOR LU
LUPVCP	EQ	10			:PVC BUILDING IN PROGRESS
LUSVCP	EQ	08			:SVC BUILDING IN PROGRESS
LUPVCO	EQ	02			:PVC OVERRIDE REQUESTED
LUMNLG	EQ	01			:MANUAL LOGON FROM VTR

:::::::::::::::::::
:: STRUCTURE OF VHR HEADER FROM VTR
VHRCMD	EQ	00			:3270 CMD (WRITE TYPE)
VHRWCC	EQ	01			:WCC (STRUCTURE FOLLOWS)

:::::::::::::::::::
:: STRUCTURE OF WCC (VHR HEADER FROM VTR)
VHROVR	EQ	02			:PVC OVERRIDE
VHRMSL	EQ	01			:MANUAL SVC LOGON

:::::::::::::::::::
:: STRUCTURE OF VHR HEADER TO VTR
VHRAID	EQ	00			:3270 AID (ENTER)
VHRCA1	EQ	01			:CURSOR POSITION 1 (STRUCTURE FOLLOWS)
VHRCA2	EQ	02			:CURSOR POSITION 2 (STRUCTURE FOLLOWS)
VHRCDE	EQ	03			:ERROR CODE (LOGON ONLY)

:::::::::::::::::::
:: STRUCTURE OF CADR1 (VHR HEADER TO VTR)
VHRCNT	EQ	04			:CONTINUE LOGON
VHRDSP	EQ	02			:GIVE DSP INFORMATION
VHRFLL	EQ	01			:ENTER FULL DUPLEX MODE

:::::::::::::::::::
:: STRUCTURE OF CADR2 (VHR HEADER TO VTR)
VHRCDR	EQ	01			:CHANGE DIRECTION REQUEST

:::::::::::::::::::
:: VHR ERROR CODE DEFINITIONS.
VHREOK	EQ	00			:OK CODE
VHREUS	EQ	01			:BAD USERNAME
VHREPW	EQ	02			:BAD PASSWORD
VHREDP	EQ	03			:BAD DSP INFO
VHREHN	EQ	04			:HOST NOT AVAILABLE
VHREOP	EQ	05			:HOST OUT OF PORTS
VHREHD	EQ	06			:HOST DOWN
VHRENA	EQ	07			:ACCESS NOT PERMITTED
VHREIN	EQ	08			:INSUFFICIENT LOGON INFO
VHREOV	EQ	09			:INCORRENT PVC OVERRIDE
VHREBY	EQ	0A			:CIRCUITS BUSY
VHRETO	EQ	0B			:LOGON TIMEOUT
VHREZP	EQ	0C			:CIRCUIT ZAPPED

:DEFAULT LINE NUMBER TO START LOGON ERROR MESSAGE.
	IF	\VHRLGR
	ELSE
VHRLGR	EQ	$A 20
	EI

	EI

:HIGH DUMMY MAX RU LENGTH IN CASE NO SEGMENTATION IS ALLOWED.
RUNOMX	EQ	4000

	FO	MAIN

	EM

	SUBTTL	SNA CONTROL BLOCK DEFINITION AREA
:	MODULE NAME IN COMMAND FILE -- SCBK02.F00

:	*************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	****************************************************

	MO	.,CBKDEF
	RA	0

OLDORG	EQ	.

:	NODE CONTROL BLOCK
:	------------------
:	THIS BLOCK CONTAINS THE PU ELEMENT ADDRESS AND NODE SUBAREA
:	ADDRESS AS WELL AS CURRENT STATE VALUES FOR THE RESOURCE
:	FSM'S WITHIN THE NODE. THIS BLOCK PROVIDES STORAGE FOR 
:	POINTERS TO ALL MAJOR LISTS IN THE NODE AND DEFAULT ENTITY
:	POINTERS FOR SOME OF THOSE LISTS
	ORG	0
NDDEVN	BS	1		:# OF LU AND PU IN THIS NODE
NDPUTY	BS	1		:PU TYPE OF THIS PU
NDMXEN	BS	1		:MAXIMUM ER # SUPPORTED BY THE NODE
NDMXVN	BS	1		:MAXIMUM VR # SUPPORTED BY THE NODE
	BND	4
:	ENTITY POINTERS
:	----------------
NDSSCB	WS	1		:DEFAULT PTR FOR SSCB
NDPCCB	WS	1		:DEFAULT PTR FOR PCCB
NDTCCB	WS	1		:DEFAULT PTR FOR TCCB
NDTGCB	WS	1		:DEFAULT PTR FOR TGCB
:NDVRCB	WS	1		:DEFAULT PTR FOR VRCB
:NDERCB	WS	1		:DEFAULT PTR FOR ERCB
:NDLSCB	WS	1		:DEFAULT PTR FOR LSCB
:NDSART	WS	1		:DEFAULT PTR FOR SUBAREA ROUTING
:NDNRCB	WS	1		:DEFAULT PTR FOR NRCB
:NDDRCB	WS	1		:DEFAULT PTR FOR DRCB
:NDCPCB	WS	1		:DEFAULT PTR FOR CPCB
:NDCPID	WS	1		:DEFAULT PTR FOR CP INDIRECT
:NDVRRS	WS	1		:DEFAULT PTR FOR VR RESERVATION
:NDERMP	WS	1		:DEFAULT PTR FOR ERN MAP
:NDALSE	WS	1		:DEFAULT PTR FOR ACT_LSCB_ENTITY
:NDVILS	WS	1		:DEFAULT PTR FOR VR_ID_LIST
:NDPDET	WS	1		:DEFAULT PTR FOR PARM_DEFINE_ER_TO_TG
:	LIST POINTERS
:	-------------
NDSCLS	WS	3		:PTR TO LIST HEADER FOR SSCB'S
NDQTCP	WS	3		:TCCB.Q_PAC DATA PRESENT (03/13/85 MIA)
NDQTDF	WS	3		:TC_TO_DFC DATA PRESENT (03/13/85 MIA)
:NDVRLS	WS	1		:PTR TO LIST HEADER FOR VRCB'S
:NDERLS	WS	1		:PTR TO LIST HEADER FOR ERCB'S
:NDTGLS	WS	1		:PTR TO LIST HEADER FOR TGCB'S
:NDLSLS	WS	1		:PTR TO LIST HEADER FOR LSCB'S
:NDNRLS	WS	1		:PTR TO LIST HEADER FOR NRCB'S
:NDDRLS	WS	1		:PTR TO LIST HEADER FOR DRCB'S
:NDEMLS	WS	1		:PTR TO LIST HEADER FOR ERN MAP LIST
:NDCPLS	WS	1		:PTR TO LIST HEADER FOR CPCB'S
:DSRLS	WS	1		:PTR TO LIST HEADER FOR SUBAREA ROUTING
:	NETWORK ADDRESS OF THE PU IN THIS NODE
:	--------------------------------------
: DELETED FOLLOWING UNUSED FIELDS (03/13/85 MIA).
:NDSAAR	WS	1		:SUBAREA ADDRESS OF THIS NODE
:NDPUEA	HS	1		:ELEMENT ADDRESS OF THE PU IN THIS NODE
:NDSCEA	HS	1		:ELEMENT ADDRESS OF THE SSCP IN NODE
:NDSCID	HS	3		:ID USED TO RESOLVE ACTCDRM CONTENTION
:NDSAMK	HS	1		:USED TO CONVERT A FID1 ADDR TO FID4 ADDR
:NDEAMK	HS	1		:USED TO CONVERT A FID1 ADDR TO FID4 ADDR
:NDPCEA	HS	1		:ELEMENT ADDR OF THE PUCP FOR THIS NODE
NDDQGP	HS	1		:DISPATCHER QUEUE GET PTR FOR THIS NODE
NDDQRP	HS	1		:DISPATCHER QUEUE RELEASE PTR
:NDSESN	HS	1		:SEQ. # FOR EXPEDITED FLOW IN THIS NODE
NDSANB	BS	1		:# OF SIGNIFICANT BITS IN SA ADDRESS
NDLSNM	BS	1		:LSCB NUMBER IN THIS NODE
NDIFLG	BS	1		:INFORMATION FLAG
				:BIT 0 -- DOES THIS NODE PROVIDE INTERMEDIATE
				:         FUNCTION?
				:BIT 1 -- WHETHER THIS NODE CAN DEFINE THE
				:         MAPPING OF ERN TO TG_ID DYMANICALLY?
NDRCAT	BS	1		:CURRENT NODE RESOURCE CATEGORY
NDRSTF	BS	1		:LINK DOWN RESET COUNTER(7/23/84/CHS)
	BND	10
NDLENG	EQ	.		:LENGTH OF NCB

:	PATH CONTROL CONTROL BLOCK
:	--------------------------
:	THIS BLOCK IS MAINTAINED FOR EACH PERIPHERAL NODE AND FOR
:	EACH SUBAREA NODE THAT PROVIDES BOUNDARY FUNCTION. IT PROVIDES
:	WORKING STORAGE AND ATTRIBUTES REQUIRED BY PATH CONTROL
:	COMPONENTS TO SEND AND RECEIVE PIU'S OVER ROUTE EXTENSIONS

	ORG	0
PCBAOP	BS	1		:PU_T1 OR T2 BIU ASSEMBLY OPTION
PCSTAT	BS	NPCFSM		:PCC FSM STATES INFORMATION
	BND	2
PCQBRG	HS	1		:Q_BTU_RCV,GET PTR TO THE QUEUE
PCQBRR	HS	1		:Q_BTU_RCV,RELEASE PTR TO THE QUEUE
PCQBRP	HS	1		:Q_BTU_RCV,PUT PTR
PCPUSG	HS	1		:PIU_SEND_LIST GET PTR
PCPUSR	HS	1		:PIU_SEND_LIST RELEASE PTR
PCPUSP	HS	1		:PIU_SEND_LIST PUT PTR
	BND	4
:PCQBUR	WS	1		:PTR TO BTU RCV QUEUE
PCBAPT	WS	1		:PTR TO PARTIALLY ASSEMBLED BIU
	BND	10
PCLENG	EQ	.		:LENGTH OF PCCB


:	NODE RESOURCE CONTROL BLOCK LIST
:	--------------------------------
:	THIS BLOCK CONTAINS INFORMATION ABOUT RESOURCES SUPPORTED BY
:	THIS NODE
	ORG	0
NRSTAT	BS	NNRFSM		:FSM STATE INFORMATION
NRRSCT	BS	1		:RESOURCE CATEGORY
NRLKDR	BS	1		:LINK DLC ROLE
NRSLMT	BS	1		:SHARE_LIMIT,THE MAX. CNT OF SSCP'S THAT MAY
				:SHARE THIS RESOURCE
NRBFLI	BS	1		:BF_LOCAL_ID,LOCAL FORM OF ADDR FOR BF.(PU|LU)
NRSRPC	BS	1		:SEC_RCV_PACING_CNT
NRPUTY	BS	1		:PU TYPE FOR BF.PU
NRCFLG	BS	1		:BIT 0 -- RESET (CONTINUE)
				:BIT 1 -- NONSWITCHED (SWITCHED)
				:BIT 2 -- CONFIGURABLE (NONCONFIGURABLE)
	BND	2
NRELAD	HS	1		:ELEMENT ADDRESS OF RESOURCE
NRASRS	HS	1		:ASSOCIATED RESOURCE
NRDHAL	HS	1		:THE DLC HEADER ADDRESS FOR ALS
	BND	4
NRCILS	WS	1		:CP_INDIRECT_LIST
NRACSI	WS	1		:ASSIGNING_CP_SCB_ID
NRMURL	WS	1		:SAVE_MU_FOR_RETRY_LIST
	BND	10
NRCBLN	EQ	.

:	CP INDIRECT LIST
:	----------------
:	CONTAINS A LIST OF POINTERS TO ENTRIES IN THE CPCB LIST
	ORG	0
CICPLS	WS		:CP_ENTRY_PTR,PTR TO CPCB LIST ENTRY

:	CONTROL POINT CONTROL BLOCK LIST
:	--------------------------------
:	CONTAINS THE LIST OF CONTROL POINTS THAT CURRENTLY SHARE THE PU
	ORG	0
CPCBFG	BS	1		:BIT 0 -- PRE_ER_VR (AJS SUPPORT ER &VR ?)
				:BIT 1 -- NS_LSA_REQUIRED
CPSTAT	BS	NCPFSM		:FSM STATE INFORMATION
	BND	4
CPSCID	WS	1		:CP_SCB_ID (ID FOR SSCP-PU SESSION)
	BND	10
CPLENG	EQ	.

:	DOMAIN RESOURCE CONTROL BLOCK LIST
:	----------------------------------
:	THIS DATA STRUCTURE CONTAINS INFORMATION ABOUT RESOURCES 
:	SUPPORTED BY THIS SSCP
	ORG	0
DRSTAT	BS	NDRFSM		:FSM STATE INFORMATION
DRRSCT	BS	1		:RESOURCE_CATEGORY, 1 SUBAREA_LU
				:2 SUBAREA_PU, 3 LINK, 4 ALS
				:5 PERIPHERAL_PU, 6 PERIPHERAL_LU
DRLDLR	BS	1		:LINK_DLC_ROLE,1 PRIMARY,2 SECONDARY
DRBFLI	BS	1		:BF_LOCAL_ID,LOCAL FORM OF ADDRESS FOR 
				:PERIPHERAL PU OR LU
DRPPTY	BS	1		:PERIPHERAL_PU_TYPE
DRSCTI	BS	1		:SEND_CONTACT_IMMEDIATELY
DRFLAG	BS	1		:BIT 0,0 SUBAREA_PU IS IN SLOWDOWN
				:BIT 1,LINK IS SWITCHED
	BND	2
DRNLAD	HS	1		:NODE_LINK_ADDR
DRNKNA	HS	3		:NETWORK_ADDRESS
	BND	4
DRNKNM	WS	2		:NETWORK_NAME
DRARPT	WS	1		:ASSOCIATED_RES_PTR
DRSSID	WS	1		:SESSION_ID
DRSMRL	WS	1		:SAVE_MU_FOR_RETRY_LIST
DRDDIG	WS	5		:DIAL_DIGITS FOR PERIPHERAL NODE
:	XID_IMAGE
:	----------
DRFSDA	WS	1		:FORMAT_SPECIFIC_DATA PTR
DRNDID	HS	3		:NODE_ID
DRIFMT	BS	1		:XID FORMAT
DRIPTY	BS	1		:PU TYPE
	BND	10
DRLENG	EQ	.


:	LINK STATION CONTROL BLOCK
:	--------------------------
:	ONE LSCB REPRESENTING THE LINK AS A WHOLE AND ONE LSCB
:	REPRESENTING EACH ADJACENT LINK STATION
	ORG	0
:	LSCB FOR A LINK
:	---------------
LSCBTY	BS	1		:LSCB_TYPE, 3 LINK, 4 ALS
LSDLTY	BS	1		:DLC_TYPE,1 SDLC,2 CHAN370
LSSTAT	BS	NLSFSM		:FSM STATE INFORMATION
LSLSFG	BS	1		:LOCAL STATION INFORMATION
				:BIT 0, 1 SWITCHED,0 NONSWITCHED
				:BIT 1, 1 TGCBPTR IS STATICALLY ASSIGNED
				:       0 TGCBPTR IS DYNAMICALLY ASSIGNED
				:BIT 2, 1 PRIMARY LOCAL STATION
				:BIT 3, 1 2-WAY SIMULTANEOUS
				:       0 2-WAY ALTERNATING
	BND	2
LSEA	HS	1		:ELEMENT ADDRESS OF LINK
LSLXBL	HS	1		:LONGEST BTU THIS STATION CAN RCV
LSASLG	HS	1		:BTU_SEND_LIST GET PTR
LSASLR	HS	1		:BTU_SEND_LIST RELEASE PTR
LSASLP	HS	1		:BTU_SEND_LIST PUT PTR
	BND	4
LSTGCB	WS	1		:POINTER TO TGCB
:	PARAMETERS OF ADJACENT LINK STATION
:	-----------------------------------
LSALSP	WS	1		:(POINTS TO CORRESPONDING LINK LSCB)
:LSASLS	WS	1		:LIST OF BTU'S TO TRANSMIT
LSAXBL	HS	1		:LONGEST BTU ADJACENT LINK CAN RCV
LSADLA	BS	1		:DLC ADDRESS IN BLU SENT TO THEALS
LSASFG	BS	1		:BIT 0, 1 PRIMARY
				:BIT 1, 1 2-WAY SIMULTANEOUS
:	PARAMETERS OF SDLC ERROR RECOVERY
:	---------------------------------
LSNS	BS	1		:SEND SEQUENCE # FOR OUTBOUND I FRAMES
LSNR	BS	1		:RCV SEQUENCE # FOR OUTBOUND FRAMES
LSLNRR	BS	1		:RCV SEQ # LAST RCV
LSNSCP	BS	1		:SEND SEQ # OF POLL
LSRJER	BS	1		:BIT 0, 1 SUPPORTED
	BND	2
LSXERT	HS	1		:MA ATTEMPTED RETRANSMISSIONS
LSIDSD	HS	1		:IDLE_STATE_DET
LSNPRR	HS	1		:NON_PROD_RCV
LSINAC	HS	1		:INACTIVITY
	BND	4
LSNSLO	WS	1		:OUTSTANDING CMD REQ EXPLICIT RSP
:	PARAMETERS OF CONTACT PROCEDURE
:	-------------------------------
LSCTST	BS	1		:STATUS CODE TO BE SENT IN CONTACTED
:	XID MOST RECENTLY SENT
:	----------------------
:	XID FORMAT 2 IS ILLUSTRATED IN FAPL
:	XID MOST RECENTLY RECEIVED
:	--------------------------
	BND	10
LSLENG	EQ	.

:	TRANSMISSION CONTROL CONTROL BLOCK
:	----------------------------------
	ORG	0
TCSTAT	BS	NTCFSM		:FSM STATES INFORMATION
TCCMPC	BS	1		:#PC FOR THE PC COMPONENT THAT MSGS 
				:PROCESSED WITH THIS CB ARE SENT TO
TCCBFG	BS	1		:BIT 0 -- SEND_PACING
				:BIT 1 -- RCV_PACING
	BND	2
TCPGCT	HS	1		:# OF RQ'S CAN BE SENT BEFORE RCV PACING RSP
TCWDSZ	HS	1		:SIZE OF PACING GROUP
TCQSPG	HS	1		:Q_PAC,SESSION LEVEL PACING Q OF MU'S (GET PTR)
TCQSPR	HS	1		:Q_PAC,SESSION LEVEL PACING Q OF MU'S (RELEASE)
	BND	4
TCMRRU	WS	1		:MAX_RCV_RU_SIZE
TCMSRU	WS	1		:MAX_SEND_RU_SIZE
:TCSLPQ	WS	1		:SESSION LEVEL PACING Q OF MU'S
	BND	10
TCLENG	EQ	.

:	DEFINE VALUE FOR THE BIT FLAG IN TCCB
:	-------------------------------------
TC.SPA	EQ	80		:BIT 0 FOR TCCBFG
TC.RPA	EQ	40		:BIT 1 FOR TCCBFG

:	TRANSMISSION GROUP CONTROL BLOCK LIST
:	-------------------------------------
:	THIS BLOCK IS MAINTAINED FOR EACH TRANSMISSION GROUP
	ORG	0
TGBBLK	WS	0		:START OF BLOCK
	BND	2
TGLFPT	HS	1		:PTR TO THE PREVIOUS TGCB (FOR LIST HANDLING)
TGNXPT	HS	1		:PTR TO THE NEXT TGCB
TGOBUC	HS	1		:OUTSTANDING_BTU_CNT (CNT OF SENT BTU'S PASSED
				:PASSED TO DLC FOR LINK STATIONS ASSIGNED
				:TO TG,THAT HAVE NOT BEEN SUCCESSFULLY XMT
TGSNFS	HS	1		:TG_SNF_SEND_CNTR,TG SEQ # FIED SEND CNT
TGSNFR	HS	1		:TG_SNF_RCV_CNTR, TG SEQ # FIED SEND CNT
TGSWAS	HS	1		:TG_SNF_WRAP_ACK_SEND_CNTR
TGSWAR	HS	1		:TG_SNF_WRAP_ACK_RCV_CNTR
TGQBRG	HS	1		:Q_BTU_RCV,GET PTR TO QUEUE
TGQBRR	HS	1		:Q_BTU_RCV,RELEASE PTR TO QUEUE
	BND	4
TGPSPL	WS	1		:PRTY_SEND_PIU_LIST
TGXBLS	WS	1		:RETRANSMIT_BTU_LIST
:TGQBTR	WS	1		:Q_BTU_RCV
TGRPLS	WS	1		:REFIFO_PIU_LIST
TGSPLS	WS	1		:SEND_BTU_PIU_VECTOR_LIST
:	TGC_WORKING_DATA
:	----------------
TGTRFG	BS	1		:BIT 0 -- TG_TRACE
TGSTAT	BS	NTGFSM		:FSM STATE INFORMATION
:	TG_FUNCTIONAL_ATTRIBUTES
:	------------------------
TGFFLG	BS	1		:BIT 0 -- MULTIPLE_LINK TG
				:BIT 1 -- PRE_ER_VR SUPPORT ER VR
				:BIT 2 -- BLOCKING SUPPORT
				:BIT 3 -- DEBLOCKING
	BND	2
TGMSBL	HS	1		:MAX_SEND_BTU_LENGTH
	BND	4
TGASLSL	WS	1		:ASSOC_LSCB_LIST
:	TG_ID
:	-----
TGCTGN	BS	1		:TRANSMISSION GROUP NUMBER
	BND	4
TGATSA	WS	1		:ADJ_SA (ADJ SUBAREA ADDR)
	BND	10
TGLENG	EQ	.
:	FLAG POSITION DEFINITION FOR TGCB
:	------------------------------------
TG.TRA	EQ	80		:TGTRFG BIT 0 TG_TRACE
TG.MLK	EQ	80		:TGFFLG BIT 0 MULTI_LINK_SUPP
TG.PEV	EQ	40		:TGFFLG BIT 1 ER_VR_SUPP
TG.BLK	EQ	20		:TGFFLG BIT 2 BLOCKING_SUPP
TG.DBK	EQ	10		:TGFFLG BIT 3 DEBLOCKING_SUPP

:	ASSOCIATED LSCB (ASSOC_LSCB_ENTITY) LIST
:	----------------------------------------
:	CONTAINS A LIST OF POINTERS TO ALL ADJACENT LINK STATION 
:	CONTROL BLOCKS THAT ARE CURRENTLY ACTIVE IN THE TRANSMISSION
:	GROUP
	ORG	0
ALSCBP	WS	1		:PTR TO THE LSCB FOR THIS ADJ LINK STATION

:	PIU VECTOR LIST
:	----------------
:	THIS BLOCK IS CREATED BY PATH CONTROL COMPONENTS TO
:	INDICATE THE LOCATION AND LENGTH OF A PIU TO BE TRANSMITTED
:	BY DLC
	ORG	0
	BND	2
PVPIUL	HS	1		:PIU_LENGTH, LENGTH OF PIU
	BND	4
PVPIUP	WS	1		:PIU_PTR, PTR TO PIU

:	VIRTUAL ROUTE CONTROL BLOCK LIST
:	--------------------------------
:	CONTAINS THE VIRTUAL ROUTE CONTROL BLOCKS
	ORG	0
VCBBLK	WS	0		:START OF BLOCK
	BND	2
VCLFPT	HS	1		:THE PREVIOUS VRCB PTR (FOR LIST HANDLING)
VCLNPT	HS	1		:THE NEXT VRCB PTR(FOR LIST HANDLING)
VCSNSC	HS	1		:SNF_SEND_CNTR
VCSNRC	HS	1		:SNF_RCV_CNTR
VCQVPG	HS	1		:Q_VR_PAC,GET PTR TO THE QUEUE
VCQVPR	HS	1		:Q_VR_PAC,RELEASE PTR TO THE QUEUE
	BND	4
VCPASA	WS	1		:PARTNER_SA (SA AT OTHER END OF VR)
:VCQVPC	WS	1		:Q_VR_PAC,PTR TO VR PACING QUEUE
VCPSLS	WS	1		:PIU_SEND_LIST
VCVRLS	WS	1		:VR_RESERVATION_LIST
VCSTAT	BS	NVCFSM		:FSM STATE INFORMATION
VCEVRS	BS	1		:ER_VR_SUPP
:	VR_ID
:	-------------------
VCVRID	BS	1		:BIT 0-3 -- VR NUMBER
				:BIT 4-5 -- RESERVED
				:BIT 6-7 -- TRANSMISSION PRIORITY
VCERNM	BS	1		:EXPLICIT ROUTE NUMBER
VCERRN	BS	1		:REVERSE EXPLICIT NUMBER
VCWDSZ	BS	1		:WINDOW_SIZE
VCMNWS	BS	1		:MIN_WINDOW_SIZE
VCMXWS	BS	1		:MAX_WINDOW_SIZE
VCWDSC	BS	1		:WINDOW_SIZE_CHANGE
VCPGCN	BS	1		:REMAINING #OF PIU'S THAT CAN BE SENT
VCCSVR	BS	1		:A CNT OF THE SESSIONS USING THE VR
	BND	10
VCLENG	EQ	.

:	VIRTUAL ROUTE RESERVATION LIST
:	------------------------------
:	THIS BLOCK STORES A SESSION ACTIVATION REQ THAT REQUIRES
:	A VR ACTIVATION
	ORG	0
VRCVLI	BS	1		:INDEX OF COS_VR_LIST
	BND	4
VRSARP	WS	1		:PTR TO SESSION ACTIVATION RQ
VRCVLP	WS	1		:PTR TO COS_VR_LIST
VRSCBP	WS	1		:PTR TO SCB
	BND	10
VRLENG	EQ	.

:	EXPLICIT ROUTE CONTROL BLOCK LIST
:	--------------------------------
:	THIS BLOCK CONTAINS THE EXPLICIT ROUTE CONTROL BLOCKS
	ORG	0
ECBBLK	WS	0		:BEGINNING OF BLOCK
ECSTAT	BS	NECFSM		:FSM STATE INFORMATION
ECERNM	BS	1		:EXPLICIT ROUTE NUMBER
ECNMTG	BS	1		:# OF TG IN THIS ER
ECEVRS	BS	1		:ER_VR_SUPP
	BND	2
ECRNMK	HS	1		:RERN_MASK
ECPNRN	HS	1		:PENDING_NRNUMBERS
	BND	4
ECPCEL	WS	1		:LIST OF PATHCB ENTITIES
ECSADE	WS	1		:SA AT OTHER END OF THE ER
	BND	10
ECLENG	EQ	.

:	PATH CONTROL BLOCK LIST
:	-----------------------
:	CONTAINS INF. ABOUT AN ER ALONG A PARTICULAR
:	ROUTE FROM THIS SUBAREA NODE
	ORG	0
PLSTAT	BS	NPLFSM		:FSM STATE INFORMATION
PLASID	BS	1		:ACT_SEQ_ID (SEQ ID FROM ACTIVATION RQ)
:	TG_ID
:	------
PLTGNM	BS	1		:TG NUMBER
	BND	4
PLAJSA	WS	1		:ADJACENT SUBAREA ADDRESS
	BND	10
PLLENG	EQ	.

:	SUBAREA ROUTING LIST
:	----------------------
:
	ORG	0
SRTGNE	BS	1		:TGN FOR THIS ERN AND DEST_SA
SRSDEF	BS	1		:STATIC (OR DYNAMIC) DEFINITION
	BND	4
SRDESA	WS	1		:SUBAREA ADDRESS
SRAJSA	WS	1		:NEXT SUBAREA FOR THIS ERN &DEST_SA
	BND	10
SRLENG	EQ	.

:	ERN MAP LIST
:	-------------
:	THIS PROVIDES A TWO-WAY MAPPING BETWEEN AN VRN AND AN ERN FOR
:	A GIVEN DSA
	ORG	0
EMERNM	BS	1		:ERN VALUE FOR THE DES SA AND VR NUMBER
	BND	4
EMDESA	WS	1		:DESTINATION SUBAREA FOR ER
	BND	10
EMLENG	EQ	.

:	VIRTUAL ROUTE IDENTIFIER LIST
:	-------------------------------
	ORG	0
VICOSN	BS	1		:CLASS OF SERVICE NAME
VILROT	BS	1		:LENGTH OF REMAINDER OF TABLE
VIFTVR	BS	1		:FORMAT OF VR INFORMATION
VIVRIN	BS	1		:NUMBER_OF_VR_IDS
VIVRNM	BS	1		:BIT 0-3 VIRTUAL ROUTE #
				:BIT 4-5 RESERVED
				:BIT 6-7 TRANSMISSION PRIORITY
VIVRTY	BS	1		:TYPE_OF_VR
	BND	10
VILENG	EQ	.

:	SESSION CONTROL BLOCK LIST
:	--------------------------
:	THIS BLOCK MAINTAINS THE STATUS OF PARTICULAR HALF-SESSION
	ORG	0
SCTCCB	HS	1		:POINTER TO TCCB
SCBREL	BS	1		:REL. # OF SESION CONTROL IN THIS PU
SCSTAT	BS	NSCFSM		:FSM STATE INFORMATION
SCSVMV	BS	1		:SVC_MGR GENERIC VALUES
SCFSMS	BS	1		:#FSM_SESS
SCMYID	BS	1		:LOCAL ID OF NAU OF THIS SESSION
SCOTID	BS	1		:LOCAL ID OF NAU WITH OTHER END OF SESSION
SCLSID	BS	1		:LOCAL SESSION ID FOR FID3
SCPNTY	BS	1		:PERIPHERAL NODE TYPE
SCSSTY	BS	1		:TYPE OF SESSION
				:0,SSCP_PU 1,SSCP_LU 2,SSCP_SSCP
				:3,LU_LU 4,PUCP_PU
SCACFG	BS	1		:BIT 0 -- 1,PRI 0,SEC
				:BIT 1 -- PU_FMD_RU_USAGE (REQ_RCV)
				:BIT 7 -- SESSION TYPE 0,HALF 1,BF_SESS
:	TC_VARIABLES
:	------------
SCFMRQ	BS	1		:FSM_RQR
SCFMST	BS	1		:FSM_STSN
SCFMDT	BS	1		:FSM_DT
SCFMCR	BS	1		:FSM_CRV
	BND	4
SCNYSA	WS	1		:SUBAREA ADDRESS
SCPTSA	WS	1		:SUBAREA ADDRESS
SCARSI	WS	2		:ACT_RQ_RSP_SEQ_ID
:	ENTITY POINT
:	---------------
SCPRSP	WS	1		:PAC_RSP_SIGNAL_PTR
:	DFC VARIABLES
:	--------------
SCSNBR	WS	1		:SNC_BSM_RCVD
SCSNBS	WS	1		:SNC_BSM_SEND
SCSNHR	WS	1		:SNC_HDX_RCVD
SCSNHS	WS	1		:SNC_HDX_SEND
	IF	FWBBF
SCMUPS	WS	1		:MU_PTR_SAVE
SCPPUP	WS	1		:PARTIAL PIU PTR
	ELSE
SCMUPS	HS	1		:MU_PTR_SAVE
SCPPUP	HS	1		:PARTIAL PIU PTR
	EI
:	TC_VARIABLES
:	---------------
SCSTBC	HS	1		:SEC_TO_BF_TC_CB__PTR
SCVRBP	HS	1		:PTR TO VRCB FOR THIS SESSION
SCLCSN	HS	1		:LAST_CLEAR_SNF
SCSNSF	HS	1		:SEND_NORM_SNF (LAST SENT BYT PU_T1)
SCSESN	HS	1		:SEND_EXP_SNF (LAST SENT BY PU_T1)
SCSQRC	HS	1		:SQN_RCV_CNT,N. FLOW SNF EXPECTED
SCRESN	HS	1		:RCV_EXP_SNF,LAST E. FLOW SNF SENT TO T1
:	PARTNER NAU (ASSOCIATED WITH OTHER END OF SESSION)
:	--------------------------------------------------
SCPTEA	HS	1		:ELEMENT ADDRESS
:	THIS NAU (ASSOCIATED WITH THIS END OF SESSION)
:	----------------------------------------------
SCMYEA	HS	1		:ELEMENT ADDRESS
SCAJEA	HS	1		:ALS ELEMENT ADDR FOR P.NODE
SCQTDG	HS	1		:Q_TC_TO_DFC,GET PTR TO QUEUE
SCQTDR	HS	1		:Q_TC_TO_DFC,RELEASE PTR TO QUEUE
:	CORRELATION TABLE
:	-----------------
SCTREG	HS	1		:CT_RCV_RQ_EXP,GET PTR
SCTRER	HS	1		:CT_RCV_RQ_EXP,RELEASE PTR
SCTRNG	HS	1		:CT_RCV_RQ_NORM,GET PTR
SCTRNR	HS	1		:CT_RCV_RQ_NORM,RELEASE PTR
SCTSEG	HS	1		:CT_SEND_RQ_EXP,GET PTR
SCTSER	HS	1		:CT_SEND_RQ_EXP,RELEASE PTR
SCTSNG	HS	1		:CT_SEND_RQ_NORM,GET PTR
SCTSNR	HS	1		:CT_SEND_RQ_NORM,RELEASE PTR
:	ENTITY POINTER
:	--------------
SCRREE	HS	1		:CT_RCV_RQ_EXP_ENTRY_PTR
SCSREE	HS	1		:CT_SEND_RQ_EXP_ENTRY_PTR
SCTNPT	HS	1		:CT_NORM_ENTRY_PTR
:	DFC_VARIABLE
:	----------------
SCSCNP	HS	1		:SCAN_PTR
SCTPTG	HS	1		:CT_PTR,GET PTR
SCTPTR	HS	1		:CT_PTR,RELEASE PTR
SCKEYY	HS	1		:KEY
SCSQSC	HS	1		:SQN_SEND_CNT
SCESQN	HS	1		:SQN FOR EXPEDITED FLOW
SCADJR	HS	1		:SQN ADJUST IN RECEIVING DIRECTION
SCADJS	HS	1		:SQN ADJUST IN SENDING DIRECTION
SCLUWK	HS	1		:SQN ADJUST WORKING AREA
:SCLRPN	HS	1		:LAST RESPONSE FOR CORR. TABLE(6/27/84/CHS)
SCBLUC	HS	1		:LUC OFFSET (6/27/84/CHS)
:	DFC REQUEST FOR THIS HALF_SESSION
:	---------------------------------
:	DFC_NORMAL_REQUEST
:	-------------------
SCDFNR	HS	1		:0 NOT ALLOWED, 1 ALLOWED
				:BIT 0 -- DFC_BID_RCV
				:BIT 1 -- DFC_BID_SEND
				:BIT 2 -- DFC_BIS_RCV
				:BIT 3 -- DFC_BIS_SEND
				:BIT 4 -- DFC_CANCEL_RCV
				:BIT 5 -- DFC_CANCEL_SEND
				:BIT 6 -- DFC_CHASE_RCV
				:BIT 7 -- DFC_CHASE_SEND
				:BIT 8 -- DFC_LUSTAT_RCV
				:BIT 9 -- DFC_LUSTAT_SEND
				:BIT10 -- DFC_QC_RCV
				:BIT11 -- DFC_QC_SEND
				:BIT12 -- DFC_RTR_RCV
				:BIT13 -- DFC_RTR_SEND
SCDFER	HS	1		:0 NOT ALLOWED, 1 ALLOWED
				:BIT 0 -- DFC_QEC_RCV
				:BIT 1 -- DFC_QEC_SEND
				:BIT 2 -- DFC_RELQ_RCV
				:BIT 3 -- DFC_RELQ_SEND
				:BIT 4 -- DFC_RSHUTD_RCV
				:BIT 5 -- DFC_RSHUTD_SEND
				:BIT 6 -- DFC_SBI_RCV
				:BIT 7 -- DFC_SBI_SEND
				:BIT 8 -- DFC_SHUTC_RCV
				:BIT 9 -- DFC_SHUTC_SEND
				:BIT10 -- DFC_SHUTD_RCV
				:BIT11 -- DFC_SHUTD_SEND
				:BIT12 -- DFC_SIG_RCV
				:BIT13 -- DFC_SIG_SEND
SCSSID	HS	3		:THIS HALF SESSION SSCP ID
SCSPID	HS	3		:PARTNER SESSION SSCP ID
:	DFC_MISC_SESSION_PARAMETERS
:	---------------------------
SCMSSP	BS	1		:BIT 0 -- 1 YES (USING BRACKETS)
				:BIT 1 -- 1 YES (FIRST SPEAKER)
				:BIT 2 -- 1 DELAYED (MY SESSION REQ MODE)
				:BIT 3 -- 1 DELAYED (PARTNER SESSION REQ MOD)
				:BIT 4 -- 1 DELAYED (MY SESSION RSP MODE)
				:BIT 5 -- 1 DELAYED (PARTNER SESSION RSP MODE)
:	DFC_FSM_USAGE
:	-------------
SCFBSM	BS	1		:FSM_BSM
SCFCHR	BS	1		:FSM_CHAIN_RCV
SCFCHS	BS	1		:FSM_CHAIN_SEND
SCFCBR	BS	1		:FSM_CONTROL_BSM_RSP_RCV
SCFCBS	BS	1		:FSM_CONTROL_BSM_RSP_SEND
SCHDRR	BS	1		:FSM_CONTROL_HDX_RSP_RCV
SCHDRS	BS	1		:FSM_CONTROL_HDX_RSP_SEND
SCFEBR	BS	1		:FSM_EBCD_RCV
SCFEBS	BS	1		:FSM_EBCD_SEND
SCFHDX	BS	1		:FSM_HDX
SCFIRR	BS	1		:FSM_IMM_RQ_MODE_RCV
SCFIRS	BS	1		:FSM_IMM_RQ_MODE_SEND
SCFQER	BS	1		:FSM_QEC_RCV
SCFQES	BS	1		:FSM_QEC_SEND
SCFQCR	BS	1		:FSM_QRI_CHAIN_RCV
SCFQCS	BS	1		:FSM_QRI_CHAIN_SEND
SCFQKS	BS	1		:FSM_QRI_CHECK_SEND
SCFRES	BS	1		:FSM_RES
SCFRTR	BS	1		:FSM_RTR
SCFSBR	BS	1		:FSM_SBI_RCV
SCFSBS	BS	1		:FSM_SBI_SEND
SCFSHT	BS	1		:FSM_SHUTD
SCCTET	BS	1		:CT_ENTRY

:	THE FOLLOWING PARAMETERS ARE OBTAINED FROM THE ACTIVATION
:	RU AND TS,FM PROFILES BY PU.SVC_MGR.CSC_MGR
:	-----------------------------------------------------------
:	BYTE 2 OF "BIND"
:	----------------
SCFMPF	BS	1		:FM_PROFILE
:	BYTE 3 OF "BIND"
:	----------------
SCTSPF	BS	1		:TS_PROFILE
:	BYTE 4 OF "BIND" PRIMARY LU PROTOCOL
:	------------------------------------
SCPLUP	BS	1		:BIT 0 -- SINGLE CHAIN OR MULTIPLE
				:BIT 1 -- IMMEDIATELY OR DELAY
				:BIT 2-3 --
				:BIT 4 -- 2-PHASE COMMIT SUPPORT OR NOT
				:BIT 6 -- COMPRESSION OR NO-COMPRESSION
				:BIT 7 -- SEND OR NOT SEND EB
:	BYTE 5 OF "BIND" SECONDARY LU PROTOCOL
:	--------------------------------------
SCSLUP	BS	1		:BIT 0 -- SINGLE CHAIN OR MULTIPLE
				:BIT 1 -- IMMEDIATELY OR DELAY
				:BIT 2-3 --
				:BIT 4 -- 2-PHASE COMMIT SUPPORT OR NOT
				:BIT 6 -- COMPRESSION OR NO-COMPRESSION
				:BIT 7 -- SEND OR NOT SEND EB
:	BYTE 6 OF "BIND" COMMON LU PROTOCOL
:	-----------------------------------
SCCLUP	BS	1		:BIT 1 -- FM_HEADER ALLOWED OR NOT
				:BIT 2 -- BRACKETS RESET STATE
				:BIT 3 -- BRACKETS TERMINATION RULE
				:BIT 4 -- ALTERNATE CODE SET ALLOWED OR NOT

:	BYTE 7 OF "BIND" 
:	-----------------
SCSRMD	BS	1		:BIT 0-1 -- 00,FULL DUPLEX
				:           01, HD CONTENTION
				:           10, HD FLIP-FLOP
				:           11, RESERVED
				:BIT 2 -- 0, LOSER RESPONSIBLE
				:         1, SYMMETRIC 
				:BIT 3 -- 0, SECONDARY IS CONTENTION WINNER
				:         1, PRIMARY IS CONTENTION WINNER
				:BIT 7 -- 0, HDX_FF RESET STATE IS SEND FOR SEC
				:         1, HDX_FF RESET STATE IS SEND FOR PRI
:	BYTE 8 OF "BIND" TS USAGE
:	-------------------------
SCTSUG	BS	1		:BIT 0 -- 0,PACING IS 1-STAGE (FROM SEC TO PRI)
				:         1,PACING IS 2_STAGE (FROM SEC TO PRI)
				:BIT 1-7,SEC_RCV_PACING_CNT
:	BYTE 9 OF "BIND" 
:	----------------
SCSRPC	BS	1		:SEC SEND PACING CNT
:	BYTE 10 OF "BIND"
:	--------------------
SCSMRU	BS	1		:SEC SEND MAX RU SIZE
:	BYTE 11 OF "BIND"
:	------------------
SCPMRU	BS	1		:PRI SEND MAX RU SIZE
:	BYTE 12 OF "BIND"
:	-----------------
SCTPUG	BS	1		:BIT 0 -- 0, PACING IS 2-STAGE (PRI TO SEC)
				:         1, PACING IS 1-STAGE (PRI TO SEC)
				:BIT 1-7,PRI_SEND_PACING_CNT
:	BYTE 13 OF "BIND"
:	------------------
SCPRPC	BS	1		:PRIMARY RECEIVING PACING CNT
:	BYTE 14 OF "BIND"
:	-----------------
SCPSUF	BS	1		:PS_USAGE_FORMAT 0,BASIC
				:PS_USAGE_FORMAT 1,RESERVED
				:(1-7 BIT)LU_LU SESSION TYPE
:	BYTE 15 TO 25 OF "BIND"
:	----------------------
SCPSLG	EQ	0B		:LENGTHOF PS USAGE FIELD
SCPSUG	BS	SCPSLG		:PS USAGE CHARACTERISTICS
:	BYTE 26 OF "BIND"
:	------------------
SCCYSL	BS	1		:CRYPTOGRAPHY_SESSION_LEVEL
:	BYTE 27 OF "BIND"
:	----------------
SCCYEM	BS	1		:BIT 0-1,CRYPTOGRAPHY_KEY_ENCIPH_METHOD
				:BIT 5-7,CRYPTOGRAPHY_CIPHER_METHOD
:	BYTE 28 TO 34 OF "BIND"
:	-----------------------
SCCYKF	BS	8		:CRYPTOGRAPHY KEY FIELD
:	THE FOLLOWING PARAMETERS ARE OBTAINED FROM THE TS,FM
:	PROFILES BY PU.SVC_MR.CSC_MGR
:	----------------------------------------------------
SCSQUS	BS	1		:SQN_USAGE 00,IDENTIFIERS
				:         01,SEQUENCE NUMBER
				:         10,NO_SEQUENCE
SCTFFG	BS	1		:BIT 0 -- 0,IMMEDIATE 1,DELAYED(PRI_RSP_MODE)
				:BIT 1 -- 0,IMMEDIATE 1,DELAYED (SEC_RSP_MODE)
				:BIT 2 -- 0,NOT ALLOWED 1,ALLOWED (SC_CLEAR)
				:BIT 3 -- 0,NOT ALLOWED 1,ALLOWED (SC_RQR)
				:BIT 4 -- 0,NOT ALLOWED 1,ALLOWED (SC_SDT)
				:BIT 5 -- 0,NOT ALLOWED 1,ALLOWED (SC_STSN)
				:BIT 6 -- 0,NOT ALLOWED 1,ALLOWED (SC_CRV)
:	CHAIN_RSP
:	---------
SCCHRP	BS	1		:CHAIN_RSP_FOR_PRIMARY,0 NOT ALLOWED,1 ALLOWED
				:BIT 0 -- PRI_NO_RSP_CHAIN
				:BIT 1 -- PRI_EXCP_RSP_CHAIN
				:BIT 2 -- PRI_DEF_RSP_CHAIN
SCCHRS	BS	1		:CHAIN_RSP_FOR_SECONDARY,0 NOT ALLOWED,1 ALLOWED
				:BIT 0 -- SEC_NO_RSP_CHAIN
				:BIT 1 -- SEC_EXCP_RSP_CHAIN
				:BIT 2 -- SEC_DEF_RSP_CHAIN
	BND	10
SCLENG	EQ	.

:	DEFINE BIT POSITIONS FOR ALL THE FLAGS IN THE SCB
:	-------------------------------------------------
:	BIT DEFINITION FOR CHAIN_RSP
:	----------------------------
SC.NRC	EQ	80		:PRI(SEC)_NO_RSP_CHAIN,ALLOWED(SET)
SC.ERC	EQ	40		:PRI(SEC)_EXCP_RSP_CHAIN,ALLOWED(SET)
SC.DRC	EQ	20		:PRI(SEC)_DEF_RSP_CHAIN,ALLOWED(SET)
:	BIT DEFINITION FOR STAGING_IND
:	-------------------------------
SC.STG	EQ	80		:BIT 0 IN SCTSUG,OR SCTPUG
:	BIT DEFINITION FOR SCSLUP
:	-------------------------
SC.SCU	EQ	80		:SCSLUP BIT 0 FOR SEC_CHAIN_USE
SC.SID	EQ	40		:SCSLUP BIT 1 FOR SEC_RQ_MODE
SC.S2P	EQ	08		:SCSLUP BIT 4 FOR SEC_TWO_PHASE_COMMIT
SC.SCP	EQ	02		:SCSLUP BIT 6 FOR SEC_COMPR_IND
SC.SEB	EQ	01		:SCSLUP BIT 7 FOR SEC_EB_IND
:	BIT DEFINITION FOR SCPLUP (BIND BYTE-4)
:	---------------------------------------
SC.PCU	EQ	80		:SCPLUP BIT 0 FOR PRI_CHAIN_USE
SC.PID	EQ	40		:SCPLUP BIT 1 FOR PRI_RQ_MODE
SC.P2P	EQ	08		:SCPLUP BIT 4 FOR PRI_TWO_PHASE_COMMIT
SC.PCP	EQ	02		:SCPLUP BIT 6 FOR PRI_COMPR_IND
SC.PEB	EQ	01		:SCPLUP BIT 7 FOR PRI_EB_IND
:	BIT DEFINITION FOR SCCLUP (BIND BYTE-6)
:	---------------------------------------
SC.FMH	EQ	40		:SCCLUP BIT 1 FOR FM_HDR_USAGE
SC.BRS	EQ	20		:SCCLUP BIT 2 FOR BRACKETS_RESET_STATE
SC.BTR	EQ	10		:SCCLUP BIT 3 FOR RKT_TERM_RULE
SC.ALC	EQ	08		:SCCLUP BIT 4 FOR ALT_CODE
:	BIT DEFINITION FOR SCSRMD (BIND BYTE-7)
:	----------------------------------------
SC.SRM	EQ	0C0		:SCSRMD BIT 0,1 FOR SEND_RCV_MODE
SC.RVR	EQ	020		:SCSRMD BIT 2 FOR RECOVERY_RESP
SC.CWN	EQ	010		:SCSRMD BIT 3 FOR CONT_WIN
SC.HFS	EQ	001		:SCSRMD BIT 7 FOR HDX_FF_RESET_STATE
:	BIT DEFINITION FOR SCTFFG (FROM TS,FM PROFILE)
:	----------------------------------------------
SC.PSM	EQ	80		:SCTFFG BIT 0 FOR SCB.PRI_RSP_MODE
SC.SSM	EQ	40		:SCTFFG BIT 1 FOR SCB.SEC_RSP_MODE
SC.CLR	EQ	20		:SCTFFG BIT 2 FOR SCB.SC_CLEAR
SC.RQR	EQ	10		:SCTFFG BIT 3 FOR SCB.SC_RQR
SC.SDT	EQ	08		:SCTFFG BIT 4 FOR SCB.SC_SDT
SC.STN	EQ	04		:SCTFFG BIT 5 FOR SCB.SC_STSN
SC.CRV	EQ	02		:SCTFFG BIT 6 FOR SCB.SC_CRV
:	BIT DEFINITION FOR SCACFG
:	-------------------------
SC.SES	EQ	80		:SCACFG BIT 0 FOR SCB.HALF_SESSION
SC.PFR	EQ	40		:PU_FMD_RU_USAGE
SC.BFS	EQ	01		:SCACFG BIT 7 FOR BF_SESS
:	BIT DEFINITION FOR SCMSSP (DFC_MISC_SESSION_PARAMETERS
:	------------------------------------------------------
SC.UBK	EQ	80		:SCMSSP BIT 0 USING_BRACKETS
SC.1SP	EQ	40		:SCMSSP BIT 1 FIRST_SPEAKERS
SC.MQM	EQ	20		:SCMSSP BIT 2 FOR THIS_HALF_SESSION_RQ_MODE
SC.PQM	EQ	10		:SCMSSP BIT 3 FOR PARTNER_HALF_SESSION_RQ_MODE
SC.MSM	EQ	08		:SCMSSP BIT 4 FOR THIS_HALF_SESSION_RSP_MODE
SC.OSM	EQ	04		:SCMSSP BIT 5 FOR PARTNER_HALF_SESSION_RSP_MODE
SC.BDR	EQ	8000		:SCDFNR	BIT 00 FOR DFC_BID_RCV
SC.BDS	EQ	4000		:SCDFNR	BIT 01 FOR DFC_BID_SEND
SC.BSR	EQ	2000		:SCDFNR	BIT 02 FOR DFC_BIS_RCV
SC.BSS	EQ	1000		:SCDFNR	BIT 03 FOR DFC_BIS_SEND
SC.CNR	EQ	0800		:SCDFNR	BIT 04 FOR DFC_CANCEL_RCV
SC.CNS	EQ	0400		:SCDFNR	BIT 05 FOR DFC_CANCEL_SEND
SC.CHR	EQ	0200		:SCDFNR	BIT 06 FOR DFC_CHASE_RCV
SC.CHS	EQ	0100		:SCDFNR	BIT 07 FOR DFC_CHASE_SEND
SC.LSR	EQ	0080		:SCDFNR	BIT 08 FOR DFC_LUSTAT_RCV
SC.LSS	EQ	0040		:SCDFNR	BIT 09 FOR DFC_LUSTAT_SEND
SC.QCR	EQ	0020		:SCDFNR	BIT 10 FOR DFC_QC_RCV
SC.QCS	EQ	0010		:SCDFNR	BIT 11 FOR DFC_QC_SEND
SC.RTR	EQ	0008		:SCDFNR	BIT 12 FOR DFC_RTR_RCV
SC.RTS	EQ	0004		:SCDFNR	BIT 13 FOR DFC_RTR_SEND
SC.QER	EQ	8000		:SCDFER	BIT 00 FOR DFC_QEC_RCV
SC.QES	EQ	4000		:SCDFER	BIT 01 FOR DFC_QEC_SEND
SC.RLR	EQ	2000		:SCDFER	BIT 02 FOR DFC_RELQ_RCV
SC.RLS	EQ	1000		:SCDFER	BIT 03 FOR DFC_RELQ_SEND
SC.RSR	EQ	0800		:SCDFER	BIT 04 FOR DFC_RSHUTD_RCV
SC.RSS	EQ	0400		:SCDFER	BIT 05 FOR DFC_RSHUTD_SEND
SC.SBR	EQ	0200		:SCDFER	BIT 06 FOR DFC_SBI_RCV
SC.SBS	EQ	0100		:SCDFER	BIT 07 FOR DFC_SBI_SEND
SC.SCR	EQ	0080		:SCDFER	BIT 08 FOR DFC_SHUTC_RCV
SC.SCS	EQ	0040		:SCDFER	BIT 09 FOR DFC_SHUTC_SEND
SC.SDR	EQ	0020		:SCDFER	BIT 10 FOR DFC_SHUTD_RCV
SC.SDS	EQ	0010		:SCDFER	BIT 11 FOR DFC_SHUTD_SEND
SC.SGR	EQ	0008		:SCDFER	BIT 12 FOR DFC_SIG_RCV
SC.SGS	EQ	0004		:SCDFER	BIT 13 FOR DFC_SIG_SEND

:	CANONICAL MESSAGE UNIT DEFINITION
:	---------------------------------
:	THE CANONICAL MESSAGE UNIT COMBINES ALL FID TYPES AND HAS ALL
:	THE FIELDS OF A PIU
:	THE MESSAGE UNIT CONTROL BLOCK IS USED TO CONTAIN INFORMATION
:	RELATED TO A MESSAGE UNIT AS IT FLOWS THROUGH A NODE. THE MUCB
:	IS CREATED AND DISCARDED WITH THE MESSAGE UNIT
:	MUCB_PTR-->MUCB (MUCB CONTAINTS + RU_PTR + PIU_PTR)
	ORG	0
MUXIDL	BS	2		:LENGTH OF XID,SET ONLY WHEN XID FLAG ON
MUMISC	BS	1		:BIT 0 - TG_SEND_PRTY WORKING PRTY
				:BIT 1 - LOST DATA INDICATOR
				:BIT 2 - RU IS XID,TH&RH NOT MEANINGFUL
				:BIT 6-7 - 00(NOT)01(PUCP_TO_PU)10(PU_TO_PUCP)
				:	11(RESERVED)
MUSCHK	BS	1		:INDICATES SNED_CHECK_SENSE IS SET
	BND	4
MURHSN	WS	1		:SENSE DATA,IF SDI=SD
MUSCKS	WS	1		:SEND_CHECK_SENSE, SENSE FIELDS ARE USED TO
				:COMMUNICATE TO THE END USER IN THIS NODE 
				:WHEN ERROR OCCURED
MURCKS	WS	1		:RECEIVE_CHECK_SENSE
:	TH FIELD INFORMATION
:	--------------------
MUDSAF	WS	1		:DESTINATION SUBAREA FIELD
MUOSAF	WS	1		:ORIGIN SUBAREA FIELD
	IF	FWBBF
MURUPT	WS	1		:RU DATA BUFFER PTR
MUCBTU	WS	1		:SAVE PTR FOR BTUCB+BTU,THE PURPOSE
	ELSE
MURUPT	HS	1		:RU DATA BUFFER PTR
MUCBTU	HS	1		:SAVE PTR FOR BTUCB+BTU,THE PURPOSE
				:TO DISCARD BTU PTR AT THE END OF MU PROCESSING
	EI
MUDEAF	HS	1		:DESTINATION ELEMENT FIELD
MUOEAF	HS	1		:ORIGIN ELEMENT FIELD
MUDADF	HS	1		:DESTINATION ADDRESS FIELD
MUOADF	HS	1		:ORIGIN ADDRESS FIELD
MUSNF	HS	1		:SEQUENCE NUMBER FIELD
MUDCF	HS	1		:DATA COUNT FIELD
MUTGSN	HS	1		:TG_SNF,USED BY VR,TG_NOFIFO_IND=1
MUVSNS	HS	1		:VR_SNF_SEND, SEND SEQUENCE NUMBER
MUCSQN	HS	1		:CMD_SEQ_NUM, FIDF COMMAND SEQUENCE NUMBER
MUDADP	BS	1		:DAFPRIME DESTINATION ADDRESS FIELD
MUOADP	BS	1		:OAFPRIME ORIGIN ADDRESS FIELD
MULSID	BS	1		:LSID
				:BIT 0 -- LU_PU_IND 0=PU,1=LU
				:BIT 1 -- LU_SSCP_IND 0=SSCP,1=LU
				:BIT 2-7 -- LOCAL ADDRESS
MUVRF2	BS	1		:BIT 0-3 INITIAL ERN
				:BIT 4-7 EXPLICIT ROUTE NUMBER
MUVRF3	BS	1		:BIT 0-3 VIRTUAL ROUTE NUMBER
				:BIT 6-7 TRANSMISSION PRIORITY FIELD
MUVRF4	BS	1		:FLAG FOR VR
				:BIT 0 -- 1=DECR RQ ON, 0=OTHERWISE
				:BIT 1 -- 1=NOT TG REFIFO, 0=TG REFIFO
				:BIT 2,3-00(NSEQ_NSUP)01(NSEQ_SUP)10 (SING_SEQ)
MUVRF6	BS	1		:FLAG FOR TH BYTE 6
				:BIT 0 -- 1=VR PACING RQ ON, 0=OFF
				:BIT 1 -- 1=VR PACING RSP ON, 0=OFF
				:BIT 2 -- 1=DECR WINDOW BY 1,0=INCR WINDOW BY 1
				:BIT 3 -- 1=RESET WINDOW TO 1, 0=OTHERWISE
				:BIT 6 -- 0=PRE_SNA, 1=OTHERWISE
MUBIU4
MUBIUF	BS	1		:BIU FLAG
				:BIT 0-3 FOR FID TYPE
:	FID0,FID1,FID2,FID3 1ST TH BYE CONTAINTS ARE DEFINED AS FOLLOWS
				:BIT 4 -- BEGIN BIU SEGMENTING FLAG
				:BIT 5 -- END BIU SEGMENTING FLAG
				:BIT 7 -- EXPEDITED FLOW INDICATOR
:	FID4 1ST TH BYE CONTAINTS ARE DEFINED AS FOLLOWS
				:BIT 4 -- TG_SWEEP (THIS PIU DOESN'T
				:OVERTAKE OTHER)
				:BIT 5 -- PRE_ER_VR=NODE ON ROUTE NOT SUPPORT
				:ER VR
				:BIT 6 -- PAC_CNT_0=VR PACING CNT HAS REACHED 0
				:BIT 7 -- NTWK_PRTY=PIU FLOWS AT NETWORK
				:PRIORITY
MUCFOM	BS	1		:FIDF,1=TG_CMD
MUCTYP	BS	1		:FIDF,1=TG_SNF_WRAP_ACK
:	RH FIELD INFORMATION
:	--------------------
MURHF1	BS	1		:BIT 0 -- RQ=REUQEST,RSP=RESPONSE
				:BIT 1,2 -- RU CATEGORY
				:BIT 4 -- 1=FMH OR NSH
				:BIT 5 -- SD=SENSE DATA INCLUDED
				:BIT 6 -- BC=FIRST IN CHAIN
				:BIT 7 -- EC=LAST IN CHAIN
MURHF2	BS	1		:BIT 0 -- DR1I
				:BIT 2 -- DR2I
				:BIT 3 -- ERI
				:BIT 6 -- QR=ENQUEUE RESPONSE IN TC Q
				:BIT 7 -- PAC=PACING RESPONSE
MURHF3	BS	1		:BIT 0 -- BB=BEGIN BRACKET
				:BIT 1 -- EB=END BRACKET
				:BIT 2 -- CD=CHANGE DIRECTION
				:BIT 4 -- ENCODING IS USED,CODE0 OR CODE1
				:BIT 5 -- ED=RU IS ENCIPHERED
				:BIT 6 -- PD=RU IS PADDED
MUDIRE	BS	1		:DIRECTION,0 SEND,1 RECEIVE
	BND	10
MULENG	EQ	.

:	DEFINE GENERAL PURPOSE DATA FOR MUCB
:	------------------------------------
MU.NSP	EQ	00		:PUCP_BASED_SESSION (NOT SUPPORTED)
MU.PUC	EQ	01		:PUCP_BASED_SESSION (PUCP_TO_PU)
MU.PUT	EQ	02		:PUCP_BASED_SESSION (PU_TO_PUCP)
MU.RES	EQ	03		:PUCP_BASED_SESSION (RESERVED)

:	DEFINE THE BIT POSITIONS FOR ALL THE FLAGS IN THE MU
:	----------------------------------------------------
MU.TSP	EQ	80		:MUMISC BIT 0 (TG_SEND_PRTY)
MU.LDI	EQ	40		:MUMISC BIT 1 (LOST DATA IND.)
MU.XID	EQ	20		:MUMISC BIT 2 (RU IS XID)
MU.PBS	EQ	03		:MUMISC BIT 6-7 (PUCP_BASED_SESSION)
MU.FMD	EQ	0		:FMD DATA IN THE RH
MU.DFC	EQ	40		:DFC  VALUE IN THE RH
MU.NC	EQ	20		:NC VALUE IN THE RH
MU.SC	EQ	60		:SC VALUE IN THE RH
MU.LPI	EQ	80		:MULSID BIT 0 FOR LU_PU_IND
MU.LSI	EQ	40		:MULSID BIT 1 FOR LU_SSCP_IND
MU.VCQ	EQ	80		:MUVRFG BIT 0 FOR VR_CWI
MU.TNI	EQ	40		:MUVRFG BIT 1 FOR TG_NONFIFO_IND
MU.VPQ	EQ	20		:MUVRFG BIT 2 FOR VRPRQ
MU.VPS	EQ	10		:MUVRFG BIT 3 FOR VRPRS
MU.VCW	EQ	08		:MUVRFG BIT 4 FOR VR_CWRI
MU.VRW	EQ	04		:MUVRFG BIT 5 FOR VR_RWI
MU.SNA	EQ	02		:MUVRFG BIT 6 FOR SNAI
MU.FID	EQ	0F0		:MUBIUF BIT 0-3 FOR FID
MU.BIU	EQ	08		:MUBIUF BIT 4 FOR BBIUI
MU.EIU	EQ	04		:MUBIUF BIT 5 FOR EBIUI
MU.EFI	EQ	01		:MUBIUF BIT 7 FOR EFI
MU.TGS	EQ	08		:MUBIUF BIT 4 FOR TG_SWEEP
MU.EVS	EQ	04		:MUBIUF BIT 5 FOR ER_VR_SUPP_IND
MU.PCI	EQ	02		:MUBIUF BIT 6 FOR VR_PAC_CNT_IND
MU.PRT	EQ	01		:MUBIUF BIT 7 FOR NTWK_PRTY
MU.RRI	EQ	80		:MURHF1 BIT 0 FOR RRI
MU.CTG	EQ	60		:MURHF1 BIT 1,2 FOR RU CATEGORY
MU.FI	EQ	08		:MURHF1 BIT 4 FOR FI
MU.SDI	EQ	04		:MURHF1 BIT 5 FOR SDI
MU.BCI	EQ	02		:MURHF1 BIT 6 FOR BCI
MU.ECI	EQ	01		:MURHF1 BIT 7 FOR ECI
MU.DR1	EQ	80		:MURHF2 BIT 0 FOR DR1I
MU.DR2	EQ	20		:MURHF2 BIT 2 FOR DR2I
MU.ERI	EQ	10		:MURHF2 BIT 3 FOR ERI (REQUEST HEADER)
MU.RTI	EQ	10		:MURHF2 BIT 3 FOR ERI (RESPONSE HEADER)
MU.QRI	EQ	02		:MURHF2 BIT 6 FOR QRI
MU.PI	EQ	01		:MURHF2 BIT 7 FOR PI
MU.BBI	EQ	80		:MURHF3 BIT 0 FOR BBI
MU.EBI	EQ	40		:MURHF3 BIT 1 FOR EBI
MU.CDI	EQ	20		:MURHF3 BIT 2 FOR CDI
MU.CSI	EQ	08		:MURHF3 BIT 4 FOR CSI
MU.EDI	EQ	04		:MURHF3 BIT 5 FOR EDI
MU.PDI	EQ	02		:MURHF3 BIT 6 FOR PDI
:	ADJUSTMENT BIT POSITION FOR HEADER INFORMATION
:	--------------------------------------------------
AD.FID	EQ	4		:BIT POSITION 0-3 FOR TH_FID FIELD
AD.BIU	EQ	3		:BIT POSITION 4 FOR THE_BIU FIELD
AD.FMP	EQ	4		:BIT POSITION 0-3 FOR FM_PROFILE (IN ACTLU)
AD.FMT	EQ	4		:BIT POSITION FOR ACTPU(RSP) FORMAT
AD.CNR	EQ	4		:BIT POSITION FOR BIND CHAIN RSP

:	DISPATCHING QUEUE ENTRY (DQE)
:	-----------------------------
:	THIS BLOCK IS CREATED BY THE SEND COMMAND AND PLACED ON THE
:	DISPATCHING QUEUE. IT IS REMOVED FROM DISPATCHING QUEUE AND
:	PROCESSED IN THE DISPATCHER
	ORG	0
	BND	4
DQSCB	WS	1		:SESSION CONTROL BLOCK PTR
DQTGCB	WS	1		:TRANSMISSION GROUP CONTROL BLOCK PTR
DQTCCB	WS	1		:TRANSMISSION CONTROL CONTROL BLOCK
:DQERCB	WS	1		:EXPLICIT ROUTE CONTROL BLOCK PTR
:DQVRCB	WS	1		:VIRTUAL ROUTE CONTROL BLOCK
:DQNRCB	WS	1		:NODE RESOURCE CONTROL BLOCK
:DQDRCB	WS	1		:DOMAIN RESOURCE CONTROL BLOCK
	IF	FWBBF
DQMUPR	WS	1		:MESSAGE UNIT PTR
DQPRMP	WS	1		:PARAMETER ENTITY PTR (FROM NIO OR DLC)
	ELSE
DQMUPR	HS	1		:MESSAGE UNIT PTR
DQPRMP	HS	1		:PARAMETER ENTITY PTR (FROM NIO OR DLC)
	EI
DQMULN	HS	1		:INPUT MU LENGTH (OR NIO MSG LENGTH)
DQLUCB	HS	1		:LU CONTROL BLOCK PTR (FROM NIO)
DQNWCM	BS	1		:COMMAND TYPE (FROM NIO CMD)
DQISIG	BS	1		:INPUT_SIGNAL INPUT SIGNAL NUMBER
DQDPRO	BS	1		:DEST_PROC,DESTINATION PROCEDURE #
DQSPRO	BS	1		:SEND_PROC,SENDING PROCEDURE #
	BND	10
DQLENG	EQ	.

:	CURRENT ENVIRONMENT CONTROL BLOCK
:	---------------------------------
	ORG	0
	BND	4
	IF	FWBBF
EVMUPR	WS	1		:MESSAGE UNIT PTR
EVPRMP	WS	1		:PARAMETER ENTITY PTR (FROM NIO OR DLC)
	ELSE
EVMUPR	HS	1		:MESSAGE UNIT PTR
EVPRMP	HS	1		:PARAMETER ENTITY PTR (FROM NIO OR DLC)
	EI
EVLUCB	HS	1		:INPUT LU CONTROL BLOCK PTR (FROM NIO)
EVMULN	HS	1		:INPUT MU LENGTH (FROM NIO OR DLC)
EVNWCM	BS	1		:COMMAND TYPE (FROM NIO)
EVISIG	BS	1		:INPUT_SIGNAL INPUT SIGNAL NUMBER
EVDPRO	BS	1		:DEST_PROC,DESTINATION PROCEDURE #
EVSPRO	BS	1		:SEND_PROC,SENDING PROCEDURE #
	BND	10
EVLENG	EQ	.

	SUBTTL	TEMPLATE DEFINITION FOR REQUEST/RESPONSE UNITS

:	DEFINE REQUEST/RESPONSE UNITS
:	=============================

:	*****************************************
:	REQUEST RU DEFINITION			:
:	*****************************************

:	ACTLUQ:	ACTIVATE LOGICAL UNIT REQUEST
:	---------------------------------------
:	SSCP --> LU, EXP, SESION CONTROL
	ORG	0
ACTLUQ
ALURCD	BS	1			:RQ.CODE X'0D'
ALUTAC	BS	1			:TYPE.ACTIVATION
ALUPFL	BS	1			:0-3 FM.PROFILE, 4-7 TS.PROFILE
ALULEN	EQ	.			:LENGTH


:	ACTPUQ:	ACTIVATE PHYSICAL UNIT
:	------------------------------
:	SSCP|PUCP --> PU, EXP, SC
	ORG	0
ACTPUQ
APURCD	BS	1			:RQ.CODE X'11'
APUFMT					:0-3 FORMAT, X'0', AND X'3'
APUTAC	BS	1			:4-7 TYPE.ACTIVATION
APUPFL	BS	1			:0-3 FM.PROFILE, 4-7 TS.PROFILE
APUPID	BS	6			:SSCP.ID
					:0-3, FORMAT: 0000
					:4-7, PU TYPE
					:8-47, IMPLEMENTAION DEPENDENT
APUFM0	EQ	.			:END OF FORMAT 0
APUCVT	BS	0			:LENGTH DEPEND ON VETOR KEYS


:	BIDRQ:	BID REQUEST UNIT
:	------------------------
:	LU --> LU, NORM, DFC
	ORG	0
BIDRQ
BIDRCD	BS	1			:RQ.CODE X'C8'
BIDLEN	EQ	.			:LENGTH


:	BINDRQ:	BIND REQUEST UNIT
:	-------------------------
:	PLU --> SLU, EXP, SC
	ORG	0
BINDRQ
BINRCD	BS	1			:RQ.CODE X'31' (BYTE 0)
BINFMT					:FORMAT , 0000 (BYTE 1)
BINTYP	BS	1			:TYPE, 0000 NEGOTIABLE
					:      0001 NOT NEGOTIABLE
BINFMP	BS	1			:FM.PROFILE (BYTE 2)
BINTSP	BS	1			:TS.PROFILE (BYTE 3)
BINPRI	BS	1			:(BYTE 4)
					:0, PRI.CHAIN.USE
					:1, PRI.RQ.MODE
					:2-3, PRI.CHAIN.RSP
					:4, PRI.TWO.PHASE.COMMIT
					:5, RESERVED
					:6, PRI.COMPRESSION.IND
					:7, PRI.EB.IND
BINSEC	BS	1			:(BYTE 5)
					:0, SEC.CHAIN.USE
					:1, SEC.RQ.MODE
					:2-3, SEC.CHAIN.RSP
					:4, SEC.TWO.PHASE.COMMIT
					:5, RESERVED
					:6, SEC.COMPRESSION.IND
					:7, SEC.EB.IND
BINCOM	BS	2			:(BYTE 6) COMMON LU PROTOCOLS
					:0, RESERVED
					:1, FM.HEADER.USAGE
					:2, BRACKETS.USAGE
					:3, BRACKET.TERM.RULE
					:4, ALTERNATE.CODE
					:5, SQN.AVAILABILITY
					:6, BIS.SENT
					:7, RESERVED
					:(BYTE 7)
					:0-1, SEND.RCV.MODE
					:2, RECOVERY.RESPONSIBILITY
					:3, CONT.WINNER.LOSER
					:4-6, RESERVED
					:7, HDX.FF.RESET.STATE
BINTSU	BS	6			:BYTE 8-13, TS USAGE
					:(BYTE 8)
					:0, SEC.TO.PRI.STAGING.IND
					:1, RESERVED
					:2-7, SEC.SEND.PACING.CNT
					:(BYTE 9)
					:0-1, RESERVED
					:2-7, SEC.RCV.PACING.CNT
					:(BYTE 10)
					:0-7, SEC.SEND.MAX.RU.SIZE
					:(BYTE 11)
					:0-7, PRI.SEND.MAX.RU.SIZE
					:(BYTE 12)
					:0, PRI.TO.SEC.STAGING.IND
					:1, RESERVED
					:2-7, PRI.SEND.PACING.CNT
					:(BYTE 13)
					:0-1, RESERVED
					:2-7, PRI.RCV.PACING.CNT
BINPSF	BS	1			:(BYTE 14) PS.PROFILE
					:0, PS.USAGE.FMT
					:1-7, LU.LU.SESSION.TYPE
BINPSU	BS	0B			:(BYTE 15-25) PS.USAGE
BINCRP	BS	1			:(BYTE 26)CRYPTOGRAPHY OPTION
					:BIT 0-1,CRYPTOGRAPHY_PRIVATE
					:BIT 2-3,CRYPTOGRAPHY_SESSION_LEVEL
					:BIT 4-7,CRYPTOGRAPHY_LENGTH
BINCIP	BS	1			:(BYTE 27) CRYPTOGRAPHY KEY METHOD
					:BIT 0-1,ENCIPH_METHOD
					:BIT 5-7,CIPHER_METHOD
BINCKY	BS	8			:(BYTE 28-34) CRYPTOGRAPHY KEY FIELD
BD.CNR	EQ	30			:MASK FOR PRI(SEC)_CHAIN_RSP
BD.CSL	EQ	30			:MASK FOR CRYPTOGRAPHY_SESSION_LEVEL
BD.CGL	EQ	0F			:MASK FOR CRYPTOGRAPHY_LENGTH
:TO BE COMPLETE


:	BISRQ:	BRACKET INITIATION STOPPED
:	----------------------------------
:	LU --> LU, NORM, DFC
	ORG	0
BISRQ
BISRCD	BS	1			:RQ.CODE X'70'
BISLEN	EQ	.


:	CNCLRQ:	CANCEL REQUEST UNIT
:	----------------------------
:	LU --> LU, NORM, DFC
	ORG	0
CNCLRQ
CNCRCD	BS	1			:RQ.CODE X'83'
CNCLEN	EQ	.


:	CHASRQ:	CHASE REQUEST UNIT
:	--------------------------
:	LU --> LU, NORM, DFC
	ORG	0
CHASRQ
CHSRCD	BS	1			:RQ.CODE, X'84'
CHSLEN	EQ	.


:	CLEARQ:	CLEAR REQUEST UNIT
:	--------------------------
:	SSCP --> SSCP, EXP, SC
	ORG	0
CLEARQ
CLRRCD	BS	1			:RQ.CODE, X'A1'
CLRLEN	EQ	.


:	DALURQ:	DEACTIVATE LOGICAL UNIT REQUEST UNIT
:	--------------------------------------------
:	SSCP <--> LU, EXP, SC
	ORG	0
DALURQ
DALUCD	BS	1			:RQ.CODE , X'0E'
DALUTP	BS	1			:TYPE.DEACTIVATION
DALUCS	BS	1			:CAUSE
DALULN	EQ	.


:	DAPURQ:	DEACTIVATE PHYSICAL UNIT REQUEST
:	----------------------------------------
:	SSCP|PUCP --> PU, PU --> SSCP, EXP, SC
	ORG	0
DAPURQ
DAPUCD	BS	1			:RQ.CODE, X'12'
DAPUTP	BS	1			:TYPE.DEACTIVATION
DAPUCS	BS	1			:CAUSE
DAPULN	EQ	.


:	LUSTRQ:	LODICAL UNIT STATUS
:	----------------------------
:	LU --> LU|SSCP, NORM, DFC
	ORG	0
LUSTRQ
LUSTCD	BS	1			:RQ.CODE, X'04'
LUSTUS	BS	4			:STATUS
LUSTLN	EQ	.


:	NTFYRQ:	NOTIFY REQUEST UNIT
:	--------------------------
:	SSCP --> SSCP|LU, LU --> SSCP, NORM, FMD NS(S)
	ORG	0
NTFYRQ
:TO BE COMPLETED


:	QCRQ:	QUIESCE COMPLETE
:	------------------------
:	LU --> LU, NORM, DFC
	ORG	0
QCRQ
QCRQCD	BS	1			:RQ.CODE, X'  '
QCRQLN	EQ	.


:	QECRQ:	QUIESCE AT END OF CHAIN
:	--------------------------------
:	LU --> LU, EXP, DFC
	ORG	0
QECRQ
QECRCD	BS	1			:RQ.CODE, X'80'
QECRLN	EQ	.


:	RELQRQ:	RELEASE QUIESCE
:	----------------------
:	LU -- > LU, EXP, DFC
	ORG	0
RELQRQ
RELQCD	BS	1			:RQ.CODE, X'82'
RELQLN	EQ	.


:	RQDSRQ:	REQUEST DISCONTACT
:	--------------------------
:	PU.T1|T2 0--> SSCP, NORM, FM NS(C)
	ORG	0
RQDSRQ
:TO BE COMPELTED


:	RQRRQ:	REQUEST RECOVERY
:	------------------------
	ORG	0
RQRRQ
RQRRCD	BS	1			:RQ.CODE, X'A3'
RQRRLN	EQ	.


:	RSHDRQ:	REQUEST SHUTDOWN
:	------------------------
:	SLU -- > PLU, EXP, DFC
	ORG	0
RSHDRQ
RSHDCD	BS	1			:RQ.CODE, X'C2'


:	RTRRQ:	READY TO RECEIVE
:	------------------------
:	LU --> LU, NORM, DFC
	ORG	0
RTRRQ
RTRCD	BS	1			:RQ.CODE, X'05'
RTRLEN	EQ	.


:	SBIRQ:	STOP BRACKET INITIATION
:	--------------------------------
:	LU --> LU, EXP, DFC
	ORG	0
SBIRQ
SBIRCD	BS	1			:RQ.CODE, X'71'
SBIRLN	EQ	.


:	SDTRQ:	START DATA TRAFFIC
:	--------------------------
:	PLU --> SLU, SSCP --> PU, EXP, SC
	ORG	0
SDTRQ
SDTRCD	BS	1			:RQ.CODE, X'A0'
SDTRLN	EQ	.


:	SHTCRQ:	SHUT DOWN COMPLETE
:	--------------------------
:	SLU --> PLU, EXP, DFC
	ORG	0
SHTCRQ
SHTCCD	BS	1			:RQ.CODE, X'C1'
SHTCLN	EQ	.


:	SHTDRQ:	SHUT DOWN
:	------------------
:	PLU --> SLU, EXP, DFC
	ORG	0
SHTDRQ
SHTRCD	BS	1			:RQ.CODE, X'C0'
SHTDLN	EQ	.


:	SIGRQ:	SIGNAL
:	----------------
:	LU --> LU, EXP, DFC
	ORG	0
SIGRQ
SIGRCD	BS	1			:RQ.CODE, X'C9'
SIGDTA	BS	4			:SIGNAL.DATA
SIGRLN	EQ	.


:	STSNRQ:	SET AND TEST SEQUENCE NUMBER
:	------------------------------------
:	PLU --> SLU, EXP, SC
	ORG	0
STSNRQ
STSNCD	BS	1			:RQ.CODE, X'A2'
STSNAC	BS	1			:0-1, ACTION.CODE.SEC.TO.PRI
					:2-3, ACTION.CODE.PRI.TO.SEC
					:4-7, RESERVED
STSNSP	BS	2			:SEC.TO.PRI.SQN
STSNPS	BS	2			:PRI.TO.SEC.SQN
STSNLN	EQ	.


:	UBINRQ:	UNBIND SESSION
:	----------------------
:	LU --> LU, EXP, SC
	ORG	0
UBINRQ
UBINCD	BS	1			:RQ.CODE, X'32'
UBINCS	BS	1			:SON.CAUSE
UBINDT	BS	4			:SENSE.DATA
UBINLN	EQ	.

:	*****************************************
:	RESPONSE RU DEFINITION			:
:	*****************************************

:	ALURSP:	ACTIVE LOGICAL UNIT RESPONE
:	-----------------------------------
:	LU --> SSCP, EXP, SC
	ORG	0
ALURSP	BS	1			:RQ.CODE, X'0D'
ALUPTP	BS	1			:TYPE.ACTIVATION
ALPPFL	BS	1			:0-3, FM.PROFILE, 4-7, TS.PROFILE
ALPSLV	BS	5			:SSCP-LU SESSION CONTROL VECTOR
ALPLLV	BS	$A16			:LU-LU SESSION CONTROL VECTOR
ALPLEN	EQ	.


:	APURSP: RSP(ACTPU)
:	-------------------
:	PU --> SSCP|PUCP, EXP, SC
	ORG	0
APURSP	BS	1			:RQ.CODE, X'11'
APUFTA	BS	1			:0-1, RESERVED
					:2-3, FORMAT
					:4-7, TYPE.ACTIVATION
APUCID	BS	8			:CONTENTS.ID
APUFDA	BS	0A			:FORMAT.DATA (FOR CONTROL VECTOR'07')
:
AP.FMP	EQ	0F0			:MASK FOR FM_PROFILE IN ACTPU
AP.TSP	EQ	00F			:MASK FOR TS_PROFILE IN ACTPU
AP.ACT	EQ	0F			:MASK FOR ACTPU(RSP) ACTIVATION
AP.FMT	EQ	0F0			:MASK FOR ACTPU(RSP) FPRMAT
AP.FMD	EQ	01			:MASK FOR PU_FMD_RU_USAGE(RQT_RCV)
DC.DCT	EQ	0F			:MASK FOR DACTCDRM TYPE DEACTIVATION


:	BINRSP:	RSP(BIND)
:	-----------------
:	SLU --> PLU, EXP, SC
	ORG	0
BINRSP	BS	1			:RQ.CODE, X'31'
BIPFMT					:FORMAT , 0000 (BYTE 1)
BIPTYP	BS	1			:TYPE, 0000 NEGOTIABLE
					:      0001 NOT NEGOTIABLE
BIPFMP	BS	1			:FM.PROFILE (BYTE 2)
					:TS.PROFILE (BYTE 3)
BIPPRI	BS	1			:(BYTE 4)
					:0, PRI.CHAIN.USE
					:1, PRI.RQ.MODE
					:2-3, PRI.CHAIN.RSP
					:4, PRI.TWO.PHASE.COMMIT
					:5, RESERVED
					:6, PRI.COMPRESSION.IND
					:7, PRI.EB.IND
BIPSEC	BS	1			:(BYTE 5)
					:0, SEC.CHAIN.USE
					:1, SEC.RQ.MODE
					:2-3, SEC.CHAIN.RSP
					:4, SEC.TWO.PHASE.COMMIT
					:5, RESERVED
					:6, SEC.COMPRESSION.IND
					:7, SEC.EB.IND
BIPCOM	BS	2			:(BYTE 6) COMMON LU PROTOCOLS
					:0, RESERVED
					:1, FM.HEADER.USAGE
					:2, BRACKETS.USAGE
					:3, BRACKET.TERM.RULE
					:4, ALTERNATE.CODE
					:5, SQN.AVAILABILITY
					:6, BIS.SENT
					:7, RESERVED
					:(BYTE 7)
					:0-1, SEND.RCV.MODE
					:2, RECOVERY.RESPONSIBILITY
					:3, CONT.WINNER.LOSER
					:4-6, RESERVED
					:7, HDX.FF.RESET.STATE
BIPTSU	BS	6			:BYTE 8-13, TS USAGE
					:(BYTE 8)
					:0, SEC.TO.PRI.STAGING.IND
					:1, RESERVED
					:2-7, SEC.SEND.PACING.CNT
					:(BYTE 9)
					:0-1, RESERVED
					:2-7, SEC.RCV.PACING.CNT
					:(BYTE 10)
					:0-7, SEC.SEND.MAX.RU.SIZE
					:(BYTE 11)
					:0-7, PRI.SEND.MAX.RU.SIZE
					:(BYTE 12)
					:0, PRI.TO.SEC.STAGING.IND
					:1, RESERVED
					:2-7, PRI.SEND.PACING.CNT
					:(BYTE 13)
					:0-1, RESERVED
					:2-7, PRI.RCV.PACING.CNT
BIPPSF	BS	1			:(BYTE 14) PS.PROFILE
					:0, PS.USAGE.FMT
					:1-7, LU.LU.SESSION.TYPE
BIPPSU	BS	0B			:(BYTE 15-25) PS.USAGE
BIPCRP	BS	1			:(BYTE 26)
:TO BE COMPLETE


:	STSNRP:	RSP(STSN)
:	------------------
:	SLU --> PLU, EXP, SC
	ORG	0
STSNRP	BS	1			:RQ.CODE, X'A2'
STNRCD	BS	1			:0-1, RESULT.CODE.SEC.TO.PRI
					:2-3, RESULT.CODE.PRI.TO.SEC
					:4-7, RESERVED
STSQSPP	BS	2			:SEC.TO.PRI.SQN
STSQPS	BS	2			:PRI.TO.SEC.SQN
STSPLN	EQ	.

	ORG	OLDORG

	EM
  
	SUBTTL	CONSTANTS AREA FOR SNA PACKAGE
:	MODULE NAME IN COMMAND FILE -- SCON02.F00

:	*********************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	**********************************************************

	MO	.,CBKDEF
	RA	0

:	THE FOLLOWING CONSTANTS ARE DEFINED ACCORDING TO THEIR FUNCTIONS
:	TO SUPPORT SNA LAYERS PROCESSES (SEE FAPL MANUAL APPENDIX-A)
:	----------------------------------------------------------------

:************************************************
:	REQUEST CODE FOR RU'S                   :
:************************************************
:	SSCP-->SSCP
:	-------------
ACCDRM	EQ	14		:ACT. CROSS-DOMAIN RESOURCE MANAGER,(E),SC
CDCINI	EQ	4B		:CROSS-DOMAIN CONTROL INI,(N),NS(S)
CDINIT	EQ	41		:CROSS-DOMAIN INIT,(N),NS(S)
CDSSEN	EQ	48		:CROSS-DOMAIN SESSION END,(N),NS(S)
CDSSFL	EQ	45		:CROSS-DOMAIN SETUP FAILURE,(N),NS(S)
CDSSST	EQ	46		:CROSS-DOMAIN SESSION STARTED,(N),NS(S)
CDSSTF	EQ	47		:CROSS-DOMAIN SESSION TAKEDOWN FAILURE
CDSSTD	EQ	49		:CROSS-DOMAIN TAKEDOWN,(N),NS(S)
CDSSTC	EQ	4A		:CROSS-DOMAIN TAKEDOWN COMPLETE,(N),NS(S)
CDTERM	EQ	43		:CROSS-DOMAIN TERMINATE,(N),NS(S)
CLEAR	EQ	0A1		:SSCP-->SSCP,(E),SC
DACDRM	EQ	15		:DEACT. CROSS-DOMAIN RESOURCE MANAGER
DSRLST	EQ	27		:DIRECT SEARCH LIST,(N),NS(S)
INIOCD	EQ	40		:INITIATE-OTHER CROSS-DOMAIN,(N),NS(S)
NOTIFY	EQ	20		:SSCP-->LU,LU-->SSCP,(N),NS(S)
TRMOCD	EQ	42		:TERMINATE-OTHER CD,(N),NS(S),TLU-->OLU
:	SSCP-->PU_T4|5
:	--------------
ABCONN	EQ	0F		:ABANDON CONNECTION PUCP-->PU,(N),NS(C)
ABCONO	EQ	18		:ABANDON CONNECTOUT PUCP-->PU,(N),NS(C)
ACCONI	EQ	16		:ACTIVATE CONNECT IN,PUCP-->PU,(N),NS(C)
ACLINK	EQ	0A		:ACTIVATE LINK,PUCP-->PU,(N),NS(C)
ACTRAC	EQ	02		:ACTIVATE TRACE,(N),NS(MA)
ADLINK	EQ	1E		:ADD LINK,(N),NS(C)
ADLNKS	EQ	21		:ADD LINK STATION,(N),NS(C)
ANA	EQ	19		:ASSIGN NETWORK ADDRESS,(N),NS(C)
CONNOU	EQ	0E		:CONNECT OUT,(N),NS(C)
CONTAC	EQ	01		:CONTACT,(N),NS(C)
DACCOI	EQ	17		:DEACTIVATE CONNECT IN,(N),NS(C)
DACLNK	EQ	0B		:DEACTIVATE LINK,(N),NS(C)
DELTNR	EQ	1C		:DELETE NETWORK RESOURCE,(N),NS(C)
DSCONT	EQ	02		:DISCONTACT,PUCP-->PU,(N),NS(C)
DSPSTO	EQ	31		:DISPLAY DTORAGE,(N),NS(MA)
DUMFIN	EQ	08		:DUMP FINAL,(N),NS(C)
DUMINI	EQ	06		:DUMP INITIAL,(N),NS(C)
DUMTXT	EQ	07		:DUMP TEXT,(N),NS(C)
EXETST	EQ	01		:EXECUTE TEST,(N),NS(MA)
FNA	EQ	1A		:FREE NETWORK ADDRESS,(N),NS(C)
INIPRO	EQ	35		:INITIATE PROCEDURE,(N),NS(C)
IPLFIN	EQ	05		:IPL FINAL,(N),NS(C)
IPLINI	EQ	03		:IPL INITIAL (N),NS(C)
IPLTXT	EQ	04		:IPL TEXT,(N),NS(C)
RNAA	EQ	10		:REQ. NETWORK ADDR. ASSIGNMENT,(N),NS(C)
RUTTST	EQ	06		:ROUTE TEST,(N),NS(MA)
RPO	EQ	09		:REMOTE POWER OFF,(N),NS(C)
SETCV	EQ	11		:SET CONTROL VECTOR,(N),NS(C)
TSTMOD	EQ	05		:TEST MODE,(N),NS(MA)
:	SSCP|PUCP-->PU
:	--------------
ACTPU	EQ	11		:ACTIVATE PHYSICAL UNIT,(E),SC
DACTPU	EQ	12		:DEACT. PHYSICAL UNIT,(E),SC,PU-->SSCP
DACTRA	EQ	03		:DEACT. TRACE,(N),NS(MA)
:	SSCP-->PU_T2
:	------------
NSIPLA	EQ	46		:NS IPL ABORT,(N),NS(C)
NSIPLF	EQ	45		:NS IPL FINAL,(N),NS(C)
NSIPLI	EQ	43		:NS IPL INITIAL,(N),NS(C)
NSIPLT	EQ	44		:NS IPLTEXT,(N),NS(C)
:	SSCP-->PU
:	---------
RQMS	EQ	04		:REQUEST MAINTENANCE STATISTICS,(N),NS(MA)
:	SSCP-->LU
:	---------
ACTLU	EQ	0D		:ACTIVATE LOGICAL UNIT,(E),SC
CINIT	EQ	01		:CONTROL INITIATE,(N),NS(S)
CLENUP	EQ	29		:CLEAN UP SESSION,(N),NS(S)
CTERM	EQ	02		:CONTROL TERMINATE,SSCP-->PLU,(N),NS(S)
DACTLU	EQ	0E		:DEACT. LOGICAL UNIT,(E),SC,LU-->SSCP
DELIVE	EQ	12		:DELIVER,(N),NS(MN)
ECHTST	EQ	89		:ECHO TEST,(N),NS(MA)
NSPE	EQ	04		:NS PROCEDURE ERROR,(N),NS(S)
:	LU-->LU
:	-------
BID	EQ	0C8		:(N),DFC
BIND	EQ	31		:BIND SESSION,PLU-->SLU,(E),SC
BIS	EQ	70		:BRACKET INITIATION STOPPED,(N),DFC
CANCEL	EQ	83		:CANCEL,(N),DFC
CHASE	EQ	84		:CHASE,(N),DFC
CRV	EQ	0C0		:CRYTOGRAPHY VERIFICATION,PLU-->SLU,(E),SC
LUSTAT	EQ	04		:LOGICAL UNIT STATUS,(N),DFC,LU-->SSCP
QC	EQ	81		:QUIESCE COMPLETE,(N),DFC
QEC	EQ	80		:QUIESCE AT END OF CHAIN,(E),DFC
RELQ	EQ	82		:RELEASE QUIESCE,(E),DFC
RTR	EQ	05		:READY TO RECEIVE
RQR	EQ	0A3		:REQUEST RECOVERY,SSCP-->SSCP,(E),SC
RSHUTD	EQ	0C2		:REQUEST SHUTDOWN,(E),DFC
RQECHO	EQ	87		:REQUEST ECHO TEST,(N),NS(MA)
SBI	EQ	71		:STOP BRACKET INITIATION,(E),DFC
SDT	EQ	0A0		:START DATA TRAFFIC,PLU-->SLU,(E),SC
SHUTC	EQ	0C1		:SHUTDOWN COMPLETE,SLU-->PLU,(E),DFC
SHUTD	EQ	0C0		:SHUTDOWN,(E),DFC,PLU-->SLU
SIG	EQ	0C9		:SIGNAL,(E),DFC
STSN	EQ	0A2		:SET & TEST SEQ. NUMBER,PLU-->SLU,(E),SC
UNBIND	EQ	32		:UNBIND SESSION,(E),SC
:	PLU-->SSCP
:	----------
BINDF	EQ	85		:BIND FAILURE,(N),NS(S)
SESSST	EQ	86		:SESSION STARTED,(N),NS(S)
:	ILU-->SSCP
:	----------
INIOTH	EQ	80		:INITIATE-OTHER,(N),NS(S)
INISEL	EQ	81		:INITIATE-SELF,(N),NS(S)
SESSED	EQ	88		:SESSION ENDED,(N),NS(S)
TERMOT	EQ	82		:TERMINATE-OTHER,TLU-->SSCP,(N),NS(S)
TERMSF	EQ	83		:TERMINATE-SELF,TLU-->SSCP,(N),NS(S)

:	PU_T4|5-->SSCP,PU-->PUCP
:	------------------------
CONTAD	EQ	80		:CONTACTED,(N),NS(C)
ERINOP	EQ	1D		:EXPLICIT ROUTE INOPERATIVE,(N),NS(C)
ERTSTD	EQ	86		:EXPLICIT ROUTE TESTED,(N),NS(MA)
ESLOW	EQ	14		:ENTERING SLOWDOWN,PU_T4-->SSCP,(N),NS(C)
EXSLOW	EQ	15		:EXITING SLOWDOWN,PU_T4-->SSCP,(N),NS(C)
INOP	EQ	81		:INOPERATIVE,PU-->PUCP,(N),NS(C)
LCP	EQ	87		:LOST CONTROL POINT,PU_T4-->PUCP,(N),NS(C)
RECMS	EQ	81		:RECORD MAINTENANCE STATISTICS,(N),NS(MA)
RECSTO	EQ	34		:RECORD STORAGE,(N),NS(MA)
RECTD	EQ	82		:RECORD TEST DATA,(N),NS(MA)
RECTR	EQ	85		:RECORD TEST RESULT,(N),NS(MA)
RECTRD	EQ	83		:RECORD TRACE DATA,(N),NS(MA)
RQACLU	EQ	40		:REQUEST ACTIVATE LOGICAL UNIT,(N),NS(C)
RQCONT	EQ	84		:REQUEST CONTACT,(N),NS(C),PU-->PUCP
RQFNA	EQ	86		:REQUEST FREE NETWORK ADDRESS,(N),NS(C)
RQTEST	EQ	80		:REQUEST TEST PROCEDURE,(N),NS(MA),LU-->SSCP
NSLSA	EQ	85		:NS LOST SUBAREA,(N),NS(C)
PROSTA	EQ	36		:PROCEDURE STATUS,(N),NS(C)
RECFMS	EQ	84		:RECORD FORMATTED MAINTENANCE,(N),NS(MA)
VRINOP	EQ	23		:VIRTUAL ROUTE INOPERATIVE,(N),NS(C),PU-->PUCP

:	PU_T4|5-->PU_T4|5
:	------------------
LSA	EQ	05		:LOST SUBAREA,(E),NC
NCACVR	EQ	0D		:ACTIVATE VIRTUAL ROUTE,(E),NC
NCDAVR	EQ	0E		:DEACTIVATE VIRTUAL ROUTE,(E),NC
NCACER	EQ	0B		:ACTIVATE EXPLICIT ROUTE,(E),NC
NCACEP	EQ	0C		:ACTIVATE EXPLICIT ROUTE REPLAY,(E),NC
NCINER	EQ	06		:EXPLICIT ROUTE INOPERATIVE
NCOPER	EQ	0F		:EXPLICIT ROUTE OPERATIVE
NCTSER	EQ	09		:EXPLICIT ROUTE TEST
NCTRER	EQ	0A		:EXPLICIT ROUTE TEST REPLY
:	PU_T4|5-->PU_T2
:	---------------
NCIPLA	EQ	46		:NC IPL ABORT,(E),NC
NCIPLF	EQ	02		:NC IPL FINAL,(E),NC
NCIPLI	EQ	03		:NC IPL INITIAL,(E),NC
NCIPLT	EQ	04		:NC IPL TEXTIAL,(E),NC
:	PU_T2-->SSCP
:	------------
LDREQD	EQ	37		:LOAD REQUIRED,(N),NS(C)
:	PU_T1|2-->SSCP
:	--------------
RQDISC	EQ	1B		:REQUEST DISCONNECT,(N),NS(C)

:*********************************************
:	SESSION (FLOW) TYPE                  :
:*********************************************
SSCPPU	EQ	0		:SSCP_PU
SSCPLU	EQ	1		:SSCP_LU
SSCPSC	EQ	2		:SSCP_SSCP
LULU	EQ	3		:LU_LU
PUCPPU	EQ	4		:PUCP_PU

:*************************************************
:	NODE RESOURCE CATEGORY		:
:*************************************************
CG.PU	EQ	0		:PU
CG.LU	EQ	1		:LU
CG.LK	EQ	3		:LINK
CG.ALS	EQ	4		:ALS
CG.BPU	EQ	5		:BF.PU
CG.BLU	EQ	6		:BF.LU
CG.SCP	EQ	7		:SSCP

:*********************************************
:	NETWORK ADDRESSABLE UNIT TYPE        :
:*********************************************
PUCNST	EQ	0		:PU
LUCNST	EQ	1		:LU
SSCPCN	EQ	2		:SSCP

:*********************************************
:	NETWORK SERVICE TYPE               :
:*********************************************
CONFSV	EQ	2		:CONFIGURATION_SERVICE
MANTSV	EQ	3		:MAINTENANCE_SERVICE

:*********************************************
:	RU CATEGORY			   :
:*********************************************
FMD	EQ	0		:FM DATA
NC	EQ	01		:NETWORK CONTROL
DFC	EQ	02		:DATA FLOW CONTROL
SC	EQ	03		:SESSION CONTROL

:*********************************************
:	REQUEST-RESPONSE INDICATOR	      :
:*********************************************
RQ	EQ	0		:REQUEST
RSP	EQ	1		:RESPONSE

:*********************************************
:	PCCB.BIU_ASSEMBLY_OPTION
:*********************************************
SESASS	EQ	2		:SESSION_ASSEMBLY
STNASS	EQ	1		:STATION_ASSEMBLY


:*********************************************
:	PU (PHYSICAL UNIT) TYPE		  :
:*********************************************
PU.T1	EQ	1		:PU TYPE 1
PU.T2	EQ	2		:PU TYPE 2
PU.T4	EQ	4		:PU TYPE 4
PU.T5	EQ	5		:PU TYPE 5

:*********************************************
:	LU (LOGICAL UNIT) TYPE		  :
:*********************************************
LU.T1	EQ	1		:LU TYPE 1
LU.T2	EQ	2		:LU TYPE 2
LU.T3	EQ	3		:LU TYPE 3
LU.T4	EQ	4		:LU TYPE 4
LU.T6	EQ	6		:LU TYPE 6
LU.T7	EQ	7		:LU TYPE 7

:*********************************************
:	FORMAT IDENTIFIER (FID, IN TH) TYPE	 :
:*********************************************
FID0	EQ	0		:TYPE 0
FID1	EQ	1		:TYPE 1
FID2	EQ	2		:TYPE 2
FID3	EQ	3		:TYPE 3
FID4	EQ	4		:TYPE 4
FIDF	EQ	0F		:TYPE 0F

:***********************************************:
:	TH HEADER LENGTH			:
:***********************************************:
FID2LN	EQ	6		:FID TYPE 2

:*********************************************
:	THE SESSION TYPE			:
:*********************************************
HALFSS	EQ	0		:HALF_SESSION
BFSESS	EQ	1		:BF_SESSION

:*********************************************
:	THE FLOW OF RUS WITHIN A HALF-SESSION     :
:*********************************************
NORMAL	EQ	0		:NORMAL FLOW
EXPEDT	EQ	1		:EXPEDITED FLOW

:*********************************************
:	PROFILE TYPE				:
:*********************************************
PROF00	EQ	0		:PROFILE_0
PROF01	EQ	1		:PROFILE_1
PROF02	EQ	2		:PROFILE_2
PROF03	EQ	3		:PROFILE_3
PROF04	EQ	4		:PROFILE_4
PROF05	EQ	5		:PROFILE_5
PROF06	EQ	6		:PROFILE_6
PROF07	EQ	7		:PROFILE_7
PROF17	EQ	11		:PROFILE_17
PROF18	EQ	12		:PROFILE_18

:*********************************************
:	RESPONSE FORMATTING TYPE		  :
:*********************************************
NORSP	EQ	0		:NO-RESPONSE
EXCRSP	EQ	1		:EXCEPTION-RESPONSE
DEFRSP	EQ	2		:DEFINITE-RESPONSE
DEXRSP	EQ	3		:DEFINITE OR EXCEPTION RESPONSE

:********************************************
:	SEND/RECEIVE MODE PROTOCOL TYPE  :
:********************************************
FULLDX	EQ	0		:FULL_DUPLEX
HDXCON	EQ	40		:HALF_DUPLEX CONTENTION
HDXFF	EQ	80		:HALF_DUPLEX FLIP_FLOP
AD.SRM	EQ	5		:HALF_WORD INDEX ADJUST FOR SEND/RCV MODE

:********************************************
:	DATA FLOW DIRECTION - RECEIVE OR SEND	:
:********************************************
RCV	EQ	1		:RECEIVE
SENT	EQ	0		:SEE PAGE A-39 ON FAPL,IT IS DIFFERENT?????
RCVD	EQ	RCV

:********************************************
:	LENGTH FOR PARTICULAR FIELD	:
:********************************************
RSPLN2	EQ	5		:RSP_OF_LENGTH_TWO
RSPLN1	EQ	4		:RSP_OF_LENGTH_ONE
RHLENG	EQ	3		:RH_LENGTH
SNLENG	EQ	4		:SENSE_LENGTH
:(F00/02/23/87/DB/START) LU_T1 IMPLEMENTATION
FMH1LN	EQ	6		:LENGTH OF FMH-1 FIELD
WSFHLN	EQ	5		:LENGTH OF WSF HEADER FOR SCS DATA
WSFLNG	EQ	1		:LENGTH OF WSF COMMAND
:(F00/02/23/87/DB/END)

:********************************************
:	SQN_USAGE IN BIND			:
:********************************************
NOSEQU	EQ	2		:NO_SNF
SEQNUM	EQ	1		:SEQUENCE_NUMBER
IDENTI	EQ	0		:IDENTIFIERS

:********************************************
:	CRYPTOGRAPHY_SESSION_LEVEL INFORMATION:
:********************************************
MANDAT	EQ	30		:MANDATORY
SELECT	EQ	10		:SELECTIVE

:********************************************
:	LU-LU SESSION ERROR SENSE CODE	:
:********************************************
:	MAJOR CODE X'80' PATH ERROR
:	---------------------------
.NOSES	EQ	8005		:NO SESSION
.SEGER	EQ	8007		:SEGMENTING ERROR
.PELUD	EQ	8009		:LU NOT ACTIVE
.TOOLP	EQ	800A		:TOO LONG PIU
:	MAJOR CODE X'40' RH USAGE ERROR
:	---------------------------
.RHESC	EQ	4001		:INVALID SC RH
.UEBBI	EQ	4003		:BB NOT ALLOWED
.UEEBN	EQ	4004		:EB NOT ALLOWED
.UEERN	EQ	4006		:EXCEPTION RESPONSE NOT ALLOWED
.UEDRN	EQ	4007		:DEFINITE  RESPONSE NOT ALLOWED
.PGNSU	EQ	4008		:PACING NOT SUPPORTED
.UECDI	EQ	4009		:CD NOT ALLOWED
.UENRN	EQ	400A		:NO-RESPONSE NOT ALLOWED
.UEBCI	EQ	400B		:CHAINING NOT SUPPORTED
.UEEBI	EQ	400C		:BRACKETS NOT SUPPORTED
.UECDN	EQ	400D		:CD NOT SUPPORTED
.UEFI	EQ	400F		:INCORRECT USE OF FI
.UECSI	EQ	4010		:ALTERNATE CODE NOT SUPPORTED
.UERUG	EQ	4011		:INCORRECT RU CATEGORY
.UERQD	EQ	4012		:INCORRECT REQUEST CODE
.UESDI	EQ	4013		:INCORRECT (SDI,RTI)
.UEDRI	EQ	4014		:INCORRECT USE OF (DR1I,DR2I,ERI)
.UEQRI	EQ	4015		:INCORRECT USE OF QRI
.UEEDI	EQ	4016		:INCORRECT USE OF EDI
.UEPDI	EQ	4017		:INCORRECT USE OF PDI
:	MAJOR CODE X'20' STATE ERROR
:	---------------------------
.SEQER	EQ	2001		:SEQUENCE NUMBER ERROR
.SECHN	EQ	2002		:CHAINING,ERROR IN THE SEQUENCE OF BCI,ECI
.SEBER	EQ	2003		:BRACKET ERROR
.SEDIR	EQ	2004		:DIRECTION ERROR
.SEDTR	EQ	2005		:DATA TRAFFC RESET
.SEDTQ	EQ	2006		:DATA TRAFFIC QUIESCED
.SEDTN	EQ	2007		:DATA TRAFFIC NOT RESET
.SENBB	EQ	2008		:NO BEGIN BRACKET
.SESCP	EQ	2009		:SESSION CONTROL PROTOCOL VIOLATION
.SEIRM	EQ	200A		:IMMEDIATE RQ MODE ERROR
.SEQRI	EQ	200B		:QRI STATE ERROR
.SEESE	EQ	200C		:ERP SYNC EVENT ERROR
.SEROB	EQ	200D		:RESPONSE OWED BEFORE SENDING REQUEST
:	MAJOR CODE X'10' REQUEST ERROR
:	---------------------------
.RUDER	EQ	1001		:RU DATA ERROR
.RULER	EQ	1002		:RU LENGTH ERROR
.RQEFN	EQ	1003		:FUNCTION NOT SUPPORTED
.CGNSU	EQ	1007		:CATEGORY NOT SUPPORTED
:	MAJOR CODE X'08' REQUEST REJECT
:	---------------------------
.MODCN	EQ	0809		:MODE INCONSISTENCY
.RRSLE	EQ	0805		:SESSION LIMIT EXCEEDED
.RRMDI	EQ	0808		:INVALID CONTENTS ID
.RRBRE	EQ	080B		:BRACKET RACE ERROR
.RRNAU	EQ	080D		:NAU CONTENTION ERROR
.RRNAN	EQ	080E		:NAU NOT AUTHORIZED
.RRISR	EQ	0812		:INSUFFICIENT RESOURCE
.RRBJN	EQ	0813		:BRACKET BID REJECT,RTR'LL NOT BE SENT
.RRBJF	EQ	0814		:BRACKET BID REJECT,RTR'LL BE SENT
.NGRTR	EQ	0819		:NEGATIVE RESPONSE FOR RTR
.RRRTM	EQ	081B		:RECEIVER IN XMT MODE
.RRFNS	EQ	0826		:FUNCTION NOT SUPPORTED
.RRRLR	EQ	082C		:RESOURCE-SHARING LIMIT REACHED
.RREMF	EQ	0846		:ERP MSG FORTHCOMING
.RRCFI	EQ	0848		:CRYPTOGRAPHY FUNCTION INOPERATIVE
.RRISB	EQ	084D		:INVALID SESSION PARAMETERS - BF
.RRISP	EQ	084E		:INVALID SESSION PARAMETER-PRI
.RRNSE	EQ	0867		:MUST SEND NEG. RSP TO SYNC EVENT

:********************************************
:	INVALID PARAMETERS CHECKING CODE	:
:********************************************
IP3501	EQ	08350001		:INVALID PARAMETER
IP3502	EQ	08350002		:INVALID PARAMETER
IP3503	EQ	08350003		:INVALID PARAMETER

:********************************************
:	TYPE ACTIVATION REQUESTED FOR ACTPU	:
:********************************************
COLD	EQ	1		:COLD
COLDNI	EQ	1		:COLD (IPL NOT REQ.)
ERP	EQ	2		:ERP TYPE
COLDIP	EQ	3		:COLD (IPL REQUIRED)

:**********************************************
:	TYPE DEACTIVATION REQUEST		:	
:**********************************************
SON	EQ	3		:SESSION OUTAGE NOTIFICATION

:*********************************************
:	TYPE SESSION OUTAGE			:
:*********************************************
SO.NRM	EQ	1		:NORMAL END OF SESSION
SO.VIO	EQ	7		:VR_INOP, VIRTUAL ROUTE INOPERABLE
SO.RIO	EQ	8		:REX_INOP,ROUTE EXTENSION INOPERABLE
SO.VRF	EQ	0B		:VR_FORCED, VIRTUAL ROUTE FORCED DOWN

:*************************************************
:	STSN_RQ.ACTION_CODE		:
:*************************************************
ACCODE	EQ	3		:SEC_TO_PRI
ACSET	EQ	1		:STSN_RQ.ACTION_CODE = SET
ACSTST	EQ	3		:STSN_RQ.ACTION_CODE = SET AND TEST

:********************************************
:	MODULO CONSTANT TO MASK OF BITS	:
:********************************************
MODUL8	EQ	07		:THE MAX. REMAINDER FOR MODULO 8

:********************************************
:	RETURN CODE FOR TRANSMISSION CONTROL:
:********************************************
GOOD	EQ	0		:GOOD
DCARMU	EQ	1		:DISCARD_MU
NEGRSP	EQ	2		:NEG_RSP
CVTEXR	EQ	3		:CONVERT_TO_EXR

:*********************************************
:	CT_ENTRY_TYPE			:
:*********************************************
PARCHA	EQ	0		:PARTIAL_CHAIN
WCNCAN	EQ	1		:WHOLE_CHAIN_NO_CANCEL
WCWCAN	EQ	2		:WHOLE_CHAIN_WITH_CANCEL
ONLCAN	EQ	3		:CANCEL_ONLY

:*********************************************
:	THE COMBINATION OF EFI AND RRI IN MUCB:
:*********************************************
NORRQ	EQ	0		:EFI=NORMAL & RRI=RQ
NORRSP	EQ	1		:EFI=NORMAL & RRI=RSP
EXPRQ	EQ	2		:EFI=EXPEDITED & RRI=RQ
EXPRSP	EQ	3		:EFI=EXPEDITED & RRI=RSP

:**********************************************
:	LSCB_TYPE (LINK,ALS)		:
:**********************************************
ALS	EQ	4		:ALS=4
LINK	EQ	3		:LINK=3

:**********************************************
:	NS HEADER (1ST BYTE OF HEADER) TYPE	:
:**********************************************
NSH101	EQ	01		:NOT SPECIFIED NS
NSH141	EQ	41		:PU RELATED NS
NSH181	EQ	81		:LU RELATED NS

:**********************************************
:	NS HEADER (2ND BYTE OF HEADER) CATEGORY	:
:**********************************************
NSCFSV	EQ	02		:CONFIGURATION SERVICE
NSMTSV	EQ	03		:MAINTENANCE SERVICE
NSMGSV	EQ	08		:MANAGEMENT SERVICE
NSSESV	EQ	06		:SESSION SERVICE
NSH180	EQ	80		:MASK OFF BIT0 OF NS HEADER BYTE 2
				:FOR SAME-DOMAIN (0) OR CROSS-DOMAIN(1)

:**********************************************
:	LENGTH OF RU (DEFINED IN ACTLU)		:
:**********************************************
RU0256	EQ	85		:RU 256 BYTES DEFINED TO X'85'

:**********************************************
:	THE KEY VALUE FOR CONTROL VECTOR IN CERTAIN RU:
:**********************************************
VC.K07	EQ	07		:CONTROL VECTOR KEY IS '07'

:**********************************************
:	MISCELLANEOUS CONSTANT FOR GENERAL USE:
:**********************************************
NGONON	EQ	1		:NONNEGOTIABLE
NGOYES	EQ	0		:NEGOTIABLE
YES	EQ	1		:VARIABLE YES
NO	EQ	0		:VARIABLE NO
PRI	EQ	1		:PRIMARY SESSION
SEC	EQ	0		:SECONDARY SESSION
TRUE	EQ	1		:TRUE CONDITION
FALSE	EQ	0		:FALSE CONDITION
NEGONE	EQ	-1		:NEGATIVE ONE
FIND	EQ	1		:FOUND
NOFIND	EQ	0		:NOT_FIND
TRUNCA	EQ	1		:TRUNCATE FOR THE RSP RU
NOTRUN	EQ	0		:NO-TRUNCATE FOR THE RSP RU
FWRD16	EQ	$A 16		:CONSTANT 16
FWRD31	EQ	$A 31		:CONSTANT 31
FWRD32	EQ	$A 32		:CONSTANT 32
BUFFLG	EQ	1		:FLAG TO CHECK VALID BUFFER PTR

:SCREEN SIZE CONSTANTS.
SCRNSZ	EQ	0E		:BITS DEFINING SCREEN SIZE IN DSP
SCRNS2	EQ	04		:SCREEN SIZE 2 (1920)
S19202	EQ	02		:BIND USAGE BYTE VALUE FOR 1920
S1920F	EQ	0FF		:BIND USAGE BYTE WITH ALT SIZE
S1920V	EQ	18		:VERTICAL SIZE (24 ROWS)
S1920H	EQ	50		:HORIZONTAL SIZE (80 COLUMNS)

	EM

 
	SUBTTL	FINITE STATE MACHINE DEFINITION FILE
:	MODULE NAME IN COMMAND FILE SFDF00.F00

:	*********************************************
:	REVISION HISTORY --
:	ORIGINAL DESIGN AND CODING (DB) -- 11 MARCH 1984
:	**************************************************

	RA	0
	MO	.,SNAPKG

	GL	F.CODE

	LO	CBKDEF

FS.SW2	EQ	1

FNC	MACRO[
	LR	R6,R6
	JER	R3
	]

FS.MC1	MACRO(FS.OFF,FS.SUB)[
	LHI	R5,FS.OFF		:R5 = FSM OFFSET INTO CONTROL BLOCK
	ST	R3,FS.RTN,,		:STORE RETURN ADDRESS(09/03/87/ACH)
	JAL	R3,FS.SUB,,		:CALL REGISTER CHECKING ROUTINE
	L	R3,FS.RTN,,		:RESTORE RETURN ADDRESS(9/8/87/ACH)
	]
	


:	FSM_INPUT_DEFINITION FOR FINITE STATE MACHINES
:	----------------------------------------------
:	INPUT SIGNAL
FS.RET	EQ	01		:FSMINPUT='RESET'
FS.AVL	EQ	02		:FSMINPUT='AVL'
FS.BEB	EQ	03		:FSMINPUT='BETB'
FS.IBR	EQ	04		:FSMINPUT='INB_RCV'
FS.IBS	EQ	05		:FSMINPUT='INB_SEND'
FS.REB	EQ	06		:FSMINPUT='RESET_BETB'
FS.REC	EQ	07		:FSMINPUT='RESET_CONT'
FS.REI	EQ	08		:FSMINPUT='RESET_INB'
FS.RER	EQ	09		:FSMINPUT='RESET_RCV'
FS.RES	EQ	0A		:FSMINPUT='RESET_SEND'
FS.UAV	EQ	0B		:FSMINPUT='UNAVL'
FS.NOR	EQ	0C		:FSMINPUT='NO_OUTSTANDING_RQS'
FS.HRT	EQ	0D		:FSMINPUT='HIERARCHICAL_RESET_RQ'
FS.HRP	EQ	0E		:FSMINPUT='HIERARCHICAL_RESET_RSP'
FS.SGE	EQ	FS.HRP		:LAST VALID SIGNAL
:	FSM ROUTINE TYPE (ACTION CALL, AND SEND_OR_RCV_CHECK)
:	-----------------------------------------------------

FS.FNC	EQ	0			:SEND_OR_RECEIVE_CHECK
FS.CAL	EQ	1			:ACTION CALL

:	STATE NAMES FOR ALL THE FSMS IN SCB
:	THE SYMBLOS FOR THE STATE ARE 'HARD COPY' THIS MOMENT (BECAUSE
:	OF THE 6-CHARACTERS NAMING PROBLEM)
FS.ST1	EQ	0		:STATE 1
FS.ST2	EQ	FS.ST1+1	:STATE 2
FS.ST3	EQ	FS.ST1+2	:STATE 3
FS.ST4	EQ	FS.ST1+3	:STATE 4
FS.ST5	EQ	FS.ST1+4	:STATE 5
FS.ST6	EQ	FS.ST1+5	:STATE 6
FS.ST7	EQ	FS.ST1+6	:STATE 7
FS.ST8	EQ	FS.ST1+7	:STATE 8
FS.ST9	EQ	FS.ST1+8	:STATE 9

	SEG	A.DATA

	WS	0
:*******************************************************************************
:	REGISTER STORAGE FOR GENERAL FSM USE
:	THIS AREA IS USED BY FSM'S WHEN CALLING ROUTINES OUTSIDE THE
:	FINITE STATE MACHINES.
:*****************************************************************************

FS.SV0	WS	10		:R0 THRU R15 STORAGE(3.F02/9/3/87/ACH)
				

:**********************************************************************
:	REGISTER STORAGE FOR ACTION CODES
:	THIS STORAGE AREA IS USED TO STORE THE ORIGINAL REGISTER INPUT
:	VALUES. ONLY FSM'S WHICH CALL ACTION CODE ROUTINES A1 & A2 NEED
:	TO SAVE THE ORIGINAL INPUT VALUES. ACTION CODE ROUTINES A1 AND A2
:	BOTH CALL OTHER FSM'S. THESES CALLED FSM'S NEVER STORE IN THIS AREA.
:**********************************************************************
FS.ASV	WS	3		:R0 THRU R2 STORAGE
FS.AS3	WS	1		:LINK REGISTER (R3) STORAG
	WS	0C		:R4 THRU R15 STORAGE 

:***********************************************************************
:	STORAGE AREA FOR DEBUGGING
:***********************************************************************
FS.DSV	WS	10		:R0 THRU R15 STORAGE AREA

:************************************************************************
:	MISCELLANEOUS STORAGE
:************************************************************************
	BND	4
FS.RTN	WS	1		:STORAGE FOR RETUREN ADDR. (R3)
FS.ISV	WS	1		:STORAGE FOR FSD1I0 ROUTINE TO STORE R3
FS.ACT	WS	1		:STORAGE FOR ACTION_CODE
FS.RQD	BS	1		:STORAGE FOR RQD INDICATOR, 0 = RQD AND
				:NON 0 = -RQD
FS.CTS	BS	1		:STORAGE FOR CT_BBI AND CT_EBI BITS
FS.RCV	BS	1		:STORAGE FOR RECOVERER INDICATOR,
				:0=NOT_RECOVERER, 1=RECOVERER

	SEG	A.CODE

FS.ERR	EQ	0FF		:ERROR CODE STORED IN FS.CTS WHEN CT_PTR EMPTY

:	ERROR CODES 
:	RETURNED IN R6 BYTE 1 WHEN FALSE RETURNED IN BYTE 0
:---------------------------------------------------------------
FS.I00	EQ	00		:VALID FALSE ACTION CODE EXECUTED (>)
FS.I01	EQ	10		:INVALID SEND INPUT
FS.I02	EQ	11		:INVALID RECEIVE INPUT
FS.I03	EQ	12		:INVALID REQUEST INPUT
FS.I04	EQ	13		:INVALID RESPONSE INPUT
FS.I05	EQ	14		:INVALID POSITIVE RESPONSE INPUT
FS.I06	EQ	15		:INVALID NEGATIVE RESPONSE INPUT
FS.I07	EQ	16		:INVALID RU_CATEGORY INPUT
FS.I08	EQ	17		:INVALID ACTION_CODE INPUT
FS.I09	EQ	18		:INVALID SENSE CODE INPUT
FS.I10	EQ	19		:INVALID SIGNAL INPUT
FS.I11	EQ	1A		:INVALID STATE VALUE (WITHIN VALID STATE
				:RANGES) THIS IS ACTION CODE /
FS.I12	EQ	1B		:INVALID CORRELATION TABLE VALUE INPUT
FS.I13	EQ	1C		:INVALID END CHAIN INDICATION INPUT (ECI)
FS.I14	EQ	1D		:INVALID CHANGE DIRECTION INPUT (CDI)
FS.I15	EQ	1E		:INVALID END BRACKET INPUT (EBI)
FS.I16	EQ	1F		:INVALID BEGIN BRACKET INPUT (BBI)
FS.I17	EQ	20		:INVALID BEGIN CHAIN INPUT (BCI)
FS.I18	EQ	21		:INVALID EXP OR NORM FLOW INPUT (EFI)
FS.I19	EQ	22		:INVALID PACING INPUT (PI)
FS.I20	EQ	23		:INVALID TO_CURRENT_CHAIN INPUT
FS.I21	EQ	24		:INVALID RESPONSE MODE REQUEST INPUT -
				: RQN/RQE/RQD
FS.I22	EQ	25		:INVALID HALF SESSION INPUT (PRI/SEC)
FS.I23	EQ	26		:INVALID ACTIVATION_TYPE INPUT
FS.I24	EQ	27		:INVALID DEACTIVATION_TYPE INPUT
FS.I25	EQ	28		:INVALID CORREATION TABLE POINTER (=0)

:	CRASH CODES
:---------------------------
FS.C01	EQ	30		:BAD R0 VALUE
FS.C02	EQ	31		:BAD R1 VALUE
FS.C03	EQ	32		:BAD R2 VALUE
FS.C04	EQ	33		:BAD R4 VALUE
FS.C05	EQ	34		:BAD R6 VALUE
FS.C06	EQ	35		:BAD R7 VALUE


:***************************************************************
:	CRASH INPUT ROUTINES - FOR TESTING USE ONLY
:***************************************************************
	IF	\FS.SW1		:IF FSM CRASH SWITCH SET

FS.CSD	
	JAL	R10,CRASH,,	:INVALID SEND
	BC	0,0,0,FS.I01
FS.CRV
	JAL	R10,CRASH,,	:INVALID RCV
	BC	0,0,0,FS.I02
FS.CRQ
	JAL	R10,CRASH,,	:INVALID REQUEST
	BC	0,0,0,FS.I03
FS.CRS
	JAL	R10,CRASH,,	:INVALID RESPONSE
	BC	0,0,0,FS.I04
FS.CPS
	JAL	R10,CRASH,,	:INVALID POSITIVE RSP
	BC	0,0,0,FS.I05
FS.CNG
	JAL	R10,CRASH,,	:INVALID NEGATIVE RSP
	BC	0,0,0,FS.I06
FS.CAT
	JAL	R10,CRASH,,	:INVALID RU_CATEGORY
	BC	0,0,0,FS.I07
FS.COD
	JAL	R10,CRASH,,	:INVALID ACTION_CODE
	BC	0,0,0,FS.I08
FS.CSC
	JAL	R10,CRASH,,	:INVALID SENSE CODE
	BC	0,0,0,FS.I09
FS.CSG
	JAL	R10,CRASH,,	:INVALID SIGNAL
	BC	0,0,0,FS.I10
FS.CIN
	JAL	R10,CRASH,,	:INVALID INPUT ACTION CODE (/)
	BC	0,0,0,FS.I11
FS.CCT
	JAL	R10,CRASH,,	:INVALID CORRELATION TABLE VALUES
	BC	0,0,0,FS.I12
FS.CEC
	JAL	R10,CRASH,,	:INVALID END CHAIN INDICATION
	BC	0,0,0,FS.I13
FS.CCD
	JAL	R10,CRASH,,	:INVALID CHANGE DIRECTION INDICATION
	BC	0,0,0,FS.I14
FS.CEB
	JAL	R10,CRASH,,	:INVALID END BRACKET INDICATION
	BC	0,0,0,FS.I15
FS.CBB
	JAL	R10,CRASH,,	:INVALID BEGIN BRACKET INDICATION
	BC	0,0,0,FS.I16
FS.CBC
	JAL	R10,CRASH,,	:INVALID BEGIN CHAIN INDICATION
	BC	0,0,0,FS.I17
FS.CFL
	JAL	R10,CRASH,,	:INVALID FLOW MODE (EXP/NORM)
	BC	0,0,0,FS.I18
FS.CPI
	JAL	R10,CRASH,,	:INVALID PACING INDICATION
	BC	0,0,0,FS.I19
FS.CUR
	JAL	R10,CRASH,,	:INVALID TO_CURRENT_CHAIN
	BC	0,0,0,FS.I20
FS.CRM
	JAL	R10,CRASH,,	:INVALID RSP MODE (RQD/RQN/RQE)
	BC	0,0,0,FS.I21
FS.CHS
	JAL	R10,CRASH,,	:INVALID HALF SESSION (PRI/SEC)
	BC	0,0,0,FS.I22
FS.CAC
	JAL	R10,CRASH,,	:INVALID ACTION_TYPE 	
	BC	0,0,0,FS.I23
FS.CDC
	JAL	R10,CRASH,,	:INVALID DEATIVATION_TYPE
	BC	0,0,0,FS.I24
FS.CPT
	JAL	R10,CRASH,,	:INVALID CORRELATION TABLE PTR (EMPTY)
	BC	0,0,0,FS.I25



:****************************************************************
:	INVALID INPUT ROUTINES
:	THESE ROUTINES ARE CALLED BY A FINITE STATE MACHINE
:	WHEN AN INVALID INPUT IS FOUND. AN INVALID INPUT IS
:	DEFINED AS AN INPUT WHICH IS NOT LISTED AS ONE OF THE
:	POSSIBLE INPUTS TO THE PARTICULAR FSM DEFINED IN THE
:	FAPL. THESE ROUTINES RETURN A FALSE IN BYTE 0 AND AN
:	ERROR CODE IN BYTE 1 OF REGISTER 6.
:****************************************************************

	ELSE
FS.CSD
	LHI	R6,FS.I01*100		:SEND ERROR CODE
	J	FS.END
FS.CRV
	LHI	R6,FS.I02*100		:RECEIVE ERROR CODE
	J	FS.END	
FS.CRQ
	LHI	R6,FS.I03*100		:REQUEST ERROR CODE
	J	FS.END
FS.CRS
	LHI	R6,FS.I04*100		:RESPONSE ERROR CODE
	J	FS.END		
FS.CPS
	LHI	R6,FS.I05*100		:POSITIVE RESPONSE ERROR CODE
	J	FS.END
FS.CNG
	LHI	R6,FS.I06*100		:NEGATIVE RESPONSE ERROR CODE
	J	FS.END
FS.CAT
	LHI	R6,FS.I07*100		:RU_CATEGORY ERROR CODE
	J	FS.END
FS.COD
	LHI	R6,FS.I08*100		:ACTION_CODE ERROR CODE
	J	FS.END
FS.CSC
	LHI	R6,FS.I09*100		:SENSE CODE ERROR CODE
	J	FS.END
FS.CSG
	LHI	R6,FS.I10*100		:SIGNAL ERROR CODE
	J	FS.END
FS.CIN
	LHI	R6,FS.I11*100		:STATE INPUT ERROR CODE (/)
	J	FS.END
FS.CCT
	LHI	R6,FS.I12*100		:CORRELATION TABLE ERROR CODE
	J	FS.END
FS.CEC
	LHI	R6,FS.I13*100		:END CHAIN INDICATOR ERROR CODE
	J	FS.END
FS.CCD
	LHI	R6,FS.I14*100		:CHANGE DIRECTION INDICATOR ERROR
	J	FS.END
FS.CEB
	LHI	R6,FS.I15*100		:END BRACKET INDICATOR ERROR CODE
	J	FS.END
FS.CBB
	LHI	R6,FS.I16*100		:BEGIN BRACKET INDICATOR ERROR CODE
	J	FS.END
FS.CBC
	LHI	R6,FS.I17*100		:BEGIN CHAIN INDICATOR ERROR CODE
	J	FS.END
FS.CFL
	LHI	R6,FS.I18*100		:FLOW MODE ERROR CODE (EXP/NORM)
	J	FS.END
FS.CPI
	LHI	R6,FS.I19*100		:PACING ERROR CODE
	J	FS.END
FS.CUR
	LHI	R6,FS.I20*100		:TO_CURRENT_CHAIN ERROR CODE
	J	FS.END		
FS.CRM
	LHI	R6,FS.I21*100		:RESPONSE MODE ERROR (RQD/RQE/RQN)
	J	FS.END
FS.CHS
	LHI	R6,FS.I22*100		:HALF SESSION ERROR CODE (PRI/SEC)
	J	FS.END
FS.CAC
	LHI	R6,FS.I23*100		:ACTIVATION_TYPE ERROR CODE
	J	FS.END
FS.CDC
	LHI	R6,FS.I24*100		:DEACTIVATION_TYPE ERROR CODE
	J	FS.END
FS.CPT
	LHI	R6,FS.I25*100		:CORRELATIONTABLE PTR EMPTY ERROR 
FS.END
	GL	FSC000
	J	FSC000,,
	EI	(FS.SW1)

:************************************************************************
:	CRASH INPUT ROUTINES
:	THESE ROUTINES ARE CALLED BY REGISTER INPUT CHECKING ROUTINES IF
:	A REGISTER IS FOUND TO CONTAIN A VALUE WHICH IS NOT WITHIN THE
:	THE RANGE OF POSSIBLE VALUES FOR THAT PARTICULAR REGISTER.
:************************************************************************
FS.CR0
	JAL	R10,CRASH,,		
	BC	0,0,0,FS.C01		:BAD R0
FS.CR1
	JAL	R10,CRASH,,	
	BC	0,0,0,FS.C02		:BAD R1 
FS.CR2
	JAL	R10,CRASH,,
	BC	0,0,0,FS.C03		:BAD R2
FS.CR4
	JAL	R10,CRASH,,	
	BC	0,0,0,FS.C04		:BAD R4
FS.CR6
	JAL	R10,CRASH,,
	BC	0,0,0,FS.C05		:BAD R6
FS.CR7
	JAL	R10,CRASH,,
	BC	0,0,0,FS.C06		:BAD R7

:*********************************************************************
:	FSM REGISTER INPUT CHECKING ROUTINES
:	FS.PCB	- FSM'S WHICH USE PCCB USE THIS ROUTINE TO CHECK IF
:		  INPUT REGISTERS ARE CORRECT
:	FS.TCB	- FSM'S WHICH USE TCCB USE THIS ROUTINE TO CHECK IF
:		  INPUT REGISTERS ARE CORRECT
:	FS.SCB	- FSM'S WHICH USE SCB USE THIS ROUTINE TO CHECK IF
:		  INPUT REGISTERS ARE CORRECT
:	IF ANY REGISTERS ARE FOUND TO CONTAIN UNDEFINED VALUES, THE
:	ROUTINE CRASHES WITH THE APROPRIATE CRASH CODE.
:......................................................................
:
:	REGISTER USAGE:
:	INPUT	:	R5 (FSM OFFSET IN CONTROL BLOCK)
:	LINK	:	R3
:	WORKING	:	R5, ALL OTHER REGISTERS ARE UNCHANGED
:*********************************************************************
FS.PCB
	IF	\FS.SW2			:DEBUGGING SWITCH
	STM	R0,FS.DSV,,		:SAVE ALL REGISTERS
	EI
	LR	R0,R0			:SIGNAL PRESENT?
	JN	FS.PC2			:YES, DON'T CHECK R2 OR R4
	CLHI	R2,MU.BIU-MU.BIU	:R2 = -BBIU?
	JE	FS.PC1			:YES
	CLHI	R2,MU.BIU		:R2 = BBIU?
	JN	FS.CR2,,		:NO, CRASH
FS.PC1
	CLHI	R4,MU.EIU-MU.EIU	:R4 = -EBIU?
	JE	FS.PC2			:YES
	CLHI	R4,MU.EIU		:R4 = EBIU ?
	JN	FS.CR4,,		:NO, CRASH
FS.PC2
	CR	R1,R5			:R1 = CORRECT FSM OFFSET?
	JN	FS.CR1,,		:NO, CRASH
	LI	R5,FS.R7P		:GET TABLE OF PCCB STATE LIMITS
	J	FS.COM			:GO CHECK COMMON REGISTER INPUTS
: CHECK TCCB INPUTS
:-------------------------------------
FS.TCB
	IF	\FS.SW2			:DEBUGGING SWITCH
	STM	R0,FS.DSV,,		:SAVE ALL REGISTERS
	EI
	CR	R1,R5			:R1 = CORRECT FSM OFFSET?
	JN	FS.CR1,,		:NO, CRASH
	LI	R5,FS.R7T		:POINT TO TABLE OF TCCB STATE LIMITS
	JFS	FS.SC1			:CHECK COMMON REGISTER INPUTS

: CHECK SCB INPUTS
:------------------------
FS.SCB
	IF	\FS.SW2			:DEBUGGING SWITCH
	STM	R0,FS.DSV,,		:SAVE ALL REGISTERS
	EI
	CR	R1,R5			:R1 = CORRECT FSM OFFSET?
	JN	FS.CR1,,		:NO, CRASH
	LI	R5,FS.R7S		:POINT TO SCB TABLE OF STATE LIMITS
FS.SC1
	LR	R0,R0			:SIGNAL PRESENT?
	JN	FS.COM			:YES, DON'T CHECK R2 OR R4
	CLHI	R2,0			:R2 = SEND?
	JE	FS.SC2			:YES
	CLHI	R2,RCV			:R2 = RCV?
	JN	FS.CR2			:NO, CRASH
FS.SC2
	CLHI	R4,RQ			:R4 = REQUEST?
	JEFS	FS.COM			:YES
	CLHI	R4,MU.RRI		:R4 = RESPONSE?
	JN	FS.CR4,,		:NO, CRASH
:
:	INPUT: R5 = POINTER TO TABLE OF FSM STATE LIMITS
:--------------------------------------------------------------
FS.COM
	LR	R0,R0			:R0 < FIRST SIGNAL?
	JL	FS.CR0,,		:YES, CRASH
	CLHI	R0,FS.SGE		:R0 > LAST SIGNAL?
	JG	FS.CR0,,		:YES, CRASH
	CLHI	R6,FS.FNC		:R6 = FUNCTION CALL?
	JEFS	FS.CO1			:YES
	CLHI	R6,FS.CAL		:R6 = CALL?
	JN	FS.CR6,,		:NO, CRASH
FS.CO1	
	CLHI	R7,FS.ST1		:R7 < STATE 1?
	JL	FS.CR7,,		:YES, CRASH
	LB	R5,0,R5,R1		:GET UPPER LIMIT FROM TABLE
	CR	R7,R5			:R7 > LAST STATE?
	JG	FS.CR7,,		:YES, CRASH
	JR	R3			:ALL REGISTERS O.K. RETURN
:
: TABLES OF FSM STATE LIMITS
:-----------------------------------------
FS.R7P
	BC	0
	BC	FS.ST2			:FSM_STATION_BIU_ASSEMBLY
FS.R7T
	BC	0
	BC	FS.ST2			:FSM_PAC_RQ_SEND
	BC	FS.ST2			:FSM_PAC_RQ_RCV
FS.R7S
	BC	0
	BC	FS.ST6			:FS0000
	BC	FS.ST6			:FS0100
	BC	FS.ST3			:FS0200
	BC	FS.ST2			:FS0300
	BC	FS.ST2			:FS0400
	BC	FS.ST3			:FS0500
	BC	FS.ST3			:FS0600
	BC	FS.ST3			:FS0700
	BC	FS.ST6			:FS0800
	BC	FS.ST9			:FS0900
	BC	FS.ST3			:FS1000
	BC	FS.ST6			:FS1100
	BC	FS.ST9			:FS1200
	BC	FS.ST3			:FS1300
	BC	FS.ST3			:FS1400
	BC	FS.ST2			:FS1500
	BC	FS.ST3			:FS1600
	BC	FS.ST4			:FS1700
	BC	FS.ST2			:FS1800
	BC	FS.ST3			:FS1900
	BC	FS.ST4			:FS2000
	BC	FS.ST2			:FS2100
	BC	FS.ST2			:FS2200
	BC	FS.ST3			:FS2300
	BC	FS.ST3			:FS2400
	BC	FS.ST8			:FS2500
	BC	FS.ST5			:FS2600
	BC	FS.ST5			:FS2700
	BC	FS.ST3			:FS2800
	BC	FS.ST3			:FS2900
	BC	FS.ST2			:FS3000
	BC	FS.ST3			:FS3100
	BC	FS.ST3			:FS3200
	BC	FS.ST2			:FS3300
	BC	FS.ST2			:FS3400
	BC	FS.ST2			:FS3500
	BC	FS.ST2			:FS3600
	BC	FS.ST2			:FS3700
	BC	FS.ST3			:FS3800
	BC	FS.ST3			:FS3900
	BC	FS.ST5			:FS4000
	BC	FS.ST5			:FS4100
	BC	FS.ST5			:FS4200
	BC	FS.ST9			:FS4300
	BC	FS.ST8			:FS4400
	BC	FS.ST7			:FS4500
	BC	FS.ST5			:FS4600
	BC	FS.ST5			:FS4700
	BC	FS.ST5			:FS4800
	BC	FS.ST5			:FS4900
	BC	FS.ST7			:FS5000
	BC	FS.ST2			:FS5100
	BC	FS.ST3			:FS5200
	BC	FS.ST3			:FS5300
	BC	FS.ST2			:FS5400
	BC	FS.ST2			:FS5500
	


	FO	CBKDEF
	EM			:END OF CBKDEF MODULE

	SUBTTL	SNA PACKAGE ALLOCATION AREA

:	THIS PACKAGE IS DESIGNED TO ALLOCATE STORAGE FOR DISPATCHER QUEUES
:	,SOME CONTROL BLOCKS AND CONSTANT
:	-------------------------------------------------------------------

:	*****************************************
:	REVISION HISTORY --
:	11/07/83 (NCS) -- ORIGINAL DESIGN AND CODE
:	*******************************************

	MO	.,CBKDEF
	LO	MAIN

	RA	0

	SEG	A.BDAT

:	SET NDEV|Q|,NTYP|Q| FOR ALL THE NODES IN THE INTERFACE
:	--------------------------------------------------------
QQ	EQ	0
Q	EQ	0
	RE	NLINES
QR	EQ	0

	RE	MSTN|Q|
NDEV|QQ|	EQ	MLU|Q||QR|
	IF	LINK|Q|			:PRIMARY (TERMINAL INTERFACE)
NTYP|QQ|	EQ	IPTY|Q||QR|
	ELSE
NTYP|QQ|	EQ	IPTY|Q||QR|	:ASSIGNED PU TYPE
	EI
QR	EQ	QR+1
QQ	EQ	QQ+1
	ER

Q	EQ	Q+1
	ER

:	CALCULATE TOTAL SESSION CONTROL BLOCKS NUMBER
:	-------------------------------------------
A2	EQ	0
Q	EQ	0
	RE	MAXPUN
A2	EQ	A2+NDEV|Q|*2
Q	EQ	Q+1
	ER

:	SCBBLK	-SESSION CONTROL BLOCK ALLOCATION AREA
:	------------------------------------------------
	BND	10
SCBBLK	EQ	.-2
	BS	SCLENG*A2
A1	EQ	.
:
:BEGIN DELETE (01/20/87 YLH)
:	INIT THE SCBBLK AT EXECUTION TIME
:
:Q	EQ	0
:QQ	EQ	0
:	RE	MAXPUN
:QQQ	EQ	0
:	RE	NDEV|Q|*2
:	ORG	SCBBLK+2+QQ*SCLENG
:	HC	QQ*TCLENG+2
:	BC	QQQ
:QQQ	EQ	QQQ+1
:QQ	EQ	QQ+1
:	ER
:Q	EQ	Q+1
:	ER
:
:END OF DELETION (01/20/87 YLH)
:

:	DEFINE FWSCB 		:DELETED (01/21/85 MIA)
:	------------
:	IF FWSCB IS UNDEFINED, SET AUTOMATICALLY IF NEEDED.
:	IF	\FWSCB
:
:	IF	A1-(SEG|A.BDAT|+0FFFF)
:Q	EQ	1
:	ELSE
:Q	EQ	0
:	EI	(A1-(SEG|A.BDAT|+0FFFF))
:
:	IF	(FWSCB-Q)&1
:	REMARK %***  FWSCB NOT CORRECTLY DEFINED !!!!!
:	EI	(FWSCB-Q)
:
:	ELSE
:	IF	A1-(SEG|A.BDAT|+0FFFF)
:	GL	FWSCB
:FWSCB	EQ	1
:	ELSE
:	GL	FWSCB
:FWSCB	EQ	0
:	EI	(A1-(SEG|A.BDAT|+0FFFF))
:
:	EI	(\FWSCB) 	:END DELETION (01/21/85 MIA)

:	TCBBLK	-TRANSMISSION CONTROL CONTROL BLOCK ALLOCATION AREA
:	-----------------------------------------------------
	ORG	A1
	BND	10
TCBBLK	EQ	.-2
	BS	TCLENG*A2
A1	EQ	.

:			DELETED REFENENCES TO A.BDA1 (01/21/85 MIA)
:A.BDA1	EQ	A.BDAT+1
:	SEG	A.BDA1
:Q	EQ	A1-SEG|A.BDA1|
:	IF	Q-0
:	ELSE
:	HC	0DEAF			:NOTHING IN SEGMENT A.BDA1
:	EI

	SEG	A.DATA

:	NCBBLK	:NODE CONTROL BLOCK ALLOCATION AREA
:	------------------------------------------
	BND	10
NCBBLK	EQ	.-2
	BS	NDLENG*MAXPUN
A1	EQ	.
Q	EQ	0
	RE	MAXPUN
	ORG	NCBBLK+2+Q*NDLENG
	BC	NDEV|Q|,NTYP|Q|
	BC	0,0
:	DEFAULT PTR FOR SCB,PCB
	WC	-1,-1
Q	EQ	Q+1
	ER

	ORG	A1

:	EVBLK	:CURRENT ENVIRONMENT VECTOR FOR EACH NODE
:	------------------------------------------------
	BND	10
EVBLK	EQ	.-2
	BS	EVLENG*MAXPUN
A1	EQ	.

:	PCBBLK	:PATH CONTROL BLOCK ALLOCATION AREA
:	-------------------------------------------
	ORG	A1
	BND	10
PCBBLK	EQ	.-2
	BS	PCLENG*MAXPUN
A1	EQ	.
Q	EQ	0
	RE	MAXPUN
	ORG	PCBBLK+2+Q*PCLENG
	BC	SESASS			:DEFAULT FOR SESSION_BIU_ASSEMBLY
Q	EQ	Q+1
	ER

:	NCBPTR	-NODE CONTROL BLOCK PTR FOR EACH NODE CONTROL BLOCK
:	-----------------------------------------------------------
	ORG	A1
	BND	10
NCBPTR	HS	0
Q	EQ	0
	RE	MAXPUN
	HC	Q*NDLENG+2
Q	EQ	Q+1
	ER

::	NNBPTR	-NODE NETWORK CONTROL BLOCK FOR EACH NODE
::	-----------------------------------------------------------
:	BND	10
:NNBPTR	HS	0
:QQ	EQ	0
:Q	EQ	0
:	RE	MAXPUN
:	HC	NDEV|Q|*NLLENG
:QQ	EQ	QQ+NDEV|Q|*NLLENG
:Q	EQ	Q+1
:	ER
:
::	NNBBLK	:NODE NETWORK CONTROL BLOCK ALLOCATION AREA
::	-------------------------------------------
:	BND	10
:NNBBLK	BS	QQ
:A1	EQ	.
:	ORG	A1

:	PCBPTR	-PATH CONTROL BLOCK PTR FOR EACH PATH CONTROL BLOCK
:	-----------------------------------------------------------
	BND	2
PCBPTR	HS	0
Q	EQ	0
	RE	MAXPUN
	HC	Q*PCLENG+2
Q	EQ	Q+1
	ER

:	EVPTR	-CURRENT ENVIRONMENT VECTOR PTR FOR EACH NODE
:	-----------------------------------------------------------
	BND	2
EVPTR	HS	0
Q	EQ	0
	RE	MAXPUN
	HC	Q*EVLENG+2
Q	EQ	Q+1
	ER

:	SCBPTR	-SESSION CONTROL BLOCK PTR FOR EACH NODE
:	-----------------------------------------------------------
	BND	2
:	(4/21/86/CHS) OLD CODE FOR SETTING SCBPTR ARE DELETED
:		NEW CODE ARE DEFINED AT THE END
:SCBPTR	HS	0
:	IF	FWSCB
:AA	EQ	4
:	ELSE
:AA	EQ	2
:	EI
:
:Q	EQ	0
:	RE	MAXPUN
:	IF	Q
:	IF	FWSCB
:	WC	AA+SCLENG*NDEV|Q-1|*2
:	ELSE
:	HC	AA+SCLENG*NDEV|Q-1|*2
:	EI
:AA	EQ	AA+SCLENG*NDEV|Q-1|*2
:
:	ELSE
:	IF	FWSCB
:	WC	4
:AA	EQ	4
:	ELSE
:	HC	2
:AA	EQ	2
:	EI
:
:	EI			:END OF 'IF Q'
:Q	EQ	Q+1
:	ER

:	(4/21/86/CHS) NEW DEFINITION FOR SCBPTR STARTS HERE
SCBPTR	HS	0
Q	EQ	0
AA	EQ	0
	RE	MAXPUN
	IF	FWSCB
	WC	SCLENG*AA+2
	ELSE
	HC	SCLENG*AA+2
	EI	(FWSCB)
AA	EQ	AA+NDEV|Q|*2
Q	EQ	Q+1
	ER

	SEG	A.CODE

:	(4/21/86/CHS) DELETE UNNECESSARY INSTRUCTIONS
:	IF	\FWSCB
:	ELSE
:FWSCB	EQ	0
:	EI
:	(4/21/86/CHS) END OF DELETION

	IF	FWSCB
BBLSCB	MACRO(D)[L]
BBSSCB	MACRO(D)[ST]
	ELSE
BBLSCB	MACRO(D)[LHL]
BBSSCB	MACRO(D)[STH]
	EI

:	RESPONSE FOR ACTPU (COLD)
:	-------------------------
:ALL HARDCODED DEFINITIONS ARE REPLACED BY SYSGENED (02/11/85 MIA).
:	BND	10
:G.APUR	BC	0
:	BC	2D,00,00,00,00,00,0EB,80,00
:	BC	11,11,40,40,40,40,40,40,40,40
:	BC	00,00,07,01,00,00,00,00,00,00
:ED.APR	EQ	.
:	ORG	G.APUR
:	BC	ED.APR-G.APUR-1
:	ORG	ED.APR
:
:	RESPONSE FOR ACTPU (ERP)
:	-------------------------
:	BND	10
:G.APUE	BC	0
:	BC	2D,00,00,00,00,00,0EB,80,00
:	BC	11,12,40,40,40,40,40,40,40,40
:	BC	00,00,07,01,00,00,00,00,00,00
:ED.APE	EQ	.
:	ORG	G.APUE
:	BC	ED.APE-G.APUE-1
:	ORG	ED.APE

:	BND	4
:G.APUP	BC	0
:	BC	2D,00,00,00,00,00,06B,80,00
:	BC	11,02,01,05,00,00,00,00,00
:ED.APP	EQ	.
:	ORG	G.APUP
:	BC	ED.APP-G.APUP-1
:	ORG	ED.APP

:	BND	4
:G.ALUP	BC	0
:	BC	2D,00,02,00,00,00,06B,80,00
:	BC	0D,02,01
:ED.ALP	EQ	.
:	ORG	G.ALUP
:	BC	ED.ALP-G.ALUP-1
:	ORG	ED.ALP

:	BND	4
:G.ALUR	BC	0
:	BC	2D,00,00,02,00,00,0EB,80,00
:	BC	0D,02
:ED.ALR	EQ	.
:	ORG	G.ALUR
:	BC	ED.ALR-G.ALUR-1
:	ORG	ED.ALR

:	BND	4
:G.DPUP	BC	0
:	BC	2D,00,00,00,00,00,06B,80,00
:	BC	12,01
:ED.APP	EQ	.
:	ORG	G.DPUP
:	BC	ED.APP-G.DPUP-1
:	ORG	ED.APP

:	BND	4
:G.DLUP	BC	0
:	BC	2D,00,02,00,00,00,06B,80,00
:	BC	0E
:ED.ALP	EQ	.
:	ORG	G.DLUP
:	BC	ED.ALP-G.DLUP-1
:	ORG	ED.ALP

:	BND	4
:G.UNBR	BC	0
:	BC	2D,00,01,02,00,00,0EB,80,00
:	BC	32
:ED.UBR	EQ	.
:	ORG	G.UNBR
:	BC	ED.UBR-G.UNBR-1
:	ORG	ED.UBR

:	BND	4
:G.UNBP	BC	0
:	BC	2D,00,02,01,00,00,06B,80,00
:	BC	32,02,0B4
:ED.UBP	EQ	.
:	ORG	G.UNBP
:	BC	ED.UBP-G.UNBP-1
:	ORG	ED.UBP


:	Information frames trace buffer			:(10/09/85/TTW)
:	-------------------------------
:	Each entry has 16D bytes.
:	First byte tells you the direction of this information
:	frame.   0: receive information frames.
:	         1: transmit information frames.
:	         2: discarded information frames.
:	The rests are the contents of the first 15 bytes of this 
:	information frame.
	SEG	A.BUFF
	BND	4
	IF	\IFTBUF
	ELSE
IFTBUF	EQ	600			:MUST BE MULTIPLE OF 16
	EI
IFTRCV	EQ	0			:0 - RCV INF. FRAME
IFTXMT	EQ	1			:1 - XMT INF. FRAME
IFTDIS	EQ	2			:1 - DISCARD INF. FRAME
IFTLEN	EQ	10			:TRACE ENTRY IS 10D BYTES
INFTLN	HS	(NLINES-1)/10+1		:INF. TRACE ACCORDING TO LINE
INFTCU	HS	(MAXPUN+0F)/10		:INF. TRACE ACCORDING TO PUCT.LN
	IF	\INTRLG
	ELSE
INTRLG	EQ	1
	EI
IFTRBF	
	RE	INTRCE
	BS	IFTBUF			:TRACE TABLE = IFTBUF * INTRCE
	ER
	BS	10			:GAP
	SEG	A.DATA
IFTRIX	HC	0			:INF. TRACE INDEX

	FO	MAIN

	EM
   	SUBTTL	(SNA) LMSG - CHARACTER SET AND 3270 MSG DEFINITIONS
:ASEB00.F00

:	:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and desgin for SNA Native Mode
:	01/10/86 (CHS) -- Enhance for FNA and HNA Support
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	RA	0

	MO	.,MAIN

:
:	3270 CHAR DEFINITIONS AND CANNED MSGS
:
 
:	3270 COMMAND CHAR CODES
:	----------------------
:
:	FOR FNA
:		EWACMD - SAME ACTION AS EWCMD
:		RMACMD - SAME ACTION AS RMCMD
:		WSFCMD - NOT SUPPORTED
:	FOR HNA
:		EWACMD, RMACMD, & WSFCMD - NOT SUPPORT
:
WCMD	EQ	0F1			:WRITE CMD
EWCMD	EQ	0F5			:ERASE / WRITE CMD
RBCMD	EQ	0F2			:READ BUFFER CMD
RMCMD	EQ	0F6			:READ MODIFIED CMD
RMACMD	EQ	06E			:READ MODIFIED ALL CMD
CPCMD	EQ	0F7			:COPY CMD - FOR BSC ONLY
EAUCMD	EQ	06F			:ERASE ALL UNPROTECTED CMD
WSFCMD	EQ	0F3			:WRTIE STRUCTURED FIELD CMD
EWACMD	EQ	07E			:ERASE WRITE ALTERNATIVE CMD

:	STRUCTURED FIELD ID CODE FOR WSF COMMAND
SCSID	EQ	41			:(F00/02/23/87/DB) SCS DATA ID 

:	WRITE CONTROL CHAR (WCC) VALUES FOR IBM AND FUJITSU
:	---------------------------------------------------
:	CRT WCCS, (FUJITSU ALWAYS HAS RESET BIT ON)
WCCAKM	EQ	0C7			:ALARM , RESTORE KBD, RESET MDT BITS
WCCKM	EQ	0C3			:KEYBOARD , MDT BITS
WCCK	EQ	0C2 			:KEYBOARD
WCCA	EQ	0C4			:SET ALARM
WCCAK	EQ	0C6			:SET ALARM , UNLOCK KBD.
WCCN	EQ	40			:NO ACTION

WCCKBR	EQ	2			:KB RESTORE BIT
WCCALM	EQ	4			:ALARM BIT
WCCSPT	EQ	8			:START PRINTER BIT

:	WRITE CONTROL CHAR (CB0) VALUES FOR HITACHI
:	-------------------------------------------
:	CRT WCCS, SIMILAR TO IBM AND FUJITSU
CB0AKM	EQ	0C7			:ALARM , RESTORE KBD, RESET MDT BITS
CB0KM	EQ	0C3			:KEYBOARD , MDT BITS
CB0K	EQ	0C2 			:KEYBOARD
CB0A	EQ	0C4			:SET ALARM
CB0AK	EQ	0C6			:SET ALARM , UNLOCK KBD.
CB0N	EQ	40			:NO ACTION

CB0KBR	EQ	2			:KB RESTORE BIT
CB0ALM	EQ	4			:ALARM BIT
CB0SPT	EQ	8			:START PRINTER BIT

:	WRITE CONTROL BYTES (CB2) VALUES FOR HITACHI
:	-------------------------------------------
:	CRT WCCS, CB2(0) AND CB2(1).
CB2AKM	EQ	8780			:ALARM , RESTORE KBD, RESET MDT BITS
CB2KM	EQ	8380			:KEYBOARD , MDT BITS
CB2K	EQ	8280 			:KEYBOARD
CB2A	EQ	8480			:SET ALARM
CB2AK	EQ	8680			:SET ALARM , UNLOCK KBD.
CB2N	EQ	8080			:NO ACTION

CB2KBR	EQ	2			:KB RESTORE BIT
CB2ALM	EQ	4			:ALARM BIT
CB2SPT	EQ	8			:START PRINTER BIT

:	PRINTER WCC VALUSS FOR IBM AND FUJITSU
:	---------------------------------------
:	FUJITSU ALWAYS HAS RESET BIT ONE
WCCPNS	EQ	0C8			:NL FORMAT , START PRINT
WCCP4S	EQ	0D8			:40 CHAR LINE , START PRINT
WCCP6S	EQ	0E8			:64 CHAR LINE , START PRINT
WCCP8S	EQ	0F8			:80 CHAR LINE , START PRINT
WCCPN	EQ	040			:NL FORMAT
WCCP4	EQ	050			:40 CHAR LINE
WCCP6	EQ	060			:64 CHAR LINE
WCCP8	EQ	0F0			:80 CHAR LINE
 
:	PRINTER WCC VALUSS FOR HITACHI
:	------------------------------
:	HITACHI ALWAYS HAS RESET BIT ONE
HWCPNS	EQ	0D0			:NL FORMAT , START PRINT
HWCP4S	EQ	0D4			:40 CHAR LINE , START PRINT
HWCP6S	EQ	0D8			:64 CHAR LINE , START PRINT
HWCP8S	EQ	0DC			:80 CHAR LINE , START PRINT
HWCPN	EQ	0C0			:NL FORMAT
HWCP4	EQ	0C4			:40 CHAR LINE
HWCP6	EQ	0C8			:64 CHAR LINE
HWCP8	EQ	0CC			:80 CHAR LINE
 
:	COPY CONTROL CHAR ( CCC ) VALUES FOR IBM AND FUJITSU
:	----------------------------------------------------
CCCODE	EQ	7B			:COPY ENTIRE 80-LINE SCREEN

:	COPY CONTROL CHAR ( CCC ) VALUES FOR HITACHI
:	--------------------------------------------
HCCODE	EQ	0DB			:COPY ENTIRE 80-LINE SCREEN

:	STRUCTURED FIELD ID'S FOR IBM AND FUJITSU
:	-----------------------------------------
:	FOR HITACHAI - NOT SUPPORTED
OUTWSF	EQ	40			:OUTBOUND 3270DS

:	FIELD ATTRIBUTE CHAR CODES FOR IBM AND FUJITSU
:	----------------------------------------------
:	NAMING CONVENTION - 
:	U/P = UNPROTECTED / PROTECTED
:	A/N = ALPHA / NUMERIC
:	N/D/I = NON-DISPLAY / DISPLAY / INTENSE DISPLAY
ATUAD	EQ	040			:UNPROCT.,ALPHA,DISP
ATUAI	EQ	0C8			:UNPROCT.,ALPHA,INTENSE
ATUAN	EQ	04C			:UNPROCT.,ALPHA,NON-DISP
ATUADM	EQ	0C1			:UNPROT.,ALPHA,DISP,MDT
ATUANM	EQ	04D			:UNPROT.,ALPHA,NON-DISP,MDT
ATUAIM	EQ	0C9			:UNPROT.,ALPHA,INTENSE,MDT
ATUNI	EQ	0D8			:UNPROT.,NUMBERIC,INTENSE.
ATPNN	EQ	07C			:PROCT.,NUMERIC,NON-DISP
ATPND	EQ	0F0			:PROCT.,NUMBERIC,DISP
ATPNI	EQ	0F8			:PROCT.,NUMERIC,INTENSE
ATPAD	EQ	060			:PROCT.,ALPHA,DISP
ATPAI	EQ	0F8			:PROCT.,ALPHA,INTENSE
 
:	FIELD ATTRIBUTE CHARS CODES FOR HITACHI
:	---------------------------------------
:	FIELD ATTRIBUTE CHARS - TWO BYTES
:	NAMING CONVENTION - 
:	U/P = UNPROTECTED / PROTECTED
:	A/N = ALPHA / NUMERIC
:	N/D/I = NON-DISPLAY / DISPLAY / INTENSE DISPLAY
HAUAD	EQ	0C0C0			:UNPROCT.,ALPHA,DISP
HAUAI	EQ	0C2C0			:UNPROCT.,ALPHA,INTENSE
HAUAN	EQ	0C3C2			:UNPROCT.,ALPHA,NON-DISP
HAUADM	EQ	0C0C1			:UNPROT.,ALPHA,DISP,MDT
HAUANM	EQ	0C3C3			:UNPROT.,ALPHA,NON-DISP,MDT
HAUAIM	EQ	0C2C1			:UNPROT.,ALPHA,INTENSE,MDT
HAUNI	EQ	0C2CC			:UNPROT.,NUMBERIC,INTENSE.
HAPNN	EQ	0C3CA			:PROCT.,NUMERIC,NON-DISP
HAPND	EQ	0C0C8			:PROCT.,NUMBERIC,DISP
HAPNI	EQ	0C2C8			:PROCT.,NUMERIC,INTENSE
HAPAD	EQ	0C0C8			:PROCT.,ALPHA,DISP
HAPAI	EQ	0C2C8			:PROCT.,ALPHA,INTENSE
 
:	AID CHAR CODES FOR IBM, FUJITSU AND HITACHI
:	-------------------------------------------
:	AIDPTR(NO AID GENERATED - PRINTER) - NOT SUPPORTED FOR HITACHI
AIDCRT	EQ	060			:NO AID GENERATED - CRT
AIDPTR	EQ	0E8			:NO AID GENERATED - PRINTER
AIDENT	EQ	07D			:ENTER
AIDPF1	EQ	0F1			:PF KEY AIDS
AIDPF2	EQ	0F2
AIDPF3	EQ	0F3
AIDPF4	EQ	0F4
AIDPF5	EQ	0F5
AIDPA1	EQ	06C			:PA KEY AIDS
AIDPA2	EQ	06E
AIDPA3	EQ	06B
AIDCLR	EQ	06D			:CLEAR KEY AID
AIDTST	EQ	0F0			:AID FOR TEST REQUEST KEY
AIDSP	EQ	07E			:AID FOR SELECTOR PEN
 
:	STATUS AND SENSE CODES
:	----------------------
DEVEND	EQ	0C240			:DEVICE END STATUS (SNA & FNA)
DVENDH	EQ	0C4C0			:DEVICE END STATUS (HNA)

:	3270 ORDER CODES
:	----------------
SF.	EQ	1D			:START FIELD
SA.	EQ	28			:SET ATTRIBUTE
SFE.	EQ	29			:START FIELD EXTENDED
SBA.	EQ	11			:SET BUFFER ADDRESS
IC.	EQ	13			:INSERT CURSOR
PT.	EQ	05			:PROGRAM TAB
RA.	EQ	3C			:REPEAT TO ADDRESS
EAU.	EQ	12			:ERASE UNPROTECTED TO ADDRESS
 
:	3270 EBCDIC BSC FRAME CHARS
:	---------------------------
ESC.	EQ	27
STX	EQ	02
ETX	EQ	03
ITB	EQ	1F
ETB	EQ	26
ENQ.	EQ	2D
ENQ	EQ	ENQ.
 
:	EBCDIC CHAR CODE
:	----------------
LA.	EQ	81
LB.	EQ	82
LC.	EQ	83
LD.	EQ	84
LE.	EQ	85
LF.	EQ	86
A.	EQ	0C1
B.	EQ	0C2
C.	EQ	0C3
D.	EQ	0C4
E.	EQ	0C5
F.	EQ	0C6
G.	EQ	0C7
H.	EQ	0C8
I.	EQ	0C9
J.	EQ	0D1
K.	EQ	0D2
L.	EQ	0D3
M.	EQ	0D4
N.	EQ	0D5
O.	EQ	0D6
P.	EQ	0D7
Q.	EQ	0D8
R.	EQ	0D9
S.	EQ	0E2
T.	EQ	0E3
U.	EQ	0E4
V.	EQ	0E5
W.	EQ	0E6
X.	EQ	0E7
Y.	EQ	0E8
Z.	EQ	0E9

N0.	EQ	0F0
N1.	EQ	0F1
N2.	EQ	0F2
N3.	EQ	0F3
N4.	EQ	0F4
N5.	EQ	0F5
N6.	EQ	0F6
N7.	EQ	0F7
N8.	EQ	0F8
N9.	EQ	0F9

NULL.	EQ	0			:NULL CHAR
VT.	EQ	0B			:VERTICAL TAB (HNA ONLY)
FF.	EQ	0C			:FORM FEED
CR.	EQ	0D			:CARRIAGE RETURN
SO.	EQ	0E			:SHIFT OUT (HNA ONLY)
NL.	EQ	15			:NEW LINE
CAN.	EQ	18			:CANCEL (HNA ONLY)
EM.	EQ	19			:END OF MESSAGE
FM.	EQ	1E			:FIELD MARK CHAR
BELL.	EQ	2F			:BELL (HNA ONLY)
SP.	EQ	40			:SPACE
CENT.	EQ	4A			:CENT CHAR
DOT.	EQ	4B			:PERIOD
LP.	EQ	4D			:LEFT PARENTHESIS
EXCL.	EQ	5A			:EXCLAMATION MARK (!)
ASTR.	EQ	5C			:ASTERISK (*)
RP.	EQ	5D			:RIGHT PARENTHESIS
SEMI.	EQ	5E			:SEMICOLON
DASH.	EQ	60			:DASH CHAR
SLAH.	EQ	61			:SLASH (/)
COMA.	EQ	6B			:COMMA (,)
QUES.	EQ	6F			:QUESTION MARK
COLON.	EQ	7A			:COLON (:)
POND.	EQ	7B			:POND SIGN (#)
DQTE.	EQ	7F			:DOUBLE QUOTE

:	ASCII CHAR CODES
:	----------------
CTRLA.	EQ	01			:CONTROL A
CTRLQ.	EQ	11			:CONTROL Q
ABEL.	EQ	07			:BELL CHAR
ABS.	EQ	08			:BACK SPACE
ALF.	EQ	0A			:LINE FEED
ACR.	EQ	0D			:CARRIAGE RETURN
AESC.	EQ	01B			:ESC
ASP.	EQ	020			:SPACE
AEXCL.	EQ	21			:EXCLAMATION MARK (!)
ASTER.	EQ	02A			:*
ACOMA.	EQ	02C			:, COMMA
ASLUH.	EQ	02F			:SLUSH
ACOLN.	EQ	03A			:COLON
ASEMI.	EQ	03B			:SEMICOLON
AQUES.	EQ	03F			:?
A0.	EQ	30			:0
A1.	EQ	31			:1
A2.	EQ	32			:2
A3.	EQ	33			:3
A4.	EQ	34			:4
A5.	EQ	35			:5
A6.	EQ	36			:6
A7.	EQ	37			:7
A8.	EQ	38			:8
A9.	EQ	39			:9

AA.	EQ	41			:A
AB.	EQ	42			:B
AC.	EQ	43			:C
AD.	EQ	44			:D
AE.	EQ	45			:E
AF.	EQ	46			:F
AG.	EQ	47			:G
AH.	EQ	48			:H
AI.	EQ	49			:I
AJ.	EQ	4A			:J
AK.	EQ	4B			:K
AL.	EQ	4C			:L
AM.	EQ	4D			:M
AN.	EQ	4E			:N
AO.	EQ	4E			:O
AP.	EQ	50			:P
AQ.	EQ	51			:Q
AR.	EQ	52			:R
AS.	EQ	53			:S
AT.	EQ	54			:T
AU.	EQ	55			:U
AV.	EQ	56			:V
AW.	EQ	57			:W
AX.	EQ	58			:X
AY.	EQ	59			:Y
AZ.	EQ	5A			:Z

AAGR.	EQ	05E			:^ ACCENT GRAVE
AFF.	EQ	0C			:FORM FEED
 
:	MACROS FOR CONVERTING NUMBERIC BUFFER ADDRESSES TO CHARS
:	GIVEN A NUMBER C - PRODUCE BC WITH CHAR
SPC	MACRO(C) [
QQX	EQ	C&0F
	IF	QQX-9
QQY	EQ	0
	ELSE
	IF	QQX-1
QQY	EQ	80
	ELSE
QQZ	EQ	(C^-3)+QQX
QQY	EQ	QQT|QQZ|
	EI
	EI
	BC	C+40+QQY
	]

:	DEFINE SYMBOLS NEEDED BY SPC
QQT0	EQ	0
QQT1	EQ	80
QQT2	EQ	0
QQT3	EQ	80
QQT4	EQ	0
QQT5	EQ	0
QQT6	EQ	80
QQT7	EQ	80
 
:	SBAC - USES ROW NO , COL. NO AND ROW SIZE TO CALC.
:	BUFFER ADDR. , IT THEN CREATES TWO BC S FOR THE BUF. ADDR CHARS
SBAC	MACRO(R,C,CMAX)
	[
QQ1	EQ	R*CMAX+C
QQ2	EQ	QQ1^-6
	SPC(QQ2)
QQ2	EQ	QQ1&3F
	SPC(QQ2)
	]
 
:	MAXIMUM ROW FOR 3270 DEVICES
:	----------------------------
MAXROW	HS	0
	BC	$A12			:0 - 480 = 12 x 40
	BC	$A12			:0 - 960 = 12 x 80
	BC	$A24			:0 - 1920 = 24 x 80
	BC	$A32			:0 - 2560 = 32 x 80
	BC	$A43			:0 - 3440 = 43 x 80
	BC	$A27			:0 - 3564 = 27 x 132

:	MAXIMUM COLUMN FOR 3270 DEVICES
:	-------------------------------
MAXCOL	HS	0
	BC	$A40			:0 - 480 = 12 x 40
	BC	$A80			:0 - 960 = 12 x 80
	BC	$A80			:0 - 1920 = 24 x 80
	BC	$A80			:0 - 2560 = 32 x 80
	BC	$A80			:0 - 3440 = 43 x 80
	BC	$A132			:0 - 3564 = 27 x 132

:	LOOK UP TABLE FORE 3270 BUFFER ADDRESS I/O INTERFACE CODES
:	----------------------------------------------------------
BAIOIC	HS	0
	XC	40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F	:00-0F
	XC	50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F	:10-1F
	XC	6061E2E3E4E5E6E7E8E96A6B6C6D6E6F	:20-2F
	XC	F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F	:30-3F



:	EBCDIC TO ASCII CONVERSION
:	---------------------------
:       THIS TABLE CONVERTS A 8 BIT EBCDIC INDEX INTO
:	SPACING ASCII.

BCDASC	HS	0
:			EBCDIC ASC GRAPHIC	EBCDIC ASC GRAPHIC
	XC	0001	:00  80  NULL		01  01  SOH
	XC	0203	:02  02  STX		03  03 ETX
	XC	7F09	:04  FF  PF/***		05  89  HT
	XC	7F7F	:06  FF  ***		07  FF  DEL
	XC	7F7F	:08  FF  GE/***		09  FF  RLF/***
	XC	7F0B	:0A  FF  SSM/***	0B  8B  VT
	XC	0C0D	:0C  8C  FF		0D  8D  CR
	XC	0E0F	:0E  8E  SO		0F  8F  SI
	XC	1011	:10  10  DLE		11  91  DC1
	XC	1213	:12  92  DC2		13  93  TM/DC3
	XC	7F0A	:14  FF  RES/***	15  8A  NL/LF
	XC	087F	:16  88  BS		17  FF  IL/***
	XC	1819	:18  98  CAN		19  99  EM
	XC	7F7F	:1A  FF  CC/***		1B  FF  ***
	XC	1C1D	:1C  9C  IFS/FS		1D  9D  IGS/GS
	XC	1E1F	:1E  9E  IRE/RS		1F  1F  IUS/US
	XC	7F7F	:20  FF DS/***		21  FF  SOS/***
	XC	1C7F	:22  9C  FS		23  FF  ***
	XC	7F0A	:24  FF  BYP/***	25  8A  LF
	XC	171B	:26  17  ETB		27  9B  ESC
	XC	7F7F	:28  FF  ***		29  FF  ***
	XC	7F7F	:2A  FF  SM/***		2B  FF  CU2/***
	XC	7F05	:2C  FF  ***		2D  05  ENQ
	XC	1617	:2E  86  ACK		2F  87  BEL
	XC	7F7F	:30  FF  ***		31  FF  ***
	XC	167F	:32  16  SYN		33  FF  ***
	XC	7F1E	:34  FF  ***		35  9E  RS
	XC	7F04	:36  FF  UC/***		37  04  EOT
	XC	7F7F	:38  FF  ***		39  FF  ***
	XC	7F7F	:3A  FF  ***		3B  FF  CU3/***
	XC	1415	:3C  94  DC4		3D  15  NAK
	XC	7F1A	:3E  FF  ***		3F  9A  SUB
	XC	207F	:40  A0  SPACE		41  FF  ***
	XC	7F7F	:42  FF  ***		43  FF  ***
	XC	7F7F	:44  FF  ***		45  FF  ***
	XC	7F7F	:46  FF  ***		47  FF  ***
	XC	7F7F	:48  FF  ***		49  FF  ***
	XC	5B2E	:4A  DB  CENT/[		4B  2E  .
	XC	3C28	:4C  BC  <		4D  A8  (
	XC	2B5E	:4E  AB  +		4F  DE  LOR/CARRET
	XC	267F	:50  A6  &		51  FF  ***
	XC	7F7F	:52  FF  ***		53  FF  ***
	XC	7F7F	:54  FF  ***		55  FF  ***
	XC	7F7F	:56  FF  ***		57  FF  ***
	XC	7F7F	:58  FF  ***		59  FF  ***
	XC	2124	:5A  A1  |		5B  A4  $
	XC	2A29	:5C  AA  *		5D  A9  )
	XC	3B5C	:5E  BB  SEMI:		5F  DC  LNOT/\
	XC	2D2F	:60  AD  -		61  AF  /
	XC	7F7F	:62  FF  ***		63  FF  ***
	XC	7F7F	:64  FF  ***		65  FF  ***
	XC	7F7F	:66  FF  ***		67  FF  ***
	XC	7F7F	:68  FF  ***		69  FF  ***
	XC	7C2C	:6A  FC  OVC BAR	6B  AC  ,
	XC	255F	:6C  A5  %		6D  DF  ULINE
	XC	3E3F	:6E  BE  >		6F  BF  ?
	XC	7F7F	:70  FF  ***		71  FF  ***
	XC	7F7F	:72  FF  ***		73  FF  ***
	XC	7F7F	:74  FF  ***		75  FF  ***
	XC	7F7F	:76  FF  ***		77  FF  ***
	XC	7F60	:78  FF  ***		79  E0  GV ACC
	XC	3A23	:7A  BA  :		7B  A3  #
	XC	4027	:7C  C0  @		7D  A7  `
	XC	3D22	:7E  BD  =		7F  A2  "
	XC	7F61	:80  FF  ***		81  E1  LC A
	XC	6263	:82  E2  LC B		83  E3  LC C
	XC	6465	:84  E4  LC D		85  E5  LC E
	XC	6667	:86  E6  LC F		87  E7  LC G
	XC	6869	:88  E8  LC H		89  E9  LC I
	XC	7F7B	:8A  FF  ***		8B  FB  LF BRCE
	XC	7F7F	:8C  FF  ***		8D  FF   ***
	XC	7F7F	:8E  FF  ***		8F  FF   ***
	XC	7F6A	:90  FF  ***		91  EA  LC J
	XC	6B6C	:92  EB  LC K		93  EC  LC L
	XC	6D6E	:94  ED  LC M		95  EE  LC N
	XC	6F70	:96  EF  LC O		97  FO  LC P
	XC	7172	:98  F1  LC Q		99  F2  LC R
	XC	7F7D	:9A  FF  ***		9B  FD  RT BRCE
	XC	7F7F	:9C  FF  ***		9D  FF  ***
	XC	7F7F	:9E  FF  ***		9F  FF  ***
	XC	7F7E	:A0  FF  ***		A1  FE  TILDA
	XC	7374	:A2  F3  LC s		A4  F4  LC t
	XC	7576	:A4  F5  LC u		A5  F6  LC v
	XC	7778	:A6  F7  LC w		A7  F8  LC x
	XC	797A	:A8  F9  LC y		A9  FA  LC z
	XC	7F7F	:AA  FF  ***		AB  FF  **
	XC	7F5B	:AC  FF  ***		AD  DB  [
	XC	7F7F	:AE  FF  ***		AF  FF  ***
	XC	7F7F	:B0  FF  ***		B1  FF  ***
	XC	7F7F	:B2  FF  ***		B3  FF  ***
	XC	7F7F	:B4  FF  ***		B5  FF  ***
	XC	7F7F	:B6  FF  ***		B7  FF  ***
	XC	7F7F	:B8  FF  ***		B9  FF  ***
	XC	7F7F	:BA  FF  ***		BB  FF  ***
	XC	7F5D	:BC  FF  ***		BD  DD  ]
	XC	7F7F	:BE  FF  ***		BF  FF  ***
	XC	7F41	:C0  FF  ***		C1  C1  A
	XC	4243	:C2  C2  B		C3  C3  C
	XC	4445	:C4  C4  D		C5  C5  E
	XC	4647	:C6  C6  F		C7  C7  G
	XC	4849	:C8  C8  H		C9  C9  I
	XC	7F7F	:CA  FF  ***		CB  FF  ***
	XC	7F7F	:CC  FF  ***		CD  FF  ***
	XC	7F7F	:CE  FF  ***		CF  FF  ***
	XC	7F4A	:D0  FF  ***		D1  CA  J
	XC	4B4C	:D2  CB  K		D3  CC  L
	XC	4D4E	:D4  CD  M		D5  CE  N
	XC	4F50	:D6  CF  O		D7  D0  P
	XC	5152	:D8  D1  Q		D9  D2  R
	XC	7F7F	:DA  FF  ***		DB  FF  ***
	XC	7F7F	:DC  FF  ***		DD  FF  ***
	XC	7F7F	:DE  FF  ***		DF  FF  ***
	XC	7C7F	:E0  FC  D VT BAR	E1  FF  ***
	XC	5354	:E2  D3  S		E3  D4  T
	XC	5556	:E4  D5  U		E5  D6  V
	XC	5758	:E6  D7  W		E7  D8  X
	XC	595A	:E8  D9  Y		E9  DA  Z
	XC	7F7F	:EA  FF  ***		EB  FF  CU1/***
	XC	7F7F	:EC  FF  ***		ED  FF  ***
	XC	7F7F	:EE  FF  ***		EF  FF  ***
	XC	3031	:F0  B0 0		F1  B1  1
	XC	3233	:F2  B2 2		F3  B3  3
	XC	3435	:F4  B4 4		F5  B5  5
	XC	3637	:F6  B6 6		F7  B7  7
	XC	3839	:F8  B8 8		F9  B9  9
	XC	7F7F	:FA  FF  ***		FB  FF  ***
	XC	7F7F	:FC  FF  ***		FD  FF  ***
	XC	7F7F	:FE  FF  ***		FF  FF  ***



:	ASCII TO EBCDIC CONVERSION
:	---------------------------
:	THIS TABLE CONVERTS A 7 BIT ASCII INDEX INTO EBCDIC.

ASCBCD	HS	0
:			ASC EBCDIC GRAPHIC	ASC EBCDIC GRAPHIC
	XC	0001	:00  00  NUL		01  01  SOH
	XC	0203	:02  02  STX		03  03  ETX
	XC	372D	:04  37  EOT		05  2D  ENQ
	XC	2E2F	:06  2E  ACK		07  2F  BEL
	XC	1605	:08  16  BS		09  05  HT
	XC	250B	:0A  25  LF		0B  0B  VT
	XC	0C0D	:0C  0C  FF		0D  0D  CR
	XC	0E0F	:0E  0E  SO		0F  0F  SI
	XC	1011	:10  10  DLE		11  11  DC1
	XC	1213	:12  12  DC2		13  13  DC3 / TM
	XC	3C3D	:14  3C  DC4		15  3D  NAK
	XC	3226	:16  32  SYN		17  26  ETB
	XC	1819	:18  18  CAN		19  19  EM
	XC	3F27	:1A  3F  SUB		1B  27  ESC
	XC	1C1D	:1C  1C  FS /IFS	1D  1D  GS / IGS
	XC	1E1F	:1E  1E  RS / IRS	1F  1F  US / IUS
	XC	405A	:20  40  SPACE		21  5A  !
	XC	7F7B	:22  7F  "		23  7B  #
	XC	5B6C	:24  5B  $		25  6C  %
	XC	507D	:26  50  &		27  7D  '
	XC	4D5D	:28  4D  (		29  5D  )
	XC	5C4E	:2A  5C  *		2B  4E  +
	XC	6B60	:2C  6B  ,		2D  60  -
	XC	4B61	:2E  4B  .		2F  61  /
	XC	F0F1	:30  F0  0		31  F1  1
	XC	F2F3	:32  F2  2		33  F3  3
	XC	F4F5	:34  F4  4		35  F5  5
	XC	F6F7	:36  F6  6		37  F7  7
	XC	F8F9	:38  F8  8		39  F9  9
	XC	7A5E	:3A  7A  :		3B  5E  SEMI:
	XC	4C7E	:3C  4C  <		3D  7E  =
	XC	6E6F	:3E  6E  >		3F  6F  ?
	XC	7CC1	:40  7C  @		41  C1  A
	XC	C2C3	:42  C2  B		43  C3  C
	XC	C4C5	:44  C4  D		45  C5  E
	XC	C6C7	:46  C6  F		47  C7  G
	XC	C8C9	:48  C8  H		49  C9  I
	XC	D1D2	:4A  D1  J		4B  D2  K
	XC	D3D4	:4C  D3  L		4D  D4  M
	XC	D5D6	:4E  D5  N		4F  D6  O
	XC	D7D8	:50  D7  P		51  D8  Q
	XC	D9E2	:52  D9  R		53  E2  S
	XC	E3E4	:54  E3  T		55  E4  U
	XC	E5E6	:56  E5  V		57  E6  W
	XC	E7E8	:58  E7  X		59  E8  Y
	XC	E9AD	:5A  E9  Z		5B  AD  [
	XC	5FBD	:5C  5F  \ / LNOT	5D  BD  ]
	XC	4F6D	:5E  4F  CARRET / LOR	5F  6D  ULINE
	XC	7981	:60  79  GV ACC		61  81  LC A
	XC	8283	:P62  82  LC B		63  83  LC C
	XC	8485	:64  84  LC D		65  85  LC E
	XC	8687	:66  86  LC F		67  87  LC G
	XC	8889	:68  88  LC H		69  89  LC I
	XC	9192	:6A  91  LC J		6B  92  LC K
	XC	9394	:6C  93  LC L		6D  94  LC M
	XC	9596	:6E  95  LC N		6F  96  LC O
	XC	9798	:70  97  LC P		71  98  LC Q
	XC	99A2	:72  99  LC R		73  A2  LC S
	XC	A3A4	:74  A3  LC T		75  A4  LC U
	XC	A5A6	:76  A5  LC V		77  A6  LC W
	XC	A7A8	:78  A7  LC X		79  A8  LC Y
	XC	A98B	:7A  A9  LC Z		7B  8B  LF BRCE
	XC	6A9B	:7C  6A  D VT BAR	7D  9B  RT BRCE
	XC	A1FF	:7E  A1  TILDA		7F  FF  DEL


    	SUBTTL	(SNA)	Command List Package	--	CMDLST
:CMDL00.F00

	RA	0

	MO	.,CMDLST

	LO	MAIN
	LO	GBLDEF


:
:	These routines manage the command lists. The command list pool is
:	a double linked list, from which links can be removed from either
:	ends.
:
:
:	NOTE...
:		COMMAND LIST POOL MUST BE LESS THAN 32K BYTES.
:


:
:	RE-DEFINE BBL AND BBST MACRO TO ALIGN THE INSTRUCTIONS
:	FOR FW BB
:
	IF	FWBBF
BBL	MACRO[
	L]
BBST	MACRO[
	ST]
	ELSE
BBL	MACRO[
	LHL]
BBST	MACRO[
	STH]
	EI	(FWBBF)


:	DEFINE REGISTERS' USAGE
:	------------------------
RLNK	EQ	4			:LINK REGISTER
RARG	EQ	6			:ARGUMENT REGISTER
RWORK	EQ	7			:WORK REGISTER


:	CRASH CODES
:	-----------
CRCLLK	EQ	50			:COMMAND LIST LOCKED
CRCLMT	EQ	51			:COMMAND LIST EMPTY


:
:	COMMAND ELEMENT FORMAT
:	----------------------
:	BS 1	- COMMAND TYPE
:	BS 1	- SUBCOMMAND TYPE
:	HS 1	- CMD ELEMENT LINK PTR (I.E. LINK TO NEXT CMD ELEMENT)
:	HS 1	- DATA LENGTH IF ANY
:	HS 1/WS 1	- PTR TO 1ST DATA BUFFER IF ANY
:
OLDORG	EQ	.
	ORG	0
CLCMD	BS	1			:COMMAND CODE
CLCMDS	BS	1			:SUB COMMAND CODE
CLPTR	HS	1			:NEXT CMD ELEMENT PTR
CLLNG	HS	1			:CMD DATA LENGTH
CLADR	EQ	CLLNG+1			:QLLC ADR BYTE
	IF	FWBBF
CLARG	HS	2			:DATA BUFFER PTR (12/20/84 MIA)
	ELSE
CLARG	HS	1			:DATA BUFFER PTR
	EI	(FWBBF)
CMDSZ	EQ	.			:CMD ELEMENT SIZE
	ORG	OLDORG

	IF	CMDSZ*NCMDLK-10000
NCMDLO	EQ	NCMDLK
NCMDLK	EQ	10000/CMDSZ
	REMARK	%Cmd link allocation was cut by 
	NUMBER	$A (NCMDLO-NCMDLK)*100/NCMDLO
	REMARK	 per cent
	EI

:
:	STORAGE AND CONSTANTS
:	-----------------------
:


	SEG	A.DATA
:	FREE LIST 1
:	-----------
CLLK1	HS	1			:LOCK FOR FREE LIST 1
CFLP1	HS	1			:PTR TO FIRST ENTRY
OFFST1	EQ	0			:OFFSET OF LINKING PTR FOR LIST 1


:	FREE LIST 2
:	-----------
CLLK2	HS	1			:LOCK
CFLP2	HS	1			:PTR TO FIRST ENTRY
OFFST2	EQ	2			:OFFSET OF LINKING PTR


:	ALLOCATE STORAGE FOR CMD ELEMENT LIST POOL
:	------------------------------------------

	SEG	A.CMDB

CMDBLK	HS	1			:UNUSED
CMD1ST	BS	CMDSZ*NCMDLK		:COMMAND LINK SPACE

:DELETED REFERENCES TO A.BDA1 (01/21/85 MIA)
:	SEG	A.BDAT
:
:Q	EQ	.-(A.BDA1^$A16)
:	IF	Q-0
:	ELSE
:	SEG	A.BDA1
:	HC	0DEAF			:IF NOTHING IN A.BDA1 SEGMENT
:	EI


	SEG	A.CODE
:******************************************************************:
:	GETCL - GET A COMMAND LINK FROM FREE POOL		   :
:								   :
:	RARG - PTR TO ALLOCATED LINK (RELATIVE TO CMDBLK)	   :
:	THIS ROUTINE WILL SKIP RETURN IF SUCCESSFUL (GOT A LINK)   :
:	AND IT MAY CRASH IF BOTH LISTS ARE LOCKED.		   :
:******************************************************************:
GETCL	LIS	RWORK,0
	SBT	RWORK,CLLK1,,		:LIST 1 LOCKED ?
	JEFS	GCL1			:N -
	SBT	RWORK,CLLK2,,		:LIST 2 LOCKED ?
	JE	GCL2			:N -
	SBT	RWORK,CLLK1,,		:TEST LOCK 1 AGAIN
	JEFS	GCL1
	JAL	R10,CRASH
	BC	0,0,4*RLNK,CRCLLK	:COMMAND LIST LOCKED
:
:	GET LINK FROM LIST 1
:GCL1	LH	RARG,CFLP1		:LST PTR1(3/6/84/CHS) (12/27/84 MIA)
:	CLH	RARG,CFLP2		:COMP TO OTHR LST PTR (12/27/84 MIA)
GCL1	LHL	RARG,CFLP1,,		:GET FREE LST PTR1 (12/27/84 MIA)
	LHL	RWORK,CFLP2,,		:GET OTHER FREE LST PTR (12/27/84 MIA)
	CR	RARG,RWORK		:COMPARE POINTERS (12/27/84 MIA)
	JE	GCL12			:EQUAL - LIST IS EMPTY
:	NHI	RARG,0FFFF		:CNV TO POS(3/6/84/CHS) (12/27/84 MIA)
	LH	RWORK,CMDBLK+OFFST1,RARG, :(3/6/84/CHS)
					:RWORK = PTR TO SECOND LIST ENTRY
	CLH	RWORK,CFLP2,,		:COMPARE TO OTHER FREE LIST PTR
	JE	GCL12			:EQUAL - TREAT LIST AS EMPTY
	STH	RWORK,CFLP1,,		:UPDATE FREE LIST 1 PTR
	LIS	RWORK,0
	RBT	RWORK,CLLK1,,		:RESET LOCK
	STH	RWORK,CMDBLK+CLCMD,RARG, :(3/6/84/CHS) CLEAR CMD ELEMENT
	STH	RWORK,CMDBLK+CLPTR,RARG, :(3/6/84/CHS) CLEAR CMD ELEMENT
	STH	RWORK,CMDBLK+CLLNG,RARG, :(3/6/84/CHS) CLEAR CMD ELEMENT
	BBST	RWORK,CMDBLK+CLARG,RARG, :(3/6/84/CHS) CLEAR CMD ELEMENT
	J	4,RLNK			:SKIP RETURN
:	LIST WAS EMPTY . RELEASE LOCK AND DO STRAIGHT RETURN
GCL12	LIS	RWORK,0
	RBT	RWORK,CLLK1,,
	JR	RLNK

:	GET LINK FROM FREE LIST 2
:GCL2	LH	RARG,CFLP2		:PTR TO 1ST(3/6/84/CHS) (12/27/84 MIA)
:	CLH	RARG,CFLP1		:COMP TO OTHR LIST PTR (12/27/84 MIA)
GCL2	LHL	RARG,CFLP2,,		:GET PTR TO 2ND LST (12/27/84 MIA)
	LHL	RWORK,CFLP1,,		:GET PTR TO OTHER LIST (12/27/84 MIA)
	CR	RARG,RWORK		:COMPARE POINTERS (12/27/84 MIA)
	JE	GCL22			:EQUAL - LIST EMPTY
:	NHI	RARG,0FFFF		:CNV TO POS(3/6/84/CHS) (12/27/84 MIA)
	LH	RWORK,CMDBLK+OFFST2,RARG, :(3/6/84/CHS)
					:RWORK = PTR TO SECOND LIST ENTRY
	CLH	RWORK,CFLP1,,		:COMPARE TO OTHER FREE LIST PTR
	JE	GCL22			:EQUAL - LIST EMPTY
	STH	RWORK,CFLP2,,		:UPDATE FREE LIST PTR 2
	LIS	RWORK,0
	RBT	RWORK,CLLK2,,		:RELEASE LOCK
	STH	RWORK,CMDBLK+CLCMD,RARG, :(3/6/84/CHS) CLEAR CMD ELEMENT
	STH	RWORK,CMDBLK+CLPTR,RARG, :(3/6/84/CHS) CLEAR CMD ELEMENT
	STH	RWORK,CMDBLK+CLLNG,RARG, :(3/6/84/CHS) CLEAR CMD ELEMENT
	BBST	RWORK,CMDBLK+CLARG,RARG, :(3/6/84/CHS) CLEAR CMD ELEMENT
	J	4,RLNK			:SKIP RETURN
:	FREE LIST IS EMPTY - UNLOCK LIST AND RETURN
GCL22	LIS	RWORK,0
	RBT	RWORK,CLLK2,,
	JR	RLNK

:***************************************************************:
:								:
:	RELCL - RETURN A CMD LINK TO FREE POOL REGISTER USAGE	:
:	LIKE GETCL						:
:								:
:***************************************************************:
RELCL					:(10/14/83 CHS)
	IF	8000-CMDSZ*(NCMDLK-1)-2	:(12/27/84 MIA)
	LR	RARG,RARG		:CHECK RARG WITHIN RANGE
	JLEFS	REL0
	CLHI	RARG,CMDSZ*(NCMDLK-1)+2
	JLEFS	RELCL1
	ELSE				:(12/27/84 MIA)
	LHR	RWORK,RARG		:EXPAND RARG (12/27/84 MIA)
	JEFS	REL0			:BAD POINTER IF 0 (12/27/84 MIA)
	JGFS	RELCL1			:OK IF POSITIVE (12/27/84 MIA)
	CHI	RWORK,CMDSZ*(NCMDLK-1)+2 :COMP WITH NEG LIMIT (12/27/84 MIA)
	JLEFS	RELCL1			:JUMP IF WITHIN LIMIT (12/27/84 MIA)
	EI
REL0
	JAL	R10,CRASH
	BC	0,0,4*RLNK,CRBCMD
RELCL1
	LIS	RWORK,0
	SBT	RWORK,CLLK1,,		:TRY TO LOCK LIST 1
	JE	RCL1			:NOT LOCKED -
	SBT	RWORK,CLLK2,,		:LIST 2 LOCKED ?
	JE	RCL2			:NOT LOCKED -
:	A RACE CONDITION COULD CAUSE US TO GET HERE
:	TRY LIST 1 AGAIN
:	IF STILL LOCKED - CRASH
	SBT	RWORK,CLLK1,,
	JEFS	RCL1
	JAL	R10,CRASH		:CRASH THE INTERFACE
	BC	0,0,4*RLNK,CRCLLK	:COMMAND LIST LOCKED
:	PUT LINK BACK AT LIST 1 END
RCL1	LHL	RWORK,CFLP1,,		:RWORK = PTR TO FIRST ENTRY
	STH	RWORK,CMDBLK+OFFST1,RARG, :LINK FIRST ENTRY TO NEW ENTRY
	STH	RARG,CMDBLK+OFFST2,RWORK, :LINK NEW ENTRY TO FIRST ENTRY
	STH	RARG,CFLP1,,		  :MAKE NEW ENTRY THE FIRST ENTRY
	LIS	RWORK,0
	RBT	RWORK,CLLK1,,		:RELEASE LOCK 1
	JR	RLNK			:RETURN
:	PUT LINK BACK ON LIST 2
RCL2	LHL	RWORK,CFLP2,,		:RWORK = PTR TO FIRST ENTRY
	STH	RWORK,CMDBLK+OFFST2,RARG, :LINK FIRST ENTRY TO NEW ENTRY
	STH	RARG,CMDBLK+OFFST1,RWORK, :LINK NEW ENTRY TO FIRST ENTRY
	STH	RARG,CFLP2,,		  :MAKE NEW ENTRY THE FIRST ENTRY
	LIS	RWORK,0
	RBT	RWORK,CLLK2,,		:RELEASE LOCK 2
	JR	RLNK			:RETURN

:***************************************************************:
:								:
:	IZCFL - INITIALIZE COMMAND FREE LIST			:
:								:
:***************************************************************:
IZCFL	LIS	RARG,0
	STH	RARG,CLLK1,,		:LOCK 1 = 0
	STH	RARG,CLLK2,,		:LOCK 2 = 0
	LHI	RARG,CMD1ST-CMDBLK	:OFFSET OF FIRST LINK
	STH	RARG,CFLP1,,		:FREE LIST 1 PTR = FIRST LINK
IZCFL1	LR	RWORK,RARG
	AIS	RARG,CMDSZ		:RARG = NEXT LINK
	STH	RARG,CMDBLK+OFFST1,RWORK, :LINK NEXT ENTRY TO CURRENT ONE
	STH	RWORK,CMDBLK+OFFST2,RARG, :LINK CURRENT TO NEXT
	IF	8000-CMDSZ*(NCMDLK-1)	:(12/27/84 MIA)
	CLHI	RARG,CMDSZ*(NCMDLK-1)	:LAST LINK REACHED ?
	JLBS	IZCFL1			:NO - CONTINUE
	ELSE				:(12/27/84 MIA)
	LHR	RWORK,RARG		:EXPAND THE POINTER (12/27/84 MIA)
	JGBS	IZCFL1			:CONTINUE IF POSITIVE (12/27/84 MIA)
	CHI	RWORK,CMDSZ*(NCMDLK-1)	:LAST LINK REACHED? (12/27/84 MIA)
	JLBS	IZCFL1			:CONTINUE IF NOT (12/27/84 MIA)
	EI				:(12/27/84 MIA)
	STH	RARG,CFLP2,,		:FREE LIST PTR 2 = LAST LINK
	JR	RLNK			:RETURN
:***************************************************************:
:								:
:	CKCMDL - CHECK FOR FREE CMD LINKS			:
:	SET CONDITION CODE = 0 IF NOT ENOUGH AVAILABLE		:
:	RARG - NUMBER OF LINKS NEEDED				:
:								:
:***************************************************************:
CKCMDL	LH	RWORK,CFLP1,,		:GET FREE LIST PTR 1(3/6/84/CHS)
	CLH	RWORK,CFLP2,,		:EMPTY ?
	JER	RLNK			:Y - RETURN
:CKCMD1	NHI	RWORK,0FFFF		:CNV TO POS(3/6/84/CHS) (12/27/84 MIA)
CKCMD1	EQ	.			:(12/27/84 MIA)
	IF	CMDSZ*(NCMDLK-1)-7FFF	:(12/27/84 MIA)
	SLL	RWORK,10		:SHIFT OUT HIGH HLF WRD (12/27/84 MIA)
	SRL	RWORK,10		:SHIFT BACK (12/27/84 MIA)
	EI				:(12/27/84 MIA)
	LH	RWORK,CMDBLK+OFFST1,RWORK, :GET NEXT LINK(3/6/84/CHS)
	CLH	RWORK,CFLP2,,		:LAST ONE ?
	JER	RLNK			:Y - RETURN
	SIS	RARG,1			:DEC. NO. LINKS NEEDED
	JGBS	CKCMD1			:CONTINUE WHILE MORE LINKS NEEDED
	LIS	RWORK,1			:SET C.C. NOT ZERO
	JR	RLNK			:RETURN

:
:	COMMAND LIST MACROS
:
:	IZCL - INITIALIZE A COMMAND LIST
:
:	PUTCMD - PUT A COMMAND INTO A LIST
:
:	RLCMD - RELEASE ALL COMMANDS IN A LIST
:		(THIS MAKES THEM ACCESSIBLE TO PEEKS)
:
:	ADVCMD - REMOVE THE FIRST COMMAND FROM THE LIST
:
:	REGISTER USAGE
:
:	R2 - COMMAND CODE
:	R3 - SECOND HALFWORD OF THE COMMAND
:	RLNK - LINK TO GETCL AND RELCL
:	RARG - PTR TO CMD LINK (PARM TO GETCL / RELCL )
:	RWORK - WORK REGISTER
:	RLSC - CURRENT LSC ADDR (OFFSET)
:	RLCB - CURRENT LCB ADDR (OFFSET)
:
:	NAMING CONVENTIONS
:
:	LNAME - COMMAND LIST NAME ( RCV , XMT , ERR ,etc.)
:	EACH LIST HAS A GET , RELEASE AND PUT PTRS
:	WHOSE NAME IS DERIVED FROM THE LIST NAME
:

IZCL	MACRO(LNAME,RLSC,RLCB)
	[
	JAL	RLNK,GETCL,,		:GET A FREE LINK
	JAL	RLNK,CLMPTY
	STH	RARG,LSCLKS+SGP`LNAME,RLSC, :SET GET,RELEASE AND PUT PTRS
	STH	RARG,LSCLKS+SRP`LNAME,RLSC,
	STH	RARG,LSCLKS+SPP`LNAME,RLSC,
	LB	R0,LSCLKS+LSCRID,RLSC,	:GET STATION'S REL ID.
	RBT	R0,LCBTAB+LDA`LNAME,RLCB, :RESET DATA PRESET
			]

PUTCMD	MACRO(LNAME,RLSC)
	[
	JAL	RLNK,GETCL,,		:GET A FREE LINK
	JAL	RLNK,CLMPTY
	LHL	RWORK,LSCLKS+SPP`LNAME,RLSC, :GET PUT PTR
	STH	R1,CMDBLK+CLCMD,RWORK,
	STH	R2,CMDBLK+CLLNG,RWORK,
	BBST	R3,CMDBLK+CLARG,RWORK,
	STH	RARG,CMDBLK+CLPTR,RWORK, :LINK NEW ENTRY
	STH	RARG,LSCLKS+SPP`LNAME,RLSC,
			]

RLCMD	MACRO(LNAME,RLSC,RLCB)
	[
	LHL	RARG,LSCLKS+SPP`LNAME,RLSC,
	STH	RARG,LSCLKS+SRP`LNAME,RLSC, :SET RELEASE PTR = PUT PTR
	LB	R0,LSCLKS+LSCRID,RLSC,	:GET REL STATION ID.
	SBT	R0,LCBTAB+LDA`LNAME,RLCB, :SET DATA PRESENT
			]


ADVCMD	MACRO(LNAME,RLSC,RLCB)
	[
	LHL	RARG,LSCLKS+SGP`LNAME,RLSC,
	LH	RWORK,CMDBLK+CLPTR,RARG, :(3/6/84/CHS)
	JE	CLERR			:CRASH IF ADVANCING AN EMPTY LIST
	STH	RWORK,LSCLKS+SGP`LNAME,RLSC,
	LB	R0,LSCLKS+LSCRID,RLSC,	:GET REL STAION ID.
	RBT	R0,LCBTAB+LDA`LNAME,RLCB, :FIRST TURN OFF DATA PRES.
	CLH	RWORK,LSCLKS+SRP`LNAME,RLSC, :COMPARE GET AND REL. PTRS.
	JEFS	.+08			:SKIP IF EQUAL
	SBT	R0,LCBTAB+LDA`LNAME,RLCB, :NOT EMPTY - TURN ON DATA PRES.
	JAL	RLNK,RELCL  ]

CLERR	JAL	R10,CRASH		:BAD COMAND ADVANCE
	BC	0,0,0,CRBCMD  


:	CLMPTY - CALLED BY PUTCMD WHEN IT CANT GET A FREE CMD
:	LINK
CLMPTY	JAL	R10,CRASH		:CRASH THE INTERFACE
	BC	0,0,01,CRCLMT		:CMD LIST EMPTY
	FO	GBLDEF

	EM
  	SUBTTL	Big Bufferlet Package	BBFLET.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		mfr 08/2/81

:THIS ROUTINE IS DIFFERENT FROM LIBRARY PACKAGE ONLY IN THAT IT USES
:ONLY 1 LOGICAL SEGMENT FOR A.BUFF SEGMENT (01/21/85 MIA).

:	This package contains all code and storage allocation needed for
:	dynamic allocation of big bufferlets.  It contains no routines
:	which manage data in big bufferlets.  Such routines are left to
:	be written by the user.

:	This is the two level re-entrant version (all routines can be called
:	by both foreground and background).


:	the following parameters MUST be defined before assembly:
:	NBBFLT	the number of big bufferlets to create.  Two of them will
:		"never" be allocated, to avoid possible race conditions
:		and unraveling of the free list.  This can't be
:		counted on, however, since it is possible for one of the
:		unusable 2 to get allocated if things are timed in just the
:		right order.
:	BBFLSZ	the size (in bytes) of a big bufferlet, MUST be even

:	If more than one segment (64K) of bufferlets are being
:	defined, the symbol FWBBF must be globally defined and set
:	to 1.  This will cause all bufferlet pointers to be a fullword.
:	All external references to the bufferlet pointers must reflect this.
:	By using the macros BBLOAD and BBSTOR this choice of halfword
:	or fullword will be automatic for the accesses.

:	the following parameters are defined for the user:
:	BBUFER	base address of big bufferlet storage area
:	BBFPSZ	The size in bytes of a bufferlet pointer

:	the following external routines are used:
:	CRASH	JAL R10,CRASH performed if catistrophic theoretically
:		impossible conditions occur

:	The big bufferlets are kept in a double linked free list
:	from which they are allocated when needed.  The pointers
:	used are relative to BBUFER.

:	The package contains both utility and primitive routines:

:	utility routines are called with link on RLINK1
:	PBBC   -Put Big Bufferlet Chain
:		RCH = pointer to 1st big bufferlet in chain
:		PBBC will return a chain of big bufferlets to the dynamic pool


:	primitive routines are called with link on RLINK
:	IZBB   -Initialize Big Bufferlets
:		initializes big bufferlet double linked list used to
:		dynamically allocate big bufferlets.
:	GBB    -Get Big Bufferlet
:		Return	       -No Big Bufferlet is available
:		Skip return    -RCH has pointer to big bufferlet, chain
:				half-word in big bufferlet set to zero
:	PBB    -Put Big Bufferlet
:		RCH has pointer to big bufferlet to return to dynamic pool
:
:	The package also contains macros for ease in accessing the
:	buferlets. Both BBLOAD and BBSTOR will generate halfword/fullword
:	load or store instructions as appropriate.

:       Debugging modes:  (active if symbol defined as a positive number)
:               BBF.D1  Count GBB and RBB calls in global cell 'BUFCNT'.
:                       When all bufferlets put back, BUFCNT=0.  Crash if
:                       BUFCNT<0.
:
:               BBF.D2  Software crash when no bufferlets available on
:                       GBB call.  This fixes lost bufferlet problem.
:
:               BBF.D3  On all returns of BB to chain, check BB addr. range.
:			CRASHES IF NOT VALID RANGE.
:
:		BBF.D4	On all gets and puts to the bufferlet pool
:			an indicator is set to indicate the status of the
:			bufferlet. If a bufferlet in use is reused or an
:			unused bufferlet is released it will crash.
:			This switch also causes allocation of a table for
:			lower halfword of the address of the caller for
:			bufferlet get.
:


	GL	NBBFLT,BBFLSZ
	MO	.,BBUFER
	GL	IZBB,GBB,PBB,PBBC,BBUFER	:PROVIDED TO USER
	GL	CRASH				:EXTERNAL ROUTINES NEEDED

	GL	BBFPSZ,FWBBF
  IF \FWBBF
  ELSE
FWBBF	EQ	0	:IF NOT SET, DEFAULT TO OFF
  EI
  IF FWBBF
BBFPSZ	EQ	4	:POINTER IS FULLWORD
BBLOAD	MACRO(d)[L]	:LOAD AND STORE FOR FULLWORDS
BBSTOR	MACRO(d)[ST]
  ELSE
BBFPSZ	EQ	2	:POINTER IS HALFWORD
BBLOAD	MACRO(d)[LHL]	:LOAD AND STORE FOR HALWORDS
BBSTOR	MACRO(d)[STH]
  EI


:	REGISTER USAGE DEFINITION
RCH	EQ	R3		:REG WITH BUFFERLET ADDR
RLINK	EQ	R4		:LINKAGE FOR IZBB,GBB,PBB
RLINK1	EQ	R5		:LINKAGE FOR PBBC
RW1	EQ	R6		:WORK REG FOR IZBB,GBB,PBB
RW2	EQ	R7		:WORK REG FOR IZBB,GBB,PBB
RW3	EQ	R2		:WORK REG FOR PBBC


:       DEBUGGING OPTIONS
  IF	\SNOBUF
  ELSE
SNOBUF	EQ	0		:DON'T SIMULATE NO BUFFERLETS EVER
  EI

  IF \BBF.D1
  ELSE
BBF.D1	EQ	0
  EI

  IF \BBF.D2
  ELSE
BBF.D2	EQ	0
  EI

  IF \BBF.D3
  ELSE
BBF.D3	EQ	0
  EI

 IF \BBF.D4
  IF BBF.D3
  ELSE
	REMARK	%%BBF.D4 CANNOT BE USED WITHOUT BBF.D3 SET.%%
  EI
 ELSE
BBF.D4	EQ	0
 EI

:	DATA AREA
	SEG	A.DATA
FREE1	WC	0		:INDEX OF HEAD OF LIST 1
FREE2	WC	0		:INDEX OF HEAD OF LIST 2
LOCK1	HC	0		:8000 = LIST 1 LOCKED DUE TO RE-ENTRANTCY
LOCK2	HC	0		:8000 = LIST 2 LOCKED DUE TO RE-ENTRANTCY
  IF BBF.D1
        GL        BUFCNT
BUFCNT  HC      0       :Used bufferlet counter
  EI

:	BUFFERLET AREA
:Q	EQ	A.BUFF
:QQ	EQ	NBBFLT*BBFLSZ

	SEG	A.BUFF		:ALLOCATE IN BUFFER AREA
	IF	.-2+NBBFLT*BBFLSZ-0E0000
NBBFLO	EQ	NBBFLT
NBBFLT	EQ	(0E0000-.+2)/BBFLSZ
	REMARK	%Buffer allocaltion was cut by 
	NUMBER	$A (NBBFLO-NBBFLT)*100/NBBFLT
	REMARK	 per cent
	EI
	HS	0		:ALLIGN TO HALF-WORD
BBUFER	EQ	.-2		:BASE ADDRESS OF BUFFERLET AREA
	BS	NBBFLT*BBFLSZ	:(01/21/85 MIA)
:	RE
:	SEG	Q
:  IF QQ-10000
:	BS	10000
:  ELSE
:	BS	QQ
:  EI
:QQ	EQ	QQ-10000
:Q	EQ	Q+1
:	ER	QQ	:STOP WHEN QQ <= 0
:A.BUFF	EQ	Q-1
CHAIN1	EQ	BBUFER+BBFLSZ-BBFPSZ
CHAIN2	EQ	CHAIN1-BBFPSZ
	SEG	A.CODE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			 S U B R O U T I N E   I Z B B			     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

IZBB	LIS	RCH,2		:RCH = RELATIVE ADDR OF BUFFERLET
	ST	RCH,FREE1,,	:INIT FREE CHAIN
	LHI	RW1,NBBFLT	:RW1 = NO. BUFLETS IN FREE LIST
	LIS	RW2,0		:CLEAR THE REGISTER

IBB10	SIS	RW1,1		:DEC BUFFERLET CNT
	JE	IBB20
 IF BBF.D4
	RBT	RW1,BBFLAG,,	:CLEAR BUFFERLET IN USE INDICATOR
	STH	RW2,BBUSER,RW1,RW1	:CLEAR THE USER POINTER
 EI
		:JUMP TO TERMINATE CHAIN
  IF FWBBF
	ST	RCH,CHAIN2+BBFLSZ,RCH,	:BACKWARD LINK IN NEXT BB
	AHI	RCH,BBFLSZ	:FIND NEXT BUFFERLET START
	ST	RCH,BBUFER-4,RCH,	:SET CHAIN TO IT
  ELSE
	STH	RCH,CHAIN2+BBFLSZ,RCH,	:BACKWARD LINK IN NEXT BB
	AHI	RCH,BBFLSZ	:FIND NEXT BUFFERLET START
	STH	RCH,BBUFER-2,RCH,	:SET CHAIN TO IT
  EI
	J	IBB10
IBB20	ST	RCH,FREE2,,	:HEAD OF LIST 2

          IF BBF.D1
            STH     RW1,BUFCNT,,      :Start with zero used
          EI
          IF BBF.D3
            STH     RW1,BBCKLK,,     :Init stack pointer
          EI
 IF	BBF.D4
	RBT	RW1,BBFLAG,,	:CLEAR BUFFERLET IN USE INDICATOR
	STH	RW1,BBUSER,,	:CLEAR USER POINTER
 EI
	LIS	RW1,0		:SET BIT POINTER
	RBT	RW1,LOCK1,,	:RESET LIST 1 LOCK
	RBT	RW1,LOCK2,,	:RESET LIST 2 LOCK
	JR	RLINK

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			  S U B R O U T I N E	G B B			     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

GBB	LIS	RW1,0		:INIT FOR BIT TESTS
                IF      SNOBUF          :SIMULATE NO BUFFER AVAILABLE
                :-:-:-:-:-:-:-:-:-:-:-:  ERROR SIMULATE :-:-:-:-:-:-:-:-:-:-:-:
                LCS     RW2,1           :COUNT ENTRY                          :
                AHM     RW2,SNOBCT                                            :
                JGFS    SNOBRT          :JUMP NOT TIME TO SIMULATE            :
                LHI     RW2,SNOBUF      :RESET ERROR SIMULATE CNTR            :
                STH     RW2,SNOBCT                                            :
                JR      RLINK           :TAKE NO BUFFERLET AVAILABLE RETURN   :
                SEG     A.DATA
SNOBCT		HC	SNOBUF		:ERROR COUNTER
		SEG	A.CODE
SNOBRT          EQ      .                                                     :
                :-:-:-:-:-:-:-:-:-:-:-:  ERROR SIMULATE :-:-:-:-:-:-:-:-:-:-:-:
                EI      :SNOBUF
	SBT	RW1,LOCK1,,	:LIST 1 LOCKED ?
	JN	GBB20		:JUMP IF SO, TRY LIST 2
	L	RCH,FREE1,,	:GET INDEX TO NEXT FREE BUFFERLET
	CL	RCH,FREE2,,	:COMPARE WITH OTHER PTR
	JE	NOBBF1		:EQUAL - LIST EMPTY

  IF FWBBF
	L	RW2,CHAIN1,RCH, :GET CHAIN TO NEXT FREE BUFFERLET
  ELSE
	LHL	RW2,CHAIN1,RCH, :GET CHAIN TO NEXT FREE BUFFERLET
  EI
	CL	RW2,FREE2,,	:COMPARE WITH OTHER LIST PTR
	JE	NOBBF1		:EQUAL - TREAT LIST AS EMPTY
	ST	RW2,FREE1,,	:PUT IN FREE POINTER
  IF FWBBF
	ST	RW1,CHAIN1,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
	ST	RW1,CHAIN2,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
  ELSE
	STH	RW1,CHAIN1,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
	STH	RW1,CHAIN2,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
  EI
          IF BBF.D1
              LIS       RW1,1
              AHM       RW1,BUFCNT,,      :Increment BUFCNT
	      LIS	RW1,0		:RESET THE REGISTER
          EI
 IF	BBF.D4
	LHI	RW1,-2,RCH	:SUBTRACT OFFSET
	DH	RW1,BBCKD,,	:DETERMINE BUFFERLET NUMBER
	SBT	RW2,BBFLAG,,	:SET INDICATOR FOR BUFFERLET IN USE
	JN	BBFLCR		:CRASH IF BUFFERLET WAS IN USE
	STH	RLINK,BBUSER,RW2,RW2	:SET USER POINTER
 EI
	RBT	RW1,LOCK1,,	:UNLOCK LIST 1
	J	4,RLINK 	:SKIP RETURN (BUFFERLET FOUND)

:	LIST 1 WAS LOCKED OR EMPTY, TRY LIST 2.
:	IF LIST 2 EMPTY OR LOCKED, RETURN.  THEORETICALLY, BOTH
:	LISTS WILL NEVER BE LOCKED (IF THEY ARE, IT
:	IS A DESIGN ERROR THAT PBB WILL DETECT AND CRASH).

GBB20	SBT	RW1,LOCK2,,	:LIST 2 LOCKED ?
        JN      NOBBUF          :Jump if  can't provide bufferlet
	L	RCH,FREE2,,	:GET INDEX TO NEXT BUFFERLET
	CL	RCH,FREE1,,	:COMPARE WITH OTHER PTR
	JNFS	GBB30		:JUMP BUFFERLET AVAILABLE
NOBBF2	RBT	RW1,LOCK2,,	:UNLOCK LIST 2 (EMPTY)
NOBBUF	EQ	.
          IF BBF.D2
            JAL       R10,CRASH       :No bufferlet crash
            BC        0,0,4*RLINK,0D2
          EI
	JR	RLINK		:RETURN (CAN'T PROVIDE BUFFERLET)

NOBBF1	RBT	RW1,LOCK1,,	:UNLOCK
	JBS	NOBBUF

  IF FWBBF
GBB30	L	RW2,CHAIN2,RCH, :GET CHAIN TO NEXT BUFFERLET
  ELSE
GBB30	LHL	RW2,CHAIN2,RCH, :GET CHAIN TO NEXT BUFFERLET
  EI
	CL	RW2,FREE1,,	:COMPARE WITH OTHER PTR
	JE	NOBBF2		:EQUAL - TREAT LIST AS EMPTY
	ST	RW2,FREE2,,	:PUT AT HEAD OF LIST 2
  IF FWBBF
	ST	RW1,CHAIN1,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
	ST	RW1,CHAIN2,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
  ELSE
	STH	RW1,CHAIN1,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
	STH	RW1,CHAIN2,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
  EI
          IF BBF.D1
            LIS       RW1,1
            AHM       RW1,BUFCNT,,      :Increment BUFCNT
	    LIS       RW1,0		:RESET THE REGISTER
          EI
 IF	BBF.D4
	LHI	RW1,-2,RCH	:SUBTRACT OFFSET
	DH	RW1,BBCKD,,	:DETERMINE BUFFERLET NUMBER
	SBT	RW2,BBFLAG,,	:SET INDICATOR FOR BUFFERLET IN USE
	JN	BBFLCR		:CRASH IF BUFFERLET WAS IN USE
	STH	RLINK,BBUSER,RW2,RW2	:SET USER POINTER
 EI
	RBT	RW1,LOCK2,,	:UNLOCK LIST 2
	J	4,RLINK 	:SKIP RETURN (BUFFERLET FOUND)


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			  S U B R O U T I N E	P B B			     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


PBB     EQ      .               :Start of routine PBB

	  IF BBF.D1
            LCS       RW1,1
            AHM       RW1,BUFCNT,,      :Decrement BUFCNT
	    JGEFS	PBB01		:Jump if ok
            JAL       R10,CRASH       :Crash if too many put back
            BC        0,0,4*RLINK,0D1
          EI

PBB01	LIS	RW1,0		:INIT FOR BIT TESTS
	SBT	RW1,LOCK1,,	:LIST 1 LOCKED ?
	JN	PBB20		:JUMP IF SO, TRY LIST 2

PBB10	EQ	.
	  IF BBF.D3
	    JAL	RW2,BBCK	:Check BB range
	  EI
	L	RW2,FREE1,,	:GET INDEX TO 1ST FREE BUFFERLET
  IF FWBBF
	ST	RW2,CHAIN1,RCH, :ONE WE'RE PUTTING BACK CHAINS TO IT
	ST	RCH,CHAIN2,RW2, :AND VICE VERSA
  ELSE
	STH	RW2,CHAIN1,RCH, :ONE WE'RE PUTTING BACK CHAINS TO IT
	STH	RCH,CHAIN2,RW2, :AND VICE VERSA
  EI
	ST	RCH,FREE1,,	:ONE PUTTING BACK NOW 1ST FREE
PBB15	RBT	RW1,LOCK1,,	:UNLOCK LIST 1
	JR	RLINK		:RETURN

:	LIST 1 LOCKED, TRY LIST 2.  IF IT IS LOCKED ALSO,
:	IT IS CONCEIVABLE THAT IT IS DUE TO A RACE CONDITION, SO CHECK
:	LIST 1 AGAIN.  IF ITS LOCKED, THAT'S INCONCEIVABLE, CRASH.

PBB20	SBT	RW1,LOCK2,,	:LIST 2 LOCKED ?
	JEFS	PBB30		:JUMP IF NOT, PUT ON IT
	SBT	RW1,LOCK1,,	:LIST 1 STILL LOCKED ?
	JE	PBB10		:JUMP IF NOT, PUT ON LIST 1
	JAL	R10,CRASH	:LISTS LOCKED UP TIGHT, CRASH
	BC	0,0,4*RLINK,0D0	:CRASH CODE

PBB30	EQ	.
	  IF BBF.D3
	    JAL	RW2,BBCK	:Check BB range
	  EI
	L	RW2,FREE2,,	:GET INDEX TO 1ST BUFFERLET IN LIST 2
  IF FWBBF
	ST	RW2,CHAIN2,RCH, :ONE WE'RE PUTTING BACK CHAINS TO IT
	ST	RCH,CHAIN1,RW2, :AND VICE VERSA
  ELSE
	STH	RW2,CHAIN2,RCH, :ONE WE'RE PUTTING BACK CHAINS TO IT
	STH	RCH,CHAIN1,RW2, :AND VICE VERSA
  EI
	ST	RCH,FREE2,,	:ONE PUTTING BACK NOW AT HEAD OF LIST 2
PBB40	RBT	RW1,LOCK2,,	:UNLOCK LIST 2
	JR	RLINK		:RETURN

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			 S U B R O U T I N E   P B B C			     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  IF FWBBF
PBBC	L	RW3,CHAIN1,RCH, :GET INDEX OF NEXT BUFFERLET IN CHAIN
  ELSE
PBBC	LHL	RW3,CHAIN1,RCH, :GET INDEX OF NEXT BUFFERLET IN CHAIN
  EI
	JAL	RLINK,PBB	:PUT THIS BUFFERLET BACK
PBBCC	LR	RCH,RW3 	:GET NEXT IN CHAIN
	JNBS	PBBC		:PUT IT BACK TOO
	JR	RLINK1		:END OF CHAIN (0), RETURN


:Check range of BB address  (Only defined if BBF.D3 on)

  IF BBF.D3
BBCK	SBT	RW1,BBCKLK,,	:SET LOCK FOR REENTRANCY
	JEFS	BBCK1
	LIS	RW1,8		:CHOSE OTHER LOCK
	SBT	RW1,BBCKLK,,
	JN	BBCK2		:CRASH IF SET, CAN'T HAPPEN
BBCK1	STM	R14,BBCKSV,RW1,
	LHI	R14,-2,RCH	:DON'T ALLOW NEGATIVE
	JL	BBCKCR
	CI	R14,(NBBFLT-1)*BBFLSZ	:CHECK MAX ADDR
	JG	BBCKCR
	DH	R14,BBCKD,,	:ADDR MUST BE MULTIPLE OF SIZE
	LR	R14,R14
BBCK2	JN	BBCKCR,,		:REM NOT 0, NOT EXACT MULTIPLE
 IF	BBF.D4
	RBT	R15,BBFLAG,,	:CLEAR BUFFERLET IN USE INDICATOR
	JE	BBFLCR		:CRASH IF BUFFERLET WAS NOT IN USE
	CI	RLINK,PBBCC	:CHECK IF CALLED BY PBBC
	JNFS	BBCK3		:SKIP IF SO
	STH	RLINK1,BBUSER,R15,R15	:SET USER POINTER
	JFS	BBCK4		:SKIP
BBCK3	STH	RLINK,BBUSER,R15,R15	:SET USER POINTER
BBCK4	EQ	.
 EI
	LM	R14,BBCKSV,RW1,	:RESTORE REGS STACKED
	RBT	RW1,BBCKLK,,	:RELEASE LOCK
	LIS	RW1,0		:RESTORE RW1
	JR	RW2
BBCKCR	JAL	R10,CRASH	:RCH=BAD CHAIN ADDR
	BC	0,0,4*RLINK,0D3	:CRASH CODE
 IF	BBF.D4
BBFLCR	JAL	R10,CRASH
	BC	0,0,4*RLINK,0D4
	SEG	A.DATA
BBFLAG	HS	(NBBFLT+0F)/10	:BUFFERLET IN USE INDICATORS
BBUSER	HS	NBBFLT		:USER POINTERS FOR EACH BUFFERLET
 EI
BBCKD	HC	BBFLSZ
	SEG	A.DATA
BBCKSV	HS	(2*2)*2
BBCKLK	HC	0		:STACK PNTR
	SEG	A.CODE
  EI

	EM

  : ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/30/86  **
: **                                                              **
: **  File Name          : FEND01.R00                             **
: **                                                              **
: **  File Description   : ISIS FRNTND.LIB                        **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	ISIS Front End Handler Package	- FEND01.R00
:*******************************************************************
	RA	0		:	FRNTND.LIB	MFR 08/12/81
:
:	This package is an ISIS Front End interface to Tymnet. It
:	is used to service the ISIS input ring, and to activate user
:	defined routines whenever a message is found for a port and
:	optionally for output service when output requests are pending.

:	The package is designed to permit the activation routines to be
:	defined on an individual port basis if desired. It is also
:	designed so that context within a process can be indicated by 
:	dynamically changing to a different set of activation routines.
:
:			Conventions
:
:	The following symbols are to be provided by the user:
:
:	ECHO	if TRUE causes Tymsat echoing for terminals
:	AUTOBP	if TRUE causes automatic backpressure application and release
:		for a port based upon comparing number of characters
:		in input buffer and MAXCHAR.
:	PTIMEO	if TRUE port timeouts are available
:	MAXCHAR	maximum number of characters in a port's input buffer
:		before backpressure should be applied. (Only needed if AUTOBP is TRUE)
:	OUTPROC	if TRUE then output activation code will be included.
:	WAITZA if TRUE then ZAPPER acknowledgements will be requested from
:		ISIS and code will be included to clean up the port upon
:		receipt of the ZAP ACK message. (User will not have to reset
:		ACP.)
:
:	The following symbol is to be initialized by the user:
:
:	PECHO	a bit for each port. If set then echoing will be honored
:		for the port, otherwise defered echo mode will not be
:		honored.
:
:	The following symbols may be provided by the user:
:	(If not provided, default values will be used)
:
:	CRIPOM	crash code for invalid port zero message (default 20x)
:	CRNAR	crash code for no activation routine found (default 21x)
:	CRINVN	crash code for invalid needle received (default 22x)
:	CRINVM	crash code for invalid message received (default 23x)
:
:	The following data structures are to be provided and initialized
:	 by the user: (They may be located in any segment)
:
:	DCB	Device Control Block, a data structure which contains all
:		the context information for a port. There should be NPORT
:		DCB's defined starting at address DCBLKS. Within each DCB
:		the following offsets must be defined:
:			DCBICC	input character count (halfword)
:			ACTIVD	relative address in A.CODE of data
:				activation routine.
:			ACTIVC	relative address in A.CODE of a table of
:				halfword offsets in A.CODE of routines
:				for each possible control message.
:			ACTIVT	relative address in A.CODE of timeout
:				activation routine.
:			ACTIVO	relative address in A.CODE of output
:				activation routine. (Only needed if OUTPROC
:				is TRUE.)

:
:	PORTAB	Port Table, a halfword array containing entries for each
:		port which are the relative offset from DCBLKS of the
:		DCB for the port.
:
:	In addition, activation routines must be defined for port zero
:	messages (ACTIV0) to for needles (ACTIVN). These labels should
:	be the location of the actual routine not offsets in A.CODE.
:
:	Whenever a data or control message activation routine is called,
:	the following registers are set up:
:		R1	port number
:		R2	message type
:		R5	link register
:		R12	DCB pointer
:		R14	input ring pointers
:
:	The activation routines are responsible for extracting all the
:	message data for the current logical record from the input ring.
:	Upon return, this package willend the logical input record (ELIR).
:	Therefore R14 must be pointing to the end of the message
:	when this package regains control. All other registers may be
:	smashed.
:
:	Needles are handled differently. The are parsed and the following
:	registers loaded.
:		R1	port number
:		R2	number of characters in username
:		R5	link register
:		R6	invoice number
:		R7	destination host number
:		R8	originating node number
:		R9	originating host number
:		R10	originating port number
:		R11	dialect code
:		R13	TID
:		R14	input ring pointer
:
:	Upon a needle activation, everything up to and including the
:	username length will have been extracted from the input ring.
:	The ACTIVN routine is responsible for extracting the username.
:
:	If PTIMEO is true then a normal return from any activate'ed
:	process indicates that the timeout state of the port should not
:	be modified. If a skip return is taken, then R0 will be
:	examined. If R0 is non-zero, a timeout for that
:	many seconds will be set for the port. If R0 is zero then any 
:	timeout for the port will be cleared. When a timeout expires for a port
:	the timeout activation routine for the port will be called with
:	the following registers set up:
:		R1	port number
:		R5	link register
:		R12	DCB pointer
:
:	Upon return from the timeout activation routine, the same
:	skip/normal return convention is followed.
:
:	The user may also set or clear a timeout for a port directly.
:	The routines SETTO and CLRTO are used to set or clear a
:	timeout for a port respectively. They are used when a timeout
:	is to be set (or cleared) at a time other than a the return from
:	an activation. The routines should be called with R1 = port number.
:	For SETTO R0 should contain the interval, in seconds, until
:	the timeout activation routine for the DCB in activated.
:
:	The output routine searches for any ports requiring output service
:	which are not backpressured. For each such port, the output
:	activation routine found in the port's DCB will be activated
:	with the following registers set up:
:		R1	port number
:		R5	link register
:		R12	DCB pointer
:
:	Upon return from the output activation routine, the same
:	skip/normal return convention for timeouts is followed.
:
:	The following routines are to be called by the user (link R0).
:
:	IZFRNT	at initialization time, after calling IZT.
:	INPUT	from EXEC loop, to process input from ISIS.
:	OUTPUT	from EXEC loop, to process output requests.
:
:	In order to facilitate setting up the control message
:	activation routine table some symbols, routines, and macros
:	have been defined.
:
:	The following symbols have the values of the offsets from A.CODE of
:	a number of control message processing routines:
:		Symbol	Routine	Description
:		XTOSS	TOSS	tosses the message
:		XZAP	ZAP	handles zapper
:		XZACK	ZACK	handles zapper acknowledgement
:		XNOSEND	NOSEND	handles backpressure
:		XRESEND	RESEND	handles release backpressure
:		XGOBBLE	GOBBLE	handles gobbler
:		XFLBACK	FLBACK	handles flush backward
:		XEDEM	EDEM	handles enter deffered echo mode
:		XLDEM	LDEM	handles leave defered echo mode
:		XGB	GB	handles green ball
:		XRB	RB	handles red ball
:		XOB	OB	handles orange or black ball
:		XPNEED	PNEED	handles psuedo needle
:		XXLIM	XLIM	handle xmit limit
:		XINVAL	INVAL	crashes with invalid message code

:	The following macros are used to set up the tables:
:
:		HTABVT with argument table name is used to set up the 
:			process table for a typical virtual terminal port.
:
:		HTABIA with argument table name is used to set set up the
:			process table for an inactive port.
:
:		CHGTAB	with arguments table name, msg number, and routine
:			label is used to substitute for a default process
:			routine in the table.
::	Example:
:		To set up the control message activation routine table for
:		a virtual terminal handler which must call a routine to
:		release resources (RELRSC) upon losing the circuit on a port
:		the following code might be used.
:
:			SEG	A.CODE
:			MO	.,FRNTND
:
:			HTABVT(VTAB)	:GENERATE DEFAULT TABLE
:			CHGTAB(VTAB,9E,RELRSR)	:CHANGE ZAPPER HANDLER
:		RELRSC	------		:CODE TO CLEAN UP AND RELEASE
:			------		:RESOURCES USED BY PORT
:			J	ZAP	:JUMP TO ZAP PROCESSOR TO CLEAN
:					:UP ITS TABLES
:			EM
:			END
:
:	It should be noted that the above code is in the module FRNTND.
:	This is the Input Handler module. The preceeding symbols, routines
:	and macros are not global'ed so the code must be in the same
:	module or the symbols LOCAL'ed.
:	It should also be noted that the user defined processing
:	routines should jump to the default process routine or perform
:	similar processing on the input ring and status indicators.
:
:
	GL	NPORT,ECHO,DEM,PECHO,XLIMIT,ACP,TOISIS,FRISIS
	GL	IZFRNT,INPUT,RPORT,RDCB,AUTOBP,OUTPROC,PTIMEO
	GL	ACTIV0,ACTIVD,ACTIVC,ACTIVN,ACTIVT,EMPTYI,EMPTYO
	GL	CRIPOM,CRNAR,CRINVN,CRINVM
 IF	OUTPROC
	GL	ACTIVO,OUTPUT,OUTDAT,FLAGS
 EI
 IF	AUTOBP
	GL	AUTOBP
 EI

	MO	.,FRNTND

RPORT	EQ	R1		:PORT CURRENTLY BEING WORKED WITH
RDCB	EQ	R12		:POINTER TO DCB

	SEG	A.DATA

XLIMIT	BS	NPORT		:MAX NUMBER OF DATA CHARACTERS THAT CAN BE SENT
				:IN ONE MESSAGE
NGRP	EQ	(NPORT+0F)/10	:NUMBER OF PORT GROUPS TO PROCESS
ACP	HS	NGRP		:ACTIVE PORTS BIT ARRAY
TOISIS	HS	NGRP		:PORTS WE CAN SEND DATA ON
FRISIS	HS	NGRP		:PORTS WE HAVE NOT BACKPRESSURED
DEM	HS	NGRP		:PORTS IN DEFERED ECHO MODE
 IF	OUTPROC
FLAGS	HS	1		:BASE ADDRESS OF BIT ARRARYS. FIRST
				:HALFWORD WASTED TO AVOID BIT DISPLACE-
				:MENTS OF ZERO.
OUTDAT	HS	NGRP		:PORTS WITH OUTPUT REQUESTS WAITING
 EI
PECHO	HS	NGRP		:PORTS FOR WHICH ECHO SHOULD BE PERFORMED
 IF	\WAITZA
 ELSE
	REMARK %PLEASE DEFINE WAITZA SWITCH. DEFAULT OFF ASSUMED%%
WAITZA	EQ	0
 EI

 IF	WAITZA
	GL	CNTRL
  IF	\CNTRL
CNTRL	EQ	CNTRL!80	:SET ZAP ACK BIT
  ELSE
CNTRL	EQ	80
  EI
 EI

REGSAV	HS	20		:REGISTER SAVE AREA
RETPTR	HS	2		:RETURN POINTER
RETRN	HS	2		:RETURN ADDRESS FOR ACTIV ROUTINE
SPORT	HS	1		:SAVE AREA FOR PORT NUMBER
SDCB	HS	1		:SAVE AREA FOR DCB POINTER
SLOOP	HS	1		:SAVE AREA FOR OUTPUT LOOP COUNTER
 IF	OUTPROC
PRTSVC	HS	1		:PORTS ELIGIBLE FOR SERVICE INDICATOR
 EI

  IF	PTIMEO			:PORT TIMEOUT
TSAVE	HS	4		:SAVE AREA FOR TIMEOUT ACTIVATOR
PTIME	HS	NGRP		:PORTS ON ACTIVE TIMEOUT
ATIME	HS	2*NPORT		:ACTIVATION TIME
  EI

:
:	DEFINE CRASH CODES IF USER HAS NOT
:

  IF	\CRIPOM
  ELSE
CRIPOM	EQ	20	:INVALID PORT ZERO MESSAGE
  EI

  IF	\CRNAR
  ELSE
CRNAR	EQ	21	:NO ACTIVATION ROUTINE IN DCB
  EI

  IF	\CRINVN
  ELSE
CRINVN	EQ	22	:INVALID NEEDLE RECEIVED
  EI

  IF	\CRINVM
  ELSE
CRINVM	EQ	23	:INVALID MESSAGE RECEIVED
  EI


	SEG	A.CODE

:	HANDY INDEXABLE HALFWORD BIT MASKS
HMASK	HC	8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1

:	BIT ARRAY TO IDENTIFY DATA MESSAGES
DATAM	HC	07FFF,-1,-1	:00
	HC	-1,-1,-1	:30
	HC	-1,-1,-1	:60
	HC	0FFFC,0,0	:90
	HC	0,0,0		:C0
	HC	0		:F0

LENGTH	BC	0		:MESSAGE LENGTH TABLE
	RE	9D;	BC	.-LENGTH+1;	NOLIST;	ER;	LIST	:DATA TEXT STRINGS
	BC	1		: 9E	DETACH
	BC	1		: 9F	DISCONNECT
	BC	1		: A0	APPLY BACKPRESSURE
	BC	1		: A1	RELEASE BACKPRESSURE
	BC	1		: A2	FLUSH FORWARD
	BC	1		: A3	FLUSH BACKWARD
	BC	1		: A4	BLACK BALL
	BC	1		: A5	GREY BALL
	BC	1		: A6	ENTER "DEM"
	BC	1		: A7	LEAVE "DEM"
	BC	1		: A8	ENTER "TRANSPARENCY"
	BC	1		: A9	LEAVE "TRANSPARENCY"
	BC	1		: AA	GREEN BALL
	BC	1		: AB	RED BALL
	BC	1		: AC	YELLOW BALL
	BC	1		: AD	ORANGE BALL
	BC	1		: AE	"BREAK" DETECTED
	BC	1		: AF	"HANG UP"
	BC	2		: B0	QUERY TERMINAL PARAMETER
	BC	3		: B1	SET TERMINAL PARAMETER
	BC	4		: B2	PSEUDO-NEEDLE
	BC	2		: B3	LOGON CHARACTER
	BC	2		: B4	NORMAL LOGON STATUS
	BC	2		: B5	LOGON FAILURE
	BC	8		: B6	SUCCESSFUL LOGON FROM THIS PORT
	BC	6		: B7	ADDENDUM TO ACCOUNTING
	BC	1		: B8	SUPER-"HANG UP"
	BC	2		: B9	TRANSMIT LIMIT
	BC	1		: BA	BREAK END
	BC	1		: BB	ZAPPER ACKNOWLEGEMENT
	BC	1		: BC	ENTER ALTERNATE OUTPUT DEVICE MODE
	BC	1		: BD	LEAVE ALTERNATE OUTPUT DEVICE MODE
	BC	2		: BE	ZAP WITH REASON
	BC	1		: BF	START IIX
	BC	1		: CO	TERMINATE IIX

:		**INTERFACE DATA TYPES**


NEDMSG	EQ	0		:NEEDLE
FIRST	EQ	9E		:FIRST MESSAGE IN LIST
DETMSG	EQ	9E		:DETACH MESSAGE
ZAPMSG	EQ	9F		:DISCONNECT MESSAGE
NOSMSG	EQ	0A0		:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1		:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2		:FLUSH OUTPUT
BKGMSG	EQ	0A3		:FLUSH INPUT
BLKMSG	EQ	0A4		:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5		:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6		:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7		:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8		:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9		:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA		:GREEN BALL
RBMSG	EQ	0AB		:RED BALL
YBMSG	EQ	0AC		:YELLOW BALL
OBMSG	EQ	0AD		:ORANGE BALL
BRKMSG	EQ	0AE		:BREAK DETECTED
HNGMSG	EQ	0AF		:HANG UP
QTPMSG	EQ	0B0		:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1		:SET TERMINAL PARAMETER
PNDMSG	EQ	0B2		:PSEUDO NEEDLE
NLOGCH	EQ	0B3		:NORMAL LOGON CHAR
NLOGST	EQ	0B4		:NORMAL LOGON STATUS
LOGFAL	EQ	0B5		:LOGON FAILURE
LOGOK	EQ	0B6		:SUCCESSFUL LOGON
ADACTG	EQ	0B7		:ADDENDUM TO ACCOUNTING
SHGMSG	EQ	0B8		:SUPER-HANG UP
SETLIM	EQ	0B9		:SET XMIT LIMIT
BRKEND	EQ	0BA		:BREAK END
ZAPACK	EQ	0BB		:ZAPPER ACKNOWLEGEMENT
EAODM	EQ	0BC		:ENTER ALTERNATE OUTPUT DEVICE MODE
LAODM	EQ	0BD		:LEAVE ALTERNATE OUTPUT DEVICE MODE
ZAPREA	EQ	0BE		:ZAP WITH REASON
SIIX	EQ	0BF		:START IIX
TIIX	EQ	0C0		:TERMINATE IIX
MAXTYP	EQ	0C0		:MAXIMUM TYPE DEFINED

:
:	HANDLES INPUT MESSAGES FROM ISIS INPUT RING
:
INPUT	ST	R0,RETPTR,,	:SAVE RETURN ADDRESS
INPUT1	JAL	R4,LOOK		:IS THERE ANYTHING TO DO?
	J	RET		:NO... RETURN ALLL DONE FOR NOW
	JN	INPUT2		:TEST IF PORT 0.. SKIP IF NOT
:
:	CHECK PORT ZERO MESSAGES
:
	JAL	R4,GETCH	:GET MSG TYPE BYTE
	LR	R2,R0		:TEST MSG TYPE
	JEFS	SPEC2		:SKIP IF MSG 0
	TBT	R2,SPECL	:TEST IF VALID MESSAGE TYPE
	JEFS	SPEC1		:SKIP IF OK
	JAL	R10,CRASH	:OTHERWISE CRASH
	BC	0,0,4*R2,CRIPOM

SPECL	BC	1D,0A9,0FF	:INVALID PORT 0 MSG TYPES

SPEC1	LA	R5,ACTIV0	:SET UP CALLING ADDRESS
	JAL	R4,ACTIV	:ACTIVATE USER PORT 0 MSG ROUTINE
SPEC2	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE....
:
:	NOT A PORT ZERO MESSAGE
:
:	R1=PORT#	R2=MSG TYPE
:
INPUT2	JAL	R4,GETCH	:GET MSG TYPE
	TBT	R0,DATAM	:TEST IF DATA MESSAGE
	JE	INPUT3		:SKIP IF NOT
:
	TBT	RPORT,DEM,,	:TEST IF PORT IS IN DEFERED ECHO MODE
	JE	INDATA		:SKIP IF NOT
	TBT	RPORT,PECHO,,	:SHOULD DEM BE HONORED?
	JE	INDATA		:SKIP IF NOT
	LR	R2,R0		:COPY MSG LENGTH
	LR	R5,R0		:COPY IT AGAIN
	ST	R14,REGSAV,,	:SAVE INPUT RING POINTER REGISTER
:
ECHO1	JAL	R4,GETCH	:GET A CHARACTER
	STB	R0,ECHOBF,R5,	:PUT IT INTO ECHO BUFFER
	SIS	R5,1		:DECREMENT COUNTER
	JGBS	ECHO1		:GO BACK IF MORE CHARS IN RECORD
	LR	R5,R2		:COPY CHAR COUNT
	LHI	R0,3,R2		:CALCULATE MSG LENGTH
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
ECHO2	LB	R0,ECHOBF,R5,	:GET A CHARACTER FROM ECHO BUFFER
	JAL	R4,PUTCH	:PUT IT INTO OUTPUT RING
	SIS	R5,1		:DECREMENT COUNTER
	JGBS	ECHO2		:REPEAT IF MORE
	JAL	R4,ELOR		:ALL DONE.. END LOGICAL RECORD
:
:	NOTE THAT BACKPRESSURE AND TRANSMIT LIMIT ARE NOT CHECKED
:	IN SERVICING THE DEFERED ECHO.
:
	L	R14,REGSAV,,	:RESTORE INPUT RING POINTER

:
INDATA	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER
	JEFS	INDCR		:CRASH IF NO DCB
	LHL	R4,DCBLKS+ACTIVD,RDCB,	:GET DATA ACTIVATION ROUTINE FOR PORT
	JNFS	INDAT1		:TEST IF THERE IS A ROUTINE
INDCR	JAL	R10,CRASH	:CRASH IF NO ROUTINE
	BC	0,0,4*RDCB,CRNAR
:
  IF	AUTOBP
:
:	CHECK IF INPUT PORT SHOULD BE BACKPRESSURED
:
INDAT1	STH	RPORT,SPORT	:PRESERVE R1
	STH	RDCB,SDCB	:PRESERVE RDCB
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	JAL	R4,ELIR		:END THE INPUT RECORD
	LHL	RDCB,SDCB	:RESTORE DCB POINTER
	LH	R0,DCBLKS+DCBICC,RDCB,	:GET INPUT CHAR COUNT
	SHI	R0,MAXCHAR	:TEST IF TOO MANY CHARACTERS
	JL	INPUT1		:NO... GO BACK FOR MORE 
	LHL	RPORT,SPORT	:RESTORE PORT NUMBER
	LIS	R0,3		:GENERATE BACKPRESSURE MESSAGE
	LHI	R2,NOSMSG	:
	JAL	R4,SLOR		:START THE RECORD
	JAL	R4,ELOR		:END IT
	RBT	RPORT,FRISIS	:SET BP INDICATOR FOR PORT
	J	INPUT1		:AND GO BACK FOR MORE
  ELSE
:
INDAT1	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	JAL	R4,ELIR		:END THE INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE
  EI

	SEG	A.DATA
ECHOBF	BS	FIRST	:ECHO BUFFER

	SEG	A.CODE

:
:	PROCESS CONTROL MESSAGES
:
INPUT3	LR	R3,R0		:COPY MSG TYPE
	JN	INCNTL		:NOT A NEEDLE....SKIP
	SBT	RPORT,ACP,,		:TEST AND SET ACTIVE PORT BIT
	JEFS	NEEDLE		:SKIP IF PORT WAS NOT ACTIVE
	JAL	R10,CRASH	:OTHERWISE CRASH
	BC	0,0,4*RPORT,CRINVN
:
:	PROCESS NEEDLES
:
NEEDLE	LHI	R0,FIRST-1	:SET UP TRANSMIT LIMIT
	STB	R0,XLIMIT,RPORT,	:STORE IT
	SBT	RPORT,TOISIS,,	:CLEAR BACKPRESSURE
	SBT	RPORT,FRISIS,,	:
 IF	OUTPROC
	RBT	RPORT,OUTDAT,,	:CLEAR OUTPUT DATA WAITING
 EI
  IF PTIMEO
	RBT	RPORT,PTIME,,	:CLEAR PORT TIMEOUT
  EI
	JAL	R4,GETCH	:SKIP LENGTH
	JAL	R4,GETW		:GET INVOICE NUMBER
	LR	R6,R0		:COPY IT
	JAL	R4,GETH		:GET DESTINATION HOST
	LR	R7,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE NODE
	LR	R8,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE HOST
	LR	R9,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE PORT
	LR	R10,R0		:COPY IT
	JAL	R4,GETW		:FUTURE EXPANSION
	JAL	R4,GETH		:GET DIALECT CODE
	LR	R11,R0		:COPY IT
	JAL	R4,GETCH	:GET TID
	LR	R13,R0		:COPY IT
:
  IF	ECHO
:		SOURCE NODE SHOULD ECHO
	THI	R13,1F		:CHECK IF TERMINAL
	JE	NEED2		:SKIP... NOT A TERM
	ST	R14,REGSAV	:SAVE INPUT RING POINTER
	THI	R13,20		:CHECK IF HALF DUPLEX
	JNFS	NEED1		:SKIP IF HDX.. DON'T SET DEM
	SBT	RPORT,DEM	:SET DEM
NEED1	LIS	R0,5		:SEND SET TERM PARM MSG
	LHI	R2,STPMSG	:
	JAL	R4,SLOR		:START THE OUTPUT RECORD
	LIS	R0,0
	JAL	R4,PUTCH	:
	LIS	R0,1		:SET ECHO ON
	JAL	R4,PUTCH	:
	JAL	R4,ELOR		:
	L	R14,REGSAV,,	:RESTORE INPUT RING POINTER
  EI
:
NEED2	JAL	R4,GETCH	:GET USERNAME LENGTH
	LR	R2,R0		:COPY USERNAME LENGTH
	LA	R5,ACTIVN	:SET UP NEEDLE ACTIVATION ROUTINE ADDR
	JAL	R4,ACTIV	:ACTIVATE IT
	JAL	R4,ELIR		:END THE INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE

:
:
:	PROCESS NON-NEEDLE CONTROL MESSAGES FOR PORTS
:
INCNTL	SHI	R3,FIRST		:SUBTRACT TO GET RELATIVE MSG NUMBER
	SLLS	R3,1			:FORM HALFWORD INDEX
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER
	JE	INCN1			:CRASH IF NO DCB
	LHL	R4,DCBLKS+ACTIVC,RDCB,	:GET TABLE POINTER
	JEFS	INCN1			:SKIP IF NO TABLE ADDRESS
	LHL	R4,SEG|A.CODE|,R4,R3	:GET ROUTINE ADDRESS
	JEFS	INCN1			:SKIP IF NO ROUTINE ADDRESS
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV		:ACTIVATE
	JAL	R4,ELIR			:END THE LOGICAL RECORD
	J	INPUT1			:AND GO BACK FOR MORE
:
INCN1	JAL	R10,CRASH		:CRASH IF NO ROUTINE
	BC	0,0,4*RDCB,CRNAR

:	INITIALIZATION FOR THIS PACKAGE
:
IZFRNT	ST	R0,RETPTR,,	:SAVE RETURN ADDRESS
	LHI	RPORT,NPORT-1	:SET UP LOOP
IZIN1	RBT	RPORT,ACP,,	:SET PORT NOT ACTIVE
	SBT	RPORT,TOISIS,,	:SET BACKPRESSURE OFF
	SBT	RPORT,FRISIS,,	:
 IF	OUTPROC
	RBT	RPORT,OUTDAT,,	:RESET OUTPUT DATA WAITING
 EI
	RBT	RPORT,DEM,,	:NOT DEFERED ECHO MODE
	SIS	RPORT,1		:DECREMENT LOOP COUNTER
	JGE	IZIN1		:REPEAT IF MORE
:
  IF	AUTOBP			:AUTOMATIC BACKPRESSURE RELEASE CODE
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,RELBP	:PUT RELBP ON TIMEOUT LIST
	LHI	R1,RATE/2,R7	:SET HALF SECOND TIMEOUT
	JAL	R5,TOPUT	:
  EI
:
  IF	PTIMEO			:PORT TIMEOUT CODE
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,ONESEC	:PUT ONESEC ON TIMEOUT LIST
	LHI	R1,RATE,R7	:SET ONE SECOND TIMEOUT
	JAL	R5,TOPUT	:
  EI
	JFS	RET		:RETURN
:
:	GENERAL RETURN ROUTINE
RET	L	R0,RETPTR,,	:GET RETURN ADDRESS
	JR	R0		:AND RETURN
:
:	ACTIVATION ROUTINE
:
ACTIV	ST	R4,RETRN,,	:SAVE RETURN ADDRESS
  IF	PTIMEO
:		PORT TIMEOUT CODE
	STH	RPORT,SPORT,,	:PRESERVE PORT NUMBER
	JALR	R5,R5		:ACTIVATE
	J	ACTIV2		:NORMAL RETURN DON'T MODIFY TIMEOUT
	LHL	RPORT,SPORT,,	:RESTORE PORT NUMBER
	LR	R0,R0		:TEST RETURN PARAMETER
	JGFS	ACTIV1		:NONZERO... SKIP
	RBT	RPORT,PTIME,,	:TURN OFF PORT TIMEOUT INDICATOR
	JFS	ACTIV2		:
ACTIV1	SBT	RPORT,PTIME,,	:SET PORT TIMEOUT INDICATOR ON
	A	R0,SLOWC,,	:ADD TIMEOUT TO SLOW CLOCK
	SLHLS	RPORT,2		:MAKE WORD INDEX POINTER
	ST	R0,ATIME,RPORT,	:STORE ACTIVATION TIME
  ELSE
	JALR	R5,R5		:ACTIVATE
  EI
ACTIV2	L	R4,RETRN,,	:RESTORE RETURN ADDRESS
	JR	R4		:AND RETURN
:
  IF	AUTOBP
:
:		CODE TO PERIODICALLY CHECK IF BACKPRESSURE CAN
:		BE RELEASED ON ANY PORTS
RELBP	AHI	R1,RATE/2		:
	JAL	R5,TOPUT	:PUT BACK ON TIMEOUT LIST FOR ONE SECOND
:
:	CHECK ALL PORTS FOR THOSE WITH BACKPRESSURE APPLIED
:
	LHI	R5,(NGRP-1)*2	:
	LHI	R6,(NGRP-1)*10	:SET UP POINTERS
RBP1	LCS	R7,1		:
	XH	R7,FRISIS,R5	:CHECK IF BACKPRESSURE APPLIED
	NH	R7,ACP,R5	:AND PORT ACTIVE
RBP2	LR	R1,R7		:TEST
	JNFS	RBP3		:SKIP.. SOMETHING TO DO
	SIS	R5,2		:DECREMENT POINTERS
	SHI	R6,10		:
	JGEBS	RBP1		:CHECK NEXT RING GROUP
	J	TORET		:OTHERWISE RETURN
:
RBP3	JAL	R3,BIDH		:DETERMINE WHICH PORT ON GROUP NEEDS SERVICE
	XH	R7,HMASK,R2,R2	:MARK PORT AS SERVICED
	AR	R2,R6		:FORM PORT NUMBER
	LR	RPORT,R2		:COPY IT
	SLHLS	R2,2		:FORM BUFFER NUMBER
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER FROM PORT TABLE
	LH	R0,DCBLKS+DCBICC,RDCB,	:GET INPUT CHAR COUNT
	SHI	R0,MAXCHAR	:TEST IF LESS THAN MAXCHAR
	JG	RBP2		:NOT EMPTY ENOUGH YET
	SBT	RPORT,FRISIS	:RELEASE BACKPRESSURE
	LIS	R0,3		:FORM 3 BYTE MESSAGE
	LHI	R2,SNDMSG	:GET MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	J	RBP2		:AND CONTINUE
  EI
  IF	PTIMEO
:
:		CODE TO CHECK PERIODICALLY FOR PORT TIMEOUTS
:
ONESEC	AHI	R1,RATE		:SET UP TO RUN AGAIN IN ONE SECOND
	JAL	R5,TOPUT	:
	LHI	R15,(NGRP*2)-2	:SEARCH BY GROUPS
OS1	LH	R14,ACP,R15,	:GET ACTIVE PORT INDICATORS
	NH	R14,PTIME,R15,	:AND IN PORTS ON TIMEOUT
	JNFS	OS3		:JUMP IF ANY TO CHECK
OS2	SIS	R15,2		:DECREMENT GROUP INDEX
	JGEBS	OS1		:REPEAT IF MORE
	J	TORET		:OTHERWISE EXIT
:
OS3	LR	R1,R14		:COPY MASK OF PORTS TO PROCESS
	JEBS	OS2		:NONE... GO ON TO NEXT GROUP
	JAL	R3,BIDH		:FIND FIRST
	XH	R14,HMASK,R2,R2	:SET IT EXAMINED
	LR	R1,R15		:COPY GROUP INDEX
	SLHLS	R1,3		:MAKE GROUP INDEX INTO PORT OFFSET
	AR	RPORT,R2	:MAKE PORT NUMBER
	LR	R2,RPORT	:COPY PORT NUMBER
	SLHLS	R2,2		:MAKE INTO FULLWORD INDEX
	L	R0,ATIME,R2,	:GET ACTIVATION TIME
	S	R0,SLOWC,,	:SUBTRACT CURRENT TIME
	JG	OS3		:NOT READY.. IGNORE FOR NOW
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER
	JNFS	OS4		:SKIP IF GOT A DCB
OSCR	JAL	R10,CRASH	:CRASH
	BC	0,0,4*RDCB,CRNAR	:NO ACTIVATION ROUTINE
:
OS4	LHL	R4,DCBLKS+ACTIVT,RDCB,	:GET ACTIVATION ROUTINE
	JEBS	OSCR		:CRASH IF NO ROUTINE
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	STM	R14,TSAVE,,	:PRESERVE WORK REGISTERS
	JAL	R4,ACTIV	:ACTIVATE
	LM	R14,TSAVE,,	:RESTORE WORK REGISTERS
	J	OS3		:GO BACK FOR MORE
:
:	SET AND CLEAR TIMEOUT ROUTINES
:		LINK ON R4
:		EXPECT R1 = PORT NUMBER
:		       R0 = TIMEOUT INTERVAL IN SECONDS (SETTO)
:		SMASHES R0
:
	GL	SETTO,CLRTO
:
SETTO	SBT	RPORT,PTIME,,	:SET PORT TIMEOUT INDICATOR
	A	R0,SLOWC,,	:ADD TO CURRENT TIME
	SLHLS	RPORT,2		:MAKE INTO FULLWORD POINTER
	ST	R0,ATIME,RPORT,	:STORE TIME
	SRHLS	RPORT,2		:MAKE BACK INTO PORT NUMBER
	JR	R4		:AND RETURN
:
CLRTO	RBT	RPORT,PTIME,,	:RESET PORT TIMEOUT INDICATIOR
	JR	R4		:AND RETURN
  EI
:

:	CONTROL MESSAGE ACTIVATION ROUTINES
:
:	TOSS A MESSAGE
TOSS	LB	R0,LENGTH,R2	:PICK UP MESSAGE LENGTH
	SIS	R0,1		:WE'VE ALREADY GOTTEN MESSAGE TYPE
	AR	R14,R0		:ADVANCE POINTER TO END OF MSG
	JR	R5		:RETURN
:
:	ZAPPER ACKNOWEDGEMENT
:
ZACK	EQ	.
:
:	DISCONNECT
ZAP	JAL	R4,EMPTYI	:EMPTY INPUT BUFFER
	JAL	R4,EMPTYO	:EMPTY OUTPUT BUFFER
	RBT	RPORT,ACP,,	:SET PORT NOT ACTIVE
	RBT	RPORT,DEM,,	:SET PORT NOT IN DEM
	JR	R5		:RETURN
:
:	APPLY BACKPRESSURE
NOSEND	RBT	RPORT,TOISIS,,	:TURN IT OFF FOR PORT
	JR	R5		:RETURN
:
:	RELEASE BACKPRESSURE
RESEND	SBT	RPORT,TOISIS,,	:TURN IT ON FOR PORT
	JR	R5		:RETURN
:
:	GOBBLER
GOBBLE	JAL	R4,EMPTYI	:EMPTY INPUT BUFFER
	SBT	RPORT,FRISIS,,	:RELEASE BACKPRESSURE
	JR	R5		:AND RETURN
:
:	FLUSH BACKWARD
FLBACK	JAL	R4,EMPTYO	:EMPTY OUTPUT BUFFER
	LIS	R0,3		:SEND GOBBLER IN OTHER DIRECTION
	LHI	R2,GOBMSG	:CREATE MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	ENTER DEM
EDEM	SBT	RPORT,DEM,,	:SET INDICATOR
	JR	R5		:RETURN

:
:	LEAVE DEM
LDEM	RBT	RPORT,DEM,,	:CLEAR INDICATOR
	JR	R5		:RETURN
:

:	GREEN BALL
GB	LIS	R0,3		: RETURN GREEN BALL
	LHI	R2,GBMSG	:CREATE MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	RED BALL
RB	LIS	R0,3		:RETURN THE RED BALL
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	ORANGE (OR BLACK) BALL
OB	LIS	R0,3		:CREATE MESSAGE
	LHI	R2,1,R2		:CREATE OTHER BALL OF PAIR
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	PSUEDO-NEEDLE
PNEED	LB	R0,LENGTH,R2	:JUST TOSS IT
	SIS	R0,1		:WE ALREADY GOT MSG TYPE
	AR	R14,R0		:ADVANCE POINTER TO END OF MSG
	LHI	R0,FIRST-1	:SET UP DEFAULT TRANSMIT LIMIT
	STB	R0,XLIMIT,RPORT,	:
	SBT	RPORT,ACP,,	:SET PORT ACTIVE
	SBT	RPORT,TOISIS,,	:CLEAR BACKPRESSURE
	SBT	RPORT,FRISIS,,	:
	JR	R5		:AND RETURN
:
:	TRANSMIT LIMIT
XLIM	JAL	R4,GETCH	:GET RESTRICTION
	CLHI	R0,FIRST-1	:RANGE CHECK
	JLFS	XLIM1		:OK...SKIP
	LHI	R0,FIRST-1	:OTHERWISE SET LIMIT
XLIM1	STB	R0,XLIMIT,RPORT,	:SET UP RESTRICTION
	JR	R5		:AND RETURN
:
:	INVALID MESSAGE
INVAL	JAL	R10,CRASH
	BC	0,0,4*R5,CRINVM
 IF	OUTPROC

:	OUTPUT PROCESS ROUTINE
:
OUTPUT	ST	R0,RETPTR,,	:SAVE RETURN ADDRESS
	LHI	R11,(NGRP-1)*2	:LOOP COUNTER
OUTP1	LCS	R1,1		:SET UP MASK
	STH	R1,PRTSVC,,	:SAVE PORT SERVICED MASK
OUTP2	LHL	R1,ACP,R11,	:GET ACTIVE PORTS INDICATOR
	NH	R1,OUTDAT,R11,	:AND WITH DATA WAITING INDICATOR
	NH	R1,TOISIS,R11,	:AND NOT BACKPRESSURED
	NH	R1,PRTSVC,,	:AND NOT ALREADY SERVICED
	JNFS	OUTP3		:SKIP IF ANYTHING TO DO
	SIS	R11,2		:DECREMENT LOOP COUNTER
	JGE	OUTP1		:LOOP
	J	RET		:DONE... RETURN
:
OUTP3	JAL	R3,BIDH		:FIND PORT TO SERVICE
	LR	R1,R11		:COPY PORT OFFSET
	SLHLS	R1,3		:TIMES EIGHT
	AR	RPORT,R2	:PORT NUMBER!
	RBT	R2,PRTSVC,,	:CLEAR PORT TO BE SERVICED BIT
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER FOR PORT
	JEFS	OUTCR			:CRASH NO DCB POINTER
	LHL	R4,DCBLKS+ACTIVO,RDCB,	:GET OUTPUT ACTIVATION ROUTINE
	JNFS	OUTP4			:GOT A ROUTINE...SKIP
:
OUTCR	JAL	R10,CRASH
	BC	0,0,4*RDCB,CRNAR	:NO ACTIVATION ROUTINE
:
OUTP4	STH	R11,SLOOP,,	:SAVE LOOP COUNTER
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	LHL	R11,SLOOP,,	:RESTORE LOOP POINTER
	J	OUTP2		:LOOP
:
 EI
:	DEFAULT CONTROL MESSAGE ACTIVATION TABLES
:
:	CALCULATE ROUTINE OFFSETS
:
XTOSS	EQ	TOSS-SEG|A.CODE|
XZAP	EQ	ZAP-SEG|A.CODE|
XZACK	EQ	ZACK-SEG|A.CODE|
XNOSEND	EQ	NOSEND-SEG|A.CODE|
XRESEND	EQ	RESEND-SEG|A.CODE|
XGOBBLE	EQ	GOBBLE-SEG|A.CODE|
XFLBACK	EQ	FLBACK-SEG|A.CODE|
XEDEM	EQ	EDEM-SEG|A.CODE|
XLDEM	EQ	LDEM-SEG|A.CODE|
XGB	EQ	GB-SEG|A.CODE|
XRB	EQ	RB-SEG|A.CODE|
XOB	EQ	OB-SEG|A.CODE|
XPNEED	EQ	PNEED-SEG|A.CODE|
XXLIM	EQ	XLIM-SEG|A.CODE|
XINVAL	EQ	INVAL-SEG|A.CODE|
:
:	TABLE CREATION MACROS
:
HTABVT	MACRO(TABNAM)
[	SEG	A.CODE
	GL	TABNAM
TABNAM	HC	XZAP,XZAP,XNOSEND,XRESEND,XGOBBLE,XFLBACK	:9E - A3
	HC	XOB,XTOSS,XEDEM,XLDEM,XTOSS,XTOSS		:A4 - A9
	HC	XGB,XRB,XOB,XTOSS,XTOSS,XTOSS			:AA - AF
	HC	XTOSS,XTOSS,XINVAL,XINVAL,XTOSS,XTOSS		:B0 - B5
	HC	XTOSS,XINVAL,XTOSS,XXLIM,XTOSS,XZACK		:B6 - BB 
	HC	XTOSS,XTOSS,XINVAL,XTOSS,XTOSS			:BC - C0
]
:
HTABIA	MACRO(TABNAM)
[	SEG	A.CODE
	GL	TABNAM
TABNAM	HC	XZAP,XZAP	:9E - 9F
	RE	0B1-9F
	HC	XTOSS
	NOLIST
	ER
	LIST
	HC	XPNEED,XINVAL	:B2 - B3
	HC	XTOSS,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS		:B4 - B9
	HC	XTOSS,XZACK,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS	:BA - C0
]
:
CHGTAB	MACRO(TABNAM,MSGNUM,ROUTIN)
[
OLDORG	EQ	.
	ORG	TABNAM+(MSGNUM-FIRST)*2
	HC	ROUTIN-SEG|A.CODE|
	ORG	OLDORG
]
	EM
:
   	SUBTTL	(SNA/SDLC) FGND GLOBAL AND STORAGES - FGGBDF
:FGDF00.F00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Re-code and re-desgin for SNA Native Mode from
:			SDLC Interface.
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


:	THIS FILE CONTAINS THE FOREGROUND GLOBAL SYMBOLS
:	AND ALLOCATES STORAGES
:	---------------------------------------------------

	MO	.,FGGBDF

	LO	MAIN
	LO	GBLDEF


:	S (SUPERVISORY) FORMAT
:	----------------------
RR	EQ	01			:RECEIVE READY
RNR	EQ	05			:RECEIVE NOT READY
REJ	EQ	09			:REJECT


:	I (INFORMATION) FORMAT MASK
:	---------------------------
INFFRM	EQ	0			:INFORMATION FRAME MASK BIT


:	P/F BIT MASK
:	------------
PFMASK	EQ	10			:MASK FOR P/F BIT
PFBOFF	EQ	0EF			:MASK OFF P/F BIT
NRBOFF	EQ	0F			:MASK OFF N(R) AND P/F BIT


:	BIT FLAGS DEFINED IN LSCBIT
:	-----------------------------
:	IOPEBXJSRNNNNNNN
:
:	BIT 0	- IPFBIT, P/F BIT IN THE INPUT FRAME
:	BIT 1	- OPFBIT, P/F BIT IN THE OUTPUT FRAME
:	BIT 2	- XPFBIT, RIGHT TO XMT P/F BIT
:	BIT 3	- ENDBIT, END CONDITION BIT
:	BIT 4	- RBYBIT, REMOTE BUSY
:	BIT 5	- RXTBIT, RE-XMT XID/TEST FRAME BIT
:	BIT 6	- REJBIT, REJ FRAME RCV'ED BIT
:	BIT 7	- SBYBIT, SET BUSY BIT
:	BIT 8	- RR0BIT, XMT RR WITH P/F BIT OFF
IPFBIT	EQ	8000			:P/F BIT IN THE INPUT FRAME
OPFBIT	EQ	4000			:P/F BIT IN THE OUTPUT FRAME
XPFBIT	EQ	2000			:RIGHT TO XMT P/F BIT
ENDBIT	EQ	1000			:END CONDITION
RBYBIT	EQ	0800			:REMOTE BUSY
RXTBIT	EQ	0400			:RE-XMT XID/TEST FRAME BIT
REJBIT	EQ	0200			:REJ FRAME RCV'ED BIT
SBYBIT	EQ	0100			:SET BUSY BIT
RR0BIT	EQ	0080			:XMT RR WITH P/F BIT OFF
RPFBIT	EQ	0040			:P/F BIT FOR RCV PROCESS


:	MAXIMUM FRAME LENGTH
:	---------------------
FUSPC	EQ	0			:UNSPECIFIED
F128	EQ	01			:128 BYTES
F256	EQ	02			:256 BYTES
F512	EQ	03			:512 BYTES
F1K	EQ	04			:1024 BYTES


:	MAXIMUM NUMBER OF OUTSTANDING FRAMES
:	------------------------------------
MOFR0	EQ	00			:UNSPECIFIED
MOFR1	EQ	01			:1 FRAME
MOFR2	EQ	02			:2 FRAMES
MOFR3	EQ	03			:3 FRAMES
MOFR4	EQ	04			:4 FRAMES
MOFR5	EQ	05			:5 FRAMES
MOFR6	EQ	06			:6 FRAMES
MOFR7	EQ	07			:7 FRAMES


:	TIME INTERVAL FOR RE-ISSUE OF COMMANDS
:	VALUE FROM 1-255, DEFAULT IS 3 SEC.
:	---------------------------------------
TSCALE	EQ	2			:SCALING TO KEEP HALFWORD'S POSITIVE
TPS	EQ	RATE^(-TSCALE)		:SCALED TICKS PER SECOND


:	VARIABLES RELATED TO SEQUENCE NUMBERS
:	-------------------------------------
MODUL8	EQ	8			:SEQUENCE NUMBER FOR FRAMES
MXSEQN	EQ	7			:MAXIMUM SEQUENCE NUMBER
FMMSK   EQ      7			:MASK FOR MODULE 8


:	REGISTERS CONVENTION FOR FOREGROUND
:	-----------------------------------
RL	EQ	R8			:CURRENT LINE BEING PROCESSED
RL2	EQ	R9			:RL*2
RLCB	EQ	R11			:FOR LCB PTR
RLSC	EQ	R12			:FOR LSC PTR
RSIO	EQ	R13			:RSIO BASE ADDR
RSIP	EQ	R14			:CURRENT  SECTOR
RBBA	EQ	R10			:CURRENT BIG BUFFERLET ADDRESS
RBBX	EQ	R15			:BIG BUFFERLET INDEX


	SUBTTL SIO TABLES AND DEFINITIONS


:	THIS PACKAGE USES DIFFERENT MAXIMUM SIZE FOR INDIVIDUAL SIO RECEIVE
:	BUFFER


:	SIO BLOCK DEFINITIONS.
:	-----------------------

:	THERE IS ONE BLOCK PER LINE.
:	THE SIO MICROCODE IMPOSES TWO RESTRICTIONS ON THESE BLOCKS.
:	FIRST, ALL AREAS MUST BEGIN ON QUADWORD BOUNDARIES.
:	SECOND, NO CHANNEL COMMAND PROGRAM MAY CROSS A 100 HEX BYTE
:	BOUNDARY.  FOR THIS REASON, THE BLOCK FOR EACH LINE BEGINS
:	ON A 100 HEX BOUNDARY AND ALL CHANNEL COMMAND PROGRAMS ARE
:	FIRST.  ALL CHANNEL COMMAND PROGRAMS FOR A LINE HAPPEN
:	TO OCCUPY LESS THAN 100 BYTES TOTAL.  THIS MEETS THE ABOVE
:	REQUIREMENTS.  AN ASSEMBLY ERROR WILL BE GENERATED IF
:	IT HAPPENS THAT THE CHANNEL COMMAND AREA EXCEEDS THIS VALUE.

:	RBUFHQ = SIZE OF SIO RECEIVE BUFFER IN HALFWORDS.
:		THE BUFFER SIZE IS SET TO FIT EXACTLY 8 MAXIMUM SIZED
:		FRAMES PLUS 8 HALFWORD COUNTS PLUS 1 HALFWORD END FLAG.
:		THE MOTHERBOARD-SIO WILL USE THIS TO CALCULATE THE
:		MAXIMUM RECORD SIZE.
:		(AND THEREFORE, DO NOT CHANGE THIS FORMULA UNLESS YOU
:			REALLY KNOW WHAT YOU ARE DOING!)
:	RBUFRQ = SIZE OF MAXIMUM RECEIVED SIO RECORD IN HALFWORDS
:		(NOT INCLUDING THE COUNT HALFWORD)
:		THIS IS THE SAME VALUE THAT THE MOTHERBOARD WILL CALCULATE.
:		I.E., THE BUFFERSIZE DIVIDED BY 8, MINUS 1.
:
:	A.IO0	:AREA FOR IO CMDS AND DATA (SIO ), LINES 0-07
:	A.IO1	:AREA FOR IO CMDS AND DATA (SIO ), LINES 08-15 (NOT USED)


:	CONSTANT
:	---------
FRMHDR	EQ	2			:FRAME HEADER LENGTH
SECHDR	EQ	4			:FRAME HEADER + SIO COUNT HALFWORD
ROTMSK	EQ	7			:MASK FOR ROTOR LIST SIZE (MODULE 8)


:	SIO READ REGISTER 0
:	-------------------
ABOMSK	EQ	80			:BREAK/ABORT
EOMMSK	EQ	40			:TX UNDERRUN/EOM
DCDGMS	EQ	20			:DCD(DSR)
DCDHMS	EQ	08			:DCD(DSR)
SYNMSK	EQ	10			:SYNC/HUNT
CTSGMS	EQ	08			:CTS
CTSHMS	EQ	20			:CTS
TBEMSK	EQ	04			:TX BUFFER EMPTY
ITPMSK	EQ	02			:INT PENDING (CH. A ONLY)
RXAMSK	EQ	01			:RX CHAR. AVAILABLE


:	SIO READ REGISTER 1
:	-------------------
EOFMSK	EQ	80			:END OF FRAME (SDLC)
CRCERR	EQ	40			:CRC/FRAMING ERROR
ROVRUN	EQ	20			:RX OVERRUN ERROR
PARITY	EQ	10			:PARITY ERROR
ALLSNT	EQ	01			:ALL SENT


:	RTSUCM FOR RTS/CTS LINE TO RAISE RTS 
:	RTSDCM FOR RTS/CTS LINE TO DISABLE TX & DROP RTS
:	------------------------------------------------
RTSUCM	EQ	385E2			:DTR UP + TX 8 BITS + RTS UP
					: (TX NOT ENABLED)
	IF	SIOEVR
RTSDCM	EQ	685E0			: RESET TX CRC + DTR UP + TX 8 BITS
	ELSE				: (TX DISABLED & RTS DROPPED)
RTSDCM	EQ	385E0			: RESET TX CRC + DTR UP + TX 8 BITS
	EI				: (TX DISABLED & RTS DROPPED)


:	TXENAB FOR LEASED LINE (RTS/CTS ALWAYS UP) TO ENABLE TX
:	TXDSAB FOR LEASED LINE (RTS/CTS ALWAYS UP) TO DISABLE TX
:	--------------------------------------------------------
TXENAB	EQ	385EB			: RESET TX CRC + ENABLE TX + RTS UP
					: + ENABLE TX CRC
	IF	SIOEVR
TXDSAB	EQ	685E2			: RESET TX CRC + RTS UP
	ELSE				: (TX NOT ENABLED)
TXDSAB	EQ	385E2			: REST TX CRC + RTS UP
	EI				: (TX NOT ENABLED)


:	DTRCU1 FOR RTS/CTS LINE TO RAISE
:	------	DTR SIGNAL. THE RTS SIGNAL WILL BE RAISED WHEN READY TO TX.
:	DTRCU2 FOR NON RTS/CTS LINE TO RAISE DTR SIGNAL.
:	------	THE RTS SIGNAL ALWAYS UP WHEN LINE IS UP.
:	DTRCD1	FOR ANY LINE TO DROP THE DTR SIGNAL. SINCE THE DROP OF THE DTR
:	------	SIGNAL INDICATES THE LINE IS NOT READY FOR ACTION,
:		THE TX AND RX SHOULD BE DISABLED.
DTRCU1	EQ	305E0			:DTR UP + TX 8 BITS
DTRCU2	EQ	305E2			:DTR UP + TX 8 BITS + RTS UP
DTRCD1	EQ	30560			:DTR DOWN + TX 8 BITS + RTS DOWN


:	MAC1 IS USED TO AVOID NAD RESTRICTION ON LENGTH OF 
:	REPEAT LOOP (IMEDIATELY FOLLOWING)
:	--------------------------------------------------
MAC1	MACRO[
MFRMH|Q| EQ	(FRMS|Q|+2)/2		: FRAME SIZE IN HALFWORDS (ROUNDED UP)
RBFH|Q|	EQ	((1+MFRMH|Q|)*RFRN|Q|)+1 :SIZE OF SO RCV BUFFER IN HW
RBFR|Q|	EQ	(RBFH|Q|/RFRN|Q|)-1	:SIZE OF MAX RCV SIO RECORD 
SSIZ|Q|	EQ	(FRMS|Q|+2+0F)&0FFFF0

	BND	100			:START ON 100 BYTE BOUNDARY
	KILL	ZZ|Q|,YY|Q|,XX|Q|
ZZ|Q|	EQ	0E0+((RBFH|Q|*2+0F)&0FFF0)+80+(SSIZ|Q|*8+0F)&0FFF0
YY|Q|	EQ	((.+10000)&0F0000)-.
	IF	ZZ|Q|-YY|Q|
XX|Q|	EQ	((.+10000)&0F0000)^-10
	IF	XX|Q|-A.IO0-1
	REMARK	*** ERROR *** SIO SEGEMENTS OVERFLOW!!!!
	ELSE
	SEG	XX|Q|
	EI	(XX|Q|-A.IO0-1)
	EI	(ZZ|Q|-YY|Q|)

SIOT|Q|	BS	0E			:SIO LINE STATUS (SEE ISIS DOC)

	BND	4*4
ICCW	EQ	.-SIOT|Q|
	IF	(\(PFDPTS))!(\(PFDMPS))!(\(SFDPTS))!(\(SFDMPS))
ICCW|Q|	WC	30018,31420,31100,303D8,3056B,3877E,313D9,0	:INIT SIO
	ELSE
	IF	SRTS|Q|			:IF RTS/CTS REQUIRED (RTS UP WHEN XMT)
ICCW|Q|	WC	30018,31420,31100,303D8,30560,3877E,313D9,0	:INIT SIO
	ELSE				:IF RTS/CTS NOT REQUIRED(RTS ALWAYS UP)
ICCW|Q|	WC	30018,31420,31100,303D8,30562,3877E,313D9,0	:INIT SIO
	EI
	EI				:END OF FULL-DUPLEX SWITCH

	BND	4*4
OCPW	EQ	.-SIOT|Q|
OCPW|Q|	HC	0,0,0,0,0,0,0,0		:OUTPUT COMMAND PAIR WORKING AREA
OCPRTS	EQ	.-SIOT|Q|		:RAISE RTS COMMAND PAIR
	WC	RTSUCM
	HC	0,0,0,0,0,0
OCPENA	EQ	.-SIOT|Q|		:ENABLE TRASMITTER COMMAND PAIR
	WC	TXENAB
	HC	0,0,0,0,0,0


	BND	4*4
TCCWL	EQ	.-SIOT|Q|		:TRANSMIT COMMAND LIST ADDRESS CONSTANT
TCCL|Q|	HC	0,0,0,(TCCL|Q|+10)/10,0,0,0,0
	HC	0,0,0,(TCCL|Q|+20)/10,0,0,0,0
	HC	0,0,0,(TCCL|Q|+30)/10,0,0,0,0
	HC	0,0,0,(TCCL|Q|+40)/10,0,0,0,0
	HC	0,0,0,(TCCL|Q|+50)/10,0,0,0,0
	HC	0,0,0,(TCCL|Q|+60)/10,0,0,0,0
	HC	0,0,0,(TCCL|Q|+70)/10,0,0,0,0
	HC	0,0,0,(TCCL|Q|)/10,0,0,0,0


	BND	4*4			:INPUT COMMAND LIST AREA
INCCW	EQ	.-SIOT|Q|		:INPUT COMMAND LIST ADDRESS CONSTANT
INCW|Q|	HC	3,RBFH|Q|+1
	IF	SIOEVR
	HC	5,RBFR|Q|+1
	EI
	HC	1,RBUF|Q|/10

	IF	.-SIOT|Q|-100
	REMARK	*** SIO CHANNEL COMMAND CROSSES 100 HEX BOUNDARY!!!!
	EI

	BND	4*4
RBUF	EQ	.-SIOT|Q|
RBUF|Q|	HS	RBFH|Q|			:SPACE RESERVED FOR RECEIVE FRAMES


:	NON-INF FRAME SECTORS
:	---------------------
:	16 BYTES NON-IFRAME OUTPUT AREA PER OUTPUT COMMAND (USES SAME
:	INDEX AS PTR INTO CMD LIST TCCWL (THEREFORE MUST BE EXACTLY 16
:	BYTES PER ENTRY)
	BND	4*4
OTSCT|Q|	EQ	.-SIOT|Q|
OSEC|Q|	BS	80


:	INF FRAME SECTORS
:	------------------
:	FOLLOWING IS STORAGE AREA FOR OUTPUT SECTORS ON THIS LINE.
	BND	4*4
TCCW	EQ	.-SIOT|Q|
TCCW|Q|	BS	SSIZ|Q|*8

	WS	4			:GIVE EXTRA ROOM (7/30/86/CHS,NSR830)

	BND	4*4
SIOX|Q|	HS
]

	SEG	A.IO0
Q	EQ	0
	RE	NLINES
	MAC1
Q	EQ	Q+1
	ER


:	SEG	A.IO1
:Q	EQ	.-S.IO1
:	IF	Q-0
:	ELSE
:	HC	0DEAF			:IF NOTHING IN A.IO1 SEGMENT
:	EI

	SEG	A.RTBL

	BND	4*4
RBUFRM	HS
Q	EQ	0
	RE	NLINES
	HC	(RBFH|Q|-(RBFR|Q|+2))*2
Q	EQ	Q+1
	ER


	BND	4*4
SIOTBL	WS
Q	EQ	0
	RE	NLINES
	WC	SIOT|Q|
Q	EQ	Q+1
	ER


SIOTBX	WS
Q	EQ	0
	RE	NLINES
	WC	SIOX|Q|-1
Q	EQ	Q+1
	ER

OUTSCT	WS
Q	EQ	0
	RE	NLINES
	WC	OTSCT|Q|
Q	EQ	Q+1
	ER

SECADR	WS
Q1	EQ	0
	RE	NLINES
Q2	EQ	0
	RE	8
	WC	TCCW|Q1|+(SSIZ|Q1|*Q2)
Q2	EQ	Q2+1
	ER
Q1	EQ	Q1+1
	ER

:	SECTOR DATA BUFFER BASE BIASE
:	-----------------------------
SEDBIA	HS
Q	EQ	0
	RE	MAXPUN
	IF	FWBBF
	HC	Q*6*8
	ELSE
	HC	Q*4*8
	EI
Q	EQ	Q+1
	ER

:	SIO OUTPUT SECTOR BASE BIASE
:	-------------------------------
SECBIA	HS
Q	EQ	0
	RE	NLINES
	HC	Q*8
Q	EQ	Q+1
	ER

:	DEFINE STORAGES USED BY F.G.
:	---------------------------

	SEG	A.DATA

RINDEX	HS	NLINES			:RCV RING TAKE OUT INDEX
RINBYT	HS	NLINES			:SAVE CELL FOR RING BYTE COUNT
CROTOR	HS	NLINES			:CURRENT ROTOR LIST ENTRY
ATTBUF	HS	NLINES*2		:ATTRIBUTE QUERY BUFFER
SECBLT	HS	MAXPUN			:BIT ARRAY FOR SECTOR BUILT INDICATION


:	SECTOR DATA BUFFER BASES
:	------------------------
:	THERE ARE 8 OUTPUT ENTRIES FOR EACH STATION
SECBAS	HS				:SECTOR DATA BUFFER BASES
	RE	MAXPUN
	RE	8
	HS	1			:DATA LENGTH
	IF	FWBBF
	HS	2			:DATA BUFFER BASE
	ELSE
	HS	1
	EI
	ER
	ER


	IF	FTRACE
:	FRAME XMT AND RCV TRACE BUFFER
:	---------------------------------------
:	WITHOUT TIME STAMP, EACH ENTRY HAS 6 BYTES
:		BS - 1ST NIBBLE, LINE#/BIT 6, TIME STAMPPED/BIT 7, RCV OR XMT
:		BS - FOR XMT, CC CODE/OP CODE
:		     FOR RCV, RETURN CODE
:		BS - 'A' FIELD
:		BS - 'C' FIELD
:		HS - RCV'ED/XMT'ED BYTE COUNT
:		WS - CURRENT TIME, IF TIME STAMPPED REQUIRED

FTRBFL	EQ	600			:MUST BE MULTIPLE OF 6

FTRRCV	EQ	0			:0 - RCV TRACE
FTRXMT	EQ	1			:1 - XMT TRACE
FTRTIM	EQ	2			:2 - TIME STAMPPED

FTRXLN	HS	(NLINES-1)/10+1		:XMT TRACE ACCORDING TO LINE
FTRRLN	HS	(NLINES-1)/10+1		:RCV TRACE ACCORDING TO LINE
FTRTLN	HS	(NLINES-1)/10+1		:TIME STAMP INDICATOR
FTRINF	HS	(NLINES-1)/10+1		:INF TRACE ONLY
FTGMTL	HC	0			:CLOCK SOUCRE, 0 FASTC, 1 GMT
FTRSIX	HC	0			:TRACE INDEX
FTRSBF
	RE	FTRACE
	BS	FTRBFL			:TRACE TABLE = FTRBFL  * FTRACE
	ER				:ER(FTRACE)
	BS	10			:GAP
	EI	(FTRACE)



: DEFINE BIT ARRAYS SIODTR, SIODSR, SIORTS, SIOCTS
: -------------------------------------------------
:	EACH BIT ARRAY IS INDEXED BY THE LINE NUMBER
:	IF 1, THE CORRESPONDING SIGNNAL IS ON, ELSE, OFF

	SEG	A.DATA

	BND	2
SIODTR	HS	(NLINES-1)/10+1		:DTR SIGNAL
SIODSR	HS	(NLINES-1)/10+1		:DCD (DSR) SIGNAL
SIORTS	HS	(NLINES-1)/10+1		:RTS SIGNAL
SIOCTS	HS	(NLINES-1)/10+1		:CTS SIGNAL

: CONFIGURE RTS/CTS HANDSHAKE LINES
: ---------------------------------
: THE FOLLOWING CODE CREATES A BIT ARRAY RTSCTS FROM USER INPUT
: SRTS0,SRTS1,...,SRTS|NLINES| WHICH THE CODE TESTS TO DETERMINE
: IF RTS/CTS HANDSHAKE MUST BE PERFORMED BEFORE DATA IS TRANSMITTED
: (HANDSHAKE IS RAISE RTS, WAIT FOR CTS, SEND DATA, LOWER RTS).
: BIT ARRAY IS INDEXED BY RL, 1 = HANDSHAKE REQUIRED

	SEG	A.CODE
RTSCTS	HS	0
QQ	EQ	0			:WORK SYMBOL
Q	EQ	0
	RE	NLINES
QQ	EQ	QQ+(SRTS|Q|&1)^(0F-(Q&0F))
Q	EQ	Q+1
	IF	Q&0F;	ELSE;
	HC	QQ  ;QQ	EQ	0;	EI
	ER
	IF	Q&0F;	HC	QQ;	EI

:	(5/10/85/CHS)
: CONFIGURE SIO DAUGHTER CARD TYPE FOR EACH LINE
: ---------------------------------
: THE FOLLOWING CODE CREATES A BIT ARRAY D.SIOC FROM USER INPUT
: SIOH0,SIOH1,...,SIOH|NLINES| WHICH THE CODE TESTS TO DETERMINE
: IF THE TYPE OF THE SIO DAUGHTER CARDS HAVE THE DCD/CTS ADJUSTED
: (FOR SIO DAUGHTER CARD TYPE A TO G, DCD/CTS ARE REVERSED)
: BIT ARRAY IS INDEXED BY RL, 1 = TYPE H AND LATER

	SEG	A.CODE
D.SIOC	HS	0
QQ	EQ	0			:WORK SYMBOL
Q	EQ	0
	RE	NLINES
QQ	EQ	QQ+(SIOH|Q|&1)^(0F-(Q&0F))
Q	EQ	Q+1
	IF	Q&0F;	ELSE;
	HC	QQ  ;QQ	EQ	0;	EI
	ER
	IF	Q&0F;	HC	QQ;	EI


	FO	MAIN
	FO	GBLDEF
	EM

    	SUBTTL	(SNA/SDLC) FOREGROUND - SDLC LINK EXEC - SNAEXC
:FGEX00.F00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Re-code and re-desgin for SNA Native Mode from
:			SDLC Interface.
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::          S D L C   E X E C U T I O N   C O N T R O L L E R           ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::  THIS ROUTINE CONTROLS THE EXECUTION OF THE VARIOUS SDLC PROCESSES   ::
::  IN THE ISIS FOREGROUND.  IT DOES SO BY MAINTAINING THREE LISTS      ::
::  FOR EACH LINE, A RECEIVE, Control, AND TRANSMIT LIST.  THIS         ::
::  ENABLES THE PROCESSES TO RUN INDEPENDENTLY AND CONCURRENTLY,        ::
::  ALLOWING THE SUPPORT OF FULL DUPLEX LINES.                          ::
::                                                                      ::
::  A PROCESS IS PLACED ON THE APPROPRIATE RUN LIST BY STORING ITS      ::
::  ADDRESS IN THAT LIST FOR A PARTICULAR LINE:                         ::
::                                                                      ::
::              LA      R0,PROCESS      SAMPLE PLACEMENT                ::
::              LHI     RL2,LINE        LINE NUMBER * 2                 ::
::                                                                      ::
::              ST      R0,RRUNL,RL2,RL2        RECEIVE                 ::
::              ST      R0,PRUNL,RL2,RL2   OR   Control                 ::
::              ST      R0,XRUNL,RL2,RL2   OR   TRANSMIT                ::
::                                                                      ::
::  THIS MAY BE DONE BY THE PROCESS ITSELF TO SWITCH CONTEXT,  BY       ::
::  ANOTHER PROCESS TO GENERATE A FORK, OR BY THE BACKGROUND TO         ::
::  INITIALLY START EXECUTION.                                          ::
::                                                                      ::
::  ONCE RUNNING, A PROCESS MAY DISMISS ITSELF TO THE NEXT ISIS         ::
::  FOREGROUND EXECUTION CYCLE OR TAKE ITSELF OFF THE RUN LIST:         ::
::                                                                      ::
::              JAL     R5,RDMISS               DISMISS RECEIVE         ::
::              JAL     R5,PDMISS          OR   DISMISS Control         ::
::              JAL     R5,XDMISS          OR   DISMISS TRANSMIT        ::
::                                                                      ::
::              J       RHALT                   HALT RECEIVE            ::
::              J       PHALT              OR   HALT Control            ::
::              J       XHALT              OR   HALT TRANSMIT           ::
::                                                                      ::
::  THE ABOVE SYMBOLS ARE ACCESSED BY 'LO SNAEXC'.  A 'FO SNAEXC'       ::
::  SHOULD BE USED FOLLOWING THE REFERENCE.                             ::
::                                                                      ::
::  NO REGISTERS ARE SAVED BETWEEN DISMISSES.  TWO REGISTERS ARE        ::
::  INITIALIZED TO ALLOW THE PROCESS TO KNOW WHICH SDLC LINE IT IS      ::
::  EXECUTING FOR:                                                      ::
::                                                                      ::
::              RL      EQ      8       SDLC line number                ::
::              RL2     EQ      9       2 * RL                          ::
::                                                                      ::
::  THE ABOVE SYMBOLS ARE ACCESSED BY 'LO SDLCDF'.                      ::
::                                                                      ::
::  PROCESSES ARE RUN FOR ALL LINES IN THE ORDER: RECEIVE, Control,     ::
::  AND TRANSMIT.  THIS IS ACCOMPLISHED BY THE USER PLACING THE         ::
::  FOLLOWING CALL IN THE FOREGROUND EXEC LOOP:                         ::
::                                                                      ::
::              JAL     R10,DLCEXC      NO REGISTERS SAVED              ::
::                                                                      ::
::  BEFORE THE FOREGROUND IS CONNECTED, THE ROUTINE MUST BE INITIALIZED ::
::  ON A LINE BY LINE BASIS:                                            ::
::                                                                      ::
::              LHI     R1,LINE         R1 = SDLC   LINE NUMBER         ::
::              JAL     R5,SDLCXI       R0,R2-R4 NOT SAVED.             ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	SUBTTL ** SDLC PROTOCOL ** SNAEXC DEFINITIONS - SNAEXI

        RA      0
	MO	.,SNAEXC
	LO	FGGBDF
	LO	MAIN


:  RUN LISTS
:  ---------
:  DEFINE AREA TO HOLD THE EXECUTION ADDRESS FOR THE RECEIVE, TRANSMIT,
:  AND CONTROL PROCESS FOR EACH LINE.

        SEG     A.DATA
RRUNL   HS      2*NLINES        :RECEIVE
XRUNL   HS      2*NLINES        :TRANSMIT
PRUNL   HS      2*NLINES        :PROTOCOL


:  MISCELLANEOUS VARIABLES
:  -----------------------

FBIRET  HS      1*2             :DLCEXC RETURN ADDR
BBIRET  HS      1*2             :SDLCXI RETURN ADDR

        SUBTTL  ** SDLC PROTOCOL **  EXECUTION SCHEDULER INTIALIZATION - SDLCXI

:SDLCXI INITIALIZE THE EXECUTION SCHEDULER RUN LISTS AND OTHER SDLC
:------ ROUTINES ON A LINE BY LINE BASIS.

        SEG     A.CODE
SDLCXI  ST      R5,BBIRET,,     :SAVE RETURN ADDR
        LR      R2,R1           :MAKE WORD INDEX FOR LINE
        SLHLS   R2,2
        LA      R0,RRUNOF       :RESET RCV RUN LIST
        ST      R0,RRUNL,R2,
        LA      R0,XRUNOF       :RESET XMT RUN LIST
        ST      R0,XRUNL,R2,
        LA      R0,PRUNOF       :RESET PROTOCOL RUN LIST
        ST      R0,PRUNL,R2,
        L       R5,BBIRET,,
        JR      R5              :RETURN

        SUBTTL  ** SDLC PROTOCOL **  FOREGROUND EXECUTION CONTROLLER - DLCEXC

:DLCEXC EXECUTE THE VARIOUS SDLC PROCESSES ON A LINE BY LINE BASIS.
:------ PROCESSES NOT SCHEDULED FOR EXECUTION WILL CAUSE A BRANCH
:       TO THE 'OFF' ENTRY FOR THE LIST.

DLCEXC	ST	R10,FBIRET,,		:SAVE RETURN ADDR

:  RECEIVE RUN LIST
:  ----------------

        IF      NLINES-8
        LHI     RL2,(NLINES-1)*2        :INIT 2 * LINE INDEX
        ELSE
        LIS     RL2,(NLINES-1)*2        :INIT 2 * LINE INDEX
        EI

        IF      NLINES-10
        LHI     RL,(NLINES-1)           :INIT LINE INDEX
        ELSE
        LIS     RL,(NLINES-1)           :INIT LINE INDEX
        EI

RRUN10  L       R5,RRUNL,RL2,RL2        :GET ADDR TO RUN
        JR      R5                      :GO RUN

RHALT   LA      R5,RRUNOF               :TAKE LINE OFF RUN LIST
RDMISS  ST      R5,RRUNL,RL2,RL2        :DISMISS USER FOR THIS RUN CYCLE

RRUNOF  EQ      .
        IF      NLINES-1
        SIS     RL,1                    :GO TO NEXT LINE
        SIS     RL2,2
        JGEBS   RRUN10
        EI


:  PROTOCOL RUN LIST
:  -----------------

        IF      NLINES-8
        LHI     RL2,(NLINES-1)*2        :INIT 2 * LINE INDEX
        ELSE
        LIS     RL2,(NLINES-1)*2        :INIT 2 * LINE INDEX
        EI

        IF      NLINES-10
        LHI     RL,(NLINES-1)           :INIT LINE INDEX
        ELSE
        LIS     RL,(NLINES-1)           :INIT LINE INDEX
        EI

PRUN10  L       R5,PRUNL,RL2,RL2        :GET ADDR TO RUN
        JR      R5                      :GO RUN

PHALT   LA      R5,PRUNOF               :TAKE LINE OFF RUN LIST
PDMISS  ST      R5,PRUNL,RL2,RL2        :DISMISS USER FOR THIS RUN CYCLE

PRUNOF  EQ      .
        IF      NLINES-1
        SIS     RL,1                    :GO TO NEXT LINE
        SIS     RL2,2
        JGEBS   PRUN10
        EI

:  TRANSMIT RUN LIST
:  -----------------

        IF      NLINES-8
        LHI     RL2,(NLINES-1)*2        :INIT 2 * LINE INDEX
        ELSE
        LIS     RL2,(NLINES-1)*2        :INIT 2 * LINE INDEX
        EI

        IF      NLINES-10
        LHI     RL,(NLINES-1)           :INIT LINE INDEX
        ELSE
        LIS     RL,(NLINES-1)           :INIT LINE INDEX
        EI

XRUN10  L       R5,XRUNL,RL2,RL2        :GET ADDR TO RUN
        JR      R5                      :GO RUN

XHALT   LA      R5,XRUNOF               :TAKE LINE OFF RUN LIST
XDMISS  ST      R5,XRUNL,RL2,RL2        :DISMISS USER FOR THIS RUN CYCLE

XRUNOF  EQ      .
        IF      NLINES-1
        SIS     RL,1                    :GO TO NEXT LINE
        SIS     RL2,2
        JGEBS   XRUN10
        EI


        L       R10,FBIRET,,      	:RETURN TO FOREGROUND EXEC LOOP
        JR      R10

	FO	FGGBDF

        EM
   	SUBTTL	(SNA/SDLC) FOREGROUND INITIALIZATION - MAIN
:FGIN00.F00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Re-code and re-desgin for SNA Native Mode from
:			SDLC Interface.
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


:	THIS MODULE CONTAINS SEVERAL ROUTINES CALLED BY 
:	BACKGROUND TO INITIALIZE STATION CONTROL BLOCK FOR EACH
:	STATION AND INITIALIZATION INFORMATIONS
:	---------------------------------------------------------

:
	MO	.,MAIN

	LO	FGGBDF
	LO	SNAEXC
	LO	GBLDEF
	GL	PUCTAB			:(01/27/87 YLH)

:
	SEG	A.DATA
:
	WS	0
RET5	WS	1
:
	SEG	A.CODE

:	INIT FOREGROUND PROCESSES
:	SHUT OFF FOREGROUND :IZFG
:	----------------------------
:	LINK ON R5.
IZFG	ST	R5,RET5,,
	IF	NLINES-8
	LHI	RL2,(NLINES-1)*2
	ELSE
	LIS	RL2,(NLINES-1)*2
	EI
:
	IF	NLINES-10
	LHI	RL,(NLINES-1)		:INIT LINE INDEX
	ELSE
	LIS	RL,(NLINES-1)
	EI
:
IZFG1	LR	R1,RL2
	SRHLS	R1,1
	JAL	R5,SDLCXI,,		:INIT F/G EXEC
	JAL	R5,IZCBLK,,		:INITIAL LSC CONTAINS
	JAL	R5,IZSIO,,		:INITIALIZE SIO
:
IZFG2
	GL	PTPINI			:(10/01/85/CHS)
	JAL	R5,PTPINI		:(10/01/85/CHS)
	IF	NLINES-1
	SIS	RL,1			:GOTO NEXT LINE
	SIS	RL2,2			:DO ALL LINES
	JGE	IZFG1
	EI
	L	R5,RET5,,
	JR	R5
:
	
:
:	IZCBLK: INITIALIZE FOREGROUND CONTROL BLOCKS
:	------
:
IZCBLK
	LHL	RLCB,LCBPTR,RL,RL	:GET OFFSET OF LCB FROM LCBPTR
	LIS	R0,0
	ST	R0,LCBTAB+LCBS.R,RLCB,	:CLEAR LCBS.R, LCBS.X, LCBRRC, LCBXRC
	LHI	R3,LDARCV		:CLEAR LCB FROM LDARCV TO THE END
IZCBL2
	ST	R0,LCBTAB,R3,RLCB	:...
	AIS	R3,4			:MOVE TO NEXT FULL WORD
	CLHI	R3,LCBLEN		:DONE ?
	JL	IZCBL2			:LOOP, IF NOT
	LHL	R2,LNCPTR,RL,RL		:GET LNCTAB
	LHL	R14,LNCTAB+LNPUTB,R2,	:GET CUCTAB
	LIS	R13,0			:RELATIVE STATION CNT 
IZCBL3
	LHL	RLSC,PUCTAB+PUCLSC,R14,	:GET LSC ADDRESS
	LIS	R1,0			:INITIAL VALUE
	LHI	R3,LSCLEN-1		:GET LENGTH OF LSC
IZCBL4
	STB	R1,LSCLKS,R3,RLSC	:INIT THAT LOCATION
	SIS	R3,1			:GET NEXT LOCATION
	JGEBS	IZCBL4
	STH	R14,LSCLKS+LSCPUC,RLSC,	:LSCPUC
	LB	R1,PUCTAB+PUPLAD,R14,	:GET POLLING ADDRESS
	STB	R1,LSCLKS+LSCSAD,RLSC,	:STORE TO LSC
	STB	R13,LSCLKS+LSCRID,RLSC,	:STORE RELATIVE STATION
	LB	R1,PUCTAB+PUCT.N,R14,	:GET TOT REL #
	STB	R1,LSCLKS+LSCT.N,RLSC,	:STORE INTO LSC
	LIS	R0,0
	STH	R0,SECBLT,R1,R1		:CLEAR SECBLT FOR THIS LSC
	LHL	R4,SEDBIA,R1,R1		:GET SECTOR DATA BUF BASE BIASE
	LIS	R6,8
IZCBLX
	STH	R0,SECBAS,R4,		:CLEAR LEGNTH
	STH	R0,SECBAS+2,R4,		:CLEAR DATA BUFFER BASE PTR
	IF	FWBBF
	STH	R0,SECBAS+4,R4,		:...
	AIS	R4,6
	ELSE
	AIS	R4,4
	EI
	SIS	R6,1			:ALL DONE FOR 8 ENTRIES?
	JG	IZCBLX			:NO, REPEAT
	LO	CMDLST
	JAL	RLNK,GETCL,,		:INIT SIO RCV QUEUE
	JAL	RLNK,CLMPTY
	STH	RARG,LSCLKS+SGPSIO,RLSC,	:SET GET, REL, PUT PTRS
	STH	RARG,LSCLKS+SRPSIO,RLSC,
	STH	RARG,LSCLKS+SPPSIO,RLSC,
	IZCL(RCV,RLSC,RLCB)		:INIT RCV-Q
	IZCL(XMT,RLSC,RLCB)		:INIT XMT-Q
	IZCL(CMD,RLSC,RLCB)		:INIT CMD-Q
	FO	CMDLST
:
	LHL	R2,LNCPTR,RL,RL		:GET LNCTAB ADDR AGAIN
	AIS	R13,1			:INC. CNT
	CLB	R13,LNCTAB+LNMXPU,R2,	:COMPARE WITH MAX. # OF CU'S
	JGE	IZCBL5			:ALL DONE, SKIP
	AHI	R14,PUCLEN		: MOVE TO NEXT CU
	J	IZCBL3			:CONTINUE
IZCBL5
	JR	R5			:RETURN



:	IZSIO:	QUERY DEVICE ATTRIBUTES AND INITIALIZE SIO LINE.
:	-----
:	LINK -- R5,USE REGISTERS  0-8

IZSIO
:	INITIALIZE DATA STRUCTURES FIRST
	RBT	RL,SIORTS,,		:RESET SIORTS BIT ARRAY
	LIS	R0,0			:CLEAR CROTOR AND NXTSEC
	STB	R0,CROTOR,RL,		:...
	STH	R0,RINDEX,RL,RL		:SET RCV RING INDEX TO ZERO
	L	R6,SIOTBL,RL2,RL2	:GET SIO TABLE BASE
	STH	R0,08,R6	:RESET INTERRUPT INDICATION (F01/11/03/87/HS)
	LCS	R0,1			:INIT THE 1ST BYTE OF RBUF TO X'FFFF'
	STH	R0,RBUF,R6		:...
	STH	R0,TCCWL,R6		:RESET SIO ROTOR LIST
	STH	R0,TCCWL+4,R6
	STH	R0,TCCWL+10,R6
	STH	R0,TCCWL+14,R6
	STH	R0,TCCWL+20,R6
	STH	R0,TCCWL+24,R6
	STH	R0,TCCWL+30,R6
	STH	R0,TCCWL+34,R6
	STH	R0,TCCWL+40,R6
	STH	R0,TCCWL+44,R6
	STH	R0,TCCWL+50,R6
	STH	R0,TCCWL+54,R6
	STH	R0,TCCWL+60,R6
	STH	R0,TCCWL+64,R6
	STH	R0,TCCWL+70,R6
	STH	R0,TCCWL+74,R6

:	QUERY THE DEVICE TO MAKE URE IT IS AN SIO
	LR	R1,RL			:LINE # TO R1
	LA	R2,ATTBUF,RL2,RL2	:SET UP FOR QUERY SVC
	LHI	R3,3			:3 BYTES ATTRIBUTE
	SVC	IO,IOQRY.+R1,,
	J	IZS010			:SVC FAILURE
	LB	R0,ATTBUF,RL2,RL2	:GET BYTE FROM ATTBUF
	CLHI	R0,4			:SIO ?
	JN	IZS020			:NO, SKIP

:	INITIALIZE SIO LIN
	LR	R1,RL			:LINE # TO R1
	LR	R2,R6			:SIO TABLE BASE TO R2
	L	R3,SIOTBX,RL2,RL2	:SIO TABLE END TO R3
	LR	R4,R2			:STATUS FIELD = SIO TABLE BASE
	SVC	IO,(CMBRD.^4)+R1	:CONNECT SIO CARD
	J	IZS030			:SVC FAILURE
	SVC	DISMIS,1		:DISMISS FOR 1 SECOND

:	NOW ISSUE THE INITIALIZE COMMAND PAIRS TO SET UP LITTLE BOARD.
	LR	R1,RL			:LINE # TO R1
	LR	R2,R6			:SIO TABLE BASE + ICCW OFFSET
	AHI	R2,ICCW			:R2 POINT TO ICCW
	SVC	IO,(FMBOT.^4)+R1	:FORCE SIO OUTPUT
	J	IZS040			:SVC FAILURE
	SVC	DISMIS,1		:DISMISS TO LET COMMAND FINISH
	TBT	RL,RTSCTS		:IF RTSCTS=0, RTS ALWAYS UP
	JNFS	IZS005			:RTSCTS=1, RTS INIT TO DOWN
	SBT	RL,SIORTS,,		:INDICATE RTS IS UP

IZS005
	LR	R1,RL			:LINE # TO R1
	LR	R2,R6			:SIO TABLE BASE TO R2
	AHI	R2,INCCW		:POINT TO INCCW
	SVC	IO,(FMBIN.^4)+R1	:FORCE SIO INPUT
	J	IZS050			:SIO FAILURE
	SVC	DISMIS,1		:DISMISS FOR 1 SEC

	JR	R5			:RETURN

IZS010
:	I/O INQUIRY SVC FAILURE
	JAL	R10,CRASH,,
	BC	0,0,0,0E1		:I/O INQUERY svc FAILURE

IZS020
:	DEVICE NOT MOTHER BOARD
	JAL	R10,CRASH,,
	BC	0,0,0,0E2		:DEVICE NOT MOTHER BOARD

IZS030
:	CONNECT MOTHER BOARD SVC FAILUE
	JAL	R10,CRASH,,
	BC	0,0,0,0E6		:CONNECT SIO SVC FAILURE

IZS040
:	CONNECT SIO OUTPUT SVC FAILURE
	JAL	R10,CRASH,,
	BC	0,0,0,0E4		:SIO OUTPUT SVC FAILUE

IZS050
:	CONNECT SIO INPUT SVC FAILURE
	JAL	R10,CRASH,,
	BC	0,0,0,0E3		:SIO INPUT SVC FAILURE


	FO	FGGBDF
	FO	SNAEXC
	FO	GBLDEF
	EM
  	SUBTTL (SNA/SDLC) SDLC FOREGROUND SUBROUTINES - SFGPTP
:FSUB00.F00

:	:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Modified from SDLC Interface for SNA Native Mode
:			(Link Level from END-TO-END to Local Mode)
:	:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	RA	0
	MO	.,SFGPTP



	LO	MAIN
	LO	GBLDEF
	LO	CMDLST
	LO	FGGBDF
	LO	SNAEXC


:	LINE OPTION TABLE GENERATION
:	----------------------------
:	THE FOLLOWING MACRO GENERATES A TABLE FOR A SPECIFIC LINE
:	OPTION THAT IS HW INDEXED BY SDLC LINE NUMBER.
:	THE TABLE IS REFERENCED IN CODE BY:
:		LHL REG,OPT.LN,RL2	OPT=OPTION
:
:	MACRO USAGE:	MAC(OPT,DFAULT,MODS)
:			OPT=OPTION NAME ENDING IN'.'
:			DFAULT=DEFAULT, EVALUATED IN DECIMAL.
:			MODS=OPERATION TO BE PERFORMED ON USER
:				DEFINED VALUE OR DEFAULT (LIKE 
:				SCALING).

	KILL	MAC			:KILL PREVIOUS TEMP MACRO
MAC	MACRO(OPT,DF,MODS)[
OPT`LN	HS	0			:START OF TABLE FOR THIS OPTION
Q	EQ	0
	RE	NLINES
	IF	$A`\OPT|Q|
	HC	$A`OPT|Q|`MODS		:USER SPECIFIED VALUE
	ELSE
	HC	$A`DF`MODS			:DEFAULT
	EI
Q	EQ	Q+1
	ER
		]


:	DEFINE CONSTANTS
:	----------------
DSRFLG	EQ	20			:DSR BIT FLAG
FRMRW	EQ	80			:W-FIELD FOR FRMR SECOND CONTROL
FRMRX	EQ	0C0			:X-FIELD FOR FRMR 2ND CONTROL (W,X=1)
FRMRY	EQ	20			:Y-FIELD FOR FRMR SECOND CONTROL
FRMRZ	EQ	10			:Z-FIELD FOR FRMR SECOND CONTROL
FRMRN	EQ	08			:FOR 8100 WRONG NR


:	DEFINE LOCAL STORAGES
:	---------------------

	SEG	A.DATA

	BND	4
RTRN	WS	NLINES		:SAVE AREA FOR RETURN ADDRESS
FSUBSV	WS	10
	IF	FDEBUG
:	TRACE BUFFER TO TRACE BUFFER USAGE AND CMD LINK
:	EVERY TIME A CMD IS EXECUTED OR IS RELEASED TO BG, AN ENTRY
:	IS RECORD IN THIS BUFFER
:	EACH ENTRY IS 8 BYTES WITHOUT TIME STAMP (GMT)
:		HS - PROTOCOL CALLING ADDRESS (TO KNOW WHERE)
:		HS - CMD CODE IN CMD CELL
:		HS - BUFFER HEAD ADDR IN THE CMD
:		HS - NEXT CMD PTR
:	WHEN TRSTLN IS SET, GMT IS THE 1ST FULL WORD FOR EACH ENTRY
TRFBLN	HS	(NLINES-1)/10+1		:F-T-B TRACE ACCORDING TO LINE
TRBFLN	HS	(NLINES-1)/10+1		:B-T-F TRACE ACCORDING TO LINE
TRSTLN	HS	(NLINES-1)/10+1		:GMT TIME STAMP REQUIRED
	IF	\TRSBFS
	ELSE
TRSBFS	EQ	800			:DEFAULT 2K BYTES
	EI	(\TRSBFS)
TRSBFP	HC	0			:DEBUG TRACE BUFFER INDEX
TRSBUF	BS	TRSBFS			:DEBUG TRACE BUFFER AREA
	EI	(FDEBUG)


	SUBTTL (SFGPTP) SDLC LINK PROCEDURES' TIMERS


	SEG	A.CODE


:	PT-TO-PT CONTENTION TIMERS
:	-------------------------
:	THE VALUES OF THE FOLLOWING TIMERS MAY BE DEFINED ON A
:	LINE BY LINE BASIS USING THE SYMBOL:TTT.LL, TTT=TIMER,
:	LL=DECIMAL SDLC LINE NUMBER (TTD.0, TBD.8, ETC).
:	THE VALUE OF THE SYMBOL IS IN SECONDS.  IF A SYMBOL IS
:	UNDEFINED FOR A LINE, THE DEFAULT FOR PT-TO-PT CONTENTION
:	'SLAVE' SPECIFIED BELOW IS USED:


T0	EQ	TPS			:1 SEC.
T1	EQ	TPS/2			:1/2 SEC.
T2	EQ	TPS/$096		:1/600 SEC.
N1	EQ	5			:5 TIMES
N2	EQ	5000			:5000 TIMES

T1.LN	HS	0			:START OF TABLE FOR THIS OPTION
Q	EQ	0
	RE	NLINES
	IF	$A\T1.|Q|
	HC	$AT1.|Q|*T0
	ELSE
	IF	LINK|Q|
	HC	$A1*T0
	ELSE
	HC	$A15*T0
	EI
	EI
Q	EQ	Q+1
	ER				:TIMER FOR RECEIVE RESPONSE (T1)

	MAC(TPO.,1,*T0)			:POLLING (SNRM) RETRY TIMER

	MAC(TRR.,1,*T1)			:RR/RR IDLE TIME

	MAC(TRX.,1,*1)			:RCV TO XMT TURN AROUND TIME

	MAC(TXC.,3,*T0)			:XMT COMPELTE TIMER

	MAC(THW.,2,*T2)			:XMT HW COMPLETE TIME, IN 1/600 SEC.

	MAC(SRC.,N1,*1)			:NUMBER OF RETRY (RC)

	MAC(PAU.,5,*T0)			:PAUSE TIMER BETWEEN RETRY SEQUENCE

	MAC(SEQ.,5,*1)			:NUMBER OF RETRY SEQUENCE

	MAC(RCB.,N1,*1)			:EXTERNAL SYSTEM BUSY, # OF RETRY (RCB)


	SUBTTL (SFGPTP) RS-232-C ELECTRICAL SIGNALS HANDLING ROUTINES


:	ROUTINE TO CHECK DCD (DSR) BIT ON SIO CHIP
:	-------------------------------------------
:	INPUT:	R8 = LINE NUMBER
:		R4 = LINK REGISTER
:	OUTPUT:	IF DCD(DSR) ON, SET THE SIODSR BIT ARRAY
:		IF DCD(DSR) OFF, RESET THE SIODSR BIT ARRAY
:	REGISTERS RESTROYED: R0,R3
CHKDSR
	SLHLS	R8,1			:MAKE R8=LINE*2
	L	R3,SIOTBL,R8,R8
	SRHLS	R8,1			:RE-SET R8 = LINE
	RBT	R8,SIODSR,,		:ASSUME DCD (DSR) OFF
	LB	R0,0,R3			:GET 1ST BYTE OF READ STATUS
	TBT	RL,D.SIOC		:NEW SIO DAUGHTER CARD?(5/10/85/CHS)
	JEFS	CHKDS1			:NO, SKIP(5/10/85/CHS)
	NHI	R0,DCDHMS		:IS DCD (DSR) ON?(5/10/85/CHS)
	JFS	CHKDS2			:SKIP TO CONTINUE(5/10/85/CHS)
CHKDS1					:(5/10/85/CHS)
	NHI	R0,DCDGMS		:IS DCD (DSR) ON? (5/10/85/CHS)
CHKDS2					:(5/10/85/CHS)
	JER	R4			:HIT, RETURN
	SBT	R8,SIODSR,,		:ELSE, INDICATE DCD(DSR) ON
	JR	R4			:AND RETURN
 
 
:	ROUTINE TO CHECK CTS BIT ON SIO CHIP
:	--------------------------------------
:	INPUT:	R8 = LINE NUMBER
:		R4 = LINK REGISTER
:	OUTPUT:	IF CTS ON, SET THE SIOCTS BIT ARRAY
:		IF DCD OFF, RESET THE SIOCTS BIT ARRAY
:	REGISTERS RESTROYED: R0,R3
CHKCTS
	SLHLS	R8,1			:MAKE R8=LINE*2
	L	R3,SIOTBL,R8,R8
	SRHLS	R8,1			:RE-SET R8 = LINE
	RBT	R8,SIOCTS,,		:ASSUME CTS OFF
	LB	R0,0,R3			:GET 1ST BYTE OF READ STATUS
	TBT	RL,D.SIOC		:NEW SIO DAUGHTER CARD?(5/10/85/CHS)
	JEFS	CHKCT1			:NO, SKIP(5/10/85/CHS)
	NHI	R0,CTSHMS		:IS CTS ON?(5/10/85/CHS)
	JFS	CHKCT2			:SKIP TO CONTINUE(5/10/85/CHS)
CHKCT1					:(5/10/85/CHS)
	NHI	R0,CTSGMS		:IS CTS ON? (5/10/85/CHS)
CHKCT2					:(5/10/85/CHS)
	JER	R4			:HIT, RETURN
	SBT	R8,SIOCTS,,		:ELSE, INDICATE CTS ON
	JR	R4			:AND RETURN
:(F05/07/27/87/DB/START)
:	ROUTINE TO CHECK FOR SIO INTERRUPT FOR OVERRUN
:	----------------------------------------------
:	LINK: R4 = LINK REGISTER
CHKINT
	LR	R9,R8			:GET LINE #
	AR	R9,R9			:GET 2 * LINE #
	L	R10,SIOTBL,R9,R9	:GET SIOTBL ENTRY
	LB	R0,08,R10,		:GET SIO STATUS
	JER	R4			:STATUS O.K. RETURN
	SRLS	R0,4	
	NHI	R0,0F
	CHI	R0,06			:SIO OVERRUN?
	JE	RSTSIO			:YES, RESET PORT
	JAL	R10,CRASH,,		:NO, OTHER CONDITION CRASH
	BC	0,0,0,0FE

RSTSIO
	LHI	R0,0
	STH	R0,08,R10		:CLEAR SIO STATUS
	JAL	R5,IZSIO,,		:RE-INIT SIO
	JR	R4			:RETURN


:	ROUTINE TO RAISE DTR OR DROP DTR
:	--------------------------------
:	INPUT:	R8 = LINE #
:		R0 = 0, DROP DTR
:		     1, RAISE DTR
:		R4 = LINK REGISTER
:	OUTPUT:	CRASH IF SVC FAILED
:		SIODTR BIT ARRAY SET/RESET ACCORDINGLY
:	REGISTER DESTROYED: R2,R3
 
DTRCTL
	SLHLS	R8,1			:SET R8 = LINE# * 2
	L	R3,SIOTBL,R8,R8		:GET SIOTABLE ADDRESS
	SRHLS	R8,1			:RE-SET R8 = LINE#
	RBT	R8,SIODTR,,		:ASSUME WANT TO DROP DTR
	RBT	R8,SIORTS,,		: WHEN DTR DROPPED, RTS TOO.
	LR	R0,R0			:SEE IF WANT TO RAISE OR DROP DTR
	JE	DTRCT1			:HIT, WANT TO DROP DTR
	SBT	R8,SIODTR,,		:ELSE, INDICATE DTR UP
	LI	R2,DTRCU1		:ASSUME DONT NEED TO RAISE RTS
	TBT	R8,RTSCTS,,		:IS THIS LINE NEED RTS/CTS?
	JNFS	DTRCT2			:YES, DONT RAISE RTS NOW, 
	LI	R2,DTRCU2		:RAISE DTR AND RTS
	SBT	R8,SIORTS,,		:INDICATE RTS UP
	JFS	DTRCT2			:GOTO ISSUE SVC CALL
DTRCT1
	LI	R2,DTRCD1		:GET DTR DOWN COMMAND
DTRCT2  
	ST	R2,OCPW,R3,		:STORE DTR CMD PAIR INTO SIOTABLE
	AHI	R3,OCPW			:GET OUTPUT CMD PAIR LOCATION
	LR	R2,R8			:GET LOGICAL UNIT NUMBER
	SVC	IO,(FMBOT.^4)+R2	:ISSUE OUTPUT SVC
	J	DTRERR			:SVC FAILED
	JR	R4			:RETURN


:	CONNECT SIO OUTPUT SVC FAILURE
:	------------------------------
DTRERR
	JAL	R10,CRASH,,
	BC	0,0,0,0E0		:CONNECT SIO OUTPUT SVC FAILURE


	SUBTTL (SFGPTP) LCB MANIPULATION ROUTINES


:***************************************************************:
:								:
:	CHECK STATE OF BIT ARRAYS IN LCB			:
:								:
:***************************************************************:


:	ROTUINE TO CHECK LCBTRM BIT
:	---------------------------
:	INPUT:	RLSC, RLCB SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN, IF LCBTRM BIT OFF
:		NORMAL RETURN, IF LCBTRM BIT ON
:	DESTROYED R6
:CHKTRM
:	LB	R6,LSCLKS+LSCRID,RLSC,	:GET RELATIVE STATION#    
:	TBT	R6,LCBTAB+LCBTRM,RLCB,	:TEST LCBTRM BIT ARRAY
:	JE	4,R5			:SKIP RETURN, IF LCBTRM BIT OFF
:	JR	R5			:NORMAL RETURN, IF LCBTRM ON


:	ROUTINE TO CHECK LCBCLR BIT
:	---------------------------
:	INPUT:	RLSC, RLCB SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN IF LCBCLR BIT OFF
:		NORMAL RETURN IF LCBCLR BIT ON
:CHKCLR
:	LB	R6,LSCLKS+LSCRID,RLSC,	:GET RELATIVE STATION#    
:	TBT	R6,LCBTAB+LCBCLR,RLCB,	:GET ( STATION) CLEAR BIT ARRAY   
:	JE	4,R5			:SKIP RETURN, IF LCBCLR BIT OFF
:	JR	R5			:NORMAL RETURN, IF LCBCLR BIT ON


:***************************************************************:
:								:
:	RESET THE STATE OF BIT ARRAYS IN LCB			:
:								:
:***************************************************************:


:	ROUTINE TO RESET THE TERMP CONDITION FOR A LKS
:	---------------------------------------------
:	INPUT: RLSC, RLCB SET UP
:		R5 = LINK REGISTER
:	OUTPUT: LCBTRM BIT RESET FOR THIS LSC
:	DESTROYED: R0
:CLRTRM
:	LB	R6,LSCLKS+LSCRID,RLSC,	:GET RELATIVE STATION#    
:	RBT	R6,LCBTAB+LCBTRM,RLCB,	:RESET ( STATION) TERMINATE BIT ARRAY 
:	JR	R5			:RETURN


:	ROUTINE TO RESET CLEARP CONDITION FOR A LKS
:	------------------------------------------
:	INPUT: RLSC, RLCB SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LCBCLR BIT RESET FOR THIS LSC
:	DESTROYED : R0
:CLRCLR
:	LB	R0,LSCLKS+LSCRID,RLSC,	:GET RELATIVE STATION#    
:	RBT	R0,LCBTAB+LCBCLR,RLCB,	:RESET ( STATION) CLEAR BIT ARRAY   
:	JR	R5			:RETURN


:***************************************************************:
:								:
:	SET UP AND DECREASE LCBRTY BYTE IN LCB			:
:								:
:***************************************************************:


:	ROUTINE TO SET RC (RETRY COUNTER) FOR A LINK
:	---------------------------------------------------
:	INPUT:	RL2 = LINE # *2
:		RLCB SET UP
:	OUTPUT:	LCBRTY CHANGED
:	DESTROYED: R0
SETLRC
	LHL	R0,SRC.LNN,RL2		:GET RETRY COUNT
	STB	R0,LCBTAB+LCBRTY,RLCB,	:PUT RETRY VALUE INTO LCB
	JR	R5


:	ROUTINE TO DECREMENT LRC BY 1
:	-----------------------------
:	INPUT:	LCB SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	R0 = LRC VALUE
:	CRASH, IF LESS THAN 0
DECLRC
	LB	R0,LCBTAB+LCBRTY,RLCB,	:GET LCBRTY
	JLE	DECLR1			:IF RETRY CNT = 0, CRASH
	SIS	R0,1			:DEC. RETRY COUNTER BY 1
	STB	R0,LCBTAB+LCBRTY,RLCB,	:STORE NEW RETRY COUNT
	JR	R5
DECLR1
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


	SUBTTL (SFGPTP) LSC MANIPULATION ROUTINES


:***************************************************************:
:								:
:	COMPARE V(S), V(R), N(S), N(R), AND NP VALUES IN LSC	:
:								:
:***************************************************************:


:	ROUTINE TO CHECK N(S)=V(R)
:	---------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN - N(S) = V(R)
:		NORMAL RETURN - N(S) NOT = V(R)
:	DESTROYED R6
CKNSVR	
	LB	R6,LSCLKS+LSCNSR,RLSC,	:GET N(S) VALUE FROM RLSC
	CLB	R6,LSCLKS+LSCVRX,RLSC,	:COMPARE N(S) TO V(R)
	JNR	R5			:NORMAL RETURN, IF N(S) NOT = V(R)
	J	4,R5			:ELSE, SKIP RETURN


:	ROUTINE TO CHECK N(R) = V(S)
:	------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN - N(R) = V(S)
:		NORMAL RETURN - N(R) NOT = V(S)
:	DESTROYED R6
CKNRVS
	LB	R6,LSCLKS+LSCNRR,RLSC,	:GET N(R) FROM LSC    
	CLB	R6,LSCLKS+LSCVSX,RLSC,	:COMPARE N(R) TO V(S)
	JNR	R5			:NORMAL RETURN, IF N(R) NOT = V(S)
	J	4,R5			:SKIP RETURN,IF N(R)=V(S)
 

:	ROUTINE TO CHECK N(R) >= NP
:	--------------------------
:	INPUT:	RLSC SET UP
:	R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN - N(R) < NP
:		NORMAL RETURN - N(R) >= NP
:	DESTROYED R6
CKNRNP	
	LB	R6,LSCLKS+LSCNRR,RLSC,	:GET NR VALUE
	CLB	R6,LSCLKS+LSCNPX,RLSC,	:COMPARE N(R) TO NP
	JGER	R5			:NORMAL RETURN, IF N(R) >= NP
	J	4,R5			:SKIP RETURN ,IF N(R) < NP


:	(8/13/85/CHS, START)
:	ROUTINE TO CHECK N(R) BETWEEN VSU AND VS
:	----------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	NO SKIP RETURN, IF N(R) OUTSIDE [VSU,VS]
:		SKIP RETURN, IF N(R) WITHIN [VSU,VS]
:	DESTROYED R0,R6,R7
CHKNR
	LB	R6,LSCLKS+LSCNRR,RLSC,	:R6 = N(R)
	LB	R0,LSCLKS+LSCVSU,RLSC,	:R0 = VSU
	SR	R6,R0			:R6 = N(R)-VSU
	LB	R1,LSCLKS+LSCVSX,RLSC,	:R1 = V(S)
	LB	R0,LSCLKS+LSCNRR,RLSC,	:R0 = N(R)
	SR	R1,R0			:R1 = V(S)-N(R)
	LB	R7,LSCLKS+LSCVSX,RLSC,	:R7 = V(S)
	LB	R0,LSCLKS+LSCVSU,RLSC,	:=R0 = VSU
	SR	R7,R0			:R7 = V(S)-VSU
	XR	R6,R1
	XR	R6,R7
	JGE	4,R5			:N(R) IN [VSU,V(S)], OK., SKIP RETURN
	JR	R5			:N(R) NOT IN [VSU,V(S)], NO-SKIP RETURN
:	(8/13/85/CHS, END)


:***************************************************************:
:								:
:	CHECK THE INDIVIDUAL BIT OF THE LSCBIT BYTE IN LSC	:
:								:
:***************************************************************:


:	ROUTINE TO CHECK INCOMING FRAME P/F BIT SET OR NOT
:	------------------------------------------------
:	INPUT:	RLSC
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN = P/F BIT ON
:		NORMAL RETURN = P/F BIT OFF
:	DESTOYED R6
CHKIPF
	LHL	R6,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R6,IPFBIT		:CHECK INPUT P/F BIT
	JN	4,R5			:SKIP RETURN,IF P/F BIT ON
	JR	R5


:	ROUTINE TO CHECK IF O.K. TO XMT FRAME WITH P/F BIT ON
:	-----------------------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN IF O.K.
:		NORMAL RETURN IF NOT
:	DESTROYED R6
CHKXPF
	LHL	R6,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R6,XPFBIT		:IS XPFBIT ON?
	JER	R5			:NORMAL RETURN, XPFBIT OFF
	J	4,R5			:SKIP RETURN IF XPFBIT ON


:	ROUTINE TO CHECK IF END BIT ON
:	-------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN, IF END BIT ON
:		NORMAL RETURN, IF END BIT OFF
:	DESTROYED R6
CHKEND
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R0,ENDBIT		:IS END BIT ON?
	JER	R5			:RETURN,IF END IS OFF
	J	4,R5			:SKIP RETURN IF END IS ON


:	ROUTINE TO CHECK IF REMOTE BUSY
:	-----------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN IF REMOTE NOT BUSY
:		NORMAL RETURN IF REMOTE BUSY
:	DESTROYED R6
CHKRBY
	LHL	R6,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R6,RBYBIT		:IS RBYBIT ON?
	JER	R5			:NORMAL RETURN, IF RBYBIT OFF
	J	4,R5			:SKIP RETURN IF RBYBIT ON


:	ROUTINE TO CHECK REJBIT
:	-----------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN, IF OFF
:		NORMAL RETURN, IF ON
:	DESTROYED R0
CHKREJ
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R0,REJBIT		:IS REJBIT ON?
	JNR	R5			:NORMAL RETURN, IF BIT ON
	J	4,R5			:SKIP RETURN IF REJ IS OFF


:	ROUTINE TO CHECK RR0BIT
:	-----------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN, IF OFF
:		NORMAL RETURN, IF ON
:	DESTROYED R0
CHKRR0
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R0,RR0BIT		:IS RR0BIT ON?
	JNR	R5			:NORMAL RETURN, IF BIT ON
	J	4,R5			:SKIP RETURN IF RR0 IS OFF


:	ROUTINE TO SEE IF ENOUGH BB AVAILABLE AND B.G. INDICATE BUSY
:	-----------------------------------------------------------
:	INPUT:	RLSC, RLCB SET UP
:		RL = LINE #
:		R5 = LINK REGISTER
:	OUTPUT:	SKIP RETURN IF NO BB OR B.G. BUSY
:			R0 = 0, IF 1ST TIME BUSY
:			R0 = 1, IF ALREADY BUSY
:		NORMAL RETURN IF EVERYTHING O.K.
:	DESTROYED R0,R6
CHKBSY	
	LB	R6,LSCLKS+LSCRID,RLSC,	:GET REL #
	TBT	R6,LCBTAB+LCBBSY,RLCB,	:CHECK BUSY BIT ARRAY
	JN	CHKBS1			:SKIP RETURN IF BUSY
	LHL	R6,LSCLKS+LSCPUC,RLSC,	:R6 = PUC OFFSET
	LH	R0,PUCTAB+PURBUS,R6,	:GET # OF RCV USAGE IN PUC
	LR	R0,R0
	JLE	CHKBS1			:SKIP RETURN IF QUOTA USED-UP
	LHL	R6,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R6,@SBYBIT		:RESET SBYBIT
	STH	R6,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE IN LSC
	JR	R5			:NORMAL RETURN IF NOT BUSY AND BB AVAIL
CHKBS1
	LHL	R6,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	LIS	R0,0			:ASSUME NOT 1ST TIME BUSY,SET R0 TO 0
	THI	R6,SBYBIT		:SEE IF ALREADY BUSY
	JEFS	CHKBS2			:1ST TIME, SKIP
	LIS	R0,1			:ELSE, SET R0 TO 1
CHKBS2
	OHI	R6,SBYBIT		:SET ALREADY BUSY
	STH	R6,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE IN LSC
	J	4,R5			:SKIP RETURN, BUSY



:***************************************************************:
:								:
:	SET THE INDIVIDUAL BIT OF THE LSCBIT BYTE IN LSC	:
:								:
:***************************************************************:


:	ROUTINE TO SET OPFBIT ON IN LSCBIT BYTE
:	----------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	OPFBIT IN LSCBIT IS SET TO 1
:	DESTROYED: R0
SETOPF
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	OHI	R0,OPFBIT		:SET OPFBIT ON
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO SET XPFBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	XPFBIT IN LSCBIT IS SET TO 1
:	DESTROYED: R0
SETXPF
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	OHI	R0,XPFBIT		:SET XPFBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO SET ENDBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	ENDBIT IN LSCBIT IS SET TO 1
:	DESTROYED: R0
SETEND	
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	OHI	R0,ENDBIT		:SET ENDBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO SET RBYBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	RBYBIT IN LSCBIT IS SET TO 1
:	DESTROYED: R0
SETRBY
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	OHI	R0,RBYBIT		:SET RBYBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO SET RXTBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	RXTBIT IN LSCBIT IS SET TO 1
:	DESTROYED: R0
SETRXT
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	OHI	R0,RXTBIT		:SET RXTBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO SET REJBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	REJBIT IN LSCBIT IS SET TO 1
:	DESTROYED: R0
SETREJ
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	OHI	R0,REJBIT		:SET REJBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO SET RR0BIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	RR0BIT IN LSCBIT IS SET TO 1
:	DESTROYED: R0
SETRR0
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	OHI	R0,RR0BIT		:SET RR0BIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:***************************************************************:
:								:
:	RESET THE INDIVIDUAL BIT OF LSCBIT BYTE IN LSC		:
:								:
:***************************************************************:


:	ROUTINE TO CLEAR OPFBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	OPFBIT IN LSCBIT IS RESET TO 0
:	DESTROYED: R0
CLROPF
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R0,@OPFBIT		:RESET OPFBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO CLEAR XPFBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	XPFBIT IN LSCBIT IS RESET TO 0
:	DESTROYED: R0
CLRXPF
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R0,@XPFBIT		:RESET XPFBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT
	JR	R5


:	ROUTINE TO CLEAR ENDBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	ENDBIT IN LSCBIT IS RESET TO 0
:	DESTROYED: R0
CLREND
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R0,@ENDBIT		:RESET ENDBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO CLEAR RBYBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	RBYBIT IN LSCBIT IS RESET TO 0
:	DESTROYED: R0
CLRRBY
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCIT BYTE
	NHI	R0,@RBYBIT		:RESET RBYBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO CLEAR RXTBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	RXTBIT IN LSCBIT IS RESET TO 0
:	DESTROYED: R0
CLRRXT
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R0,@RXTBIT		:RESET RXTBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO CLEAR REJBIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	REJBIT IN LSCBIT IS RESET TO 0
:	DESTROYED: R0
CLRREJ
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCIT BYTE
	NHI	R0,@REJBIT		:RESET REJBIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:	ROUTINE TO CLEAR RR0BIT IN LSCBIT BYTE
:	------------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	RR0BIT IN LSCBIT IS RESET TO 0
:	DESTROYED: R0
CLRRR0
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCIT BYTE
	NHI	R0,@RR0BIT		:RESET RR0BIT
	STH	R0,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE
	JR	R5


:***************************************************************:
:								:
:	RETRY COUNTS - SRC, RCB MANIPULATION ROTUINES		:
:								:
:***************************************************************:


:	ROUTINE TO SET RC FOR A STATION
:	-------------------------------
:	INOUT:	RL2 = LINE # * 2
:		RLSC SET UP
:	OUTPUT:	LSCSRC CHANGED
:	DESTROYED: R0
SETSRC
	LHL	R0,SRC.LN,RL2		:GET RETRY VALUE
	STB	R0,LSCLKS+LSCSRC,RLSC,	:PUT INTO LSC
	JR	R5

:	ROUTINE TO SET RC.SEQ FOR A STATION
:	-------------------------------
:	INOUT:	RL2 = LINE # * 2
:		RLSC SET UP
:	OUTPUT:	LSCSEQ CHANGED
:	DESTROYED: R0
SETSEQ
	LHL	R0,SEQ.LN,RL2		:GET RETRY SEQ  VALUE
	STB	R0,LSCLKS+LSCSEQ,RLSC,	:PUT INTO LSC
	JR	R5

:	ROUTINE TO SET RE-TRANSMISSION COUNTER
:	-----------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LSCRCB CHANGED
:	DESTROYED: R0
SETRCB	
	LHL	R0,RCB.LN,RL2		:GET RETRY VALUE
	STB	R0,LSCLKS+LSCRCB,RLSC,	:SET RETRANSMISSION COUNTER
	JR	R5


:	ROUTINE TO DECREMENT RC BY 1
:	----------------------------
:	INPUT:	LSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	R0 = LSCSRC VALUE
:		CRASH, IF LESS THAN 0
DECSRC
	LB	R0,LSCLKS+LSCSRC,RLSC,	:GET RETRY COUNTER
	JLE	DECSR1			: IF RETRY CNT=0, CRASH
	SIS	R0,1			:DEC. RETRY COUNTER BY 1
	STB	R0,LSCLKS+LSCSRC,RLSC,	:STORE NEW RETRY COUNT
	JR	R5			:RETURN
DECSR1
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


:	ROUTINE TO DECREMENT RETRY SEQUENCES BY 1
:	----------------------------
:	INPUT:	LSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	R0 = LSCSEQ VALUE
:		CRASH, IF LESS THAN 0
DECSEQ
	LB	R0,LSCLKS+LSCSEQ,RLSC,	:GET RETRY SEQUENCE COUNTER
	JLE	DECSE1			: IF RETRY SEQ. CNT=0, CRASH
	SIS	R0,1			:DEC. RETRY SEQ. COUNTER BY 1
	STB	R0,LSCLKS+LSCSEQ,RLSC,	:STORE NEW RETRY SEQ. COUNT
	JR	R5			:RETURN
DECSE1
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


:	ROUTINE TO DECREMENT RCB BY 1
:	------------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT: R0 = LSCRCB VALUE
:		CRASH, IF LESS THAN 0
DECRCB
	LB	R0,LSCLKS+LSCRCB,RLSC,	:GET LSCRCB CNT
	JLE	DECRC1			:IF RETRY CNT=0, CRASH
	SIS	R0,1			:DEC. RETRY COUNTER BY 1
	STB	R0,LSCLKS+LSCRCB,RLSC,	:STORE NEW RETRY COUNT
	JR	R5			:RETURN
DECRC1
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


:***************************************************************:
:								:
:	VSU AND FRAMES ACKNOWLEDGEMENT ROUTINES			:
:								:
:***************************************************************:


:	ROUTINE TO SET VSU=N(R) AND HANDLE FRAMES ACK'ED
:	------------------------------------------------
:	RESET SECTOR BUILT ARRAY FROM SECTOR VSU TO NR
:	AND SET VSU = N(R)
:	INPUT:	LSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SECBLT RESET FROM VSU TO N(R)
:		LSCVSU = LSCNRR
:	DESTROYED: R0, R1, R4
SETUR
	LB	R0,LSCLKS+LSCVSU,RLSC,	:GET VSU VALUE
	LB	R1,LSCLKS+LSCNRR,RLSC,	:GET N(R) VALUE
	LB	R4,LSCLKS+LSCT.N,RLSC,
SETUR1
	CR	R0,R1			:IS VSU = N(R)?
	JEFS	SETUR2			:YES, SKIP
	RBT	R0,SECBLT,R4,R4		:RESET SECBLT ARRAY (I.E.
					: THIS SECTOR ACK'ED)
	JEFS	SETURX
	JAL	R6,DLTSEC		:DELETE ENTRY
SETURX
	AIS	R0,1			:INCREASE TO NEXT SECTOR
	AHI	R0,MODUL8		:MODULU 8
	NHI	R0,FMMSK		:WRAP AROUND
	JBS	SETUR1
SETUR2
	STB	R1,LSCLKS+LSCVSU,RLSC,	:SET VSU=N(R)
	JR	R5


:	ROUTINE TO RESET SECTBLT ARRY AND SET VSU=V(S)=N(R)
:	------------------------------------------------
:	RESET SECTOR BUILT ARRAY FROM SECTOR VSU TO NR
:	AND SET VSU = V(S) = N(R)
:	INPUT:	LSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	SECBLT RESET FROM VSU TO N(R)
:		LSCVSU = LSCVSX = LSCNRR
:	DESTROYED: R0, R1, R4
SETUSR
	LB	R0,LSCLKS+LSCVSU,RLSC,	:GET VSU VALUE
	LB	R1,LSCLKS+LSCNRR,RLSC,	:GET N(R) VALUE
	LB	R4,LSCLKS+LSCT.N,RLSC,
SETUS1
	CR	R0,R1			:IS VSU = N(R)?
	JEFS	SETUS2			:YES, SKIP
	RBT	R0,SECBLT,R4,R4		:RESET SECBLT ARRAY (I.E.
					: THIS SECTOR ACK'ED)
	JEFS	SETUSX
	JAL	R6,DLTSEC		:DELETE ENTRY
SETUSX
	AIS	R0,1			:INCREASE TO NEXT SECTOR
	AHI	R0,MODUL8		:MODULU 8
	NHI	R0,FMMSK		:WRAP AROUND
	JBS	SETUS1
SETUS2
	STB	R1,LSCLKS+LSCVSU,RLSC,	:SET VSU=N(R)
	STB	R1,LSCLKS+LSCVSX,RLSC,	:SET VS = N(R)
	JR	R5


:	ROUTINE TO SET NP = VSU
:	------------------------
:	INPUT: RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	NP = VSU
:	DESTROYED: R0
SETNPU	
	LB	R0,LSCLKS+LSCVSU,RLSC,	:GET VSU VALUE
	STB	R0,LSCLKS+LSCNPX,RLSC,	:STORE NEW NP VALUE
	JR	R5


:	ROUTINE TO SET NP = V(S)
:	-------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT: NP = V(S)
:	DESTROYED: R0
SETNP	
	LB	R0,LSCLKS+LSCVSX,RLSC,	:GET VS VALUE
	STB	R0,LSCLKS+LSCNPX,RLSC,	:STORE NEW NP VALUE
	JR	R5


:	ROUTINE TO INCREMENT VS VALUE
:	-----------------------------
:	INPUT:	RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LSCVSX INCREASED
:	DESTROYED: R0
INCVS	
	LB	R0,LSCLKS+LSCVSX,RLSC,	:GET VS VALUE
	AIS	R0,1			:INC. VS BY 1
	NHI	R0,FMMSK		:MASK OFF UNUSED BITS (WINDOW)
	STB	R0,LSCLKS+LSCVSX,RLSC,	:STORE NEW VS VALUE
	JR	R5


:	ROUTINE TO INCREMENT VR VALUE BY 1
:	-----------------------------------
:	INPUT: RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT: LSCVRX INCREASED
:	DESTROYED: R0
INCVR	
	LB	R0,LSCLKS+LSCVRX,RLSC,	:GET VR VALUE
	AIS	R0,1			:INC. VR BY 1
	NHI	R0,FMMSK		:MASK OFF UNUSED BITS (WINDOW)
	STB	R0,LSCLKS+LSCVRX,RLSC,	:STORE NEW VR VALUE
	JR	R5


:	ROUTINE TO CLEAR VS AND VR VALUE
:	---------------------------------
:	INPUT: RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT: LSCVSX AND LSCVRX CLEARED
:	DESTROYED: R0
CLRVSR	
	LIS	R0,0
	STB	R0,LSCLKS+LSCVRX,RLSC,	:SET VR VALUE TO 0
	STB	R0,LSCLKS+LSCVSX,RLSC,	:SET VS VALUE TO 0
	JR	R5			:RETURN


:	ROUTINE TO CLEAR NR , NS AND VSU
:	--------------------------------
:	INPUT: RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT: LSCNRR, LSCNSR, LSCVSU CLEARED
:	DESTROYED: R0
CLRNSR	
	LIS	R0,0
	STB	R0,LSCLKS+LSCNRR,RLSC,	:SET NR VALUE TO 0
	STB	R0,LSCLKS+LSCVSU,RLSC,	:SET UNACK VS TO 0
	STB	R0,LSCLKS+LSCNSR,RLSC,	:SET NS VALUE TO 0
	JR	R5			:RETURN


:	ROUTINE TO INC. IC, IC=IC+V(S)-N(R)
:	------------------------------------
:	INPUT:	LSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LSCRXC = V(S)-N(R), RE-XMT COUNT
:		IC = IC + LSCRXC
:	DESTROYED: R0, R1
INCIC	
	LB	R0,LSCLKS+LSCVSX,RLSC,	:GET V(S) VALUE
	LB	R1,LSCLKS+LSCNRR,RLSC,	:GET N(R) VALUE
	SR	R0,R1			:CALCULATE IC=IC+V(S)-N(R)
	AHI	R0,MODUL8		:ADD SEQUENCE NUMBER TO MODULE IT
	NHI	R0,FMMSK		:WRAP AROUND FOR WINDOW SIZE
	IF	DEBUG
	JNFS	INCIC1			:IF NOT ALL ACK'ED, SKIP
	EI	DEBUG
	AHM	R0,LSCLKS+LSCIFC,RLSC,	:STORE NEW IC VALUE
	LB	R1,LSCLKS+LSCRXC,RLSC,	:RE-XMT COUNT =RE-XMT COUNT + V(S)-N(R)
:					(10/10/85/CHS)
	AR	R0,R1			:(10/10/85/CHS)
	STB	R0,LSCLKS+LSCRXC,RLSC,	:(101/10/85/CHS)
	JR	R5			:RETURN
	IF	DEBUG
INCIC1
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
	EI	(DEBUG)

:	ROUTINE TO DECREMENT IC VALUE
:	-----------------------------
:	INPUT:	LSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	IC = IC - 1
:		IF IC < 0, CRASH
:	DESTROYED: R0
DECIC	
	LCS	R0,1			:DECREMENT IC BY 1
	AHM	R0,LSCLKS+LSCIFC,RLSC,
	JGER	R5
	JAL	R10,CRASH,,		:CRASH IF IC<0
	BC	0,0,0,0FF


:	DECRXC	:DECREMENT RE-XMT CNT LSCRXC BY 1
:	--------------------------------------------
:	INPUT:	RSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	R0 = THE CURRENCT LSCRXC
:		CRASH, IF LESS THAN 0

DECRXC
	LB	R0,LSCLKS+LSCRXC,RLSC,	:GET LSCRXC
	JLE	DECRX1			:RE-XMT CNT=0,CRASH
	SIS	R0,1
	STB	R0,LSCLKS+LSCRXC,RLSC,	:UPDATE RE-XMT CNT
	JR	R5			:RETURN
DECRX1	JAL	R10,CRASH,,
	BC	0,0,0,0FF


:	ROUTINE TO GET DIFF=V(S)-VSU
:	-----------------------------
:	INPUT: RLSC, RLCB SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	R1 = DIFF = V(S)-VSU
:		R0 = VSU
:		R6 = MAX. WINDOW SIZE
GETDIF	
	LB	R1,LSCLKS+LSCVSX,RLSC,	:GET VS VALUE
	LB	R0,LSCLKS+LSCVSU,RLSC,	:GET VSU VALUE
	LB	R6,LCBTAB+LCBMWD,RLCB,	:GET WINDOW SIZE
	CR	R1,R0			:COMPARE VS AND VSU
	JGE	GETDI2			:VS>=VSU JUMP
	AIS	R1,FMMSK+1		:ADD MODULO TO VS(5/17/85/CHS)
GETDI2
	SR	R1,R0			:SUBTRACT VSU
	NHI	R1,FMMSK		:MASK OFF UNUSED BITS (WINDOW)
	JR	R5			:RETURN


:	CLRIBA:	ROUTINE TO CLEAR RCV'ING BB CHAIN AND BYTE COUNT 
:	------
:	INPUT: RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT: LSCRHP, LSCRCN CLEARED
:	DESTROYED : R0
CLRIBA
	LIS	R0,0			:CLEAR LSC BUFFER CHAIN & CNT
	BBST	R0,LSCLKS+LSCRHP,RLSC,	:CLEAR BUFFER POINTER 
	STH	R0,LSCLKS+LSCRCN,RLSC,	:ZERO INPUT CHAR CNT   
	JR	R5

:*******************************************************:
:							:
:	SET UP LINK LEVEL TIMERS IN LSC			:
:							:
:*******************************************************:


:	ROUTINE TO SET UP POLLING TIMER
:	-------------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LSCRT1 = FASTC + TPO.LN
:	DESTROYED: R0
SETTPO
	LHL	R0,TPO.LN,RL2,		:GET POLLING RESPONSE TIMER
	JEFS	SETTP1			:NO TIMER, SKIP
	SLLS	R0,TSCALE		:SCALE
	A	R0,FASTC,,		:CALCULATE REAL TIME
SETTP1
	ST	R0,LSCLKS+LSCRT1,RLSC,	:PUT INTO LSC
	JR	R5			:RETURN


:	ROUTINE TO SET UP RECEIVE RESPONSE TIMER
:	----------------------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LSCRT1 = FASTC + T1.LN
:	DESTROYED: R0
SETRT1
	LHL	R0,T1.LN,RL,RL		:GET RECEIVE RESPONSE TIMER
	JEFS	SETRT2			:NO TIMER, SKIP
	SLLS	R0,TSCALE		:SCALE
	A	R0,FASTC,,		:CALCULATE REAL TIME
SETRT2
	ST	R0,LSCLKS+LSCRT1,RLSC,	:PUT INTO LSC
	JR	R5			:RETURN


:	ROUTINE TO SET UP RR/RR IDLE TIMER
:	----------------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT: LSCXTT = FASTC + TRR.LN
:	DESTROYED: R0
SETTRR
	LHL	R0,TRR.LN,RL2,		:GET RR/RR IDLE TIMER
	JEFS	SETTR1			:NO TIMER, SKIP
	SLLS	R0,TSCALE		:SCALE
	A	R0,FASTC,,		:CALCULATE REAL TIME
SETTR1
	ST	R0,LSCLKS+LSCXTT,RLSC,	:PUT INTO LSC
	JR	R5			:RETURN


:	ROUTINE TO SET UP RCV TO XMT TURN AROUND TIMER
:	----------------------------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLCB SET UP
:		R5 = LINK REGISTER
:	OUTPUT: LCBXTM = FASTC + TRX.LN
:	DESTROYED: R0
SETTRX
	LHL	R0,TRX.LN,RL2,		:GET LINE TURN AROUND TIMER
	JEFS	SETRX1			:NO TIMER, SKIP
	SLLS	R0,TSCALE		:SCALE
	A	R0,FASTC,,		:CALCULATE REAL TIME
SETRX1
	ST	R0,LCBTAB+LCBXTM,RLCB,	:PUT INTO LCB
	JR	R5			:RETURN


:	ROUTINE TO SET UP XMT NETWORK RESPONSE TIMER
:	--------------------------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LSCXTT = FASTC + T1.LN
:	DESTROYED: R0
SETXT1
	LHL	R0,T1.LN,RL2,		:GET XMT NETWORK RESPONSE TIMER
	JEFS	SETXT2			:NO TIMER, SKIP
	SLLS	R0,TSCALE		:SCALE
	A	R0,FASTC,,		:CALCULATE REAL TIME
SETXT2
	ST	R0,LSCLKS+LSCXTT,RLSC,	:PUT INTO LSC
	JR	R5			:RETURN


:*******************************************************:
:							:
:	RESET LINK LEVEL TIMERS IN LSC			:
:							:
:*******************************************************:


:	ROUTINE TO RESET T1 TIMER
:	-------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LSCRT1 TO 0
:	DESTROYED: R0
CLRRT1
	LIS	R0,0			:SET R0 TO 0
	ST	R0,LSCLKS+LSCRT1,RLSC,	:PUT INTO LSC
	JR	R5			:RETURN


:	ROUTINE TO RESET XT1 TIMER
:	--------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LSCXTT TO 0
:	DESTROYED: R0
CLRXT1
	LIS	R0,0			:SET R0 TO 0
	ST	R0,LSCLKS+LSCXTT,RLSC,	:PUT INTO LSC
	JR	R5			:RETURN

:	ROUTINE TO RESET TRR TIMER
:	--------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	LSCXTT TO 0
:	DESTROYED: R0
CLRTRR
	LIS	R0,0			:SET R0 TO 0
	ST	R0,LSCLKS+LSCXTT,RLSC,	:PUT INTO LSC
	JR	R5			:RETURN


:*******************************************************:
:							:
:	CHECK LINK LEVEL TIMERS IN LSC			:
:							:
:*******************************************************:
:	ROUTINE TO CHECK TRR TIMER
:	-------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	NORMAL RETURN IF TRR NOT EXPIRED
:		SKIP RETURN, IF TRR EXPIRED
:	DESTROYED: R0
CHKTRR
	L	R0,LSCLKS+LSCXTT,RLSC,	:GET LSCXTT
	JE	4,R5			:NO TIMER, SKIP RETURN
	CL	R0,FASTC,,		:TIME EXPIRED?
	JGR	R5			:NO, RETURN
	J	4,R5			:SKIP RETURN, TIMER EXPIRED

:	ROUTINE TO CHECK RT1 TIMER
:	-------------------------
:	INPUT:	RL2 = LINE# * 2
:		RLSC SET UP
:		R5 = LINK REGISTER
:	OUTPUT:	NORMAL RETURN IF RT1 NOT EXPIRED
:		SKIP RETURN, IF RT1 EXPIRED
:	DESTROYED: R0
CHKRT1
	L	R0,LSCLKS+LSCRT1,RLSC,	:GET LSCXTT
	JE	4,R5			:NO TIMER, SKIP RETURN
	CL	R0,FASTC,,		:TIME EXPIRED?
	JGR	R5			:NO, RETURN
	J	4,R5			:SKIP RETURN, TIMER EXPIRED

	SUBTTL (SFGPTP) COMMAND LIST HANDLING ROUTINES


:*******************************************************:
:							:
:	ROUTINES TO HANDLE MESSAGE TRANSFER BETWEEN	:
:	FOREGROUND AND BACKGROUND			:
:							:
:*******************************************************:

:	QUEINF:	ROUTINE TO QUEUE INF CMD TO RCV QUEUE
:	-------
:	INPUT:	RLSC, RLCB, LSCRCN AND LSCRHP SET UP
QUEINF
	ST	R5,RTRN,RL2,RL2		:PRESERVE LINK ADDRESS
	LIS	R1,CDATA		:QLLC DATA CMD/RSP CODE
	LHL	R2,LSCLKS+LSCRCN,RLSC,	:GET DATA LENGTH
	BBL	R3,LSCLKS+LSCRHP,RLSC,	:GET DATA CHAIN HEAD
	JAL	R5,QUERCV		:QUEUE INF CMD/RSP TO RCV QUEUE
	JAL	R5,CLRIBA		:CLEAR LSCRHP, LSCRCN, LSCRST
	L	R5,RTRN,RL2,RL2		:RESTORE R5
	JR	R5			:RETURN

:	QUEETE:	ROUTINE TO QUEUE SPECIAL NON-DATA CMD TO RCV QUEUE
:	-------
:	INPUT:	RLSC, RLCB PSET UP
:		R1 = QLLC SUB COMMAND CODE(XID/TEST/FRMR)
QUEETE
	ST	R5,RTRN,RL2,RL2		:PRESERVE LINK ADDRESS
	LHL	R2,LSCLKS+LSCRCN,RLSC,	:GET DATA LENGTH
	BBL	R3,LSCLKS+LSCRHP,RLSC,	:GET DATA CHAIN HEAD
	JAL	R5,QUERCV		:QUEUE INF CMD/RSP TO RCV QUEUE
	JAL	R5,CLRIBA		:CLEAR LSCRHP, LSCRCN, LSCRST
	L	R5,RTRN,RL2,RL2		:RESTORE R5
	JR	R5			:RETURN

:	QUESTA:	ROUTINE QUEUE A STATUS CMD TO RCV QUEUE
:	-------
:	INPUT:	RLSC , RLCB SET UP
:		R2 = 1ST AND 2ND STATUS SUB-CODE
:		R3 = 3RD AND 4TH STATUS SUB-CODE
QUESTA
	ST	R5,RTRN,RL2,RL2		:SAVE CALLING ADDRESS
	LIS	R1,CSTATE		:STATUS CC
	JAL	R5,QUERCV		:QUEUE IT
	L	R5,RTRN,RL2,RL2		:RESTORE CALLING ADDRESS
	JR	R5			:RETURN

:	QUECMD:	ROUTINE TO QUEUE NON-DATA CMD TO RCV QUEUE
:	------
:	INPUT:	RLSC, RLCB SET UP
:		R1 = QLLC SUB CC
QUECMD
	LIS	R3,0			:NO BUFFER
	LIS	R2,0			:LENGTH = 0

:	ROUTINE TO QUEUE CMD/INF TO RCV QUEUE
:	INPUT:	R1 = QLLC SUB COMMAND CODE
:		R2 = 2-BYTE DATA LENGTH, OR
:		   = ADDR + 1-BYTE DATA LENGTH
:		R3 = 0 / SUB STATUS CODES/  BB CHAIN HEAD
QUERCV
	OHI	R1,DLCLNK^8		:INCLUDE CCC CODE
	PUTCMD(RCV,RLSC)

	IF	FDEBUG
	TBT	RL,TRFBLN		:F-T-B TRACING?
	JEFS	QUERC1			:NO, SKIP
	JAL	R4,TRSBUG		:DEBUG TRACING
QUERC1
	EI

	RLCMD(RCV,RLSC,RLCB)
	JR	R5			:RETURN

:
:	ROUTINE TO PEEK THE COMMAND CODE IN THE XMT QUEUE
:	----------------------------------------------------------
:	EXPECT:	RLCB AND RLSC PROPERLY SET UP.
:	OUTPUT:
:		R1  = QLLC SUB COMMAND CODE (I.E. XMT OP CODE)
:		R2  = 2-BYTE LENGTH/ ADDR + 1-BYTE LENGTH/ SUB STATUS CODES
:		R3  = CMD DATA BUFFER POINTER/ SUB STATUS CODES
PKXMTQ
	LIS	R1,0			:ASSUME RE-XMT
	LB	R3,LSCLKS+LSCRXC,RLSC,	:RXC CNT > 0 ?
	LR	R3,R3			:
	JGR	R5			:RE-XMT, EXIT
	LCS	R1,1			:INIT R1 TO -1, (OR = NON-CMD QUEUED)
	LB	R0,LSCLKS+LSCRID,RLSC,	:GET RELATIVE STATION #
	TBT	R0,LCBTAB+LDAXMT,RLCB,	:TEST TO SEE XMT BIT ARRAY SET OR NOT
	JER	R5			:EXIT, NO CMD QUEUED R1 = -1
	LHL	RARG,LSCLKS+SGPXMT,RLSC, :GET THE CMD ADDR
:	CLH	RARG,LSCLKS+SRPXMT,RLSC, :ANY CMD QUED? (01/09/85 MIA)
	LHL	R3,LSCLKS+SRPXMT,RLSC, :GET REL PTR (01/09/85 MIA)
	CR	RARG,R3			:ANY CMD QUED? (01/09/85 MIA)
	JN	PKXMT1			:IF GP NOT = RP, CMD QUEUED, SKIP
	JAL	R10,CRASH,,		:ELSE, CRASH, PROGRAMMING ERROR
	BC	0,0,0,088
PKXMT1
	BBL	R3,CMDBLK+CLARG,RARG,	:R3 = BUFFER CHAIN HEAD
	LB	R1,CMDBLK+CLCMDS,RARG,	:R1 = QLLC SUB COMMAND CODE
	LHL	R2,CMDBLK+CLLNG,RARG,	:R2 = DATA LENGTH
	JR	R5			:AND EXIT


:	ROUTINE TO FETCH CMD FROM XMT QUEUE
:	-------------------------------------
:	INPUT:	RLSC, RLCB SET UP
:		RL, RL2 = LINE #, LINE # * 2
:	OUTPUT:
:		LSCXCN, LSCXHP SET UP
:			R1 = QLLC SUB CC (XMT OP CODE)
:			R2 = 2-BYTE LENGTH/ ADDR + 1-BYTE LENGTH/ SUB STATUS 
:			R3 = DATA BUFFER PTR
FHXMTQ
	LIS	R1,0			:ASSUME RE-XMT
	LB	R3,LSCLKS+LSCRXC,RLSC,	:
	LR	R3,R3
	JGR	R5			:RE-XMT , EXIT
	ST	R5,RTRN,RL2,RL2		:PRESERVE LINK ADDRESS
	LHL	RARG,LSCLKS+SGPXMT,RLSC, :GET GET PTR
:	CLH	RARG,LSCLKS+SRPXMT,RLSC, :COMP GT TO RP (01/09/85 MIA)
	LHL	R3,LSCLKS+SRPXMT,RLSC,	:GET REL PTR (01/09/85 MIA)
	CR	RARG,R3			:COMPARE PTR (01/09/85 MIA)
	JNFS	FHXMT1			:GP NOT = RP, XMT CMD QUEUED, SKIP
	JAL	R10,CRASH,,		:PROGRAMMING ERROR
	BC	0,0,0,0FF
FHXMT1
	BBL	R3,CMDBLK+CLARG,RARG,	:GET BUFFER PTR
	LB	R1,CMDBLK+CLCMDS,RARG,	:GET QLLC SUB CC
	LHL	R2,CMDBLK+CLLNG,RARG,	:GET THE DATA LENGTH
	ADVCMD(XMT,RLSC,RLCB)		:UPDATE GP & BIT ARRAY

	IF	FDEBUG
	TBT	RL,TRBFLN		:B-T-F TRACING?
	JEFS	FHXMT3			:NO, SKIP
	L	R5,RTRN,RL2,RL2		:FETCH CALLING ADDRESS
	JAL	R4,TRSBUG		:DEBUG TRACING
FHXMT3
	EI
	CLHI	R1,CDATA		:DATA CMD/RSP?
	JE	FHXMTX			:YES, DATA, SKIP
	CLHI	R1,CSTATE		:ILLEGAL QLLC SUB CODE?
	JG	FHXMT6			:YES,GO TO CRASH
FHXMT4
	NHI	R2,0FF			:ASSUME XID/TEST/FRMR < 256 BYTES
FHXMTX
	STH	R2,LSCLKS+LSCXCN,RLSC,	:PUT XMT BYTE CNT INTO LSC
	BBST	R3,LSCLKS+LSCXHP,RLSC,	:PUT DATA BUFFER PTR INTO LSC
FHXMT5
	L	R5,RTRN,RL2,RL2		:RESTORE RETURN ADDRESS
	JR	R5			:RETURN
FHXMT6
	JAL	R10,CRASH,,		:CRASH NOW
	BC	0,0,0,088


:	DQXMTQ:	ROUTINE TO DEQUEUE CURRENT XMT CMD FROM XMT QUEUE
:	-----
:	OUTPUT:
:		THE 1ST XMT CMD IS DELETED FROM THE XMT QUEUE
:		IF CMD WITH DATA, THE DATA BB ALSO RELEASED
DQXMTQ
	ST	R5,RTRN,RL2,RL2		:RESERVE LINK ADDRESS 
	LB	R0,LSCLKS+LSCRID,RLSC,	:GET THE REL #
	TBT	R0,LCBTAB+LDAXMT,RLCB,	:XMT BIT ON?
	JER	R5			:NO, JUST EXIT
	LHL	RARG,LSCLKS+SGPXMT,RLSC, :GET GET PTR
:	CLH	RARG,LSCLKS+SRPXMT,RLSC, :COMP GT TO RP (01/09/85 MIA)
	LHL	R3,LSCLKS+SRPXMT,RLSC,	:GET REL PTR (01/09/85 MIA)
	CR	RARG,R3			:COMPARE PTR (01/09/85 MIA)
	JN	DQXMT1			:GP NOT = RP, CMD QUEUED
	JAL	R10,CRASH,,		:ELSE, PROGRAMMING ERROR
	BC	0,0,0,0FF

DQXMT1
	BBL	R3,CMDBLK+CLARG,RARG,	:GET BUFFER PTR
:	LHL	R2,CMDBLK+CLCMDS,RARG,	:GET COMMAND CODE(6/20/85/CHS)
	LB	R1,CMDBLK+CLCMDS,RARG,	:GET COMMAND CODE(6/20/85/CHS)
	ADVCMD(XMT,RLSC,RLCB)		:UPDATE GP & BIT ARRAY

	IF	FDEBUG
	TBT	RL,TRBFLN		:B-T-F TRACING?
	JEFS	DQXMT2			:NO, SKIP
	L	R5,RTRN,RL2,RL2		:GET CALLING ADDRESS
	JAL	R4,TRSBUG		:DEBUG TRACING
DQXMT2
	EI

:	CLHI	R2,CDATA		:DATA?(6/20/85/CHS)
	CLHI	R1,CDATA		:DATA?(6/20/85/CHS)
	JGFS	DQXMT3			:IF NON-DATA, SKIP
	JAL	R5,DECIC		:ELSE, DATA, DECREASE IC BY 1
	JFS	DQXMT4
DQXMT3
:	CLHI	R2,CFRMR		:...(6/20/85/CHS)
	CLHI	R1,CFRMR		:...(6/20/85/CHS)
	JG	DQXMT5			:SKIP, NO DATA
DQXMT4
	LR	R3,R3			:ANY DTA BUFFER
	JE	DQXMT5			:NO, SKIP
	BBL	R5,BBUFER+BBFLSZ-BBFPSZ,R3, :GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE CURRENT BB
	LHL	R3,LSCLKS+LSCPUC,RLSC,	:R3 = PUC OFFSET
	LHL	R4,LNCPTR,RL,RL		:R4 = LNC OFFSET
	LIS	R0,1
	AHM	R0,PUCTAB+PUXBUS,R3,	:UPDATE THE XMT BB USAGE IN PUC
	AHM	R0,LNCTAB+LNXBUS,R4,	:UPDATE THE XMT BB USAGE IN LNC
	LR	R3,R5			:MOVE NEW BB ADDR TO R3, AND MORE?
	JN	DQXMT4			:YES, MORE, CONTINUE
DQXMT5
	L	R5,RTRN,RL2,RL2		:RESTORE LINK ADDR
	JR	R5			:SKIP RETURN, DEQUEUE SUCCESS


:	FHCMDQ:	ROUTINE TO FETCH CMD FROM CMD QUEUE
:	-------
:	INPUT:	RLSC, RLCB SET UP
:		RL, RL2 = LINE #, LINE # * 2
:	OUTPUT:
:			R1 = SDLC CONTROL SUB CC
:			R2 = RESERVED
:			R3 = RESERVED
FHCMDQ
	ST	R5,RTRN,RL2,RL2		:PRESERVE LINK ADDRESS
	LHL	RARG,LSCLKS+SGPCMD,RLSC, :GET GET PTR
:	CLH	RARG,LSCLKS+SRPCMD,RLSC, :COMPARE GET PTR TO RP (01/09/85 MIA)
	LHL	R3,LSCLKS+SRPCMD,RLSC,	:GET RELEASE PTR (01/09/85 MIA)
	CR	RARG,R3			:COMPARE POINTERS (01/09/85 MIA)
	JNFS	FHCMD1			:GP NOT = RP, CMD IN CMD Q, SKIP
	JAL	R10,CRASH,,		:PROGRAMMING ERROR
	BC	0,0,0,0FF
FHCMD1
:	BBL	R3,CMDBLK+CLARG,RARG,	:GET CLARG DATA
	LB	R1,CMDBLK+CLCMDS,RARG,	:GET SDLC CONTROL SUB CC
:	LHL	R2,CMDBLK+CLLNG,RARG,	:GET CLLNG DATA
	ADVCMD(CMD,RLSC,RLCB)		:UPDATE GP & BIT ARRAY

	IF	FDEBUG
	TBT	RL,TRBFLN		:B-T-F TRACING?
	JEFS	FHCMD3			:NO, SKIP
	L	R5,RTRN,RL2,RL2		:FETCH CALLING ADDRESS
	JAL	R4,TRSBUG		:DEBUG TRACING
FHCMD3
	EI
	CLHI	R1,INITCD		:ILLEGAL SUB CODE?
	JG	FHCMD4			:YES,GO TO CRASH
	L	R5,RTRN,RL2,RL2		:RESTORE RETURN ADDRESS
	JR	R5			:RETURN
FHCMD4
	JAL	R10,CRASH,,		:CRASH NOW
	BC	0,0,0,088


	SUBTTL (SFGPTP) MISCELLANEOUS ROUTINES


:	GETLSC:	ROUTINE TO SET UP RLSC TO THE LSC ADDR
:	------
:	INPUT:	R2 = REL # OF THIS LKS ON THIS LINK
:		R5 = LINK REGISTER
:	OUTPUT: RLSC SET UP (RLSC CONTAINS THE LSC ADDR)
:	DESTROYED: R3, R4, R6
GETLSC
	LHL	R4,LNCPTR,RL,RL		:GET LNCTAB 1ST
	LHL	R4,LNCTAB+LNPUTB,R4,	:GET THE 1ST PUCTAB ON THIS LINK
	LHI	R6,PUCLEN		:LENGTH OF THE CUCTAB
	LR	R3,R2			:MOVE REL # INTO R3
	MHR	R3,R6			:CALCULATE REL OFFSET OF THIS LKS ENTRY
	AR	R3,R4			:CALCULATE TO GET THIS LKS PUCTAB
	LHL	RLSC,PUCTAB+PUCLSC,R3,	:GET LSC ADDRESS
	JR	R5			:RETURN

:	QSIORV:	TO QUEUE SIO RCV'ED FRAME INTO LSC
:	------
:	INPUT:	RLSC, RLCB, LCBRCN, LCBRHP SET UP
QSIORV
	ST	R5,RTRN,RL2,RL2		:PRESERVE LINK
	BBL	R3,LCBTAB+LCBRHP,RLCB,	:GET DATA CHAIN ADDRESS
	LHL	R2,LCBTAB+LCBRCN,RLCB,	:GET DATA LENGTH
	PUTCMD(SIO,RLSC)
	LHL	RARG,LSCLKS+SPPSIO,RLSC, :SET REL PTR = PUT PTR
	STH	RARG,LSCLKS+SRPSIO,RLSC,
	L	R5,RTRN,RL2,RL2
	JR	R5

:	FLSIOQ:	ROUTINE TO FLUSH CURRENT SIO CMDS FROM SIO QUEUE
:	-----
:	OUTPUT:
:		ALL THE SIO CMDS ARE DELETED FROM THE SIO QUEUE
:		IF CMD WITH DATA, THE DATA BB ALSO RELEASED
FLSIOQ
	ST	R5,RTRN,RL2,RL2		:RESERVE LINK ADDRESS 
FLSIO1
	LHL	RARG,LSCLKS+SGPSIO,RLSC, :GET GET PTR
:	CLH	RARG,LSCLKS+SRPSIO,RLSC, :COMP GT TO RP (01/09/85 MIA)
	LHL	R3,LSCLKS+SRPSIO,RLSC,	:GET REL PTR (01/09/85 MIA)
	CR	RARG,R3			:COMPARE PTR (01/09/85 MIA)
	JE	FLSIO3			:ALL DELETED, SKIP
	BBL	R3,CMDBLK+CLARG,RARG,	:GET BUFFER PTR
	LHL	RWORK,CMDBLK+CLPTR,RARG, :ADVANCE CMD
	JE	CLERR			:CRASH IF ADVANCE AN EMPTY LIST
	STH	RWORK,LSCLKS+SGPSIO,RLSC, :ADVANCE
	JAL	RLNK,RELCL		:RELEASE CMD-ELEMENT
FLSIO2
	LR	R3,R3			:ANY DTA BUFFER
	JE	FLSIO1			:NO, SKIP TO CHECK NEXT CMD-E
	BBL	R5,BBUFER+BBFLSZ-BBFPSZ,R3, :GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE CURRENT BB
	LHL	R3,LSCLKS+LSCPUC,RLSC,	:R3 = PUC OFFSET
	LHL	R4,LNCPTR,RL,RL		:R4 = LNC OFSET
	LIS	R0,1
	AHM	R0,PUCTAB+PURBUS,R3,	:UPDATE THE RCV BB USAGE IN PUC
	AHM	R0,LNCTAB+LNRBUS,R4,	:UPDATE THE RCV BB USAGE IN LNC
	LR	R3,R5			:MOVE NEW BB ADDR TO R3
	J	FLSIO2			:REPEAT
FLSIO3
	L	R5,RTRN,RL2,RL2		:RESTORE LINK ADDR
	JR	R5			:SKIP RETURN, DEQUEUE SUCCESS

:	IDELET:	ROUTINE TO DISCARD RCV'ED SIO FRAME
:	------
:	INPUT: RL, RL2
:	OUTPUT:	LSCRHP, LSCRCN, AND LSCRST CLEARED
IDELET
	ST	R5,RTRN,RL2,RL2		:PRESERVE LINK ADDRESS
	BBL	R3,LSCLKS+LSCRHP,RLSC,	:GET BB HEAD PTR
	JE	IDELE2			:NO, SKIP
IDELE1
	BBL	R5,BBUFER+BBFLSZ-BBFPSZ,R3, :GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE CURRENT BB
	LHL	R3,LSCLKS+LSCPUC,RLSC,	:R3 = PUC OFFSET
	LHL	R4,LNCPTR,RL,RL		:R4 = LNC OFFSET
	LIS	R0,1
	AHM	R0,PUCTAB+PURBUS,R3,	:INCREASE BB USAGE BY 1 IN PUC
	AHM	R0,LNCTAB+LNRBUS,R4,	:INCREASE BB USAGE BY 1 IN LNC
	LR	R3,R5			:NEXT BB ADDR TO R3, AND SEE IF MORE?
	JN	IDELE1			:MORE, LOOP
IDELE2
	JAL	R5,CLRIBA		:CLEAR LSCRHP, LSCRCN, LSCRST
	L	R5,RTRN,RL2,RL2		:RESTORE RETURN ADDRESS
	JR	R5			:RETURN

	IF	FDEBUG
:	TRSBUG:	ROUTINE TO RECORD THE CMD, BUFFER, ETC.
:	------------------------------------------------
:	R4:	LINK REGISTER
:	R5:	PROTOCOL RETURN ADDRESS
:	DESTROYED:	R10
TRSBUG
	LHL	R10,TRSBFP		:GET DEBUG TRACE BUFFER INDEX
	TBT	RL,TRSTLN		:GMT TIME STAMP?
	JEFS	TRSBU1			:NO, SKIP
	L	R0,GMT,,		:GET GMT
	ST	R0,TRSBUF,R10		:SAVE GMT
	AIS	R10,4			:UPDATE PTR
TRSBU1
	STH	R5,TRSBFP,R10,		:SAVE PROTOCOL CALLING ADDRESS
	STH	R1,TRSBUF+2,R10,	:STORE QLLC SUB CC
	STH	R3,TRSBUF+4,R10,	:STORE CMD BUFFER HEAD ADDRESS
	STH	R6,TRSBUF+6,R10,	:STORE CMD LINK PTR
	AIS	R10,8			:INCREASE INDEX PTR
	CLHI	R10,TRSBFS		:WRAP AROUND?
	JLFS	TRSBU2			:NO, SKIP
	LIS	R10,0			:ELSE, RESET INDEX PTR
TRSBU2
	STH	R10,TRSBFP		:UPDATE NEW TRACE INDEX PTR
	JR	R4			:RETURN
	EI	(FDEBUG)

:	DLTSEC:	ROUTINE TO DELETE ENTRY IN SECTOR DATA BUFFER BASE
:	------
:	INPUT:	 RL, RL2
:		LSC SET UP, R0 = INDEX
DLTSEC
	STM	R0,FSUBSV,,
	LHL	R6,SEDBIA,R4,R4
	LR	R5,R0
	AR	R5,R5
	IF	FWBBF			:(11/25/84 MIA)
	AR	R5,R0
	EI				:(11/25/84 MIA)
	SLHLS	R5,1
	LIS	R0,0
	STH	R0,SECBAS,R6,R5
	BBL	R3,SECBAS+2,R6,R5
	BBST	R0,SECBAS+2,R6,R5
DLTSE1
	LR	R3,R3			:ANY?
	JE	DLTSE2
	BBL	R5,BBUFER+BBFLSZ-BBFPSZ,R3,
	JAL	R4,PBB,,
	LHL	R3,LSCLKS+LSCPUC,RLSC,
	LHL	R4,LNCPTR,RL,RL
	LIS	R0,1
	AHM	R0,PUCTAB+PUXBUS,R3,
	AHM	R0,LNCTAB+LNXBUS,R4,
	LR	R3,R5
	J	DLTSE1
DLTSE2
	LM	R0,FSUBSV,,
	JR	R6

:	RSTSEC:	RESET SECTOR DATA BUFFER BASE
:	------
RSTSEC
	LB	R4,LSCLKS+LSCT.N,RLSC,
	LIS	R0,0			:START FROM 0
	STB	R0,LSCLKS+LSCRXC,RLSC,	:BUT CLEAR RE-XMT COUNT(4/12/85/CHS)
RSTSE1
	RBT	R0,SECBLT,R4,R4
	JEFS	RSTSE2			:SECTOR NOT BUILT, SKIP
	JAL	R6,DLTSEC
RSTSE2
	AIS	R0,1
	CLHI	R0,8
	JLBS	RSTSE1
	JR	R5
	

	FO	MAIN
	FO	GBLDEF
	FO	CMDLST
	FO	FGGBDF
	FO	SNAEXC


	EM
 	SUBTTL	(SNA/SDLC) SIO RECEIVER - SFGRCV
:FRCV00.F00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	RA	0
	MO	.,SFGRCV


	LO	GBLDEF
	LO	FGGBDF
	LO	SNAEXC
	LO	MAIN
	LO	SFGPTP


:
:	THIS SIO FOREGROUND RECEIVER HAS BEEN TOTALLY RE-DESGINED, IT IS
:	NO LONGER COMPITABLE WITH SDLC INTERFACE'S SIO RECEIVER
:	(03/20/84/CHS)


:	RECEIVE RETURN CODE
:	-------------------
:
RCNODA	EQ	0		:NON-DATA
RCINF	EQ	1		:INF. FRAME RECEIVED
RCSNRM	EQ	2		:SNRM RECEIVED
RCUA	EQ	3		:UA RECEIVED
RCDISC	EQ	4		:DISC RECEIVED
RCDM	EQ	5		:DM RECEIVED
RCRD	EQ	RCDISC		:RD RECEIVED
RCSIM	EQ	6		:SIM RECEIVED
RCRIM	EQ	RCSIM		:RIM RECEIVED
RCXID	EQ	7		:XID RECEIVED
RCTEST	EQ	8		:TEST RECEIVED
RCFRMR	EQ	9		:FRMR RECEIVED
RCRR	EQ	0A		:RR RECEIVED
RCRNR	EQ	0B		:RNR RECEIVED
RCREJ	EQ	0C		:REJ RECEIVED
RCCTL	EQ	0D		:UN RECOGNIZED 'C' FIELD
RCIPHB	EQ	0E		:I-FIELD PROHIBITED
RCOVRN	EQ	0F		:RCV'ED FRAME TOO LONG
RCLNG	EQ	10		:RCV'ED FRAME TOO SHORT
RCADRU	EQ	11		:UN-CONFIGURED LKS ADDR RCV'ED
RCADRD	EQ	12		:UN-INTENDED LKS ADDR RCV'ED
RCLOST	EQ	13		:LOST DATA BECAUSE OF INAVAIL. BUFFERLET
RCTMOT	EQ	14		:TIMEOUT BEFORE MESSAGE RECEIVED
RCMAXI	EQ	RCTMOT		:MAXI VALUE OF THE RC CODE


:	DEFINE LOCAL SYMBOLS
:	--------------------
RC	EQ	R5		:RCV OP COMPLETE CODE


:	DEFINE LOCAL STORAGES
:	---------------------
	SEG	A.DATA
RCVCNT	HS	NLINES			:RCV BYTE COUNT
RCVADR	BS	NLINES			:RCV ADDRESS
RCVCTL	BS	NLINES			:RCV C-FIELD
RCVRTC	BS	NLINES			:RCV CODE


	SUBTTL	SDLC LINK LEVEL RECEIVER - RECEIVING PROCESS


:	Algorithm for SIO Receive Module ----
:	(1.) Get Line Control Table (Block) according to Line number.
:	(2.) Check SIO input ring, any data in the ring?
:	(3.) Queue the frame.
:	(4.) Decide this link is half-duplex or full-duplex.


:	REGISTER CONVENTIONS:
:	---------------------
:	(R0) ---> NO. OF BYTES IN FRAME
:	(R1) ---> INCOMING FRAME CONTROL FIELD
:	(R2) ---> BYTE INDEX FOR RBUF DATA
:	(R5) ---> LINK REGISTER
:	RBBA ---> R7  FOR BUFFERLET BASE ADDRESS
:	RBBX ---> R4  FOR BUFFERLET PTR
:	RL   ---> R08 FOR CURRENT LINE NUMBER
:	RL2  ---> R09 FOR 2*LINENUMBER
:	RLCB ---> R11 FOR LCB PTR
:	RLSC ---> R12 FOR LSC PTR
:	RSIO ---> R13 FOR SIO TABLE PURPOSE


:	OUTPUT REGISTER CONVENTION:
:	------------------------------
:	RC   ---> STORE RETURN CODE (R5)
	SEG	A.CODE


:	RSTATR: RECEIVE PROCESS ENTRY POINT
:	-----------------------------------
RSTART		
	L	RSIO,SIOTBL,RL2,RL2	:SET SIOTABLE BASE ADDRESS
	LHL	R2,RINDEX,RL,RL		:INDEX TO RECEIVE SIO
	LHL	RLCB,LCBPTR,RL,RL	:GET OFFSET OF LCB FROM LCBPTR
	LIS	R0,0
	STH	R0,RINBYT,RL,RL		:INITIAL RINBYT
	STH	R0,LCBTAB+LCBRCN,RLCB,
	BBST	R0,LCBTAB+LCBRHP,RLCB,	:(10/09/85/CHS)
	LH	R0,RBUF,R2,RSIO		:GET LENGTH OF SIO RCV FRAME
	JG	DATAIN			:GOT DATA
	JL	SRWAIT			:NO DATA, TO WAIT
	LHL	R2,RINDEX,RL,RL		:IF '00' ADVANCE TO NEXT HW
	AIS	R2,2
	LHL	R3,RBUFRM,RL,RL
	CR	R2,R3
	JLEFS	RSTAR0
	LIS	R2,0
RSTAR0
	STH	R2,RINDEX,RL,RL		:UPDATE NEW INDEX

:	NODATA		
:	------
SRWAIT
	JAL	R5,RDMISS		:DISMISS
	J	RSTART			:TO START RECEIVING


	SUBTTL	SDLC LINK LEVEL RECEIVER - INPUT FRAME PROCESSOR


DATAIN		
	STH	R0,RINBYT,RL,RL		:SAVE BYTE CNT FOR LATER
	LR	R2,R2			:GET RING INDEX USED
	JNFS	DATAI0			:JUMP,IF NOT FIRST ONE IN THE BUFFER
	LCS	R3,1			:CLR RCV BUF CNT PTR
	STH	R3,RBUF,R2,RSIO		:PUT "FFFF" INTO BYTE CNT
DATAI0
	AR	R2,RSIO			:CALCULATE ABSOLUTE ADDR
	AIS	R2,2			:ADVANCE POINTER TO ADDR FILED
	LB	R5,RBUF,R2		:GET "A" FIELD DATA
	STB	R5,RCVADR,RL,		:SAVE LOCALLY
	AIS	R2,1			:ADVANCE TO 'C' FIELD
	LB	R1,RBUF,R2		:GET 'C' FIELD BYTE
	STB	R1,RCVCTL,RL,		:SAVE LOCALLY
	STB	R1,LCBTAB+LCBCTL,RLCB,	:PUT INTO LCB
	LHL	R4,LNCPTR,RL,RL		:GET LNCTAB
	LB	R3,LNCTAB+LNMXPU,R4,	:GET TOTAL # OF PU'S
	LHL	R4,LNCTAB+LNPUTB,R4,	:GET 1ST PU TABLE ON THIS LINK
	LIS	RLSC,0			:INIT RLSC
	LIS	R6,0			:RELATIVE STATION CNT 
NXTLSC		
	LB	R7,PUCTAB+PUPLAD,R4,	:GET LKS POLLING ADDR
	CR	R5,R7			:RCV'ED 'A' THE SAME AS THIS LKS' ADDR?
	JE	FINDST			:YES, FOUND, SKIP
	CLHI	R5,0FF			:BROADCASTING ADDR 'FF'?
	JE	FINDST			:YES, ALWAYS GO TO 1ST STN
	AIS	R6,1			:ELSE, NEXT ONE
	CR	R6,R3			:ALL SEARCHED?
	JGE	ADDRER			:YES, RCV'ED UN-RECOGNIZED LKS FRAME
	AHI	R4,PUCLEN		:MOVE TO NEXT PU
	J	NXTLSC			:CONTINUE TO SERACH


:	FINDST:	SEARCH PUCTAB TO MATCH THE POLLING ADDRESS
:	---------------------------------------------------
FINDST		
	LHL	RLSC,PUCTAB+PUCLSC,R4,	:GET LSC ADDRESS
	STH	RLSC,LCBTAB+LCBC.R,RLCB, :UPDATE CURRENT RCV LSC
	CLHI	R0,2			:IS FRAME LENGHT  > 2 ?
	JL	RNGERR			:IF NOT, ILLEGAL FRAME
	CLH	R0,LCBTAB+LCBMFM,RLCB,	:IS RCV'ED FRAME TOO LONG?
	JG	RNGER1			:YES, ERROR
	SIS	R0,2			:LENGTH OF FRAME (NOT INC. A,C FIELD)
:	IDENTIFY THE RCV'ED FRAME TYPE
:	------------------------------
	LR	R4,R1
	SRHLS	R4,1			:NO CARRY, MUST BE A INF. FRAME
	JNC	INFORM			:NO CARRY, MUST BE A INF.
	LR	R6,R4
	NHI	R4,07			:ONLY 3-BIT NEEDED
	SRHLS	R6,4			:
	SLHLS	R6,3
	OR	R4,R6			:GET 6-BIT OF "C" FILED
	LB	RC,CFRCTB,R4		:FROM TABLE GET RC
	LHL	R6,CFPRTB,RC,RC		:AND GET CORRESPONDING PROCESS
	J	CFPRTB,R6		:TO PROCESS IT


:	"C" FILED DECISION TABLE
:	-----------------------
:	INDEXED BY 'C' FIELD VALUE BIT 1-3 AND BIT 5-7
:
CFRCTB	HS	0
	BC	RCRR,0,RCRNR,RCRIM	:RR,0,RNR,RIM
	BC	RCREJ,0,0,RCDM		:REJ,0,0,DM
	BC	RCRR,0,RCRNR,0		:RR,0,RNR,0
	BC	RCREJ,0,0,0		:REJ,0,0,0
	BC	RCRR,RCDISC,RCRNR,0	:RR,DISC/RD,RNR,0
	BC	RCREJ,0,0,0		:REJ,0,0,0
	BC	RCRR,RCUA,RCRNR,0	:RR,UA,RNR,0
	BC	RCREJ,0,0,0		:REJ,0,0,0
	BC	RCRR,RCSNRM,RCRNR,RCFRMR :RR,SNRM,RNR,FRMR
	BC	RCREJ,0,0,0		:REJ,0,0,0
	BC	RCRR,0,RCRNR,0		:RR,0,RNR,0
	BC	RCREJ,0,0,RCXID		:REJ,0,0,XID
	BC	RCRR,0,RCRNR,0		:RR,0,RNR,0
	BC	RCREJ,0,0,0		:REJ,0,0,0
	BC	RCRR,RCTEST,RCRNR,0	:RR,TEST,RNR,0
	BC	RCREJ,0,0,0		:REJ,0,0,0


:	"C" FILED PROCESSING TABLE
:	----------------------------
:	INDEXED BY THE 'RC' CODE
:
CFPRTB	HS	0
	HC	RCVILG-CFPRTB		:0  - ILLEGAL FRAME
	HC	RCVILG-CFPRTB		:1  - ILLEGAL FRAME (SHOULD NOT HAPPEN)
	HC	RCVUNB-CFPRTB		:2  - SNRM FRAME
	HC	RCVUNB-CFPRTB		:3  - UA FRAME
	HC	RCVUNB-CFPRTB		:4  - DISC/RD FRAME
	HC	RCVUNB-CFPRTB		:5  - DM FRAME
	HC	RCVUNB-CFPRTB		:6  - SIM/RIM FRAME
	HC	RCVCTD-CFPRTB		:7  - XID FRAME
	HC	RCVCTD-CFPRTB		:8  - TEST FRAME
	HC	RCVCTD-CFPRTB		:9 - FRMR FRAME
	HC	RCVSPV-CFPRTB		:0A  - RR FRAME
	HC	RCVSPV-CFPRTB		:0B - RNR FRAME
	HC	RCVSPV-CFPRTB		:0C - REJ FRAME

	SUBTTL	SDLC LINK LEVEL RECEIVER - PROCESSING ROUTINE

:	INFORM:	INFORMATION FRAME
:	----------------------------

:
:(1) FETCHS BUFFER FROM THE FREE BUFFER POLLS, R3  IS THE
:    BUFFER ADDRESS.
:(2) FETCHS ANOTHER BUFFER IF BYTES COUNT IS LARGER THAN
:    BUFFER SIZE, CHAINS NEW BUFFER TO PREVIOUS BUFFER.
:	      ------------------------------------------
:    R3  --> |	      DATA	     | NEXT BUFFER PTR |
:	      -----------------------------------------
:

INFORM		
	LHL	R7,LNCPTR,RL,RL		:GET LNC 
	LHL	R3,LNCTAB+LNIACT,R7,	:RESET LINK INACT TIMER
	JEFS	INFORX			:NO TIMER, SKIP
	A	R3,SLOWC,,
INFORX
	ST	R3,LNCTAB+LNITME,R7,	:...
	LIS	RC,RCINF		:RETURN CODE IS 'INF FRAME'
INFOR1
	AIS	R2,1			:MOVE INPUT FRAME POINTER TO 'I' FIELD
:	CALCULATE NUMBER OF BIG BUFFLET REQUIRED, IF O.K. THEN MOVE DATA
:		FROM SIO INPUT BUFFER TO BIG BUFFERLET, AND INCREASE RCV FRAME
:		COUNT BY 1
:	IF NOT ENOUGH BIG BUFFERLETS AVAILABLE, THEN SET RETURN CODE TO
:		DATA LOST DUE TO UNAVAILABLE BIG BUFFERLETS.
	LR	R3,R0			:MOVE 'I' FILED LENGTH TO R3
	LHI	R6,BBFLSZ-BBFPSZ	:LENGTH OF BIG BUFFERLET (NOT INCLUDE
					: THE CHAIN POINTER FIELD)
	DHR	R3,R6			:QUOTIENT IN R4
	LR	R3,R3			:REMAINDER IN R3
	JEFS	INFOR2			:IF NOT PARTIAL BB REQUIRED, SKIP
	AIS	R4,1			:PARTIAL BB COUNTED AS 1
INFOR2
	LHL	R7,LSCLKS+LSCPUC,RLSC,	:R7 = PUC OFFSET
	CLH	R4,PUCTAB+PURBUS,R7,	:ENOUGH BB ?
	JLEFS	INFOR3			:YES, SKIP
	LHI	RC,RCLOST		:ELSE, SET RETURN CODE TO DATA LOST
	J	RCVEND			:AND, EXIT TO RCVEND

INFOR3
:	IF LENGTH OF I-FIELD IS 0, THEN EXIT
	STH	R0,LCBTAB+LCBRCN,RLCB,	:STORE I-FIELD BYTE CNT TO RLCB
	LR	R0,R0			:NO I-FIELD ?
	JE	RCVEND			:YES, EXIT
:	UPDATE THE RCV BB QUOTA
	LIS	R3,0
	SR	R3,R4
	AHM	R3,PUCTAB+PURBUS,R7,	:UPDATE THE BB USAGE CNT IN PUC
	LHL	R7,LNCPTR,RL,RL		:R7 = LNC OFFSET
	AHM	R3,LNCTAB+LNRBUS,R7,	:UPDATE THE BB USAGE CNT IN LNC
	JAL	R4,GBB,,		:GET A BIG BUFFERLET
	J	NOBUF1			:SKIP TO CRASH, IF NO BB
	BBST	R3,LCBTAB+LCBRHP,RLCB,	:STORE 1ST BB ADDR TO HEAD CHAIN
	LR	RBBA,R3 		:SET BUFFERLET BASE ADDR REG
	LHI	RBBX,-BBFLSZ+BBFPSZ	:INIT BUFFERLET INDEX
:	MOVE DATA FROM SIO INPUT RING TO BUFFERLET
INFOR4
	LB	R4,RBUF,R2		:GET A CHARACTER
	STB	R4,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA
					:STORE CHARACTER IN BUFFERLET
	SIS	R0,1			:MORE DATA?
	JLE	INFOR5			:NO, END OF INF FRAME
	AIS	R2,1			:ADVANCE INPUT FRAME DATA POINTER
	AIS	RBBX,1			:ADVANCE BB INDEX
	JNBS	INFOR4			:IF NOT END OF CURRENT BB, LOOP
:	TO GET ANOTHER NEW BIG BUFFERLET
	JAL	R4,GBB,,		:GET BIG BUFFERLET
	J	NOBUF1			:FAILURE NO BUFFERLET
	LHL	R4,BBUFER+BBFLSZ-BBFPSZ,RBBA, :GET CHARS IN CHAIN AREA
	BBST	R3,BBUFER+BBFLSZ-BBFPSZ,RBBA, :CHAIN THE NEW ONE TO THE OLD ONE
	LR	RBBA,R3			:LOAD NEW BASE ADDRESS
	LHI	RBBX,-BBFLSZ+BBFPSZ	:INIT INDEX
	STH	R4,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA :STORE CHAR IN NEW BB
	J	INFOR4			:GO TO MOVE DATA

:	END OF I-FIELD DATA, UPDATE RCV'ED FRAME COUNTER
INFOR5
	LIS	R1,1			:DEC. RECEIVE BUFFER QUOTA
	AHM	R1,LSCLKS+LSCN.R,RLSC,	:INCREASE 1
	AM	R1,LCBTAB+LCBN.R,RLCB,	:INCREASE 1
	J	RCVEND			:END, EXIT

NOBUF1
	JAL	R10,CRASH,,		:CRASH, NO BUFFER
	BC	0,0,4*R4,CRNOBF


:	RCVILG:	CONTROL FIELD ILLEGAL
:	------------------------------
RCVILG
	LHI	RC,RCCTL		:CONTROL FILED ERROR
	J	RCVEND


:	RCVUNB:	CONTROL FILED WITHOUT I-FIELD (UNNUMBERED FRAME)
:	----------------------------------------------------------
RCVUNB
	LR	R0,R0			:MAKE SURE NO I-FIELD
	JE	RCVEND			:NO I-FILED, EXIT
RCVCT1
	LHI	RC,RCIPHB		:SET ERROR CODE
	J	RCVEND			:EXIT


:	RCVSPV:	CONTROL FILED WITHOUT I-FIELD (SUPERVISOR FRAME)
:	------------------------------------------------------
RCVSPV
	LR	R0,R0			:MAKE SURE NO I-FIELD
	JN	RCVCT1			:HAVE I-FIELD,JUMP TO SET ERROR
	J	RCVEND			:EXIT


:	RCVCTD	:RECEIVING U-FRAME WITH I-FIELD
:	-----------------------------------------
:	RCV'ED XID/TEST/FRMR FRAME
RCVFRR
RCVCTD
	J	INFOR1			:TO MOVE I-FILED TO BB


:	RNGERR:	FRAME LENGTH ERROR
:	----------------------------
RNGERR
	LHI	RC,RCLNG		:LENGTH TOO SHORT (< 32 BITS)
	J	RCVEND

RNGER1
	LHI	RC,RCOVRN		:TOO LONG
	J	RCVEND


:	ADDRER AND ADRER1 :  ADDRESS ERRER
:	---------------------------------
:	ADDRER:	NOT CONFIGURAED POLLING ADDRESS
:	ADRER1: NOT SPECIFIED ADDRESS RECEIVED
ADDRER
	LHI	RC,RCADRU
	JFS	ADRER2
ADRER1
	LHI	RC,RCADRD
ADRER2
	J	RCVEND

:	RCVEND	:RECEIVE END
:	----------------------
RCVEND		
:	TO SEE IF THE SIO INPUT RING HAS ROOM FOR ONE MORE FRAME
:	IF NO, THEN START TO RCV DATA FROM SIO INPUT RING STARTING ADDRESS
:	AND UPDATE THE RINDEX
	LHL	R2,RINDEX,RL,RL		:GET RING INDEX USED
	AIS	R2,3			:GET NEXT INDEX
	AH	R2,RINBYT,RL,RL		:ADD IN BYT CNT TO FORM NEXT INDEX
	NHI	R2,0FFFE		:ADJUST INDEX FOR HWD OF CNT
	LHL	R3,RBUFRM,RL,RL		:GET ENOUGH ROOM SIZE FOR 1 MORE FRAME
	CR	R2,R3			:COMPARE 
	JLEFS	RCVEN1			:JUMP, IF STILL HAS ROOM
	LIS	R2,0			:START FROM 0, IF NO ROOM AT THE END
RCVEN1
	STH	R2,RINDEX,RL,RL		:SAVE NEW RINDEX

	IF	FTRACE			:FOREGROUND TRACING
	TBT	RL,FTRRLN,,		:RCV TRACING?
	JE	RCVEN6			:NO, SKIP
	TBT	RL,FTRINF,,		:TRACE INF ONLY?
	JEFS	RCVENX			:NO, SKIP
	CLHI	RC,RCINF		:INF?
	JG	RCVEN6			:YES
RCVENX
	LHL	R6,FTRSIX,,		:GET FRAME TRACING INDEX
	LR	R2,RL			:COPY LINE # TO R2
	SLHLS	R2,4			:SHIFT LEFT ONE NIBBLE
	OHI	R2,FTRRCV		:MARK AS RCV TRACING
	TBT	RL,FTRTLN,,		:TIME STAMP?
	JEFS	RCVEN3			:NO, SKIP
	OHI	R2,FTRTIM		:ELSE, INDICATE IN 1ST BYTE
RCVEN3
	STB	R2,FTRSBF+0,R6,		:SAVE LINE # AND RCV/XMT INDICATOR
	STB	RC,FTRSBF+1,R6,		:SAVE RCV RETURN CODE
	LB	R2,RCVADR,RL,		:GET'A' BYTE
	STB	R2,FTRSBF+2,R6,		:...
	LB	R2,RCVCTL,RL,		:GET 'C' BYTE
	STB	R2,FTRSBF+3,R6,		:SAVE INTO TRACING BUFFER
	LHL	R2,RINBYT,RL,RL		:GET RCV'ED BYTE COUNT
	STH	R2,FTRSBF+5,R6,		:BYTE COUNT
	AIS	R6,6			:ADVANCE INDEX PTR
	TBT	RL,FTRTLN,,		:STAMP?
	JE	RCVEN4			:NO, SKIP
	L	R2,FASTC,,		:GET FASTC
	LHL	R14,FTGMTL,,		:GMT OR FASTC?
	JEFS	.+8			:FASTC, SKIP
	L	R2,GMT,,		:GET GMT
	STH	R2,FTRSBF+2,R6,		:STORE 2ND HW OF THE TIME
	EXHR	R2,R2			:EXCHANGE TWO HW'S
	STH	R2,FTRSBF,R6,		:STORE 1ST HW OF THE TIME
	AIS	R6,4			:UPDATE INDEX PTR
RCVEN4
	CLHI	R6,FTRACE*FTRBFL	:WRAP AROUND?
	JLFS	RCVEN5			:NO, SKIP
	LIS	R6,0			:YES, RESET INDEX PTR
RCVEN5
	STH	R6,FTRSIX,,		:UPDATE NEW INDEX PTR
RCVEN6
	EI	(FTRACE)

	STB	RC,RCVRTC,RL,		:SAVE LOCALLY
	LR	RLSC,RLSC		:ANY LSC ?
	JE	RSTART			:TO RCV AGAIN
	LR	R1,R5			:R1 = RC
	EXBR	R1,R1
	LB	R0,LCBTAB+LCBCTL,RLCB,
	OR	R1,R0			:R1 = RC | CTL 
:	DELETE FRAMES  RECEVIED PREVIOULY, IF START TO RECEIVE
:	NEW SEQUENCE OF FRAMES
:	(10/24/84 MIA)
	LHL	R5,LSCLKS+LSCBIT,RLSC,	:GET LSC BIT ARRAY
	LR	R3,R5			:COPY IT
	NHI	R3,@RPFBIT		:MASK OLD P/F BIT
	THI	R0,PFMASK		:IS INPUT P/F BIT ON
	JEFS	RCVEN7			:JUMP IF NOT
	OHI	R3,RPFBIT		:ELSE TURN IT ON
RCVEN7	STH	R3,LSCLKS+LSCBIT,RLSC,	:UPDATE LSC BIT ARRAY
	THI	R5,RPFBIT		:WAS OLD P/F BIT ON?
	JEFS	RCVEN8			:JUMP IF NOT
	JAL	R5,FLSIOQ		:FLUSH INPUT
RCVEN8	JAL	R5,QSIORV		:QUEUE NEW INPUT
	J	RSTART			:REPEAT RCV


	FO	GBLDEF
	FO	FGGBDF
	FO	SNAEXC
	FO	MAIN
	EM
 	SUBTTL	(SNA/SDLC) SIO TRANSMITTER -- SFGXMT
:FXMT00.F00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Modified from SDLC Interface for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	RA      0       
	MO	.,SFGXMT

	LO	MAIN
	LO	GBLDEF
	LO	FGGBDF
	LO	SNAEXC
	LO	SFGPTP


:	RETURN CODES TO CALLER
:	----------------------

XMTOK	EQ	0		:XMT SUCESSFUL
XMTTMO	EQ	1		:XMT NOT COMPLETED BEFORE TIMEOUT VALUE
XMTNOR	EQ	2		:XMT ROTOR LIST NO ROOM
XMTCTS	EQ	3		:CTS NOT UP IN TIME
XMTHWD	EQ	4		:XMT SIO RR STATUS ERROR
XMTHLT	EQ	5		:XMT HALT (04/01/86 YLH)

:	XMT OP CODE FROM PROTOCOL MANAGER
:	---------------------------------

XCRXMT	EQ	0		:REXMT 
XCDATA	EQ	1		:XMT DATA
XCSNRM	EQ	2		:XMT SNRM CODE
XCUA	EQ	3		:XMT UA
XCDISC	EQ	4		:XMT DISC
XCRD	EQ	XCDISC		:XMT RD CODE
XCDM	EQ	5		:XMT DM
XCSIM	EQ	6		:XMT SIM CODE
XCRIM	EQ	XCSIM		:XMT RIM CODE
XCXID	EQ	07		:XMT XID CODE
XCTEST	EQ	8		:XMT TEST CODE
XCFRMR	EQ	9		:XMT FRMR CODE
XCRR	EQ	0A		:XMT RR
XCRNR	EQ	0B		:XMT RNR
XCREJ	EQ	0C		:XMT REJ
XCMAXI	EQ	XCRNR		:MAXI VALUE OF XMT OP CODE

:	CTS BIT ON SIO RR0
:	------------------
CTSGBT	EQ	4			:VERSION < H 
CTSHBT	EQ	2			:VERSION < H 


:	LOCAL STORAGES
:	--------------

	SEG	A.DATA

XRETAD	WS	NLINES		:CALLER'S RETURN ADDRESS
XTIME	WS	NLINES		:FASTC TIME TO ABORT XMT OPERATION
XWHWTM	WS	NLINES		:XMT WAIT FOR OP COMPLETE TIME DELAY
XSCADR	WS	NLINES		:SECTOR XMT SAVE AREA
X1STFR	HS	(NLINES-1)/10+1	:XMT FIRST FRAME BIT ARRAY
XOPCOD	BS	NLINES		:OPERATION CODE
XMTRTC	BS	NLINES		:XMT COMPLETE CODE
	IF	FTRACE
XMTBFS	EQ	0C0		:XMT ERROR EVENT TRACE BUFFER SIZE
				:(1/3/85/CHS)
XMTBFP	HC	0		:XMT ERROR EVENT TRANCE BUFFER INDEX
XMTBUF	BS	XMTBFS		:XMT ERROR EVENT TRACE BUFFER
	EI


	SUBTTL	SIO TRANSMIT MODULE


:
:
:	ALGORITHM FOR SIO TRANSMIT MODULE ----
:
:	(1.) GET LCB ACCORDING TO LINE NUMBER
:	(2.) CHECK CURRENT XMT STATION # IN LCB
:	(3.) GET LSC ACCORDING TO CURRENT XMT STATION #
:	(4.) CHECK ENOUGH ROOM IN SIO RING OR NOT
:	(5.) IF NO ROOM GOTO (A)
:	(6.) ASSEMBLE THE FRAME (COMBINE A AND C FIELD TO OUTGOING FRAME)
:	(7.) PUT FRAME INTO ROTOR LIST
:	(8.) SET XMTOK STATUS				
:	(9.) REMOVE ITSELF FROM RUNLIST AND PUT PTP INTO RUNLIST
:	  THEN RETURN
:	(A.) DISMISS ITSELF,PUT PTP IN RUNLIST
:	(B.) AFTER WAKE UP, CHECK TIME OUT OR NOT
:	(C.) IF TIME OUT,INFORM PTP TIMEOUT GOTO (9.)
:	(D.) NOT TIME OUT,GOTO (4.)
:


:	REGISTER CONVENTIONS:
:	---------------------
:
:	(R2) ---> OUTGOING FRAME ADDRESS FIELD
:	RLCB ---> R11 REGISTER FOR RLCB ADDRESS
:	RL   ---> R08 CONTAINS LINK NUMBER
:	RL2  ---> R09 CONTAINS 2*NUMBERLINES
:	RBBA ---> R7  FOR BUFFERLET BASE ADDRESS
:	RBBX ---> R4  FOR BUFFERLET PTR
:	RLSC ---> R12 CONTAINS LSC ADDRESS
:	RSIO ---> R13 FOR SIO TABLE PURPOSE
:	RSIP ---> R14 FOR SIO POINTER
:	R15  ---> R15 PTP DISPATCHER LINK REGISTER
:
:	INPUT REGISTERS CONTAIN:
:	R0 --- TIME TO FORCE XMT OP COMPLETE
:	R1 --- OP CODE FOR XMT
:	RLCB --- CONTAINS LCB ADDRESS (R11)
:	RLSC --- CONTAINS LSC ADDRESS (R12)
:	R5 --- LINK ADDRESS
:	R15 --- MUST BE PRESERVED
:


	SEG	A.CODE


SIOXMT
	ST	R0,XTIME,RL2,RL2	:SAVE TIME FOR FORCE XMT OP COMPLETE
	ST	R5,XRETAD,RL2,RL2	:SAVE RETURN ADDRESS
	STB	R1,XOPCOD,RL,		:SAVE OP CODE
	LA	R5,XSTART
	ST	R5,XRUNL,RL2,RL2	:PUT NEXT PROCESS ON XMT RUNLST
	J	PHALT			:REMOVE PROTOCOL DRIVER FROM RUNLST


:	PROTOCOL RUN LIST ACTIVE, RETURN TO CALLER
:	-----------------------------------------
XTPRET
	LHL	RLCB,LCBPTR,RL,RL	:SET UP RLCB
	LHL	RLSC,LCBTAB+LCBC.X,RLCB, :SET UP RLSC
	L	R5,XRETAD,RL2,RL2	:GET RETURN ADDR
	JR	R5			:RETURN

:	XSETRG:	SET UP RLCB, RLSC, AND RSIP
:	------
:	SHOULD BE CALLED AFTER XDMISS
XSETRG
	LHL	RLCB,LCBPTR,RL,RL	:GET LCB ADDR
	LHL	RLSC,LCBTAB+LCBC.X,RLCB, :GET CURRENT STATION IN RLCB-XMT
	LB	RSIP,CROTOR,RL,		:GET PRESENT ENTRY TO LOOK AT
	L	RSIO,SIOTBL,RL2,RL2	:SET SIOTABLE BASE ADDRESS
	LR	R4,RSIP			:QUAD WORD
	SLLS	RSIP,4			:MAKE QUAD WORD INDEX
	JR	R5

	SUBTTL	SDLC LINK LEVEL TRANSMITTER - TRANSMITTING PROCESS


:	XSTART: TRANSMIT PROCESS ENTRY POINT
:	------------------------------------
XSTART
	JAL	R5,XSETRG		:SET UP RLCB, RLSC, RSIP
	LHL	R3,TCCWL,RSIP,RSIO	:CHECK THE CMD FIELD
	CLHI	R3,1			:IF CMD = OUTPUT HDLC, THEN NOROOM
	JN	XSTAR1			:AVAILABLE, SKIP
	L	R2,XTIME,RL2,RL2	:XMT TIMOUT?
	JE	SXWAIT			:NO TIMER SET
	CL	R2,FASTC,,		:TIME UP ?
	JLE	XSTAR0			:YES, TIMEOUT
SXWAIT
	JAL	R5,XDMISS		:DIMISS
	J	XSTART			:RESTART

XSTAR0
	LIS	R7,XMTNOR		:SET CC TO NO ROOM
	J	XMTEND			:GO TO XMT END ROUTINE

XSTAR1
	LIS	R0,0			:CLEAR CURRENT ENTRY IN THE ROTOR LIST
	STH	R0,TCCWL,RSIP,RSIO	:CMD FIELD
	STH	R0,TCCWL+4,RSIP,RSIO	:TRANSFER CMD FIELD
	LB	R4,XOPCOD,RL,		:GET OP CODE
	LHL     R5,SXMTAB,R4,R4
	J	SEG|A.CODE|,R5, 


:	"C" FIELD DECISION TABLE
:	-----------------------
:	INDEXED BY THE XMT OP CODE
:
CFXCTB	HS	0
	BC	0,0,SNRM,UA		:REXMT,DATA,SNRM,UA
	BC	DISC,DM,SIM,XID		:DISC,DM,SIM,XID
	BC	TEST,FRMR,RR,RNR	:TEST,FRMR,RR,RNR
	BC	REJ			:REJ


:	"C" FIELD PROCESSING TABLE
:	--------------------------
:	INDEXED BY XMT OP CODE
:
:
	HS	0
SXMTAB
	HC	XMTRXT-SEG|A.CODE|	:0  - RE-XMT XMT OP CODE
	HC	XMTINF-SEG|A.CODE|	:1  - XMT INFORMATION FRAME
	HC	XMSNRM-SEG|A.CODE|	:2  - XMT SNRM FRAME
	HC	XMUA-SEG|A.CODE|	:3  - XMT UA FRAME
	HC	XMDISC-SEG|A.CODE|	:4  - XMT DISC/RD FRAME
	HC	XMDM-SEG|A.CODE|	:5  - XMT DM FRAME
	HC	XMSIM-SEG|A.CODE|	:6  - XMT SIM/RIM FRAME
	HC	XMXID-SEG|A.CODE|	:7  - XMT XID FRAME
	HC	XMTEST-SEG|A.CODE|	:8  - XMT TEST FRAME
	HC	XMFRMR-SEG|A.CODE|	:9 - XMT FRMR FRAME
	HC	XMRR-SEG|A.CODE|	:0A - XMT RR FRAME
	HC	XMREJ-SEG|A.CODE|	:0B - XMT REJ FRAME
	HC	XMRNR-SEG|A.CODE|	:0C - XMT RNR FRAME


	SUBTTL	SDLC LINK LEVEL TRANSMITTER - PROCESSING ROUTINE


:	XMRR,XMRNR,XMREJ	:XMT RR,RNR,REJ FRAME
:	-----------------------------------------------
:
XMRR
XMREJ
XMRNR
	LB	R1,CFXCTB,R4		:FROM TABLE GET CONTROL FIELD CODE
	J	XCMD00			:TO XMT CMD FRAME


:	XMUA,XMDM,XMDISC,XMSNRM,XMSIM,XMRIM
:	--------------------------------------------
:	XMT UA,DM,DISC(RD),SNRM,SIM(RIM) FRAMES
:
XMUA
XMDM
XMDISC
XMSNRM
XMSIM
XMRIM
XMRD
	LB	R1,CFXCTB,R4		:FROM TABLE GET CONTROL FIELD 
	J	XCMD01			:TO XMT CMD FRAME


:	XMTEST/XMXID/XMFRMR: XMT TEST/XID/FRMR FRAME
:	-------------------------------------------
:
XMXID
XMTEST
XMFRMR
	LB	R1,CFXCTB,R4		:FROM TABLE GET CONTROL FIELD CODE
	LHL	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	THI	R0,RXTBIT		:IS THIS A RE-XMT?
	JE	XMTIN0			:NO, NOT A RE-XMT, SKIP
	J	XMTRX1			:GO TO RE-XMT THE LAST CMD



:	XMTINF	:XMT INFORMATION FRAME
:	------------------------------------


XMTINF
	LHL	R7,LNCPTR,RL,RL		:GET LNC 
	LHL	R3,LNCTAB+LNIACT,R7,	:RESET LINK INACT TIMER
	JEFS	XMTINX			:NO TIMER, SKIP
	A	R3,SLOWC,,
XMTINX
	ST	R3,LNCTAB+LNITME,R7,	:...
	LB	R1,LSCLKS+LSCVRX,RLSC,	:GET N(R) VALUE
	SLLS	R1,5			:PUT N(R) INTO 'A' FIELD
	LB	R4,LSCLKS+LSCVSX,RLSC,	:GET V(S) VALUE
	SLLS	R4,1			:PUT IT IN PROPER POSITION
	OR	R1,R4			:OR IN N(S) VALUE
XMTIN0
	LHL	R3,LSCLKS+LSCBIT,RLSC,	:CHK OPFBIT
	NHI	R3,OPFBIT		:....
	JEFS	XMTIN1
	OHI	R1,PFMASK		:OR'ED IN P/F BIT
XMTIN1
	LB	R4,LSCLKS+LSCT.N,RLSC,
	LHL	R6,SEDBIA,R4,R4
	LB	R0,LSCLKS+LSCVSX,RLSC,
	LR	R5,R0
	AR	R5,R5
	IF	FWBBF			:(11/23/84 MIA)
	AR	R5,R0
	EI				:(11/23/84 MIA)
	SLHLS	R5,1
	LB	R0,LSCLKS+LSCVSX,RLSC,
	SBT	R0,SECBLT,R4,R4
	JE	XMTIN3			:SEC NOT BUILT, SKIP
	BBL	R10,SECBAS+2,R6,R5	:ELSE, SEE IF NEED TO RELASE BB
	JE	XMTIN3			:NO, SKIP
	LR	R0,R6			:SAVE R6 INTO R0
XMTIN2
	LR	R3,R10			:PREPARE FOR THE RELEASE OF BB
	BBL	R10,BBUFER+BBFLSZ-BBFPSZ,R10, :GET NEXT BB ADDR
	JAL	R4,PBB,		:RELASE THIS BB
	LHL	R3,LSCLKS+LSCPUC,RLSC,	:R3 = PUC OFFSET
	LHL	R4,LNCPTR,RL,RL		:R4 = LNC OFFSET
	LIS	R6,1
	AHM	R6,PUCTAB+PUXBUS,R3,	:UPDATE BB XMT USAGE IN PUC
	AHM	R6,LNCTAB+LNXBUS,R4,	:UPDATE BB XMT USAGE IN LNC
	LR	R10,R10			:ALL DONE?
	JN	XMTIN2			:REPEAT
	LR	R6,R0			:RESTORE R6
XMTIN3
	LHL	R0,LSCLKS+LSCXCN,RLSC,
	STH	R0,SECBAS,R6,R5
	BBL	R0,LSCLKS+LSCXHP,RLSC,
	BBST	R0,SECBAS+2,R6,R5
	LB	R5,LSCLKS+LSCVSX,RLSC,	:
	LHL	R0,SECBIA,RL2,		:
	AR	R5,R0			:
	AR	R5,R5			:
	J	INFTRM			:GOTO TO ENTRY OF OUTPUT LIST


:	XMTRXT	:RE-XMT
:	---------------

XMTRXT
	LHL	R7,LNCPTR,RL,RL		:GET LNC 
	LHL	R3,LNCTAB+LNIACT,R7,	:RESET LINK INACT TIMER
	JEFS	XMTRX0			:NO TIMER, SKIP
	A	R3,SLOWC,,
XMTRX0
	ST	R3,LNCTAB+LNITME,R7,	:...
	JAL	R5,DECRXC		:DECREASE RE-XMT
	LB	R1,LSCLKS+LSCVRX,RLSC,	:GET N(R) VALUE
	SLLS	R1,5			:PUT N(R) INTO 'A' FIELD
	LB	R4,LSCLKS+LSCVSX,RLSC,	:GET V(S) VALUE
	SLLS	R4,1			:PUT IT IN PROPER POSITION
	OR	R1,R4			:OR IN N(S) VALUE
	LHL	R3,LSCLKS+LSCBIT,RLSC,	:CHK OPFBIT
	NHI	R3,OPFBIT		:....
	JEFS	XMTRX1			:JUMP,IF P/F NOT SET
	OHI	R1,PFMASK		:OR'ED IN P/F BIT
XMTRX1
	LB	R5,LSCLKS+LSCVSX,RLSC,	:GET V(S)
XMTRX2
	LB	R4,LSCLKS+LSCT.N,RLSC,
	TBT	R5,SECBLT,R4,R4		:TEST SECTOR BUILD ARRAY
	JE	RXMTER			:JUMP,IF SECTOR IS NOT BUILD
	LHL	R6,SEDBIA,R4,R4		:GET SECTOR DATA BUFFER BIAS
	LR	R4,R5
	AR	R4,R4
	IF	FWBBF			:(11/23/84 MIA)
	AR	R4,R5
	EI				:(11/23/84 MIA)
	SLHLS	R4,1
	LHL	R0,SECBAS,R4,R6		:GET DATA LENGTH
	STH	R0,LSCLKS+LSCXCN,RLSC,
	BBL	R0,SECBAS+2,R4,R6	:GET DATA BUFFER BASE
	BBST	R0,LSCLKS+LSCXHP,RLSC,
	LHL	R0,SECBIA,RL2,		:GET SECTOR BIASE
	AR	R5,R0
	AR	R5,R5
:	J	XSETCM			:JUMP TO CONT (11/23/84 MIA)
	J	INFTRM			:JUMP TO CONT (11/23/84 MIA)

	SUBTTL	UTILITY ROUTINES TO XMT CMD OTHER THAN I-FRAMES


:	XCMD00	:TO XMT A SUPERVISORY COMMAND
:	---------------------------------------
:	R1 = 'C' FIELD
:	R5 = BYTE COUNT
XCMD00
	LB	R6,LSCLKS+LSCVRX,RLSC,	:GET CURRENT V(R) VALUE
	SLHLS	R6,5
	OR	R1,R6			:OR IN N(R) VALUE
:	XCMD01	:TO XMT AN UNNUMBERED FRAME
:	----------------------------------
XCMD01
	LHL	R3,LSCLKS+LSCBIT,RLSC,	:GET LKS' LSCBIT BYTE
	NHI	R3,OPFBIT		:IS OPFBIT ON?
	JEFS	XCMD02			: IF P/F BIT NONE, SKIP
	OHI	R1,PFMASK		:ELSE, OR'ED IN P/F BIT TO 'C' FIELD
:	STORE 'A' VALUE INTO 'A' FIELD AND 'C' VALUE INTO 'C' FIELD
XCMD02
	LR	R6,RSIO			:CALCULATE OUTPUT SECTOR ABSOLUTE ADDR
	A	R6,OUTSCT,RL2,RL2	:ADD OFFSET OF OUTSCT(5/10/85/CHS)
:	AHI	R6,OUTSCT,RSIP		:R6 CONTAINS OUTPUT SECTOR ADDR(5/10/85/CHS)
	AR	R6,RSIP			:R6 CONTAINS OUTPUT SECTOR ADDR(5/10/85/CHS)
	LB	R2,LSCLKS+LSCSAD,RLSC,  :GET POLLING ADDR
	STB	R2,2,R6 		:PUT INTO OUTPUT SECTOR
	STB	R1,3,R6			:PUT IN THE 'C' FIELD VALUE
	LIS	R5,2			:BYTE COUNT IS 2
	STH	R5,0,R6			:PUT BYTE CNT TO 1ST HW OF XMT SECTOR
	J	XSETCM			:TO SET UP ROTOR LIST ENTRY


	SUBTTL	UTILITY ROUTINES TO XMT INFORMATION FRAMES


:	INFTRM:	FINISH UP AN OUTPUT SECTOR FOR TRANSMISSION.
:	-------------------------------------------------------
:
:	INPUT	R1 = 'C' BYTE
:		R5 = INDEX INTO SECTOR POINTER

INFTRM
	L	R5,SECADR,R5,R5		:GET SECTOR ADDR
	STB	R1,3,R5			:PUT 'C' VALUE INTO XMT SECTOR
	LB	R0,LSCLKS+LSCSAD,RLSC,  :GET STATION ADDRESS
	STB	R0,2,R5			:PUT 'A' VALUE INTO XMT SECTOR
	LIS	R0,1			:INCREASE XMT FAMRE CNT
	AHM	R0,LSCLKS+LSCN.X,RLSC,	:UPDATE FRAME XMT CNT
	AM	R0,LCBTAB+LCBN.X,RLCB,	:...
INFTR1
	LH	R0,LSCLKS+LSCXCN,RLSC,	:GET # OF BYTES WANT TO XMT
	LR	R1,R0			:R1 CONTAINS I-FIELD BYTE COUNT
	AIS	R0,FRMHDR		:ADD HEADER CNT TO TOTAL
	STH	R0,0,R5			:PUT BYTE CNT INTO 1ST HW OF XMT SECTOR
	LIS	R2,0			:INITIALIZE INDEX TO OUTPUT XMT SECTOR
	BBL	RBBA,LSCLKS+LSCXHP,RLSC, :GET BUFFERLET ADDRESS
	LHI	RBBX,-BBFLSZ+BBFPSZ	:INIT RBBX
INFTR2
	SIS	R1,1			:SUBTRACT LENGTH BY 1
	JL	INFTR3			:FINISH ALL DATA IN THIS BB
	LB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA :GET A CHAACTER
	AIS	R2,1			:GO TO NEXT ONE
	STB	R0,3,R2,R5		:PUT DATA INTO XMT SECTOR
	AIS	RBBX,1			:TO GET NEXT BYTE
	JN	INFTR2			:MORE DATA, CONTINUE
INFTR3
	BBL	RBBA,BBUFER+BBFLSZ-BBFPSZ,RBBA, :GET NEXT BB ADDR
	LHI	RBBX,-BBFLSZ+BBFPSZ	:INIT RBBX
	LR	RBBA,RBBA		:ALL DONE?
	JN	INFTR2			:NO, MORE BB, CONTINUE
	LR	R6,R5			:R6=R5= XMT SECTOR ADDR
	J	XSETCM			:TO SET UP ROTOR LIST ENTRY


	SUBTTL	SDLC LINK LEVEL TRANSMITTER - PRIMITIVE ROUTINES


:	XSETCM	:XMT SETTING UP ROTOR LIST ENTRY
:	-----------------------------------------
:		  R6 --- TRANSMIT SECTOR ADDRESS
XSETCM
	ST	R6,XSCADR,RL2,RL2	:SAVE XMT SECTOR ADDR
	LB	R4,LCBTAB+LCBALK,RLCB,	:GET HALF/FULL DUPLEX INDICATOR
	NHI	R4,HDMASK		:COMPARE WITH MASK
	JE	XSET30			:JUMP, IF FULL DUPLEX
	TBT	RL,X1STFR,,		:1ST FRAME ?
	JE	XSET30			:NOT FIRST FRAME ,SKIP
:	IF HALF DUPLEX, 1ST FRAME, AND RTS/CTS HANDSHAKING
:	THEN RAISE RTS AND WAIT CTS
	TBT	RL,RTSCTS,,		:RTS UP?
:	JE	XSET10			:YES, SKIP(5/12/86/CHS)
	JE	XSET20			:YES, SKIP(5/12/86/CHS)
	LIS	R0,CTSGBT		:CLEAR CTS BIT ON RR0 (5/12/86/CHS)
	TBT	RL,D.SIOC		:ASSUME VERSION < H (5/12/86/CHS)
	JEFS	XSET05			:HIT, SKIP (5/12/86/CHS)
	LIS	R0,CTSHBT		:ELSE,.. (5/12/86/CHS)
XSET05
	RBT	R0,0,RSIO		:CLEAR CTS INIDCATOR (5/12/86/CHS)
	LA	R4,OCPRTS,RSIO,		:POINT TO RTS COMMAD PAIR
	LR	R3,RL			:GET LOGICAL UNIT #
	SVC	IO,(FMBOT.^4)+R3	:OUTPUT THIS CMD PAIR
	J	TXRERR			:IF SVC FAILED
	SBT	RL,SIORTS,,		:INDICATE SIO RTS UP
:	WAIT FOR CTS TO BE UP
XSET10
:	TBT	RL,RTSCTS,,		:RTS/CTS HANDSHAKING ?(5/12/86/CHS)
:	JE	XSET20			:SKIP, IF HANDSHAKING NOT NEEDED(5/12/86/CHS)
	LB	R4,0,RSIO		:GET SIO READ REGISTER 0
	TBT	RL,D.SIOC		:NEW SIO DAUGHTER CARD?(5/10/85/CHS)
	JEFS	XSET12			:NO, SKIP(5/10/85/CHS)
:	NHI	R0,CTSHMS		:IS CTS ON?(5/10/85/CHS)
	NHI	R4,CTSHMS		:IS CTS ON? (07/31/85 MIA)
	JFS	XSET13			:SKIP TO CONTINUE(5/10/85/CHS)
XSET12					:(5/10/85/CHS)
:	NHI	R0,CTSGMS		:IS CTS ON? (5/10/85/CHS)
	NHI	R4,CTSGMS		:IS CTS ON? (07/31/85 MIA)
XSET13					:(5/10/85/CHS)
	JN	XSET20			:IF CTS UP, CONTINUE
	L	R2,XTIME,RL2,RL2	:GET FASTC TIME TO STOP OP
	CL	R2,FASTC,,		:TIME UP ?
	JLE	XSET15			:SKIP, IF SO
	JAL	R5,XDMISS		:DISMISS THIS LINE FOR THIS CYCLE
	JAL	R5,XSETRG		:SET UP RLCB, RLSC, RSIP
	J	XSET10			:CHECK CTS AGAIN
XSET15
	LIS	R7,XMTCTS		:SET XMT CC TO CTS NOT UP
	J	XSET85			:GO TO DO ERROR RECOVERY
:	(07/30/86/CHS) IT IS NOT NECESSARY TO CHECK EOM BIT
XSET20
:	CHECK TO SEE SIO RR STATUS O.K.
:XSET20
:	LB	R4,0,RSIO		:GET SIO READ REGISTER 0
:	NHI	R4,EOMMSK		:XMT UNDERRUN/EOM ON?
:	JN	XSET30			:READY TO XMT FOR HALF-DUPLEX MODE
:	L	R2,XTIME,RL2,RL2	:GET FASTC TIME TO STOP OP
:	CL	R2,FASTC,,		:TIME UP ?
:	JLE	XSET25			:YES, TIMEOUT
:	JAL	R5,XDMISS		:DISMISS THIS LINE FOR THIS CYCLE
:	JAL	R5,XSETRG		:SET UP RLCB, RLSC, RSIP
:	J	XSET20			:CHECK CTS AND/OR EOMMSK
:XSET25
:	LIS	R7,XMTHWD		:FLAG SIO RR STATUS ERROR
:	J	XSET85			:GO TO DO ERROR RECOVERY
:	(7/30/86/CHS) END OF DELETE CHECKING EOM ROUTINE


:	READY TO SET UP XMT CMD INTO ROTOR LIST FOR
:	HALF-DUPLEX AND FULL-DUPLEX TRANSMISSION
XSET30
	L	R6,XSCADR,RL2,RL2	:RESTORE R6 = XMT SECTOR ADDR
	LR	R4,R6			:MOVE SECTOR ADDR TO R4
	SRLS	R4,4			:FORM QUAD WORD
	STH	R4,TCCWL+2,RSIP,RSIO	:PUT INTO ROTOR LIST
	LIS	R5,1			:SET CMD TO XMT
	STH	R5,TCCWL,RSIP,RSIO	:PUT INTO ROTOR LIST

:	IF FULL DUPLEX, LINK THIS ONE TO THE PREVIOUS ONE, OR RE-ISSUE SVC
:	IF HALF DUPLEX AND 1ST FRAME, LINK OCPENA AND THIS ONE, ISSUE SVC
:	IF HALF DUPLEX, 1ST FRAME, AND NEW SIO MICRO CODE, THEN
:	 LINK OCPENA AND THIS ONE, ISSUE SVC
:	IF HALF DUPLEX, LAST FRAME, AND NEW SIO MICRO CODE, THEN
:	 LINK OCPW TO THE END OF THIS ONE TO DISABLE TX
	LB	R4,LCBTAB+LCBALK,RLCB,	:SEE FULL OR HALF DUPLEX
	NHI	R4,HDMASK		:???
	JE	XSET40			:FULL-DUPLEX, SKIP
:	FOLLOWING TO XSET40 ARE FOR HALF-DUPLEX
	IF	SIOEVR
	LHL	R4,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R4,OPFBIT		:OPFBIT ON?
	JE	XSET35			:NO, NOT LAST FRAME, SKIP
	LA	R3,OCPW,RSIO		:R3 POINT TO OCPW
	LI	R4,TXDSAB		:SET UP TX DISABLE CCW
:	TBT	RL,RTSCTS,,		:IF RTSCTS, DROP RTS TOO(5/7/86/CHS)
:	JEFS	XSET32			:NO, SKIP(5/7/86/CHS)
:	LI	R4,RTSDCM		:YES, GET POPER COMMAND(5/7/86/CHS)
XSET32
	ST	R4,0,R3			:PUT CCW INTO OCPW
	SRLS	R3,4			:FORM QUAD WORD
	STH	R3,TCCWL+6,RSIP,RSIO	:CURRENT LINK TO OCPW
	LIS	R3,2			:SET UP TRANSFER CMD ( LINK)
	STH	R3,TCCWL+4,RSIP,RSIO	: TO LINK TO OCPW
XSET35
	EI
	RBT	RL,X1STFR,,		:CHECK AND RESET 1ST FRAME INDICATOR
	JE	XSET40			:NO 1ST FRAME, SKIP
	LA	R4,TCCWL,RSIP,RSIO	:1ST FRAME, LINK OCPENA
	SRLS	R4,4			: AND THIS ONE
	STH	R4,OCPENA+6,RSIO	:LINK IT TOGETHER
	LIS	R4,2			:SET UP A"TRANSFER" CMD
	STH	R4,OCPENA+4,RSIO	:PUT ITNO TRASF. CMD FIELD
	LA	R4,OCPENA,RSIO		:SET R4 = OCPENA ADDR
	J	XSET50			:TO ISSUE SVC
:	FULL DUPLEX AND
:	MIDDLE FRAME(S) FOR HALF-DUPLEX
XSET40
	LB	R2,CROTOR,RL,		:CHECK PREVIOUS ONE IS BUSY OR NOT
	SIS	R2,1			:FORM PREVIOUS ENTRY
	NHI	R2,ROTMSK		:MODULUS WITH # OF ROTOR LIST ENTRIES
	SLHLS	R2,4			:EACH ENTRY 16 BYTES
	AR	R2,RSIO			:CALCULATE PREVIOUS ENTRY ADR
	LHL	R4,TCCWL,R2		:GET PREVIOUS ONE'S CMD FIELD
	CLHI	R4,1			:CMD STILL 'XMT'
	JN	XSET45			:NO, PREVIOUS ONE ALREADY COMPLETED
					:TO RE-ISSUE SVC
:	PREVEIOUS ENTRY STILL BUSY XMITTING. TACK ON A JUMP TO THIS ONE.
	LA	R4,TCCWL,RSIP,RSIO	:SET UP TRANSFER ADDR
	SRLS	R4,4			:...
	STH	R4,TCCWL+6,R2,		:INTO PREV ONE
	LIS	R4,2			:SET UP A 'TRANSFER' CMD
	STH	R4,TCCWL+4,R2		:PUT INTO THE 'TRANSFER' FILED
	LHL	R4,TCCWL,R2		:MAKE SURE PREVIOUS COMMAND DID NOT
					:FINISH BEFORE JUMP GOT STORED
	CLHI	R4,0200			:PREVIOUS FINISHED?
	JN	XSET55			:NO, DONT NEED TO ISSUE SVC
XSET43					:(04/01/86 YLH)
	LIS	R4,0			:ELSE CLEAR CMD FIELD
	STH	R4,TCCWL,R2		:...
	STH	R4,TCCWL+4,R2		:CLEAR 'TRANSFER' FIELD
					:OF PREV. ONE
:	ISSUE SVC FOR OUTPUT.
XSET45
	LA	R4,TCCWL,RSIP,RSIO	:FORM ENTRY ADDRESS
:	R4 ALREADY SET UP
XSET50
	LR      R3,RL			:GET LOGICAL UNIT #
	SVC	IO,(FMBOT.^4)+R3	:ISSUE SVC
	J	TXRERR			:IF SVC FAILED

XSET55
:	IF FULL-DUPLEX, EXIT
:	IF HALF-DUPLEX, AND NOT LAST FRAME, EXIT
:	IF HALF-DUPLEX, AND LAST FRAME, THEN
:	 DISABLE TRANSMITTER, DROP RTS IF NECESSARY
	LIS	R7,XMTOK		:ASSUME XMT OK
	LB	R4,LCBTAB+LCBALK,RLCB,	:GET HALF/FULL DUPLEX
	NHI	R4,HDMASK		:FULL-DUPLEX?
	JE	XSET95			:YES, EXIT TO CLEAN UP
	LHL	R3,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R3,OPFBIT		:IS OPFBIT ON?
	JE	XSET95			:NOT LAST FRAME, CAN NOT DIABLE XMT'ER
:	FROM HERE TO XSETYY, FOR HALF DUPLEX AND LAST FRAME
:	PREPARE FOR THE HALF-DUPLEX RECEIVING
	JAL	R5,FLSIOQ		:SYN THE SIO INPUT

:	DISABLE TRANSMITTER AFTER ALL THE FRAMES HAVE BEEN TRANSMITTED
:	MUST CHECK THE SIO STATUS REGISTERS
XSET60
	JAL	R5,XDMISS		:DISMISS THIS LINE FOR THIS CYCLE
	JAL	R5,XSETRG		:SET UP RLSC, RLCB, RSIP
:	IF NEW SIO MICRO CODE, CHECK OCPW EXECUTED
:	ELSE CHECK LAST ENTRY
	IF	SIOEVR
	LHL	R4,OCPW,RSIO		:GET OCPW COMMAND CODE
	CLHI	R4,0200			:CMD COMPLETE?
	JN	XSET65			:NO, SKIP TO WAIT
	LIS	R7,XMTOK		:INDICATE XMT OK.
	SBT	RL,X1STFR,,		:NEXT TIME MUST BE THE 1ST FRAME
	TBT	RL,RTSCTS,,		:RTS ALWAYS UP?
	JE	XSET95			:YES, SKIP TO EXIT
:	RBT	RL,SIORTS,,		:NO, INDICATE RTS DROPPED(5/7/86/CHS)
:	J	XSET95			:AND SKIP TO EXIT(5/7/86/CHS)
	J	XSET75			:AND SKIP TO DROP RTS(5/7/86/CHS)
XSET65
	ELSE
	LHL	R4,TCCWL,RSIP,RSIO	:GET LAST CMD CODE
	CLHI	R4,0200			:LAST CMD COMPLETE?
:	JEFS	XSET75			:COMMAND COMPLETE,JUMP (04/01/86 YLH)
	JE	XSET75			:COMMAND COMPLETE,JUMP (04/01/86 YLH)
	EI
:
:BEGIN (04/01/86 YLH)
:	MICROCODE AND SLOT CODE CONTENTION RECOVERY LOGIC IS INSERTED
:
	LB	R3,CROTOR,RL,		:GET NEXT TCCW
	AIS	R3,1			:...
	NHI	R3,ROTMSK		:IN CASE WRAP AROUND
	LR	RSIP,R3	
	SLHLS	RSIP,4			:SET UP RSIP
	LHL	R4,TCCWL,RSIP,RSIO	:GET STATUS OF NEXT TCCW
	CLHI	R4,1			:STILL OUTPUTTING?
	JE	XSETTO			:YES, HALT COND. IMPOSSIBLE
:LOOK AT REST OF TCCWs
NEXT
	AIS	R3,1			:INCREMENT TO NEXT TCCW
	NHI	R3,ROTMSK		:IN CASE WRAP AROUND
	LB	R4,CROTOR,RL,		:GET CURRENT TCCW ON ROTOR LIST
	AIS	R4,1			:CURRENT +1
	NHI	R4,ROTMSK		:IN CASE WRAP AROUND
	CR	R3,R4			:HAVE ALL TCCWs BEEN CHECKED?
	JE	XSETTO			:YES, NO HALT - GO CHECK TIMEOUT
	LR	RSIP,R3			:SETUP RSIP
	SLHLS	RSIP,4			:...
	LHL	R4,TCCWL,RSIP,RSIO	:GET STATUS OF TCCW
	CLHI	R4,1			:NEXT ONE STILL OUTPUTTING?
	JN	NEXT			:NO, NOT IN HALT- GO CHECK NEXT TCCW
:TCCW FOUND WITH STATUS = 1
:CHECK IF PREVIOUS TCCW STATUS = 200 WITH A JUMP (2)
	LR	R2,R3			:GET PREVIOUS TCCW
	SIS	R2,1			:...
	NHI	R2,ROTMSK		:IN CASE OF WRAP AROUND
	SLHLS	R2,4			:...
	LHL	R4,TCCWL,R2,RSIO	:GET PREVIOUS STATUS
	CLHI	R4,200			:COMPLETE?
	JN	NEXT			:NO, CHECK NEXT TCCW
	LHL	R4,TCCWL+4,R2,RSIO	:YES, CHECK IF JUMP TO NEXT TCCW
	CLHI	R4,2			:JUMP TO NEXT?
	JN	NEXT			:NO, CHECK NEXT TCCW FOR HALT
:HALTED TCCW FOUND - RE-ISSUE SVC AND STORE INFO IN BUFFER
	LHL	R4,XMTBFP,,		:POINT TO SAVE BUFFER
	STB	RL,XMTBUF,R4,		:SAVE LINE NUMBER
	LIS	R7,XMTHLT		:INDICATE HALT CONDITION
	STB	R7,XMTBUF+1,R4,		:SAVE HALT INDICATOR
	LB	R3,0,RSIO,		:GET READ REG 0
	STB	R3,XMTBUF+2,R4,		:STORE READ REG 0
	LB	R3,1,RSIO,		:GET READ REG 1
	STB	R3,XMTBUF+3,R4,		:STORE READ REG 1
	LB	R3,6,RSIO,		:GET STATUS INFO
	STB	R3,XMTBUF+4,R4,		:STORE STATUS INFO
	LB	R3,8,RSIO,		:GET INTERRUPT INFO
	STB	R3,XMTBUF+5,R4,		:STORE INTERRUPT STATUS
	AIS	R4,6			:INCREASE INDEX PTR
	CLHI	R4,XMTBFS		:WRAP AROUND?
	JLFS	XSETHT			:NO
	LIS	R4,0			:YES
XSETHT
	STH	R4,XMTBFP,,		:UPDATE BUFFER PTR
	AR	R2,RSIO
	J	XSET43			:RE-ISSUE SVC
:
:END (04/01/86 YLH)
:NO HALT FOUND - REGULAR TIMEOUT LOGIC
:
XSETTO	L	R3,XTIME,RL2,RL2	:GET XMT TIMER (RESPONSE TIME LIMIT)
	CL	R3,FASTC,,		:TIME UP?
	JLEFS	XSET70			:TIME UP, EXIT
	J	XSET60			:TO DISMISS AND RE-CHECK

:	XMT TIME OUT, SET XMT COMPLETE CODE, AND TO RECOVERY
XSET70
	LIS	R7,XMTTMO		:SET XMT CC TO TIMEOUT
	J	XSET85			:TO RECOVERY

:	OLD SIO MICRO CODE
:	LAST CMD FINISH, DELAY FOR A SHORT PERIOD BEFORE ISSUE
:	DISABLE TRANSMITTER COMMAND
XSET75
	LHL	R3,THW.LN,RL,RL		:GET XMT HARDWARE DELAY VALUE
	A	R3,FASTC,,		:ADD TO FAST CLOCK
	ST	R3,XWHWTM,RL2,RL2	:SAVE TIMER
XSET80
	JAL	R5,XDMISS		:DISMISS THIS LINE FOR THIS CYCLE
	JAL	R5,XSETRG		:SET UP RLCB, RLSC, RSIP
	L	R3,XWHWTM,RL2,RL2	:GET FASTC TIME TO STOP OP
	CL	R3,FASTC,,		:TIME UP?
	JGE	XSET80			:NOT, DISMISS AGAIN
	LIS	R7,XMTOK		:FLAG XMT OK
XSET85
	LI	R5,RTSDCM		:DISABLE XMT'ER AND DROP RTS CMD PAIR
	TBT	RL,RTSCTS,,		:RTS/CTS IS REQUIRED ?
	JNFS	XSET90			:YES, NEED DROP RTS, SKIP
	LI	R5,TXDSAB		:ELSE DIABLE XMT'ER ONLY (RTS STILL UP)
XSET90
	ST	R5,OCPW,RSIO		:PUT DISABLE XMT'ER CMD TO ROTOR LIST
	SBT	RL,X1STFR,,		:NEXT TIME WILL BE 1ST FRAME
	LA	R4,OCPW,RSIO		:POINT TO OCPW AREA
	LR	R3,RL			:GET LOGICAL UNIT #
	SVC	IO,(FMBOT.^4)+R3	:ISSUE DISABLE XMT'ER CMD
	J	TXRERR			:IF SVC FAILED
	TBT	RL,RTSCTS,,		:SEE IF DROPPED RTS
	JEFS	XSET95			:NO, SKIP
	RBT	RL,SIORTS,,		:FLAG RTS DROPPED
XSET95					:MUST GO THRU THIS POINT
	LR	R7,R7			:XMT O.K.?
	JE	XSETB0			:YES, SKIP
	IF	FTRACE
:	RECORD THE SIO RR STATUS AND INTERRRUPT INFORMATION
	LHL	R4,XMTBFP,,		:INDEX INTO EVENT BUFFER
	STB	RL,XMTBUF,R4,		:LINE THAT HAS PROBLEM
	STB	R7,XMTBUF+1,R4,		:(1/3/85/CHS) SAVE XMT RC CODE
	LB	R3,0,RSIO		:GET SIO RR0
:	STB	R3,XMTBUF+1,R4,		:RECORD IT(1/3/85/CHS)
	STB	R3,XMTBUF+2,R4,		:RECORD IT(1/3/85/CHS)
	LB	R3,1,RSIO		:GET SIO RR1
:	STB	R3,XMTBUF+2,R4,		:RECORD IT(1/3/85/CHS)
	STB	R3,XMTBUF+3,R4,		:RECORD IT(1/3/85/CHS)
	LB	R3,6,RSIO		:GET STATUS INFOR
:	STB	R3,XMTBUF+3,R4,		:RECORD IT(1/3/85/CHS)
	STB	R3,XMTBUF+4,R4,		:RECORD IT(1/3/85/CHS)
	LB	R3,8,RSIO		:GET INTERRUPT INFO
:	STB	R3,XMTBUF+4,R4,		:RECORD IT(1/3/85/CHS)
	STB	R3,XMTBUF+5,R4,		:RECORD IT(1/3/85/CHS)
:	AIS	R4,5			:INCREASE INDEX PTR(1/3/85/CHS)
	AIS	R4,6			:INCREASE INDEX PTR(1/3/85/CHS)
	CLHI	R4,XMTBFS		:WRAP AROUND?
	JLFS	XSETA0			:SKIP, NO
	LIS	R4,0			:YES, RESET INDEX
XSETA0
	STH	R4,XMTBFP,,		:UPDATE INDEX PTR
	EI
XSETA5
	LIS	R4,0			:SET R4 TO 0
	STH	R4,2,RSIO		:CLEAR RR0 AND RR1
	ST	R4,4,RSIO		:CELAR 2ND WORD OF SIO STATUS
:	CLEAR CCP, ONLY THE CMD FILEDS
	STH	R4,TCCWL+00,RSIO	:1ST CMD FIELD
	STH	R4,TCCWL+04,RSIO	:1ST TRANSFER FIELD
	STH	R4,TCCWL+10,RSIO	:2ND COMMAND FIELD
	STH	R4,TCCWL+14,RSIO	:2ND TRANSFER FIELD
	STH	R4,TCCWL+20,RSIO	:3RD COMMAND FIELD
	STH	R4,TCCWL+24,RSIO	:3RD TRANSFER FIELD
	STH	R4,TCCWL+30,RSIO	:4TH COMMAND FIELD
	STH	R4,TCCWL+34,RSIO	:4TH TRANSFER FIELD
	STH	R4,TCCWL+40,RSIO	:5TH COMMAND FIELD
	STH	R4,TCCWL+44,RSIO	:5TH TRANSFER FIELD
	STH	R4,TCCWL+50,RSIO	:6TH COMMAND FIELD
	STH	R4,TCCWL+54,RSIO	:6TH TRANSFER FIELD
	STH	R4,TCCWL+60,RSIO	:7TH COMMAND FIELD
	STH	R4,TCCWL+64,RSIO	:7TH TRANSFER FIELD
	STH	R4,TCCWL+70,RSIO	:8TH COMMAND FIELD
	STH	R4,TCCWL+74,RSIO	:8TH TRANSFER FIELD
XSETB0
:
:BEGIN (04/01/86 YLH)
:	ZERO OUT THE JUMP OPCODE FIELD
:
	IF	SIOEVR
	LB	R4,CROTOR,RL,		:GET CURRENT ROTOR LIST ENTRY
	NHI	R4,ROTMSK		:WRAP AROUND IF NECESSARY
	SLHLS	R4,4			:GET QUAD WORD BOUNDARY
	LIS	R0,0			:STORE 0 INTO THE 2ND CCW COMMAND FIELD
	STH	R0,TCCWL+4,R4,RSIO
	EI
:
:END (04/01/86 YLH)
:
	LB	R4,CROTOR,RL,		:GET CURRENT ROTOR LIST PTR
	AIS	R4,1			:NEXT ENTRY
	NHI	R4,ROTMSK		:WRAP AROUND IF NECESSARY
	STB	R4,CROTOR,RL,		:UPDATE NEXT AVAIL. ENTRY
	J	XMTEND			:JUMP TO FINISH

:	SIO OUTPUT SVC ERROR EXIT
:	-------------------------
TXRERR
	JAL	R10,CRASH,,
	BC	0,0,0,0E4		:SIO OUTPUT SVC ERROR
:	F.G. RETRANSMISSION ERROR
:	--------------------------
RXMTER
	JAL	R10,CRASH,,
	BC	0,0,0,0E4		:RETRANSMISSION ERROR


:	XMT OP COMPLETE
:	---------------
:	TAKE US OFF THE XMT RUN LIST AND PUT US ON THE PROTOCOL RUN LIST.
:	WHEN ACTIVATED, RETURN TO ORIGNAL CALLER WITH OPERATION RESULTS.
XMTEND
	STB	R7,LCBTAB+LCBXRC,RLCB,	:STORE XMT RETRUN CODE IN RLCB
	STB	R7,XMTRTC,RL,		:SAVE XMT COMPLETE CODE LOCALLY
	LHL	R3,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT BYTE
	NHI	R3,@OPFBIT		:CLEAR OPFBIT
	STH	R3,LSCLKS+LSCBIT,RLSC,	:UPDATE LSCBIT BYTE


	IF	FTRACE
:	LR	R7,R7			:XMT COMPLETED NORMAL? (03/05/86 MIA)
:	JN	XMTEN4			:JUMP IF NOT (03/05/86 MIA)
	TBT	RL,FTRXLN,,		:TRACE THIS LINE?
	JE	XMTEN4			:NO, SKIP
	TBT	RL,FTRINF,,		:TRACE INF ONLY?
	JEFS	XMTEN0			:NO, SKIP
	LB	R0,XOPCOD,RL,
	CLHI	R0,XCDATA		:INF?
	JG	XMTEN4			:NO, SKIP
XMTEN0
	LHL	R6,FTRSIX,,		:GET TRACE INDEX PTR
	LR	R0,RL
	SLHLS	R0,4			:SHIFT LEFT ONE NIBBLE
	OHI	R0,FTRXMT		:MASK TRACE XMT
	TBT	RL,FTRTLN,,		:TIME STAMP REQUIRED?
	JEFS	XMTEN1			:NO, SKIP
	OHI	R0,FTRTIM		:INDICATE TIME STAMPPED
XMTEN1
	STB	R0,FTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LB	R0,XOPCOD,RL,		:GET XMT OP CODE
	SLHLS	R7,4			:XMT CC CODE
	OR	R0,R7
	SRHLS	R7,4
	STB	R0,FTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LR	R0,RL			:COPY LINE # TO R0
	L	R3,XSCADR,RL2,RL2	:GET LAST XMT SECTOR ADDR
					:IF XMT CC = NOROOM, THE OTHER DATA
					: ARE NOT SIGNIFICANT
	LB	R0,2,R3			:GET THE XMT'ED 'A' BYTE
	STB	R0,FTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	LB	R0,3,R3			:GET THE XMT'ED 'C' BYTE
	STB	R0,FTRSBF+3,R6,		:SAVE INTO TRACE BUFFER
	LHL	R0,0,R3			:GET THE XMT'ED FRAME BYTE COUNT
	STH	R0,FTRSBF+5,R6,		:BYTE COUNT
	AIS	R6,6			:ADVANCE INDEX PTR
	TBT	RL,FTRTLN,,		:TIME STAMP?
	JE	XMTEN2			:NO, SKIP
	L	R3,FASTC,,		:GET FAST CLOCK
	LHL	R0,FTGMTL,,		:FASTC OR GMT?
	JEFS	.+8			:FASTC, SKIP
	L	R3,GMT,,		:GET GMT
	STH	R3,FTRSBF+2,R6,		:SAVE 2ND HW OF TIME
	EXHR	R3,R3			:EXCHANGE 1ST AND 2ND HW
	STH	R3,FTRSBF,R6,		:SAVE 1ST HW OF TIME
	AIS	R6,4			:ADVANCE INDEX
XMTEN2
	CLHI	R6,FTRACE*FTRBFL	:WRAP AROUND?
	JLFS	XMTEN3			:NO, SKIP
	LIS	R6,0			:ESLE, RESET INDEX PTR
XMTEN3
	STH	R6,FTRSIX,,		:UPDATE NEW INDEX PTR
XMTEN4
	EI	(FTRACE)

	LR	R7,R7			:IF XMT OK, SKIP
	JEFS	XMTEN5
	LIS	R0,1			:ELSE,  INCREASE ERROR COUNT
	SIS	R7,1			:INDEX FROM XMTTMO
	SLHLS	R7,1			:AND MAKE HW INDEX
	AHM	R0,LCBTAB+LCBN.T,RLCB,R7 :TALLY ERROR
XMTEN5
	LA	R3,XTPRET		:PUT US ON PROTOCOL RUN LIST
	ST	R3,PRUNL,RL2,RL2
	J	XHALT			:DISCONNECT LINE FROM TRANSMIT RUN LIST


	FO	MAIN
	FO	GBLDEF
	FO	FGGBDF
	FO	SNAEXC
	FO	SFGPTP
	EM
	SUBTTL (SNA/SDLC) SDLC PROTOCOL HANDLER INIT, DISPATCHER - SFGPTP
:SFGP00.F00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	RA	0
	MO	.,SFGPTP


	LO	MAIN
	LO	GBLDEF
	LO	CMDLST
	LO	FGGBDF
	LO	SNAEXC
	LO	SFGRCV
	LO	SFGXMT


:	DEFINE CONSTANTS
:	----------------
TXMTER	EQ	5*TPS		:TIME GIVEN TO TRY AGAIN AFTER XMT ERROR   

:	DEFINE LOCAL STORAGES
:	---------------------
	SEG	A.DATA

XMTOPC	BS	NLINES		:XMT OP CODE FOR ROUTINE XMT
RCVOPC	BS	NLINES		:RCV RC CODE FOR ROUTINE RCV
	BND	4
XMTRET	WS	NLINES		:RETURN ADDRESS FOR XMT


	SUBTTL (SFGPTP) SDLC PROTOCOL HANDLER INITIALIZATION


:*******************************************************:
:						  	:
:	PROTOCOL HANDLER INITIALIZATION ROUTINES     	:
:						  	:
:	THIS ROUTINE IS CALLED BY BACKGROUND PROCESS TO :
:	ACTIVATE THE PROTOCOL MANAGER FOR A SPECIFIED   :
:	LINE.						:
:							:
:*******************************************************:


	SEG	A.CODE


:	PTPINI:	PROTOCOL MGR INITIALIZATION
:	------
:	EXPECT: R8 = LINE #
PTPINI
	LR	R10,R5			:SAVE PTPINT RETURN ADDRESS
	LHL	RLCB,LCBPTR,R8,R8	:GET ADDR OF LCB
	SBT	R8,X1STFR,,		:SET FIRST FRAME XMT BIT ARRAY
	LB	R7,LCBTAB+LCBALK,RLCB,	:GET ACCESS METHOD
	SLLS	R7,1			:SHIFT LEFT 1 BIT
	LB	R1,LCBTAB+LCBP.S,RLCB,	:GET PRIMARY/SECONDARY BIT
	OR	R7,R1			:OR WITH ACCESS METOD
	NHI	R7,3			:GET THE LAST 2 BITS
	LIS	0,0			:INIT R0 TO 0
	ST	R0,LCBTAB+LCBXMT,RLCB,	:CLEAR XMT BIT ARRAY
	ST	R0,LCBTAB+LCBRCV,RLCB,	:CLEAR RCV BIT ARRAY
	STH	R0,LCBTAB+LCBC.X,RLCB,	:INIT
	LIS	R2,0			:INIT R2 TO 1ST LKS ON THIS LINK
PTPIN1
	JAL	R5,GETLSC		:GET THIS LSC
	STH	R0,LSCLKS+LSCXHL,RLSC,	:CLEAR XMT PROTOCOL ENTRY IN LSC
	STH	R0,LSCLKS+LSCRHL,RLSC,	:CLEAR RCV PROTOCOL ENTRY IN LSC
	LHL	R5,CLRTAB,R7,R7		:GET CLEARP CMD PROCESSING ROUTINE
	STH	R5,LSCLKS+LSCCLR,RLSC,	:PUT INTO LSC
	LHL	R5,TRMTAB,R7,R7		:GET TERMP CMD PROCESSING ROUTINE
	STH	R5,LSCLKS+LSCTRM,RLSC,	:PUT INTO LSC
	LHL	R5,LKSPTB,R7,R7		:GET PROTOCOL ENTRY STATE
	JE	PTPIN4			:NO PROTOCOL ENTRY ROUTINE
	LR	R1,R1			:PRIMARY OR SECONDARY?
	JEFS	PTPIN2			:SECONARY, SKIP
	STH	R5,LSCLKS+LSCXHL,RLSC,	:PUT XMT INIT STATE TO LSC
	SBT	R2,LCBTAB+LCBXMT,RLCB,	:ACTIVE THIS LKS' PROTOCOL
	LR	R2,R2			:LINK START FROM 1ST CU
	JNFS	PTPIN3			:SKIP, IF NOT 1ST ONE
	STH	RLSC,LCBTAB+LCBC.X,RLCB, :SET UP XMT CU
	JFS	PTPIN3			:SKIP TO CONTINUE
PTPIN2
	STH	R5,LSCLKS+LSCRHL,RLSC,	:PUT RCV INIT STATE TO LSC
	JAL	R5,SETRT1		:SET UP RCV COMPLTET TIMER
	SBT	R2,LCBTAB+LCBRCV,RLCB,	:ACTIVE THIS LKS' PROTOCOL
PTPIN3
	AIS	R2,1			:NEXT STATION
	LHL	R3,LNCPTR,R8,R8		:GET LNCTAB
	CLB	R2,LNCTAB+LNMXPU,R3,	:ALL PU DONE?
	JL	PTPIN1			:NO, LOOP
	LA	R0,DSPPTP		:GET THE PTP DISPATCHER ADDR
	SLHLS	R8,1
	ST	R0,PRUNL,R8,R8		:PUT ON RUN LISY
	LA	R0,RSTART		:GET THE RCV PROCESS ADDR
	ST	R0,RRUNL,R8,R8		:PUT ON RUN LIST
	SRHLS	R8,1
	LR	R5,R10			:RESTORE RETURN ADDRESS
	JR	R5			:RETURN
PTPIN4
	JAL	R10,CRASH
	BC	0,0,0,0FF


:	STATION PROTOCOL IDLE STATE
:	---------------------------
LKSPTB
	IF	(DLCSFD)
	GL	FSRNDM
	HC	FSRNDM-PSEG		:FDX P-T-P/MP SECONDARY
	ELSE
	HC	0
	EI

	IF	(DLCPFD)
	GL	FPXNDM
	HC	FPXNDM-PSEG		:FDX P-T-P/MP PRIMARY
	ELSE
	HC	0
	EI

	IF	(DLCSHD)
	GL	HSRNDM
	HC	HSRNDM-PSEG		:HDX P-T-P/MP SECONDARY
	ELSE
	HC	0
	EI

	IF	(DLCPHD)
	GL	HPXNDM
	HC	HPXNDM-PSEG		:HDX P-T-P/MP PRIMARY
	ELSE
	HC	0
	EI


:	STATION PROTOCOL PROCESSING ROUTINE ENTRY FOR CLEARP COMMAND
:	------------------------------------------------------------
CLRTAB
	IF	(DLCSFD)
	GL	FSCLRI
	HC	FSCLRI-PSEG		:FDX P-T-P/MP SECONDARY
	ELSE
	HC	0
	EI

	IF	(DLCPFD)
	GL	FPCLRI
	HC	FPCLRI-PSEG		:FDX P-T-P/MP PRIMARY
	ELSE
	HC	0
	EI

	IF	(DLCSHD)
	GL	HSCLRI
	HC	HSCLRI-PSEG		:HDX P-T-P/MP SECONDARY
	ELSE
	HC	0
	EI

	IF	(DLCPHD)
	GL	HPCLRI
	HC	HPCLRI-PSEG		:HDX P-T-P/MP PRIMARY
	ELSE
	HC	0
	EI


:	STATION PROTOCOL PROCESSING ROUTINE ENTRY FOR TERMP COMMAND
:	------------------------------------------------------------
TRMTAB
	IF	(DLCSFD)
	GL	FSTRMI
	HC	FSTRMI-PSEG		:FDX P-T-P/MP SECONDARY
	ELSE
	HC	0
	EI

	IF	(DLCPFD)
	GL	FPTRMI
	HC	FPTRMI-PSEG		:FDX P-T-P/MP PRIMARY
	ELSE
	HC	0
	EI

	IF	(DLCSHD)
	GL	HSTRMI
	HC	HSTRMI-PSEG		:HDX P-T-P/MP SECONDARY
	ELSE
	HC	0
	EI

	IF	(DLCPHD)
	GL	HPTRMI
	HC	HPTRMI-PSEG		:HDX P-T-P/MP PRIMARY
	ELSE
	HC	0
	EI


	SUBTTL (SFGPTP) PROTOCOL DISPATCHER FOR AN SDLC LINK


:*******************************************************:
:							:
:	THIS IS THE DISPATCHER FOR A LINK WHICH HAS	:
:	ONE OR MORE STATIONS TO SWITCH THE PROTOCOL	:
:	ACTIVATION ROUTINE FROM ONE STATION TO ANOTHER	:
:	OR FROM RCV TO XMT AND VICE VERSA.		:
:							:
:							:
:*******************************************************:

DSPPTP
	LHL	RLCB,LCBPTR,RL,RL	:GET RLCB ADDR
:	PROCESS CLEARP & TERMP CMD, ETC..
DSPCMD
	LCS	R0,1			:SET LCBPRO TO ALL 1'S
	ST	R0,LCBTAB+LCBPRO,RLCB,	:...
DSPCM1
	L	R1,LCBTAB+LDACMD,RLCB,	:GET LKS CMD PRESENT BIT ARRAY
	N	R1,LCBTAB+LCBPRO,RLCB,	:ANY NEED TO BE PROCESSES?
	JFFO	R1,DSPCMX		:FIND THE LKS ID #
	J	DSPXMT			:ALL DONE FOR CLR, GO TO SCAN XMT
DSPCMX
	RBT	R2,LCBTAB+LCBPRO,RLCB,	:INDICATE THIS LKS PROC. THIS ROUND
	JAL	R5,GETLSC		:GET LSC ADDR
	JAL	R5,FHCMDQ		:FETCH CMD FROM CMD QUEUE, CMD IN R2
	LHL	R5,LSCLKS+LSCCLR,RLSC,	:GET CLEARP PROCESSING ENTRY
	CLHI	R1,CLRCD		:IS IT A CLRCD?
	JEFS	DSPCM2			:HIT, SKIP TO CONTINUE
	LHL	R5,LSCLKS+LSCTRM,RLSC,	:ELSE GET TERMP PROCESSING ENTRY
DSPCM2
	LR	R5,R5			:PROCESS SET?
	JE	DSPCRH			:IF NONE, CRASH
	J	PSEG,R5,		:GO TO ACTIVATION ROTUINE

:	PROCESS XMT QUEUES
DSPXMT
	LHL	RLSC,LCBTAB+LCBC.X,RLCB,:SERVING XMT?
	JE	DSPRCV			:NO, SKIP TO RCV
	L	R0,LCBTAB+LCBXTM,RLCB,	:RCV TO XMT TURN AROUND TIME UP?
	JE	DSPXM0			:NO TIMER, SKIP
	CL	R0,FASTC,,		:...
	JLE	DSPXM0			:YES, SKIP(5/22/85/CHS)
	LB	R0,LCBTAB+LCBALK,RLCB,	:IF HALF DUPLEX, CAN NOT RCV(5/22/85/CHS)
	LR	R0,R0
	JN	DSPDMS			:... (5/20/85/CHS)
DSPXM0
	LB	R2,LSCLKS+LSCRID,RLSC,	:GET RID
	TBT	R2,LCBTAB+LCBXMT,RLCB,	:DOUBLE CHECK
	JE	DSPCRH			:CRASH, IF NOT IN XMT STATE
	LHL	R4,LSCLKS+LSCXHL,RLSC,	:TRIPLE CHECK
	JE	DSPCRH			:CRASH, IF NO XMT PROC.
DSPXM1
	JAL	R5,PKXMTQ		:PEEK AT THE QUEUED CMD, CMD IN R2
					:AND DATA BUFFER PTR IN R3
					:R1 = CMD CONVERTED CODE
	SLHLS	R1,1			:MAKE HW INDEX
	LHL	R4,LSCLKS+LSCXHL,RLSC,	:GET XMT PROTOCOL STATE TABLE
	JE	DSPCRH			:IF NONE, CRASH
	LHL	R5,PSEG,R1,R4		:GET XMT PROTOCOL ENTRY PTR
	J	PSEG,R5,		:GO TO ACTIVATION ROTUINE

:	PROCESS RCV QUEUES
DSPRCV
	LHL	RLSC,LCBTAB+LCBC.R,RLCB,	:SEE IF SPECIFIC RCV
	JN	DSPRC2			:YES, SKIP
	LCS	R0,1			:SET THE LCBPRO TO ALL 1'S
	ST	R0,LCBTAB+LCBPRO,RLCB,	:
DSPRC1
	L	R1,LCBTAB+LCBRCV,RLCB,	:GET LKS IN RCV STATE BIT ARRAY
	N	R1,LCBTAB+LCBPRO,RLCB,	:ANY NEED TO BE PROCESSES?
	JFFO	R1,DSPRCZ		:FIND THE LKS ID #
	J	DSPDMS			:ALL DONE FOR RCV, GO TO DISMISS
DSPRCZ
	RBT	R2,LCBTAB+LCBPRO,RLCB,	:INDICATE THIS LKS PROC. THIS ROUND
	JAL	R5,GETLSC		:GET LSC ADDR
	STH	RLSC,LCBTAB+LCBC.R,RLCB, :PUT INTO LCB
DSPRC2
	JAL	R5,SRCV			:DO A SINGLE SIO RECEIVING
	SLHLS	R1,1			:MAKE HW INDEX
	LHL	R4,LSCLKS+LSCRHL,RLSC,	:GET RCV PROTOCOL STATE TABLE
	JE	DSPCRH			:IF NONE, CRASH
	LHL	R5,PSEG,R1,R4		:GET RCV PROTOCOL ENTRY PTR
	J	PSEG,R5,		:GO TO ACTIVATION ROTUINE

DSPDMS
	JAL	R5,PDMISS		:DISMISS FOR THIS LINK
	J	DSPPTP			:AFTER WAKE UP, TO DISPATCH

DSPCRH
	JAL	R10,CRASH,,		:PROGRAMMING ERROR
	BC	0,0,0,088


	SUBTTL (SFGPTP) INTERFACE BETWEEN LINK PROCEDURE AND XMT/RCV MODULES

:*******************************************************:
:						    	:
:	ROUTINES TO HANDLE RCV,XMT			:
:						    	:
:*******************************************************:
 
:	THIS ROUTINE IS THE INTERFACE BETWEEN PTP AND RCV
:	---------------------------------------------------
:	INPUT:R5 --	 LINK ADDRESS      
 
SRCV	
	LIS	R1,0			:INIT LSCRST
	STB	R1,LSCLKS+LSCRST,RLSC,	:...
	LHL	RARG,LSCLKS+SGPSIO,RLSC, :SEE IF ANY SIO FRAME RCV'ED
:	CLH	RARG,LSCLKS+SRPSIO,RLSC, :... (01/02/85 MIA)
	LHL	R0,LSCLKS+SRPSIO,RLSC,	:GET RELEASE PTR (01/02/25 MIA)
	CR	RARG,R0			:COMP GET AND REL PTR (01/02/25 MIA)
	JNFS	SRCV1			:YES, SKIP
	L	R0,LSCLKS+LSCRT1,RLSC,	:SEE IF TIMEOUT
	CL	R0,FASTC,,
	JGER	R5			:NO, EXIT
	LHI	R1,RCTMOT		:ELSE, TIMEOUT
	STB	R1,LSCLKS+LSCRST,RLSC,	:..
	JR	R5
SRCV1
	BBL	R3,CMDBLK+CLARG,RARG,	:R3 - BB CHAIN
	BBST	R3,LSCLKS+LSCRHP,RLSC,	:PUT INTO LSC
	LHL	R2,CMDBLK+CLLNG,RARG,	:R2 = DATA LENGTH
	STH	R2,LSCLKS+LSCRCN,RLSC,	:PUT INTO LSC
	LB	R1,CMDBLK+CLCMD,RARG,	:R1 = RC CODE
	STB	R1,LSCLKS+LSCRST,RLSC,	:PUT INTO LSC
	LB	R0,CMDBLK+CLCMDS,RARG,	:R0 = C FIELD
	STB	R0,LSCLKS+LSCCTL,RLSC,	:PUT INTO LSC
	LHL	RARG,LSCLKS+SGPSIO,RLSC, :ADVANCE CMD
	LHL	RWORK,CMDBLK+CLPTR,RARG,
	JE	CLERR			:CRASH IF ADVANCE AN EMPTY LIST
	STH	RWORK,LSCLKS+SGPSIO,RLSC, :ADVANCE
	JAL	RLNK,RELCL		:RELEASE GP CMD ELEMENT
	LHL	R4,LSCLKS+LSCBIT,RLSC,
	NHI	R4,@IPFBIT		:MASK OFF OLD P/F BIT
	NHI	R0,PFMASK		:IS THE INPUT P/F BIT ON?
	JEFS	SRCV2			:NO, SKIP
	OHI	R4,IPFBIT		:ELSE, SET IPFBIT IN LSCBIT
SRCV2
	STH	R4,LSCLKS+LSCBIT,RLSC,
	LHL	R4,NRNSTB,R1,R1		:BASE ON RC TO GET NR OR NS
	JAL	R4,PSEG,R4,		:SET UP NR/NS
	JR	R5			:RETURN

 
:	NRNSTB:	SET UP NR/NS
:	--------
NRNSTB	HC	NRNSNU-PSEG		:00 - NON-DATA, NO ACTION
	HC	NRNSBH-PSEG		:01 - INF, BOTH NR AND NS
	HC	NRNSNU-PSEG		:02 - SNRM, NO ACTRION
	HC	NRNSNU-PSEG		:03 - UA, NO ACTRION
	HC	NRNSNU-PSEG		:04 - DISC, NO ACTRION
	HC	NRNSNU-PSEG		:05 - DM, NO ACTRION
	HC	NRNSNU-PSEG		:06 - SIM, NO ACTRION
	HC	NRNSNU-PSEG		:07 - XID, NO ACTRION
	HC	NRNSNU-PSEG		:08 - TEST, NO ACTRION
	HC	NRNSNU-PSEG		:09 - FRMR, NO ACTRION
	HC	NRONLY-PSEG		:0A - RR, NR ONLY
	HC	NRONLY-PSEG		:0B - RNR, NR ONLY
	HC	NRONLY-PSEG		:0C - REJ, NR ONLY
	HC	NRNSNU-PSEG		:0D - CTL ERR, NO ACTION
	HC	NRNSNU-PSEG		:0E - I ERR, NO ACTION
	HC	NRNSNU-PSEG		:0F - IPHB, NO ACTION
	HC	NRNSNU-PSEG		:10 - OVRN, NO ACTION
	HC	NRNSNU-PSEG		:11 - LENG, NO ACTION
	HC	NRNSNU-PSEG		:12 - ADDR, NO ACTION
	HC	NRNSNU-PSEG		:13 - LOST, NO ACTION
	HC	NRNSNU-PSEG		:14 - TIME, NO ACTION


:	NRNSNU:	NULL
:	-----
NRNSNU
	JR	R4

:	NRNSBH:	GET NR AND NS
:	-------
NRNSBH
	LB	R0,LSCLKS+LSCCTL,RLSC,
	SRHLS	R0,1
	NHI	R0,07			:ISOLATE N(S) BIT
	STB	R0,LSCLKS+LSCNSR,RLSC,	:PUTINTO LSC
:	NRONLY:	GET NR ONLY
:	------
NRONLY
	LB	R0,LSCLKS+LSCCTL,RLSC,
	SRHLS	R0,5
	NHI	R0,07			:ISOLATE N(R) BIT
	STB	R0,LSCLKS+LSCNRR,RLSC,
	JR	R4

:	THIS ROUTINE IS THE INTERFACE TO THE XMT MODULE
:	------------------------------------------------
:	INPUT:	R1 --	 OP CODE FOR SFGXMT
:		R5 --	 LINK REGISTER
:	OUTPUT:	NORMAL RETURN, IF XMT ERROR
:		SKIP RETURN, XMT SUCCESS
SXMT	
	LHL	R0,TXC.LN,RL2		:GET XMT TIMER RESPONSE INTERVAL
	JEFS	SXMT1			:NO TIMER, SKIP
	SLLS	R0,TSCALE		:SCALE
	A	R0,FASTC,,		:CALCULATE REAL TIME
SXMT1
	STB	R1,XMTOPC,RL,		:SAVE XMT OP CODE
	ST	R5,XMTRET,RL2,RL2	:SAVE RETURN ADDRESS
	JAL	R5,SIOXMT		:DO A XMT
	LB	R0,LCBTAB+LCBXRC,RLCB,	:GET XMT RETURN CODE
	STB	R0,LSCLKS+LSCXST,RLSC,	:PUT INTO RLSC
	L	R5,XMTRET,RL2,RL2	:GET RETURN ADDR
	LR	R0,R0			:XMT O.K. ?
	JNR	R5			:NO, NORMAL RETURN
	J	4,R5			:OK. SKIP RETURN

 
    	IF	TERMIF

	SUBTTL (HDXPRI) BASIC CONTROL MODULE FOR HALFDUPLEX PRI CU - SFGPTP
:PHDP00.G00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:*******************************************************:
:							:
:	PROTOCOL MANAGER (BASIC CONTROL MODULE) FOR 	:
:	HALF DUPLEX, PRIMARY AND POINT TO POINT     	:
:							:
:*******************************************************:


	IF	(DLCPHD)

	RA	0
	MO	.,SFGPTP

	LO	SFGPTP
	LO	FGGBDF
	LO	SNAEXC
	LO	GBLDEF
	LO	SFGXMT
	LO	SFGRCV
	LO	MAIN


	SEG	A.CODE


	SUBTTL (HDXPRI) XMT STATE TABLES FOR HDXPRI


:	HPXNDM:	NORMAL DISCONNECT MODE, WAITING SNRM FROM B.G.
:	-------------------------------------------------------
	HS	0
	HC	HPXDNU-PSEG		:-1 - NO CMD, DISMISS
HPXNDM	HC	HPXDRX-PSEG		:0  - RE-XMT CMD, RECOVER/DISMISS
	HC	HPXDIF-PSEG		:1  - INF CMD, DISCARD
	HC	HPXDSN-PSEG		:2  - SNRM CMD, XMT SNRM/HPRWOP STATE
	HC	HPXDUA-PSEG		:3  - UA CMD, NEC/ERROR
	HC	HPXDDS-PSEG		:4  - DISC CMD, DISCARD
	HC	HPXDDM-PSEG		:5  - DM CMD, NEC/ERROR
	HC	HPXDSM-PSEG		:6  - SIM CMD, XMT SIM/HPRWOP STATE
	HC	HPXDXD-PSEG		:7  - XID CMD, XMT XID/HPRDSP STATE
	HC	HPXDTS-PSEG		:8  - TEST CMD, XMT TEST/HPRDSP STATE
	HC	HPXDFR-PSEG		:9  - FRMR CMD, DISCARD


:	HPXTOP:	RIM FRAME RCV'ED, WAITING SIM CMD FROM B.G.
:	----------------------------------------------------
	HS	0
	HC	HPXTNU-PSEG		:-1 - NO CMD, DISMISS
HPXTOP	HC	HPXTRX-PSEG		:0  - RE-XMT CMD, RECOVER/DISMISS
	HC	HPXTIF-PSEG		:1  - INF CMD, DISCARD
	HC	HPXTSN-PSEG		:2  - SNRM CMD, DISCARD
	HC	HPXTUA-PSEG		:3  - UA CMD, NEC/ERROR
	HC	HPXTDS-PSEG		:4  - DISC CMD, XMT DISC/HPRWND STATE
	HC	HPXTDM-PSEG		:5  - DM CMD, NEC/ERROR
	HC	HPXTSM-PSEG		:6  - SIM CMD, XMT SIM/HPRWOP STATE
	HC	HPXTXD-PSEG		:7  - XID CMD, DISCARD
	HC	HPXTTS-PSEG		:8  - TEST CMD, DISCARD
	HC	HPXTFR-PSEG		:9  - FRMR CMD, DISCARD


:	HPXOPA:	NORMAL RESPONSE MODE, TRANSMIT I COMMANDS
:	-------------------------------------------------
	HS	0
	HC	HPXANU-PSEG		:-1 - NO CMD, DISMISS
HPXOPA	HC	HPXARX-PSEG		:0  - RE-XMT CMD, RE-XMT
	HC	HPXAIF-PSEG		:1  - INF CMD, XMT INF
	HC	HPXASN-PSEG		:2  - SNRM CMD, XMT SNRM/HPRWOP STATE
	HC	HPXAUA-PSEG		:3  - UA CMD,NEC/ERROR
	HC	HPXADS-PSEG		:4  - DISC CMD, XMT DISC/HPRWND STATE
	HC	HPXADM-PSEG		:5  - DM CMD, NEC/ERROR
	HC	HPXASM-PSEG		:6  - SIM CMD, XMT SIM/HPRWOP STATE
	HC	HPXAXD-PSEG		:7  - XID CMD, XMT XID/HPROSP STATE
	HC	HPXATS-PSEG		:8  - TEST CMD, XMT TEST/HPROSP STATE
	HC	HPXAFR-PSEG		:9  - FRMR CMD, DISCARD


:	HPXOPB:	NORMAL RESPONSE MODE, TRANSMIT S COMMANDS
:	-------------------------------------------------
	HS	0
	HC	HPXBNU-PSEG		:-1 - NO CMD, XMT S CMD
HPXOPB	HC	HPXBRX-PSEG		:0  - RE-XMT CMD, RECOVER/XMT S CMD
	HC	HPXBIF-PSEG		:1  - INF CMD, PEEK, XMT S CMD
	HC	HPXBSN-PSEG		:2  - SNRM CMD, XMT SNRM/HPRWOP STATE
	HC	HPXBUA-PSEG		:3  - UA CMD, NEC/ERROR
	HC	HPXBDS-PSEG		:4  - DISC CMD, XMT DISC/HPRWND STATE
	HC	HPXBDM-PSEG		:5  - DM CMD, NEC/ERROR
	HC	HPXBSM-PSEG		:6  - SIM CMD, XMT SIM/HPRWOP STATE
	HC	HPXBXD-PSEG		:7  - XID CMD, XMT XID/HPRDSP STATE
	HC	HPXBTS-PSEG		:8  - TEST CMD, XMT TEST/HPROSP STATE
	HC	HPXBFR-PSEG		:9  - FRMR CMD, DISCARD


:	HPXWND:	PWNDM STATE, WAITING DISC CMD FROM B.G.
:	-------------------------------------------------
	HS	0
	HC	HPXWNU-PSEG		:-1 - NO CMD, DISMISS
HPXWND	HC	HPXWRX-PSEG		:0  - RE-XMT CMD, RECOVER
	HC	HPXWIF-PSEG		:1  - INF CMD, DISCARD
	HC	HPXWSN-PSEG		:2  - SNRM CMD, XMT SNRM
	HC	HPXWUA-PSEG		:3  - UA CMD, NEC/ERROR
	HC	HPXWDS-PSEG		:4  - DISC CMD, XMT DISC/HPRWND STATE
	HC	HPXWDM-PSEG		:5  - DM CMD, NEC/ERROR
	HC	HPXWSM-PSEG		:6  - SIM CMD, NEC/DISCARD
	HC	HPXWXD-PSEG		:7  - XID CMD, NEC/DISCARD
	HC	HPXWTS-PSEG		:8  - TEST CMD, NEC/DISCARD
	HC	HPXWFR-PSEG		:9  - FRMR CMD, NEC/DISCARD


	SUBTTL (HDXPRI) RCV STATE TABLES FOR HDXPRI


:	HPRDSP:	NDM MODE, XID OR TEST SENT, WAITING FOR XID OR TEST
:	------------------------------------------------------------
HPRDSP
	HC	HPRSNU-PSEG		:0  - NO DATA, NO ACTION
	HC	HPRSIF-PSEG		:1  - INF FRAME, NEF/DISCARD
	HC	HPRSSN-PSEG		:2  - SNRM FRAME, NEF/DISCARD
	HC	HPRSUA-PSEG		:3  - UA FRAME, NEF/DISCARD
	HC	HPRSDS-PSEG		:4  - RD FRAME, NEF/DISCARD
	HC	HPRSDM-PSEG		:5  - DM FRAME, NEF/DISCARD
	HC	HPRSSM-PSEG		:6  - RIM FRAME, NEF/DISCARD
	HC	HPRSXD-PSEG		:7  - XID FRAME, LAST XID/HPXNDM STATE
	HC	HPRSTS-PSEG		:8  - TEST FRAME, LAST TEST/HPXNDM STATE
	HC	HPRSFR-PSEG		:9  - FRMR FRAME, NEF/DISCARD
	HC	HPRSRR-PSEG		:0A - RR FRAME, NEF/DISCARD
	HC	HPRSRN-PSEG		:0B - RNR FRAME, NEF/DISCARD
	HC	HPRSRJ-PSEG		:0C - REJ FRAME, NEF/DISCARD
	HC	HPRSCT-PSEG		:0D - 'C' FILED ERROR, DISCARD/NEF
	HC	HPRSIH-PSEG		:0E - I-FIELD PROHIBITED, DISCARD/NEF
	HC	HPRSOV-PSEG		:0F - FRAME TOO LONG, NEF/DISCARD
	HC	HPRSLN-PSEG		:10 - FRAME TOO SHORT, NEF/DISCARD
	HC	HPRSAU-PSEG		:11 - ADDR NOT CONFIG'ED, DISCARD
	HC	HPRSAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HPRSLS-PSEG		:13 - LOST DATA, NEF/DISCARD
	HC	HPRSTM-PSEG		:14 - TIME OUT, DISMISS


:	HPRWOP:	SNRM/SIM SENT, WAITING UA FROM EXTERNAL CU
:	-----------------------------------------------
HPRWOP
	HC	HPRTNU-PSEG		:0  - NO DATA, NO ACTION
	HC	HPRTIF-PSEG		:1  - INF FRAME, NEF/DISCARD/RET-XMT
	HC	HPRTSN-PSEG		:2  - SNRM FRAME, NEF/DISCARD/RE-XMT
	HC	HPRTUA-PSEG		:3  - UA FRAME, ENTER HPXNDM
	HC	HPRTDS-PSEG		:4  - RD FRAME, NEF/DISCARD/RE-XMT
	HC	HPRTDM-PSEG		:5  - DM FRAME, HPXNDM STATE
	HC	HPRTSM-PSEG		:6  - RIM FRAME, NEF/DISCARD/RE-XMT
	HC	HPRTXD-PSEG		:7  - XID FRAME, NEF/DISCARD/RE-XMT
	HC	HPRTTS-PSEG		:8  - TEST FRAME, NEF/DISCARD/RE-XMT
	HC	HPRTFR-PSEG		:9  - FRMR FRAME, RECOVERY
	HC	HPRTRR-PSEG		:0A - RR FRAME, NEF/DISCARD/RE-XMT
	HC	HPRTRN-PSEG		:0B - RNR FRAME, NEF/DISCARD/RE-XMT
	HC	HPRTRJ-PSEG		:0C - REJ FRAME, NEF/DISCARD/RE-XMT
	HC	HPRTCT-PSEG		:0D - C-FILED ERROR, DISCARD/RE-XMT
	HC	HPRTIH-PSEG		:0E - I-FIELD PROHIBITED, DISCARD/RE-XMT
	HC	HPRTOV-PSEG		:0F - FRAME TOO LONG, DISCARD/RE-XMT
	HC	HPRTLN-PSEG		:10 - FRAME TOO SHORT, DISCARD/RE-XMT
	HC	HPRTAU-PSEG		:11 - ADDR NOT CONFIG'ED, DISCARD
	HC	HPRTAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HPRTLS-PSEG		:13 - LOST DATA, DISCARD/RE-XMT
	HC	HPRTTM-PSEG		:14 - TIME OUT, RE-XMT


:	HPROPC:	NRM RECEIVING RESPONSE
:	---------------------------------
HPROPC
	HC	HPRCNU-PSEG		:0  - NO DATA, NO ACTION
	HC	HPRCIF-PSEG		:1  - INF FRAME, PROCESS
	HC	HPRCSN-PSEG		:2  - SNRM FRAME, NEF/DISCARD
	HC	HPRCUA-PSEG		:3  - UA FRAME, NEF/DISCARD
	HC	HPRCDS-PSEG		:4  - RD FRAME, ENTER HPXWND STATE
	HC	HPRCDM-PSEG		:5  - DM FRAME, ENTER HPXNDM STATE
	HC	HPRCSM-PSEG		:6  - RIM FRAME, ENTER HPXNDM STATE
	HC	HPRCXD-PSEG		:7  - XID FRAME, NEF/DISCARD
	HC	HPRCTS-PSEG		:8  - TEST FRAME, NEF/DISCARD
	HC	HPRCFR-PSEG		:9  - FRMR FRAME, PROCESS
	HC	HPRCRR-PSEG		:0A - RR FRAME, PROCESS
	HC	HPRCRN-PSEG		:0B - RNR FRAME, PROCESS
	HC	HPRCRJ-PSEG		:0C - REJ FRAME, NEF/DISCARD
	HC	HPRCCT-PSEG		:0D - C-FIELD ERROR, REC/DISCARD
	HC	HPRCIH-PSEG		:0E - I-FIELD PROHIBITED, REC/DISCARD
	HC	HPRCOV-PSEG		:0F - FRAME TOO LONG, DISCARD/RECOVER
	HC	HPRCLN-PSEG		:10 - FRAME TOO SHORT, DISCARD/RECOVERY
	HC	HPRCAU-PSEG		:11 - ADDR NOT CONFIG'ED, DISCARD
	HC	HPRCAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HPRCLS-PSEG		:13 - LOST DATA, DISCARD/REC
	HC	HPRCTM-PSEG		:14 - TIME OUT, RECOVER


:	HPROSP:	NRM XID/TEST SENT WAITING FOR XID/TEST
:	----------------------------------------------
HPROSP
	HC	HPRONU-PSEG		:0  - NO DATA, NO ACTION
	HC	HPROIF-PSEG		:1  - INF FRAME, DISCARD/NEF
	HC	HPROSN-PSEG		:2  - SNRM FRAME, DISCARD/NEF
	HC	HPROUA-PSEG		:3  - UA FRAME, DISCARD/NEF
	HC	HPRODS-PSEG		:4  - RD, DISCARD/NEF
	HC	HPRODM-PSEG		:5  - DM FRAME, DISCARD/NEF
	HC	HPROSM-PSEG		:6  - RIM FRAME, DISCARD/NEF
	HC	HPROXD-PSEG		:7  - XID FRAME, PROCESS/HPXOPA STATE
	HC	HPROTS-PSEG		:8  - TEST FRAME, PROCESS/HPXOPA STATE
	HC	HPROFR-PSEG		:9  - FRMR FRAME, DISCARD/NEF
	HC	HPRORR-PSEG		:0A - RR FRAME, DISCARD/NEF
	HC	HPRORN-PSEG		:0B - RNR FRAME, DISCARD/NEF
	HC	HPRORJ-PSEG		:0C - REJ FRAME, DISCARD/NEF
	HC	HPROCT-PSEG		:0D - C-FIELD ERROR, DISCARD
	HC	HPROIH-PSEG		:0E - I-FIELD PROHIBITED, DISCARD
	HC	HPROOV-PSEG		:0F - FRAME TOO LONG, DISCARD/NEF
	HC	HPROLN-PSEG		:10 - FRAME TOO SHORT, DISCARD/NEF
	HC	HPROAU-PSEG		:11 - ADDR NOT CONFIG'ED, DISCARD
	HC	HPROAD-PSEG		:12 - ADDR NOT DESIRED,DISCARD
	HC	HPROLS-PSEG		:13 - LOST DATA, DISCARD/NEF
	HC	HPROTM-PSEG		:14 - TIME OUT, ENTER HPXNDM STATE


:	HPRWND:	DISC SENT, WAITING FOR DM/UA FROM EXTERNAL CU
:	-----------------------------------------------------
HPRWND
	HC	HPRWNU-PSEG		:0  - NO DATA, NO ACTION
	HC	HPRWIF-PSEG		:1  - INF FRAME, DISCARD/RE-XMT
	HC	HPRWSN-PSEG		:2  - SNRM FRAME, DISCARD/NEF
	HC	HPRWUA-PSEG		:3  - UA FRAME, PROCESS/HPXNDM STATE
	HC	HPRWDS-PSEG		:4  - RD FRAME, DISCARD/RE-XMT
	HC	HPRWDM-PSEG		:5  - DM FRAME, PROCESS/HPXNDM STATE
	HC	HPRWSM-PSEG		:6  - RIM FRAME, DISCARD/RE-XMT
	HC	HPRWXD-PSEG		:7  - XID FRAME, DISCARD/RE-XMT
	HC	HPRWTS-PSEG		:8  - TEST FRAME, DISCARD/RE-XMT
	HC	HPRWFR-PSEG		:9  - FRMR FRAME, RECOVERY
	HC	HPRWRR-PSEG		:0A - RR FRAME, DISCARD/RE-XMT
	HC	HPRWRN-PSEG		:0B - RNR FRAME, DISCARD/RE-XMT
	HC	HPRWRJ-PSEG		:0C - REJ FRAME, DISCARD/RE-XMT
	HC	HPRWCT-PSEG		:0D - C-FIELD ERROR, RE-XMT
	HC	HPRWIH-PSEG		:0E - I-FIELD PROHIBITED, RE-XMT
	HC	HPRWOV-PSEG		:0F - FRAME TOO LONG, RE-XMT
	HC	HPRWLN-PSEG		:10 - FRAME TOO SHORT, RE-XMT
	HC	HPRWAU-PSEG		:11 - ADDR NOT CONFIG'ED, DISCARD
	HC	HPRWAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HPRWLS-PSEG		:13 - LOST DATA, RE-XMT
	HC	HPRWTM-PSEG		:14 - TIME OUT, RE-XMT


	SUBTTL (HDXPRI) PROCESSING ROUTINES FOR HDXPRI IN HPXNDM STATE


:	HPXDNU: NDM, NO CMD QUEUED
:	-----------------------------
:	SCHEDULE TO RUN NEXT CU, AND EXIT
HPXDNU
	J	HPXNX1


:	HPXDRX: RE-XMT
:	-------------
:	CLEAR RE-XMT COUNT (LSCRXC), ADJUST IC COUNTER
:	SCHEDULE NEXT CU, DISMISS
HPXDRX
	LB	R5,LSCLKS+LSCRXC,RLSC,	:GET LSCRXC
	LIS	R0,0
	STB	R0,LSCLKS+LSCRXC,RLSC,	:CLEAR RE-XMT COUNTER
	SR	R0,R5			:R0 = NEGATIVE RE-XMT COUNT
	AHM	R0,LSCLKS+LSCIFC,RLSC,	:ADJUST IC COUNTER
	J	HPXNX1			:TO RUN NEXT CU, AND EXIT


:	HPXDIF: NDM, INF CMD IN XMT QUEUE
:	----------------------------------
:	DELETE THIS INF CMD, SCHEDULE TO RUN NEXT CU, EXIT
HPXDIF
	J	HPXNXT			:TO DELETE CMD, RUN NEXT, AND EXIT


:	HPXDSN/HPXDSM: NDM MODE, SNRM/SIM CMD IN XMT QUEUE
:	------------------------------------------
:	XMT/SIM SNRM  FRAME, AND ENTER HPRWOP STATE
:	 SET RC FOR POLLING RETRY
HPXDSN
HPXDSM
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,SETSEQ		:SET POLLING RETRY SEQUENCE
	JAL	R5,SETSRC		:SET POLLING RETRY LIMIT
	JAL	R5,FHXMTQ		:FETCH CMD
	STB	R1,LSCLKS+LSCCXC,RLSC,	:PUT XMT OP CODE (R1) TO LSC
HPXDS1
	LB	R1,LSCLKS+LSCCXC,RLSC,	:GET CURRENT XMT OP CODE
	JAL	R5,SETOPF		:SNRM/SIM ALWAYS HAS P BIT ON
	JAL	R5,SXMT			:XMT THIS FRAME
	J	HPDISC			:XMT ERROR,....
	JAL	R5,DECSRC		:DECREASE RC COUNT BY 1
	LHI	R0,HPRWOP-PSEG		:ENTER HPRWOP STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	LB	R1,LSCLKS+LSCCXC,RLSC,	:GET LAST XMT OP CODE
	CLHI	R1,XCSNRM		:SEE IF SNRM
	JN	HPX.R			:TO SET T1 AND TO RCV
	JAL	R5,SETTPO		:ELSE, SET POLLING TIMER
	J	HPX.R1			:SWITCH FROM XMT TO RCV


:	HPXDUA/HPXDDM/HPXDFR: NDM MODE, UA/DM/FRMR CMD IN XMT QUEUE
:	----------------------------------------------------------
:	THIS IS AN IMPLEMENTAION ERROR
HPXDUA
HPXDDM
HPXDFR
	J	HPCRSH			:TO CRASH


:	HPXDDS: DISC CMD IN XMT QUEUE
:	------------------------------
:	XMT DISC FRAME, AND ENTER HPRWND STATE
HPXDDS
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,SETSEQ		:SET RC SEQ COUNT
	JAL	R5,SETSRC		:SET RC COUNT
	JAL	R5,FHXMTQ		:FETCH CMD
	STB	R1,LSCLKS+LSCCXC,RLSC,	:PUT XMT OP CODE (R1) TO LSC
HPXDD1
	LB	R1,LSCLKS+LSCCXC,RLSC,	:GET CURRENT XMT OP CODE
	JAL	R5,SETOPF		:DISC ALWAYS HAS P BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HPDISC			:XMT ERROR, DISC
	JAL	R5,DECSRC		:DECREASE RC COUNT BY 1
	LHI	R1,HPRWND-PSEG		:ENTER HPRWND STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	LHI	R0,HPTRM4-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPX.R			:SWITCH FROM XMT TO RCV


:	HPXDXD/HPXDTS: NDM MODE, XID/TEST CMD IN XMT QUEUE
:	-------------------------------------------------------
:	XMT XID/TEST FRAME, AND ENTER HPRDSP STATE
HPXDXD
HPXDTS
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,CLRRXT		:CLEAR RXTBIT
	JAL	R5,SETSEQ		:SET RETRY SEQ COUNT
	JAL	R5,SETSRC		:SET RETRY COUNT
	JAL	R5,FHXMTQ		:FETCH CMD
	STB	R1,LSCLKS+LSCCXC,RLSC,	:PUT XMT OP CODE (R1) TO LSC
HPXDT1
	LB	R1,LSCLKS+LSCCXC,RLSC,	:GET CURRENT XMT OP CODE
	JAL	R5,SETOPF		:XID/TEST ALWAYS HAS P BIT ON
	JAL	R5,SXMT			:XMT THIS FRAME
	J	HPDISC			:XMT ERROR,....
	JAL	R5,DECSRC		:DECREASE RC COUNT BY 1
	LHI	R0,HPRDSP-PSEG		:ENTER HPRDSP STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:ENTER NEW STATE
	J	HPX.R			:SWITCH FROM XMT TO RCV


	SUBTTL (HDXPRI) PROCESSING ROUTINES FOR HDXPRI IN HPXTOP STATE


:	HPXTNU: NO CMD
:	--------------
:	DISMISS
HPXTNU
	J	HPXNX1			:TO RUN NEXT CU


:	HPXTRX: RE-XMT CMD IN XMT QUEUE
:	-------------------------------
:	CLEAR RE-XMT COUNTER (LSCRXC), ADJUST IC COUNTER
:	DISMISS
HPXTRX
	LB	R5,LSCLKS+LSCRXC,RLSC,	:GET LSCRXC
	LIS	R0,0
	STB	R0,LSCLKS+LSCRXC,RLSC,	:CLEAR RE-XMT COUNTER
	SR	R0,R5			:R0 = NEGATIVE RE-XMT COUNT
	AHM	R0,LSCLKS+LSCIFC,RLSC,	:ADJUST IC COUNT
	J	HPX.X			:DISMISS


:	HPXTIF/HPXTSN/HPXTXD/HPXTTS: INF/SNRM/XID/TEST CMD IN XMT QUEUE
:	---------------------------------------------------------------
:	DISCARD THIS CMD FROM XMT QUEUE
HPXTIF
HPXTSN
HPXTXD
HPXTTS
	J	HPXNXT			:TO DELETE CMD, RUN NEXT, AND EXIT


:	HPXTUA/HPXTDM/HPXTFR: UA/DM/FRMR CMD IN XMT QUEUE
:	-----------------------------------------------
:	IMPLEMENTAION ERROR
HPXTUA
HPXTDM
HPXTFR
	J	HPCRSH			:TO CRASH


:	HPXTDS: DISC CMD IN XMT QUEUE
:	------------------------------
:	XMT DISC FRAME, AND ENTER HPRWND STATE
HPXTDS
	J	HPXDDS			:SAME AS HPXDDS


:	HPXTSM: SIM CMD IN XMT QUEUE
:	----------------------------
:	XMT SIM AND ENTER HPRWOP STATE
HPXTSM
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,SETSEQ		:SET RC SQE  COUNT
	JAL	R5,SETSRC		:SET RC COUNT
	JAL	R5,FHXMTQ		:FETCH CMD
	STB	R1,LSCLKS+LSCCXC,RLSC,	:PUT XMT OP CODE (R1) TO LSC
HPXTS1
	LB	R1,LSCLKS+LSCCXC,RLSC,	:GET CURRENT XMT OP CODE
	JAL	R5,SETOPF		:SET P BIT
	JAL	R5,SXMT			:DO THE XMT
	J	HPDISC			:IF XMT ERROR, DISC
	JAL	R5,DECSRC		:DECREASE RC BY 1
	LHI	R0,HPRWOP-PSEG		:ENTER HPRWOP STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:....
	J	HPX.R			:SWITCH FROM XMT TO RCV


	SUBTTL (HDXPRI) PROCESSING ROUTINE FOR HDXPRI IN HPXOPA STATE


:	HPXANU: NRM MODE, NO CMD IN XMT QUEUE
:	--------------------------------------
:	IF TRR TIMER UP
:	DECIDE TO SEND RR OR RNR
:	ELSE, DISMISS
HPXANU
	JAL	R5,CHKTRR		:TIME TO XMT RR/RNR?
	J	HPX.X			:NO, DISMISS
	J	HPOPA1			:ELSE, SAME AS DIFF=K WHEN IC > 0


:	HPXARX:	RE-XMT
:	---------------
:	RE-XMT I-FRAMES, DETAILS SEE ECMA-71 DIAGRAMS
:	(THE SAME AS INF CMD)
HPXARX


:	HPXAIF: NRM MODE, INF CMD IN XMT QUEUE
:	----------------------------------------
:	XMT I-FRAMES, DETAILS SEE ECMA-71 DIAGRAM
HPXAIF
HPOPA0
	LHL	R3,LSCLKS+LSCIFC,RLSC,	:GET IC VALUE
	JAL	R5,GETDIF		:DIFF=V(S)-VSU, IN R1, MAXW IN R6
	CR	R1,R6			:COMPRAE DIFF TO MAX WINDOW
	JGE	HPOPA1			:DIFF >= K, SKIP
	CHI	R3,1			:SEE IF MORE THAN 1 FRAME
	JLE	HPXAI1			:JUMP ,IF IC<=1 (REALLY IC = 1)
	LR	R0,R6			:MOVE K TO R0
	SIS	R0,1			:R0 = K-1
	CR	R1,R0			:COMPARE DIFF TO (K-1)
	JL	HPOPA3			:(IC>1) ^ (DIFF<K-1)
:	ENTRY:(IC=1 & DIFF<K) OR (IC>1 & DIFF=K-1)
:	IF BUSY, XMT INF FRAME WITH P BIT OFF
:	ELSE, XMT INF FRAME WITH P BIT ON
HPXAI1
	JAL	R5,CHKBSY		:GOTO CHECK BUSY OR NOT
	J	HPOPA4			:NOT BUSY, XMT INF FRAME WITH P ON
	J	HPOPA3			:BUSY, XMT INF FRAME WITH P BIT OFF
 

:	WHEN	DIFF=K
:	------------------
:	IF BUSY, XMT RNR
:	ELSE, XMT RR
HPOPA1
	JAL	R5,CLRTRR		:CLEAR TRR TIMER
	LHI	R1,XCRR			:ASSUME NOT BUSY
	JAL	R5,CHKBSY		:CHECK BUSY
	J	HPOPA2			:NOT BUSY, SKIP
	LHI	R1,XCRNR		:ELSE, XMT RNR
HPOPA2
	JAL	R5,SETOPF		:SET XMT WITH P BIT ON
	JAL	R5,SXMT			:SIO XMT
	J	HPDISC			:DISC,IF XMT TIME-OUT

	J	HPXAI2			:TO ENTER HPROPC STATE


:	WHEN	(IC>1) AND (DIFF<(K-1))	OR
:		((IC>0) AND (DIFF<K) AND BUSY)
:	--------------------------------------
:	XMT INF FRAME WITH P BIT OFF
HPOPA3
	JAL	R5,FHXMTQ		:FETCH XMT INF. FRAME PARAMETER
	JAL	R5,SXMT			:GOTO XMT ROUTINE
	J	HPDISC			:DISC,IF XMT TIME-OUT
	JAL	R5,INCVS		:INCREASE VS
	JAL	R5,DECIC		:DECREMENT IC BY 1
	J	HPX.X			:CONTINUE TO XMT


:	WHEN	(IC=1) AND (NOT BUSY), OR
:		(DIFF=K-1) AND (IC>1) AND (NOT BUSY)
:	--------------------------------------------
:	XMT INF FRAME WITH P BIT ON
HPOPA4
:	JAL	R5,SETOPF		:SETXMT WITH P BIT ON(11/07/85/CHS)
	JAL	R5,FHXMTQ		:FETCH XMT CMD PARAMETER
	JAL	R5,SXMT			:XMT
	J	HPDISC			:DISC,IF XMT TIME-OUT
	JAL	R5,DECIC		:DECREMENT IC BY 1
	JAL	R5,INCVS		:INCREASE VS BY 1
	JAL	R5,SETTRR		:WAIT BEFORE SENT RR (11/07/85/CHS)
	J	HPX.X			:CONTINUE TO XMT (11/07/85/CHS)
:	HPXAI2:	TO ENTER HPROPC STATE
:	------------------------------
HPXAI2
	LHI	R0,HPROPC-PSEG		:ENTER RCV REPONSE STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:....
	J	HPX.R			:SWITCH FROM XMT TO RCV STATE


:	HPXASN: SRNM CMD IN THE XMT QUEUE
:	----------------------------------
:	SAME AS HPXDSN
HPXASN
	J	HPXDSN


:	HPXAUA/HPXADM/HPXAFR: UA/DM/FRMR CMD IN THE XMT QUEUE
:	----------------------------------------------------
:	IMPLEMENTAION ERROR
HPXAUA
HPXADM
HPXAFR
	J	HPCRSH			:TO CRASH


:	HPXADS: DISC CMD IN THE XMT QUEUE
:	---------------------------------
:	XMT DISC FRAME, AND ENTER HPRWND STATE
HPXADS
	J	HPXDDS			:SAME AS HPXDDS


:	HPXASM: NRM MODE, SIM CMD IN THE XMT QUEUE
:	------------------------------------------
:	XMT SIM FRAME, AND ENTER HPRWOP STATE
HPXASM
	J	HPXDSM			:SAME AS SIM IN HPXNDM STATE


:	HPXAXD/HPXATS: XID/TEST CMD IN THE XMT QUEUE
:	--------------------------------------------------
:	XMT XID/TEST FRAME, AND ENTER HPROSP STATE
HPXAXD
HPXATS
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,CLRRXT		:CLEAR RXTBIT
	JAL	R5,SETSEQ		:SET RC SEQ COUNT
	JAL	R5,SETSRC		:SET RC COUNT
	JAL	R5,FHXMTQ		:FETCH CMD FROM XMT QUEUE
	STB	R1,LSCLKS+LSCCXC,RLSC,	:PUT XMT OP CODE (R1) TO LSC
HPXAT1
	LB	R1,LSCLKS+LSCCXC,RLSC,	:GET CURRENT XMT OP CODE
	JAL	R5,SETOPF		:SET XMT WITH P BIT ON
	JAL	R5,SXMT			:SIO XMT
	J	HPDISC			:DISC,IF XMT TIME-OUT
	JAL	R5,DECSRC		:DECREASE RC BY 1
	LHI	R0,HPROSP-PSEG		:ENTER HPROSP STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HPX.R			:SWITCH FROM XMT TO RCV


	SUBTTL (HDXPRI) PROCESSING ROUTINE FOR HDXPRI IN HPXOPB STATE


:	HPXBNU/HPXBRX/HPXBIF/HPXBTS: NULL/RE-XMT/INF/TEST
:	--------------------------------------------------
HPXBNU
HPXBRX
HPXBIF
HPXBTS
	LB	R0,LSCLKS+LSCRCB,RLSC,	:IS RCB = 0?
	JE	HPXB03			:YES, TO SET PBUSY
	LB	R0,LSCLKS+LSCSRC,RLSC,	:IS RC = 0?
	JE	HPXB02			:YES, TO SET PINOP
	LHI	R1,XCRR			:ESLE, ASSUME NO BUSY
	JAL	R5,CHKBSY		: SEE IF BUSY
	J	HPXB01			:NO, TO XMT RR
	LHI	R1,XCRNR		:ELSE, XMT RNR
HPXB01
	JAL	R5,SETOPF		:RR/RNR HAS P BIT ON
	JAL	R5,SXMT			:DO SIO XMT
	J	HPDISC			:XMT ERROR, DISC
	LHI	R0,HPROPC-PSEG		:ELSE, ENTER HPROPC STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HPX.R			:SWITCH FROM XMT TO RCV

HPXB02
	JAL	R5,SETSRC		:RESET RETRY CNT
	JAL	R5,DECSEQ		:DECREASE RETRY SEQ
	LB	R0,LSCLKS+LSCSEQ,RLSC,	:IS SEQ = 0?
	LR	R0,R0
	JN	HPXBNU			:NO, TO RE-XMT FRAME
	LHI	R1,UPINOP+CSTATE	:QUEUE INOP STATUS TO RCV QUEUE
	JFS	HPXB04

HPXB03
	LHI	R1,UPBUSY+CSTATE	:QUEUE PBUSY STATUS TO RCV QUEUE

HPXB04
	JAL	R5,QUECMD		:QUEUE STATUS TO RCV QUEUE
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRMI-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPX.X			:ENTER NDM MODE


:	HPXBUA/HPXBDM/HPXBFR: UA/DM/FRMR CMD IN XMT QUEUE
:	-------------------------------------------------
:	IMPLEMENTAION ERROR
HPXBUA
HPXBDM
HPXBFR
	J	HPCRSH			:TO CRASH


:	HPXBSN/HPXBSM: SNRM/SIM CMD IN XMT QUEUE
:	-----------------------------------------
:	XMT SNRM/SIM (SAME AS SNRM/SIM CMD IN HPXNDM STATE)
HPXBSN
HPXBSM
	J	HPXDSN


:	HPXBDS:	DISC CMD IN XMT QUEUE
:	------------------------------
:	XMT DISC FRAME, AND ENTER HPRWND STATE
HPXBDS
	J	HPXDDS			:SAME AS HPXDDS


:	HPXBXD: XID CMD IN XMT QUEUE
:	-----------------------------
:	XMT XID FRAME, AND ENTER HPRDSP STATE (SAME AS XID IN HPXNDM STATE)
HPXBXD
	J	HPXDXD			:SAME AS HPXDXD


	SUBTTL (HDXPRI) PROCESSING ROUTINE FOR HDXPRI IN HPXWND STATE


:	HPXWNU/HPXWIF/HPXWSM/HPXWXD/HPXWTS
:	----------------------------------------
:	INF/SIM/XID/TEST CMD IN THE XMT QUEUE, DISCARD
:
HPXWNU
HPXWIF
HPXWSN
HPXWSM
HPXWXD
HPXWTS
	J	HPXNXT			:TO DELETE CMD, RUN NEXT, AND EXIT


:	HPXWRX: RE-XMT 
:	----------------
:	CLEAR RE-XMT COUNT (LSCRXC), ADJUST IC COUNTER
:	CONTINUE TO XMT
HPXWRX
	LB	R5,LSCLKS+LSCRXC,RLSC,	:GET LSCRXC
	LIS	R0,0
	STB	R0,LSCLKS+LSCRXC,RLSC,	:CLEAR RE-XMT COUNTER
	SR	R0,R5			:R0 = NEGATIVE RE-XMT COUNT
	AHM	R0,LSCLKS+LSCIFC,RLSC,	:ADJUST IC COUNTER
	J	HPX.X			:CONTINUE TO XMT


:	HPXWSN: SNRM CMD
:	----------------
:	XMT SNRM , AND ENTER HPRWOP STATE
HPXWSN
	J	HPXDSN			:SAME AS HPXDSN
:	HPXWUA/HPXWDM/HPXWFR: UA/DM/FRMR CMD IN THE XMT QUEUE
:	-----------------------------------------------------
:	IMPLEMENTAION ERROR
HPXWUA
HPXWDM
HPXWFR
	J	HPCRSH			:TO CRASH


:	HPXWDS: DISC CMD IN THE XMT QUEUE
:	---------------------------------
:	XMT THE DISC FRAME, AND ENTER HPRWND STATE
HPXWDS
	J	HPXDDS			:SAME AS HPXDDS


	SUBTTL (HDXPRI) PROCESSING ROUTINE FOR HDXPRI IN HPRDSP STATE


:	HPRSIF/HPRSRR/HPRSRN/HPRSRJ/HPRSSN/HPRSDS/HPRSSM/HPRSUA
:	HPRSUA/HPRSCT/HPRSIH/HPRSOV/HPRSLN/HPRSAU/HPRSAD/HPRSLS
:	-----------------------------------------------------
:	IGNORE THIS FRAME, IF F BIT SET, ENTER HPXNDM STATE
:	ELSE CONTINUE TO RCV
HPRSIF
HPRSRR
HPRSRN
HPRSRJ
HPRSSN
HPRSDS
HPRSSM
HPRSUA
HPRSDM
HPRSCT
HPRSIH
HPRSOV
HPRSLN
HPRSAU
HPRSAD
HPRSLS
	JAL	R5,IDELET		:DELETE RCV BUFFER
	LHI	R1,UPNEF+CSTATE		:QUEUE NEF RCV'ED STATUS TO RCV QUEUE
	JAL	R5,CHKIPF		:SEE IF RCV'ED FRAME HAS F BIT SET
	J	HPRSL2			:NO, TO RCV AGAIN
					:ELSE, SKIP RETURN, CONTINUE
HPRSL1
	JAL	R5,QUECMD		:QUEUE THE STATUS TO RCV QUEUE
HPRSL0
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:..
	J	HPR.X			:SWITCH FROM RCV TO XMT STATE


:	CONTINUE TO RECEIVE
HPRSL2
	J	HPR.R			:CONTINUE RCV


:	HPRSFR: RCV'ED FRMR WHEN IN THE HPRDSP STATE
:	--------------------------------------------
:	LOG THE EVENT, IFNORE THE RCV'ED FRAME
:	IF F BIT SET, ENTER HPXNDM STATE, ELSE CONTINUE TO RCV
HPRSFR
	JAL	R5,CHKIPF		:IS RCV'ED FRAME WITH F BIT ON?
	J	HPRSLS			:NO, CONTINUE TO RCV
	LHI	R1,CFRMR		:QUEUE FRMR CMD
	JAL	R5,QUECMD		:QUEUE IT
	J	HPRSL1			:GO TO HPRSL1


:	HPRSXD/HPRSTS: RCV'ED XID/TEST WHEN IN THE HPRDSP STATE
:	-------------------------------------------------------
:	PROCESS THE RCV'ED FRAME IF F BIT SET, ELSE DISCARD THE RCV'ED
:	ALWAYS ENTER HPXNDM STATE
HPRSXD
HPRSTS
	JAL	R5,CHKIPF		:IS INPUT FRAME HAS F BIT SET?
	J	HPRSIF			:NO, SKIP TO DISCARD THE RCV'ED FRAME
	LB	R1,LSCLKS+LSCRST,RLSC,	:GET RC CODE
	CLB	R1,LSCLKS+LSCCXC,RLSC,	:IS THE RC THE SAME AS XMT OP CODE?
	JN	HPRSLS			:NO, SKIP TO DISCARD THE RCV'ED FRAME
	JAL	R5,QUEETE		:QUEUE THE CMD WITH DATA TO B.G.
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT


:	HPRSTM: TIMEOUT 
:	----------------
:	ENTER HPXNDM STATE
HPRSTM
	LB	R0,LSCLKS+LSCSRC,RLSC,	:IS RC = 0?
	JN	HPXRUF			:NO, SKIP
	JAL	R5,SETSRC		:RESET RETRY CNT
	JAL	R5,DECSEQ		:DECREASE RETRY SEQ
	LB	R0,LSCLKS+LSCSEQ,RLSC,	:IS SEQ = 0?
	LR	R0,R0
	JN	HPXRUF			:NO, TO RE-XMT FRAME
	LHI	R1,UPINOP+CSTATE	:SET TO PINOP STATUS
	J	HPRSL1			:GO TO HPRSL1

HPRST1
	JAL	R5,SETRXT		:SET RE-XMT XID/TEST FRAME
	J	HPXDT1			:TO DO RE-XMT


	SUBTTL (HDXPRI) PROCESSING ROUTINE FOR HDXPRI IN HPRWOP STATE


:	HPRTIF/HPRTXD/HPRTTS/HPRTRR/HPRTRN/HPRTRJ/HPRTDS/HPRTSN
:	HPRTRJ/HPRTDS/HPRTSN/HPRTOV/HPRTLN/HPRTAU/HPRTAD/HPRTLS
:	---------------------------------------------------------
:	IF F BIT SET AND RC NOT= 0, RE-XMT SNRM FRAME
:	IF F BIT SET BUT RC = 0, QUEUE PINOP STATUS TO RCV QUEUE
:	ELSE, CONTINUE TO RCV
HPRTIF
HPRTXD
HPRTTS
HPRTRR
HPRTRN
HPRTRJ
HPRTDS
HPRTSN
HPRTSM
HPRTCT
HPRTIH
HPRTOV
HPRTLN
HPRTAU
HPRTAD
HPRTLS
	JAL	R5,IDELET		:DELETE THE RCV'ED BUFFER
	JAL	R5,CHKIPF		:IS RCV'ED FRAME F BIT ON?
	J	HPRTL2			:NO, TO RCV AGAIN

HPRTL1
	LB	R0,LSCLKS+LSCSRC,RLSC,	:IS RC = 0 ?
	JN	HPXRUF			:NO, TO RE-XMT SNRM FRAME
	JAL	R5,SETSRC		:RESET RETRY CNT
	JAL	R5,DECSEQ		:DECREASE RETRY SEQ
	LB	R0,LSCLKS+LSCSEQ,RLSC,	:IS SEQ = 0?
	LR	R0,R0
	JN	HPXRUF			:NO, TO RE-XMT SNRM FRAME
	LHI	R1,UPINOP+CSTATE	:QUEUE INOP STATUS TO RCV QUEUE
	J	HPRSL1			:TO HPRSL1

HPRTL2
	J	HPR.R			:TO CONTINUE RCV


:	HPRTFR: RCV'ED FRMR
:	-------------------
:	IF F BIT OFF, TO RCV
:	ELSE, LOG THE EVENT, AND ENTER HPXNDM STATE
HPRTFR
	JAL	R5,CHKIPF		:IS THE RCV'ED FRAME WITH F BIT ON?
	J	HPRSLS			:NO, CONTINUE TO RCV
	LHI	R1,CFRMR		:QUEUE FRMR CMD
	JAL	R5,QUECMD		:QUEUE IT
	J	HPRSL0			:TO ENTER HPXNDM STATE


:	HPRTUA: RCV'ED UA WHEN IN HPRWOP STATE
:	---------------------------------------
:	IF F BIT NOT SET, CONTINUE TO RCV
:	ELSE
:	QUEUE UA TO RCV QUEUE AND
:	IF LAST SENT SIM, ENTER HPXNDM STATE
:	IF LAST SENT SNRM, ENTER HPXOPA STATE AND
:	DELETE ANY SNRM CMD IN THE XMT QUEUE
:	(SET UP TURN AROUND TIMER), AND ENTER HPXOPA STATE
HPRTUA
	JAL	R5,CHKIPF		:IS RCV'ED FRAME WITH F BIT ON?
	J	HPRTU4			:NO, SKIP TO CONTINUE RCV
	LHI	R1,CUA			:QUEUE THE UA CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT TO RCV QUEUE
	LB	R0,LSCLKS+LSCCXC,RLSC,	:GET LAST XMT OP CODE
	CLHI	R0,XCSNRM		:LAST SENT WAS SNRM?
	JE	HPRTU1			:YES, SKIP
	LHI	R0,HPXNDM-PSEG		:ELSE, MUST SIM, ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HPRTU3			:SKIP,..
HPRTU1
	JAL	R5,PKXMTQ		:PEEK THE XMT CMD
	CLHI	R1,CSNRM		:A SNRM CMD AGAIN?
	JN	HPRTU2			:NO, SKIP
	JAL	R5,DQXMTQ		:ELSE, DELETE THIS CMD
	JBS	HPRTU1
HPRTU2
	JAL	R5,CLRVSR		:RESET VS AND VR
	JAL	R5,CLRNSR		:RESET NS AND NR
	LHI	R0,HPXOPA-PSEG		:ENTER HPXOPA STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRM2-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:..
	JAL	R5,CLRRT1		:RESET RT1 TIMER
	JAL	R5,SETSEQ		:SET RC SEQ COUNT
	JAL	R5,SETSRC		:SET RC
	JAL	R5,SETRCB		:SET RCB
HPRTU3
	J	HPR.X			:ENTER XMT STATE

HPRTU4
	J	HPRTL2			:SAME AS HPRTL2


:	HPRTDM: RCV'ED DM WHEN IN PRWOP STATE
:	-----------------------------------------
:	IF F BIT ON, THEN QUEUE DM CMD TO RCV QUEUE
:	ELSE, IGNORE, AND CONTINUE TO RCV
HPRTDM
	JAL	R5,CHKIPF		:IS RCV'ED FRAME F BIT ON?
	J	HPRTD1			:NO, SKIP TO CONTINUE RCV
	LHI	R1,CDM			:QUEUE DM CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HPR.X			:ENTER XMT STATE

HPRTD1
	J	HPRTL2			:TO CONTINUE RCV

:	HPRTTM: TIMOUT 
:	--------------
:
HPRTTM
	J	HPRTL1			:GO TO HPRTL1


	SUBTTL (HDXPRI) PROCESSING ROUTINE FOR HDXPRI IN HPROPC STATE


:	HPRCIF: RCV'ED INF FRAME
:	----------------------------
:	IF GOOD FRAME, QUEUE TO RCV QUEUE
:	AND IF F BIT ON, SWITCH FROM RCV TO XMT STATE (HPXOPA)
:		ELSE, CONTINUE TO RCV
HPRCIF
	JAL	R5,CHKIPF		:IS RCV'ED FRAME WITH F BIT ON?
	J	HPRCI2			:NO, SKIP
	JAL	R5,CKNSVR		:ELSE, IS N(S)=V(R) ?
	J	HPRCI1			:NO, SKIP (F=0 & N(S) NOT= V(R))

:	(F=1) & (N(S)=V(R))
:	---------------------
	JAL	R5,CHKNR		:N(R) IN [VSU, V(S)]? (8/13/85/CHS)
	J	HPRCIY			:NO, SKIP (8/13/85/CHS)
HPRCIX					:.. (8/13/85/CHS)
	JAL	R5,INCVR		:V(R)=V(R)+1
	JAL	R5,INCIC		:IC=IC+V(S)-N(R)
	JAL	R5,SETUSR		:VSU=V(S)=N(R)
	JAL	R5,QUEINF		:QUEUE INF FRAME TO RCV QUEUE
	LHI	R0,HPXOPA-PSEG		:ENTER HPXOPA STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	JAL	R5,CLRRT1		:RESET RT1 TIMER
	JAL	R5,SETSEQ		:SET RC SEQ COUNT
	JAL	R5,SETSRC		:SET RC COUNT
	JAL	R5,SETRCB		:SET RCB COUNT
	J	HPR.X			:SWITCH FROM RCV TO XMT STATE
HPRCIY					:(8/13/85/CHS)
	LB	R0,LSCLKS+LSCVSU,RLSC,	:RESTORE N(R) (8/13/85/CHS)
	STB	R0,LSCLKS+LSCNRR,RLSC,	:.. (8/13/85/CHS)
	J	HPRCIX			: TO CONTINUE (8/13/85/CHS)

:	(F=1) AND (N(S) NOT= V(R))
:	----------------------------
HPRCI1
	LB	R0,LSCLKS+LSCVSU,RLSC,	:IGNORE RCV'ED N(R) (8/13/85/CHS)
	STB	R0,LSCLKS+LSCNRR,RLSC,	:BY RESTORE N(R) (8/13/85/CHS)
	JAL	R5,INCIC		:IC=IC+V(S)-N(R)
	JAL	R5,SETUSR		:VSU=V(S)=N(R)
	JAL	R5,IDELET		:DISCARD THIS RCV'ED FRAME
	LHI	R0,HPXOPA-PSEG		:ENTER HPXOPA STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	JAL	R5,CLRRT1		:RESET RT1 TIMER
	JAL	R5,SETSEQ		:SET RC SEQ COUNT
	JAL	R5,SETSRC		:SET RC COUNT
	JAL	R5,SETRCB		:SET RCB COUNT
	J	HPR.X			:SWITCH FROM RCV TO XMT STATE

:	(F = 0)
:	-----------
HPRCI2
	JAL	R5,CKNSVR		:IS N(S) = V(R) ?
	J	HPRCI3			:NO, TO DISCARD THIS FRAME
:	(F = 0) &  (N(S) = V(R))
	JAL	R5,CHKNR		:N(R) IN [VSU, V(S)]? (8/13/85/CHS)
	J	HPRCIW			:NO, SKIP (8/13/85/CHS)
HPRCIZ					: (8/13/85/CHS)
	JAL	R5,INCVR		:INC. V(R)
	JAL	R5,SETUR		:SET VSU=N(R)
	JAL	R5,QUEINF		:QUEUE THIS INF FRAME TO RCV QUEUE
	J	HPR.R			:CONTINUE TO RCV
HPRCIW					: (8/13/85/CHS)
	LB	R0,LSCLKS+LSCVSU,RLSC,	:RESTORE N(R) (8/13/85/CHS)
	STB	R0,LSCLKS+LSCNRR,RLSC,	:.. (8/13/85/CHS)
	J	HPRCIZ			:TO CONTINUE (8/13/85/CHS)

:	OUT SEQUENCED FRAME, DISCARD
:	------------------------------------
HPRCI3
	JAL	R5,IDELET		:DISCARD THIS FRAMES
	J	HPR.R			:CONTINUUE TO RCV


:	HPRCSN/HPRCUA/HPRCAU/HPRCAD/HPRCRJ/HPRCXD/HPRCTS
:	HPRCCT/HPRCIH/HPRCOV/HPRCLN
:	----------------------------------------------
:	RECEIVING NOT EXPECTED FRAME OR FRAME ERROR
:	DISCARD THE RCV'ED FRAME, AND ENTER HPXNDM STATE
HPRCSN
HPRCUA
HPRCAU
HPRCAD
HPRCRJ
HPRCXD
HPRCTS
HPRCCT
HPRCIH
HPRCOV
HPRCLN
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	LHI	R1,UPNEF+CSTATE		:QUEUE NEF STATUS TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRMI-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT STATE


:	HPRCDM: RCV'ED DM 
:	-----------------
:	QUEUE DM TO RCV QUEUE, AND ENTER HPXNDM STATE
HPRCDM
	JAL	R5,CHKIPF		:IS F BIT ON?
	J	HPR.R			:NO, CONTINUE TO RCV
	LHI	R1,CDM			:QUEUE DM RESPONSE TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:....
	LHI	R0,HPTRMI-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT


:	HPRCLS: LOST DATA DUE TO BUFFER UNAVAILABLE
:	-----------------------------------------
:	IF F BIT NOT ON, IGNORE
:	IF F BIT IS ON, THEN SEE IF N(S)=V(R)
:	IF O.K., THEN PROCESS, AND ENTER HPXOPA STATE
HPRCLS
	JAL	R5,CHKIPF		:IS F BIT ON?
	J	HPR.R			:CONTINUE TO RCV
	JAL	R5,CKNSVR		:IS N(S)=V(R)?
	J	HPR.R			:CONTINUE TO RCV
	JAL	R5,INCIC		:IC=IC+V(S)-N(R)
	JAL	R5,SETUSR		:SET VSU=V(S)=N(R)
	LHI	R0,HPXOPA-PSEG		:ENTER HPXOPA STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	JAL	R5,CLRRT1		:RESET RT1 TIMER
	J	HPR.X			:SWITCH FROM RCV TO XMT 


:	HPRCRR: RCV'ED RR FRAME
:	--------------------------------------
HPRCRR
	JAL	R5,CHKNR		:N(R) IN [VSU,V(S)]? (8/13/85/CHS)
	J	HPRCRX			:NO, ... (8/13/85/CHS)
HPRCR0					:(8/13/85/CHS)
	JAL	R5,CHKIPF		:IS RCV'ED FRAME F BIT ON?
	J	HPRCR2			:NO, SKIP
	JAL	R5,CKNRVS		:IS N(R)=V(S) ?
	J	HPRCR1			:NO, SKIP
	LHL	R0,LSCLKS+LSCIFC,RLSC,	:CHECK IF IC = 0
	JN	HPRCR1			:NO, SKIP
	JAL	R5,CHKEND		:IS END BIT SET?
	J	HPRCR1			:NO, SKIP
:	(F = 1) AND (N(R) = V(S)) AND (IC = 0) AND END
:	-----------------------------------------------
	JAL	R5,CLREND		:RESET END BIT
	LHI	R0,HPXWND-PSEG		:ENTER HPXWND STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRM4-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT
HPRCRX					:(8/13/85/CHS)
	LB	R0,LSCLKS+LSCVSU,RLSC,	:RESTORE N(R) (8/13/85/CHS)
	STB	R0,LSCLKS+LSCNRR,RLSC,	:.. (8/13/85/CHS)
	J	HPRCR0			:TO CONTINUE (8/13/85/CHS)

:	(F = 1)
:	---------
HPRCR1
	JAL	R5,INCIC		:INC. IC,IC=IC+V(S)-N(R)
	JAL	R5,SETUSR		:SET VSU=V(S)=N(R)
	LHI	R0,HPXOPA-PSEG		:ENTER HPXOPA STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:..
	JAL	R5,CLRRT1		:RESET RT1 TIMER
	JAL	R5,SETSEQ		:SET RC SEQ CNT
	JAL	R5,SETSRC		:SET RC
	JAL	R5,SETRCB		:SET RCB
	JAL	R5,SETTRR		:SET RR/RR IDLE TIMER
	J	HPR.X			:SWITCH FROM RCV TO XMT

:	(F = 0)
:	--------
HPRCR2
	JAL	R5,SETUR		:SET VSU=N(R)
	J	HPR.R			:CONTINUE TO RCV


:	HPRCRN: RCV'ED RNR 
:	-------------------
HPRCRN
HPRCNR
	JAL	R5,CHKNR		:N(R) IN [VSU,V(S)]? (8/13/85/CHS)
	J	HPRCNX			:NO, .. (8/13/85/CHS)
HPRCN0					: (8/13/85/CHS)
	JAL	R5,CHKIPF		:IS RCV'ED FRAME F BIT ON?
	J	HPRCN1			:NO, SKIP
	JAL	R5,CKNRVS		:YES, IS N(R)=V(S) ?
	J	HPRCN1			:NO, SKIP
	LHL	R0,LSCLKS+LSCIFC,RLSC,	:CHECK C = 0
	JN	HPRCN1			:NO, SKIP
	JAL	R5,CHKEND		:IS END BIT SET ?
	J	HPRCN1			:NO, SKIP
:	(F = 1) AND (V(S) = N(R)) AND (IC = 0) AND END
:	-----------------------------------------------
	JAL	R5,CLREND		:CLEAR END CONDITION
	LHI	R0,HPXWND-PSEG		:ENTER HPXWND STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRM4-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT
HPRCNX					: (8/13/85/CHS)
	LB	R0,LSCLKS+LSCVSU,RLSC,	:RESTORE N(R) (8/13/85/CHS)
	STB	R0,LSCLKS+LSCNRR,RLSC,	:. (8/13/85/CHS)
	J	HPRCN0			:TO CONTINUE (8/13/85/CHS)

:	RNR AND NOT END
:	---------------
HPRCN1
	JAL	R5,SETUR		:SET VSU=N(R)
	JAL	R5,SETSEQ		:SET RETRY SEQ COUNTER
	JAL	R5,SETSRC		:SET RETRY COUNTER
	JAL	R5,DECRCB		:DECREMENT RCB BY 1
	J	HPR.R			:CONTINUE TO RCV


:	HPRCDS: RCV'ED RD
:	-------------------
:	QUEUE RD CMD TO RCV QUEUE, AND ENTER HPXWND STATE
HPRCDS
	JAL	R5,CHKIPF		:IS RCV'ED FRAME F BIT ON?
	J	HPRCD1			:F BIT NOT SET, SKIP
	LHI	R1,CRD			:SET PARAMETER FOR B.G. (RD COMMAND)
	JAL	R5,QUECMD		:QUEUE RD CMD TO RCV QUEUE
	LHI	R0,HPXWND-PSEG		:ENTER HPXWND STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRM4-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT STATE

HPRCD1
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	J	HPR.R			:CONTINUE TO RCV


:	HPRCSM: RCV'ED RIM FRAME
:	------------------------------
:	QUEUE RIM RESPONSE TO RCV QUEUE
:	ENTER HPXTOP STATE
:	SWITCH FROM RCV TO XMT
HPRCSM
	JAL	R5,CHKIPF		:ISRCV'ED FRAME F BIT ON?
	J	HPRCM1			:NO, TO DISCARD FROME
	LHI	R1,CRIM			:QUEUE RIM CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HPXTOP-PSEG		:ENTER HPXTOP STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRM1-PSEG		:ETNER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT

HPRCM1
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	J	HPR.R			:CONTINUE TO RCV


:	HPRCFR: RCV'ED FRMR 
:	------------------
:	LOG THE EVENET , AND ENTER HPXNDM STATE
HPRCFR
	JAL	R5,CHKIPF		:IS RCV'ED FRAME F BIT ON?
	J	HPRCF1			:F BIT NOT SET ,SKIP
	LHI	R1,CFRMR		:QUEUE FRMR STATUS TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRMI-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT

HPRCF1
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	J	HPR.R			:CONTINUE TO RCV


:	HPRCTM:	TIMEOUT
:	-----------------
HPRCTM
	JAL	R5,DECSRC		:DECREMENT RC
	LHI	R0,HPXOPB-PSEG		:ENTER HPXOPB STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT STATE


	SUBTTL (HDXPRI) PROCESSING ROUTINE FOR HDXPRI IN HPROSP STATE


:	HPROIF/HPROSN/HPROUA/HPRODS/HPROSM/HPRORR/HPRORN/HPRORJ
:	HPROCT/HPROIH/HPROOV/HPROLN/HPROAU/HPROAD/HPROLS
:	-----------------------------------------------------------------
:	IF NOT EXPECTED FRAME, ENTER NDM MODE
HPROIF
HPROSN
HPROUA
HPRODS
HPROSM
HPRORR
HPRORN
HPRORJ
HPROCT
HPROIH
HPROOV
HPROLN
HPROAU
HPROAD
HPROLS
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	JAL	R5,CHKIPF		:IS F BIT ON?
	J	HPR.R			:NO, CONTINUE TO RCV
	LHI	R1,UPNEF+CSTATE		:QUEUE NEF STATUS TO RCV QUEUE

HPROL1
	JAL	R5,QUECMD		:QUEUE STATUS
HPROL0
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRMI-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT


:	HPRODM: RCV'ED DM FRAME
:	-----------------------
:	QUEUE DM CMD TO RCV QUEUE, AND ENTER HPXNDM STATE
HPRODM
	JAL	R5,CHKIPF		:IS F BIT ON?
	J	HPR.R			:NO, CONTINUE TO RCV
	LHI	R1,CDM			:QUEUE DM RESPONSE TO RCV QUEUE
	JAL	R5,QUECMD		:...
	J	HPROL0			:GO TO QUEUE IT


:	HPROFR: RCV'ED FRMR FRAME
:	-------------------------
:	QUEUE FRMR STATUS TO RCV QUEUE, AND ENTER HPXNDM STATE
HPROFR
	JAL	R5,CHKIPF		:IS F NIT ON?
	J	HPR.R			:NO, CONTINUE TO RCV
	LHI	R1,CFRMR		:QUEUE FRMR CMD
	JAL	R5,QUECMD		:QUEUE IT
	J	HPROL0			:GO TO QUEUE IT


:	HPROTM: TIMEOUT
:	--------------
:	QUEUE INOP STATUS TO RCV QUEUE
HPROTM
	LB	R0,LSCLKS+LSCSRC,RLSC,	:IS RC = 0 ?
	JN	HPROM1			:NO, TO RE-XMT FRAME
	JAL	R5,SETSRC		:RESET RETRY CNT
	JAL	R5,DECSEQ		:DECREASE RETRY SEQ
	LB	R0,LSCLKS+LSCSEQ,RLSC,	:IS SEQ = 0?
	LR	R0,R0
	JN	HPROM1			:NO, TO RE-XMT FRAME
	LHI	R1,UPINOP+CSTATE	:QUEUE INOP STATUS TO RCV QUEUE
	J	HPROL1			:TO QUEUE IT

HPROM1
	JAL	R5,SETRXT		:SET TO RE-XMT XID/TEST
	J	HPXRUF			:TO DO RE-XMT


:	HPROXD/HPROTS: RCV'ED XID/TEST FRAME
:	-------------------------------------
:	SEE IF DESIRED, IF YES, QUEUE TO RCV QUEUUE, AND ENTER HPXOPA STATE
:	IF NOT, ENTER HPXNDM STATE
HPROXD
HPROTS
	JAL	R5,CHKIPF		:IS RCV'ED FRAME F BIT ON?
	J	HPROT1			:TO DISCARD THE FRAME
	LB	R1,LSCLKS+LSCRST,RLSC,	:
	CLB	R1,LSCLKS+LSCCXC,RLSC,	:THE SAME ?
	JN	HPROT1			:NO, TO DSICARD
	JAL	R5,QUEETE		:XID/TEST QUEUE AS INF
	LHI	R0,HPXOPA-PSEG		:ENTER HPXOPA STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	JAL	R5,CLRRT1		:RESET RT1 TIMER
	J	HPR.X			:SWITCH FROM RCV TO XMT

HPROT1
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:....
	LHI	R0,HPTRMI-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITTCH FROM RCV TO XMT 


	SUBTTL (HDXPRI) PROCESSING ROUTINE FOR HDXPRI IN HPRWND STATE


:	HPRWUA/HPRWDM: RCV'ED UA/DM 
:	---------------------------
HPRWUA
	LHI	R1,CUA
	JFS	HPRWD1

HPRWDM
	LHI	R1,CDM

HPRWD1
	JAL	R5,CHKIPF		:IS RCV'ED FRAME F BIT ON?
	J	HPR.R			:NO, CONTINUE TO RCV
	JAL	R5,QUECMD		:QUEUE UA/DM TO RCV QUEUE
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRMI-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT


:	HPRWIF/HPRWSN/HPRWDS/HPRWSM/HPRWXD/HPRWTS/HPRWRR/HPRWRN
:	HPRWRJ/HPRWCT/HPRWIH/HPRWOV/HPRWLN/HPRWAU
:	HPRWAD/HPRWLS
:	--------------------------------------------------------
:	UNDESIRED FRAME OR FRAME ERROR
:	IF F BIT ON,  QUEUE NEF STATUS TO RCV QUEUE
:	ELSE, CONTINUE TO RCV
HPRWIF
HPRWSN
HPRWDS
HPRWSM
HPRWXD
HPRWTS
HPRWRR
HPRWRN
HPRWRJ
HPRWCT
HPRWIH
HPRWOV
HPRWLN
HPRWAU
HPRWAD
HPRWLS
	JAL	R5,IDELET		:DISCARD THIS FRAME
	JAL	R5,CHKIPF		:IS RCV'ED FRAME F BIT ON?
	J	HPR.R			:NO, TO CONTINUE RCV
	LB	R0,LSCLKS+LSCSRC,RLSC,	:IS RC = 0?
	JN	HPXRUF			:NO, TO RE-XMT DISC
	JAL	R5,SETSRC		:RESET RETRY CNT
	JAL	R5,DECSEQ		:DECREAE RETRY SEQ
	LB	R0,LSCLKS+LSCSEQ,RLSC,	:IS SEQ = 0?
	LR	R0,R0
	JN	HPXRUF			:NO, TO RE-XMT DISC
	LHI	R1,UPNEF+CSTATE		:QUEUE NEF STATUS
HPRWL1
	JAL	R5,QUECMD		:QUEUE STATUS TO RCV QUEUE
HPRWL0
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRMI-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT


:	HPRWFR: FRMR RCV'ED
:	-------------------
:	QUEUE FRMR STATUS TO RCV QUEUE
:	AND ENTER HPXNDM STATE
HPRWFR
	JAL	R5,CHKIPF		:IS F BIT ON ?
	J	HPR.R			:NO TO CONTINUE RCV
	LHI	R1,CFRMR		:QUEUE FRMR CMD
	JAL	R5,QUECMD		:QUEUE IT
	J	HPRWL0			:TO QUEUE THE STATUS


:	HPRWTM: TIMOUT
:	----------------
:	IF RC > 0, RE-XMT DISC FRAME
:	ELSE, IF RC = 0, QUEUE INOP STATUS
HPRWTM
	LB	R0,LSCLKS+LSCSRC,RLSC,	:IS RC > 0?
	JN	HPXRUF			:YES, RE-XMT DISC FRAME
	LHI	R1,UPINOP+CSTATE	:QUEUE INOP STATUS
	J	HPRWL1			:TO QUEUE THE STATUS


	SUBTTL (HDXPRI) PROCESSING ROUTINES FOR HDXPRI IN EXCEPTIONAL STATE


:	HPRSNU/HPRTNU/HPRCNU/HPRONU/HPRWNU
:	------------------------------------
:	NO ACTION, RETURN TO DISPATCHER
HPRSNU
HPRTNU
HPRCNU
HPRONU
HPRWNU
	J	HPR.R			:CONTINUE TO RCV

:	HPCRSH: CRASH ROUTINE
:	---------------------
HPCRSH
	JAL	R10,CRASH,,		:....
	BC	0,0,0,088		:...


:	HPDISC:	XMT ERROR
:	------------------
:	DEQUEUE ALL CMD'S IN XMT QUEUE AND QUEUE UPXMT STATUS TO RCV QUEUE
HPDISC
	JAL	R5,RSTSEC		:RESET ...(11/11/85/CHS)
	JAL	R5,PKXMTQ		:PEEK THE XMT CMD
	CLHI	R1,-1			:XMT QUEUE EMPTY?
	JEFS	HPDIS1			:YES, SKIP
	JAL	R5,DQXMTQ		:NO, DELETE IT
	JBS	HPDISC			:LOOP
HPDIS1
	JAL	R5,RSTSEC		:RESET ...
	LHI	R1,UPXMT+CSTATE		:QUEUE XMT ERROR STATUS TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HPXNDM-PSEG		:ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:....
	LHI	R0,HPTRMI-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPXNX1			:...


	SUBTTL (HDXPRI) PROCESSING ROUTINES FOR HDXPRI FOR CLEARP CMD


:	HPCLRI: CLEARP CMD AT ANY STATE
:	--------------------------------
:	DELETE ALL XMT CMD FROM XMT QUEUE, CLEAN UP OTHER STUFF
:	QUEUE A STATUS<UPCLRD> TO RCV QUEUE
HPCLRI
	JAL	R5,RSTSEC		:RESET ..(11/11/85/CHS)
	JAL	R5,PKXMTQ		:IS THE 1ST CMD EMPTY?
	CLHI	R1,-1			:...
	JEFS	HPCLR1			:YES, SKIP
	JAL	R5,DQXMTQ		:ELSE, DELETE IT
	JBS	HPCLRI			:AND LOOK AT NEXT CMD
HPCLR1
	JAL	R5,RSTSEC		:RESET ..
	LHI	R1,UPCLRD+CSTATE	:QUEU CLEARED STATUS TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HPXNDM-PSEG		:AND ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRM1-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	HPR.X			:TO RUN NEXT CU


	SUBTTL (HDXPRI) PROCESSING ROUTINES FOR HDXPRI FOR TERMP CMD


:	HPTRMI: TERMP CMD AT HPXNDM/HPXTOP/HPRDSP/HPRWOP STATE
:	------------------------------------------------------
:	DELETE ALL XMT CMD FROM XMT QUEUE, CLEAR UP OTHER STUFF
:	QUEUE A STATUS<UPTRMD) TO RCV QUEUE
HPTRMI
	JAL	R5,RSTSEC		:RESET ...(11/11/85/CHS)
	JAL	R5,PKXMTQ		:LOOK AT THE XMT CMD
	CLHI	R1,-1			:IS XMT CMD EMPTY?
	JEFS	HPTRM1			:YES, SKIP
	JAL	R5,DQXMTQ		:ELSE, DELETE THIS CMD
	JBS	HPTRMI			:AND LOOK AT NEXT CMD
HPTRM1
	JAL	R5,RSTSEC		:RESET ...
	LHI	R1,UPTRMD+CSTATE	:QUEUE TERMINATED STATUS TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HPXNDM-PSEG		:AND ENTER HPXNDM STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HPR.X			:TO RUN NEXT CU (CLEAR RCV STATE)


:	HPTRM2: TERMP CMD AT HPXOPA/HPXOPB/HPROPC/HPROSP STATE
:	------------------------------------------------------
:	IF N(R) NOT= V(S) OR IC NOT= 0, SET END CONDITION
:	ELSE, ENTER HPXWND STATE
HPTRM2
	JAL	R5,CKNRVS		:IS N(R) = V(S)?
	J	HPTRM3			:NO, SKIP
	LHL	R0,LSCLKS+LSCIFC,RLSC,	:IS IC = 0?
	JE	HPTRM3			:NO, SKIP
	LHI	R0,HPXWND-PSEG		:N(R)=V(S) AND IC=0, ENTER HPXWND STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	LHI	R0,HPTRM4-PSEG		:ENTER NEW TERMP HANDLING ROUTINE
	STH	R0,LSCLKS+LSCTRM,RLSC,	:...
	J	DSPCM1			:AND EXIT TO PTP CMD DISPATCHER

HPTRM3
	JAL	R5,CLREND		:SET END CONDITION ON
	J	DSPCM1			:AND RETUNR TO PTP DISPATCHER


:	HPTRM4: TERMP CMD AT HPXWND/HPRWND STATE
:	-----------------------------------------
:	NO ACTION, RETURN TO PTP DISPATCHER
HPTRM4
	J	DSPCM1			:RETURN TO PTP CMD DISPATCHER


	SUBTTL (HDXPRI) PROCSESSING ROUTINES AND TABLE FOR RE-XMT UN-FRAMES

:	HPXRUN:	RE-TRANSMIT UN-NUMBERED FRAMES(SNRM,SIM,DISC,TEST,XID)
:	---------------------------------------------------------------
	HS	0
	HC	HPXRNU-PSEG		:-1 - NO CMD, XMT U-FRAME
HPXRUN	HC	HPXRRX-PSEG		:0  - RE-XMT CMD, RECOVER/XMT U-FRAME
	HC	HPXRIF-PSEG		:1  - INF CMD, RECOVER/XMT U-FRAME
	HC	HPXRSN-PSEG		:2  - SNRM CMD, RECOVERY/XMT U-FRAME
	HC	HPXRUA-PSEG		:3  - UA CMD, RECOVERY/XMT U-FRAME
	HC	HPXRDS-PSEG		:4  - DISC CMD, RECOVERY/XMT U-FRAME
	HC	HPXRDM-PSEG		:5  - DM CMD, RECOVERY/XMT U-FRAME
	HC	HPXRSM-PSEG		:6  - SIM CMD, RECOVERY/XMT U-FRAME
	HC	HPXRXD-PSEG		:7  - XID CMD, RECOVERY/XMT U-FRAME
	HC	HPXRTS-PSEG		:8  - TEST CMD, RECOVERY/XMT U-FRAME
	HC	HPXRFR-PSEG		:9  - FRMR CMD, RECOVERY/XMT U-FRAME


:	HPXRNU/HPXRRX/HPXRIF/HPXRSN/HPXRUA/HPXRDS
:	HPXRDM/HPXRSM/HPXRXDOHPXRTS/HPXRFR
:	-----------------------------------------
HPXRNU
HPXRRX
HPXRIF
HPXRSN
HPXRUA
HPXRDS
HPXRDM
HPXRSM
HPXRXD
HPXRTS
HPXRFR
	LB	R1,LSCLKS+LSCCXC,RLSC,	:GET CURRENT XMT OP CODE
	CLHI	R1,CSNRM		:'SNRM'?
	JE	HPXDS1			:TO RE-XMT SNRM
	CLHI	R1,CDISC		:'DISC'?
	JE	HPXDD1			:TO RE-XMT DISC
	CLHI	R1,CSIM			:'SIM'?
	JE	HPXDS1			:TO RE-XMT SIM
	CLHI	R1,CXID			:'XID'?
	JE	HPXRUM			:TO RE-XMT XID
	CLHI	R1,CTEST		:'TEST'?
	JE	HPXRUM			:TO RE-XMT TEST
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
HPXRUM
	LB	R0,LSCLKS+LSCBIT,RLSC,	:GET LSCBIT
	NHI	R0,RXTBIT
	JE	HPXDT1
	J	HPXAT1


:	HPXRUF:	TO SET UP FOR RE-XMT OF U-FRAMES
:	-----------------------------------------
HPXRUF
	LHI	R0,HPXRUN-PSEG		:ENTER HPXRUN STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HPR.X			:SWITCH FROM RCV TO XMT


	SUBTTL (HDXPRI) PRIMITIVE PROCESSING ROUTINE FOR HDXPRI


:	HPXNXT: ENTRY POINT TO DELE. XMT CMD, SCHEDULE NEW CU, AND EXIT
:	------------------------------------------------------------------
:	DELETE CURRENT XMT CMD FROM XMT QUEUE
:	SCHEDULE TO SERVICE NEXT CU, AND RETURN TO PTP DISPATCHER
HPXNXT
	JAL	R5,DQXMTQ		:DELETE CURR. CMD, AND MOVE TO NEXT ONE

HPXNX1
	LB	R2,LSCLKS+LSCRID,RLSC,	:GET REL #
HPXNX2
	AIS	R2,1			:MOVE TO NEXT CU
	LHL	R5,LNCPTR,RL,RL		:GET LNCTAB ADDR
	CLB	R2,LNCTAB+LNMXPU,R5,	:WRAP AROUND?
	JLFS	HPXNX3			:NO, SKIP
	LIS	R2,0			:YES,ROUND ROBIN ALOGORITHM
HPXNX3
	TBT	R2,LCBTAB+LCBXMT,RLCB,	:IN XMT STATE?
	JE	HPXNX2			:NO, TRY NEXT ONE
	JAL	R5,GETLSC		:GET LSC ADDR
:	CLH	RLSC,LCBTAB+LCBC.X,RLCB, :THE SAME ONE?
:	JE	DSPDMS			:YES, DISMISS
	STH	RLSC,LCBTAB+LCBC.X,RLCB, :SET UP XMT CU
	J	DSPDMS			:RETURN TO PTP XMT DISPATCHER


:	HPX.X: CONTINUE TO XMT FOR THE (SAME) CU
:	------------------------------------------
HPX.X
	J	DSPDMS			:RETURN TO PTP XMT DISPATCHER


:	HPX.R:	SWITCH FROM XMT TO RCV FOR THE (SAME) CU
:	-----------------------------------------------
HPX.R
	JAL	R5,SETRT1		:SET T1 TIMER
HPX.R1
	LIS	R1,0			:CLEAR XMT STATE
	STH	R1,LSCLKS+LSCXHL,RLSC,	:...
	STH	R1,LCBTAB+LCBC.X,RLCB,	:NOT XMT
	LB	R1,LSCLKS+LSCRID,RLSC,	:GET REL #
	RBT	R1,LCBTAB+LCBXMT,RLCB,	:SWITCH FROM XMT
	SBT	R1,LCBTAB+LCBRCV,RLCB,	:TO RCV

:	HPR.R:	CONTINUE TO RCV FOR THE (SAME) CU
:	----------------------------------------
HPR.R
	STH	RLSC,LCBTAB+LCBC.R,RLCB,
	J	DSPDMS			:RETURN TO PTP DISPATCHER


:	HPR.X:	SWITCH FROM RCV TO XMT STATE
:	-------------------------------------
:	SCHDULE FOR THE NEXT CU TO BE SERVED
HPR.X
	JAL	R5,SETTRX		:SET RCV TO XMT TURN AROUND TIMER
	LIS	R0,0			:CLEAR RCV STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	STH	R0,LCBTAB+LCBC.R,RLCB,	:NO SPECIFIC RCVING (2/2/7/85/CHS)
	LB	R0,LSCLKS+LSCRID,RLSC,	:GET REL #
	RBT	R0,LCBTAB+LCBRCV,RLCB,	:SWITCH FROM RCV TO XMT
	SBT	R0,LCBTAB+LCBXMT,RLCB,	:...
	J	HPXNX1			:SERVICE NEW CU


	FO	FGGBDF
	FO	SNAEXC
	FO	GBLDEF
	FO	SFGXMT
	FO	SFGRCV
	FO	MAIN

	EM
	EI	(DLCPHD)
	EI	(TERMIF)
 	IF	HOSTIF

	SUBTTL (HDXSEC) BASIC CONTROL MODULE FOR HALFDUPLEX SEC CU - SFGPTP
:PHDS00.H00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Re-design and re-code for SNA Native Mode from
:			SDLC Interface.
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Re-design and re-code for SNA Native Mode from
:			SDLC Interface.
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:*******************************************************:
:	                                            	:
:	PROTOCOL MANAGER (BASIC CONTROL MODULE) FOR 	:
:	HALF DUPLEX, SECONDARY,P-T-P AND MULTI-POINT
:	                                            	:
:*******************************************************:

	IF	(DLCSHD)

	RA	0
	MO	.,SFGPTP

	LO	SFGPTP
	LO	FGGBDF
	LO	SNAEXC
	LO	GBLDEF
	LO	SFGXMT
	LO	SFGRCV
	LO	MAIN


	SEG	A.CODE


	SUBTTL (HDXSEC) XMT STATE TABLES FOR HDXSEC


:	HSXWOP: SNRM/SIM  RCV'ED, WAITING UA/DM FROM B.G.
:	-------------------------------------------------
	HS	0
	HC	HSXPNU-PSEG		:-1 - NO CMD, DISMISS
HSXWOP	HC	HSXPRX-PSEG		:0  - RE-XMT CMD, RECOVER/DISMISS
	HC	HSXPIF-PSEG		:1  - INF CMD, DISCARD/DISMISS
	HC	HSXPSN-PSEG		:2  - SNRM CMD, IMPLEMENTAION ERROR
	HC	HSXPUA-PSEG		:3  - UA CMD, ENTER HSROPC/HSRNDM STATE
	HC	HSXPDS-PSEG		:4  - RD CMD, DISCARD/DISMISS
	HC	HSXPDM-PSEG		:5  - DM CMD, ENTER HSRNDM STATE
	HC	HSXPSM-PSEG		:6  - RIM CMD, DISCARD/DISMISS
	HC	HSXPXD-PSEG		:7  - XID CMD, DISCARD
	HC	HSXPTS-PSEG		:8  - TEST CMD, DISCARD
	HC	HSXPFR-PSEG		:9  - FRMR CMD, DISCARD


:	HSXDSP: XID/TEST RCV'ED IN NDM MODE, WAITING XID/TEST FROM B.G.
:	--------------------------------------------------------------
	HS	0
	HC	HSXSNU-PSEG		:-1 - NO CMD, DISMISS
HSXDSP	HC	HSXSRX-PSEG		:0  - RE-XMT CMD, RECOVER/DISMISS
	HC	HSXSIF-PSEG		:1  - INF CMD, DISCARD/DISMISS
	HC	HSXSSN-PSEG		:2  - SNRM CMD, IMPLEMENTAION ERROR
	HC	HSXSUA-PSEG		:3  - UA CMD, DISCARD/DISMISS
	HC	HSXSDS-PSEG		:4  - RD CMD, DISCARD/DIMISS
	HC	HSXSDM-PSEG		:5  - DM CMD, ENTER HSRNDM STATE
	HC	HSXSSM-PSEG		:6  - RIM CMD, DISCARD/DISMISS
	HC	HSXSXD-PSEG		:7  - XID CMD, XMT XID/HSRNDM
	HC	HSXSTS-PSEG		:8  - TEST CMD, XMT TEST/HSRNDM
	HC	HSXSFR-PSEG		:9  - FRMR CMD, XMT FRMR/HSRFRM


:	HSXOPA: NRM MODE, TRANSMIT I RESPONSE
:	--------------------------------------
	HS	0
	HC	HSXANU-PSEG		:-1 - NO CMD, DISMISS
HSXOPA	HC	HSXARX-PSEG		:0  - RE-XMT CMD, RE-XMT
	HC	HSXAIF-PSEG		:1  - INF CMD, PROCESS
	HC	HSXASN-PSEG		:2  - SNRM CMD, IMPLEMENTAION ERROR
	HC	HSXAUA-PSEG		:3  - UA CMD, NEC/DISCARD
	HC	HSXADS-PSEG		:4  - RD CMD, XMT RD/HSRWND STATE
	HC	HSXADM-PSEG		:5  - DM CMD, ENTER HSRNDM STATE
	HC	HSXASM-PSEG		:6  - RIM CMD, XMT RIM/HSRWND STATE
	HC	HSXAXD-PSEG		:7  - XID CMD, NEC/DISCARD
	HC	HSXATS-PSEG		:8  - TEST CMD, NEC/DISCARD
	HC	HSXAFR-PSEG		:9  - FRMR CMD, XMT FRMR/HSRFRM


:	HSXOPB: NRM MODE, TRANSMIT S RESPONSE
:	--------------------------------------
	HS	0
	HC	HSXBNU-PSEG		:-1 - NO CMD, DISMISS
HSXOPB	HC	HSXBRX-PSEG		:0  - RE-XMT CMD, RECOVERY/DISMISS
	HC	HSXBIF-PSEG		:1  - INF CMD, PEEK/XMT S CMD
	HC	HSXBSN-PSEG		:2  - SNRM CMD, IMPLEMENTAION ERROR
	HC	HSXBUA-PSEG		:3  - UA CMD, NEC/DISCARD
	HC	HSXBDS-PSEG		:4  - RD CMD, XMT RD/HSRWND STATE
	HC	HSXBDM-PSEG		:5  - DM CMD, ENTER HSRNDM STATE
	HC	HSXBSM-PSEG		:6  - RIM CMD, XMT RIM/HSRWND STATE
	HC	HSXBXD-PSEG		:7  - XID CMD, NEC/DISCARD
	HC	HSXBTS-PSEG		:8  - TEST CMD, NEC/DISCARD
	HC	HSXBFR-PSEG		:9  - FRMR CMD, XMT FRMR/HSRFRM


:	HSXOSP: NRM MODE, XID/TEST RCV'ED, WAITING FOR XID/TEST
:	----------------------------------------------------------
	HS	0
	HC	HSXONU-PSEG		:-1 - NO CMD, DISMISS
HSXOSP	HC	HSXORX-PSEG		:0  - RE-XMT CMD, RECOVERY/DISMISS
	HC	HSXOIF-PSEG		:1  - INF CMD, DISCARD
	HC	HSXOSN-PSEG		:2  - SNRM CMD, IMPLEMENTAION ERROR
	HC	HSXOUA-PSEG		:3  - UA CMD, DISCARD
	HC	HSXODS-PSEG		:4  - RD CMD, DISCARD
	HC	HSXODM-PSEG		:5  - DM CMD, DISCARD
	HC	HSXOSM-PSEG		:6  - RIM CMD, DISCARD
	HC	HSXOXD-PSEG		:7  - XID CMD, XMT XID/HSROPC
	HC	HSXOTS-PSEG		:8  - TEST CMD, XMT TEST/HSROPC
	HC	HSXOFR-PSEG		:9  - FRMR CMD, XMT FRMR/HSRFRM


:	HSXWND: DISC RCV'ED, WAITING UA/DM FROM B.G.
:	---------------------------------------------
	HS	0
	HC	HSXWNU-PSEG		:-1 - NO CMD, DISMISS
HSXWND	HC	HSXWRX-PSEG		:0  - RE-XMT CMD, RECOVERY/DISMISS
	HC	HSXWIF-PSEG		:1  - INF CMD, DISCARD
	HC	HSXWSN-PSEG		:2  - SNRM CMD, IMPLEMENTAION ERROR
	HC	HSXWUA-PSEG		:3  - UA CMD, XMT UA/HSRNDM STATE
	HC	HSXWDS-PSEG		:4  - RD CMD, DISCARD
	HC	HSXWDM-PSEG		:5  - DM CMD, XMT DM/HSRNDM STATE
	HC	HSXWSM-PSEG		:6  - RIM CMD, DISCARD
	HC	HSXWXD-PSEG		:7  - XID CMD, NEC/DISCARD
	HC	HSXWTS-PSEG		:8  - TEST CMD, NEC/DISCARD
	HC	HSXWFR-PSEG		:9  - FRMR CMD, XMT FRMR/HSRFRM


	SUBTTL (HDXSEC) RCV STATE TABLES FOR HDXSEC


:	HSRNDM: NDM MODE, WAITING FOR SNRM/RR/DISC
:	------------------------------------------
	HS	0
HSRNDM	HC	HSRDNU-PSEG		:0  - NO DATA, NO ACTION
	HC	HSRDIF-PSEG		:1  - INF FRAME, DISCARD
	HC	HSRDSN-PSEG		:2  - SNRM FRAME, PROCESS
	HC	HSRDUA-PSEG		:3  - UA FRAME, DISCARD
	HC	HSRDDS-PSEG		:4  - DISC FRAME, ENTER HSXWND
	HC	HSRDDM-PSEG		:5  - DM FRAME, DISCARD
	HC	HSRDSM-PSEG		:6  - SIM FRAME, ENTER HSXWOP STATE
	HC	HSRDXD-PSEG		:7  - XID FRAME, ENTER HSXDSP STATE
	HC	HSRDTS-PSEG		:8  - TEST FRAME, ENTER HSXDSP STATE
	HC	HSRDFR-PSEG		:9  - FRMR FRAME, DISCARD
	HC	HSRDRR-PSEG		:0A - RR FRAME, DM/DISCARD
	HC	HSRDRN-PSEG		:0B - RNR FRAME, DM/DISCARD
	HC	HSRDRJ-PSEG		:0C - REJ FRAME, DM/DISCARD
	HC	HSRDCT-PSEG		:0D - 'C' FIELD ERROR, DISCARD
	HC	HSRDIH-PSEG		:0E - I-FIELD PROHIBITED, DISCARD
	HC	HSRDOV-PSEG		:0F - FRAME TOO LONG, DISCARD
	HC	HSRDLN-PSEG		:10 - FRAME TOO SHORT, DISCARD
	HC	HSRDAU-PSEG		:11 - ADDR NOT CONFIGURATED, DISCARD
	HC	HSRDAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HSRDLS-PSEG		:13 - LOST DATA, DISCARD
	HC	HSRDTM-PSEG		:14 - TIMEOUT, IGNORE

:	HSROPT: NRM MODE, RIGHT AFTER UA WAS SENT
:	-------------------------------------
:	THIS NEW STATE IS REQUIRED TO GET RID OF EXTRA SNRMS
	HS	0
HSROPT	HC	HSRONU-PSEG		:0  - NO DATA, NO ACTION
	HC	HSROIF-PSEG		:1  - INF FRAME, PROCESS
	HC	HSROSN-PSEG		:2  - SNRM FRAME, ENTER HSXWOP STATE
	HC	HSROUA-PSEG		:3  - UA FRAME, NEF/DISCARD
	HC	HSRODS-PSEG		:4  - DISC FRAME, ENTER HSXWND STATE
	HC	HSRODM-PSEG		:5  - DM FRAME, NEF/DISCARD
	HC	HSROSM-PSEG		:6  - SIM FRAME, ENTER HSRNDM/DISCARD
	HC	HSROXD-PSEG		:7  - XID FRAME, ENTER HSXOSP STATE
	HC	HSROTS-PSEG		:8  - TEST FRAME, ENTER HSXOSP STATE
	HC	HSROFR-PSEG		:9  - FRMR FRAME, NEF/DISCARD
	HC	HSRORR-PSEG		:0A - RR FRAME, ENTER HSXOPA/HSXOPB STATE
	HC	HSRORN-PSEG		:0B - RNR FRAME, ENTER HSXOPB STATE
	HC	HSRORJ-PSEG		:0C - REJ FRAME, NEF/DISCARD
	HC	HSROCT-PSEG		:0D - 'C' FIELD ERROR, NEF/DISCARD
	HC	HSROIH-PSEG		:0E - I-FIELD PROHIBITED, NEF/DISCARD
	HC	HSROOV-PSEG		:0F - FRAME TOO LONG, NEF/DISCARD
	HC	HSROLN-PSEG		:10 - FRAME TOO SHORT, NEF/DISCARD
	HC	HSROAU-PSEG		:11 - ADDR NOT CONFIGURATED, DISCARD
	HC	HSROAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HSROLS-PSEG		:13 - LOST DATA, HSXOPA/HSXOPB OR RCV
	HC	HSROTM-PSEG		:14 - TIMEOUT, HSTMOT

:	HSROPC: NRM MODE, RECEIVING COMMANDS
:	-------------------------------------
	HS	0
HSROPC	HC	HSRCNU-PSEG		:0  - NO DATA, NO ACTION
	HC	HSRCIF-PSEG		:1  - INF FRAME, PROCESS
	HC	HSRCSN-PSEG		:2  - SNRM FRAME, ENTER HSXWOP STATE
	HC	HSRCUA-PSEG		:3  - UA FRAME, NEF/DISCARD
	HC	HSRCDS-PSEG		:4  - DISC FRAME, ENTER HSXWND STATE
	HC	HSRCDM-PSEG		:5  - DM FRAME, NEF/DISCARD
	HC	HSRCSM-PSEG		:6  - SIM FRAME, ENTER HSRNDM/DISCARD
	HC	HSRCXD-PSEG		:7  - XID FRAME, ENTER HSXOSP STATE
	HC	HSRCTS-PSEG		:8  - TEST FRAME, ENTER HSXOSP STATE
	HC	HSRCFR-PSEG		:9  - FRMR FRAME, NEF/DISCARD
	HC	HSRCRR-PSEG		:0A - RR FRAME, ENTER HSXOPA/HSXOPB STATE
	HC	HSRCRN-PSEG		:0B - RNR FRAME, ENTER HSXOPB STATE
	HC	HSRCRJ-PSEG		:0C - REJ FRAME, NEF/DISCARD
	HC	HSRCCT-PSEG		:0D - 'C' FIELD ERROR, NEF/DISCARD
	HC	HSRCIH-PSEG		:0E - I-FIELD PROHIBITED, NEF/DISCARD
	HC	HSRCOV-PSEG		:0F - FRAME TOO LONG, NEF/DISCARD
	HC	HSRCLN-PSEG		:10 - FRAME TOO SHORT, NEF/DISCARD
	HC	HSRCAU-PSEG		:11 - ADDR NOT CONFIGURATED, DISCARD
	HC	HSRCAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HSRCLS-PSEG		:13 - LOST DATA, HSXOPA/HSXOPB OR RCV
	HC	HSRCTM-PSEG		:14 - TIMEOUT, HSTMOT


:	HSRTOP: NDM/NRM MODE, RIM SENT, WAITING FOR SIM
:	-----------------------------------------------
	HS	0
HSRTOP	HC	HSRTNU-PSEG		:0  - NO DATA, NO ACTION
	HC	HSRTIF-PSEG		:1  - INF FRAME, NEF/DISCARD
	HC	HSRTSN-PSEG		:2  - SNRM FRAME, NEF/DISCARD
	HC	HSRTUA-PSEG		:3  - UA FRAME, NEF/DISCARD
	HC	HSRTDS-PSEG		:4  - DISC FRAME, NEF/DISCARD
	HC	HSRTDM-PSEG		:5  - DM FRAME, NEF/DISCARD
	HC	HSRTSM-PSEG		:6  - SIM FRAME, ENTER HSXWOP/DISCARD
	HC	HSRTXD-PSEG		:7  - XID FRAME, NEF/DISCARD
	HC	HSRTTS-PSEG		:8  - TEST FRAME, NEF/DISCARD
	HC	HSRTFR-PSEG		:9  - FRMR FRAME, NEF/DISCARD
	HC	HSRTRR-PSEG		:0A - RR FRAME, NEF/DISCARD
	HC	HSRTRN-PSEG		:0B - RNR FRAME, NEF/DISCARD
	HC	HSRTRJ-PSEG		:0C - REJ FRAME, NEF/DISCARD
	HC	HSRTCT-PSEG		:0D - 'C' FIELD ERROR, NEF
	HC	HSRTIH-PSEG		:0E - I-FIELD PROHIBITED, NEF/DISCARD
	HC	HSRTOV-PSEG		:0F - FRAME TOO LONG, NEF/DISCARD
	HC	HSRTLN-PSEG		:10 - FRAME TOO SHORT, NEF/DISCARD
	HC	HSRTAU-PSEG		:11 - ADDR NOT CONFIGURATED, DISCARD
	HC	HSRTAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HSRTLS-PSEG		:13 - LOST DATA, NEF/DISCARD
	HC	HSRTTM-PSEG		:14 - TIMEOUT, HSTMOT


:	HSRWND: NRM MODE, RD SENT, WAITING FOR DISC
:	-----------------------------------------------
	HS	0
HSRWND	HC	HSRWNU-PSEG		:0  - NO DATA, NO ACTION
	HC	HSRWIF-PSEG		:1  - INF FRAME, NEF/DISCARD
	HC	HSRWSN-PSEG		:2  - SNRM FRAME, NEF/DISCARD
	HC	HSRWUA-PSEG		:3  - UA FRAME, NEF/DISCARD
	HC	HSRWDS-PSEG		:4  - DISC FRAME, ENTER HSXWND
	HC	HSRWDM-PSEG		:5  - DM FRAME, NEF/DISCARD
	HC	HSRWSM-PSEG		:6  - SIM FRAME, NEF/DISCARD
	HC	HSRWXD-PSEG		:7  - XID FRAME, NEF/DISCARD
	HC	HSRWTS-PSEG		:8  - TEST FRAME, NEF/DISCARD
	HC	HSRWFR-PSEG		:9  - FRMR FRAME, NEF/DISCARD
	HC	HSRWRR-PSEG		:0A - RR FRAME, NEF/DISCARD
	HC	HSRWRN-PSEG		:0B - RNR FRAME, NEF/DISCARD
	HC	HSRWRJ-PSEG		:0C - REJ FRAME, NEF/DISCARD
	HC	HSRWCT-PSEG		:0D - 'C' FIELD ERROR, NEF
	HC	HSRWIH-PSEG		:0E - I-FIELD PROHIBITED, NEF/DISCARD
	HC	HSRWOV-PSEG		:0F - FRAME TOO LONG, NEF/DISCARD
	HC	HSRWLN-PSEG		:10 - FRAME TOO SHORT, NEF/DISCARD
	HC	HSRWAU-PSEG		:11 - ADDR NOT CONFIGURATED, DISCARD
	HC	HSRWAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HSRWLS-PSEG		:13 - LOST DATA, NEF/DISCARD
	HC	HSRWTM-PSEG		:14 - TIMEOUT, HSTMOT


:	HSRFRM: NRM MODE, FRMR SENT, WAITING FOT SNRM/DISC/SIM
:	-----------------------------------------------
	HS	0
HSRFRM	HC	HSRFNU-PSEG		:0  - NO DATA, NO ACTION
	HC	HSRFIF-PSEG		:1  - INF FRAME, NEF/DISCARD
	HC	HSRFSN-PSEG		:2  - SNRM FRAME, ENTER HSXWOP STATE
	HC	HSRFUA-PSEG		:3  - UA FRAME, NEF/DISCARD
	HC	HSRFDS-PSEG		:4  - DISC FRAME, ENTER HSXWND STATE
	HC	HSRFDM-PSEG		:5  - DM FRAME, NEF/DISCARD
	HC	HSRFSM-PSEG		:6  - SIM FRAME, ENTER HSRWOP STATE
	HC	HSRFXD-PSEG		:7  - XID FRAME, NEF/DISCARD
	HC	HSRFTS-PSEG		:8  - TEST FRAME, NEF/DISCARD
	HC	HSRFFR-PSEG		:9  - FRMR FRAME, NEF/DISCARD
	HC	HSRFRR-PSEG		:0A - RR FRAME, NEF/DISCARD
	HC	HSRFRN-PSEG		:0B - RNR FRAME, NEF/DISCARD
	HC	HSRFRJ-PSEG		:0C - REJ FRAME, NEF/DISCARD
	HC	HSRFCT-PSEG		:0D - 'C' FIELD ERROR, NEF
	HC	HSRFIH-PSEG		:0E - I-FIELD PROHIBITED, NEF/DISCARD
	HC	HSRFOV-PSEG		:0F - FRAME TOO LONG, NEF/DISCARD
	HC	HSRFLN-PSEG		:10 - FRAME TOO SHORT, NEF/DISCARD
	HC	HSRFAU-PSEG		:11 - ADDR NOT CONFIGURATED, DISCARD
	HC	HSRFAD-PSEG		:12 - ADDR NOT DESIRED, DISCARD
	HC	HSRFLS-PSEG		:13 - LOST DATA, NEF/DISCARD
	HC	HSRFTM-PSEG		:14 - TIMEOUT, HSTMOT


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSXWOP STATE

:	HSXPNU: XMT QUEUE EMPTY
:	-----------------------
:	IF TIMEUP, RECOVER
:	ELSE, DISMISS
HSXPNU
:	CHECK TO SEE IF WAIT TOO LONG
	J	HSX.X			:DISMISS


:	HSXPRX: RE-XMT CMD IN XMT QUEUE
:	-------------------------------
:	CLEAR RE-XMT COUNTER (LSCRXC), ADJUST IC COUNT
:	IF NOT TIMEUP, DISMISS
HSXPRX
	LB	R5,LSCLKS+LSCRXC,RLSC,	:GET LSCRXC
	LIS	R0,0			:...
	STB	R0,LSCLKS+LSCRXC,RLSC,	:CLEAR RE-XMT COUNT
	SR	R0,R5			:R0 = NEGATIVE RE-XMT COUNT
	AHM	R0,LSCLKS+LSCIFC,RLSC,	:ADJUST IC OUNT
:	CHECK TO SEE IF WAIT TOO LONG
	J	HSX.X			:DISMISS


:	HSXPIF/HSXPDS/HSXPSM/HSXPXD/HSXPTS/HSXPFR
:	--------------------------------------------
:	DISCARD THIS CMD FROM XMT QUEUE
:	IF NOT TIME UP, DISMISS
HSXPIF
HSXPDS
HSXPSM
HSXPXD
HSXPTS
HSXPFR
	JAL	R5,DQXMTQ		:DELETE IT FROM XMT QUEUE
:	CHECK TIMEUP
	J	HSX.X			:DISMISS


:	HSXPSN: SNRM CMD IN XMT QUEUE
:	---------------------------
:	THIS IS IMPLEMENTAION ERROR
HSXPSN
	J	HSCRSH			:TO CRASH


:	HSXPUA: UA CMD IN XMT QUEUE
:	-------------------------
:	XMT UA, AND ENETER HSROPC STATE
HSXPUA
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	JAL	R5,SETSRC		:SET NSRM/UA RETRY LIMIT
	LHI	R0,HSROPT-PSEG		:ENTER HSROPT STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXPDM: DM CMD IN XMT QUEUE
:	---------------------------
:	XMT DM FRAME, AND ENTER HSRNDM STATE
HSXPDM
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,FHXMTQ		:FETCH THE CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRNDM-PSEG		:ENTER HSRNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV

	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSXDSP STATE


:	HSXSNU: XMT QUEUE EMPTY
:	-----------------------
:	IF NOT TIME UP , DISMISS
HSXSNU
	J	HSX.X			:CONTINUE TO XMT


:	HSXSRX: RE-XMT CMD IN XMT QUEUE
:	-------------------------------
:	CLEAR RE-XMT COUNT (LSCRXC), ADJUST IC COUNT
HSXSRX
	LB	R5,LSCLKS+LSCRXC,RLSC,	:GET LSCRXC
	LIS	R0,0			:...
	STB	R0,LSCLKS+LSCRXC,RLSC,	:....
	SR	R0,R5			:R0 = NEGATIVE RE-XMT COUNT
	AHM	R0,LSCLKS+LSCIFC,RLSC,	:ADJUST IC COUNT
	J	HSX.X			:DISMISS


:	HSXSIF/HSXSUA/HSXSDS/HSXSSM: INF/UA/RD/RIM CMD IN XMT QUEUE
:	------------------------------------------------
:	DISCARD THIS COMMAND
HSXSIF
HSXSUA
HSXSDS
HSXSSM
	JAL	R5,DQXMTQ		:DISCARD THIS CMD FROM XMT QUEUE
	J	HSX.X			:DISMISS


:	HSXSSN: SNRM CMD IN XMT QUEUE
:	-----------------------------
:	IMPLEMENTAION ERROR
HSXSSN
	J	HSCRSH			:TO CRASH


:	HSXSDM: DM CMD IN XMT QUEUE
:	---------------------------
:	XMT DM FRAME, AND ENTER HSRNDM STATE
HSXSDM
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	LHI	R0,HSRNDM-PSEG		:ENTER HSRNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXSXD/HSXSTS: XID/TEST CMD IN XMT QUEUE
:	-----------------------------------------
:	IF LAST RCV'ED FRAME IS XID/TEST, XMT XID/TEST, AND ETNER HSRNDM STATE
HSXSXD
HSXSTS
	SRHLS	R1,1			:SHIFT BACK TO GET CONVERTED CODE
	CLB	R1,LSCLKS+LSCCXC,RLSC,	:XID/XID OR TEST/TEST?
	JN	HSXST1			:NO, SKIP
HSXST0
	JAL	R5,RSTSEC		:RESET...
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRNDM-PSEG		:ENTER HSRNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV

HSXST1
	JAL	R5,DQXMTQ		:DISCARD THIS CMD
	J	HSX.X			:CONTINUE TO XMT


:	HSXSFR:	FRMR CMD IN XMT QUEUE
:	------------------------------
:	XMT FRMR AND ENTER HSRFRM STATE
HSXSFR
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R9,HSRFRM-PSEG		:ENTER HSRFRM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSXOPA STATE


:	HSXANU:	NRM MODE, NO CMD IN XMT QUEUE
:	-------------------------------------
:	DECIDE TO SEND RR OR RNR
HSXANU
	J	HSOPA2			:ELSE, SAME AS DIFF=K, IC = 0


:	HSXARX: RE-XMT 
:	----------------
:	RE-XMT I-FRAMES, DETAILS SEE ECMA-71 DIAGRAMS
:	(THE SAME AS INF CMD)
HSXARX


:	HSXAIF: NRM, INF CMD IN XMT QUEUE
:	---------------------------------
:	XMT I-FRAME, DETAILS SEE ECMA-71 DIAGRAMS
HSXAIF
HSOPA0
	LHL	R3,LSCLKS+LSCIFC,RLSC,	:GET IC VALUE
	JAL	R5,GETDIF		:DIFF=V(S)-VSU, IN R1, MAXW IN R6
	CR	R1,R6			:COMPRAE DIFF TO MAX WINDOW
	JGE	HSOPA2			:SKIP, IF DIFF >= K
	CHI	R3,1			:SEE IF MORE THAT 1 FRAME
	JLE	HSOPA1			:SKIP, IF IC = 1
	LR	R0,R6			:MOVE K TO R0
	SIS	R0,1			:R0 = K-1
	CR	R1,R0			:COMPARE DIFF TO (K-1)
	JL	HSOPA5			:DIFF < K-1 & IC>1, SKIP
:	ENTRY:(IC=1 & DIFF<K) OR (IC>1 & DIFF=K-1)
:	IF BUSY, XMT INF FRAME WITH F BIT OFF
:	ELSE, XMT INF FRAME WITH F BIT ON
HSOPA1
	JAL	R5,CHKBSY		:NO BB OR B.G. BUSY?
	J	HSOPA4			:NORMAL RETURN, NOT BUSY, SKIP
	J	HSOPA5			:BUSY, XMT INF FRAME WITH F BIT OFF


:	WHEN DIFF = K
:	-------------
:	IF BUSY, XMT RR, ELSE XMT RNR
HSOPA2	
	LHI	R1,XCRR			:ASSUME NOT BUSY, SO XMT RR
	JAL	R5,CHKBSY		:CHECK BUSY
	J	HSOPA3			:NOT BUSY, SKIP
	LHI	R1,XCRNR		:ELSE, XMT RNR
HSOPA3
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC

	J	HSOPA6			:TO ENTER HSROPC STATE

:	WHEN	(IC=1) AND (NOT BUSY)	OR
:		(DIFF=K-1) AND (IC>1) AND (NOT BUSY)
:	--------------------------------------------
:	XMT INF FRAME WITH F BIT ON
HSOPA4
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,FHXMTQ		:FETCH XMT CMD
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,DECIC		:DECREMENT IC BY 1
	JAL	R5,INCVS		:INCREASE VS BY 1
	J	HSOPA6			:TO ENTER HSROPC STATE


:	WHEN	(IC>1) AND (DIFF<(K-1))	OR
:		((IC>0) AND (DIFF<K) AND (BUSY))
:	---------------------------------------
:	XMT INF FRAME WITH F BIT OFF
HSOPA5
	JAL	R5,FHXMTQ		:SETUP XMT INF. FRAME PARAMETER
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,DECIC		:DECREASE IC BY 1
	JAL	R5,INCVS		:INCREASE VS BY 1
	J	HSX.X			:CONTINUE TO XMT


:	HSOPA6: TO ENTER HSROPC STATE
:	------------------------------
HSOPA6
	LHI	R0,HSROPC-PSEG		:ENTER RCV COMMAND STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXASN: SNRM CMD IN XMT QUEUE
:	-----------------------------
:	IMPLEMENTATION ERROR
HSXASN
	J	HSCRSH			:TO CRASH


:	HSXAUA/HSXAXD/HSXATS
:	---------------------------
:	NOT EXPECTED CMD, DISCARD
HSXAUA
HSXAXD
HSXATS
	JAL	R5,DQXMTQ		:DISCARD THIS CMD
	J	HSX.X			:CONTINUE TO XMT


:	HSXADS: RD CMD IN XMT QUEUE
:	---------------------------
:	XMT RD FRAME, ADN ENTER HSRWND STATE
HSXADS
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,FHXMTQ		:FETCH THE RD CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRWND-PSEG		:ENTER HSRWND STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXADM: DM CMD IN XMT QUEUE
:	---------------------------
:	XMT DM FRAME, AND ENETER HSRNDM STATE
HSXADM
	JAL	R5,RSTSEC		:RESET ...
	JAL	R5,FHXMTQ		:FETCH XMT CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRNDM-PSEG		:ENTER HSRNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXASM: RIM CMD IN XMT QUEUE
:	----------------------------
:	XMT RIM FRAME, AND ENTER HSRTOP STATE
HSXASM
	JAL	R5,RSTSEC		:RESET...
	JAL	R5,FHXMTQ		:FETCH XMT CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRTOP-PSEG		:ENTER HSRTOP STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FORM XMT TO RCV


:	HSXAFR: FRMR CMD
:	----------------
:	XMT FRMR AND ENTER HSRFRM STATE
HSXAFR
	J	HSXSFR


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSXOPB STATE


:	HSXBNU/HSXBRX/HSXBIF/HSXBXD/HSXBTS
:	-----------------------------------------
HSXBNU
HSXBRX
HSXBIF
HSXBXD
HSXBTS
	LHI	R1,XCRR			:ASSUME NOT BUSY, SO XMT RR
	JAL	R5,CHKBSY		:CHECK BUSY
	J	HSXB01			:NO BUSY, TO XMT RR
	LHI	R1,XCRNR		:ELSE, XMT RNR
HSXB01
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	LHI	R0,HSROPC-PSEG		:ENETER HSROPC STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXBSN: SNRM CMD  IN XMT QUEUE
:	------------------------------
:	IMPLEMENTAION ERROR
HSXBSN
	J	HSCRSH			:TO CRASH


:	HSXBUA/HSXBXD/HSXBTS: NOT EXPECTED CMD
:	--------------------------------------
:	DISCARD THIS CMD
HSXBUA
HSXBXD
HSXBTS
	JAL	R5,DQXMTQ		:DISCARD CMD
	J	HSX.X			:CONTINUE TO XMT


:	HSXBDS: RD CMD IN XMT QUEUE
:	---------------------------
:	XMT RD FRAME, AND ENTER HSRWND STATE
HSXBDS
	JAL	R5,RSTSEC		:RESET...
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRWND-PSEG		:ENTER HSRWND STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXBDM: DM CMD IN XMT QUEUE
:	---------------------------
:	XMT DM FRAME, AND ENTER HSRNDM STATE
HSXBDM
	JAL	R5,RSTSEC			:RESET...
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRNDM-PSEG		:ENTER HSRNDM STTAE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FORM XMT TO RCV


:	HSXBSM: RIM CMD IN XMT QUEUE
:	----------------------------
:	XMT RIM FRAME, AND ENTER HSRTOP STATE
HSXBSM
	JAL	R5,RSTSEC		:RESET...
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR,DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRTOP-PSEG		:ENTER HSRTOP STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXBFR: FRMR CMD
:	----------------
:	XMT FRMR AND ENTER HSRFRM STATE
HSXBFR
	J	HSXSFR


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSXOSP STATE


:	HSXONU: XMT QUEUE EMPTY
:	-----------------------
:	IF NOT TIME UP , DISMISS
HSXONU
	J	HSX.X			:CONTINUE TO XMT


:	HSXORX: RE-XMT CMD IN XMT QUEUE
:	-------------------------------
:	CLEAR RE-XMT COUNT (LSCRXC), ADJUST IC COUNT
HSXORX
	LB	R5,LSCLKS+LSCRXC,RLSC,	:GET LSCRXC
	LIS	R0,0			:...
	STB	R0,LSCLKS+LSCRXC,RLSC,	:....
	SR	R0,R5			:R0 = NEGATIVE RE-XMT COUNT
	AHM	R0,LSCLKS+LSCIFC,RLSC,	:ADJUST IC COUNT
	J	HSX.X			:DISMISS


:	HSXOIF/HSXOUA/HSXODS/HSXOSM
:	-----------------------------------
:	DISCARD THIS COMMAND
HSXOIF
HSXOUA
HSXODS
HSXOSM
	JAL	R5,DQXMTQ		:DISCARD THIS CMD FROM XMT QUEUE
	J	HSX.X			:DISMISS


:	HSXOSN: SNRM CMD IN XMT QUEUE
:	-----------------------------
:	IMPLEMENTAION ERROR
HSXOSN
	J	HSCRSH			:TO CRASH


:	HSXODM: DM CMD IN XMT QUEUE
:	---------------------------
:	XMT DM FRAME, AND ENTER HSRNDM STATE
HSXODM
	JAL	R5,RSTSEC		:RESET...
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRNDM-PSEG		:ENTER HSRNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXOXD/HSXOTS: XID/TEST CMD IN XMT QUEUE
:	-----------------------------------------
:	IF LAST RCV'ED FRAME IS XID/TEST, XMT XID/TEST, AND ETNER HSRNDM STATE
HSXOXD
HSXOTS
	SRHLS	R1,1			:SHIFT BACK TO GET CONVERTED CODE
	CLB	R1,LSCLKS+LSCCXC,RLSC,	:XID/XID OR TEST/TEST?
	JN	HSXST1			:NO, SKIP
	JAL	R5,RSTSEC		:RESET SECTOR DATA BUFFER BASE
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSROPC-PSEG		:ENTER HSROPC STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV

HSXOT1
	JAL	R5,DQXMTQ		:DISCARD THIS CMD
	J	HSX.X			:CONTINUE TO XMT


:	HSXOFR: FRMR CMD
:	----------------
:	XMT FRMR AND ENTER HSRFRM STATE
HSXOFR
	J	HSXSFR


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSXWND STATE


:	HSXWNU: XMT QUEUE EMPTY
:	-----------------------
:	IF NOT TIME UP , DISMISS
HSXWNU
	J	HSX.X			:CONTINUE TO XMT


:	HSXWRX: RE-XMT CMD IN XMT QUEUE
:	-------------------------------
:	CLEAR RE-XMT COUNT (LSCRXC), ADJUST IC COUNT
HSXWRX
	LB	R5,LSCLKS+LSCRXC,RLSC,	:GET LSCRXC
	LIS	R0,0			:...
	STB	R0,LSCLKS+LSCRXC,RLSC,	:....
	SR	R0,R5			:R0 = NEGATIVE RE-XMT COUNT
	AHM	R0,LSCLKS+LSCIFC,RLSC,	:ADJUST IC COUNT
	J	HSX.X			:DISMISS


:	HSXWIF/HSXWDS/HSXWSM/HSXWXD/HSXWTS
:	-----------------------------------------
:	DISCARD THIS COMMAND
HSXWIF
HSXWDS
HSXWSM
HSXWXD
HSXWTS
	JAL	R5,DQXMTQ		:DISCARD THIS CMD FROM XMT QUEUE
	J	HSX.X			:DISMISS


:	HSXWSN: SNRM CMD IN XMT QUEUE
:	-----------------------------
:	IMPLEMENTAION ERROR
HSXWSN
	J	HSCRSH			:TO CRASH


:	HSXWUA/HSXWDM: UA/DM CMD IN XMT QUEUE
:	---------------------------
:	XMT DM FRAME, AND ENTER HSRNDM STATE
HSXWUA
HSXWDM
	JAL	R5,RSTSEC		:RESET THE SECTOR DATA BUFFER BASE
	JAL	R5,FHXMTQ		:FETCH CMD
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	LHI	R0,HSRNDM-PSEG		:ENTER HSRNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


:	HSXWFR:	FRMR CMD
:	-----------------
:	XMT FRMR  AND ENTER HSRFRM STATE
HSXWFR
	J	HSXSFR


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSRNDM STATE


:	HSRDIF/HSRDUA/HSRDDM/HSRDFR/HSRDCT/HSRDIH
:	HSRDOV/HSRDLN/HSRDAU/HSRDAD/HSRDLS/HSRDRR/HSRDRN/HSRDRJ
:	-------------------------------------------------------------
:	IN NDM MODE, RCV'ED UN-DESIRED FRAMES, DISCARD  AND DISMISS
HSRDIF
HSRDUA
HSRDDM
HSRDRR
HSRDRN
HSRDRJ
HSRDFR
HSRDCT
HSRDIH
HSRDOV
HSRDLN
HSRDAU
HSRDAD
HSRDLS
	JAL	R5,IDELET		:DELETE RCV'ED FRAME
	JAL	R5,CHKIPF		:IS F BIT ON?
	J	HSR.R			:NO, SKIP TO CONTINUE RCVING
	LHI	R1,CDISC		:ELSE, QUEUE DISC CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HSXWND-PSEG		:ENTER HSXWND STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:(PREPARE FOR THE RETURN OF DM RESPONSE)
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRDSN/HSRDSM: NDM MODE, RCV'ED SNRM/SIM FRAME
:	------------------------------------------------
:	IF P BIT IS OFF, DISCARD IT
:	IF P BIT IS ON, QUEUE SNRM/SIM TO RCV QUEUE, AND ENTER HSXWOP STATE
HSRDSN
HSRDSM
	JAL	R5,IDELET		:DELETE INF FRAME FIRST
	JAL	R5,CHKIPF		:IS THE P BIT ON?
	J	HSR.R			:CONTINUE TO RCV
HSRDS1
	LHI	R1,CSNRM		:QUEUE SNRM CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	JAL	R5,CLRVSR		:CLEAR VS AND VR
	JAL	R5,CLRNSR		:CLEAR NS AND NR
	LHI	R0,HSXWOP-PSEG		:ENTER HSXWOP STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRDDS: NDM MODE, RCV'ED DISC FRAME
:	-----------------------------------
:	IF P BIT ON, QUEUE DISC CMD TO RCV QUEUE, AND ENTER HSXWND STATE
HSRDDS
	JAL	R5,CHKIPF		:IS THE RCV'ED FRAME WITH P BIT ON?
	J	HSR.R			:CONTINUE TO RCV
	LHI	R1,CDISC		:QUEUE DISC CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HSXWND-PSEG		:ENTER HSXWND STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRDXD/HSRDTS: XID/TEST RCV'ED
:	------------------------------
:	IF P BIT ON, QUEUE XID/TEST TO RCV QUEUE
:	ELSE, DISCARD THIS FRAME
HSRDXD
	LHI	R1,CXID
	JFS	HSRDT1

HSRDTS
	LHI	R1,CTEST

HSRDT1
	JAL	R5,CHKIPF		:IS RCV'ED FRAME WITH P BIT ON?
	J	HSRDT2			:NO, SKIP
	LB	R0,LSCLKS+LSCRST,RLSC,	:SAVE RCV RC CODE TO LSCCXC
	STB	R0,LSCLKS+LSCCXC,RLSC,	:...
	LHI	R0,HSXDSP-PSEG		:ENTER HSXDSP STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:..
	J	HSR.X			:SWITCH FROM RCV TO XMT

HSRDT2
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	J	HSR.R			:CONTINUE TO RCV


:	HSRDTM: TIMEOUT 
:	---------------
HSRDTM
:	J	HSTMOT			:(5/14/85/CHS)
	J	HSX.R			:(5/14/85/CHS)


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSROPT STATE



:	HSROIF: RCV'ED INF FRAME IN NRM MODE
:	------------------------
:	SAME AS HSRCIF AT HSROPC STATE, BUT ENTER HSROPC STATE FIRST
HSROIF
	LHI	R5,HSROPC-PSEG		:ENTER HSROPC STATE
	STH	R5,LSCLKS+LSCRHL,RLSC,
	J	HSRCIF			:SAME AS HSRCIF AT HSROPC STATE

:	HSRCSN: RCV'ED SNRM FRAME, DISCARD
:	-------------------------
:	IF RETRY UP, SEND TO BG
HSROSN
	JAL	R5,IDELET
:	JAL	R5,CHKIPF		:IF P BIT OFF, TO RCV(7/189/84/CHS)
:	J	HSR.R			: (7/19/84/CHS)
:	JAL	R5,DECSRC		:DECREASE RETRY COUNT (7/19/84/CHS)
:	LB	R0,LSCLKS+LSCSRC,RLSC,	:IF NO ZERO (7/19/84/CHS)
:	JN	HSR.R			:CONTINUE TO RCV (7/6/84/CHS)
	J	HSR.R			:CONTINUE TO RCV (7/6/84/CHS)
:	J	HSRDS1			:ELSE, SEND CSRNM TO BG (7/19/84/CHS)

:	HSRCDS: RCV'ED DISC FRAME
:	-------------------------
:	ENTER HSROPC STATE AND SAME AS HSRCDS
HSRODS
	LHI	R0,HSROPC-PSEG
	STH	R0,LSCLKS+LSCRHL,RLSC,
	J	HSRCDS			:SAME AS HSRCDS AT HSROPC STATE

:	HSROUA/HSRODM/HSROSM/HSRORJ/HSROFR/HSROCT/HSROIH/HSROOV/HSROLN
:	--------------------------------------------------------
:	NOT EXPECT FRAME RCV'ED, DISCARD, AND QUEUE NEF STATUS TO RCV QUEUE
HSROUA
HSRODM
HSROSM
HSRORJ
HSROFR
HSROCT
HSROIH
HSROOV
HSROLN
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
:	LHI	R1,USNEF+CSTATE		:QUEUE NEF STATUS TO RCV QUEUE
:	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,FRMRY		:SET THE REASON CODE
	J	HSFRMR			:GO TO FRMR HANDLING ROUTINE

:	HSRORR/HSRORN: RCV'ED RR/RNR IN NRM MODE
:	---------------------------------------
:	ENTER HSROPC STATE SNA SAME AS HSRCRR/HSRCRN AT HSROPC STATE
HSRORR
HSRORN
	JAL	R5,CHKIPF
	J	HSR.R
	LB	R0,LSCLKS+LSCNRR,RLSC,
	LR	R0,R0
	JN	HSROR1			:IF N(R) NOT RESET, FRMR
	LHI	R5,HSROPC-PSEG
	STH	R5,LSCLKS+LSCRHL,RLSC,
	J	HSRCRR			:SAME  AS HSRCRR/HSRCRN
HSROR1
	LHI	R0,FRMRN		:SET THE REJECT CODE
	J	HSFRMR

:	HSROXD/HSROTS: RCV'ED XID/TEST FRAME
:	---------------------------------------
:	ENTER HSROPC STATE, AND SAME AS HSRCXD/NSRCTS
HSROXD
HSROTS
	LHI	R5,HSROPC-PSEG
	STH	R5,LSCLKS+LSCRHL,RLSC,
	J	HSRCXD			:SAME AS HSRCXD/HSRCTS

:	HSROAU/HSROAD: RCV'ED FRAME WITH ADDR NOT SUPPORTED/DESIRED
:	-----------------------------------------------------------
:	DISCARD THIS FRAME
HSROAU
HSROAD
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	J	HSR.R			:CONTINUE TO RCV

:	HSRCLS: DATA LOST DUE TO BUFFER UNAVAILABLE
:	-------------------------------------------
:	ENTER HSROPC STATE, AND SAME AS HSRCLS
HSROLS
	LHI	R5,HSROPC-PSEG
	STH	R5,LSCLKS+LSCRHL,RLSC,
	J	HSRCLS			:SAME AS HSRCLS AT HSROPC STATE

:	HSROTM: TIMEOUT
:	---------------
:	TIMEOUT,
HSROTM
	J	HSTMOT


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSROPC STATE



:	HSRCIF: RCV'ED INF FRAME IN NRM MODE
:	------------------------
:	IF GOOD FRAME, QUEUE IT TO RCV QUEUE
:	IF P BIT OFF, CONTINUE TO RCV
:	IF P BIT ON,  ENTER HSXOPA STATE
HSRCIF
	JAL	R5,CHKIPF		:IS P BIT ON?
	J	HSRCI2			:NO, SKIP
	JAL	R5,CKNSVR		:ELSE, IS N(S)=V(R)?
	J	HSRCI1			:NO, SKIP (P=0 && N(S) NOT= V(R))
:	JAL	R5,CHKBSY		:CHECK BUSY OR NOT
:	J	HSRCI1			:SKIP,(P=0&N(S)=V(R)&NOT BUSY)

:	(P=1) & (N(S)=V(R))
:	--------------------
	JAL	R5,CHKNR		:N(R) IN [VSU,V(S)]? (8/13/85/CHS)
	J	HSROR1			:NO, TO SEND FRMR (8/13/85/CHS)
	JAL	R5,INCVR		:INC. V(R)
	JAL	R5,INCIC		:IC=IC+V(S)-N(R)
	JAL	R5,SETUSR		:VSU=V(S)=N(R)
	JAL	R5,QUEINF		:QUEUE INF FRAME TO RCV QUEUE
	LHI	R0,HSXOPA-PSEG		:ENTEER HSXOPA STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT

:	(P=1) AND (N(S) NOT= V(R))
:	----------------------------
:	DISCARD THE FRAME, AND IGNORE THE N(R) FIELD
HSRCI1
	LB	R0,LSCLKS+LSCVSU,RLSC,	:RESTORE N(R) (8/13/85/CHS)
	STB	R0,LSCLKS+LSCNRR,RLSC,	:... (8/13/85/CHS)
	JAL	R5,INCIC		:IC=IC+V(S)-N(R)
	JAL	R5,SETUSR		:VSU=V(S)=N(R)
	JAL	R5,IDELET		:DISCARD THIS RCV'ED FRAME
	LHI	R0,HSXOPA-PSEG		:ENTER HSXOPA STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:....
	J	HSR.X			:SWITCH FROM RCV TO XMT

:	(P = 0)
:	------------
HSRCI2
	JAL	R5,CKNSVR		:IS N(S) = V(R) ?
	J	HSRCI3			:NO, TO DISCARD THIS RCV'ED FRAME
					:ELSE, (P=0) & (N(S)=V(R))
	JAL	R5,CHKNR		:N(R) IN [VSU, V(S)]? (8/13/85/CHS)
	J	HSRCIY			:NO, SKTIP (8/13/85/CHS)
HSRCIX					:(8/13/85/CHS)
	JAL	R5,INCVR		:INCE. V(R)
	JAL	R5,SETUR		:SET VSU=N(R)
	JAL	R5,QUEINF		:QUEUE THE RCV'ED FRAME TO RCV QUEUE
	J	HSR.R			:CONTINUE TO RCV
HSRCIY					:(8/13/85/CHS)
	LB	R0,LSCLKS+LSCVSU,RLSC,	:RESTORE N(R) (8/13/85/CHS)
	STB	R0,LSCLKS+LSCNRR,RLSC,	:.. (8/13/85/CHS)
	J	HSRCIX			:TO CONTINUE (8/13/85/CHS)

:	OUT SEQUENCED FRAME, DISACRD
:	----------------------------
HSRCI3
	JAL	R5,IDELET		:DISCARD THIS FRAME
	J	HSR.R			:CONTINUE TO RCV


:	HSRCSN: RCV'ED SNRM FRAME
:	-------------------------
:	QUEUE SNRM CMD TO RCV QUEUE, AND ENTER HSXWOP STATE
HSRCSN
	J	HSRDSN			:SAME AS RCV'ED SNRM IN NDM STATE


:	HSRCDS: RCV'ED DISC FRAME
:	-------------------------
:	IF P BIT ON, QUEUE DISC CMD TO RCV QUEUE AND ENTER HSXWND STATE
HSRCDS
	JAL	R5,CHKIPF		:IS P BIT ON
	J	HSR.R			:NO, CONTINUE TO RCV
	LHI	R1,CDISC		:QUEUE DISC CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HSXWND-PSEG		:ENTER HSXWND STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRCUA/HSRCDM/HSRCSM/HSRCRJ/HSRCFR/HSRCCT/HSRCIH/HSRCOV/HSRCLN
:	--------------------------------------------------------
:	NOT EXPECT FRAME RCV'ED, DISCARD, AND QUEUE NEF STATUS TO RCV QUEUE
HSRCUA
HSRCDM
HSRCSM
HSRCRJ
HSRCFR
HSRCCT
HSRCIH
HSRCOV
HSRCLN
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
:	LHI	R1,USNEF+CSTATE		:QUEUE NEF STATUS TO RCV QUEUE
:	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,FRMRY		:SET FRMR REASON CODE (07/22/86 YLH)
	J	HSFRMR			:GO TO FRMR HANDLING ROUTINE


:	HSRCRR/HSRCRN: RCV'ED RR/RNR IN NRM MODE
:	--------------------------------------------
HSRCRR
HSRCRN
	JAL	R5,CHKIPF		:IS P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	JAL	R5,CHKNR		:N(R) IN [VSU, V(S)]? (8/13/85/CHS)
	J	HSROR1			:NO, TO SEND FRMR (8/13/85/CHS)
	JAL	R5,INCIC		:IC=IC+V(S)-N(R)
	JAL	R5,SETUSR		:SET VSU=V(S)=N(R)
	LB	R5,LSCLKS+LSCRST,RLSC,	:GET RC CODE
	LHI	R0,HSXOPA-PSEG		:ASSUME RR, AND ENTER HSXOPA STATE
	CLHI	R5,RCRR			:HIT ?
	JEFS	HSRCR1			:YES, SKIP
	LHI	R0,HSXOPB-PSEG		:ELSE, RNR, ENTER HSXOPB STATE
HSRCR1
	STH	R0,LSCLKS+LSCXHL,RLSC,	:....
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRCXD/HSRCTS: RCV'ED XID/TEST FRAME
:	---------------------------------------
:	IF P BIT ON, QUEUE XID/TEST TO RCV QUEUE
:	ELSE, DSICARD THIS FRAME
HSRCXD
HSRCTS
	JAL	R5,CHKIPF		:IS P BIT ON?
	J	HSRCT1			:NO, SKIP
	LB	R1,LSCLKS+LSCRST,RLSC,	:SAVE THE RCV RC CODE
	STB	R1,LSCLKS+LSCCXC,RLSC,	:INTO LSCCXC
	JAL	R5,QUEETE		:XID/TEST CMD TREAT AS INF CMD
	LHI	R0,HSXOSP-PSEG		:ENTER HSXOSP STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT STATE

HSRCT1
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	J	HSR.R			:CONTINUE TO RCV


:	HSRCAU/HSRCAD: RCV'ED FRAME WITH ADDR NOT SUPPORTED/DESIRED
:	-----------------------------------------------------------
:	DISCARD THIS FRAME
HSRCAU
HSRCAD
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	J	HSR.R			:CONTINUE TO RCV


:	HSRCLS: DATA LOST DUE TO BUFFER UNAVAILABLE
:	-------------------------------------------
:	IF P BIT OFF, DISCARD , AND CONTINUE TO RCV
:	IF P BIT ON, AND N(S)=V(R) SET VSU=V(S)=N(R) AND IC=IC+V(S)-N(R)
HSRCLS
	JAL	R5,IDELET		:THIS FRAME ALWAYS DISCARD
	JAL	R5,CHKIPF		:IS P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	JAL	R5,CKNSVR		:IS THE RCV'ED FRAME 'GOOD'?
	J	HSR.R			:NO, CONTINUE TO RCV
	JAL	R5,INCIC		:IC=IC+V(S)-N(R)
	JAL	R5,SETUSR		:SET VSU=V(S)=N(R)
	LHI	R0,HSXOPA-PSEG		:ENTER HSXOPA STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRCTM: TIMEOUT
:	---------------
:	TIMEOUT,
HSRCTM
	J	HSTMOT


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSRTOP STATE


:	HSRTIF/HSRTSN/HSRTDS/HSRTXD/HSRTTS
:	HSRTRR/HSRTRN/HSRTLS:
:	----------------------------------
:	NOT EXPECTED FRAME, DISCARD IT
:	IF P BIT ON, RE-XMT RIM FRAME
HSRTIF
HSRTSN
HSRTDS
HSRTXD
HSRTTS
HSRTRR
HSRTRN
HSRTLS
	JAL	R5,IDELET		:DISCARD THIS FRAME
	JAL	R5,CHKIPF		:IS RCV''ED FRAME WITH P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	LB	R1,LSCLKS+LSCCXC,RLSC,	:GET RIM XMT OP CODE
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	STH	RLSC,LCBTAB+LCBC.X,RLCB, :SET UP C.X (7/31/85/CHS)
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	J	HSX.R			:SWITCH XMT TO RCV


:	HSRTUA/HSRTDM/HSRTRJ/HSRTFR
:	HSRTCT/HSRTIH/HSRTOV/HSRTLN:
:	-------------------------------------
:	NOT EXPECTED FRAME, DISCARD
:	IF P BIT ON, SET WXYZ BIT, AND GO TO HSFRMR
HSRTUA
HSRTDM
HSRTRJ
HSRTFR
HSRTCT
HSRTLN
	JAL	R5,IDELET		:DISCARD THIS FRAME
	JAL	R5,CHKIPF		:THE RCV'ED FRAME HAS P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	LHI	R0,FRMRW		:SET W BIT ON
	J	HSFRMR			:GO TO XMT FRMR


:	IPUT INHIBITED
:	--------------
HSRTIH
	JAL	R5,CHKIPF		:THE RCV'ED FRAME HAS P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	LHI	R0,FRMRX		:SET X BIT ON
	J	HSFRMR			:GO TO XMT FRMR


:	INPUT OVERFLOW
:	--------------
HSRTOV
	JAL	R5,CHKIPF		:THE RCV'ED FRAME HAS P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	LHI	R0,FRMRY		:SET Y BIT ON
	J	HSFRMR			:GO TO XMT FRMR


:	HSRTSM: SIM RCV'ED
:	--------------------
:	IF P BIT ON, QUEUE SIM CMD TO RCV QUEUE, AND ENTER HSXWOP STATE
HSRTSM
	JAL	R5,CHKIPF		:IS RCV'ED FRAME P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	LHI	R1,CSIM			:QUEUE SIM CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HSXWOP-PSEG		:ENTER HSXWOP STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRTAU/HSRTAD: WRONG ADDR FRAME RCV'ED
:	---------------------------------------
:	DISCARD THIS FRAME, DISMISS
HSRTAU
HSRTAD
	JAL	R5,IDELET		:DISCARD THE RCV'ED FRAME
	J	HSR.R			:CONTINUE TO RCV


:	HSRTTM: TIMEOUT 
:	---------------
HSRTTM
	J	HSTMOT


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSRWND STATE


:	HSRWIF/HSRWSN/HSRWSM/HSRWXD/HSRWTS/HSRWRR/HSRWRN/HSRWLS
:	-------------------------------------------------------
:	NOT EXPECTED FRAME RCV'ED , DISCARD IT
:	IF P BIT ON, RE-XMT RD FRAME
HSRWIF
HSRWSN
HSRWSM
HSRWXD
HSRWTS
HSRWRR
HSRWRN
HSRWLS
	J	HSRTLS			:SAME AS HSRTLS IN HSRTOP STATE


:	HSRWUA/HSRWDM/HSRWRJ/HSRWFR
:	HSRWCT/HSRWIH/HSRWOV/HSRWLN:
:	-------------------------------------
:	NOT EXPECTED FRAME, DISCARD
:	IF P BIT ON, SET WXYZ BIT, AND GO TO HSFRMR
HSRWUA
HSRWDM
HSRWRJ
HSRWFR
HSRWCT
HSRWLN
	J	HSRTLN			:SAME AS HSRTLN IN HSRTOP STATE


HSRWIH
	J	HSRTIH			:SAME AS HSRTIG IN HSRTOP STATE


HSRWOV
	J	HSRTOV			:SAME AS HSRTOV IN HSRTOP STATE


:	HSRWDS: DISC FRAME RCV'ED
:	-------------------------
:	IF P BIT ON, QUEUE DISC CMD TO RCV QUEUE, AND ENTER HSXWND STATE
HSRWDS
	JAL	R5,CHKIPF		:IS RCV'ED FRAME P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	LHI	R1,CDISC		:QUEUE DISC CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HSXWND-PSEG		:ENTER HSXWND STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRWAU/HSRWAD: WRONG ADDR FRAME RCV'ED
:	---------------------------------------
:	DISCARD THIS FRAME, DISMISS
HSRWAU
HSRWAD
	J	HSRTAD			:SAME AS HSRTAD IN HSRTOP STATE


:	HSRWTM: TIMOUT
:	--------------
:	GO TO CRASH
HSRWTM
	J	HSCRSH			:TO CRASH


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN HSRFRM STATE


:	HSRFIF/HSRFXD/HSRFTS/HSRFRR/HSRFRN/HSRFLS
:	-------------------------------------------------------
:	NOT EXPECTED FRAME RCV'ED , DISCARD IT
:	IF P BIT ON, RE-XMT LAST FRMR FRAME
HSRFIF
HSRFXD
HSRFTS
HSRFRR
HSRFRN
HSRFLS
:	J	HSRTLS			:SAME AS HSRTLS IN HSRTOP STATE(3/20/85/CHS)
	JAL	R5,IDELET		:DISCARD THIS FRAME (3/20/85)
	JAL	R5,CHKIPF		:P BIT ON? (3/20/85/CHS)
	J	HSR.R			:NO, CONTINUE TO RCV(3/20/85)
	LHI	R0,FRMRW		:SET W BIT ON(3/20/85/CHS)
	J	HSFRMR			:GO SEND FRMR (3/20/85/CHS)


:	HSRFUA/HSRFDM/HSRFRJ/HSRFFR
:	HSRFCT/HSRFIH/HSRFOV/HSRFLN:
:	-------------------------------------
:	NOT EXPECTED FRAME, DISCARD
:	IF P BIT ON, SET WXYZ BIT, AND GO TO HSFRMR
HSRFUA
HSRFDM
HSRFRJ
HSRFFR
HSRFCT
HSRFLN
	J	HSRTLN			:SAME AS HSRTLN IN HSRTOP STATE


HSRFIH
	J	HSRTIH			:SAME AS HSRTIG IN HSRTOP STATE


HSRFOV
	J	HSRTOV			:SAME AS HSRTOV IN HSRTOP STATE


:	HSRFSM/HSRFSN: SNRM/SIM FRAME RCV'ED
:	-------------------------
:	IF P BIT ON, QUEUE SNRM/SIM CMD TO RCV QUEUE, AND ENTER HSXWOP STATE
HSRFSN
	LHI	R1,CSNRM
	JFS	HSRFS1

HSRFSM
	LHI	R1,CSIM

HSRFS1
	JAL	R5,CHKIPF		:IS RCV'ED FRAME P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	JAL	R5,QUECMD		:QUEUE SNRM/SIM CMD TO RCV QUEUE
					:(3.F01/07/14/87/DB/START)
	JAL	R5,CLRVSR,,		:RESET SEQUENCE NUMBERS
	JAL	R5,CLRNSR,,		:...
					:(3.F01/07/14/87/DB/END)
	LHI	R0,HSXWOP-PSEG		:ENTER HSXWOP STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRFDSO DISC FRAME RCV'ED
:	-------------------------
:	IF P BIT ON, QUEUE DISC CMD TO RCV QUEUE, AND ENTER HSXWND STATE
HSRFDS
	JAL	R5,CHKIPF		:IS RCV'ED FRAME P BIT ON?
	J	HSR.R			:NO, CONTINUE TO RCV
	LHI	R1,CDISC		:QUEUE DISC CMD TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HSXWND-PSEG		:ENTER HSXWND STATE
	STH	R0,LSCLKS+LSCXHL,RLSC,	:...
	J	HSR.X			:SWITCH FROM RCV TO XMT


:	HSRFAU/HSRFAD: WRONG ADDR FRAME RCV'ED
:	---------------------------------------
:	DISCARD THIS FRAME, DISMISS
HSRFAU
HSRFAD
	J	HSRTAD			:SAME AS HSRTAD IN HSRTOP STATE


:	HSRFTM: TIMEOUT
:	---------------
HSRFTM
	J	HSTMOT			:TO CRASH


	SUBTTL (HDXSEC) NRM MODE -- FRMR HANDLING


:	NORMAL RESPONSE MODE ---- FRMR HANDLING
:	--------------------------------------
:	XMT FRMR FRAME, AND QUEUE STATUS<USFRMR> TO RCV QUEUE
HSFRMR	
	JAL	R4,GBB			:GET XMT BUFFER
	J	HSFRM1			:NO BB, SKIP
	BBSTOR  R3,LSCLKS+LSCXHP,RLSC,	:PUT INTO LSC
	LHI	R4,-BBFLSZ+BBFPSZ	:INIT BB INDEX
	LIS	R5,3			:LENGTH = 3
	STH	R5,LSCLKS+LSCXCN,RLSC,	:PUT INTO LSC
:	STH	R5,BBUFER+BBFLSZ-BBFPSZ,R4,R3
:					:PUT INTO 1ST HW OF BB
:	AIS	R4,2			:ADVANCE BB INDEX(10/24/84/CHS)
	LB	R5,LSCLKS+LSCCTL,RLSC,	:GET THE RCV'ED "C" BYTE
	STB	R5,BBUFER+BBFLSZ-BBFPSZ,R4,R3
					:PUT IN THE 1ST BYTE OF FRMR
	AIS	R4,1			:ADVANCE BB  INDEX
	LB	R6,LSCLKS+LSCVRX,RLSC,	:GET N(R) VALUE FROM RLSC
	SLHLS	R6,5			:SHIFT LEFT 5 BIT-POSITION
	LB	R5,LSCLKS+LSCVSX,RLSC,	:GET N(S) VALUE FROM RLSC
	SLHLS	R5,1			:SHIFT LEFT 1 BIT-POSITION (07/22/86 YLH)
	OR	R5,R6			:PUT N(S) AND N(R) TOGETHER
	STB	R5,BBUFER+BBFLSZ-BBFPSZ,R4,R3
					:PUT IN THE 2ND BYTE OF FRMR
	AIS	R4,1			:ADVANCE BB INDEX
	STB	R0,BBUFER+BBFLSZ-BBFPSZ,R4,R3
					:PUT IN THE 3RD BYTE OF FRMR
	SLHLS	R5,8			:
	OR	R5,R0
	LR	R3,R5			:R3 = 2ND AND 3RD BYTE OF FRMR
	LHI	R1,USFRMR+CSTATE	:QUEUE FRMR SENT STATUS TO RCV QUEUE
	JAL	R5,QUERCV		:QUEUE IT
	JAL	R5,SETOPF		:SET XMT WITH F BIT ON
	LHI	R1,XCFRMR		:XMT FRMR RESPONSE
	STH	RLSC,LCBTAB+LCBC.X,RLCB, :SET UP C.X
	JAL	R5,SXMT			:DO THE XMT
	J	HSDISC			:IF XMT ERRROR, DISC
	JAL	R5,FLSIOQ		:FLUSH ANY RCV'ED FRAMES
	JAL	R5,RSTSEC		:RESET SECTOR OUT DATA BUFFER BASE
	LHI	R0,HSRFRM-PSEG		:ENTER HSRFRM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV

HSFRM1
	JAL	R10,CRASH,,
	BC	0,0,0,088


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC IN EXCEPTIONAL STATE


:	HSRDNU/HSRCNU/HSRONU/HSRTNU/HSRWNU/HSRFNU
:	-----------------------------------------
HSRDNU
HSRCNU
HSRONU
HSRTNU
HSRWNU
HSRFNU
	J	DSPRC1			:RETURN TO PTP RCV DISPATCHER

:	HSCRSH: CRASH ROUTNE
:	--------------------
HSCRSH
	JAL	R10,CRASH,,		:... (01/28/87 YLH)
	BC	0,0,0,088		:...


:	HSDISC: XMT ERROR
:	--------------------
:	DEQUEUE ALL CMD'S IN XMT QUEUE AND QUEUE USXMT STATUS TO RCV QUEUE
HSDISC
	JAL	R5,RSTSEC		:RESET ...(11/11/85/CHS)
	JAL	R5,PKXMTQ		:PEEK AT THE XMT QUEUE
	CLHI	R1,-1			:XMT QUEUE EMPTY?
	JEFS	HSDIS1			:YES, SKIP
	JAL	R5,DQXMTQ		:NO, DELETE THIS CMD
	JBS	HSDISC			:LOOP
HSDIS1
	JAL	R5,FLSIOQ		:..(1/3/85/CHS)
	JAL	R5,RSTSEC		:RESET ...
	LHI	R1,USXMT+CSTATE		:QUEUE XMT ERROR STATUS TO RV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HSRNDM-PSEG		:ENTER HSRNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:...


:	HSTMOT: TIMEOUT WHEN NO FRAME RCV'ED
:	------
:	IF NO ACTITVIY TIMER NOT EXPIRED, NO ACTION RETURN TO DISPATCHER
:	ELSE, INFORM BG, AND GO TO NDM
:	REMARK ****
HSTMOT
					:(5/10/85/CHS, START)
	JAL	R5,RSTSEC		:RESET
	LHI	R1,USINOP+CSTATE	:QUEUE INOP ERROR STATUS
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HSRNDM-PSEG		:ENTER HSRNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
					:(5/10/85/CHS, END)
	J	HSX.R			:RETURN TO PTP DISPATCHER


	SUBTTL (HDXSEC) PROCESSING ROUTINES FOR HDXSEC FOR CLEARP CMD


:	HSCLRI: CLEARP CMD AT ANY STATE
:	-------------------------------
:	DELETE ALL XMT CMD FROM XMT QUEUE, CLEAN UP OTHER STUFF
:	QUEUE A STATUS<USCLRD> TO RCV QUEUE
HSCLRI
	JAL	R5,RSTSEC		:(11/11/85/CHS)
	JAL	R5,PKXMTQ		:LOOK AT THE 1ST CMD
	CLHI	R1,-1			:IT THE XMT CMD QUEUE EMPTY?
	JEFS	HSCLR1			:YES, SKIP
	JAL	R5,DQXMTQ		:ELSE, DELETE THIS CMD
	JBS	HSCLRI			:AND LOOK AT NEXT ONE
HSCLR1
	JAL	R5,FLSIOQ
	JAL	R5,RSTSEC
	LHI	R1,USCLRD+CSTATE	:QUEUE CLEARED STATUS TO RCV QUEUE
	JAL	R5,QUECMD		:QUEUE IT
	LHI	R0,HSRNDM-PSEG		:AND ENTER HSRNDM STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	J	HSX.R			:SWITCH FROM XMT TO RCV


	SUBTTL (HDXSEC) PROCESSING ROUTIENS FOR HDXSEC FOR TERMP CMD


:	HSTRMI: TERMP CMD AT ANY  STATE
:	-------------------------------
:	THIS SHOULD NOT HAPPEN FOR HDX SEC, CRASH
HSTRMI
	J	HSCRSH			:TO CRASH


	SUBTTL (HDXSEC) PRIMITIVE PROCESSING ROUTINE FOR HDXSEC


:	HSX.X: CONTINUE TO XMT (SAME CU)
:	---------------------------------
HSX.X
	J	DSPDMS			:RETURN TO PTP XMT DISPATCHER


:	HSX.R:	SWITCH FROM XMT TO RCV
:	------------------------------
:	FOR HDX SEC RCV'ING ALWAYS WILDCARD RCV'ING
HSX.R
	LIS	R1,0			:CLEAR XMT STATE
	STH	R1,LSCLKS+LSCXHL,RLSC,	:...
	STH	R1,LCBTAB+LCBC.X,RLCB,	:NOT XMT
	LB	R1,LSCLKS+LSCRID,RLSC,	:GET REL #
	RBT	R1,LCBTAB+LCBXMT,RLCB,	:SWITCH FROM XMT
	SBT	R1,LCBTAB+LCBRCV,RLCB,	:TO RCV
	JAL	R5,SETRT1		:SET T1 TIMER


:	HSR.R: CONTINUE TO RCV
:	-----------------------
:	FOR HDX SEC RCV'ING ALWAYS WILDCARD RCV'ING
HSR.R
	LIS	R1,0			:INIT R1 TO 0
	STH	R1,LCBTAB+LCBC.R,RLCB,	:INDICATE A WILDCARD RCV'ING
	J	DSPRC1			:RETURN TO PTP RCV DISPATCHER


:	HSR.X:	SWITCH FROM RCV TO XMT FOR THE SAME CU
:	-----------------------------------------------
HSR.X
	JAL	R5,SETTRX		:SET RCV TO XMT TURN AROUND TIME
	LIS	R0,0			:CLEAR RCV STATE
	STH	R0,LSCLKS+LSCRHL,RLSC,	:...
	STH	R0,LCBTAB+LCBC.R,RLCB,	:NO SPECIFIC RCVING(2/27/85/CHS)
	LB	R0,LSCLKS+LSCRID,RLSC,	:GET REL #
	RBT	R0,LCBTAB+LCBRCV,RLCB,	:SWITCH FROM RCV TO XMT
	SBT	R0,LCBTAB+LCBXMT,RLCB,	:...
	STH	RLSC,LCBTAB+LCBC.X,RLCB, :SET UP XMT CU
	J	DSPDMS			:RETURN TO PTP XMT DISPATCHER


	FO	FGGBDF
	FO	SNAEXC
	FO	GBLDEF
	FO	SFGXMT
	FO	SFGRCV
	FO	MAIN

	EM
	EI	(DLCSHD)
	EI	(HOSTIF)
 	SUBTTL	(SNA) SUPPORTING ROUTINES FOR BACKGROUND MODULES - BGSUBR
:BSUB00.F00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	RA	0			:RADIX TO HEX

	MO	.,BSUB

:	GL	TRASHO,INACTI			:(01/27/87 YLH)
	GL	TRASHO,INACTI,PUCTAB,LUCTAB	:(01/27/87 YLH)

	LO	GBLDEF
	LO	FRNTND
	LO	CMDLST
	LO	MAIN

:	REGISTERS USED
:	--------------
:R6	- LINK REGISTER
RBCC	EQ	R8			:BUFFER CHARACTER COUNT
RBBA	EQ	R10			:BBUFERLET BASE ADDRESS
RBBX	EQ	R9			:BBUFERLET INDEX
RDCB	EQ	R12			:DCB ADDR

:	LOCAL STORAGES
:	--------------
	SEG	A.DATA
RTRN	WS	1			:SAVE AREA FOR RETURN ADDRESS
RSMSAV	HS	20			:REGISTER SAVE AREA
RSLSAV	HS	20			:REGISTER SAVE AREA

	SUBTTL	LINKAGE BETWEEN FRNTND AND NISC

	SEG	A.CODE

:	EMPTYI/EMPTYO
:	----------
:	LINK ON R4
:	REQUIRED BY FRNTND, AND LINK TO NISC
EMPTYI;EMPTYO
	JR	R4

:	ACTIV0:	PORT 0 MESSAGES HANDLER
:	-----
:	REQUIRED BY FRNTND, AND LINK TO NISC
ACTIV0
	GL	ACTI0V
	J	ACTI0V,,		:LINK TO NISC

:	ACTIVN:	NEEDLE HANDLING 
:	------
:	REQUIRED FROM FRNTND, LINK TO NISC
ACTIVN
	GL	ACTINV
	J	ACTINV,,		:LINK TO NISC


	SUBTTL	Device Control Blocks Support Routines


	SEG	A.CODE

:	IZDCB:	DCB INITIALIZER ROUTINE
:	-------
:	INPUT:	NONE
:		R6 - LINK REGISTER
:	OUTPUT:	DCB INITIALIZAED
:	DESTROYED: R0,R1,R2,R3,R4
IZDCB
	LIS	R1,DCB1ST-DCBLKS	:OFFSET TO FIRST DCB
	STH	R1,DCBACT,,		:PUT ON ACTIVE LIST
	LIS	R4,0			:
	LI	R3,(NPORT+1)*DCBLEN	:NUMBER OF BYTES TO CLEAR
IZDCB1
	ST	R4,DCBLKS,R3,		:INIT TO ZERO
	SIS	R3,4			:DECREMENT LOOP COUNTER
	JGBS	IZDCB1			:REPEAT
	STH	R4,DCBLKS+DCBCHN,R1,	:SET END CHAIN
	LHI	R0,INACTI-PSEG		:OFFSET FOR INACTIVE PORT CONTROL
					:MSG PROCESS TABLE
	STH	R0,DCBLKS+ACTIVC,R1,	:STORE IT
	LHI	R0,XTOSS		:OFFSET FOR ROUTINE TO TOSS DATA MSG
	STH	R0,DCBLKS+ACTIVD,R1,	:STORE IT
	LHI	R0,TRASHO-PSEG		:OFFSET FOR INVALID OUTPUT REQUEST
	STH	R0,DCBLKS+ACTIVO,R1,	:STORE IT
	LHI	R0,0			:NOT TIMEOUT
	STH	R0,DCBLKS+ACTIVT,R1,	:STORE IT
	AHI	R1,DCBLEN		:POINT TO NEXT DCB
	STH	R1,DCBFRE,,		:PUT ON FREE LIST
	LHI	R2,NPORT-1		:SET UP LOOP
IZDCB2
	LR	R3,R1			:COPY DCB POINTER
	AHI	R1,DCBLEN		:POINT TO NEXT DCB
	STH	R1,DCBLKS+DCBCHN,R3,	:STORE CHAIN POINTER
	SIS	R2,1			:DECREMENT LOOP
	JGBS	IZDCB2			:REPEAT IF MORE
	STH	R4,DCBLKS+DCBCHN,R1,	:END CHAIN
	JR	R6			:AND RETURN

:	GETDCB:	GET DCB ROUTINE
:	-------
:	INPUT:	NONE
:		R6 - LINK REGISTER
:	OUTPUT: RDCB - ADDR OF DCB
:		SKIP+2, IF NONE
:	DESTROYED: R0,R4
GETDCB
	LHL	RDCB,DCBFRE,,		:GET FREE LIST POINTER
	JE	2,R6			:NONE FOUND... RETURN
	LHL	R4,DCBLKS+DCBCHN,RDCB,	:GET POINTER TO NEXT
	STH	R4,DCBFRE,,		:MAKE IT HEAD OF LIST
	LHL	R4,DCBACT,,		:GET ACTIVE LIST POINTER
	STH	R4,DCBLKS+DCBCHN,RDCB,	:PUT ON ACTIVE LIST
	STH	RDCB,DCBACT,,		:MAKE IT NEW HEAD OF LIST
	LIS	R0,0			:INIT R0 TO 0
	LHI	R4,DCBCHN-2		:INIT R4 TO DCBLEN
GETDC1	STH	R0,DCBLKS,RDCB,R4	:CLEAR THIS DCB
	SIS	R4,2			:DECREASE 2 BYTES
	JGEBS	GETDC1			:LOOP
	JR	R6			:AND RETURN

:	RELDCB: RELEASE DCB BLOCK REOUTINE
:	-------
:	INPUT:	RDCB SET UP
:		R6 - LINK REGISTER
:	OUTPUT:	NONE
:	DESTORYED: R3,R4
RELDCB
	XR	R4,R4			:CLEAR THE REGISTER (08/14/86 MIA)
	STH	R4,DCBLKS+DCBIPR,RDCB,	:CLEAR PORT NUMBER (08/14/86 MIA)
	STB	R4,DCBLKS+DCBSTA,RDCB,	:CLEAR STATUS (08/14/86 MIA)
	LHL	R3,DCBACT,,		:LOAD ACTIVE LIST POINTER
	CR	R3,RDCB			:TEST FOR MATCH
	JEFS	RELDC2			:HEAD OF LIST MATCHES...SKIP
RELDC1
	LHL	R4,DCBLKS+DCBCHN,R3,	:GET POINTER TO NEXT IN CHAIN
	JE	RELDC6			:ERROR...NOT FOUND IN CHAIN
	CR	R4,RDCB			:IS THIS PREDECESSOR?
	JEFS	RELDC3			:YES...SKIP
	LR	R3,R4			:NO...GO ON TO NEXT
	JBS	RELDC1			:LOOP
RELDC2
	LHL	R3,DCBLKS+DCBCHN,RDCB,	:GET SUCCESSOR
	STH	R3,DCBACT,,		:MAKE IT NEW HEAD OF LIST
	JFS	RELDC4			:TO ...
RELDC3
	LHL	R4,DCBLKS+DCBCHN,RDCB,	:GET SUCCESSOR
	STH	R4,DCBLKS+DCBCHN,R3,	:RELINK CHAIN
RELDC4
	LHL	R4,DCBFRE,,		:GET FREE LIST POINTER
	STH	R4,DCBLKS+DCBCHN,RDCB,	:PUT ON FREE LIST
	STH	RDCB,DCBFRE,,		:PUT AS HEAD OF FREEE LIST
	JR	R6			:AND RETURN
RELDC6
	JAL	R10,CRASH,,		:DCB CHAIN ERROR
	BC	0,0,4*R6,CRDCB

:	CPLUDV:	COPY LUC DATA INTO DCB
:	------
:	R6 - LINK REG.
:	REMARK ****
CPLUDV
	JR	R6


NOBUF
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	RLOGBB:	RELEASE LOGON BUFFERLETS ROUTINE
:	-------
:	INPUT:	RDCB SET UP
:		DCBLBA - HEAD ADDR OF BB CHAIN
:	OUTPUT:	BB'S IN THE CHAIN ARE RELEASED
:		DCBLBA, DCBLBX ARE CLEARED
:	DESTROYED: R0,R3,R4,R7
RLOGBB
	LIS	R0,D.STOR		:IF STORED LOGON, JUST RETURN
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JNR	R6
	ST	R6,RTRN,,			:PRESERVE R6
	BBL	R3,DCBLKS+DCBLBA,RDCB,	:GET HEAD OF LOGON BUFFER CHAIN
	JE	RLOGB2			:SKIP, IF EMPTY
RLOGB1
	BBL	R10,BBUFER+BBFLSZ-BBFPSZ,R3,:GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE THIS BB
	LHL	R3,DCBLKS+DCBPUC,RDCB,	:R3 = PUC OFFSET
	LHL	R4,DCBLKS+DCBLNC,RDCB,	:GET LNCTAB ENTRY
	LIS	R0,1
	AHM	R0,PUCTAB+PURBUS,R4,	:INCREASE BB QA BY 1 IN PUC
	AHM	R0,LNCTAB+LNRBUS,R4,	:INCREASE BB QA BY 1 IN LNC
	LR	R3,R10			:COPY NEXT BB ADDR TO R3
	JN	RLOGB1			:IF NOT END, THEN LOOP
	LIS	R0,0			:SET R0 TO 0
	BBST  R0,DCBLKS+DCBLBA,RDCB,	:CLEAR DCBLBA
	STH	R0,DCBLKS+DCBLBX,RDCB,	:ZERO LOGON BB INDEX
RLOGB2
	L	R6,RTRN,,			:RESTORE R6
	JR	R6			:RETURN

	SUBTTL	(SNA) BSUB - ISIS IN/OUT DATA MANIPULATION ROUTINES


:	ROUTQ:	RELEASE ISIS/OUTPUT QUEUE
:	-------
:	THIS ROUTINE FLUSHES ANY OUTPUT REQUESTS AND THEIR
:	ASSOCIATED BUFFERLETS.
:	INPUT:	RPORT, AND RDCB SET UP
:		R6 - LINK REGISTER
:	OUTPUT:	QUEUED CMD AND BB ARE RELEASED
:		DCBOQU, DCBOBA, DCBOBX ARE CLEARED
:		OUTDAT BIT IS RESET
:		DESTROYED: R0, R2-R8
ROUTQ
	ST	R6,RTRN,,			:SAVE R6
	LHL	R8,DCBLKS+DCBOQU,RDCB,	:GET OUTPUT Q ELEMENT
	JER	R6			:QUEUE EMPTY, RETURN
ROUTQ1
	LB	R0,CMDBLK+CLCMD,R8,	:GET COMMAND
:	SEE IF DATA THERE
	JN	ROUTQ4			:NO DATA, SKIP
	BBL	R10,CMDBLK+CLARG,R8,	:GET HEAD OF BUFFERLET CHAIN
ROUTQ2
	LR	R3,R10
	JE	ROUTQ3			:NO MORE BUFFERLET, SKIP
	BBL	R10,BBUFER+BBFLSZ-BBFPSZ,R3,:GET NEXT BUFFERLET
	JAL	R4,PBB,,		:RELEASE TO BB POOL
	LB	R4,DCBLKS+DCBUTY,RDCB,	:GET DCB TYPE
	LR	R4,R4			:SEE IF MONTYP
	JE	ROUTQ3			:YES, SKIP
	LHL	R3,DCBLKS+DCBPUC,RDCB,	:R3 = PUC OFFSET
	LHL	R4,DCBLKS+DCBLNC,RDCB,	:R4 = LNC OFFSET
	LIS	R0,1
	AHM	R0,PUCTAB+PURBUS,R3,	:INCREASE BB QA BY 1 IN PUC
	AHM	R0,LNCTAB+LNRBUS,R4,	:INCREASE BB QA BY 1 IN LNC
	J	ROUTQ2			:LOOP
ROUTQ3
:	LB	R0,DCBLKS+DCBMQA,RDCB,
	AIS	R0,1			:...
:	STB	R0,DCBLKS+DCBMQA,RDCB,	:...
	J	ROUTQ2			:LOOP
ROUTQ4
	LR	R6,R8			:COPY LINK PTR
	LIS	R0,0			:CLEAR THIS CMD ELEMENT
	STH	R0,CMDBLK+CLCMD,R8,	:CLCMD FIELD
	STH	R0,CMDBLK+CLPTR,R8,	:CLPTR FIELD
	STH	R0,CMDBLK+CLLNG,R8,	:CLLNG FIELD
	BBST	R0,CMDBLK+CLARG,R8,	:CLARG FIELD
	LHL	R8,CMDBLK+CLPTR,R8,	:GET POINTER TO NEXT
	JAL	R4,RELCL,,		:RELEASE CMD LINK
	LR	R8,R8			:MORE ??
	JG	ROUTQ1			:YES, LOOP
	RBT	RPORT,OUTDAT,,		:RESET OUTPUT WAITING INDICATOR
	LIS	R8,0			:CLEAR DCB FIELDS
	STH	R8,DCBLKS+DCBOBA,RDCB,	:DCBOBA FIELD
	STH	R8,DCBLKS+DCBOBX,RDCB,	:DCBOBX FIELD
	STH	R8,DCBLKS+DCBOQU,RDCB,	:DCBOQU FIELD
	L	R6,RTRN,,			:RESTORE R6
	JR	R6

	SUBTTL 	MISCELLANEOUS ROUTINES


:***************************************************************:
:								:
:	PUT AN ENTRY INTO EVENT LOG TABLE			:
:	(AND REPORT TO SUPERVISOR LOG FILE)			:
:								:
:***************************************************************:

:	DEFINE FORMAT FOR REPORT TO SUP MSG
:	-----------------------------------

	SEG	A.DATA
	HS	0
RPSUPL	HC	0			:PORT '0'
	BC	3,0			:SUP REPORT, KEY
RPSDA2	HC	0			:DATA2 (HALFWORD)
RPSTYP	BC	0			:REPORT TYPE
RPSDA1	BC	0			:DATA1 (BYTE)
RPSPID	BC	PRODID			:PRODID(BYTE)
RPSHWS	BC	0			:RESERVED


	SEG	A.CODE


:	SEVLOG:	SETUP EVENT LOG ENTRY
:	-------
:	PUT A NEW ENTRY INTO EVENT-LOG TABLE
:	AND REPORT TO SUPERVISOR'S LOG FILE
:
:	LINK ON R6, SAVE ALL REGISTERS
:	R3	= EVENT CATEGORY
:	R4	= EVENT CODE
:	R0	= EVENT SUB CODE
:	R11	= EVENT RELATED DATA
:
:	ELGTYP	= EVENT CATEGORY
:	ELGDA1	= EVENT CODE
:	ELGDA2	= EVENT SUB CODE / ZERO, OR
:		= EVENT SUB CODE / STATION ID, OR
:	ELGDA2	= EVENT SUB CODE / SESSION ID
:
:	IF	R3 = 0 (MISCELLANEOUS EVENT)
:		R4 = EVENT CODE
:	IF	R3 = 1 (DATA LINK ERRORS)
:		R4 = EVENT CODE
:		R0 = SUB EVENT CODE
:		R11 = PUCTAB ADDR
:	IF	R3 = 2 (ISIS RELATED EVENT)
:		R4 = EVENT CODE (ISIS MSG)
:		R0 = EVENT SUB CODE
:	IF	R3 = 3 (SESSION EVENT)
:		R4 = EVENT CODE
:		R0 = SUB EVENT CODE
:		R11 = LUCTAB ADDR
:	IF	R3 = 4 (NAU-CP EVENT)
:		R4 = EVENT CODE
:		R0 = SUB EVENT CODE
:		R11 = LUCTAB ADDR
:	IF	R3 = 5 (END USER LAYER EVENT)
:		R4 = EVENT CODE
:		R0 = SUB EVENT CODE
:

:	EVPRTB: EVENT PROCESSING ROUTINE TABLE
:	-------
:	INDEXED BY THE EVENT TYPE
EVPRTB
	HC	EVT0PR-EVPRTB		:TYPE 0 PROCESSING ROUTINE
	HC	EVT1PR-EVPRTB		:TYPE 1 PROCESSING ROUTINE
	HC	EVT2PR-EVPRTB		:TYPE 2 PROCESSING ROUTINE
	HC	EVT3PR-EVPRTB		:TYPE 3 PROCESSING ROUTINE
	HC	EVT4PR-EVPRTB		:TYPE 4 PROCESSING ROUTINE
	HC	EVT5PR-EVPRTB		:TYPE 5 PROCESSING ROUTINE


:	EVENT PROCESSING DISPATCH
:	-------------------------
SEVLOG
	STM	R0,RSLSAV,,		:SAVE ALL REGISTERS
	LHL	R8,ELGNXT,,		:GET EVENT LOG TABLE NEXT ENTRY PTR
	STB	R3,ELGTBL+ELGTYP,R8,	:PUT EVENT CATEGORY INTO TABLE
	STB	R3,RPSTYP,,		:PUT EVENT CATEGORY INTO REPORT TYPE
	STB	R4,ELGTBL+ELGDA1,R8,	:EVENT CODE INTO DATA1
	STB	R4,RPSDA1,,		:PUT EVNET CODE INTO REPORT DATA1
	L	R5,GMT,,		:GET GMT TIME
	STH	R5,ELGTBL+ELGGMT+2,R8,	:PUT 2ND HW FIRST
	EXHR	R5,R5			:
	STH	R5,ELGTBL+ELGGMT,R8,	:PUT 1ST HW INTO LOGGMT
	SLHLS	R0,8			:SHIFT EVENT SUB CODE LEFT ONE BYTE
	LHL	R3,EVPRTB,R1,R1		:GET EVENT PROCESSING ROUTINE
	J	EVPRTB,R3		:GO TO PROCESS


:	EVT0PR: EVENT TYPE 0
:	-------
EVT0PR
	LIS	R0,0			:EVENT DATA 2
	J	SEVLFI			:GO TO COMMON FINISH ROUTINE


:	EVT1PR: EVENT TYPE 1
:	-------
EVT1PR
	LB	R4,PUCTAB+PUCT.N,R11,	:GET PU ID
	OHI	R4,0FF			:ONE BYTE ONLY
	OR	R0,R4			:MAKE DATA 2
	J	SEVLFI			:GO TO COMMON FINISH ROUTINE


:	EVT2PR/EVT5PR: EVENT TYPE  AND 5
:	-----------
EVT2PR;EVT5PR
	J	SEVLFI			:GO TO COMMON FINISH ROUTINE


:	EVT3PR/EVT4PR: EVENT TYPE 3 AND 4
:	------------
EVT3PR;EVT4PR
	LHL	R4,LUCTAB+LUCT.N,R11,	:GET SESSION ID
	OHI	R4,0FF			:ONE BYTE ONLY
	OR	R0,R4			:MAKE THE DATA 2
	J	SEVLFI			:GO TO COMMON FINISH ROUTINE


:	COMMON PROCESSING ROUINTE
:	-------------------------
SEVLFI
	STH	R0,ELGTBL+ELGDA2,R8,	:PUT DATA2 INTO TALE
	STH	R0,RPSDA2,,		:PUT DATA 2
	AHI	R8,ELGLEN		:INCREMENT TO NEXT ENTRY
	CLHI	R8,ELGTBE-ELGTBL	:WRAP AROUND ?
	JLFS	SEVLF2			:NO, SKIP
	LIS	R8,0			:ELSE, RESET TO 0
SEVLF2
	STH	R8,ELGNXT,,		:SAVE NEW POINTER
	IF	RPTSUP
	LIS	R0,RSUPLN		:LENGTH OF SUP REPORT
	JAL	R4,ROOM,,		:CHECK ROOM
	LIS	R2,RSUPLN		:LENGTH OF SUP REPORT
	LA	R3,RPSUPL		:REPORT TO SUP MESSAGE
	JAL	R5,OBS,,		:REPORT IT
	JAL	R4,ELOR,,		:END RING MSG
	EI	(RPTSUP)
	LM	R0,RSLSAV,,		:RESTORE ALL REGISTERS
	JR	R6			:AND , RETURN


	FO	GBLDEF
	FO	FRNTND
	FO	CMDLST
	FO	MAIN
	EM
    	SUBTTL	(SNA) SJIS - JAPANESE KATAKANA CHARACTER SET
:SJIS01.F00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	01/16/86 (CHS) -- ORIGINAL CODE AND DESIGN FOR SNA/XNA
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	RA	0

	MO	.,MAIN

:	JIS-8 SYMBOL TABLE
:
J.NUL	EQ	0
J.SOH	EQ	1
J.STX	EQ	2
J.ETX	EQ	3
J.EOT	EQ	4
J.ENQ	EQ	5
J.ACK	EQ	6
J.BEL	EQ	7
J.BS	EQ	8
J.HT	EQ	9
J.LFE	EQ	0A
J.VT	EQ	0B
J.FF	EQ	0C
J.CR	EQ	0D
J.SOL	EQ	0E
J.SIL	EQ	0F
J.DLE	EQ	10
J.DC1	EQ	11
J.DC2	EQ	12
J.DC3	EQ	13
J.DC4	EQ	14
J.NAK	EQ	15
J.SYN	EQ	16
J.ETB	EQ	17
J.CAN	EQ	18
J.EM	EQ	19
J.SUB	EQ	1A
J.ESC	EQ	1B
J.LFS	EQ	1C
J.LGS	EQ	1D
J.LRS	EQ	1E
J.LUS	EQ	1F
J.SP	EQ	20
J.EXCL	EQ	21
J.DQT	EQ	22
J.PND	EQ	23
J.DOL	EQ	24
J.PCT	EQ	25
J.AND	EQ	26
J.SQT	EQ	27
J.LPAR	EQ	28
J.RPAR	EQ	29
J.STAR	EQ	2A
J.PLUS	EQ	2B
J.COM	EQ	2C
J.DASH	EQ	2D
J.PER	EQ	2E
J.SLSH	EQ	2F
J.0	EQ	30
J.1	EQ	31
J.2	EQ	32
J.3	EQ	33
J.4	EQ	34
J.5	EQ	35
J.6	EQ	36
J.7	EQ	37
J.8	EQ	38
J.9	EQ	39
J.COLN	EQ	3A
J.SEMI	EQ	3B
J.LTH	EQ	3C
J.EQ	EQ	3D
J.GT	EQ	3E
J.QUE	EQ	3F
J.AT	EQ	40
J.UA	EQ	41
J.UB	EQ	42
J.UC	EQ	43
J.UD	EQ	44
J.UE	EQ	45
J.UF	EQ	46
J.UG	EQ	47
J.UH	EQ	48
J.UI	EQ	49
J.UJ	EQ	4A
J.UK	EQ	4B
J.UL	EQ	4C
J.UM	EQ	4D
J.UN	EQ	4E
J.UO	EQ	4F
J.UP	EQ	50
J.UQ	EQ	51
J.UR	EQ	52
J.US	EQ	53
J.UT	EQ	54
J.UU	EQ	55
J.UV	EQ	56
J.UW	EQ	57
J.UX	EQ	58
J.UY	EQ	59
J.UZ	EQ	5A
J.LBKT	EQ	5B
J.BSLH	EQ	5C
J.RBKT	EQ	5D
J.CART	EQ	5E
J.UNDR	EQ	5F
J.GRAV	EQ	60
J.LA	EQ	61
J.LB	EQ	62
J.LC	EQ	63
J.LD	EQ	64
J.LE	EQ	65
J.LF	EQ	66
J.LG	EQ	67
J.LH	EQ	68
J.LI	EQ	69
J.LJ	EQ	6A
J.LK	EQ	6B
J.LL	EQ	6C
J.LM	EQ	6D
J.LN	EQ	6E
J.LO	EQ	6F
J.LP	EQ	70
J.LQ	EQ	71
J.LR	EQ	72
J.LS	EQ	73
J.LT	EQ	74
J.LU	EQ	75
J.LV	EQ	76
J.LW	EQ	77
J.LX	EQ	78
J.LY	EQ	79
J.LZ	EQ	7A
J.LBRC	EQ	7B
J.VIRT	EQ	7C
J.RBRC	EQ	7D
J.TLDE	EQ	7E
J.DEL	EQ	7F
J.HNUL	EQ	80
J.HSOH	EQ	81
J.HSTX	EQ	82
J.HETX	EQ	83
J.HEOT	EQ	84
J.HENQ	EQ	85
J.HACK	EQ	86
J.HBLE	EQ	87
J.HBS	EQ	88
J.HHT	EQ	89
J.HLFE	EQ	8A
J.HVT	EQ	8B
J.HFF	EQ	8C
J.HCR	EQ	8D
J.HSO	EQ	8E
J.HSI	EQ	8F
J.HDLE	EQ	90
J.HDC1	EQ	91
J.HDC2	EQ	92
J.HDC3	EQ	93
J.HDC4	EQ	94
J.HNAK	EQ	95
J.HSYN	EQ	96
J.HETB	EQ	97
J.HCAN	EQ	98
J.HEM	EQ	99
J.HSUB	EQ	9A
J.HESC	EQ	9B
J.HFS	EQ	9C
J.HGS	EQ	9D
J.HRS	EQ	9E
J.HUS	EQ	9F
J.KSP	EQ	0A0
J.KUTN	EQ	0A1
J.LKAK	EQ	0A2
J.RKAK	EQ	0A3
J.TOTN	EQ	0A4
J.CHTN	EQ	0A5
J.WO	EQ	0A6
J.A.	EQ	0A7
J.I.	EQ	0A8
J.U.	EQ	0A9
J.E.	EQ	0AA
J.O.	EQ	0AB
J.YA.	EQ	0AC
J.YU.	EQ	0AD
J.YO.	EQ	0AE
J.TU.	EQ	0AF
J.KDSH	EQ	0B0
J.A	EQ	0B1
J.I	EQ	0B2
J.U	EQ	0B3
J.E	EQ	0B4
J.O	EQ	0B5
J.KA	EQ	0B6
J.KI	EQ	0B7
J.KU	EQ	0B8
J.KE	EQ	0B9
J.KO	EQ	0BA
J.SA	EQ	0BB
J.SI	EQ	0BC
J.SU	EQ	0BD
J.SE	EQ	0BE
J.SO	EQ	0BF
J.TA	EQ	0C0
J.TI	EQ	0C1
J.TU	EQ	0C2
J.TE	EQ	0C3
J.TO	EQ	0C4
J.NA	EQ	0C5
J.NI	EQ	0C6
J.NU	EQ	0C7
J.NE	EQ	0C8
J.NO	EQ	0C9
J.HA	EQ	0CA
J.HI	EQ	0CB
J.HU	EQ	0CC
J.HE	EQ	0CD
J.HO	EQ	0CE
J.MA	EQ	0CF
J.MI	EQ	0D0
J.MU	EQ	0D1
J.ME	EQ	0D2
J.MO	EQ	0D3
J.YA	EQ	0D4
J.YU	EQ	0D5
J.YO	EQ	0D6
J.RA	EQ	0D7
J.RI	EQ	0D8
J.RU	EQ	0D9
J.RE	EQ	0DA
J.RO	EQ	0DB
J.WA	EQ	0DC
J.N	EQ	0DD
J.DAK	EQ	0DE
J.HAN	EQ	0DF

:
:	EBCDIC LETTER SYMBOLS
:
K.NUL	EQ	0
K.SOH	EQ	1
K.STX	EQ	2
K.ETX	EQ	3
K.PT	EQ	5
K.GE	EQ	8
K.FF	EQ	0C
K.CR	EQ	0D
K.SBA	EQ	11
K.EUA	EQ	12
K.IC	EQ	13
K.NL	EQ	15
K.EM	EQ	19
K.DUP	EQ	1C
K.SF	EQ	1D
K.FM	EQ	1E
K.ETB	EQ	26
K.ESC	EQ	27
K.ENQ	EQ	2D
K.KRA	EQ	3C
K.SUB	EQ	3F
K.SP	EQ	40
K.KUTN	EQ	41
K.LKAK	EQ	42
K.RKAK	EQ	43
K.TOTN	EQ	44
K.CHTN	EQ	45
K.WO	EQ	46
K.A.	EQ	47
K.I.	EQ	48
K.U.	EQ	49
K.PER	EQ	4B
K.LTH	EQ	4C
K.LPAR	EQ	4D
K.PLUS	EQ	4E
K.AND	EQ	50
K.E.	EQ	51
K.O.	EQ	52
K.YA.	EQ	53
K.YU.	EQ	54
K.YO.	EQ	55
K.TU.	EQ	56
K.CHON	EQ	58
K.BLSH	EQ	5B
K.STAR	EQ	5C
K.RPAR	EQ	5D
K.SEMI	EQ	5E
K.DASH	EQ	60
K.SLSH	EQ	61
K.COM	EQ	6B
K.PCT	EQ	6C
K.UNDR	EQ	6D
K.GT	EQ	6E
K.QUE	EQ	6F
K.COLN	EQ	7A
K.PND	EQ	7B
K.AT	EQ	7C
K.SQT	EQ	7D
K.EQ	EQ	7E
K.DQT	EQ	7F
K.A	EQ	81
K.I	EQ	82
K.U	EQ	83
K.E	EQ	84
K.O	EQ	85
K.KA	EQ	86
K.KI	EQ	87
K.KU	EQ	88
K.KE	EQ	89
K.KO	EQ	8A
K.SA	EQ	8C
K.SI	EQ	8D
K.SU	EQ	8E
K.SE	EQ	8F
K.SO	EQ	90
K.TA	EQ	91
K.TI	EQ	92
K.TU	EQ	93
K.TE	EQ	94
K.TO	EQ	95
K.NA	EQ	96
K.NI	EQ	97
K.NU	EQ	98
K.NE	EQ	99
K.NO	EQ	9A
K.HA	EQ	9D
K.HI	EQ	9E
K.HU	EQ	9F
K.HE	EQ	0A2
K.HO	EQ	0A3
K.MA	EQ	0A4
K.MI	EQ	0A5
K.MU	EQ	0A6
K.ME	EQ	0A7
K.MO	EQ	0A8
K.YA	EQ	0A9
K.YU	EQ	0AA
K.YO	EQ	0AC
K.RA	EQ	0AD
K.RI	EQ	0AE
K.RU	EQ	0AF
K.RE	EQ	0BA
K.RO	EQ	0BB
K.WA	EQ	0BC
K.N	EQ	0BD
K.DAK	EQ	0BE
K.HAN	EQ	0BF
K.UA	EQ	0C1
K.UB	EQ	0C2
K.UC	EQ	0C3
K.UD	EQ	0C4
K.UE	EQ	0C5
K.UF	EQ	0C6
K.UG	EQ	0C7
K.UH	EQ	0C8
K.UI	EQ	0C9
K.UJ	EQ	0D1
K.UK	EQ	0D2
K.UL	EQ	0D3
K.UM	EQ	0D4
K.UN	EQ	0D5
K.UO	EQ	0D6
K.UP	EQ	0D7
K.UQ	EQ	0D8
K.UR	EQ	0D9
K.DOL	EQ	0E0
K.US	EQ	0E2
K.UT	EQ	0E3
K.UU	EQ	0E4
K.UV	EQ	0E5
K.UW	EQ	0E6
K.UX	EQ	0E7
K.UY	EQ	0E8
K.UZ	EQ	0E9
K.0	EQ	0F0
K.1	EQ	0F1
K.2	EQ	0F2
K.3	EQ	0F3
K.4	EQ	0F4
K.5	EQ	0F5
K.6	EQ	0F6
K.7	EQ	0F7
K.8	EQ	0F8
K.9	EQ	0F9

:
:	VARIATIONS OF EBCDIC CODE BETWEEN IBM AND HITACHI
:	
K.CENT	EQ	4A	;H.LBKT	EQ	4A
K.VRT	EQ	4F	;H.EXCL	EQ	4F
K.EVCL	EQ	5A	;H.RBKT	EQ	5A
K.NOT	EQ	5F	;H.CART	EQ	5F
K.KDSH	EQ	0A1


	EM
   	SUBTTL	(SNA) MESSAGE MACRO DEFINITIONS
:SMAC01.F06

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	01/21/86 (CHS) -- DESIGN AND CODE FOR SNA/XNA
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	LIST	-X,-R

	RA	0
	MO	.,MAIN
	LO	MAIN

	SEG	A.CODE

	IF	TERMIF

:	SNATNN -- "SNAT NN - "
:	-------
	SEG	A.DATA
SNATNN	HC	SNATNL
	BC	S.,N.,A.,T.,SP.
	BC	N0.,N0.
	BC	SP.,DASH.,SP.
SNATNL	EQ	.-SNATNN-2

	SEG	A.CODE

:	LEM1 -- TYPE USERNAME
:	----
LEM1E	HC	LEM1Y
	BC	T.,Y.,P.,E.,SP.,U.,S.,E.,R.,N.,A.,M.,E.
LEM1Y	EQ	.-LEM1E-2

	IF	JAPANESE
LEM1J	HC	LEM1Z
	BC	K.YU,K.DASH,K.SA,K.DAK,K.NE,K.DASH,K.MU
	BC	K.WO,K.SP,K.NI,K.YU.,K.U,K.RI,K.YO.,K.KU,K.SI
	BC	K.TE,K.KU,K.TA,K.DAK,K.SA,K.I
LEM1Z	EQ	.-LEM1J-2
	EI


:	LEM2 -- TYPE PASSWORD
:	----
LEM2E	HC	LEM2Y
	BC	T.,Y.,P.,E.,SP.,P.,A.,S.,S.,W.,O.,R.,D.
LEM2Y	EQ	.-LEM2E-2

	IF	JAPANESE
LEM2J	HC	LEM2Z
	BC	K.HA,K.HAN,K.SU,K.WA,K.DASH,K.TO,K.DAK,K.WO
	BC	K.SP,K.NI,K.YU.,K.U,K.RI,K.YO.,K.KU,K.SI,K.TE
	BC	K.KU,K.TA,K.DAK,K.SA,K.I
LEM2Z	EQ	.-LEM2J-2
	EI


:	LEM3 -- LOGON IN PROGRESS
:	----
LEM3E	HC	LEM3Y
	BC	L.,O.,G.,O.,N.,SP.,I.,N.,SP.,P.,R.,O.,G.,R.,E.,S.,S.
LEM3Y	EQ	.-LEM3E-2

	IF	JAPANESE
LEM3J	HC	LEM3Z
	BC	K.RO,K.KU,K.DAK,K.O,K.N,K.SP,K.TE,K.TU,K.TU,K.DAK
	BC	K.KI,K.TI,K.YU.,K.DASH
LEM3Z	EQ	.-LEM3J-2
	EI


:	LEM4 -- LOGON FAILED
:	----
LEM4E	HC	LEM4Y
	BC	L.,O.,G.,O.,N.,SP.,F.,A.,I.,L.,E.,D.
LEM4Y	EQ	.-LEM4E-2

	IF	JAPANESE
LEM4J	HC	LEM4Z
	BC	K.RO,K.KU,K.DAK,K.O,K.N,K.SP
	BC	K.TE,K.DAK,K.KI,K.MA,K.SE,K.N,K.TE,K.DAK,K.SI,K.TA
LEM4Z	EQ	.-LEM4J-2
	EI


:	LEM5 -- USER NAME ERROR DURING PRESET LOGON
:	----
LEM5E	HC	LEM5Y
	BC	0			:LENGTH
	BC	U.,S.,E.,R.,N.,A.,M.,E.,SP.,E.,R.,R.,O.,R.,SP.,D.,U.,R.
	BC	I.,N.,G.,SP.,P.,R.,E.,S.,E.,T.,SP.,L.,O.,G.,O.,N.
LEM5Y	EQ	.-LEM5E-2

	IF	JAPANESE
LEM5J	HC	LEM5Z
	BC	K.YU,K.DASH,K.SA,K.DAK,K.NE,K.DASH
	BC	K.MU,K.SP,K.E,K.RA,K.DASH
LEM5Z	EQ	.-LEM5J-2
	EI


:	LEM6 -- PASSWORD ERROR DURING PRESET LOGON
:	----
LEM6E	HC	LEM6Y
	BC	P.,A.,S.,S.,W.,O.,R.,D.,SP.,E.,R.,R.,O.,R.,SP.,D.,U.,R.
	BC	I.,N.,G.,SP.,P.,R.,E.,S.,E.,T.,SP.,L.,O.,G.,O.,N.
LEM6Y	EQ	.-LEM6E-2

	IF	JAPANESE
LEM6J	HC	LEM6Z
	BC	K.HA,K.HAN,K.SU,K.WA,K.DASH,K.TO
	BC	K.DAK,K.SP,K.E,K.RA,K.DASH
LEM6Z	EQ	.-LEM6J-2
	EI


:	LEM7 -- BAD STORED DSP ELEMENT - ABORTED
:	----
LEM7E	HC	LEM7Y
	BC	B.,A.,D.,SP.,S.,T.,O.,R.,E.,D.,SP.,D.,S.,P.,SP.
	BC	E.,L.,E.,M.,E.,N.,T.,SP.,DASH.,SP.,A.,B.,O.,R.,T.,E.,D.
LEM7Y	EQ	.-LEM7E-2

	IF	JAPANESE
LEM7J	HC	LEM7Z
	BC	K.UD,K.US,K.UP,K.NO,K.SP,K.TO,K.U
	BC	K.RO,K.KU,K.KA,K.DAK,K.SP,K.MA,K.TI,K.KA,K.DAK
	BC	K.TU.,K.TE,K.I.,K.MA,K.SU
LEM7Z	EQ	.-LEM7J-2
	EI


:	LEM8 -- PLEASE SEE YOUR REP...
:	----
LEM8E	HC	LEM8Y
	BC	P.,L.,E.,A.,S.,E.,SP.,S.,E.,E.,SP.,Y.,O.,U.
	BC	R.,SP.,R.,E.,P.,DOT.,DOT.,DOT.
LEM8Y	EQ	.-LEM8E-2

	IF	JAPANESE
LEM8J	HC	LEM8Z
	BC	K.HO,K.SI,K.YU.,K.I,K.N,K.HE
	BC	K.SP,K.KO,K.DAK,K.RE,K.N,K.RA,K.KU,K.KU,K.TA
	BC	K.DAK,K.SA,K.I
LEM8Z	EQ	.-LEM8J-2
	EI


:	LEM9 -- BAD MUD
:	----
LEM9E	HC	LEM9Y
	BC	B.,A.,D.,SP.,M.,U.,D.
LEM9Y	EQ	.-LEM9E-2

	IF	JAPANESE
LEM9J	HC	LEM9Z
	BC	K.UM,K.UU,K.UD,K.KA,K.DAK,K.SP
	BC	K.MA,K.TI,K.KA,K.DAK,K.TU.,K.TE,K.I,K.MA,K.SU
LEM9Z	EQ	.-LEM9J-2
	EI


:	LEM0A -- CIRCUIT BUSY
:	-----
LEM0AE	HC	LEM0AY
	BC	C.,I.,R.,C.,U.,I.,T.,SP.,B.,U.,S.,Y.
LEM0AY	EQ	.-LEM0AE-2

	IF	JAPANESE
LEM0AJ	HC	LEM0AZ
	BC	K.KA,K.I,K.SE,K.N,K.KA,K.DAK,K.SP
	BC	K.A,K.I,K.TE,K.O,K.RI,K.MA,K.SE,K.N
LEM0AZ	EQ	.-LEM0AJ-2
	EI


:	LEM0B -- HOST NOT AVAILABLE
:	-----
LEM0BE	HC	LEM0BY
	BC	H.,O.,S.,T.,SP.,N.,O.,T.,SP.,A.,V.,A.,I.,L.
	BC	A.,B.,L.,E.
LEM0BY	EQ	.-LEM0BE-2

	IF	JAPANESE
LEM0BJ	HC	LEM0BZ
	BC	K.HO,K.SU,K.TO,K.KA,K.DAK,K.SP
	BC	K.SI,K.YO,K.U,K.TE,K.DAK,K.KI,K.MA,K.SE,K.N
LEM0BZ	EQ	.-LEM0BJ-2
	EI


:	LEM0C -- HOST OUT OF PORTS
:	-----
LEM0CE	HC	LEM0CY
	BC	H.,O.,S.,T.,SP.,O.,U.,T.,SP.,O.,F.,SP.
	BC	P.,O.,R.,T.,S.
LEM0CY	EQ	.-LEM0CE-2

	IF	JAPANESE
LEM0CJ	HC	LEM0CZ
	BC	K.HO,K.HAN,K.DASH,K.TO,K.KA
	BC	K.DAK,K.SP,K.A,K.I,K.TE,K.O,K.RI,K.MA,K.SE,K.N
LEM0CZ	EQ	.-LEM0CJ-02
	EI


:	LEM0D -- HOST DOWN
:	-----
LEM0DE	HC	LEM0DY
	BC	H.,O.,S.,T.,SP.,D.,O.,W.,N.
LEM0DY	EQ	.-LEM0DE-2

	IF	JAPANESE
LEM0DJ	HC	LEM0DZ
	BC	K.HO,K.SU,K.TO,K.KA,K.DAK,K.SP,K.TU
	BC	K.NA,K.KA,K.DAK,K.TU.,K.TE,K.O,K.RI,K.MA,K.SE,K.N
LEM0DZ	EQ	.-LEM0DJ-2
	EI


:	LEM0E -- HOST SHUT
:	------
LEM0EE	HC	LEM0EY
	BC	H.,O.,S.,T.,SP.,S.,H.,U.,T.
LEM0EY	EQ	.-LEM0EE-2

	IF	JAPANESE
LEM0EJ	HC	LEM0EZ
	BC	K.HO,K.SU,K.TO,K.NI,K.SP
	BC	K.SI,K.N,K.KI,K.SE,K.TU,K.SO,K.DAK,K.KU,K.KA
	BC	K.DAK,K.SP,K.TE,K.DAK,K.KI,K.MA,K.SE,K.N
LEM0EZ	EQ	.-LEM0EJ-2
	EI


:	LEM0F -- TRY AGAIN IN 2 MINUTES
:	-----
LEM0FE	HC	LEM0FY
	BC	T.,R.,Y.,SP.,A.,G.,A.,I.,N.,SP.,I.,N.
	BC	SP.,N2.,M.,I.,N.,U.,T.,E.,S.
LEM0FY	EQ	.-LEM0FE-2

	IF	JAPANESE
LEM0FJ	HC	LEM0FZ
	BC	K.SI,K.HA,K.DAK,K.RA,K.KU,K.SI
	BC	K.TE,K.SP,K.MO,K.U,K.I,K.TI,K.TO,K.DAK,K.SP,K.SE,K.TU
	BC	K.SO,K.DAK,K.KU,K.SI,K.TE,K.KU,K.TA,K.DAK,K.SA,K.I
LEM0FZ	EQ	.-LEM0FJ-2
	EI


:	LEM10 -- ACCESS NOT PERMITTED
:	-----
LEM10E	HC	LEM10Y
	BC	A.,C.,C.,E.,S.,S.,SP.,N.,O.,T.,SP.
	BC	P.,E.,R.,M.,I.,T.,T.,E.,D.
LEM10Y	EQ	.-LEM10E-2

	IF	JAPANESE
LEM10J	HC	LEM10Z
	BC	K.KO,K.NO,K.HO,K.SU,K.TO,K.HE
	BC	K.NO,K.SP,K.SE,K.TU,K.SO,K.DAK,K.KU,K.HA
	BC	K.SP,K.MI,K.TO,K.ME,K.RA,K.RE,K.TE,K.O
	BC	K.RI,K.MA,K.SE,K.N
LEM10Z	EQ	.-LEM10J-2
	EI


:	LEM11 -- NO HOST SPECIFIED
:	-----
LEM11E	HC	LEM11Y
	BC	N.,O.,SP.,H.,O.,S.,T.,SP.,S.,P.,E.,C.,I.,F.,I.,E.,D.
LEM11Y	EQ	.-LEM11E-2

	IF	JAPANESE
LEM11J	HC	LEM11Z
	BC	K.HO,K.SU,K.TO,K.NA,K.N,K.HA,K.DAK
	BC	K.DASH,K.WO,K.SP,K.SI,K.TE,K.I,K.SI,K.TE
	BC	K.KU,K.TA,K.DAK,K.SA,K.I
LEM11Z	EQ	.-LEM11J-2
	EI


:	LEM12 -- BAD HOST NUMBER
:	-----
LEM12E	HC	LEM12Y
	BC	B.,A.,D.,SP.,H.,O.,S.,T.,SP.,N.,U.,M.,B.,E.,R.
LEM12Y	EQ	.-LEM12E-2

	IF	JAPANESE
LEM12J	HC	LEM12Z
	BC	K.HO,K.SU,K.TO,K.NA,K.N,K.HA,K.DAK,K.DASH,K.KA
	BC	K.DAK,K.SP,K.MA,K.TI,K.KA,K.DAK,K.TU.
	BC	K.TE,K.I,K.MA,K.SU
LEM12Z	EQ	.-LEM12J-2
	EI


:	LEM13 -- MUD ERROR
:	-----
LEM13E	HC	LEM13Y
	BC	M.,U.,D.,SP.,E.,R.,R.,O.,R.
LEM13Y	EQ	.-LEM13E-2

	IF	JAPANESE
LEM13J	HC	LEM13Z
	BC	K.UM,K.UU,K.UD,K.SP,K.E,K.RA,K.DASH
LEM13Z	EQ	.-LEM13J-2
	EI


:	LEM14 -- CONNECTION IN PROGRESS
:	-----
LEM14E	HC	LEM14Y
	BC	C.,O.,N.,N.,E.,C.,T.,I.,O.,N.,SP.
	BC	I.,N.,SP.,P.,R.,O.,G.,R.,E.,S.,S.
LEM14Y	EQ	.-LEM14E-2

	IF	JAPANESE
LEM14J	HC	LEM14Z
	BC	K.KO,K.NE,K.KU,K.SI,K.YO.,K.N,K.SP,K.TE,K.TU,K.TU,K.DAK
	BC	K.KI,K.TI,K.YU.,K.DASH
LEM14Z	EQ	.-LEM14J-2
	EI


:	LEM15 -- CONNECTION FAILED
:	-----
LEM15E	HC	LEM15Y
	BC	C.,O.,N.,N.,E.,C.,T.,I.,O.,N.,SP.,F.,A.,I.,L.,E.,D.
LEM15Y	EQ	.-LEM15E-2

	IF	JAPANESE
LEM15J	HC	LEM15Z
	BC	K.KO,K.NE,K.KU,K.SI,K.YO.,K.N,K.SP,K.TE,K.DAK,K.KI,K.MA
	BC	K.SE,K.N,K.TE,K.DAK,K.SI,K.TA
LEM15Z	EQ	.-LEM15J-2
	EI


:	LEM16 -- PROCEDURE ABORTED
:	-----
LEM16E	HC	LEM16Y
	BC	P.,R.,O.,C.,E.,D.,U.,R.,E.,SP.,A.,B.,O.,R.,T.,E.,D.
LEM16Y	EQ	.-LEM16E-2

	IF	JAPANESE
LEM16J	HC	LEM16Z
	BC	K.KI,K.YO.,K.U,K.SE,K.I,K.SP,K.SI,K.YU.,K.U,K.RI,K.YO.,K.U
	BC	K.SI,K.MA,K.SI,K.TA
LEM16Z	EQ	.-LEM16J-2
	EI


:	LEM18 -- LOGON FAILED - NON SNA HOST
:	-----
LEM18E	HC	LEM18Y
	BC	L.,O.,G.,O.,N.,SP.,F.,A.,I.,L.,E.,D.,SP.,DASH.
	BC	SP.,N.,O.,N.,SP.,S.,N.,A.,SP.,H.,O.,S.,T.
LEM18Y	EQ	.-LEM18E-2

	IF	JAPANESE
LEM18J	HC	LEM18Z
	BC	K.US,K.UN,K.UA,K.HO,K.SU,K.TO,K.TE,K.DAK
	BC	K.NA,K.I,K.TA,K.ME,K.SP,K.RO,K.KU,K.DAK,K.O,K.N
	BC	K.TE,K.DAK,K.KI,K.MA,K.SE,K.N
LEM18Z	EQ	.-LEM18J-2
	EI


:	LEM19 -- INPUT ERROR
:	-----
LEM19E	HC	LEM19Y
	BC	I.,N.,P.,U.,T.,SP.,E.,R.,R.,O.,R.
LEM19Y	EQ	.-LEM19E-2

	IF	JAPANESE
LEM19J	HC	LEM19Z
	BC	K.NI,K.YU.,K.U,K.RI,K.YO.,K.KU,K.SP,K.E,K.RA,K.DASH
LEM19Z	EQ	.-LEM19J-2
	EI


:	LEM1A -- CIRCUIT CLEARED
:	-----
LEM1AE	HC	LEM1AY
	BC	C.,I.,R.,C.,U.,I.,T.,SP.,C.,L.,E.,A.,R.,E.,D.
LEM1AY	EQ	.-LEM1AE-2

	IF	JAPANESE
LEM1AJ	HC	LEM1AZ
	BC	K.KA,K.I,K.SE,K.N,K.KA,K.DAK,K.SP,K.KU,K.RI,K.A
	BC	K.DASH,K.SA,K.RE,K.MA,K.SI,K.TA
LEM1AZ	EQ	.-LEM1AJ-2
	EI


:	LEM20 - CRT IS CURRENTLY LOGGED IN
:	-----
LEM20E	HC	LEM20Y
	BC	C.,R.,T.,SP.,I.,S.,SP.,C.,U.,R.,R.,E.,N.,T.,L.
	BC	Y.,SP.,L.,O.,G.,G.,E.,D.,SP.,I.,N.
LEM20Y	EQ	.-LEM20E-2

	IF	JAPANESE
LEM20J	HC	LEM20Z
	BC	K.TE,K.DAK,K.I.,K.SU,K.HU,K.HAN
	BC	K.RE,K.I,K.HA,K.SP,K.SU,K.TE,K.DAK,K.NI,K.TU
	BC	K.NA,K.KA,K.DAK,K.TU.,K.TE,K.I,K.MA,K.SU
LEM20Z	EQ	.-LEM20J-2
	EI


:	LEM21 -- CRT IS CURRENTLY NO LOGGED IN
:	------
LEM21E	HC	LEM21Y
	BC	C.,R.,T.,SP.,I.,S.,SP.,C.,U.,R.,R.,E.,N.,T.,L.,Y.
:	BC	SP.,L.,O.,G.,G.,E.,D.,SP.,I.,N.		:(F01/10/14/87/HS)
	BC	SP.,N.,O.,T.,SP.,L.,O.,G.,G.,E.,D.,SP.,I.,N. :(F01/10/14/87/HS)
LEM21Y	EQ	.-LEM21E-2

	IF	JAPANESE
LEM21J	HC	LEM21Z
	BC	K.TE,K.DAK,K.I,K.SU,K.HU,K.HAN,K.RE,K.I,K.HA
	BC	K.SP,K.MA,K.TA,K.DAK,K.TU,K.NA,K.KA,K.DAK,K.TU.
	BC	K.TE,K.I,K.MA,K.SE,K.N
LEM21Z	EQ	.-LEM21J-2
	EI


:	LEM22 -- PRT IS CURRENTLY LOGGED IN
:	------
LEM22E	HC	LEM22Y
	BC	P.,R.,T.,SP.,I.,S.,SP.,C.,U.,R.,R.,E.,N.,T.,L.,Y.
	BC	SP.,L.,O.,G.,G.,E.,D.,SP.,I.,N.
LEM22Y	EQ	.-LEM22E-2

	IF	JAPANESE
LEM22J	HC	LEM22Z
	BC	K.HU,K.HAN,K.RI,K.N,K.TA,K.DASH,K.HA,K.SP,K.SU
	BC	K.TE,K.DAK,K.NI,K.TU,K.NA,K.KA,K.DAK,K.TU.,K.TE
	BC	K.I,K.MA,K.SU
LEM22Z	EQ	.-LEM22J-2
	EI


:	LEM23 -- PRT IS CURRENTLY NOT LOGGED IN
:	-----
LEM23E	HC	LEM23Y
	BC	P.,R.,T.,SP.,I.,S.,SP.,C.,U.,R.,R.,E.,N.,T.,L.,Y.
	BC	SP.,N.,O.,T.,SP.,L.,O.,G.,G.,E.,D.,SP.,I.,N.
LEM23Y	EQ	.-LEM23E-2

	IF	JAPANESE
LEM23J	HC	LEM23Z
	BC	K.HU,K.HAN,K.RI,K.N,K.TA,K.DASH,K.HA,K.SP,K.MA
	BC	K.TA,K.DAK,K.SP,K.TU,K.NA,K.KA,K.DAK,K.TU.,K.TE,K.I
	BC	K.MA,K.SE,K.N
LEM23Z	EQ	.-LEM23J-2
	EI


:	NNS02 -- 1. MANUAL LOGON - CRT
:	------
NNS02E	HC	NNS02Y
	BC	N1.,DOT.,SP.,M.,A.,N.,U.,A.,L.,SP.,L.,O.,G.,O.,N.
	BC	SP.,DASH.,SP.,C.,R.,T.
NNS02Y	EQ	.-NNS02E-2

	IF	JAPANESE
NNS02J	HC	NNS02Z
	BC	K.1,K.PER,K.SP,K.MA,K.NI,K.YU.,K.A,K.RU,K.SP,K.RO
	BC	K.KU,K.DAK,K.O,K.N,K.SP,K.SP,K.DASH,K.SP,K.TE,K.DAK
	BC	K.I.,K.SU,K.HU,K.HAN,K.RE,K.I,K.LPAR,K.UC,K.UR,K.UT,K.RPAR
NNS02Z	EQ	.-NNS02J-2
	EI


:	NNS03 -- 2. PRESET LOGON - CRT
:	------
NNS03E	HC	NNS03Y
	BC	N2.,DOT.,SP.,P.,R.,E.,S.,E.,T.,SP.,L.,O.,G.,O.,N.
	BC	SP.,DASH.,SP.,C.,R.,T.
NNS03Y	EQ	.-NNS03E-2

	IF	JAPANESE
NNS03J	HC	NNS03Z
	BC	K.2,K.PER,K.SP,K.HU,K.HAN,K.RI,K.SE,K.TU.,K.TO,K.SP,K.RO
	BC	K.KU,K.DAK,K.O,K.N,K.SP,K.DASH,K.SP,K.TE,K.DAK,K.I.,K.SU
	BC	K.HU,K.HAN,K.RE,K.I,K.LPAR,K.UC,K.UR,K.UT,K.RPAR
NNS03Z	EQ	.-NNS03J-2
	EI


:	NNS04 -- 3. MANUAL LOGON - PRT
:	-----
NNS04E	HC	NNS04Y
	BC	N3.,DOT.,SP.,M.,A.,N.,U.,A.,L.,SP.,L.,O.,G.,O.,N.
	BC	SP.,DASH.,SP.,P.,R.,T.
NNS04Y	EQ	.-NNS04E-2

	IF	JAPANESE
NNS04J	HC	NNS04Z
	BC	K.3,K.PER,K.SP,K.MA,K.NI,K.YU.,K.A,K.RU,K.SP,K.RO,K.KU
	BC	K.DAK,K.O,K.N,K.SP,K.SP,K.DASH,K.SP,K.HU,K.HAN,K.RI,K.N,K.TA
	BC	K.DASH,K.LPAR,K.UP,K.UR,K.UT,K.RPAR
NNS04Z	EQ	.-NNS04J-2
	EI


:	NNS05 -- 4. PRESET LOGON - PRT
:	------
NNS05E	HC	NNS05Y
	BC	N4.,DOT.,SP.,P.,R.,E.,S.,E.,T.,SP.,L.,O.,G.,O.,N.
	BC	SP.,DASH.,SP.,P.,R.,T.
NNS05Y	EQ	.-NNS05E-2

	IF	JAPANESE
NNS05J	HC	NNS05Z
	BC	K.4,K.PER,K.SP,K.HU,K.HAN,K.RI,K.SE,K.TU.,K.TO,K.SP,K.RO
	BC	K.KU,K.DAK,K.O,K.N,K.SP,K.DASH,K.SP,K.HU,K.HAN,K.RI,K.N,K.TA
	BC	K.DASH,K.LPAR,K.UP,K.UR,K.UT,K.RPAR
NNS05Z	EQ	.-NNS05J-2
	EI


:	NNS06 -- 5. LOGOFF - CRT
:	------
NNS06E	HC	NNS06Y
	BC	N5.,DOT.,SP.,L.,O.,G.,O.,F.,F.,SP.,DASH.,SP.,C.,R.,T.
NNS06Y	EQ	.-NNS06E-2

	IF	JAPANESE
NNS06J	HC	NNS06Z
	BC	K.5,K.PER,K.SP,K.RO,K.KU,K.DAK,K.O,K.HU,K.SP,K.DASH,K.SP
	BC	K.TE,K.DAK,K.I.,K.SU,K.HU,K.HAN,K.RE,K.I,K.LPAR,K.UC,K.UR
	BC	K.UT,K.RPAR
NNS06Z  EQ      .-NNS06J-2
	EI


:	NNS07 -- 6. LOGOFF - PRT
:	-----
NNS07E	HC	NNS07Y
	BC	N6.,DOT.,SP.,L.,O.,G.,O.,F.,F.,SP.,DASH.,SP.,P.,R.,T.
NNS07Y	EQ	.-NNS07E-2

	IF	JAPANESE
NNS07J	HC	NNS07Z
	BC	K.6,K.PER,K.SP,K.RO,K.KU,K.DAK,K.O,K.HU,K.SP,K.DASH,K.SP
	BC	K.HU,K.HAN,K.RI,K.N,K.TA,K.DASH,K.LPAR,K.UP,K.UR,K.UT,K.RPAR
NNS07Z	EQ	.-NNS07J-2
	EI


:	NNS08 -- 7. EXIT
:	------
NNS08E	HC	NNS08Y
	BC	N7.,DOT.,SP.,E.,X.,I.,T.
NNS08Y	EQ	.-NNS08E-2

	IF	JAPANESE
NNS08J	HC	NNS08Z
	BC	K.7,K.PER,K.SP,K.A,K.HU,K.HAN,K.RI,K.KE,K.DASH,K.SI
	BC	K.YO.,K.N,K.HE,K.SP,K.MO,K.TO,K.DAK,K.RI,K.MA,K.SU
NNS08Z	EQ	.-NNS08J-2
	EI


:	NNS09 -- ENTER SELECTION:
:	------
NNS09E	HC	NNS09Y
	BC	E.,N.,T.,E.,R.,SP.,S.,E.,L.,E.,C.,T.,I.,O.,N.,COLON.
NNS09Y	EQ	.-NNS09E-2

	IF	JAPANESE
NNS09J	HC	NNS09Z
	BC	K.SE,K.N,K.TA,K.KU,K.SI,K.TE,K.KU,K.TA,K.DAK,K.SA,K.I
	BC	K.COLN
NNS09Z	EQ	.-NNS09J-2
	EI


:	NNSX9 -- , ENTER PRINTER #:
:	------
NNSX9E	HC	NNSX9Y
	BC	COMA.,SP.,E.,N.,T.,E.,R.,SP.,P.,R.,I.,N.,T.,E.,R.,COLON.
NNSX9Y	EQ	.-NNSX9E-2

	IF	JAPANESE
NNSX9J	HC	NNSX9Z
	BC	K.COM,K.HU,K.HAN,K.RI,K.N,K.TA,K.DASH,K.NA,K.N
	BC	K.HA,K.DAK,K.DASH,K.WO,K.SP,K.NI,K.YU.,K.U,K.RI,K.YO.
	BC	K.KU,K.SI,K.TE,K.KU,K.TA,K.DAK,K.SA,K.I,K.COLN
NNSX9Z	EQ	.-NNSX9J-2
	EI


:	NNS0A -- DEVICES STATUS
:	------
NNS0AE	HC	NNS0AY
	BC	D.,E.,V.,I.,C.,E.,S.,SP.,S.,T.,A.,T.,U.,S.
NNS0AY	EQ	.-NNS0AE-2

	IF	JAPANESE
NNS0AJ	HC	NNS0AZ
	BC	K.SO,K.U,K.TI,K.NO,K.SP,K.SI,K.DAK,K.YO.,K.U,K.TA,K.I
NNS0AZ	EQ	.-NNS0AJ-2
	EI


:	NNS0B -- LU NN CRT/PRT
:	-----
	SEG	A.DATA

NNS0BE	HC	NNS0BY
	BC	L.,U.,SP.,SP.,SP.,N2.,SP.,C.,R.,T.,SP.
NNS0BY	EQ	.-NNS0BE-2

	IF	JAPANESE
NNS0BJ	HC	NNS0BZ
NNS0BJ  EQ      NNS0BE
NNS0BZ	EQ	.-NNS0BJ-2
	EI


	SEG	A.CODE

:	NNS0C -- DISCONNECTED FROM REMOTE
:	------
NNS0CE	HC	NNS0CY
	BC	D.,I.,S.,C.,O.,N.,N.,E.,C.,T.,E.,D.,SP.
	BC	F.,R.,O.,M.,SP.,R.,E.,M.,O.,T.,E.
NNS0CY	EQ	.-NNS0CE-2

	IF	JAPANESE
NNS0CJ	HC	NNS0CZ
	BC	K.SE,K.TU,K.SO,K.DAK,K.KU,K.SP,K.SA,K.RE,K.TE
	BC	K.I,K.MA,K.SE,K.N
NNS0CZ	EQ	.-NNS0CJ-2
	EI


:	NNS0D -- CONNECTED TO REMOTE
:	-----
NNS0DE	HC	NNS0DY
	BC	C.,O.,N.,N.,E.,C.,T.,E.,D.,SP.,T.,O.,SP.,R.,E.,M.,O.,T.,E.
NNS0DY	EQ	.-NNS0DE-2

	IF	JAPANESE
NNS0DJ	HC	NNS0DZ
	BC	K.SE,K.TU,K.SO,K.DAK,K.KU,K.SP,K.SA,K.RE,K.TE,K.I,K.MA,K.SU
NNS0DZ	EQ	.-NNS0DJ-2
	EI


:	NNSE1 -- WRONG KEY..., TRY AGAIN
:	-----
NNSE1E	HC	NNSE1Y
	BC	W.,R.,O.,N.,G.,SP.,K.,E.,Y.,DOT.,DOT.,DOT.
	BC	COMA.,SP.,T.,R.,Y.,SP.,A.,G.,A.,I.,N.
NNSE1Y	EQ	.-NNSE1E-2

	IF	JAPANESE
NNSE1J	HC	NNSE1Z
	BC	K.SO,K.U,K.SA,K.KA,K.DAK,K.SP,K.MA,K.TI
	BC	K.KA,K.DAK,K.TU.,K.TE,K.I,K.MA,K.SU,K.PER,K.MO
	BC	K.U,K.I,K.TI,K.TO,K.DAK
NNSE1Z	EQ	.-NNSE1J-2
	EI


:	NNSE3 -- DEVICE NOT LOGGED IN
:	-----
NNSE3E	HC	NNSE3Y
	BC	D.,E.,V.,I.,C.,E.,SP.,N.,O.,T.,SP.,L.,O.,G.,G.,E.,D.
	BC	SP.,I.,N.
NNSE3Y	EQ	.-NNSE3E-2

	IF	JAPANESE
NNSE3J	HC	NNSE3Z
	BC	K.SO,K.U,K.TI,K.KA,K.DAK,K.SP,K.TU,K.NA
	BC	K.KA,K.DAK,K.TU.,K.TE,K.O,K.RI,K.MA,K.SE,K.N
NNSE3Z	EQ	.-NNSE3J-2
	EI


:	NNSE4 -- SOMEONE ELSE IS LOGGING PRINTER
:	-----
NNSE4E	HC	NNSE4Y
	BC	S.,O.,M.,E.,O.,N.,E.,SP.,E.,L.,S.,E.,SP.,I.,S.,SP.
	BC	L.,O.,G.,G.,I.,N.,G.,SP.,P.,R.,I.,N.,T.,E.,R.
NNSE4Y	EQ	.-NNSE4E-2

	IF	JAPANESE
NNSE4J	HC	NNSE4Z
	BC	K.HU,K.HAN,K.RI,K.N,K.TA,K.DASH,K.HA
	BC	K.SP,K.SI,K.YO,K.U,K.SP,K.TI,K.YU.,K.U,K.TE,K.DAK,K.SU
NNSE4Z	EQ	.-NNSE4J-2
	EI


:	NNSE5 -- PRINTER IS ALREADY LOGGED IN
:	------
NNSE5E	HC	NNSE5Y
	BC	P.,R.,I.,N.,T.,E.,R.,SP.,I.,S.,SP.,A.,L.,R.,E.,A.,D.,Y.
	BC	SP.,L.,O.,G.,G.,E.,D.,SP.,I.,N.
NNSE5Y	EQ	.-NNSE5E-2

	IF	JAPANESE
NNSE5J	HC	NNSE5Z
	BC	K.HU,K.HAN,K.RI,K.N,K.TA,K.DASH
	BC	K.HA,K.SP,K.SU,K.TE,K.DAK,K.NI,K.SE,K.TU,K.SO,K.DAK,K.KU
	BC	K.SA,K.RE,K.TE,K.U,K.I,K.MA,K.SU
NNSE5Z	EQ	.-NNSE5J-2
	EI


:	NNSE6 -- CRT NOT CONNECTED, EXIT NOT ALLOWED
:	------
NNSE6E	HC	NNSE6Y
	BC	C.,R.,T.,SP.,N.,O.,T.,C.,O.,N.,N.,E.,C.,T.,E.,D.
	BC	COMA.,SP.,E.,X.,I.,T.,SP.,N.,O.,T.,SP.,A.,L.,L.,O.,W.,E.,D.
NNSE6Y	EQ	.-NNSE6E-2

	IF	JAPANESE
NNSE6J	HC	NNSE6Z
	BC	K.TE,K.DAK,K.I.,K.SU,K.HU,K.HAN,K.RE,K.I,K.NI,K.SP
	BC	K.SE,K.TU,K.SO,K.DAK,K.KU,K.SP,K.TE,K.DAK,K.KI,K.MA,K.SE
	BC	K.N,K.TE,K.DAK,K.SI,K.TA
NNSE6Z	EQ	.-NNSE6J-2
	EI


:	NNSE7 -- FUNCTION NOT SUPPORTED YET
:	-------
NNSE7E	HC	NNSE7Y
	BC	F.,U.,N.,C.,T.,I.,O.,N.,SP.,N.,O.,T.,SP.
	BC	S.,U.,P.,P.,O.,R.,T.,E.,D.,SP.,Y.,E.,T.
NNSE7Y	EQ	.-NNSE7E-2

	IF	JAPANESE
NNSE7J	HC	NNSE7Z
	BC	K.KO,K.NO,K.KI,K.NO,K.U,K.HA,K.SP,K.MA,K.TA
	BC	K.DAK,K.SA,K.HO,K.HAN,K.DASH,K.TO,K.SP,K.SA,K.RE
	BC	K.TE,K.I,K.MA,K.SE,K.N
NNSE7Z	EQ	.-NNSE7J-2
	EI


:	LOGS2 -- ENTER SELECTION:
:	------
LOGS2E	HC	LOGS2Y
	BC	E.,N.,T.,E.,R.,SP.,S.,E.,L.,E.,C.,T.,I.,O.,N.,COLON.
LOGS2Y	EQ	.-LOGS2E-2

	IF	JAPANESE
LOGS2J	HC	LOGS2Z
	BC	K.SE,K.N,K.TA,K.KU,K.SI,K.TE,K.KU,K.TA,K.DAK,K.SA,K.I
	BC	K.COLN
LOGS2Z	EQ	.-LOGS2J-2
	EI


:	MLGS1 -- MANUAL LOGON
:	------
MLGS1E	HC	MLGS1Y
	BC	M.,A.,N.,U.,A.,L.,SP.,SP.,L.,O.,G.,O.,N.
MLGS1Y	EQ	.-MLGS1E-2

	IF	JAPANESE
MLGS1J	HC	MLGS1Z
	BC	K.MA,K.NI,K.YU.,K.A,K.RU,K.SP,K.RO,K.KU,K.DAK,K.O,K.N
MLGS1Z	EQ	.-MLGS1J-2
	EI


:	MLGS2 -- PLEASE LOGIN
:	------
MLGS2E	HC	MLGS2Y
	BC	P.,L.,E.,A.,S.,E.,SP.,L.,O.,G.,I.,N.
MLGS2Y	EQ	.-MLGS2E-2

	IF	JAPANESE
MLGS2J	HC	MLGS2Z
	BC	K.RO,K.KU,K.DAK,K.I,K.N,K.SP,K.SI,K.TE,K.KU,K.TA,K.DAK
	BC	K.SA,K.I
MLGS2Z	EQ	.-MLGS2J-2
	EI


:	MLGS3 -- USERNAME:
:	----
MLGS3E	HC	MLGS3Y
	BC	U.,S.,E.,R.,N.,A.,M.,E.,COLON.
MLGS3Y	EQ	.-MLGS3E-2

	IF	JAPANESE
MLGS3J	HC	MLGS3Z
	BC	K.YU,K.DASH,K.SA,K.DAK,K.NE,K.DASH,K.MU,K.COLN
MLGS3Z	EQ	.-MLGS3J-2
	EI


:	MLGS4 -- PASSWORD:
:	----
MLGS4E	HC	MLGS4Y
	BC	P.,A.,S.,S.,W.,O.,R.,D.,COLON.
MLGS4Y	EQ	.-MLGS4E-2

	IF	JAPANESE
MLGS4J	HC	MLGS4Z
	BC	K.HA,K.HAN,K.SU,K.WA,K.DASH,K.TO,K.DAK,K.COLN
MLGS4Z	EQ	.-MLGS4J-2
	EI


:	DSPS1 -- CONNECTION INFORMATION
:	-----
DSPS1E	HC	DSPS1Y
	BC	C.,O.,N.,N.,E.,C.,T.,I.,O.,N.,SP.
	BC	I.,N.,F.,O.,R.,M.,A.,T.,I.,O.,N.
DSPS1Y	EQ	.-DSPS1E-2

	IF	JAPANESE
DSPS1J	HC	DSPS1Z
	BC	K.KO,K.NE,K.KU,K.SI,K.YO.,K.N,K.SP,K.SI,K.DAK,K.YO.
	BC	K.U,K.HO,K.U
DSPS1Z	EQ	.-DSPS1J-2
	EI


:	DSPS2 -- CONNECTION REQUEST MODE:
:	------
DSPS2E	HC	DSPS2Y
	BC	C.,O.,N.,N.,E.,C.,T.,I.,O.,N.,SP.
	BC	R.,E.,Q.,U.,E.,S.,T.,SP.,M.,O.,D.,E.,COLON.
DSPS2Y	EQ	.-DSPS2E-2

	IF	JAPANESE
DSPS2J	HC	DSPS2Z
	BC	K.KO,K.NE,K.KU,K.SI,K.YO.,K.N,K.SP,K.RI,K.KU,K.E,K.SU
	BC	K.TO,K.SP,K.MO,K.DASH,K.TO,K.DAK,K.LPAR,K.UC,K.UR,K.UM
	BC	K.RPAR,K.COLN
DSPS2Z	EQ	.-DSPS2J-2
	EI


:	DSPS3 -- DESTINATION INTERFACE ADDRESS:
:	-------
DSPS3E	HC	DSPS3Y
	BC	D.,E.,S.,T.,I.,N.,A.,T.,I.,O.,N.,SP.
	BC	I.,N.,T.,E.,R.,F.,A.,C.,E.,SP.
	BC	A.,D.,D.,R.,E.,S.,S.,COLON.
DSPS3Y	EQ	.-DSPS3E-2

	IF	JAPANESE
DSPS3J	HC	DSPS3Z
	BC	K.SE,K.TU,K.SO,K.DAK,K.KU,K.SA,K.KI,K.SP,K.A,K.TO,K.DAK
	BC	K.RE,K.SU,K.COLN
DSPS3Z	EQ	.-DSPS3J-2
	EI


:	DSPS4 -- APPLICATION IDENTIFIER:
:	-------
DSPS4E	HC	DSPS4Y
	BC	A.,P.,P.,L.,I.,C.,A.,T.,I.,O.,N.,SP.
	BC	I.,D.,E.,N.,T.,I.,F.,I.,E.,R.,COLON.
DSPS4Y	EQ	.-DSPS4E-2

	IF	JAPANESE
DSPS4J	HC	DSPS4Z
	BC	K.A,K.HU,K.HAN,K.RI,K.KE,K.DASH,K.SI,K.YO.,K.N,K.SP
	BC	K.UI,K.UD,K.COLN
DSPS4Z	EQ	.-DSPS4J-2
	EI


:	DSPS5 -- DESTINATION CONTROL UNIT:
:	------
DSPS5E	HC	DSPS5Y
	BC	D.,E.,S.,T.,I.,N.,A.,T.,I.,O.,N.,SP.
	BC	C.,O.,N.,T.,R.,O.,L.,SP.,U.,N.,I.,T.,COLON.
DSPS5Y	EQ	.-DSPS5E-2

	IF	JAPANESE
DSPS5J	HC	DSPS5Z
	BC	K.SE,K.TU,K.SO,K.DAK,K.KU,K.SA,K.KI,K.SP,K.KO,K.N,K.TO
	BC	K.RO,K.DASH,K.RU,K.SP,K.YU,K.NI,K.TU.,K.TO,K.COLN
DSPS5Z	EQ	.-DSPS5J-2
	EI


:	DSPS6 -- DESTINATION DEVICE ADDRESS:
:	-------
DSPS6E	HC	DSPS6Y
	BC	D.,E.,S.,T.,I.,N.,A.,T.,I.,O.,N.,SP.,D.,E.
	BC	V.,I.,C.,E.,SP.,A.,D.,D.,R.,E.,S.,S.,COLON.
DSPS6Y	EQ	.-DSPS6E-2

	IF	JAPANESE
DSPS6J	HC	DSPS6Z
	BC	K.SE,K.TU,K.SO,K.DAK,K.KU,K.SA,K.KI,K.SP,K.SO,K.U,K.TI
	BC	K.SP,K.A,K.TO,K.DAK,K.RE,K.SU,K.COLN
DSPS6Z	EQ	.-DSPS6J-2
	EI


:	DSPS7 -- DO YOU WANT EXTENDED ATTRIBUTES?
:	-------
DSPS7E	HC	DSPS7Y
	BC	D.,O.,SP.,Y.,O.,U.,SP.,W.,A.,N.,T.,SP.
	BC	E.,X.,T.,E.,N.,D.,E.,D.,SP.
	BC	A.,T.,T.,R.,I.,B.,U.,T.,E.,S.,QUES.
DSPS7Y	EQ	.-DSPS7E-2

	IF	JAPANESE
DSPS7J	HC	DSPS7Z
	BC	K.KA,K.KU,K.TI,K.YO.,K.U,K.SP,K.A,K.TO,K.RI,K.HI,K.DAK
	BC	K.YU.,K.DASH,K.TO,K.WO,K.SP,K.SI,K.YO,K.U,K.SI
	BC	K.MA,K.SU,K.KA,K.QUE
DSPS7Z	EQ	.-DSPS7J-2
	EI


:	DSPS8 -- DO YOU WISH TO USE ASCII MODE?
:	------
DSPS8E	HC	DSPS8Y
:	BC	D.,O.,SP.,Y.,O.,U.,W.,I.,S.,H.,SP.,T.,O.,SP. (F01/10/14/87/HS)
	BC	D.,O.,SP.,Y.,O.,U.,SP.,W.,I.,S.,H.,SP.,T.,O.,SP. :(F01/10/14/87/HS)
	BC	U.,S.,E.,SP.,A.,S.,C.,I.,I.,SP.,M.,O.,D.,E.,QUES.
DSPS8Y	EQ	.-DSPS8E-2

	IF	JAPANESE
DSPS8J	HC	DSPS8Z
	BC	K.UA,K.US,K.UC,K.UI,K.UI,K.MO,K.DASH,K.TO,K.DAK
	BC	K.TE,K.DAK,K.SP,K.SI,K.YO,K.U,K.SI,K.MA,K.SU
	BC	K.KA,K.QUE
DSPS8Z	EQ	.-DSPS8J-2
	EI


:	DSPS9 -- DO YOU WANY COLOR?
:	------
DSPS9E	HC	DSPS9Y
	BC	D.,O.,SP.,Y.,O.,U.,SP.,W.,A.,N.,T.,SP.
	BC	C.,O.,L.,O.,R.,QUES.
DSPS9Y	EQ	.-DSPS9E-2

	IF	JAPANESE
DSPS9J	HC	DSPS9Z
	BC	K.KA,K.RA,K.DASH,K.TE,K.DAK,K.I.,K.SU,K.HU,K.HAN,K.RE
	BC	K.I.,K.TE,K.DAK,K.SU,K.KA,K.QUE
DSPS9Z	EQ	.-DSPS9J-2
	EI

:	DSPSA -- CHARACTER SET(0/4/5-ENG/KATA/KANJI):
:	------
DSPSAE	HC	DSPSAY
	BC	C.,H.,A.,R.,A.,C.,T.,E.,R.,SP.,S.,E.,T.,LP.,N0.,SLAH.
	BC	N4.,SLAH.,N5.,DASH.,E.,N.,G.,SLAH.,K.,A.,T.,A.,SLAH.
	BC	K.,A.,N.,J.,I.,RP.,COLON.
DSPSAY	EQ	.-DSPSAE-2

	IF	JAPANESE
DSPSAJ	HC	DSPSAZ
	BC	K.MO,K.SI,K.DAK,K.SP,K.SI,K.YU.,K.HE,K.DAK,K.TU
	BC	K.LPAR,K.0,K.SLSH,K.4,K.SLSH,K.5,K.DASH,K.E,K.I,K.MO
	BC	K.SI,K.DAK,K.SLSH,K.KA,K.TA,K.KA,K.NA,K.SLSH,K.KA,K.N
	BC	K.SI,K.DAK,K.RPAR,K.COLN
DSPSAZ	EQ	.-DSPSAJ-2
	EI
	EI	(TERMIF)

	IF	TERMIF!VHRSUP
:	DSPE0 -- ILLEGAL CRM NO.
:	-----
DSPE0E	HC	DSPE0Y
	BC	I.,L.,L.,E.,G.,A.,L.,SP.,C.,R.,M.,SP.,N.,O.,DOT.
DSPE0Y	EQ	.-DSPE0E-2
	EI	(TERMIF!VHRSUP)

	IF	TERMIF
	IF	JAPANESE
DSPE0J	HC	DSPE0Z
	BC	K.KO,K.NE,K.KU,K.SI,K.YO.,K.N,K.SP,K.RI,K.KU,K.E,K.SU
	BC	K.TO,K.SP,K.MO,K.DASH,K.TO,K.DAK,K.LPAR,K.UC,K.UR,K.UM
	BC	K.RPAR,K.SP,K.NA,K.N,K.HA,K.DAK,K.DASH,K.KA,K.DAK,K.SP,K.MA
	BC	K.TI,K.KA,K.DAK,K.TU.,K.TE,K.I,K.MA,K.SU
DSPE0Z	EQ	.-DSPE0J-2
	EI
	EI	(TERMIF)

	IF	TERMIF!VHRSUP
:	DSPE1 -- CRM4 NOT SUPPORTED
:	-------
DSPE1E	HC	DSPE1Y
	BC	C.,R.,M.,SP.,N4.,SP.,N.,O.,T.,SP.
	BC	S.,U.,P.,P.,O.,R.,T.,E.,D.
DSPE1Y	EQ	.-DSPE1E-2
	EI	(TERMIF!VHRSUP)

	IF	TERMIF
	IF	JAPANESE
DSPE1J	HC	DSPE1Z
	BC	K.KO,K.NE,K.KU,K.SI,K.YO.,K.N,K.SP,K.RI,K.KU,K.E,K.SU
	BC	K.TO,K.SP,K.MO,K.DASH,K.TO,K.DAK,K.SP,K.4,K.LPAR,K.UC
	BC	K.UR,K.UM,K.RPAR,K.HA,K.SP,K.SI,K.YO,K.U,K.TE,K.DAK
	BC	K.KI,K.MA,K.SE,K.N
DSPE1Z	EQ	.-DSPE1J-2
	EI
	EI	(TERMIF)

	IF	TERMIF!VHRSUP
:	DSPE2 -- ILLEGAL INTERFACE ADDR
:	------
DSPE2E	HC	DSPE2Y
	BC	I.,L.,L.,E.,G.,A.,L.,SP.,I.,N.,T.,E.,R.
	BC	F.,A.,C.,E.,SP.,A.,D.,D.,R.
DSPE2Y	EQ	.-DSPE2E-2
	EI	(TERMIF!VHRSUP)

	IF	TERMIF
	IF	JAPANESE
DSPE2J	HC	DSPE2Z
	BC	K.SE,K.TU,K.SO,K.DAK,K.KU,K.SA,K.KI,K.SP,K.A,K.TO,K.DAK
	BC	K.RE,K.SU,K.KA,K.DAK,K.SP,K.MU,K.KO,K.U,K.TE,K.DAK,K.SU
DSPE2Z	EQ	.-DSPE2J-2
	EI
	EI	(TERMIF)

	IF	TERMIF!VHRSUP
:	DSPE3 -- ILLEGAL APPLID-ID
:	------
DSPE3E	HC	DSPE3Y
	BC	I.,L.,L.,E.,G.,A.,L.,SP.,A.,P.,P.,L.,DASH.,I.,D.
DSPE3Y	EQ	.-DSPE3E-2
	EI	(TERMIF!VHRSUP)

	IF	TERMIF
	IF	JAPANESE
DSPE3J	HC	DSPE3Z
	BC	K.A,K.HU,K.HAN,K.RI,K.KE,K.DASH,K.SI,K.YO.,K.N
	BC	K.UI,K.UD,K.KA,K.DAK,K.SP,K.MU,K.KO,K.U,K.TE
	BC	K.DAK,K.SU
DSPE3Z	EQ	.-DSPE3J-2
	EI
	EI	(TERMIF)

	IF	TERMIF!VHRSUP
:	DSPE4 -- ILLEGAL CONTROLLER ADDR
:	-----
DSPE4E	HC	DSPE4Y
	BC	I.,L.,L.,E.,G.,A.,L.,SP.,C.,O.,N.
	BC	T.,R.,O.,L.,L.,E.,R.,SP.,A.,D.,D.,R.
DSPE4Y	EQ	.-DSPE4E-2
	EI	(TERMIF!VHRSUP)

	IF	TERMIF
	IF	JAPANESE
DSPE4J	HC	DSPE4Z
	BC	K.KO,K.N,K.TO,K.RO,K.DASH,K.RA,K.DASH,K.SP,K.A,K.TO
	BC	K.DAK,K.RE,K.SU,K.KA,K.DAK,K.SP,K.MU,K.KO,K.U
	BC	K.TE,K.DAK,K.SU
DSPE4Z	EQ	.-DSPE4J-2
	EI
	EI	(TERMIF)

	IF	TERMIF!VHRSUP
:	DSPE5 -- ILLEGAL DEVICE ADDR
:	-----
DSPE5E	HC	DSPE5Y
	BC	I.,L.,L.,E.,G.,A.,L.,SP.,D.,E.,V.,I.,C.,E.
	BC	SP.,A.,D.,D.,R.
DSPE5Y	EQ	.-DSPE5E-2
	EI	(TERMIF!VHRSUP)

	IF	TERMIF
	IF	JAPANESE
DSPE5J	HC	DSPE5Z
	BC	K.SO,K.U,K.TI,K.SP,K.A,K.TO,K.DAK,K.RE,K.SU,K.KA
	BC	K.DAK,K.SP,K.MU,K.KO,K.U,K.TE,K.DAK,K.SU
DSPE5Z	EQ	.-DSPE5J-2
	EI

:	DSPE6 -- ILLEGAL CHARACTER SET
:	-----
DSPE6E	HC	DSPE6Y
	BC	I.,L.,L.,E.,G.,A.,L.,SP.,C.,H.,A.,R.,A.,C.
	BC	T.,E.,R.,SP.,S.,E.,T.
DSPE6Y	EQ	.-DSPE6E-2

	IF	JAPANESE
DSPE6J	HC	DSPE6Z
	BC	K.MO,K.SI,K.DAK,K.SI,K.YU.,K.HE,K.DAK
	BC	K.TU,K.SP,K.E,K.RA,K.DASH
DSPE6Z	EQ	.-DSPE6J-2
	EI



	SUBTTL	(SNA) MESSAGES POINTERS TABLES

	HS	0

:	LEM1T -- TYPE USERNAME
:	------
LEM1T
	HC	LEM1E-PSEG
	IF	JAPANESE
	HC	LEM1J-PSEG
	EI

:	LEM2T -- TYPE PASSWORD
:	------
LEM2T
	HC	LEM2E-PSEG
	IF	JAPANESE
	HC	LEM2J-PSEG
	EI

:	LEM3T -- LOGON IN PROGRESS
:	------
LEM3T
	HC	LEM3E-PSEG
	IF	JAPANESE
	HC	LEM3J-PSEG
	EI

:	LEM4T -- LOGON FAILED
:	------
LEM4T
	HC	LEM4E-PSEG
	IF	JAPANESE
	HC	LEM4J-PSEG
	EI

:	LEM5T -- USERNAME ERROR DURING PRESET LOGON
:	------
LEM5T
	HC	LEM5E-PSEG
	IF	JAPANESE
	HC	LEM5J-PSEG
	EI

:	LEM6T -- PASSWORD ERROR DURING PRESET LOGON
:	------
LEM6T
	HC	LEM6E-PSEG
	IF	JAPANESE
	HC	LEM6J-PSEG
	EI

:	LEM7T -- BAD STORED DSP ELEMENT - ABORTED
:	------
LEM7T
	HC	LEM7E-PSEG
	IF	JAPANESE
	HC	LEM7J-PSEG
	EI

:	LEM8T -- PLEASE SEE YOUR REP...
:	------
LEM8T
	HC	LEM8E-PSEG
	IF	JAPANESE
	HC	LEM8J-PSEG
	EI

:	LEM9T -- BAD MUD
:	------
LEM9T
	HC	LEM9E-PSEG
	IF	JAPANESE
	HC	LEM9J-PSEG
	EI

:	LEM0AT -- CIRCUIT BUSY
:	------
LEM0AT
	HC	LEM0AE-PSEG
	IF	JAPANESE
	HC	LEM0AJ-PSEG
	EI

:	LEM0BT -- HOST NOT AVAILABLE
:	------
LEM0BT
	HC	LEM0BE-PSEG
	IF	JAPANESE
	HC	LEM0BJ-PSEG
	EI

:	LEM0CT -- HOST OUR OF PORTS
:	------
LEM0CT
	HC	LEM0CE-PSEG
	IF	JAPANESE
	HC	LEM0CJ-PSEG
	EI

:	LEM0DT -- HOST DOWN
:	------
LEM0DT
	HC	LEM0DE-PSEG
	IF	JAPANESE
	HC	LEM0DJ-PSEG
	EI

:	LEM0ET -- HOST SHUT
:	------
LEM0ET
	HC	LEM0EE-PSEG
	IF	JAPANESE
	HC	LEM0EJ-PSEG
	EI

:	LEM0FT -- TRY AGAIN IN 2 MINUTES
:	------
LEM0FT
	HC	LEM0FE-PSEG
	IF	JAPANESE
	HC	LEM0FJ-PSEG
	EI

:	LEM10T -- ACCESS NOT PERMITTED
:	------
LEM10T
	HC	LEM10E-PSEG
	IF	JAPANESE
	HC	LEM10J-PSEG
	EI

:	LEM11T -- NO HOST SPECIFIED
:	------
LEM11T
	HC	LEM11E-PSEG
	IF	JAPANESE
	HC	LEM11J-PSEG
	EI

:	LEM12T -- BAD HOST NUMBER
:	------
LEM12T
	HC	LEM12E-PSEG
	IF	JAPANESE
	HC	LEM12J-PSEG
	EI

:	LEM13T -- MUD ERROR
:	------
LEM13T
	HC	LEM13E-PSEG
	IF	JAPANESE
	HC	LEM13J-PSEG
	EI

:	LEM14T -- CONNECTION IN PROGRESS
:	------
LEM14T
	HC	LEM14E-PSEG
	IF	JAPANESE
	HC	LEM14J-PSEG
	EI

:	LEM15T -- CONNECTION FAILED
:	------
LEM15T
	HC	LEM15E-PSEG
	IF	JAPANESE
	HC	LEM15J-PSEG
	EI

:	LEM16T -- PROCEDURE ABORTED
:	------
LEM16T
	HC	LEM16E-PSEG
	IF	JAPANESE
	HC	LEM16J-PSEG
	EI

:	LEM18T -- LOGON TAILED - NON SNA HOST
:	------
LEM18T
	HC	LEM18E-PSEG
	IF	JAPANESE
	HC	LEM18J-PSEG
	EI

:	LEM19T -- INPUT ERROR
:	------
LEM19T
	HC	LEM19E-PSEG
	IF	JAPANESE
	HC	LEM19J-PSEG
	EI

:	LEM1AT-- NO HOST SPECIFIED
:	------
LEM1AT
	HC	LEM1AE-PSEG
	IF	JAPANESE
	HC	LEM1AJ-PSEG
	EI

:	LEM20T -- CRT IS CURRENTLY LOGGED IN
:	------
LEM20T
	HC	LEM20E-PSEG
	IF	JAPANESE
	HC	LEM20J-PSEG
	EI

:	LEM21T - CRT IS CURRENTLY NOT LOGGED IN
:	------
LEM21T
	HC	LEM21E-PSEG
	IF	JAPANESE
	HC	LEM21J-PSEG
	EI

:	LEM22T -- PRT IS CURRENTLY LOGGED IN
:	------
LEM22T
	HC	LEM22E-PSEG
	IF	JAPANESE
	HC	LEM22J-PSEG
	EI

:	LEM23T -- PRT IS CURRRENTLY NOT LOGGED IN
:	------
LEM23T
	HC	LEM23E-PSEG
	IF	JAPANESE
	HC	LEM23J-PSEG
	EI

:	NNS02T -- 1. MANUAL LOGON - CRT
:	------
NNS02T
	HC	NNS02E-PSEG
	IF	JAPANESE
	HC	NNS02J-PSEG
	EI

:	NNS03T -- 2. PRESET LOGON - CRT
:	------
NNS03T
	HC	NNS03E-PSEG
	IF	JAPANESE
	HC	NNS03J-PSEG
	EI

:	NNS04T -- 3. MANUAL LOGON - PRT
:	------
NNS04T
	HC	NNS04E-PSEG
	IF	JAPANESE
	HC	NNS04J-PSEG
	EI

:	NNS05T -- 4. PRESET LOGON - PRT
:	------
NNS05T
	HC	NNS05E-PSEG
	IF	JAPANESE
	HC	NNS05J-PSEG
	EI

:	NNS06T -- 5. LOGOFF - CRT
:	------
NNS06T
	HC	NNS06E-PSEG
	IF	JAPANESE
	HC	NNS06J-PSEG
	EI

:	NNS07T -- 6. LOGOFF - PRT
:	------
NNS07T
	HC	NNS07E-PSEG
	IF	JAPANESE
	HC	NNS07J-PSEG
	EI

:	NNS08T -- 7. EXIT
:	------
NNS08T
	HC	NNS08E-PSEG
	IF	JAPANESE
	HC	NNS08J-PSEG
	EI

:	NNS09T -- ENTER SELECTION:
:	------
NNS09T
	HC	NNS09E-PSEG
	IF	JAPANESE
	HC	NNS09J-PSEG
	EI

:	NNSX9T -- , ETNER PRINTER #:
:	------
NNSX9T
	HC	NNSX9E-PSEG
	IF	JAPANESE
	HC	NNSX9J-PSEG
	EI

:	NNS0AT -- DEVICES STATUS
:	------
NNS0AT
	HC	NNS0AE-PSEG
	IF	JAPANESE
	HC	NNS0AJ-PSEG
	EI

:	NNS0BT - LU NN CRT/PRT
:	-----
NNS0BT
	HC	NNS0BE
	IF	JAPANESE
	HC	NNS0BJ
	EI

:	NNS0CT -- DISCONNECTD FROM REMOTE
:	------
NNS0CT
	HC	NNS0CE-PSEG
	IF	JAPANESE
	HC	NNS0CJ-PSEG
	EI

:	NNS0DT -- CONNECTED TO REMOTE
:	------
NNS0DT
	HC	NNS0DE-PSEG
	IF	JAPANESE
	HC	NNS0DJ-PSEG
	EI

:	NNSE1T -- WRONG..., TRY AGAIN
:	------
NNSE1T
	HC	NNSE1E-PSEG
	IF	JAPANESE
	HC	NNSE1J-PSEG
	EI

:	NNSE3T -- DEVICE NOT LOGGED IN
:	------
NNSE3T
	HC	NNSE3E-PSEG
	IF	JAPANESE
	HC	NNSE3J-PSEG
	EI

:	NNSE4T -- SOMEONE ELSE IS LOGGING PRINTER
:	------
NNSE4T
	HC	NNSE4E-PSEG
	IF	JAPANESE
	HC	NNSE4J-PSEG
	EI

:	NNSE5T -- PRINTER IS ALREADY LOGGED IN
:	------
NNSE5T
	HC	NNSE5E-PSEG
	IF	JAPANESE
	HC	NNSE5J-PSEG
	EI

:	NNSE6T -- CRT NOT CONNECTED, EXIT NOT ALLOWED
:	------
NNSE6T
	HC	NNSE6E-PSEG
	IF	JAPANESE
	HC	NNSE6J-PSEG
	EI

:	NNSE7T -- FUNCTION NOT SUPPORTED YET
:	------
NNSE7T
	HC	NNSE7E-PSEG
	IF	JAPANESE
	HC	NNSE7J-PSEG
	EI

:	MLGS1T-- MANUAL  LOGON
:	------
MLGS1T
	HC	MLGS1E-PSEG
	IF	JAPANESE
	HC	MLGS1J-PSEG
	EI

:	MLGS2T -- PLEASE LOGIN
:	------
MLGS2T
	HC	MLGS2E-PSEG
	IF	JAPANESE
	HC	MLGS2J-PSEG
	EI

:	MLGS3T -- USERNAME:
:	------
MLGS3T
	HC	MLGS3E-PSEG
	IF	JAPANESE
	HC	MLGS3J-PSEG
	EI

:	MLGS4T -- PASSWORD
:	------
MLGS4T
	HC	MLGS4E-PSEG
	IF	JAPANESE
	HC	MLGS4J-PSEG
	EI

:	LOGS2T -- ENTER SELECTION:
:	------
LOGS2T
	HC	LOGS2E-PSEG
	IF	JAPANESE
	HC	LOGS2J-PSEG
	EI

:	DSPS1T -- CONNECRTION INFORMATION
:	------
DSPS1T
	HC	DSPS1E-PSEG
	IF	JAPANESE
	HC	DSPS1J-PSEG
	EI

:	DSPS2T -- CONNCETION REQUEST MODE:
:	------
DSPS2T
	HC	DSPS2E-PSEG
	IF	JAPANESE
	HC	DSPS2J-PSEG
	EI

:	DSPS3T -- DESTINATION INTERFACE ADDRESS:
:	------
DSPS3T
	HC	DSPS3E-PSEG
	IF	JAPANESE
	HC	DSPS3J-PSEG
	EI

:	DSPS4T -- APPLICATION IDENTIFIER:
:	------
DSPS4T
	HC	DSPS4E-PSEG
	IF	JAPANESE
	HC	DSPS4J-PSEG
	EI

:	DSPS5T -- DESTINATION CONTROL UNIT:
:	------
DSPS5T
	HC	DSPS5E-PSEG
	IF	JAPANESE
	HC	DSPS5J-PSEG
	EI

:	DSPS6T -- DESTINATION DEVICE ADDRESS:
:	------
DSPS6T
	HC	DSPS6E-PSEG
	IF	JAPANESE
	HC	DSPS6J-PSEG
	EI

:	DSPS7T -- DO YOU WANT EXTENDED ATTRIBUTES?
:	-------
DSPS7T
	HC	DSPS7E-PSEG
	IF	JAPANESE
	HC	DSPS7J-PSEG
	EI

:	DSP8T -- DO YOU WICH TO USE ASCII MODE?
:	------
DSPS8T
	HC	DSPS8E-PSEG
	IF	JAPANESE
	HC	DSPS8J-PSEG
	EI

:	DSPS9T -- DO YOU WANT COLOR?
:	------
DSPS9T
	HC	DSPS9E-PSEG
	IF	JAPANESE
	HC	DSPS9J-PSEG
	EI

:	DSPSAT -- CHARACTER SET(0/4/5-ENG/KATA/KANJI):
:	------
DSPSAT
	HC	DSPSAE-PSEG
	IF	JAPANESE
	HC	DSPSAJ-PSEG
	EI

:	DSPE0T -- ILLEGAL CRM NO.
:	------
DSPE0T
	HC	DSPE0E-PSEG
	IF	JAPANESE
	HC	DSPE0J-PSEG
	EI

:	DSPE1T -- CRM 4 NOT SUPPORTED
:	------
DSPE1T
	HC	DSPE1E-PSEG
	IF	JAPANESE
	HC	DSPE1J-PSEG
	EI

:	DSPE2T -- ILLEGAL INTERFACE ADDR
:	------
DSPE2T
	HC	DSPE2E-PSEG
	IF	JAPANESE
	HC	DSPE2J-PSEG
	EI

:	DSPE3T -- ILLEGAL APPL-ID
:	------
DSPE3T
	HC	DSPE3E-PSEG
	IF	JAPANESE
	HC	DSPE3J-PSEG
	EI

:	DSPE4T -- ILLEGAL CONTROLLER ADDR
:	------
DSPE4T
	HC	DSPE4E-PSEG
	IF	JAPANESE
	HC	DSPE4J-PSEG
	EI

:	DSPE5T -- ILLEGAL DEVICE ADDR
:	------
DSPE5T
	HC	DSPE5E-PSEG
	IF	JAPANESE
	HC	DSPE5J-PSEG
	EI

:	DSPE6T -- ILLEGAL CHARACTER SET
:	------
DSPE6T
	HC	DSPE6E-PSEG
	IF	JAPANESE
	HC	DSPE6J-PSEG
	EI

	EI	(TERMIF)


	IF	HOSTIF

:
:	ERROR MSGS FOR CIRCUIT ATTCHMENT (HIF)
:	IN EBCDIC
:

:	ATER1 -- SNAH 01 - INVLIDD HOST NUMBER
:	-----
ATER1E	HC	ATER1Y
	BC	S.,N.,A.,H.,SP.,N0.,N1.,SP.,DASH.,SP.,I.,N.,V.,A.,L.,I.
	BC	D.,SP.,H.,O.,S.,T.,SP.,N.,U.,M.,B.,E.,R.
ATER1Y	EQ	.-ATER1E-2

	IF	JAPANESE
ATER1J	HC	ATER1Z
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.1,K.SP,K.DASH,K.SP
	BC	K.HO,K.SU,K.TO,K.NA,K.N,K.HA,K.DAK,K.DASH,K.KA,K.DAK,K.SP
	BC	K.MA,K.TI,K.KA,K.DAK,K.TU.,K.TE,K.I,K.MA,K.SU
ATER1Z	EQ	.-ATER1J-2
	EI

:	ATER2 -- SNAH 02 - APPL-ID/LINE# NOT AVAILABLE
:	-----
ATER2E	HC	ATER2Y
	BC	S.,N.,A.,H.,SP.,N0.,N2.,SP.,DASH.,A.,P.,P.,L.
	BC	DASH.,I.,D.,SLAH.,L.,I.,N.,E.,POND.,SP.,N.,O.
	BC	T.,SP.,A.,V.,A.,I.,L.,A.,B.,L.,E.
ATER2Y	EQ	.-ATER2E-2

	IF	JAPANESE
ATER2J	HC	ATER2Z
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.2,K.SP,K.DASH,K.SP
	BC	K.UL,K.UI,K.UN,K.UE,K.PND,K.NO,K.SP,K.A,K.HU,K.HAN,K.RI
	BC	K.KE,K.DASH,K.SI,K.YO.,K.N,K.UI,K.UD,K.KA,K.DAK,K.SP,K.MA
	BC	K.TI,K.KA,K.DAK,K.TU.,K.TE,K.I,K.MA,K.SU
ATER2Z	EQ	.-ATER2J-2
	EI

:	ATER3 -- SNAH 03 - CONTROL UNIT NOT AVAILABLE
:	----
ATER3E	HC	ATER3Y
	BC	S.,N.,A.,H.,SP.,N0.,N3.,SP.,DASH.,C.,O.,N.
	BC	T.,R.,O.,L.,SP.,U.,N.,I.,T.,SP.,N.,O.,T.,SP.
	BC	A.,V.,A.,I.,L.,A.,B.,L.,E.
ATER3Y	EQ	.-ATER3E-2

	IF	JAPANESE
ATER3J	HC	ATER3Z
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.3,K.SP,K.DASH,K.SP
	BC	K.KO,K.N,K.TO,K.RO,K.DASH,K.RU,K.YU,K.NI,K.TU.,K.TO,K.KA
	BC	K.DAK,K.SP,K.SI,K.YO,K.U,K.TE,K.DAK,K.KI,K.MA,K.SE,K.N
ATER3Z	EQ	.-ATER3J-2
	EI

:	ATER4 -- SNAH 04 - DEVICE NOT AVAILABLE
:	----
ATER4E	HC	ATER4Y
:	BC	S.,N.,A.,H.,SP.,N0.,N4.,SP.,D.,E.,V.,I.,C.,E. :(F01/10/14/87/HS)
	BC	S.,N.,A.,H.,SP.,N0.,N4.,SP.,DASH.,SP.,D.,E.,V.,I.,C.,E. :(F01/10/14/87/HS)
	BC	SP.,N.,O.,T.,SP.,A.,V.,A.,I.,L.,A.,B.,L.,E.
ATER4Y	EQ	.-ATER4E-2

	IF	JAPANESE
ATER4J	HC	ATER4Z
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.4,K.SP,K.DASH,K.SP
	BC	K.SO,K.U,K.TI,K.KA,K.DAK,K.SP,K.SI,K.YO,K.U,K.TE,K.DAK
	BC	K.KI,K.MA,K.SE,K.N
ATER4Z	EQ	.-ATER4J-2
	EI

:	ATER5 --  SNAH 05 - DEVICE WITH SPECIFIED TYPE NOT AVAILABLE
:	-----
ATER5E	HC	ATER5Y
	BC	S.,N.,A.,H.,SP.,N0.,N5.,SP.,DASH.,D.,E.,V.,I.,C.,E.
	BC	SP.,W.,I.,T.,H.,SP.,S.,P.,E.,C.,I.,F.,I.,E.,D.,SP.
:	BC	N.,O.,T.,SP.,A.,V.,A.,I.,L.,A.,B.,L.,E. :(F01/10/14/87/HS)
	BC	T.,Y.,P.,E.,SP.,N.,O.,T.,SP.,A.,V.,A.,I.,L.,A.,B.,L.,E. :(F01/10/14/87/HS)
ATER5Y	EQ	.-ATER5E-2

	IF	JAPANESE
ATER5J	HC	ATER5Z
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.5,K.SP,K.DASH,K.SP
	BC	K.KO,K.NO,K.TA,K.I,K.HU,K.HAN,K.NO,K.SP,K.SO,K.U,K.TI,K.HA
	BC	K.SI,K.YO,K.U,K.TE,K.DAK,K.KI,K.MA,K.SE,K.N
ATER5Z	EQ	.-ATER5J-2
	EI

:	ATER6 -- SNAH 06 - DEVICE WITH SPECIFIED ATTRIBUTE NOT AVAILABLE
:	----
ATER6E	HC	ATER6Y
	BC	S.,N.,A.,H.,SP.,N0.,N6.,SP.,DASH.,D.,E.,V.,I.,C.,E.
	BC	SP.,W.,I.,T.,H.,SP.,S.,P.,E.,C.,I.,F.,I.,E.,D.,SP.
	BC	A.,T.,T.,R.,I.,B.,U.,T.,E.,SP.,N.,O.,T.,SP.
	BC	A.,V.,A.,I.,L.,A.,B.,L.,E.
ATER6Y	EQ	.-ATER6E-2

	IF	JAPANESE
ATER6J	HC	ATER6Z
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.6,K.SP,K.DASH,K.SP
	BC	K.SI,K.TE,K.I,K.NO,K.SP,K.A,K.TO,K.RI,K.HI,K.DAK,K.YU.
	BC	K.DASH,K.TO,K.HA,K.SP,K.SI,K.YO,K.U,K.TE,K.DAK,K.KI,K.MA
	BC	K.SE,K.N
ATER6Z	EQ	.-ATER6J-2
	EI

:	ATER7 -- SNAH 07 - DEVICE NOT ACTIVATED
:	----
ATER7E	HC	ATER7Y
	BC	S.,N.,A.,H.,SP.,N0.,N7.,SP.,DASH.,SP.,D.,E.,V.,I.,C.,E.
	BC	SP.,N.,O.,T.,SP.,A.,C.,T.,I.,V.,A.,T.,E.,D.
ATER7Y	EQ	.-ATER7E-2

	IF	JAPANESE
ATER7J	HC	ATER7Z
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.7,K.SP,K.DASH,K.SP
	BC	K.SO,K.U,K.TI,K.KA,K.DAK,K.SP,K.SA,K.TO,K.DAK,K.U,K.SI
	BC	K.TE,K.I,K.MA,K.SE,K.N
ATER7Z	EQ	.-ATER7J-2
	EI

:	ATER8 -- SNAH 08 - DEVICE ALREADY IN USE
:	-----
ATER8E	HC	ATER8Y
	BC	S.,N.,A.,H.,SP.,N0.,N8.,SP.,DASH.,SP.,D.,E.,V.,I.,C.,E.
	BC	SP.,A.,L.,R.,E.,A.,D.,Y.,SP.,I.,N.,SP.,U.,S.,E.
ATER8Y	EQ	.-ATER8E-2

	IF	JAPANESE
ATER8J	HC	ATER8Z
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.8,K.SP,K.DASH,K.SP
	BC	K.SO,K.U,K.TI,K.HA,K.SU,K.TE,K.DAK,K.NI,K.SP,K.SI,K.TO,K.U
	BC	K.SA,K.RE,K.TE,K.I,K.MA,K.SU
ATER8Z	EQ	.-ATER8J-2
	EI

:	ATER9 -- SNAH 09 - USER NOT AUTHORIZED
:	-----
ATER9E	HC	ATER9Y
	BC	S.,N.,A.,H.,SP.,N0.,N9.,SP.,DASH.,U.,S.,E.,R.,SP.
	BC	N.,O.,T.,SP.,A.,U.,T.,H.,O.,R.,I.,Z.,E.,D.
ATER9Y	EQ	.-ATER9E-2

	IF	JAPANESE
ATER9J	HC	ATER9Z
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.9,K.SP,K.DASH,K.SP
	BC	K.U,K.DASH,K.SA,K.DAK,K.NO,K.SP,K.SI,K.YO,K.U,K.HA,K.SP
	BC	K.MI,K.TO,K.ME,K.RA,K.RE,K.TE,K.O,K.RI,K.MA,K.SE,K.N
ATER9Z	EQ	.-ATER9J-2
	EI

:	ATERA -- SNAH 0A - WAIT ONE MINUTE AND TRY AGAIN
:	-----
ATERAE	HC	ATERAY
	BC	S.,N.,A.,H.,SP.,N0.,A.,SP.,DASH.,SP.,W.,A.,I.,T.
	BC	SP.,O.,N.,E.,SP.,M.,I.,N.,U.,T.,E.,SP.,A.,N.,D.
	BC	SP.,T.,R.,Y.,SP.,A.,G.,A.,I.,N.
ATERAY	EQ	.-ATERAE-2

	IF	JAPANESE
ATERAJ	HC	ATERAZ
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.UA,K.UH,K.SP,K.DASH,K.SP
	BC	K.SI,K.HA,K.DAK,K.RA,K.KU,K.SI,K.TE,K.MO,K.U,K.TI,K.TO
	BC	K.DAK,K.SP,K.YA,K.RI,K.NA,K.O,K.SI,K.TE,K.KU,K.TA,K.DAK
	BC	K.SA,K.I
ATERAZ	EQ	.-ATERAJ-2
	EI

:	ATERB -- SNAH 0B - NO ASSOCIATED DEVICE
:	----
ATERBE	HC	ATERBY
	BC	S.,N.,A.,H.,SP.,N0.,B.,SP.,DASH.,SP.,N.,O.,SP.
	BC	A.,S.,S.,O.,C.,I.,A.,T.,E.,D.,SP.,D.,E.,V.,I.,C.,E.
ATERBY	EQ	.-ATERBE-2

	IF	JAPANESE
ATERBJ	HC	ATERBZ
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.UB,K.SP,K.DASH,K.SP
	BC	K.SO,K.U,K.TI,K.NI,K.SP,K.SE,K.TU,K.SO,K.DAK,K.KU,K.TE
	BC	K.DAK,K.KI,K.MA,K.SE,K.N
ATERBZ	EQ	.-ATERBJ-2
	EI

:	ATERC -- SNAH 0C - ASSOCIATED DEVICE ALREADY IN USE
:	-----
ATERCE	HC	ATERCY
	BC	S.,N.,A.,H.,SP.,N0.,C.,SP.,DASH.,SP.,A.,S.,S.,O.
	BC	C.,I.,A.,T.,E.,D.,SP.,D.,E.,V.,I.,C.,E.,SP.
	BC	A.,L.,R.,E.,A.,D.,Y.,SP.,I.,N.,SP.,U.,S.,E.
ATERCY	EQ	.-ATERCE-2

	IF	JAPANESE
ATERCJ	HC	ATERCZ
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.UC,K.SP,K.DASH,K.SP
	BC	K.SO,K.U,K.TI,K.HA,K.SU,K.TE,K.DAK,K.NI,K.SP,K.SE,K.TU
	BC	K.SO,K.DAK,K.KU,K.SA,K.RE,K.TE,K.I,K.MA,K.SU
ATERCZ	EQ	.-ATERCJ-2
	EI

:	ATERD -- SNAH 0D - PROTOCOL NOT SUPPORTED
:	-----
ATERDE	HC	ATERDY
	BC	S.,N.,A.,H.,SP.,N0.,D.,SP.,DASH.,SP.,P.,R.,O.
	BC	T.,O.,C.,O.,L.,SP.,N.,O.,T.,SP.,S.,U.,P.,P.
	BC	O.,R.,T.,E.,D.
ATERDY	EQ	.-ATERDE-2

	IF	JAPANESE
ATERDJ	HC	ATERDZ
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.UD,K.SP,K.DASH.K.SP
	BC	K.TU,K.U,K.SI,K.N,K.TE,K.SI,K.DAK,K.YU.,K.N,K.KA,K.DAK
	BC	K.SP,K.SA,K.HO,K.HAN,K.DASH,K.TO,K.SA,K.RE,K.TE,K.O,K.RI
	BC	K.MA,K.SE,K.N
ATERDZ	EQ	.-ATERDJ-2
	EI

:	ATERE -- SNAH 0E - DEVICE WITH SPECIFIED CHARACTER SET NOT AVAILABLE
:	-----
ATEREE	HC	ATEREY
	BC	S.,N.,A.,H.,SP.,N0.,E.,SP.,DASH.,SP.,D.,E.,V.,I.
	BC	C.,E.,SP.,W.,I.,T.,H.,SP.,S.,P.,E.,C.,I.,F.,I.,E.
	BC	D.,SP.,C.,H.,A.,R.,A.,C.,T.,E.,R.,SP.,S.,E.,T.
	BC	SP.,N.,O.,T.,SP.,A.,V.,A.,I.,L.,A.,B.,L.,E.
ATEREY	EQ	.-ATEREE-2

	IF	JAPANESE
ATEREJ	HC	ATEREZ
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.UE,K.SP
	BC	K.DASH,K.SP
        BC      K.MO,K.SI,K.DAK,K.SI,K.YU.,K.HE,K.DAK,K.TU,K.KA
        BC      K.DAK,K.SP,K.I,K.TU.,K.TI,K.SI,K.TE,K.I,K.MA,K.SE,K.N
ATEREZ	EQ	.-ATEREJ-2
	EI

:	ATERF -- SNAH 0F - EQUIPMENT TYPE NOT SUPPORTED
:	-----
ATERFE	HC	ATERFY
	BC	S.,N.,A.,H.,SP.,N0.,F.,SP.,DASH.,SP.,E.,Q.,U.
	BC	I.,P.,M.,E.,N.,T.,SP.,T.,Y.,P.,E.,SP.,N.,O.
	BC	T.,SP.,S.,U.,P.,P.,O.,R.,T.,E.,D.
ATERFY	EQ	.-ATERFE-2

	IF	JAPANESE
ATERFJ	HC	ATERFZ
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.UF,K.SP
	BC	K.DASH,K.SP
        BC      K.KO,K.NO,K.SP,K.SO,K.U,K.TI,K.HA,K.SP,K.TU,K.KA,K.E
        BC      K.MA,K.SE,K.N
ATERFZ	EQ	.-ATERFJ-2
	EI
				:(F00/02/09/87/DB/START) CRM 4 IMPLEMENTATION
:	ATERG -- SNAH 10 - ASSOCIATED CRT UNATTACHED
:	-----
ATERGE	HC	ATERGY
	BC	S.,N.,A.,H.,SP.,N1.,N0.,SP.,DASH.,SP.,A.,S.,S.
	BC	O.,C.,I.,A.,T.,E.,D.,SP.,C.,R.,T.,SP.,U.,N.,A.,T.
	BC	T.,A.,C.,H.,E.,D.
ATERGY	EQ	.-ATERGE-2

	IF	JAPANESE
ATERGJ	HC	ATERGZ
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.UF,K.SP
	BC	K.DASH,K.SP
        BC      K.KO,K.NO,K.SP,K.SO,K.U,K.TI,K.HA,K.SP,K.TU,K.KA,K.E
        BC      K.MA,K.SE,K.N
ATERGZ	EQ	.-ATERGJ-2
	EI

:	ATERH -- SNAH 11 - INVALID ASSOCIATION
:	-----
ATERHE	HC	ATERHY
	BC	S.,N.,A.,H.,SP.,N1.,N1.,SP.,DASH.,SP.,I.,N.,V.
	BC	A.,L.,I.,D.,SP.,A.,S.,S.,O.,C.,I.,A.,T.,I.,O.,N.
ATERHY	EQ	.-ATERHE-2

	IF	JAPANESE
ATERHJ	HC	ATERHZ
	BC	K.US,K.UN,K.UA,K.UH,K.SP,K.0,K.UF,K.SP
	BC	K.DASH,K.SP
        BC      K.KO,K.NO,K.SP,K.SO,K.U,K.TI,K.HA,K.SP,K.TU,K.KA,K.E
        BC      K.MA,K.SE,K.N
ATERHZ	EQ	.-ATERHJ-2
	EI
				:(F00/02/09/87/DB/END)

	HS	0

ATER1T
	HC	ATER1E-PSEG
	IF	JAPANESE
	HC	ATER1J-PSEG
	EI

ATER2T
	HC	ATER2E-PSEG
	IF	JAPANESE
	HC	ATER2J-PSEG
	EI

ATER3T
	HC	ATER3E-PSEG
	IF	JAPANESE
	HC	ATER3J-PSEG
	EI

ATER4T
	HC	ATER4E-PSEG
	IF	JAPANESE
	HC	ATER4J-PSEG
	EI

ATER5T
	HC	ATER5E-PSEG
	IF	JAPANESE
	HC	ATER5J-PSEG
	EI

ATER6T
	HC	ATER6E-PSEG
	IF	JAPANESE
	HC	ATER6J-PSEG
	EI

ATER7T
	HC	ATER7E-PSEG
	IF	JAPANESE
	HC	ATER7J-PSEG
	EI

ATER8T
	HC	ATER8E-PSEG
	IF	JAPANESE
	HC	ATER8J-PSEG
	EI

ATER9T
	HC	ATER9E-PSEG
	IF	JAPANESE
	HC	ATER9J-PSEG
	EI

ATERAT
	HC	ATERAE-PSEG
	IF	JAPANESE
	HC	ATERAJ-PSEG
	EI

ATERBT
	HC	ATERBE-PSEG
	IF	JAPANESE
	HC	ATERBJ-PSEG
	EI

ATERCT
	HC	ATERCE-PSEG
	IF	JAPANESE
	HC	ATERCJ-PSEG
	EI

ATERDT
	HC	ATERDE-PSEG
	IF	JAPANESE
	HC	ATERDJ-PSEG
	EI

ATERET
	HC	ATEREE-PSEG
	IF	JAPANESE
	HC	ATEREJ-PSEG
	EI

ATERFT
	HC	ATERFE-PSEG
	IF	JAPANESE
	HC	ATERFJ-PSEG
	EI
				:(F00/02/09/87/DB/START) CRM 4 IMPLEMENTATION
ATERGT
	HC	ATERGE-PSEG
	IF	JAPANESE
	HC	ATERGJ-PSEG
	EI
ATERHT
	HC	ATERHE-PSEG
	IF	JAPANESE
	HC	ATERHJ-PSEG
	EI
				:(F00/02/09/87/DB/END)

	EI	(HOSTIF)


	IF	TERMIF

:
:	PROMPT MESSAGES FOR LU.SVC ROUTINES
:

:	SNT50 -- <NL>SNAT 50 - INTERFACE NOT READY<NL>
:	-----
SNT50E	HS	0
	HC	SNT50Y
	BC	NL.,S.,N.,A.,T.,SP.,N5.,N0.,SP.,DASH.,I.,N.,T.,E.,R.
	BC	F.,A.,C.,E.,SP.,N.,O.,T.,SP.,R.,E.,A.,D.,Y.,NL.
SNT50Y	EQ	.-SNT50E-2

	IF	JAPANESE
SNT50J	HS	0
	HC	SNT50Z
	BC	K.NL,K.US,K.UN,K.UA,K.UT,K.SP,K.5,K.0,K.SP,K.DASH,K.SP
	BC	K.SE,K.TU,K.SO,K.DAK,K.KU,K.SA,K.KI,K.NO,K.SP,K.SI,K.DAK
	BC	K.YU.,K.N,K.HI,K.DAK,K.KA,K.DAK,K.SP,K.TE,K.DAK,K.KI,K.TE
	BC	K.O,K.RI,K.MA,K.SE,K.N,K.NL
SNT50Z	EQ	.-SNT50J-2
	EI

SNT50T	HS	0
	HC	SNT50E-PSEG
	IF	JAPANESE
	HC	SNT50J-PSEG
	EI

:	SNT51 -- <NL>SNAT 51 - INPUT DISCARDED<NL>
:	-----
SNT51E	HS	0
	HC	SNT51Y
	BC	NL.,S.,N.,A.,T.,SP.,N5.,N1.,SP.,DASH.,I.,N.,P.,U.,T.
	BC	SP.,D.,I.,S.,C.,A.,R.,D.,E.,D.,NL.
SNT51Y	EQ	.-SNT51E-2

	IF	JAPANESE
SNT51J	HS	0
	HC	SNT51Z
	BC	K.NL,K.US,K.UN,K.UA,K.UT,K.SP,K.5,K.1,K.SP,K.DASH,K.SP
	BC	K.NI,K.YU.,K.U,K.RI,K.YO.,K.KU,K.SI,K.DAK,K.YO.,K.U,K.HO
	BC	K.U,K.HA,K.SP,K.SU,K.TE,K.RA,K.RE,K.MA,K.SI,K.TA,K.NL
SNT51Z	EQ	.-SNT51J-2
	EI

SNT51T	HS	0
	HC	SNT51E-PSEG
	IF	JAPANESE
	HC	SNT51J-PSEG
	EI

:	SNT52 -- <NL>SNAT 52 - HIT SYS/REQ KEY TO RETURN TO LU-LU SCREEN<NL>
:	-----
SNT52E	HS	0
	HC	SNT52Y
:	BC	NL.,H.,I.,T.,SP.,S.,Y.,S.,SLAH.,R.,E.,Q.,SP. :(F01/10/14/87/HS)
	BC	NL.,S.,N.,A.,T.,SP.,N5.,N2.,SP.,DASH.,SP.,H.,I.,T. :(F01/10/14/87/HS)
	BC	SP.,S.,Y.,S.,SLAH.,R.,E.,Q.,SP. 	     :(F01/10/14/87/HS)
	BC	K.,E.,Y.,SP.,T.,O.,SP.,R.,E.,T.,U.,R.,N.,SP.,T.,O.
	BC	SP.,L.,U.,DASH.,L.,U.,SP.,S.,C.,R.,E.,E.,N.,NL.
SNT52Y	EQ	.-SNT52E-2

	IF	JAPANESE
SNT52J	HS	0
	HC	SNT52Z
	BC	K.NL,K.US,K.UN,K.UA,K.UT,K.SP,K.5,K.2,K.SP,K.DASH,K.SP
	BC	K.US,K.UY,K.US,K.SLSH,K.UR,K.UE,K.UQ,K.KI,K.DASH,K.TE,K.DAK
	BC	K.SP,K.UL,K.UU,K.DASH,K.UL,K.UU,K.SE,K.TU,K.SO,K.DAK,K.KU
	BC	K.NO,K.SP,K.KA,K.DAK,K.ME,K.N,K.NI,K.MO,K.TO,K.DAK,K.RI,K.MA
	BC	K.SU,K.NL
SNT52Z	EQ	.-SNT52J-2
	EI

SNT52T	HS	0
	HC	SNT52E-PSEG
	IF	JAPANESE
	HC	SNT52J-PSEG
	EI


	EI	(TERMIF)


	IF	HOSTIF

:
:	PROMPT MESSAGES FOR LU.SVC ROUTINES
:

:	SNH50 -- <NL>SNAH 50 - COMMNAD UNRECOGNIZED<NL>
:	-----
SNH50E	HS	0
	HC	SNH50Y
	BC	NL.,S.,N.,A.,H.,SP.,N5.,N0.,SP.,DASH.,C.,O.,M.,M.,A.
	BC	N.,D.,SP.,U.,N.,R.,E.,C.,O.,G.,N.,I.,Z.,E.,D.,NL.
SNH50Y	EQ	.-SNH50E-2

	IF	JAPANESE
SNH50J	HS	0
	HC	SNH50Z
	BC	K.NL,K.US,K.UN,K.UA,K.UH,K.SP,K.5,K.0,K.SP,K.DASH,K.SP
	BC	K.KO,K.MA,K.N,K.TO,K.DAK,K.KA,K.DAK,K.SP,K.MA,K.TI,K.KA
	BC	K.DAK,K.TU.,K.TE,K.O,K.RI,K.MA,K.SU,K.NL
SNH50Z	EQ	.-SNH50J-2
	EI

SNH50T	HS	0
	HC	SNH50E-PSEG
	IF	JAPANESE
	HC	SNH50J-PSEG
	EI

	EI	(HOSTIF)

	EM
   
	IF	TERMIF

	SUBTTL	(SNA) MESSAGES AND SCREENS FORMAT
:SCRN00.F00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	01/17/86 (CHS) -- RE-DESGIN AND CODE FOR SNA/XNA
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	LIST	-X,-R
	RA	0

	MO	.,MAIN
	LO	MAIN

	SEG	A.CODE

:
:	DEFINE MESSAGE(SCREEN) ELEMENT TYPES
:
METP0	EQ	0			:0 - COPY NEXT 1 BYTE
METP1	EQ	1			:1 - WCC(CB0)
METP2	EQ	2			:2 - CB2S
METP3	EQ	3			:3 - ATTRIBUTE
METP4	EQ	4			:4 - TIF MSG HEADER #
METP5	EQ	5			:5 - ROW, COLUMN (2 BYTES)
METP6	EQ	6			:6 - (ROW, COLUMN) POINTER (2 BYTES)
METP7	EQ	7			:7 - MSG TABLE POINTER (2 BYTES)
METP8	EQ	8			:8 - MSG TABLE POINTER IN A.DATA SEG.
METP9	EQ	9			:9 - END

:
:	DEFINE INDEX FOR ATTRIBUTES
:
UADAT	EQ	00			:ATUAD(40) - UNPROCT,ALPHA,DISP
UAIAT	EQ	01			:ATUAI(C8) - UNPROCT,ALPHA,INTENSE
UANAT	EQ	02			:ATUAN(4C) - UNPROCT,ALPHA,NON-DISP
UADMAT	EQ	03			:ATUADM(C1) - UNPROT,ALPHA,DISP,MDT
UANMAT	EQ	04			:ATUANM(4D) - UNPROT,ALPHA,NON-DISP,MDT
UAIMAT	EQ	05			:ATUAIM(C9) - UNPROT,ALPHA,INTENSE,MDT
UNIAT	EQ	06			:ATUNI(D8) - UNPROT,NUMBERIC,INTENSE
PNNAT	EQ	07			:ATPNN(7C) - PROCT,NUMERIC,NON-DISP
PNDAT	EQ	08			:ATPND(F0) - PROCT,NUMBERIC,DISP
PNIAT	EQ	09			:ATPNI(F8) - PROCT,NUMERIC,INTENSE
PADAT	EQ	0A			:ATPAD(60) - PROCT,ALPHA,DISP
PAIAT	EQ	0B			:ATPAI(F8) - PROCT,ALPHA,INTENSE
 
:	IFATTR:	IBM/FUJITSU ATTRIBUTES
:	------
IFATTR	HS	0
	BC	ATUAD,ATUAI,ATUAN,ATUADM
	BC	ATUANM,ATUAIM,ATUNI,ATPNN
	BC	ATPND,ATPNI,ATPAD,ATPAI

:	HIATTR:	HITACHI ATTRIBUTES
:	------
HIATTR	HS	0
	HC	HAUAD,HAUAI,HAUAN,HAUADM
	HC	HAUANM,HAUAIM,HAUNI,HAPNN
	HC	HAPND,HAPNI,HAPAD,HAPAI


:	ERASCN:	ERASE WHOLE SCREEN
:	------
ERASCN
	BC	METP0,EWCMD		:EWCMD
	BC	METP2,WCCN		:WCCN
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,0,0		:SBAC(0,0)
	BC	METP0,IC.		:IC.
	BC	METP9,0

:
:	LOGON DATA/ERROR MSGS
:

:	LEM1 - TYPE USERNAME
:	----
LEM1
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,2,1		:SBAC(2,1)
	BC	METP4,1			:SNAT 001
	BC	METP7,0
	HC	LEM1T-PSEG		:TYPE USERNAME
	BC	METP0,RA.		:RA.
	BC	METP5,0,2,$A79		:SBAC(2,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	LFAUSR-PSEG		:LFAUSR FIELD
	BC	METP0,IC.		:IC.
	BC	METP9,0

:	LEM2 - TYPE PASSWORD
:	----
LEM2
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,2,1		:SBAC(2,1)
	BC	METP4,2			:SNAT 002
	BC	METP7,0
	HC	LEM2T-PSEG		:TYPE PASSWORD
	BC	METP0,RA.		:RA.
	BC	METP5,0,2,$A79		:SBAC(2,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	LFAPWD-PSEG		:LFAPWD FIELD
	BC	METP0,IC.		:IC.
	BC	METP9,0			:

:	LEM3 - LOGON IN PROGRESS
:	----
LEM3
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,3			:SNAT 003
	BC	METP7,0
	HC	LEM3T-PSEG		:LOGON IN PROGRESS
	BC	METP0,RA.		:RA.
	BC	METP5,0,2,$A79		:SBAC(2,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP5,0,2,1		:SBAC(2,1)
	BC	METP0,RA.		:RA.
	BC	METP5,0,2,$A79		:SBAC(2,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM4 - LOGON FAILED
:	----
LEM4
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAKM		:WCCAKM
	BC	METP0,EAU.		:EAU.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,4			:SNAT 004
	BC	METP7,0
	HC	LEM4T-PSEG		:LOGON FAILED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:
:	LOGON ERROR MSGS FOR PRESET LOGON
:

:	LEM5 - USERNAME ERROR DURING PRESET LOGON
:	----
LEM5
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,5			:SNAT 005
	BC	METP7,0
	HC	LEM5T-PSEG		:USERNAME ERROR DURING PRESET LOGON
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM6 - PASSWORD ERROR DURING PRESET LOGON
:	----
LEM6
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,6			:SNAT 005
	BC	METP7,0
	HC	LEM6T-PSEG		:PASSWORD ERROR DURING PRESET LOGON
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM7 - BAD STORED DSP ELEMENT - ABORTED
:	----
LEM7
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,7			:SNAT 007
	BC	METP7,0
	HC	LEM7T-PSEG		:BAD STORED DSP ELEMENT - ABORTED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM8 - PLEASE SEE YOUR REP...
:	----
LEM8
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,8			:SNAT 008
	BC	METP7,0
	HC	LEM8T-PSEG		:PLEASE SEE YOUR REP...
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM9 - BAD MUD
:	----
LEM9
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,9			:SNAT 009
	BC	METP7,0
	HC	LEM9T-PSEG		:BAD MUD
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM0A - CIRCUIT BUSY
:	----
LEM0A
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,0A		:SNAT 00A
	BC	METP7,0
	HC	LEM0AT-PSEG		:CIRCUIT BUSY
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM0B - HOST NOT AVAILABLE
:	----
LEM0B
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,0B		:SNAT 00B
	BC	METP7,0
	HC	LEM0BT-PSEG		:HOST NOT AVAILABLE
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM0C - HOST OUT OF PORTS
:	----
LEM0C
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,0C		:SNAT 00C
	BC	METP7,0
	HC	LEM0CT-PSEG		:HOST OUT OF PORTS
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM0D - HOST DOWN
:	----
LEM0D
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,0D		:SNAT 00D
	BC	METP7,0
	HC	LEM0DT-PSEG		:HOST DOWN
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM0E - HOST  SHUT
:	----
LEM0E
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,0E		:SNAT 00E
	BC	METP7,0
	HC	LEM0ET-PSEG		:HOST SHUT
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM0F - TRY AGAIN IN 2 MINUTES
:	----
LEM0F
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,0F		:SNAT 00F
	BC	METP7,0
	HC	LEM0FT-PSEG		:TRY AGAIN IN 2 MINUTES
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM10 - ACCESS NOT PERMITTED
:	----
LEM10
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,10		:SNAT 010
	BC	METP7,0
	HC	LEM10T-PSEG		:ACCESS NOT PERMITTED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM11 - NO HOST SPECIFIED
:	----
LEM11
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,11		:SNAT 011
	BC	METP7,0
	HC	LEM11T-PSEG		:NO HOST SPECIFIED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM12 - BAD HOST NUMBER
:	----
LEM12
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,12		:SNAT 012
	BC	METP7,0
	HC	LEM12T-PSEG		:BAD HOST NUMBER
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM13 - MUD ERROR
:	----
LEM13
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,13		:SNAT 013
	BC	METP7,0
	HC	LEM13T-PSEG		:MUD ERROR
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM14 - CONNECTION IN PROGRESS
:	----
LEM14
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,14		:SNAT 014
	BC	METP7,0
	HC	LEM14T-PSEG		:CONNECTION IN PROGRESS
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM15 - CONNECTION FAILED
:	----
LEM15
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,15		:SNAT 015
	BC	METP7,0
	HC	LEM15T-PSEG		:CONNECTION FAILED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM16 - PROCEDURE ABORTED
:	----
LEM16
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,16		:SNAT 016
	BC	METP7,0
	HC	LEM16T-PSEG		:PROCEDURE ABORTED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP5,0,2,1	        :SBAC(2,1)
	BC	METP0,RA.		:RA.
	BC	METP5,0,2,$A79		:SBAC(2,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM17 - ERASE STATUS LINE
:	----
LEM17
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCN		:WCCN
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM18 - LOGON FAILED - NON SNA HOST
:	----
LEM18
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAKM		:WCCAKM
	BC	METP0,EAU.		:EAU.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,18		:SNAT 018
	BC	METP7,0
	HC	LEM18T-PSEG		:LOGON FAILED - NON SNA HOST
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM19 - PROCEDURE ABORTED
:		INPUT ERROR
:	----
LEM19
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCA		:WCCA
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,19		:SNAT 019
	BC	METP7,0
	HC	LEM16T-PSEG		:PROCEDURE ABORTED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP5,0,2,1	        :SBAC(2,1)
	BC	METP7,0
	HC	LEM19T-PSEG		:INPUT ERROR
	BC	METP0,RA.		:RA.
	BC	METP5,0,2,$A79		:SBAC(2,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:

:	LEM1A - CIRCUIT CLEARED
:	----
LEM1A
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAKM		:WCCAKM
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,1A		:SNAT 01A
	BC	METP7,0
	HC	LEM1AT-PSEG		:CIRCUIT CLEARED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.		:NULL.
	BC	METP9,0			:


:
:	INPUT ERROR MESSAGES FOR NETWORK SERVICE SREEEN
:

:	LEM20 - CRT IS CURRENTLY LOGGED IN
:	----
LEM20
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,20		:SNAT 020
	BC	METP7,0
	HC	LEM20T-PSEG		:CRT IS CURRENTLY LOGGED IN
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.		:IC.
	BC	METP9,0			:

:	LEM21 - CRT IS CURRENTLY NOT LOGGED IN
:	----
LEM21
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,21		:SNAT 021
	BC	METP7,0
	HC	LEM21T-PSEG		:CRT IS CURRENTLY NOT LOGGED IN
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.		:IC.
	BC	METP9,0			:

:	LEM22 - PRT IS CURRENTLY LOGGED IN
:	----
LEM22
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,22		:SNAT 022
	BC	METP7,0
	HC	LEM22T-PSEG		:PRT IS CURRENTLY LOGGED IN
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.		:IC.
	BC	METP9,0			:

:	LEM23 - PRT IS CURRENTLY NOT LOGGED IN
:	----
LEM23
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,23		:SNAT 023
	BC	METP7,0
	HC	LEM23T-PSEG		:PRT IS CURRENTLY NOT LOGGED IN
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.		:IC.
	BC	METP9,0			:


:
:	NETWORK SERVICES SCREEN
:
:		-------------------------------------------------------
:		|       NETWORK SERVICE SCREEN                        |
:		|                                                     |
:		|1. MANUAL LOGON - CRT                                |
:		|2. PRESET LOGON - CRT                                |
:		|3. MANUAL LOGON - PRINTER                            |
:		|4. PRESET LOGON - PRINTER                            |
:		|5. LOGOFF - CRT                                      |
:		|6. LOGOFF - PRINTER                                  |
:		|7. EXIT                                              |
:		|ENTER SELECTION: _                                   |
:		|                                                     |
:		|    (DEVICES STATUS)                                 |
:		|                                                     |
:		|------------------------------------------------------
:

:	NETSCN:	NETWORK SERVICE SCREEN  HEADLINE
:	-------
NETSCN
	BC	METP0,EWCMD		:EWCMD
	BC	METP2,WCCKM		:WCCKM
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,0,8		:SBAC(0,8)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP9,0			:

:	NNS01: NETSCN
:	-------
NNS01
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,0		:SBAC(1,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNIAT		:PNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,2,0		:SBAC(2,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNIAT		:PNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,2,$A79		:SBAC(2,$A79)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
:	NNS02:	1. MANUAL LOGON - CRT
:	------
NNS02
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,3,0		:SBAC(3,0)
	BC	METP7,0
	HC	NNS02T-PSEG		:1. MANUAL LOGON - CRT
:	NNS03:	2. PRESET LOGON - CRT
:	------
NNS03
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,4,0		:SBAC(4,0)
	BC	METP7,0
	HC	NNS03T-PSEG		:2. PRESET LOGON - CRT
	BC	METP9,0			:END OF 1ST SEGMENT

:	NNS04:	3. MANUAL LOGON - PRT
:	------
NNS04
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,5,0		:SBAC(5,0)
	BC	METP7,0
	HC	NNS04T-PSEG		:3. MANUAL LOGON - PRT
:	NNS05:	4. PRESET LOGON - PRT
:	------
NNS05
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,6,0		:SBAC(6,0)
	BC	METP7,0
	HC	NNS05T-PSEG		:5. PRESET LOGON - PRT
:	NNS06:	5. LOGOFF - CRT
:	------
NNS06
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,7,0		:SBAC(7,0)
	BC	METP7,0
	HC	NNS06T-PSEG		:5. LOGOFF - CRT
	BC	METP9,0			:END OF 2ND SEGMENT

:	NNS07:	6. LOGOFF - PRT
:	------
NNS07
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,8,0		:SBAC(8,0)
	BC	METP7,0
	HC	NNS07T-PSEG		:6. LOGOFF - PRT
:	NNS08:	7. EXIT
:	------
NNS08
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,9,0		:SBAC(9,0)
	BC	METP7,0
	HC	NNS08T-PSEG		:7. EXIT
:	NNS09:	ENTER SELECTION: _ , ENTER PRINTER #: _
:	------
NNS09
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,$A10,0		:SBAC($A10,0)
	BC	METP7,0
	HC	NNS09T-PSEG		:ENTER SLECTION: 
	BC	METP0,SF.		:SF.
	BC	METP3,UNIAT		:UNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	NETSF3-PSEG		:1 BYTE PASS INPUT FILED
	BC	METP0,SF.		:SF.
	BC	METP3,PADAT		:PADAT
	BC	METP7,0
	HC	NNSX9T-PSEG		:, ENTER PRINTER #:
	BC	METP0,SF.		:SF.
	BC	METP3,UNIAT		:UNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	NETSF4-PSEG		:2 BYTS PASS INPUT FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PADAT		:PADAT
	BC	METP9,0			:END OF 3RD SEGMENT

:	NNS0A:	DEVICES STATUS
:	------
NNS0A
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,$A12,0		:SBAC($A12,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PADAT		:PADAT
	BC	METP7,0
	HC	NNS0AT-PSEG		:DEVICES STATUS
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:CURSOR AT INPUT FIELD
	BC	METP0,IC.		:IC.
:	NNS0B - "LU NN CRT/PRT "
:	-----
NNS0B
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,$A13,0		:SBAC($A13,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PADAT		:PADAT
	BC	METP8,0
	HC	NNS0BT-PSEG		:LU  N CRT/PRT
	BC	METP0,SF.		:SF.
	BC	METP3,PNIAT		:PNIAT
	BC	METP9,0

:	NNS0C:	"DISCONNECTED FROM REMOTE"
:	------
NNS0C
	BC	METP7,0
	HC	NNS0CT-PSEG		:"DISCONNECTED FROM REMOTE"
	BC	METP9,0

:	NNS0D:	"CONNECTED TO REMOTE"
:	------
NNS0D
	BC	METP7,0
	HC	NNS0DT-PSEG		:"CONNECTED TO REMOTE"
	BC	METP9,0

:
:	BUFFER ADDRESSES FOR ANSWER NS SELECTION
:
:	NETSF1 = SBAC($A10,$A17)
:		SBAC($A10,$A13)
:	NETSF3 = SBAC($A10,$A18)
:		SBAC($A10,$A14)
:	NETSF2 = SBAC($A10,$A36)
:		SBAC($A10,$A44)
:	NETSF4 = SBAC($A10,$A38)
:		SBAC($A10,$A46)
:

:	NETSF1:	(ROW,COLUMN) FOR "ENTER SELCTION"
:	------
NETSF1
	BC	$A10,$A17
	BC	$A10,$A13

:	NETSF3:	(ROW,COLUMN) AFTER "ENTER SELCTION" FIELD
:	------
NETSF3
	BC	$A10,$A18
	BC	$A10,$A14

:	NETSF2:	(ROW,COLUMN) FOR "ENTER PRINTER#"
:	------
NETSF2
	BC	$A10,$A36
	BC	$A10,$A44

:	NETSF4:	(ROW,COLUMN) AFTER "ENTER PRINTER#" FIELD
:	------
NETSF4
	BC	$A10,$A38
	BC	$A10,$A46


:
:	ERROR MESSAGES FOR ANSWER NS SELECTION
:

:	NNSE1:	"WRONG KEY...,TRY AGAIN"
:	------
NNSE1
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC.(1,1)
	BC	METP4,30		:SNAT 030
	BC	METP7,0
	HC	NNSE1T-PSEG		:WRONG KEY...,TRY AGAIN
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.
	BC	METP9,0

:	NNSE2:	ERASE ERROR MSG AND RESET CURSOR POSITION
:	------
NNSE2
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC.(1,1)
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.
	BC	METP9,0

:	NNSE3:	"DEVICE NOT LOGGED IN"
:	------
NNSE3
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC.(1,1)
	BC	METP4,31		:SNAT 031
	BC	METP7,0
	HC	NNSE3T-PSEG		:DEVICE NOT LOGGED IN
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.
	BC	METP9,0

:	NNSE4:	"SOMEONE ELSE IS LOGGING PRINTER"
:	------
NNSE4
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC.(1,1)
	BC	METP4,32		:SNAT 032
	BC	METP7,0
	HC	NNSE4T-PSEG		:SOMEONE ELSE IS LOGGING PRT IN
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.
	BC	METP9,0

:	NNSE5:	"PRINTER IS ALREADY LOGGED IN"
:	------
NNSE5
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC.(1,1)
	BC	METP4,33		:SNAT 033
	BC	METP7,0
	HC	NNSE5T-PSEG		:PRINTER IS ALREADY LOGGED IN
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.
	BC	METP9,0

:	NNSE6:	"CRT NOT CONNECTED, EXIT NOT ALLOWED"
:	------
NNSE6
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC.(1,1)
	BC	METP4,34		:SNAT 034
	BC	METP7,0
	HC	NNSE6T-PSEG		:CRT NOT CONNECTED, EXIT NOT ALLOWED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.
	BC	METP9,0

:	NNSE7:	"FUNCTION NOT SUPPORTED YET"
:	------
NNSE7
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC.(1,1)
	BC	METP4,35		:SNAT 035
	BC	METP7,0
	HC	NNSE7T-PSEG		:FUNCTION NOT SUPPORTED YET
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	NETSF1-PSEG		:NETSF1 FIELD
	BC	METP0,IC.
	BC	METP9,0



:
:	LOGON SELECTION MENU SCREEN
:

:	LOGS1:	LOGON SELECTION HEADER
:	------
LOGS1
	BC	METP0,EWCMD		:EWCMD
	BC	METP2,WCCKM		:WCCKM
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,0,9		:SBAC(0,9)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP9,0

:	LOGS2:	LOGON SELECTION TERMINATING ATTRIBUTES
:	------
LOGS2
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,$A14,0		:SBAC($A14,0)
	BC	METP7,0
	HC	LOGS2T-PSEG		:ENTER SELECTION: 
	BC	METP0,SF.		:SF.
	BC	METP3,UNIAT		:UNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	LOGSF2-PSEG		:LOGSF2 FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PADAT		:PADAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,0		:SBAC(1,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNIAT		:PNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,2,0		:SBAC(2,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNIAT		:PNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,3,$A79		:SBAC(3,$A79)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	LOGSF1-PSEG		:LOGSF1 FIELD
	BC	METP0,IC.		:IC.
	BC	METP9,0

:	LOGSF1:	BUFFER ADDRESS TO ANSWER LOGON SELECTION
:	------
LOGSF1
	BC	$A14,$A17
	BC	$A14,$A13

:	LOGSF2:	BUFFER ADDRESS AFTER ANSWER LOGON SELECTION FIELD
:	------
LOGSF2
	BC	$A14,$A18
	BC	$A14,$A14



:
:	MANUAL LOGON SCREEN
:


:	MLGSCN - MANUAL LOGON SCREEN
:	------
MLGSCN
	BC	METP0,EWCMD		:EWCMD
	BC	METP2,WCCKM		:WCCKM
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,0,9		:SBAC(0,9)
	BC	METP7,0
	HC	MLGS1T-PSEG		:MANUAL  LOGON
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,0		:SBAC(1,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNIAT		:PNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,2,0		:SBAC(2,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNIAT		:PNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,4,0		:SBAC(4,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP7,0
	HC	MLGS2T-PSEG		:PLEASE LOGIN
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,5,1		:SBAC(5,1)
	BC	METP7,0
	HC	MLGS3T-PSEG		:USERNAME: 
	BC	METP0,SF.		:SF.
	BC	METP3,UAIMAT		:UAIMAT
	BC	METP0,IC.,METP0,SBA.	:IC.,SBA.
	BC	METP5,0,6,0		:SBAC(6,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP7,0
	HC	MLGS4T-PSEG		:PASSWORD:
	BC	METP0,SF.		:SF.
	BC	METP3,UANMAT		:UANMAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,7,0		:SBAC(7,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP9,0

:	MLGS1 - ERASE USERNAME FIELD
:	-----
MLGS1
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCN		:WCCN
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	LFAUSR-PSEG		:LFAUSR FIELD
	BC	METP0,IC.,METP0,NULL.	:IC.,NULL.
	BC	METP0,EAU.		:EAU.
	BC	METP6,0
	HC	LFAUSR-PSEG		:LFAUSR FIELD
	BC	METP0,IC.		:IC.
	BC	METP9,0

:
:	BUFFER ADDR CHARS OF USERNAME AND PASSWORD FIELDS
:
:	LFAUSR = SBAC(5,$A11)
:		SBAC(5,$A10)
:	LFAPWD = SBAC(6,$A11)
:		SBAC(6,$A10)

:	FLAUSR:	(ROW,COLUMN) FOR "USERNAME" FILED
:	------
LFAUSR
	BC	5,$A11
	BC	5,$A10

:	LFAPWD:	(ROW,COLUMN) FOR "PASSWORD" FILED
:	------
LFAPWD
	BC	6,$A11
	BC	6,$A10



:	DSP SCREEN
:
DSPSCN
	BC	METP0,EWCMD		:EWCMD
	BC	METP2,WCCKM		:WCCKM
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,0,4		:SBAC(0,4)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP7,0
	HC	DSPS1T-PSEG		:CONNECTION INFORMATION
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,0		:SBAC(1,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNIAT		:PNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,2,0		:SBAC(2,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNIAT		:PNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,3,0		:SBAC(3,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP7,0
	HC	DSPS2T-PSEG		:CONNECTION REQUEST MODE:
	BC	METP0,SF.		:SF.
	BC	METP3,UNIAT		:UNIAT
	BC	METP0,IC.,METP0,SBA.	:IC.,SBA.
	BC	METP6,0
	HC	DSPL1X-PSEG		:1 BYTE AFTER DSPL1 FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,4,1		:SBAC(4,1)
	BC	METP7,0
	HC	DSPS3T-PSEG		:DESTINATION INTERFACE ADDRESS:
	BC	METP0,SF.		:SF.
	BC	METP3,UNIAT		:UNIAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	DSPL2X-PSEG		:14 BYTES AFTER DSPL2 FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,5,1		:SBAC(5,1)
	BC	METP7,0
	HC	DSPS4T-PSEG		:APPLICATION IDENTIFIER:
	BC	METP0,SF.		:SF.
	BC	METP3,UAIAT		:UAIAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	DSPL3X-PSEG		:2 BYTES AFTER DSPL3 FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,6,1		:SBAC(6,1)
	BC	METP7,0
	HC	DSPS5T-PSEG		:DESTINATION CONTROL UNIT:
	BC	METP0,SF.		:SF.
	BC	METP3,UAIAT		:UAIAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	DSPL4X-PSEG		:2 BYTES AFTER DSPL4 FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,7,1		:SBAC(7,1)
	BC	METP7,0
	HC	DSPS6T-PSEG		:DESTINATION DEVICE ADDRESS:
	BC	METP0,SF.		:SF.
	BC	METP3,UAIAT		:UAIAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	DSPL5X-PSEG		:2 BYTES AFTER DSPL5 FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP9,0

:	DSPEXT: CHACTER SET SELECTION AND EXTENDED DSP SCREEN
:	--------
DSPEXT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,8,0		:SBAC(8,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP7,0
	HC	DSPSAT-PSEG		:CHARACTER SET(0/4/5-ENG/KATA/KANJI):
	BC	METP0,SF.		:SF.
	BC	METP3,UAIAT		:UAIAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	DSPL8X-PSEG		:1 BYTE AFTER DSPLA FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,9,0		:SBAC(9,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP7,0
	HC	DSPS7T-PSEG		:DO YOU WANT EXTENDED ATTRIBUTES?
	BC	METP0,SF.		:SF.
	BC	METP3,UAIAT		:UAIAT
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	DSPL6X-PSEG		:1 BYTE AFTER DSPL6 FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP9,0

:	DSPASC: DISPLAY QUESTION TO SELECT ASCII MODE
:	------
DSPASC
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCK		:WCCK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,$A10,0		:SBAC($A10,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP7,0
	HC	DSPS8T-PSEG		:DO YOU WISH TO USE ASCII MODE?
	BC	METP0,SF.		:SF.
	BC	METP3,UAIMAT		:UAIMAT
	BC	METP0,IC.		:IC.
	BC	METP0,SBA.		:SBA.
	BC	METP6,0
	HC	DSPL0X-PSEG		:1 BYTE AFTER DSP0 FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP9,0

:	DSPCOL: DISPLAY QUESTION TO SELECT COLOR
:	------
DSPCOL
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCK		:WCCK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,$A11,0		:SBAC($A11,0)
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP7,0
	HC	DSPS9T-PSEG		:DO YOU WANT COLOR?
	BC	METP0,SF.		:SF.
	BC	METP3,UAIMAT		:UAIMAT
	BC	METP0,IC.		:IC.
	BC	METP0,SBA.		:SBAC.
	BC	METP6,0
	HC	DSPL7X-PSEG		:1 BYTE AFTER DSP7 FIELD
	BC	METP0,SF.		:SF.
	BC	METP3,PNDAT		:PNDAT
	BC	METP9,0


:
:	BUFFER ADDRESS TO ANSWERS OF DSP SCREEN QUESTIONS
:
:	DSPL0 = SBAC($A10,$A32)
:		SBAC($A10,$A22)
:	DSPL1 = SBAC(3,$A26)
:		SBAC(3,$A25)
:	DSPL2 = SBAC(4,$A32)
:		SBAC(4,$A16)
:	DSPL3 = SBAC(5,$A25)
:		SBAC(5,$A14)
:	DSPL4 = SBAC(6,$A27)
:		SBAC(6,$A21)
:	DSPL5 = SBAC(7,$A29)
:		SBAC(7,$A22)
:	DSPL6 = SBAC(9,$A38)
:		SBAC(9,$A28)
:	DSPL7 = SBAC($A11,$A20)
:		SBAC($A11,$A18)
:	DSPL8 = SBAC(8,$A38)
:		SBAC(8,$A35)

:	DSPL0:	(ROW,COLUMN) FOR "DO YOU WISH ASICC"
:	-----
DSPL0
	BC	$A10,$A31
	BC	$A10,$A22

DSPL0X
	BC	$A10,$A32
	BC	$A10,$A23

:	DSPL1:	(ROW,COLUMN) FOR "CRM#"
:	-----
DSPL1
	BC	3,$A26
	BC	3,$A25

DSPL1X
	BC	3,$A27
	BC	3,$A26

:	DSPL2:	(ROW,COLUMN) FOR "DESTINATION INTERFACE ADDR"
:	------
DSPL2
	BC	4,$A32
	BC	4,$A16

DSPL2X
	BC	4,$A46
	BC	4,$A30

:	DSPL3:	(ROW,COLUMN) FOR "APPLICATION ID"
:	-----
DSPL3
	BC	5,$A25
	BC	5,$A15

DSPL3X
	BC	5,$A27
	BC	5,$A17

:	DSPL4:	(ROW,COLUMN) FOR "DESTINATION CUA"
:	-----
DSPL4
	BC	6,$A27
	BC	6,$A22

DSPL4X
	BC	6,$A29
	BC	6,$A24

:	DSPL5:	(ROW,COLUMN) FOR "DESTINATION DVA"
:	------
DSPL5
	BC	7,$A29
	BC	7,$A20

DSPL5X
	BC	7,$A31
	BC	7,$A22

:	DSPL6:	(ROW,COLUMN) FOR "EXTENDED ATTRIBUTES"
:	------
DSPL6
	BC	9,$A34
	BC	9,$A26

DSPL6X
	BC	9,$A35
	BC	9,$A27

:	DSPL7: (ROW,COLUMN) FOR FIELD "COLOR"
:	------
DSPL7
	BC	$A11,$A20
	BC	$A11,$A18

DSPL7X
	BC	$A11,$A21
	BC	$A11,$A19

:	DSPL8: (ROW,COLUMN) FOR "CHARACTER SET"
:	------
DSPL8
	BC	8,$A38
	BC	8,$A35

DSPL8X
	BC	8,$A39
	BC	8,$A36

:
:	ERROR MESSAGES FOR DATA ERROR FROM DSP SCREEN
:

:	FDSPE0:	ILLEGAL CRM #
:	------
FDSPE0
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,40		:SNAT 040
	BC	METP7,0
	HC	DSPE0T-PSEG		:ILLEGAL CRM NO.
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	DSPL1-PSEG		:DSPL1
	BC	METP0,IC.		:IC.
	BC	METP9,0

:	FDSPE1:	CRM 4 NOT SUPPORT
:	------
FDSPE1
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,41		:SNAT 041
	BC	METP7,0
	HC	DSPE1T-PSEG		:CRM 4 NOT SUPPORTED
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	DSPL1-PSEG		:DSPL1
	BC	METP0,IC.		:IC.
	BC	METP9,0

:	FDSPE2:	ILLEGAL INTERFACE ADDR
:	------
FDSPE2
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,42		:SNAT 042
	BC	METP7,0
	HC	DSPE2T-PSEG		:ILLEGAL INTERFACE ADDR
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	DSPL2-PSEG		:DSPL2
	BC	METP0,IC.		:IC.
	BC	METP9,0

:	FDSPE3:	ILLEGAL APPLID-ID
:	------
FDSPE3
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,43		:SNAT 043
	BC	METP7,0
	HC	DSPE3T-PSEG		:ILLEGAL APPL-ID
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	DSPL3-PSEG		:DSPL3
	BC	METP0,IC.		:IC.
	BC	METP9,0

:	FDSPE4:	ILLEGAL CONTROLLER ADDR
:	------
FDSPE4
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,44		:SNAT 044
	BC	METP7,0
	HC	DSPE4T-PSEG		:ILLEGAL CONTROLLER ADDR
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	DSPL4-PSEG		:DSPL4
	BC	METP0,IC.		:IC.
	BC	METP9,0

:	FDSPE5:	ILLEGAL DEVICE ADDR
:	------
FDSPE5
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,45		:SNAT 045
	BC	METP7,0
	HC	DSPE5T-PSEG		:ILLEGAL DEVICE ADDR
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	DSPL5-PSEG		:DSPL5
	BC	METP0,IC.		:IC.
	BC	METP9,0

:	FDSPE6:	ILLEGAL CHARACTER SET
:	------
FDSPE6
	BC	METP0,WCMD		:WCMD
	BC	METP1,WCCAK		:WCCAK
	BC	METP0,SBA.		:SBA.
	BC	METP5,0,1,1		:SBAC(1,1)
	BC	METP4,46		:SNAT 046
	BC	METP7,0
	HC	DSPE6T-PSEG		:ILLEGAL CHARACTER SET
	BC	METP0,RA.		:RA.
	BC	METP5,0,1,$A79		:SBAC(1,$A79)
	BC	METP0,NULL.,METP0,SBA.	:NULL.,SBA.
	BC	METP6,0
	HC	DSPL8-PSEG		:DSPL8
	BC	METP0,IC.		:IC.
	BC	METP9,0

	EM

	EI	(TERMIF)
	SUBTTL	(SNA) UTILITIES ROUTINES
:PTBQ00.Z00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and desgin for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	MO	.,BSUB

	LO	MAIN
	LO	GBLDEF
	LO	CMDLST
	LO	CBKDEF
	GL	PUCTAB,LUCTAB		:(01/27/87 YLH)

	SUBTTL (SNA) SNA RQ/RSP MESSAGE BUILDING UTILITIES


:	UTILITY ROUTINES TO BUILD MSGS IN BUFFERLET CHAINS
:	--------------------------------------------------
:
:	A) FOR DATA COMING FROM ISIS (USING DCBIBH,DCBIBA,DCBIBX, ETC.)
:	PTIBS - PUT A CANNED STRING INTO AN EXISTING BUF. CHAIN
:	PTIBC - PUT ONE CHAR INTO A BUF. CHAIN
:	PTIBH - START A MSG WHICH IS THE 1ST SEGMENT (PUT TH & RH INTO BUF.)
:	PTIBN - START A MSG WHICH IS NOT THE 1ST SEGMENT (PUT TH INTO BUF.)
:	SINPBB - START NEW INPUT BUF.
:	RINPBB - RELEASE INPUT BB CHAIN
:	GINPBB - GET 2ND NEW INPUT BB
:	PINDTA - QUEUE ISIS/INPUT DATA TO NWKC->SNA DATA-Q
:	PINDQ  - QUEUE ISIS/INPUT DQ TO NWKC->SNA DATA-Q
:
:	B) FOR MESSAGE BUILT LOCALLY (USING LUCIBH ONLY)
:	PTLBS - PUT A CANNED STRING INTO AN EXISTING BUF. CHAIN
:	PTLAS - PUT/CONVERT A CANNED STRING INTO AN EXISTING BUF. CHAIN
:	PTLBC - PUT ONE CHAR INTO A BUF. CHAIN
:	PTLBH - START A MSG WHICH IS THE 1ST SEGMENT (PUT TH & RH INTO BUF.)
:	PTLBN - START A MSG WHICH IS NOT THE 1ST SEGMENT (PUT TH INTO BUF.)
:	SLOCBB - START NEW INPUT BUF.
:	RLOCBB - RELEASE INPUT BB CHAIN
:	GLOCBB - GET 2ND NEW INPUT BB
:
:	C) MISCELLANEOUS ROUTINES
:	QDIFSN - QUEUE DATA/DQ TO NWKC->SNA DATA-Q
:	GETBC - GET NEXT CHAR FROM BUF. CHAIN
:
 
:	COMMON REGISTER USAGE
:	INPUT - R1 POINT TO THE HALF-WORD BYTE COUNT OF THE MEGS
:			FOR (PTIBM, PTIBS, PTLBM, PTLBS ROTUINES)
:		R0 CHAR TO BE ADDED TO MSG (FOR PTLBC ROTUINE)
:		RBBA CURRENT BB ADDRESS
:		RBBX CURRENT BB OFSET (INDEX)
:		RBCC PATITIAL BYTE COUNT
:	WORK -	R4,R7,R0
:	LINK -	R6
 
RBCC	EQ	R8
RBBA	EQ	R10
RBBX	EQ	R9
RDCB	EQ	R12
FID2LN	EQ	6
RHLEN	EQ	3

	SEG	A.DATA
IBSSAV	WS	1			:LINK REG. SAVE FOR PTIBS
IBCSAV	WS	1			:LINK REG. SAVE FOR PTIBC
IBHSAV	WS	1			:LINK REG. SAVE FOR PTIBH
BBISAV	WS	1			:LINK REG. SAVE FOR SINPBB, RINPBB
					: GINPBB , PINDTA, PINDQ, QDIFSN
LASSAV	WS	1			:LINK REG. SAVE FOR PTLAS
LBSSAV	WS	1			:LINK REG. SAVE FOR PTLBS
LBCSAV	WS	1			:LINK REG. SAVE FOR PTLBC
LBHSAV	WS	1			:LINK REG. SAVE FOR PTLBH
LBNSAV	WS	1			:LINK REG. SAVE FOR PTLBN
OS6SAV	WS	1			:LINK REG. FOR OUTPUT DATA/CMD-Q PROC
OS7SAV	WS	1			:LINK REG. FOR OUTPUT DATA/CMD-Q PROC
	SEG	A.CODE

	SUBTTL	(SNA) PTBQ - INPUT DATA BUFFER HANDLING ROUTINES


:	PTIBS - PUT A CANNED STRING INTO BUF.
:	-----
:	INPUT R1 AS FOR PTIBM
PTIBS
	ST	R6,IBSSAV,,		:SAVE R6
	LIS	R13,0
PTIBS1	LB	R0,2,R1,R13		:GET NEXT BYTE
	JAL	R6,PTIBC		:STORE IT
	AIS	R13,1			:ADVANCE INDEX
	CLH	R13,0,R1		:END OF STRING ?
	JLBS	PTIBS1			:N - REPEAT
	L	R6,IBSSAV,,		:RESTORE R6
	JR	R6
 
:	PTIBC - PUT ONE CHAR INTO BUF.
:	-----
PTIBC
	ST	R6,IBCSAV,,		:SAVE R6
	AIS	RBBX,1			:ADVANCE OFFSET
	STB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA, 
	JNFS	PTIBC1			:BB NOT FULL YET, SKIP
	JAL	R6,GINPBB		:ELSE, GET A NEW BB
PTIBC1
	AIS	RBCC,1			:INCREASE BYTE CNT
	L	R6,IBCSAV,,		:RESTORE R6
	JR	R6
 
:	PTIBH - START A MSG IN BUF. AND PUT TH & RH
:	------
:	OUTPUT:	RBBA, RBBX, RBCC SET
PTIBH
	ST	R6,IBHSAV,,		:SAVE R6
	JAL	R6,SINPBB		:GET FIRST BUFF.
	LIS	RBCC,FID2LN+RHLEN	:TH & RH LENGTH
	AR	RBBX,RBCC		:ADVANCE OFFSET
	L	R6,IBHSAV,,		:RESTORE R6
	JR	R6

:	SINPBB:	SETUP NEW INPUT BIG BUFFLET
:	-------
:	INPUT:	RDCB SETUP
:		R6 - LINK REGISTER
:	OUTPUT:	RBBA - NEW BB ADDR
:		DCBIBH, DCBIBA - NEW BB ADDR
:		DCBICC, DCBIBX - 0
:	DESTROYED: R0,R3,R4,R7
SINPBB
	ST	R6,BBISAV,,		:SAVE R6
	JAL	R4,GBB,,		:GET BUFFERLET
	J	PUTCR			:NO BUFFERLET AVAILABLE...SKIP
	IF	DEBUG
	JNFS	SINPB0
	LR	R3,R3
	JAL	R10,CRASH,,
SINPB0
	EI	(DEBUG)
	LHL	R4,DCBLKS+DCBLNC,RDCB,	:R4 = LNC OFFSET
	LHL	R6,DCBLKS+DCBPUC,RDCB,	:R6 = PUC OFFSET
	LCS	R0,1
	AHM	R0,LNCTAB+LNXBUS,R4,	:DECREASE BB QA BY 1 IN LNC
	AHM	R0,PUCTAB+PUXBUS,R6,	:DECREASE BB QA BY 1 IN PUC
	LR	RBBA,R3			:SET UP RBBA = NEW BB ADDR
	BBST	RBBA,DCBLKS+DCBIBH,RDCB,:STORE AS HEAD POINTER
	BBST	RBBA,DCBLKS+DCBIBA,RDCB,:STORE AS BASE ADDR 
	LHI	RBBX,-BBFLSZ+BBFPSZ-1	:INIT BUFFERLET INDEX POINTER
	LIS	RBCC,0			:SET RBCC TO 0
	STH	RBCC,DCBLKS+DCBICC,RDCB,:CLEAR INPUT CHAR COUNT DCBICC
	STH	RBBX,DCBLKS+DCBIBX,RDCB,:CLEAR INPUT CHAR INDEX DCBIBX
	L	R6,BBISAV,,
	JR	R6

	IF	VHRSUP
:	SINVHR :INIT REPLY RU FOR VHR
SINVHR	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET POINTER TO HEAD BUFFERLET
	LHI	R0,AIDENT		:GET ENTER AID
	STB	R0,BBUFER+FID2LN+RHLENG+VHRAID,R3,	:PUT IN THE BUFFER
	LHI	R0,FID2LN+RHLENG+VHRCDE+1	:POINT BEYOND ERRCDE
	STH	R0,DCBLKS+DCBALU,RDCB,	:UPDATE CHAR COUNTER
	STH	R0,DCBLKS+DCBIBX,RDCB,	:UPDATE BUFFER INDEX
	JR	R6			:AND RETURN
	EI

:	RINPBB:	RELEASE INPUT BUFFERLETS ROUTINE
:	------
:	INPUT:	RDCB SET UP
:		DCBIBH - HEAD ADDR OF BB CHAIN
:	OUTPUT:	BB'S IN THE CHAIN ARE RELEASED
:		DCBIBH, DCBICC, DCBIBX ARE CLEARED
:	DESTROYED: R0,R3,R4,R7
RINPBB
	ST	R6,BBISAV,,		:SAVE R6
	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET HEAD OF INPUT BUFFER CHAIN
	JE	RINPB2			:SKIP, IF EMPTY
RINPB1
	BBL	R10,BBUFER+BBFLSZ-BBFPSZ,R3,:GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE THIS BB
	LHL	R4,DCBLKS+DCBLNC,RDCB,	:R4 = LNC OFFSET
:	LHL	R6,DCBLKS+DCBLUC,RDCB,	:R6 = PUC OFFSET (02/22/85 MIA)
	LHL	R6,DCBLKS+DCBPUC,RDCB,	:R6 = PUC OFFSET (02/22/85 MIA)
	LIS	R0,1
	AHM	R0,LNCTAB+LNXBUS,R4,	:INCREASE BB QA BY 1 IN LNC
	AHM	R0,PUCTAB+PUXBUS,R6,	:INCREASE BB QA BY 1 IN PUC
	LR	R3,R10			:COPY NEXT BB ADDR TO R3
	JN	RINPB1			:IF NOT END, THEN LOOP
	LIS	R0,0			:SET R0 TO 0
	BBST	R0,DCBLKS+DCBIBH,RDCB,	:CLEAR BUFFER POINTER
	STH	R0,DCBLKS+DCBICC,RDCB,  :ZERO INPUT CHAR COUNT
RINPB2
	L	R6,BBISAV,,
	JR	R6			:RETURN

:	GINPBB: GET ANOTHER INPUT BUFFERLETS ROUTINE
:	-------
:	INPUT:	RDCB SET UP
:		R6 - LINK REGISTER
:	OUTPUT:	RBBA - NEW BB ADDR
:		RBBX - INIT INDEX
:	DESTROYED: R0,R3,R4,R7
GINPBB
	ST	R6,BBISAV,,		:SAVE R6
	JAL	R4,GBB,,		:GET BIG BUFFERLET
	J	PUTCR
	IF	DEBUG
	LR	R3,R3
	JNFS	GINPB0
	JAL	R10,CRASH,,
GINPB0
	EI	(DEBUG)
	LHL	R4,DCBLKS+DCBLNC,RDCB,	:R4 = LNC OFFSET
	LHL	R6,DCBLKS+DCBPUC,RDCB,	:R6 = PUC OFFSET
	LCS	R0,1
	AHM	R0,LNCTAB+LNXBUS,R4,	:DECREASE BB QA BY 1 IN LNC
	AHM	R0,PUCTAB+PUXBUS,R6,	:DECREASE BB QA BY 1 IN PUC
	LHL	R0,BBUFER+BBFLSZ-BBFPSZ,RBBA,:GET CHARS IN CHAIN AREA
	BBST	R3,BBUFER+BBFLSZ-BBFPSZ,RBBA,:CHAIN IT
	LR	RBBA,R3			:LOAD RBBA WITH NEW BB ADDR
	LHI	RBBX,-BBFLSZ+BBFPSZ	:INIT INDEX
	STH	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA:STORE CHAR IN NEW BUFFERLET
	L	R6,BBISAV,,
	JR	R6

:	PINDTA:	QUEUE ISIS/INPUT DATA TO NWKC->SNA DATA-Q
:	------
:	INPUT:	RDCB, DCBIBH SET UP
:		RBCC(R8) = BYTE COUNT
:		R6 = LINK REGISTER
:	OUTPUT:
:	DESTROYED: R0, R2, R3, R4, R7, R11
PINDTA
	LHI	R2,NSETEM^8		:E-T-E DATA
	LB	R0,DCBLKS+DCBSTA,RDCB,	:SEE IF AT E-T-E STATE(2/26/86/CHS)
	CLHI	R0,L.NATV		:.. SNA NATIVE E-T-E (2/26/86/CHS)
	JEFS	PINDT1			:YES, SKIP.. (2/26/86/CHS)
	CLHI	R0,L.BDSP		:.. BSC/CMT/DSP E-T-E (2/26/86/CHS)
	JEFS	PINDT1			:YES, SKIP ..(2/26/86/CHS)
	LHI	R2,NSINTM^8		:ELSE, MAY BE A CRM/MSG (2/26/86/CHS)
					: TREATED AS LOCAL MSG(2/26/86/CHS)
PINDT1
	BBL	R3,DCBLKS+DCBIBH,RDCB,	:R3 = BB HEAD PTR
	LB	R4,BBUFER,R3,		:GET TH 1ST BYTE
	SRHLS	R4,2			:GET THE SEGMENTATION INDICATOR
	NHI	R4,03			:MASK
	LB	R0,INVTBL,R4		:INVERSE
	OR	R2,R0			:MAKE THE WHOLE CMD
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	J	QDIFSN			:TO COMMON ROUTINE

INVTBL	BC	03,02,01,00

:	PINDQQ: QUEUE ISIS/INPUT DQ CMD TO NWKC->SNA DATA Q
:	-------
:	INPUT:	RDCB, DCBIBH SET UP
:		DCBDFG CONTAINS CONTROL SUB CMD
:		RBCC(R8) = BYTE COUNT (1 BYTE ONLY)
:		R6 = LINK REGISTER
:	OUTPUT:
:	DESTROYED: R0, R2, R3, R4, R7, R11
PINDQ
	LB	R2,DCBLKS+DCBDFG,RDCB,	:GET CONTROL SUB CMD
:	REMARK NEED TO ADJUST
	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET BB HEAD PTR
	J	QDIFSN			:TO COMMON ROUTINE

	SUBTTL	(SNA) PTBQ - LOCAL DATA BUFFER HANDLING ROUTINES


:	PTLBS - PUT A CANNED STRING INTO LOCAL BUF.
:	-----
:	INPUT R1 AS FOR PTLBM
PTLBS
	ST	R6,LBSSAV,,		:SAVE R6
	LIS	R13,0
PTLBS1	LB	R0,2,R1,R13		:GET NEXT BYTE
	JAL	R6,PTLBC		:STORE IT
	AIS	R13,1			:ADVANCE INDEX
	CLH	R13,0,R1		:END OF STRING ?
	JLBS	PTLBS1			:N - REPEAT
	L	R6,LBSSAV,,		:RESTORE R6
	JR	R6
 
:	PTLAS - PUT/CONVERT A CANNED STRING INTO LOCAL BUF.
:	-----
:	CONVERT THE ASC STRINGS INTO EBCDIC FORMAT
:	INPUT R1 AS FOR PTLBM
PTLAS
	ST	R6,LASSAV,,		:SAVE R6
	LIS	R13,0
PTLAS1	LB	R6,2,R1,R13		:GET NEXT BYTE
	NHI	R6,7F			:MASK OFF PARITY BIT
	LB	R0,ASCBCD,R6,		:GET EBCIDC CHAR
	JAL	R6,PTLBC		:STORE IT
	AIS	R13,1			:ADVANCE INDEX
	CLH	R13,0,R1		:END OF STRING ?
	JL	PTLAS1			:N - REPEAT
	L	R6,LASSAV,,		:RESTORE R6
	JR	R6
 
:	PTLBC - PUT ONE CHAR INTO LOCAL BUF.
:	-----
PTLBC
	ST	R6,LBCSAV,,		:SAVE R6
	AIS	RBBX,1			:ADVANCE OFFSET
	STB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA, 
	JNFS	PTLBC1			:BB NOT FULL YET, SKIP
	JAL	R6,GLOCBB		:ELSE, GET A NEW BB
PTLBC1
	AIS	RBCC,1			:INCREASE BYTE CNT
	L	R6,LBCSAV,,		:RESTORE R6
	JR	R6
 
:	PTLDH - START A MSG IN BUF. AND PUT TH & RH
:	------
:	OUTPUT:	RBBA, RBBX, RBCC SET
PTLBH
	ST	R6,LBHSAV,,		:SAVE R6
	JAL	R6,SLOCBB		:GET FIRST BUFF.
	LIS	RBCC,FID2LN+RHLEN	:TH & RH LENGTH
	AR	RBBX,RBCC		:ADVANCE OFFSET
	L	R6,LBHSAV,,		:RESTORE R6
	JR	R6

:	PTLBN - GET BUFFER TO START A NON-1ST SEGMENT MESSAGE
:	------
:	OUTPUT:	RBBA, RBBX, RBCC SET
:	USES	- R0,R4,R7
PTLBN
	ST	R6,LBNSAV,,		:SAVE R6
	JAL	R6,SLOCBB		:GET 1ST BUFF.
	LIS	RBCC,FID2LN		:RH ONLY
	AR	RBBX,RBCC		:ADVANCE OFFSET
	L	R6,LBNSAV,,		:RESTORE R6
	JR	R6
 
:	SLOCBB:	SETUP NEW LOCAL BIG BUFFLET
:	-------
:	INPUT:	R11 = LUCTAB OFFSET
:		R6 - LINK REGISTER
:	OUTPUT:	RBBA - NEW BB ADDR
:		LUCIBH - NEW BB ADDR
:	DESTROYED: R0,R3,R4,R7
SLOCBB
	ST	R6,BBISAV,,		:SAVE R6
	JAL	R4,GBB,,		:GET BUFFERLET
	J	PUTCR			:NO BUFFERLET AVAILABLE...SKIP
	IF	DEBUG
	JNFS	SLOCB0
	LR	R3,R3
	JAL	R10,CRASH,,
SLOCB0
	EI	(DEBUG)
	LHL	R4,LUCTAB+LUCLNC,R11,	:R4 = LNC OFFSET
	LHL	R6,LUCTAB+LUCPUC,R11,	:R6 = PUC OFFSET
	LCS	R0,1
	AHM	R0,LNCTAB+LNXBUS,R4,	:DECREASE BB QA BY 1 IN LNC
	AHM	R0,PUCTAB+PUXBUS,R6,	:DECREASE BB QA BY 1 IN PUC
	LR	RBBA,R3			:SET UP RBBA = NEW BB ADDR
	BBST	RBBA,LUCTAB+LUCIBH,R11,	:STORE AS HEAD POINTER
	LHI	RBBX,-BBFLSZ+BBFPSZ-1	:INIT BUFFERLET INDEX POINTER
	L	R6,BBISAV,,
	JR	R6

:	RLOCBB:	RELEASE LOCAL BUFFERLETS ROUTINE
:	------
:	INPUT:	R11 SET UP
:		LUCIBH - HEAD ADDR OF BB CHAIN
:	OUTPUT:	BB'S IN THE CHAIN ARE RELEASED
:		LUCIBH IS CLEARED
:	DESTROYED: R0,R3,R4,R7
RLOCBB
	ST	R6,BBISAV,,		:SAVE R6
	BBL	R3,LUCTAB+LUCIBH,R11,	:GET HEAD OF LOCAL BUFFER CHAIN
	JE	RLOCB2			:SKIP, IF EMPTY
RLOCB1
	BBL	R10,BBUFER+BBFLSZ-BBFPSZ,R3,:GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE THIS BB
	LHL	R4,LUCTAB+LUCLNC,R11,	:R4 = LNC OFFSET
	LHL	R6,LUCTAB+LUCPUC,R11,	:R6 = PUC OFFSET
	LIS	R0,1
	AHM	R0,LNCTAB+LNXBUS,R4,	:INCREASE BB QA BY 1 IN LNC
	AHM	R0,PUCTAB+PUXBUS,R6,	:INCREASE BB QA BY 1 IN PUC
	LR	R3,R10			:COPY NEXT BB ADDR TO R3
	JN	RLOCB1			:IF NOT END, THEN LOOP
	LIS	R0,0			:SET R0 TO 0
	BBST	R0,LUCTAB+LUCIBH,R11,	:CLEAR BUFFER POINTER
RLOCB2
	L	R6,BBISAV,,
	JR	R6			:RETURN

:	GLOCBB: GET ANOTHER LOCAL BUFFERLET ROUTINE
:	-------
:	INPUT:	R11 SET UP
:		R6 - LINK REGISTER
:	OUTPUT:	RBBA - NEW BB ADDR
:		RBBX - INIT INDEX
:	DESTROYED: R0,R3,R4,R7
GLOCBB
	ST	R6,BBISAV,,		:SAVE R6
	JAL	R4,GBB,,		:GET BIG BUFFERLET
	J	PUTCR
	IF	DEBUG
	LR	R3,R3
	JNFS	GLOCB0
	JAL	R10,CRASH,,
GLOCB0
	EI	(DEBUG)
	LHL	R4,LUCTAB+LUCLNC,R11,	:R4 = LNC OFFSET
	LHL	R6,LUCTAB+LUCPUC,R11,	:R6 = PUC OFFSET
	LCS	R0,1
	AHM	R0,LNCTAB+LNXBUS,R4,	:DECREASE BB QA BY 1 IN LNC
	AHM	R0,PUCTAB+PUXBUS,R6,	:DECREASE BB QA BY 1 IN PUC
	LHL	R0,BBUFER+BBFLSZ-BBFPSZ,RBBA,:GET CHARS IN CHAIN AREA
	BBST	R3,BBUFER+BBFLSZ-BBFPSZ,RBBA,:CHAIN IT
	LR	RBBA,R3			:LOAD RBBA WITH NEW BB ADDR
	LHI	RBBX,-BBFLSZ+BBFPSZ	:INIT INDEX
	STH	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA:STORE CHAR IN NEW BUFFERLET
	L	R6,BBISAV,,
	JR	R6

	SUBTTL	(SNA) PTBQ - INPUT DATA BUFFER HANDLING ROUTINES

:	QDIFSN:	QUEUE A DATA/DQ TO NWKC->SNA DATA Q
:	-------
:	INPUT:	R11 = LUCTAB
:		R2 = CMD & SUB CMD CODE
:		R3 = BB CHAIN HEADER ADDRESS
:		R8 = BYTE COUNT (E.G. CLLNG FIELD)
:		R6 = LINK REGISTER
:	OUTPUT:
:	DESTROYED: R0,R3,R4,R7,R11
QDIFSN
	ST	R6,BBISAV,,		:SAVE R6
	JAL	R4,GETCL,,		:GET A FREE LINK
	J	PUTCR			:NO AVAILABLE CMD CELL
	LHL	R4,LUCTAB+LUSNDP,R11,	:GET NWKC->SNA DATA Q PUT PTR
	STH	R2,CMDBLK+CLCMD,R4,	:PUT IN CMD & CMDS CODES
	STH	R8,CMDBLK+CLLNG,R4,	:PUT IN CLLNG FIELD
	BBST	R3,CMDBLK+CLARG,R4,	:PUT IN BB ADDR
	STH	RARG,CMDBLK+CLPTR,R4,	:LINK NEW ENTRY
	STH	RARG,LUCTAB+LUSNDP,R11,	:..
	STH	RARG,LUCTAB+LUSNDR,R11,	:GIVE IT TO SNA
	LHL	R0,LUCTAB+LUCT.N,R11,	:GET LUCTAB REL ID #
	SBT	R0,DPNWSN,,		:INDICATE NWKC->SNA DATA Q INPUT AVAIL
	L	R6,BBISAV,,
	JR	R6

:	QOPCMD/QUPCM1:	QUEUE A CMD TO NWKC->SNA CMD Q
:	------------
:	INPUT:	R12 = DBC/PUC, R11=LUC OFFSET
:		R2 = CMD & SUB CMD CODE
:	IF ENTER FROM QUECM1
:		R3 = BB CHAIN HEADER ADDRESS
:		R8 = BYTE COUNT (E.G. CLLNG FIELD)
:		R6 = LINK REGISTER
:	OUTPUT:
:	DESTROYED: R0,R3,R4,R7,R11
QOPCMD
	LIS	R3,0
	LIS	R8,0
QOPCM1
	ST	R6,BBISAV,,		:SAVE R6
	JAL	R4,GETCL,,		:GET A FREE LINK
	J	PUTCR			:NO AVAILABLE CMD CELL
	LHL	R4,LUCTAB+LUSNCP,R11,	:GET NWKC->SNA CMD Q PUT PTR
	STH	R2,CMDBLK+CLCMD,R4,	:PUT IN CMD & CMDS CODES
	STH	R8,CMDBLK+CLLNG,R4,	:PUT IN CLLNG FIELD
	BBST	R3,CMDBLK+CLARG,R4,	:PUT IN BB ADDR
	STH	RARG,CMDBLK+CLPTR,R4,	:LINK NEW ENTRY
	STH	RARG,LUCTAB+LUSNCP,R11,	:..
	STH	RARG,LUCTAB+LUSNCR,R11,	:GIVE IT TO SNA
	LHL	R0,LUCTAB+LUCT.N,R11,	:GET LUCTAB REL ID #
	SBT	R0,CPNWSN,,		:INDICATE NWKC->SNA CMD Q INPUT AVAIL
	L	R6,BBISAV,,
	JR	R6

:	GETBC - GET NEXT CHAR FROM BUF. CHAIN
:	-----
:	INPUT:	RBBA,RBBX
:	OUTPUT:	R0 = CHAR
:	LINK:	R4
GETBC	AIS	RBBX,1			:ADVANCE OFFSET
	JNFS	GETBC1			:SKIP IF NOT AT END OF BUF.
	BBL	RBBA,BBUFER+BBFLSZ-BBFPSZ,RBBA,	:GET ADD OF NEXT BUF.
	JE	GETCR			:IF ADVANCE TO NULL BUF.
	LHI	RBBX,-BBFLSZ+BBFPSZ	:INITIALIZE OFFSET
GETBC1	LB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBA,RBBX
					:GET THE CHAR
	JR	R4
 
:	GETCR:	CRASH IF ADVANCE INTO NULL BUFF
:	-----
GETCR	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	PUTCR:	CRASH HERE IF NO BUFFER IF AVAILABLE WHEN TRYING TO GET ONE
:	-----
PUTCR	JAL	R10,CRASH,,
        BC      0,0,0,99

	SUBTTL	(SNA-NOSC) NWKC/SNA OUTPUT SCANNER - MISC ROUTINES


:	PKOCMD:	PEEK OUTPUT CMD-Q CMD
:	------
:	INPUT:	R11 = LUCTAB, R6 = INK REG
:	OUTPUT:	R3 = CLARG DATA, R2 = CCC CODE
:		R0 = SCC CODE, R8 = CLLNG DATA
PKOCMD
	RBT	R2,CPSNNW,,		:DOUBLE CHECK THE QUEUE
	LHL	R4,LUCTAB+LUNWCG,R11,	:R8 = SNA->NWKC CMD-Q GET PTR
:	CLH	R4,LUCTAB+LUNWCP,R11,	:COMP WITH PUT PTR (01/09/85 MIA)
	LHL	R3,LUCTAB+LUNWCP,R11,	:GET PUT PTR (01/09/85 MIA)
	CR	R4,R3			:COMPARE POINTERS (01/09/85 MIA)
	JER	R6			:QUEUE EMPTR, NORMAL RETURN
	SBT	R2,CPSNNW,,		:ELSE, RESTORE CPSNNW
	BBL	R3,CMDBLK+CLARG,R4,	:GET CLARG DATA
	LB	R0,CMDBLK+CLCMDS,R4,	:GET SCC CODE
	LB	R2,CMDBLK+CLCMD,R4,	:GET CCC CODE
	LHL	R8,CMDBLK+CLLNG,R4,	:GET CLLNG DATA
	CLHI	R2,MXSNNW		:CMD O.K.
	JLE	4,R6			:YES, SKIP RETURN
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,0FF

:	GTOCMD:	GET OUTPUT CMD-Q CMD
:	-------
:	INPUT:
:		R11 = LUCTAB, R6 = LINK REG.
:	OUTPUT:
:		R3 = CLARG DATA
:		R2 = CCC CODE
:		R0 = SCC CODE
:		R8 = CLLNG DATA
GTOCMD
	ST	R6,OS6SAV,,		:SAVE R6
	LHL	R6,LUCTAB+LUNWCG,R11,	:GET GET PTR
:	CLH	R6,LUCTAB+LUNWCR,R11,	:COMP WITH RELEASE PTR (01/09/85 MIA)
	LHL	R3,LUCTAB+LUNWCR,R11,	:GET RELEASE PTR (01/09/85 MIA)
	CR	R6,R3			:COMPARE POINTERS (01/09/85 MIA)
	JNFS	GTOCM1			:QUEUE NOT EMPTY, SKIP
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,0FF
GTOCM1
	BBL	R3,CMDBLK+CLARG,R6,	:GET CLARG DATA
	LB	R0,CMDBLK+CLCMDS,R6,	:GET SCC CODE
	LB	R2,CMDBLK+CLCMD,R6,	:GET CCC CODE
	LHL	R8,CMDBLK+CLLNG,R6,	:GET CLLNG DATA
:	LHL	R7,CMDBLK+CLPTR,R6,	:ADVANCING AN EMPTY LST (01/09/85 MIA)
	LH	R7,CMDBLK+CLPTR,R6,	:ADVANCING EMPTY LIST? (01/09/85 MIA)
	JE	CLERR,,			:CRASH, IF SO
	STH	R7,LUCTAB+LUNWCG,R11,	:ADVANCE TO NEXT
:	LB	R1,LUCTAB+LUCT.N,R11,	:GET LU #(1/5/85/CHS)
	LHL	R1,LUCTAB+LUCT.N,R11,	:GET LU #(1/5/85/CHS)
	RBT	R1,CPSNNW,,		:ASSUME NO MORE OUTPUT DATA
	CLH	R7,LUCTAB+LUNWCR,R11,	:SEE IF MORE OUTPUT 
	JEFS	.+08			:SKIP, IF NONE
	SBT	R1,CPSNNW,,		:TURN PRESENT BIT ON
	JAL	R4,RELCL,,		:RELEASE THE OUTPUT DATA-CMD CELL
	L	R6,OS6SAV,,		:RESTORE R6
	JR	R6

:	PKODTA:	PEEK OUTPUT DATA-Q CMD
:	------
:	INPUT:	R11 = LUCTAB, R6 = INK REG
:	OUTPUT:	R3 = CLARG DATA, R2 = CCC CODE
:		R0 = SCC CODE, R8 = CLLNG DATA
PKODTA
	RBT	R2,DPSNNW,,		:DOUBLE CHECK THE QUEUE
	LHL	R4,LUCTAB+LUNWDG,R11,	:R8 = SNA->NWKC DATA-Q GET PTR
:	CLH	R4,LUCTAB+LUNWDP,R11,	:COMPARE WITH PUT PTR (01/09/85 MIA)
	LHL	R3,LUCTAB+LUNWDP,R11,	:GET PUT POINTER (01/09/85 MIA)
	CR	R4,R3			:COMPARE POINTERS (01/09/85 MIA)
	JER	R6			:QUEUE EMPTR, NORMAL RETURN
	SBT	R2,DPSNNW,,		:ELSE, RESTORE DPSNNW
	BBL	R3,CMDBLK+CLARG,R4,	:GET CLARG DATA
	LB	R0,CMDBLK+CLCMDS,R4,	:GET SCC CODE
	LB	R2,CMDBLK+CLCMD,R4,	:GET CCC CODE
	LHL	R8,CMDBLK+CLLNG,R4,	:GET CLLNG DATA
	LR	R4,R2			:MOVE R2 TO WORK REG R4
	NHI	R4,80			:A "CMD" OR "DATA"?
	JEFS	PKODT1			:DATA
	CLHI	R2,0FF			:IF > 0FF 
	JGFS	PKODT2			:ILLEGAL
	CLHI	R2,SNCMMX		:IF LESS THAN SNCCMMX
	JLFS	PKODT2			:ILLEGAL
	SHI	R2,(SNCMMX-SNDTMX-1)	:ADJUST IF A "CMD"
	J	4,R6			:SKIP RETURN
PKODT1
	CLHI	R2,SNDTMX		:WITHIN RANGE
	JLE	4,R6			:YES, RETURN SKIP
PKODT2
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,0FF

:	DLOCMD:	DELETE OUTPUT CMD QUEUE
:	------
:	INPUT:	R11 = LUCTAB, R6 = LINK REG.
:	SAME AS GTOCMD, SINCE CMD HAS NO BUFFER
DLOCMD	J	GTOCMD

:	GTODTA:	GET OUTPUT DATA QUEUE
:	-------
:	INPUT:
:		R11 = LUCTAB, R6 = LINK REG.
:	OUTPUT:
:		R3 = CLARG DATA
:		R2 = CCC CODE
:		R0 = SCC CODE
:		R8 = CLLNG DATA
GTODTA
	ST	R6,OS6SAV,,		:SAVE R6
	LHL	R6,LUCTAB+LUNWDG,R11,	:GET GET PTR
:	CLH	R6,LUCTAB+LUNWDR,R11,	:COMP WITH RELEASE PTR (01/09/85 MIA)
	LHL	R3,LUCTAB+LUNWDR,R11,	:GET RELEASE PTR (01/09/85 MIA)
	CR	R6,R3			:COMPARE POINTERS (01/09/85 MIA)
	JNFS	GTODT1			:QUEUE NOT EMPTY, SKIP
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,0FF
GTODT1
	BBL	R3,CMDBLK+CLARG,R6,	:GET CLARG DATA
	LB	R0,CMDBLK+CLCMDS,R6,	:GET SCC CODE
	LB	R2,CMDBLK+CLCMD,R6,	:GET CCC CODE
	LHL	R8,CMDBLK+CLLNG,R6,	:GET CLLNG DATA
:	LHL	R7,CMDBLK+CLPTR,R6,	:ADVANCING AN EMPTY LST (01/09/85 MIA)
	LH	R7,CMDBLK+CLPTR,R6,	:ADVANCING EMPTY LINST? (01/09/85 MIA)
	JE	CLERR,,			:CRASH, IF SO
	STH	R7,LUCTAB+LUNWDG,R11,	:ADVANCE TO NEXT
:	LB	R1,LUCTAB+LUCT.N,R11,	:GET LU #(1/4/85/CHS)
	LHL	R1,LUCTAB+LUCT.N,R11,	:GET LU #(1/4/85/CHS)
	RBT	R1,DPSNNW,,		:ASSUME NO MORE OUTPUT DATA
	CLH	R7,LUCTAB+LUNWDR,R11,	:SEE IF MORE OUTPUT 
	JEFS	.+08			:SKIP, IF NONE
	SBT	R1,DPSNNW,,		:TURN PRESENT BIT ON
	JAL	R4,RELCL,,		:RELEASE THE OUTPUT DATA-CMD CELL
	L	R6,OS6SAV,,		:RESTORE R6
	JR	R6

:	FLODTA: FLUSH OUTPUT DATA QUEUE
:	-------
:	INPUT:
:		R11 = LUCTAB, R7 = LINK REG.
:	OUTPUT:
FLODTA
	ST	R7,OS7SAV,,		:SAVE R7
FLODT1					:(5/13/85/CHS, REWRITE)
	LHL	R1,LUCTAB+LUCT.N,R11,	:(03/14/85 MIA) (5/20/85/CHS)
	TBT	R1,DPSNNW,,		:EMPTY???
	JEFS	FLODT2			:NO, SKIP TO EXIT
	JAL	R6,GTODTA
	JAL	R6,DLODBB
	JBS	FLODT1			:REPEAT
FLODT2
	L	R7,OS7SAV,,		:RESTORE R7
	JR	R7

:	DLODTA:	DELETE OUTPUT DATA QUEUE
:	-------
:	INPUT:
:		R11 = LUCTAB, R7 = LINK REG.
:	OUTPUT:
DLODTA
	ST	R7,OS7SAV,,		:SAVE R7
	JAL	R6,GTODTA
	JAL	R6,DLODBB
	L	R7,OS7SAV,,		:RESTORE R7
	JR	R7

:	DLODBB:	DELETE OUTPUT DATA BUFFER
:	-------
:	INPUT:
:		R11 = LUCTAB, R6 = LINK REG
:		R3 = BB HEAD
:	OUTPUT:
DLODBB
	LB	R1,LUCTAB+LUCPUN,R11,	:GET PU #
	LHL	R1,PUCPTR,R1,R1,	:R1 = PUCTAB
	LHL	R1,PUCTAB+PUCLNC,R1,	:R1 = LNCTAB
	LR	R3,R3			:DOUBLE CHECK
	JER	R6			:RETURN
	ST	R6,OS6SAV,,
DLODB1
	BBL	R10,BBUFER+BBFLSZ-BBFPSZ,R3,:GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE THIS BB
	LHL	R6,LUCTAB+LUCPUC,R11,	:R6 = PUC OFFSET
	LHL	R4,LUCTAB+LUCLNC,R11,	:R4 = LNC OFFSET
	LIS	R0,1
	AHM	R0,PUCTAB+PURBUS,R6,	:INCREASE BB USAGE BY 1 IN PUC
	AHM	R0,LNCTAB+LNRBUS,R4,	:INCREASE BB USAGE BY 1 IN LNC
	LR	R3,R10			:MOVE BB ADDR TO R3, AND SEE IF MORE
	JN	DLODB1			:MORE, LOOP
	L	R6,OS6SAV,,
	JR	R6			:ELSE, RETURN

	IF	VHRSUP
:	DTHBDR AND DTHUBR - SEND POSITIVE RESPONSE FOR LOGON/LOGOFF
:	REQUEST FOR SNA VHR FUNCTION.
DTHBDR	LHI	R2,NSFNLG^8!NSBDRP	:RESPONSE FOR LOGON REQUEST
	JFS	DTHUB1			:JUMP TO CONTINUE
DTHUBR	LHI	R2,NSSTLG^8!NSUBRP	:RESPONSE FOR LOGOFF REQUEST
DTHUB1	XR	R8,R8			:0 LENGTH
	XR	R3,R3			:NO BUFFERLETS
	J	QDIFSN			:QUEUE IT TO SNA DATA QUEUE

	EI	(VHRSUP)

	FO	CBKDEF

	EM

 	SUBTTL	(SNA-3270) SUBROUTINES FOR HANDLING 3270 DEVICE LOGON
:D32700.Z00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY -- 
:	02/29/84 (CHS) -- Original code and design for SNA Natvie Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	MO	.,BSUB
	LO	BSUB

:	GL	ISIEND				:(01/27/87 YLH)
	GL	ISIEND,PUCTAB,LUCTAB		:(01/27/87 YLH)
	GL	CENCRM				:(F00/02/09/87/DB)
	LO	GBLDEF
	LO	FRNTND
	LO	MAIN
	LO	CBKDEF

:
:	THIS FILE CONTAINS:
:		A. SUBROUTINES FOR HANDLING THE 3270 CRT DISPLAY
:		B. SUBROUTINES FOR HANDLING THE 3270 LOGON
:

:	DEFINE CONSTATNTS
:	-----------------
CRT.	EQ	SP.^18!C.^10!R.^8!T.
PRT.	EQ	SP.^18!P.^10!R.^8!T.
ON.	EQ	SP.^18!O.^10!N.^8!SP.
OFF.	EQ	SP.^18!O.^10!F.^8!F.

:	DEFINE 3270/DSP CRMS FOR CALL USER DATA FIELD
:	---------------------------------------------
CUDPID	EQ	0			:+0  - PROTOCOL ID
CUDSCU	EQ	CUDPID+1		:+1  - SOURCE CU ADDR
CUDSLU	EQ	CUDSCU+1		:+2  - SOURCE DEVICE (LU) ADDR
CUDCBT	EQ	CUDSLU+1		:+3  - CONTROL BYTE
CUDDIF	EQ	CUDCBT+1		:+4  - DEVICE INFORMATION
CUDCRM	EQ	CUDDIF+1		:+5  - CRM
CUDDDF	EQ	CUDCRM+1		:+6  - DESTINATION DESIGNATOR

:	CRM1:	FIXED CLASS CRM
:	---------------
CRM1AP	EQ	0			:APPLICATION IDENTIFIER

:	CRM2:	SPECIFIC CRM
:	--------------------
CRM2AP	EQ	0			:APPLICATION IDENTIFIER
CRM2DC	EQ	1			:DESTINATION CU ADDR
CRM2DD	EQ	2			:DESTINATION DEVICE (LU ) ADDR

:	CRM3:	NON-SPECIFIC CRM
:	------------------------
:	SAME AS CRM2
CRM3AP	EQ	CRM2AP
CRM3DC	EQ	CRM2DC
CRM3DD	EQ	CRM2DD

:	CRM4:	ASSOCIATED DEVICE CRM
:	------------------------------
CRM4B0	EQ	0			:ALWAYS 0
CRM4B1	EQ	1			:ALWAYS 0
CRM4DD	EQ	2			:DESTINATION DEVICE (LU) ADDR
					:(F00/02/10/87/DB/START) - CRM 4
CRMADR	EQ	3			:CU ADDR. & LU ADDR. - 2 BYTES
CRM4CB	EQ	5			:CRT CB PTR.- 2 BYTES
					:(F00/02/10/87/DB/END)

MAXCRM	EQ	4			:MAX TYPE OF CRM

:	CUDCBT:	CALL USER DATA CONTROL BYTE
:	------
CRUSAG	EQ	80			:BIT 0  - CIRCUIT REQUEST USAGE
					: 0 - ALL INFOR IN CALL RQ
					: 1 - FURTHER INFOR IN CIRCUIT RQ
SMUCRQ	EQ	40			:BIT 1  - SNGL./MUTI. USER CIRCUIT RQ
					: 0 - SINGLE USER CIRCUIT RQ
					: 1 - MULTIPLE USER CIRCUIT RQ
XPAREN	EQ	20			:BIT 2  - TRANSPARENT TEXT
					: 0 - NOT SUPPORT TRANSPARENT TEXT
					: 1 - SUPPORT TRANSPARENT TEXT
EADVRQ	EQ	10			:BIT 3  - EBCDIC/ASCII
					: 0 - FOR AN EBCDIC DEVICE
					: 1 - FOR AN ASCII DEVICE
DEVFSZ	EQ	0E			:BIT 4,5,6 - DEVICE FORMAT SIZE
					: 0 - 480 CHARS.
					: 1 - 960 CHARS.
					: 2 - 1920 CHARS.
					: 3 - 2560 CHARS.
					: 4 - 3440 CHARS.
					: 5 - 3564 CHARS.
					: 6,7 - RESERVED.
DVDPPR	EQ	01			:BIT 7  - DISPLAY OR PRINTER
					: 0 - FOR A DISPLAY DEVICE
					: 1 - FOR A PRINTER DEVICE

:	CUDDIF:	DEVICE & INFORMATION
:	------
					:BIT 0,1,2 - RESERVED
SNATIF	EQ	80			:BIT 0 - SNA EQUIPMENT (USED BY SNA ONLY)
SNASRQ	EQ	40			:BIT 1 - SNA DEV WITH SYS/RQ SUPPORT
ATTPRT	EQ	10			:BIT 3 - ATTACHED PRINTER
					: 0 - NO ATTACHED PRINTER
					: 1 - HAS ATTACHED PRINTER
DEVCOL	EQ	08			:BIT 4 - COLOR OPTION
					: 0 - NOT SUPPORT COLOR
					: 1 - SUPPORT COLOR
CHRSET	EQ	07			:BIT 5,6,7 - CHAR. SET
					: 0 - NONE
					: 1 - APL CAPABILITY
					: 2 - TEXT CAPABILITY
					: 3 - APL AND TEXT CAPABILITY
					: 4 - KATAKANA
					: 5 - KANJI

:	THE FOLLOWING DEFINITIONS ARE REQURED ONLY IF TIMEOUT BY PHYSICAL
:	TERMINAL IS SPECIFIED (01/15/85 MIA).
	IF	PHTIMO
:STRUCTURE OFF APPLICATION ID BYTE (2 HIGH BITS NOT USED).
:APP.US	EQ	60			:USERCLASS (07/10/85 MIA)
:APP.OV	EQ	40			:TIMEOUT OVERRIDE (07/10/85 MIA)
APP.US	EQ	30			:USERCLASS
APP.OV	EQ	10			:USERCLASS WITH TIMEOUT OVERRIDE
:OTHER USER CLASSES USE THE DEFAULT TIMEOUT.
APP.LW	EQ	08			:1-SPECIFIC LINE, 0-WILDCARD LINE
APP.LN	EQ	07			:LINE #
	EI

:END OF DEFINITIONS FOR TIMEOUT BY PHYSICAL TERMINAL (01/51/85 MIA)

:	DEFINE LOCAL STORAGES
:	-----------------------
	SEG	A.DATA
D0SAVE	WS	1
D1SAVE	WS	1
D2SAVE	WS	1			:(F00/02/05/87/DB)
D5SAVE	WS	1
D6SAVE	WS	1
D7SAVE	WS	1
D8SAVE	WS	1			:(F00/02/05/87/DB)
D9SAVE	WS	1			:(F00/02/05/87/DB)
DCSAVE	WS	1			:(F00/04/01/87/DB)
FT6SAV	WS	1
FLDADR	HS	1			:FIELD BBIO CODE ADDR
FLDIND	HS	1			:FIELD SERACH ENABLE IF > 0
CDIND	HS	1			:CHANGE DIRECTION INFOR
SGIND	HS	1			:SEGMENT INFOR (09/09/86/CHS)
PMLBSV	HS	1			:FOR PMLB ROUTINE
GWYRCD	HS	20			:31 BYTES

	SEG	A.CODE

	IF	VHRSUP
:	PTVHRH - CREATE 3270 WRITE HEDAER FOR VHR MESSAGES.
:PUT WCMD, WCC, SF AND SBA AFTER VHR HEADER.
PTVHRH	ST	R6,IBSSAV,,		:SAVE R6
	LHI	R0,WCMD			:GET WRITE CMD
	JAL	R6,PTIBC		:PUT IN THE BUFFER
	LHI	R0,WCCKM		:PREPARE WCC
	JAL	R6,PTIBC		:PUT IN THE BUFFER
	LHI	R0,SBA.			:PREPARE SBA
	JAL	R6,PTIBC		:PUT IN THE BUFFER
	LHI	R4,VHRLGR		:GET LOGON MSG ROW NUMBER
	LIS	R7,0			:COLUMN 0
	LHI	R0,$A80			:WIDTH 80
	JAL	R6,SBADDR		:CALCULATE SCREEN ADDRESS
	EXBR	R0,R0			:PREPARE 1ST BYTE OF ADDRESS
	JAL	R6,PTIBC		:PUT IN THE BUFFER
	EXBR	R0,R0			:SECOND BYTE OF ADDRESS
	JAL	R6,PTIBC		:PUT IN THE BUFFER
	LHI	R0,SF.			:START FIELD
	JAL	R6,PTIBC		:PUT IN THE BUFFER
	LHI	R0,ATPND		:FIELD ATTRIBUTE
	JAL	R6,PTIBC		:PUT IN THE BUFFER
	LIS	R6,7			:VHR HEADER HAS 7 BYTES
	AHM	R6,DCBLKS+DCBALU,RDCB,	:INCREASE MESSAGE COUNTER
	L	R6,IBSSAV,,		:RESTORE R6
	JR	R6			:AND RETURN

	EI	(VHRSUP)

:	SBADDR:	CALCULATE THE BUFFER ADDRESS INTO 3270 I/O CODE
:	------
:	INPUT:	R0 = ROW SIZE
:		R4 = ROW #
:		R7 = COLUMN #
:	OUTPUT:	R0 = 3270 I/O CODE
SBADDR
	MHR	R4,R0
	AR	R4,R7			:R4 = ABSOLUTE ADDR
	LR	R7,R4			:R7 = ABSOLUTE ADDR
	LB	R0,LUCTAB+LUCSYS,R11,	:SEE IF HITACHI
	CLHI	R0,HITACHI
	JE	SBADD1			:YES, SKIP
	NHI	R4,03F			:ONLY LAST 6 BITS
	NHI	R7,0FC0			:GET FISRT 6  BITS
	SRHLS	R7,6			:ADJUST
	LB	R0,BAIOIC,R7,		:GET THE BAIO OCDE FOR 1ST GRAPHIC
	EXBR	R0,R0			:SHIFT TO BECOME 1ST GRAPHIC CODE
	LB	R7,BAIOIC,R4,		:GET 2ND BAIO CODE
	OR	R0,R7			:MERGE THE 1ST AND 2ND BAIO CODES
	JR	R6			:RETURN
SBADD1
	NHI	R4,01F			:LAST 5 BITS ONLY
	OHI	R4,0E0			:TURN ON FIRST 3 BITS
	EXBR	R4,R4			:IT IS 1ST BYTE
	SRHLS	R7,5			:1ST 6 BITS, SHIFT TO PROPER POSITIONS.
	OHI	R7,0C0			:TURN ON FIRST 2 BITS
	LR	R0,R4
	OR	R0,R7			:R0
	JR	R6

	IF	TERMIF

:	FCSRAD:	FIND CURSOR ROW
:	-------
:	FIVEN CURSON ADDR, FIND THE ROW NUMBER
:	INPUT:	RBBA - ADDR OF THE RQ(RU) MSG BB (1ST SEGMENT)
:	OUTPUT:	R0 = ROW NUMBER
FCSRAD
:	(9/4/85/CHS) THE ORIGINAL ALGORITHM WAS COPIED FROM
:		BISYNC 3270 INTERFACE. IT DID NOT WORK PROPERLY.
:		THE CODE WAS RE-WRITTEN.
:
:	DELETION OF ORIGINAL CODE START FROM HERE
:	LB	R0,DCBLKS+DCBFST,RDCB,	:IS THIS A SMALL/LARGE SCREEN?
:	NHI	R0,DEVFSZ		:GET DEVICE FORMAT SIZE
:	CLHI	R0,C480
:	JE	FCSAD2			:SMALL, SKIP
:	LARGE SCREEN
:	LB	R4,BBUFER+FID2LN+RHLEN+2,RBBA, :GET 2ST BYTE OF CURSOR ADDR
:	NHI	R4,030			:NEED ONLY ESSENTIAL BITS
:	SRHLS	R4,4			:INDEX 0,1,2,3
:	LB	R0,BBUFER+FID2LN+RHLEN+1,RBBA, :GET 1ST BYTE OF CURSOR ADDR
:	NHI	R0,1F			:NEED ONLY ESSENTIAL BITS
:	SR	R0,R4			:GET GROUP HEADER
:	NHI	R0,1C			:OBTAIN GROUP #
:	THI	R0,10			:GROUP # 0,1,2,3,4,5
:	JEFS	FCSAD1			:SKIP, IF NOT GROUP # 5 OR 6
:	SIS	R0,4			:THEN DECREMENT BY 1
:FCSAD1
:	AR	R0,R4			:CALCULATE ROW #
:	AIS	R0,1			:R0 = ROW #
:	JR	R6
:	SMALL SCREEN
:FCSAD2
:	LB	R4,BBUFER+FID2LN+RHLEN+1,RBBA, :GET 1ST BYTE OF CURSOR ADDR
:	NHI	R4,0F			:NEED ONLY RIGHT NIBBLE
:	SLHLS	R4,1			:DOUBLE IT AS INDEX TO TABLE
:	LB	R0,BBUFER+FID2LN+RHLEN+2,RBBA, :GET 2ND BYTE OF CURSOR ADDR
:	NHI	R0,0F			:GET RIGHT NIBBLE
:	JEFS	FCSAD3			:IF 0,  THEN SKIP
:	AIS	R4,1			:ELSE, INCREMENT INDEX
:FCSAD3
:	LB	R0,SMSTBL,R4		:GET SMALL SCREEN CURSON ROW #
:	JR	R6
:	SMSTBL:	TABLE FOR ROW NUMBER OF SMALL SCREEN
:	------
:SMSTBL	BC	1,2,3,4,5,0,7,6,0,8,9,0A,0B,0C
:
:	(9/4/85/CHS) END OF DELETION
:
:	(9/4/85/CHS) START OF NEW CODE
	LB	R4,BBUFER+FID2LN+RHLEN+1,RBBA,
					:GET 1ST BYTE OF CURSOR ADDR
	NHI	R4,3F			:NEED ONLY ESSENTIAL BITS
	SRHLS	R4,6			:SHIFT INTO PROPER PLACE
	LB	R0,BBUFER+FID2LN+RHLEN+2,RBBA,
					:GET 2ND BYTE OF CURSOR ADDR
	NHI	R0,1F			:NEED ONLY ESSENTIAL BITS
	OR	R4,R0			:COMBINE TO GET BYTE ADDR
	LB	R3,DCBLKS+DCBFST,RDCB,	:CHECK SCREEN SIZE
	NHI	R3,DEVFSZ
	LHI	R0,$A40			:ASSUME SMALL SCREEN
	CLHI	R3,C480			:SMALL?
	JEFS	FCSAD1			:YES, SKIP
	LHI	R0,$A80			:ELSE, MUST BE LARGE SCREEN
FCSAD1
	LIS	R3,0			:CLEAR R3
	DR	R3,R0			:(BYTE-ADDR)/SIZE=ROW#
	LR	R0,R4			:R0=R4=ROW #
	JR	R6			:RETURN
:	(9/4/85/CHS) END OF NEW CODE

:	GETSC:	 TO GET NEXT CHAR IN STORED LOGON MODE
:	-----
:	EXPECT:	RBBA - ADDR TO ELEMENT OF LOGON STRING
:	RBBX - INDEX TO CHAR ALREADY ACCESSED
:	R0 - RETURNED ASCII CHAR
:	R6 - LINK
GETSC
	BBL	RBBA,DCBLKS+DCBLBA,RDCB,
	LHL	RBBX,DCBLKS+DCBLBX,RDCB,
	AIS	RBBX,1			:INCREMENT COUNT
	CLB	RBBX,PSEG,RBBA,		:IS ELEMENT COMPLETELY FINISHED?
	JLE	GETSC1			:NO, SKIP
	LIS	R0,1			:ELSE, RETURN "01" INDICATOR
	LR	R2,0
	JR	R6
GETSC1
	STH	RBBX,DCBLKS+DCBLBX,RDCB, :SAVE COUNT OF CHARS ALREADY ACCESSED
	LB	R0,PSEG,RBBA,RBBX	:GET NEXT CHAR
	LR	R4,R0
	NHI	R4,7F			:MASK OUT PARITY BIT
	LB	R2,ASCBCD,R4,		:CONVERT TO EBCDIC
	JR	R6

	EI	(TERMIF)

	IF	TERMIF!VHRSUP
:	NXTSC - GET NEXT ELEMENT FOR STORED LOGON
:	-----
:	CALLED WHEN NEW ELEMENT IS REQUIRED TO INSURE LOGON INTEGRITY
:	EXPECT:	SAME AS GETSC
:	R6 - LINK
NXTSC
	LB	R0,DCBLKS+DCBLLS,RDCB,	:MAKE SURE ELEMENTS EXIST
	AIS	R0,1
	CLB	R0,DCBLKS+DCBLLV,RDCB,
	JLFS	NXTSC2
	LIS	R0,1			:NO ELEMENT, RETURN "01"
	LR	R2,0
	JR	R6
NXTSC2
	STB	R0,DCBLKS+DCBLLS,RDCB,	:ADVANCE TO NEXT ELEMENT
	BBL	RBBA,DCBLKS+DCBLBA,RDCB,
	LHL	RBBX,DCBLKS+DCBLBX,RDCB,
	AR	RBBA,RBBX
	AIS	RBBA,1			:SET RBBA TO START OF NEXT ELEMENT
	BBST	RBBA,DCBLKS+DCBLBA,RDCB,
	LIS	RBBX,0			:INIT RBBX
	STH	RBBX,DCBLKS+DCBLBX,RDCB,
	JR	R6

	EI	(TERMIF!VHRSUP)

	IF	TERMIF
:	GETFB:	GET CHAR FROM LOGON DATA BB, SEARCH FIELD IF FLDIND>1
:	-----
:	R0 - RETURNED ASCII CHAR (=00, IF NO DATA)
:	R2 - RETURNED EBCDIC CHAR (=00, IF NO DATA)
:	RBBA,RBBX - POINTS TO BUFFER WITH CHAR
:	FLDADR - BBIO CODE ADDR TO BE MATCHED
:	FLDIND - IF > 1, FILED SERACH REQUIRED
:	R6 - LINK
GETFB
	LIS	R2,0
	LHL	R0,FLDIND,,
	STH	R2,FLDIND,,
	LR	R0,R0
	JE	GETFB4			:NO SEARCH REQUIRED
	LHI	RBBX,-BBFLSZ+BBFPSZ-1	:INIT OFFSET
	BBL	RBBA,DCBLKS+DCBLBA,RDCB,:SET UP RBBA
	LIS	RBCC,0
GETFB1
	JAL	R4,GETBC		:GET NEXT CHAR FROM BB
	AIS	RBCC,1
	CLHI	R0,SBA.			:SBA CHAR ?
	JN	GETFB2			:NO, SKIP
	JAL	R4,GETBC		:FOUND SBA., GET NEXT CHAR
	AIS	RBCC,1
	CLB	R0,FLDADR,,		:COMPARE 1ST CHAR
	JNFS	GETFB2			:NOT THE SAME, SKIP
	JAL	R4,GETBC		:ELSE GET 2ND CHAR
	AIS	RBCC,1
	CLB	R0,FLDADR+1,,		:COMPARE 2ND CHAR
	JEFS	GETFB4			:YES, SKIP
GETFB2
	CLB	RBCC,DCBLKS+DCBLLV,RDCB,:END OF BBS
	JN	GETFB1			:REPEAT
GETFB3
	LIS	R0,0			:SET R0 = R2 = NULL
	LR	R2,R0
	JR	R6			:RETURN
GETFB4
	CLB	RBCC,DCBLKS+DCBLLV,RDCB,
	JGEBS	GETFB3			:NO DATA, TO SET INDICATOR
	JAL	R4,GETBC		:GET CHAR
	AIS	RBCC,1
	LR	R2,R0
	LB	R0,BCDASC,R2,		:CONVERT TO ASCII
	JR	R6			:RETURN

	EI	(TERMIF)

	IF	VHRSUP
:LOGON MODE FETCH ROUTINE FOR VHR SVC MODE.
GETRFB	LIS	R2,0			:CLEAR THE REGISTER
	LHL	R0,FLDIND		:GET FIELD INDICATOR
	STH	R2,FLDIND		:CLEAR FIELD INDICATOR
	LR	R0,R0			:1ST CHARACTER IN THE FIELD?
	JE	GETRF2			:JUMP IF NOT
	BBL	RBBA,DCBLKS+DCBLBA,R12,	:GET POINTER TO HEAD BUFFER
	LHL	RBBX,DCBLKS+DCBLBX,R12,	:GET BYTE COUNT
	LR	RBCC,RBBX		:SAVE IT
GETRF1	SHI	RBBX,BBFLSZ-BBFPSZ	:THIS BUFFERLET?
	JLFS	GETRF2			:JUMP IF SO
	BBL	RBBA,BBUFER+BBFLSZ-BBFPSZ,RBBA,	:ADVANCE TO NEXT BUFFERLET
	JBS	GETRF1			:JUMP TO CONTINUE
GETRF2	LR	R4,RBCC			:COPY BYTE COUNT
	AIS	R4,1			:ICREASE BY 1
	CLB	R4,DCBLKS+DCBLLV,RDCB,	:END OF DATA?
	JGEFS	GETRF4			:JUMP IF SO
	JAL	R4,GETBC		:GET CHAR
	AIS	RBCC,1			:COUNT IT
	STH	RBCC,DCBLKS+DCBLBX,RDCB,	:SAVE NEW COUNTER
	LR	R2,R0			:COPY EBCDIC CHAR
	LB	R0,BCDASC,R2,		:CONVERT INTO ASCII
	JR	R6			:END RETURN

:END OF LOGON DATA.
GETRF4	LIS	R0,0			:EMULATE NULL
	LR	R2,R0			:EBCDIC NULL
	JR	R6			:AND RETURN
	EI	(VHRSUP)

	IF	TERMIF

	SUBTTL	(SNA-3270) SUBROUTINE TO BUILD MSGS

:
:	UTILITY ROUTINES TO BUILD MSGS
:
:	FOR MESSAGE BUILD LOCALLY (USING LUCIBH)
:	AND USING NEW SCREEN FORMATS
:

:	PMLB	:PUT A 'SPECIAL' CANNED STRING INTO BUFF
:	-----
:	INPUT -
:		R1 - POINT TO STRING.FORMAT
:		RBBA - CURRENT BB ADDRESS
:		RBBX - CURRENT BB OFFSET
:		RBCC - PARTIAL BYTE COUNT
:	WORK REGISTERS - R0,R4,R7
:	LINK - R6
PMLB
	ST	R6,PMLBSV,,		:
PMLB0
	LB	R6,0,R1			:FETCH MSG ELEMENT TYPE
	AIS	R1,1			:ADVANCE 1 BYTE
	SLHLS	R6,1			:MAKE HW INDEX
	LHL	R7,PMLBT,R6,		:GET MSG ELEMENT TYPE PROC ROUTINE
	J	PSEG,R7,,		:TO PROC THIS MSG ELEMENT

PMLBT
	HC	PMLB00-PSEG		:METP0 - COPY NEXT 1 BYTE
	HC	PMLB10-PSEG		:METP1 - WCC (CB0)
	HC	PMLB20-PSEG		:METP2 - CB2S
	HC	PMLB30-PSEG		:METP3 - ATTRIBUTE
	HC	PMLB40-PSEG		:METP4 - TIF MSG HEADER #
	HC	PMLB50-PSEG		:METP5 - ROW, COLUMN (2 BYTES)
	HC	PMLB60-PSEG		:METP6 - (R,C) POINTER (2 BYTES)
	HC	PMLB70-PSEG		:METP7 - MSG TABLE POINTER
	HC	PMLB80-PSEG		:METP8 - MSG TABLE POINTER
	HC	PMLB90-PSEG		:METP9 - END

:	PMLB00:	COPY NEXT 1 BYTE
:	------
PMLB00
	LB	R0,0,R1			:FETCH NEXT BYTE
	AIS	R1,1			:ADVANCE POINTER
	JAL	R6,PTLBC		:COPY
	J	PMLB0			:RETURN TO MAIN ROUTINE

:	PMLN10:	WCC (CB0)
:	------
:	CURRENTLY, SAME AS PMLB00
PMLB10
	J	PMLB00

:	PMLB20:	CB2S
:	------
:	IF HITACH, MAKE CB2S
PMLB20
	LB	R0,0,R1			:FETCH WCC
	AIS	R1,1			:ADVANCE POINTER
	LB	R6,LUCTAB+LUCSYS,R11,	:SEE IF HITACH
	CLHI	R6,HITACHI		:..
	JE	PMLB21			:YES, SKIP
	JAL	R6,PTLBC		:WRITE WCC
	J	PMLB0			:RETURN TO MAIN ROUTINE
PMLB21
	NHI	R0,0BF			:TURN OFF 2ND BIT
	JAL	R6,PTLBC		:WRITE CB2(0)
	LHI	R0,80			:SET UP CB2(1)
	JAL	R6,PTLBC		:WRITE CB2(1)
	J	PMLB0			:RETURN TO MAIN ROUTINE

:	PMLB30:	ATTRIBUTE
:	-------
:	FETCH ATTRIBUTE BYTE(BYTES) FROM PROPER TABLE
PMLB30
	LB	R7,0,R1			:GET ATTRIBUTE INDEX
	AIS	R1,1			:ADVANCE POINTER
	LB	R6,LUCTAB+LUCSYS,R11,	:SEE IF HITACHI
	CLHI	R6,HITACHI		:...
	JE	PMLB31			:YES, SKIP
	LB	R0,IFATTR,R7,		:GET ATTRIBUTE BYTE
	JAL	R6,PTLBC		:WRITE ATTR BYTE
	J	PMLB0			:RETURN TO MAIN ROUTINE
PMLB31
	LHL	R0,HIATTR,R7,R7		:GET ATTRIBUTE BYTES
	ST	R0,D0SAVE,,		:SAVE R0
	EXBR	R0,R0			:WRITE 1ST BYTE
	JAL	R6,PTLBC		:...
	L	R0,D0SAVE,,		:RESTORE R0
	JAL	R6,PTLBC		:...
	J	PMLB0			:RETURN TO MAIN ROUTINE

:	PMLB40:	TIF MSG HEADER #
:	-------
:	FORM "SNAT nn - "
PMLB40
	LB	R6,0,R1			:GET nn IN BINARY/HEX
	AIS	R1,1			:ADVANCE POINTER
	LR	R7,R6			:R7=R6
	NHI	R6,0F			:
	LB	R0,HEXBCD,R6,		:FETCH EBCDIC CODE
	STB	R0,SNATNN+8,,
	SRHLS	R7,4
	LB	R0,HEXBCD,R7,		:FETCH EBCDIC CODE
	STB	R0,SNATNN+7,,
	ST	R1,D1SAVE,,		:SAVE R1
	LA	R1,SNATNN,,		:R1 POINT TO SNATNN
	JAL	R6,PTLBS		:COPY EBCDIC STRING
	L	R1,D1SAVE,,		:RESTORE R1
	J	PMLB0			:RETURN TO MAIN ROUTINE
HEXBCD
	BC	N0.,N1.,N2.,N3.,N4.
	BC	N5.,N6.,N7.,N8.,N9.
	BC	A.,B.,C.,D.,E.,F.


:	PMLB50:	SBAC(ROW,COLUMN)
:	------
:	BYPASS  NEXT BYTE FIRST
PMLB50
	AIS	R1,1			:ADVANCE POINTER
	LHI	R0,$A80			:R0 = ROW SIZE
	LB	R4,0,R1			:R4 = ROW #
	AIS	R1,1			:ADVANCE POINTER
	LB	R7,0,R1			:R7 = COLUMN #
	AIS	R1,1			:ADVANCE POINTER
	JAL	R6,SBADDR		:R0 = SBAC CODE
	ST	R0,D0SAVE,,		:SAVE R0
	EXBR	R0,R0			:WRITE 1ST BYTE
	JAL	R6,PTLBC		:...
	L	R0,D0SAVE,,		:RESTORE R0
	JAL	R6,PTLBC		:
	J	PMLB0			:RETURN TO MAIN ROUTINE

:	PMLB60:	SBAC(ROW,COLUMN) POINTER
:	------
:	BYPASS  NEXT BYTE FIRST
PMLB60
	AIS	R1,1			:ADVANCE POINTER
	LHL	R7,0,R1			:GET (R,C) POINTER
	AIS	R1,2			:ADVANCE PTR TO PASS (R,C) PTR
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH, OR JAP
	NHI	R0,07			:ONLY LAST 3 BITS
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	PMLB61			:ENGLISH, SKIP
	LIS	R6,2			:ELSE, JAPANESE
PMLB61
	LB	R4,PSEG,R6,R7		:FETCH ROW
	LB	R7,PSEG+1,R6,R7		:FETCH COLUMN
	LHI	R0,$A80			:R0 = ROW SIZE
	JAL	R6,SBADDR		:R0 = SBAC CODE
	ST	R0,D0SAVE,,		:SAVE R0
	EXBR	R0,R0			:WRITE 1ST BYTE
	JAL	R6,PTLBC		:...
	L	R0,D0SAVE,,		:RESTORE R0
	JAL	R6,PTLBC		:
	J	PMLB0			:RETURN TO MAIN ROUTINE

:	PMLB70:	MSG TABLE POINTER
:	--------
:	IF ENGLISH VERSION, FETCH 1ST ENTRY
:	IF JAPANESE VERSION, FETCH 2ND ENTRY
PMLB70
	LIS	R4,0			:IT IS METP6
PMLB7X
	AIS	R1,1			:BY PASS NEXT BYTE
	LHL	R7,0,R1			:GET MSG TABLE POINTER
	AIS	R1,2			:ADVANCE PTR TO PASS MSG TBL PTR
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH, OR JAP
	NHI	R0,07			:ONLY LAST 3 BITS
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	PMLB71			:ENGLISH, SKIP
	LIS	R6,2			:ELSE, JAPANESE
PMLB71
	ST	R1,D1SAVE,,		:SAVE R1 FIRST
	LHL	R1,PSEG,R6,R7		:FETCH MSG TEXT POINTER
	LR	R4,R4			:METP6 OR METP7
	JNFS	PMLB72			:METP7, SKIP
	AI	R1,PSEG			:ABSOLUTE PTR
PMLB72
	JAL	R6,PTLBS		:COPY EBCDIC STRING
	L	R1,D1SAVE,,		:RESTORE R1
	J	PMLB0			:RETRUN TO MAIN ROUTINE

:	PMLB80: MSGTABLE POINTER
:	-------
:	SAME AS PMLB70, EXCEPT MEG TEXT IN A.DATA SEGMENT
PMLB80
	LIS	R4,1			:METP7
	J	PMLB7X			:TO COMMOM ROUTINE

:	PMLB90:	END OF MSG ELEMENTS
:	------
PMLB90
	L	R6,PMLBSV,,		:RESTORE R6
	JR	R6			:RETRUN TO CALLER
	

	SUBTTL	(SNA-3270) SUBROUTINES FOR HANDLING 3270 DEVICE LOGON


:	SNDNSS:	CREATE AND SEND NETWORK SERVICE SCREEN
:	-------
:	REMARK ****
SNDNSS
	ST	R6,D6SAVE,,		:SAVE R6
	ST	R7,D7SAVE,,		:SAVE R7
	JAL	R6,PTLBH		:START 1ST SEG.
	LA	R1,NETSCN		:PUT EW, ETC
	JAL	R6,PMLB
	LHL	R2,LUCTAB+LUCT.N,R11,
	LHI	R6,NSMLEN
	MHR	R2,R6			:CALCULATE NSM OFFSET
	LHL	R1,NSMTBL+2,R2,		:R1 = NSM HEADER
	AI	R1,PSEG			:R1 = ADDR OF NSM HEADER
	LHL	R0,NSMTBL,R2,		:GET MSG TEXT TYPE
	CLHI	R0,ASCII		:ASCII DATA
	JNFS	SNANS1			:NO, SKIP
	JAL	R6,PTLAS		:ASC->EBCIDC, AND PUT INTO LOCAL BB
	JFS	SNDNS2			:SKIP
SNANS1
	JAL	R6,PTLBS		:EBCDIC, PUT INTO LOCAL BB
SNDNS2
	LA	R1,NNS01		:PUT NEXT WHOLE CHUNK INTO BB
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTFS	:1ST RU
	LHL	R0,CDIND,,		:GET CHANGE DIRECTION INDICATOR
	OR	R2,R0
	LIS	R0,0
	STH	R0,CDIND,,		:RESET
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN		:GIVE IT TO SNA.LU.SVC
	JAL	R6,PTLBN		:NEXT RU SEGMENT
:	(5/27/86/CHS) REDUCE SIZE OF EACH RU SEGMENT
	LA	R1,NNS04		:PUT NEXT WHOLE CHUNK INTO BB
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTIS	:INTERMEDIATE RU SEGMENT
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN		:GIVE IT TO SNA.LU.SVC
	JAL	R6,PTLBN		:NEXT RU
	LA	R1,NNS07		:PUT NEXT WHOLE CHUNK INTO BB
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTIS	:INTERMEDIATE RU SEGMENT
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN		:GIVE IT TO SNA.LU.SVC
	JAL	R6,PTLBN		:NEXT RU SEGMENT
	LA	R1,NNS0A
	JAL	R6,PMLB
	LA	R4,NNS0BE,,		:ASSUME ENGLIGH VERSION
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF SUPPORT JAPANSES
	NHI	R0,07
	CLHI	R0,04
	JLFS	SNDNS3			:NO, SKIP
	IF	JAPANESE
	LA	R4,NNS0BJ,,		:FETCH JAPANSES
	EI	(JAPANESE)
SNDNS3
	LB	R2,LUCTAB+LUCADR,R11,	:R2 = LUC ADDR
	LIS	R6,0A
	LIS	R1,0
	DR	R1,R6			:R1= 3RD DIGIT
	LB	R0,BIDETB,R1		:R0 = 1ST DIGIT
	STB	R0,7,R4
	LIS	R1,0
	DR	R1,R6			:R1 = 2ND DIGIT
	LB	R0,BIDETB,R1
	STB	R0,6,R4
	LB	R0,BIDETB,R2
	STB	R0,5,R4
	LB	R0,LUCTAB+LUCFST,R11,
	LI	R6,CRT.			:ASSUME CRT
	NHI	R0,01			:CRT/PRT?
	JEFS	SNDNS4
	LI	R6,PRT.			:ELSE, IT IS PRT
SNDNS4
	ST	R6,8,R4			:MUST BE AT HW ****
	LA	R1,NNS0B
	JAL	R6,PMLB
	LA	R1,NNS0D		:ASSUME CONNECTED
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	LB	R0,DCBLKS+DCBSTA,R12,	:R0 = CRT STATE
	CLHI	R0,L.NATV		:CHECKING
	JGE	SNDNS5			:CONNECTED, SKIP
	LA	R1,NNS0C		:ELSE, DISCONNECTED
SNDNS5
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTLS
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN
	L	R7,D7SAVE,,
	L	R6,D6SAVE,,
	JR	R6

:	BIDETB:	BINARY TO EBCDIC DECIMAL CONVERSION
:	------
BIDETB	BC	N0.,N1.,N2.,N3.,N4.
	BC	N5.,N6.,N7.,N8.,N9.


SNDLGS
:	SNDLGS:	CREATE AND SEND LOGON SELECTION MENU SCREEN
:	-------
:	LINK ON R6
SNDLGS
	ST	R5,D5SAVE,,		:SAVE R5
	ST	R6,D6SAVE,,		:SAVE R6
	ST	R7,D7SAVE,,		:SAVE R7
	JAL	R6,PTLBH		:START A 1ST SEG. AT LOC BB
	LA	R1,LOGS1		:PUT INTO 1ST PIECE
	JAL	R6,PMLB
	LHL	R2,LUCTAB+LUCT.N,R11,
	SLHLS	R2,3			:R2=LUCT.N*8
	LHL	R5,PSTTBL+4,R2,		:R8 = PSDTBL OFFSET
	LB	R0,PSTTBL+6,R2,		:R0 = TOTAL # OF PSD ENTRIES
	STB	R0,DCBLKS+DCBLLV,R12,	:SAVE INTO DCB
	LHL	R1,PSTTBL+2,R2,		:R1 = LG SELC HEADER STRING ADDR OFFSET
	AI	R1,PSEG			:R1 = ADDR
	LHL	R0,PSTTBL,R2,		:GET LG SELC TEXT TYPE
	CLHI	R0,ASCII		:ASCII?
	JNFS	SNDLG0			:NO, SKIP
	JAL	R6,PTLAS		:PUT LG SLEC HEAD INTO BB
	JFS	SNDLG1
SNDLG0
	JAL	R6,PTLBS		:COPY EBCDIC STRING
SNDLG1
	AI	R5,PSEG			:R5 = PSDTBL ADDR
	LHI	R0,NSDTCD		:CHANGE DIRECTION
	STH	R0,CDIND,,
	LHI	R0,NSDTFS		:FIRST SEGMENT
	STH	R0,SGIND,,
SNDLG2
	LHI	R0,SBA.
	JAL	R6,PTLBC
	LB	R4,0,R5			:R0 = ENTRY
	AIS	R4,4			:ADJUST
	LIS	R7,0			:COLUMN 0
	LHI	R0,$A80			:ROW SIZE, TEMPORY
	JAL	R6,SBADDR		:CONVET TO BF IO CODE
	ST	R0,D0SAVE,,		:SAVE R0
	EXBR	R0,R0
	JAL	R6,PTLBC
	L	R0,D0SAVE,,		:RESTORE R0
	JAL	R6,PTLBC
	LB	R0,0,R5			:GET ENTRY AGAIN
	AIS	R0,1			:START FROM 1.
	OHI	R0,0F0			:CONVERT INTO EBCDIC
	JAL	R6,PTLBC
	LHI	R0,DOT.
	JAL	R6,PTLBC
	LHI	R0,SP.
	JAL	R6,PTLBC
	LHL	R1,PSTPRM,R5		:R1 = PROPT MESSAGE OFFSET
	AI	R1,PSEG			:R1 = PROPT MSG ADDR
	LHL	R6,LUCTAB+LUCLNC,R11,	:R6 = LNCTAB
	LHL	R6,LNCTAB+LNMXFM,R6,	:R6 = MAX FRAME SIZE
	LHL	R0,0,R1			:R0 = PROMPT MESSAGE LENGTH
	AR	R0,R8			:POSSIBLE RU SEG SIZE
	SIS	R6,2			:ADDR, CNTL
	CR	R0,R6			:OVERFLOW?
	JG	SNDLG6			:YES, SKIP
SNDLG3
	LHL	R0,PSTAEC,R5		:GET PROMPT TEXT TYPE
	CLHI	R0,ASCII		:ASCII>
	JNFS	SNDLG4			:NO, SKIP
	JAL	R6,PTLAS
	JFS	SNDLG5
SNDLG4
	JAL	R6,PTLBS		:COPY EBCDIC STRING
SNDLG5
	LB	R0,DCBLKS+DCBLLV,R12,
	SIS	R0,1
	CLB	R0,0,R5			:ALL DONE?
	JLE	SNDLG7			:YES, SKIP
	AHI	R5,PSTLEN		:NEXT ENTRY
	J	SNDLG2			:REPEAT
SNDLG6
	LHI	R2,NSINTM^8
	LHL	R0,CDIND,,
	OR	R2,R0
	LHL	R0,SGIND,,
	OR	R2,R0
	LIS	R0,0
	STH	R0,CDIND,,
	STH	R0,SGIND,,
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN
	ST	R1,D1SAVE,,
	JAL	R6,PTLBN		:NEXT RU
	L	R1,D1SAVE,,
	J	SNDLG3			:TO CONTINUE
SNDLG7
	LHL	R6,LUCTAB+LUCLNC,R11,	:R6 = LNCTAB
	LHL	R6,LNCTAB+LNMXFM,R6,	:R6 = MAX FRAME SIZE
	LHI	R0,32			:R0 = FINI LOG SEL MSG LENGTH
	AR	R0,R8			:POSSIBLE RU SEG SIZE
	SIS	R6,2			:ADDR, CNTL
	CR	R0,R6			:OVERFLOW?
	JLE	SNDLG8			:NO, TO OCNTINUE
	LHI	R2,NSINTM^8
	LHL	R0,CDIND,,
	OR	R2,R0
	LHL	R0,SGIND,,
	OR	R2,R0
	LIS	R0,0
	STH	R0,CDIND,,
	STH	R0,SGIND,,
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN
	JAL	R6,PTLBN		:NEXT RU
SNDLG8
	LA	R1,LOGS2		:FINISH LOGON SLEC SCREEN
	JAL	R6,PMLB
	LHI	R2,NSINTM^8
	LHL	R0,CDIND,,
	OR	R2,R0
	LHL	R0,SGIND,,
	JNFS	SNDLG9
	OHI	R2,NSDTLS		:LAST SEG
SNDLG9
	LIS	R0,0
	STH	R0,CDIND,,
	STH	R0,SGIND,,
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN		:GIVE TO SNA
	L	R5,D5SAVE,,		:RESTORE R5
	L	R6,D6SAVE,,		:RESTORE R6
	L	R7,D7SAVE,,		:RESTORE R7
	JR	R6


	EI	(TERMIF)

	IF	TERMIF!VHRSUP

:	SNDLFD - SEND NEXT LOGON FIELD/ELEMENT
:	-----
:	EXPECT:	RDCB
SNDLFD
	ST	R6,D6SAVE,,		:SAVE R6
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC
	LB	R4,DCBLKS+DCBSTA,RDCB,	:SEE LOGON IN WHICH STATE
	CLHI	R4,L.PSNT		:HAS USID & PSWD BEEN SENT?
	JE	SNDLF8			:YES, EXIT
	LIS	R0,D.GATE		:SEE IF IN GATEWAY LOGON
	TBT	R0,DCBLKS+DCBMOD,RDCB,	:...
	JN	SNDLF5			:YES, SKIP
	CLHI	R4,L.PSWD		:SENDING PASSWORD NOW?
	JE	SNDLF3			:YES, SKIP
	CLHI	R4,L.USER		:SENDING USER NAME NOW?
	JN	SNDLF8			:NO, TO EXIT
	LIS	R0,4			:SET MSG LENGTH FOR LOGON CHAR
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT
	LHI	R2,NLOGCH		:NORMAL LOGON CHAR MSG
        JAL     R4,SLOR,,
	LIS	R0,GAUGE		:SEND GAUGING CHAR 1ST
	JAL	R4,PUTCH,,
	JAL	R4,ELOR,,
SNDLF1					:SEND USID & HOST #
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	SNLF01			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
SNLF01
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,LFAUSR,R6		:ROW TO USERNAME FIELD
	LR	R2,R7			:SAVE R7
	LB	R7,LFAUSR+1,R6		:COLUMN TO USERNAME
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,
	LR	R7,R2			:RESTORE R7
	EI	(TERMIF)
	LIS	R0,1
	STH	R0,FLDIND,,
SNDLFX
	LIS	R0,4			:SET MSG LENGTH FOR LOGON CHAR
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT
	LHI	R2,NLOGCH		:NORMAL LOGON CHAR MSG
        JAL     R4,SLOR,,
	LHL	R4,DCBLKS+DCBLGT,RDCB,	:GET LOGON INPUT DATA ROUTINE
	JAL	R6,PSEG,R4,		:TO GET LOGON CHAR
	LB	R0,BCDASC,R2,		:XLATE INTO ASCII
	CLHI	R0,ASP.			:IS IT A CNTL CHAR?
	IF	1-VHRSUP
	JLFS	SNDLF2			:EXIT IF CNTL CHAR (MANUAL LOGON)
	CLHI	R0,ASEMI.		:SEMICOLON ?
	JEFS	SNDLF2			:EXIT IF SEMI CHAR (STORED LOGON)
:FOR VHR IN VTR/PRE-STORED MODE THE USERNAME MAY BE TERMINATED WITH
:COMMA OR EXCLAMATION MARK (04/24/86 MIA)
	ELSE
	JL	SNDLF2			:EXIT IF CNTL CHAR (MANUAL LOGON)
	CLHI	R0,ASEMI.		:SEMICOLON?
	JE	SNDLF2			:EXIT IF SEMI CHAR (STORED LOGON)
	LHL	R4,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R4,LUCTAB+LUCVHR,R4,	:GET VHR STATE BYTE
	NHI	R4,LUVHRF!LUPVCP!LUSVCP!LUMNLG	:LEAVE ONLY THESE BITS
	CHI	R4,LUVHRF!LUSVCP	:VTR PRE-STORED?
	JN	SNDLFQ			:JUMP IF NOT
	CHI	R0,ACOMA.		:COMMA?
	JEFS	SNDLF2			:JUMP IF SO
	CHI	R0,AEXCL.		:EXCLAMATION MARK?
	JEFS	SNDLF2			:JUMP IF SO
	EI	(VHRSUP)
SNDLFQ	OHI	R0,80			:TURN ON HIGH ORDER BIT
	JAL	R4,PUTCH,,		:SEND TO ORING
	JAL	R4,ELOR,,
	J	SNDLFX			:REPEAT UNTIL CNTL OR SEMI
SNDLF2					:CNTL OR SEMI FOUND
	LHI	R0,ASEMI.!80		:SEND SEMICOLON W/ HIGH BIT SET
	JAL	R4,PUTCH,,		:PUT INTO RING
	JAL	R4,ELOR,,
	LIS	R0,L.PSWD		:NEXT WILL BE PASSWORD
	STB	R0,DCBLKS+DCBSTA,RDCB,
	J	SNDLF8			:TO SET TIMER AND WAIT
SNDLF3					:SEND PASSWORD
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	SNLF03			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
SNLF03
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,LFAPWD,R6		:ROW TO PASSWORD FIELD
	LR	R2,R7			:SAVE R7
	LB	R7,LFAPWD+1,R6		:COLUMN TO PASSWORD
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,
	LR	R7,R2			:RESTORE R7
	EI	(TERMIF)
	LIS	R0,1
	STH	R0,FLDIND,,
SNDLFY
	LIS	R0,4			:SET MSG LENGTH FOR LOGON CHAR
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT
	LHI	R2,NLOGCH		:NORMAL LOGON CHAR MSG
	JAL	R4,SLOR,,
	LHL	R4,DCBLKS+DCBLGT,RDCB,	:SET LOGON INPUT ROUTINE
	JAL	R6,PSEG,R4,		:GO GET LOGON CHAR
	LB	R0,BCDASC,R2,		:XLATE INTO ASCII
	CLHI	R0,ASP.			:IS IT A CNTL CHAR ?
	IF	1-VHRSUP
	JLFS	SNDLF4			:EXIT IF CNTL CHAR (MANUAL LOGON)
	CLHI	R0,ASEMI.		:SEMICOLON ?
	JEFS	SNDLF4			:EXIT IF SEMI CHAR (STORED LOGON)
:FOR VHR IN VTR/PRE-STORED MODE THE PASSWORD MAY BE TERMINATED WITH
:COMMA OR EXCLAMATION MARK (02/12/86 MIA)
	ELSE
	JL	SNDLF4			:EXIT IF CNTL CHAR (MANUAL LOGON)
	CLHI	R0,ASEMI.		:SEMICOLON?
	JE	SNDLF4			:EXIT IF SEMI CHAR (STORED LOGON)
	LHL	R4,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R4,LUCTAB+LUCVHR,R4,	:GET VHR STATE BYTE
	NHI	R4,LUVHRF!LUPVCP!LUSVCP!LUMNLG	:LEAVE ONLY THESE BITS
	CHI	R4,LUVHRF!LUSVCP	:VTR PRE-STORED?
	JN	SNDL31			:JUMP IF NOT
	CHI	R0,ACOMA.		:COMMA?
	JEFS	SNDLF4			:JUMP IF SO
	CHI	R0,AEXCL.		:EXCLAMATION MARK?
	JEFS	SNDLF4			:JUMP IF SO
	EI	(VHRSUP)
SNDL31	OHI	R0,80			:TURN ON HIGH ORDER BIT
	JAL	R4,PUTCH,,
	JAL	R4,ELOR,,
	J	SNDLFY			:REPEAT UNTIL CNTL OR SEMI CHAR
SNDLF4
	LHI	R0,ASEMI.!80		:SEND SEMICOLON W/ HIGH BIT SET
	JAL	R4,PUTCH,,
	JAL	R4,ELOR,,
	LIS	R0,L.PSNT		:USID & PSWD SENT
	STB	R0,DCBLKS+DCBSTA,RDCB,
	J	SNDLF8			:SET TIMER AND EXIT
SNDLF5					:GATEWAY LOGON, SEND USID + PASSWD
	LIS	R0,GAUGE		:SEND GAUGE CHAR TOO
	STB	R0,GWYRCD+1,,		:GOUGE CHAR
	LIS	R7,1			:TALLY THE GATEWAY RCD BYTE COUNT
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	SNLF05			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
SNLF05
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,LFAUSR,R6		:ROW TO USERNAME FIELD
	LR	R2,R7			:SAVE R7
	LB	R7,LFAUSR+1,R6		:COLUMN TO USERNAME FIELD
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,
	LR	R7,R2			:RESTORE R7
	EI	(TERMIF)
	LIS	R0,1			:FIELD SEARCH
	STH	R0,FLDIND,,
	LIS	R0,D.STOR
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JEFS	SNDLF6
	JAL	R6,NXTSC		:PREPARE NEW ELEMENT FOR STORED MODE
SNDLF6
	LHL	R4,DCBLKS+DCBLGT,RDCB,	:SET LOGON CHAR GET ROUTNE
	JAL	R6,PSEG,R4,		:GET NEXT LOGON CHR
	LB	R0,BCDASC,R2,		:XLATE INTO ASCII
	JE	SNDLF7			:EXIT IF "01" CHAR (STORED LOGON)
	CLHI	R0,ASP.			:IS IT A CNTL CHAR
	JL	SNDLFZ			:EXIT IF CNTL CHAR (MANUAL LOGON)
:FOR VHR IN VTR/PRE-STORED MODE THE USERNAME MAY BE TERMINATED WITH
:COMMA OR EXCLAMATION MARK (04/24/86 MIA)
	IF	VHRSUP
	LHL	R4,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R4,LUCTAB+LUCVHR,R4,	:GET VHR STATE BYTE
	NHI	R4,LUVHRF!LUPVCP!LUSVCP!LUMNLG	:LEAVE ONLY THESE BITS
	CHI	R4,LUVHRF!LUSVCP	:VTR PRE-STORED?
	JNFS	SNDLFJ			:JUMP IF NOT
	CHI	R0,ACOMA.		:COMMA?
	JE	SNDLF7			:JUMP IF SO
	CHI	R0,AEXCL.		:EXCLAMATION MARK?
	JE	SNDLF7			:JUMP IF SO
	EI	(VHRSUP)
SNDLFJ	OHI	R0,80			:SET HIGH ORDER BIT ON
	STB	R0,GWYRCD+1,R7,		:SAVE 
	AIS	R7,1			:INC BYTE CNT
	J	SNDLF6			:REPEAT UNTIL CNTL OR SEMI CHAR
SNDLFZ					:MANUAL USERID COLLECTEDSENT, PSWD NEXT
	LHI	R0,ASEMI.!80		:USERID END WITH SEMI
	STB	R0,GWYRCD+1,R7,
	AIS	R7,1			:INC BYTE CNT
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	SNLF06			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
SNLF06
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,LFAPWD,R6		:ROW TO PASSWORD FIELD
	LR	R2,R7			:SAVE R7
	LB	R7,LFAPWD+1,R6		:COLUMN TO PASSWORD FIELD
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,
	LR	R7,R2			:RESTORE R7
	EI	(TERMIF)
	LIS	R0,1
	STH	R0,FLDIND,,
					:COLLECT PSWD FOR GATEWAY LOGON(MANUAL)
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,
	LB	R0,BCDASC,R2,
	CLHI	R0,ASP.
	JL	SNDLFV			:ALL SCANED, BUT DONT APPEND SEMI AGAIN
	IF	VHRSUP
:FOR VHR IN VTR/PRE-STORED MODE THE PASSWORD MAY BE TERMINATED WITH
:COMMA OR EXCLAMATION MARK (02/12/86 MIA)
	LHL	R4,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R4,LUCTAB+LUCVHR,R4,	:GET VHR STATE BYTE
	NHI	R4,LUVHRF!LUPVCP!LUSVCP!LUMNLG	:LEAVE ONLY THESE BITS
	CHI	R4,LUVHRF!LUSVCP	:VTR PRE-STORED?
	JN	SNDLF4			:JUMP IF NOT
	CHI	R0,ACOMA.		:COMMA?
	JE	SNDLFV			:JUMP IF SO
	CHI	R0,AEXCL.		:EXCLAMATION MARK?
	JE	SNDLFV			:JUMP IF SO
	EI	(VHRSUP)
	J	SNDLFU			:SKIP TO SEE IF SEMI
SNDLFW
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,
	LB	R0,BCDASC,R2,
	CLHI	R0,ASP.
	JL	SNDLF7			:ALL SCANNED, SKIP
SNDLFU
	CLHI	R0,ASEMI.
	JE	SNDLF7			:END IF SEMI, DONE
	OHI	R0,80
	STB	R0,GWYRCD+1,R7,
	AIS	R7,1
	J	SNDLFW			:REPEAT
SNDLF7					:USERID AND PSWD COLLECTED
	LHI	R0,ASEMI.!80		:SEND SEMICOLON W/ PARITY BIT ON
	STB	R0,GWYRCD+1,R7,
	AIS	R7,1
SNDLFV
	STB	R7,GWYRCD,,		:BYTE COUNT
	LHL	R2,DCBLKS+DCBIPR,RDCB,	:R2 = ISIS PORT#
	LA	R3,GWYRCD,,		:R3 = MESSAGE
	LR	R6,R5
	JAL	R5,OCS,,
	LR	R5,R6
	LIS	R0,L.PSNT		:USID & PSWD SENT
	STB	R0,DCBLKS+DCBSTA,RDCB,
SNDLF8
	L	R6,D6SAVE,,		:RESTORE R6
	JR	R6
 
:	LGNERR:	LOGON STATUS (VIA ISIS/IIX) NOT CONTINUE
:	------
:	EXPECT:	DCBTMP = ERROR CODE
:		R6 = LINK REG.
LGNERR
	ST	R6,D6SAVE,,		:SAVE R6
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	IF	TERMIF
	LIS	R0,D.STOR		:SEE IF STORED LOGON MODE
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JE	LGNER1			:NO, SKIP
	EI	(TERMIF)
	IF	TERMIF&VHRSUP
	LB	R2,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R2,LUVHRF		:VHR FUNCTION?
	JE	LGNER0			:MUST BE TIF IF NOT
	EI	(TERMIF&VHRSUP)

	IF	VHRSUP
:RELEASE BUFFERS WITH VTR LOGON INFORMATION.
	BBL	R3,DCBLKS+DCBLBA,RDCB,	:GET POINTER TO LOGON BUFFERS
	JEFS	LGNERU			:JUMP IF NONE
	JAL	R6,DLODBB		:RELASE LOGON BUFFERS
	XR	R3,R3			:CLEAR THE REGISTER
	BBST	R3,DCBLKS+DCBLBA,RDCB,	:UPDATE LOGON POINTER

:FILL IN CADR1 AND CADR2 AND SEND LOGON REPLY RU TO VTR. THIS CODE ASSUMES
:THAT REPLY RU IS 1 SEGMENT 1 ELEMENT CHAIN. IF NOT THIS CODE SHOULD BE
:CHANGED LATER.
LGNERU	LB	R7,DCBLKS+DCBTMP,RDCB,	:GET CODE OF LOGON ERROR
	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET  POINTER TO PREPARED REPLY
	LB	R2,LUCTAB+LUCVHR,R11,	:GET VHR STATE (04/29/86 YLH)
	THI	R2,LUMNLG		:VTR MANUAL LOGON?
:	JEFS	LGNERV			:JUMP IF NOT (09/24/86 MIA)
	JFS	LGNERV			:TEMPORARY (09/24/86 MIA)
	LIS	R6,VHRCNT		:PREPARE CONTINUE TO VTR
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	LB	R0,NLSTAB,R7		:GET NEXT STATE
	JFS	LGNERX			:JUMP TO CONTINUE
LGNERV	LHI	R6,SP.			:PREPARE LOGON COMPLETED
	GL	FSHINP
	LHI	R0,FSHINP-PSEG		:FLUSH INPUT
	STH	R0,DCBLKS+DCBINP,RDCB,	:UPDATE PORCESSING ROUTINE IN DCB
	LHI	R0,L.ERCK		:ERROR LOGON STATE
LGNERX	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA1,R3,	:FILL CADR1
	STB	R0,DCBLKS+DCBSTA,RDCB,	:UPDATE LOGON STATUS
	LIS	R6,VHRCDR		:PREPARE CADR2(CD)
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:FILL CADR2
	LB	R6,LGNEVR,R7		:GET VHR ERROR CODE
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCDE,R3,	:PUT IT IN VHR HEADER
	XR	R6,R6			:CLEAR THE REGISTER
	BBST	R6,DCBLKS+DCBIBH,RDCB,	:UPDATE REPLY POINTER
	LHL	R8,DCBLKS+DCBALU,RDCB,	:GET MESSAGE LENGTH
	LHI	R2,NSETEM^8!NSDTCD	:ASSUME SINGLE SEG, SINGLE RU CHAIN
	JAL	R6,QDIFSN		:SEND IT TO SNA
	J	LGNER4			:JUMP TO CONTINUE
	EI

	IF	TERMIF
LGNER0	JAL	R6,PTLBH		:START ERROR MESSAGE
	LB	R7,DCBLKS+DCBTMP,RDCB,	:R7 = ERROR CODE
	SLHLS	R7,1			:STORED LOGON MODE ERROR
	LHL	R1,LEMSGB,R7		:GET ERRO MSG
	AI	R1,PSEG			:ADJUST
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN
	GL	RSTTRM
	JAL	R6,RSTTRM		:ZAP THE CIRCUIT
	LHI	R0,L.ERCK		:INTO ERROR STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,R11,
	J	LGNER4			:SKIP TO EXIT
LGNER1					:MANUAL LOGON ERROR
	JAL	R6,ISIEND		:END OF ANY EXISTING FROM NETWORK
	JAL	R6,RLOGBB		:RELEASE ANY LOGON BB
	JAL	R6,PTLBH		:START ERROR MESSAGE
	LB	R7,DCBLKS+DCBTMP,RDCB,	:GET R7 = ERRO CODE
	SLHLS	R7,1			:MAKE HW INDEX
	LHL	R1,LEMSGA,R7		:GET ERROR MSG
	AI	R1,PSEG
	JAL	R6,PMLB
	LB	R7,DCBLKS+DCBTMP,RDCB,	:GET ERROR CODE
	CLHI	R7,8			:IS THIS HOST ERROR
	JL	LGNER2			:NO, SKIP
	LHI	R2,NSINTM^8
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN
	JAL	R6,PTLBH		:START ANOTHER MESSAGE
	LA	R1,MLGS1		:TO ERASE THE USID FIELD ON SCREEN
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN
	LIS	R0,D.LERR		:SET HOST ERROR FLAG
	SBT	RDCB,DCBLKS+DCBMOD,RDCB,
	LHI	R0,L.USER		:SET NEW LOGON STATE
	JFS	LGNER3			:SKIP
LGNER2
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN
	LB	R7,DCBLKS+DCBTMP,RDCB,
	LB	R0,NLSTAB,R7		:GET NEX LOGON STATE (FIELD)
LGNER3
	STB	R0,DCBLKS+DCBSTA,RDCB,
:	REMARK *** OCAN TO FLUSH OUTPUT DATA UNTIL...
:	SET 'USER LOGON DURATION ' TIMER

	EI	(TERMIF)

LGNER4
	L	R6,D6SAVE,,		:RESTORE R6
	JR	R6			:RETURN
	
	IF	VHRSUP
:VHR ERROR CODE TRANSLATION TABLE
:LGNEVR	BC	VHREOK,VHREUS,VHREUS,VHREPW,VHREUS,VHREPW	:(08/24/86)
LGNEVR	BC	VHREOK,VHREZP,VHREZP,VHREZP,VHREZP,VHREZP	:TERM (MIA)
	BC	VHREZP,VHREZP,VHREZP,VHREZP,VHREBY,VHREHN
	BC	VHREOP,VHREHD,VHREHD,VHREBY,VHRENA,VHREHN
	BC	VHREHN,VHREZP

	EI

:	NLSTAB:	NEXT LOGON STATE(=FIELD) TABLE
:	-------
:	CURRENT LOGON STATUS AS INDEX
NLSTAB	BC	L.USER			:CONTINUE
	BC	L.USER			:"PLEASE LOG IN"
	BC	L.USER			:"ERROR, TYPE USERNAME"
	BC	L.PSWD			:"ERROR, TYPE PASSWORD"
	BC	L.USER			:"USERNAME"
	BC	L.PSWD			:"PASSWORD"

	EI	(TERMIF!VHRSUP)

	IF	TERMIF

:	LEMSGA:	LOGON ERROR MSGS FOR MANUAL LOGON
:	------
LEMSGA
	HC	LEM1-PSEG		:0 - CONTINUE
	HC	LEM1-PSEG		:1 - "PLEASE LOG IN"
	HC	LEM1-PSEG		:2 - "ERROR, TYPE USERNAME"
	HC	LEM2-PSEG		:3 - "ERROR, TYPE PASSWORD"
	HC	LEM1-PSEG		:4 - "USERNAME"
	HC	LEM2-PSEG		:5 - "PASSWORD"
	HC	LEM1-PSEG		:6 - RESERVED
	HC	LEM1-PSEG		:7 - RESERVED
	HC	LEM8-PSEG		:8 - "PLEASE SEE YOUR REP..."
	HC	LEM9-PSEG		:9 - "BAD MUD"
	HC	LEM0A-PSEG		:A - "CIRCUITS BUSY"
	HC	LEM0B-PSEG		:B - "HOST NOT AVAIL..."
	HC	LEM0C-PSEG		:C - "HOST OUT OF PORTS"
	HC	LEM0D-PSEG		:D - "HOST DOWN"
	HC	LEM0E-PSEG		:E - "HOST SHUT"
	HC	LEM0F-PSEG		:F - "TRY AGAIN IN 2 MINUTES"
	HC	LEM10-PSEG		:10 - "ACCESS NOT PERMITTED"
	HC	LEM11-PSEG		:11 - "NO HOST SPECIFIED"
	HC	LEM12-PSEG		:12 - "BAD HOST NUMBER"
	HC	LEM13-PSEG		:13 - "MUD ERROR"

:	LEMSGB:	LOGON ERROR MSGS FOR STORED LOGON
:	------
LEMSGB
	HC	LEM5-PSEG		:0 - CONTINUE
	HC	LEM5-PSEG		:1 - "PLEASE LOG IN"
	HC	LEM5-PSEG		:2 - "ERROR, TYPE USERNAME"
	HC	LEM6-PSEG		:3 - "ERROR, TYPE PASSWORD"
	HC	LEM5-PSEG		:4 - "USERNAME"
	HC	LEM6-PSEG		:5 - "PASSWORD"
	HC	LEM5-PSEG		:6 - RESERVED
	HC	LEM5-PSEG		:7 - RESERVED
	HC	LEM8-PSEG		:8 - "PLEASE SEE YOUR REP..."
	HC	LEM9-PSEG		:9 - "BAD MUD"
	HC	LEM0A-PSEG		:A - "CIRCUITS BUSY"
	HC	LEM0B-PSEG		:B - "HOST NOT AVAIL..."
	HC	LEM0C-PSEG		:C - "HOST OUT OF PORTS"
	HC	LEM0D-PSEG		:D - "HOST DOWN"
	HC	LEM0E-PSEG		:E - "HOST SHUT"
	HC	LEM0F-PSEG		:F - "TRY AGAIN IN 2 MINUTES"
	HC	LEM10-PSEG		:10 - "ACCESS NOT PERMITTED"
	HC	LEM11-PSEG		:11 - "NO HOST SPECIFIED"
	HC	LEM12-PSEG		:12 - "BAD HOST NUMBER"
	HC	LEM13-PSEG		:13 - "MUD ERROR"

	EI	(TERMIF)

	IF	TERMIF!VHRSUP

:	CHKHEX	: CHECK TO SEE IF THE CHAR IS A HEX NUMBER
:	-------
:	LINK ON R6
:	DESTROY R2
:	EXPECT R2 = CHAR
:	NORMAL RETURN = NON-NUMBERIC/NON-HEX, ERROR
:	SKIP +4 RETURN = R2 CONTAINS THE CONVERTED BINARY VALUE
:
CHKHEX
	CLHI	R2,LA.			:LESS THAN LOW A?
	JLR	R6			:YES, ERROR
	CLHI	R2,LF.			:WITHIN LA. AND LF.?
	JLE	CHKHE1			:YES, OK, SKIP
	CLHI	R2,A.			:SMALL THAN A?
	JLR	R6			:YES, ERROR
	CLHI	R2,F.			:LESS THAN F?
	JLE	CHKHE1			:WITHIN A. AND F., SKIP
	CLHI	R2,N0.			:LESS THAN N0.?
	JLR	R6			:YES, ERROR
	CLHI	R2,N9.			:GRATER THAN N9.?
	JGR	R6			:YES, ERROR
	NHI	R2,0F			:N0. <-> N9., CONVERT TO BINARY
	J	4,R6			:SKIP RETURN
CHKHE1
	NHI	R2,0F			:USE THE LEFTEST NIBBLE AS INDEX
	LB	R2,HTBTBL,R2		:CONVERT TO BINARY
	J	4,R6			:SKIP +4 RETURN

HTBTBL	HS	0
	BC	0,0A,0B,0C,0D,0E,0F
	HS	0

:	FETDSP:	FETCH DSP DATA FROM DSP SCREEN
:	------
:	INPUT:	RDCB, R11
:		R6 - LINK REG.
FETDSP
	ST	R6,FT6SAV,,		:SAVE R6
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	FTDS00			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
FTDS00
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,DSPL1,R6		:ROW TO CRM# FIELD
	LB	R7,DSPL1+1,R6		:COLUMN TO CRM# FIELD
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,		:FOR SEARCH
	EI	(TERMIF)
	LIS	R0,1			:SET SEARCH FIELD
	STH	R0,FLDIND,,		:INDICATOR
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,		:TO GET CRM#
	IF	VHRSUP
	JAL	R4,FETDSS		:CHECK FOR VHR CONTROL INFO
	J	FETDSJ			:JUMP IF FOUND VHR CONTROL
	EI
	LIS	R6,0			:ERROR CODE = 0
	LR	R2,R2			:ANY DATA???
	JE	FETDSX			:NO, TO RE-DISPLAY DSP SCREEN
	SHI	R2,N0.			:DATA RANGE CHECKING
	JLE	FETDSX			:OUT OF RANGE ...
	CLHI	R2,MAXCRM		:..
	JG	FETDSX			:...
	LIS	R6,1			:ERROR CODE = 1
	CLHI	R2,4			:CRM 4
	JNFS	FETDS1			:NO, SKIP
	J	FETDSX			:CRM4 NOT SUPPORTED
	IF	VHRSUP
FETDSJ	LIS	R2,3			:DEFUALT TO CRM 3
	STB	R2,DCBLKS+DCBCRM,RDCB,	:SAVE IT IN DCB
	JFS	FETDS0			:JUMP TO CONTINUE
	EI
FETDS1
	STB	R2,DCBLKS+DCBCRM,RDCB,	:SAVE CRM# INTO DCB
	IF	VHRSUP
:FOR VHR WE HAVE TO FETCH SEMICOLON AFTER CRM.
	JAL	R4,FETDSV		:GET SEMICOLON AND CHECK
FETDS0
	EI
					:FETCH DESTI INTERFACE ADDR
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	FTDS01			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
FTDS01
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,DSPL2,R6		:ROW TO DESTI INTERFACE ADDR
	LB	R7,DSPL2+1,R6		:COLUMN TO DESTI INTERFACE ADDR
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,
	EI	(TERMIF)
	LIS	R0,1			:SERACH FIELD
	STH	R0,FLDIND,,		:SET INDICATOR
	LIS	R7,0			:SET ADR COUNTER IN BYTES
FETDS2
	LHL	R4,DCBLKS+DCBLGT,RDCB,	:GET ROUTINE ADR
	JAL	R6,PSEG,R4,		:GET CHAR OF ADR
	CLHI	R2,SP.			:A CONTROL CHAR?
	JL	FETDS4			:SKIP, IF NO DATA OR CONTROL
	IF	VHRSUP
	JAL	R4,FETDSS		:CHECK IF VHR CONTROL INFO
	J	FETDS4			:SKIP IF NO DATA OR CONTROL
	EI
	LB	R13,BCDASC,R2,		:XLATE INTO ASCII
	LIS	R6,2			:ERROR CODE = 2
	CLHI	R13,A9.			:CHAR IS A DIGIT?
	JG	FETDSX			:N - GET ANSWER AGAIN
	SHI	R13,A0.			:
	JL	FETDSX
	SLHLS	R13,4			:PUT DIGIT TO LEFT NIBBLE
	LHL	R4,DCBLKS+DCBLGT,RDCB,	:GET NEXT CHAR ROUTINE
	JAL	R6,PSEG,R4,		:GET NEXT CHAR
	CLHI	R2,SP.			:A CONTROL CHAR?
	JL	FETDS3			:SKIP, IF NO DATA OR CONTROL
	LB	R0,BCDASC,R2,		:CONVERT TO ASCII
	LIS	R6,2			:ERROR CODE = 2
	CLHI	R0,A9.			:CHAR IS A DIGIT?
	JG	FETDSX			:N - GET ANSWER AGAIN
	SHI	R0,A0.
	JL	FETDSX
	OR	R13,R0			:COMBINE 2 DIGITS TO A BYTE
	STB	R13,DCBLKS+DCBCDA+1,RDCB,R7 :SAVE INTO DCB
	AIS	R7,1			:INCREMENT ADR BYTE COUNT
	J	FETDS2			:GET NEXT CHAR IF NOT FINISHED
FETDS3
	STB	R13,DCBLKS+DCBCDA+1,RDCB,R7 :STORE ODD ADDR
	LR	R0,R7			:CALCULATION FOR AN ODD # OF DIGITS
	SLHLS	R0,1
	SIS	R0,1
	JFS	FETDS5
FETDS4
	LR	R0,R7			:CALCULATION FOR AN EVEN # OF DIGITS
	SLHLS	R0,1
FETDS5
	STB	R0,DCBLKS+DCBCDA,RDCB,	:STORE # OF DIGITS OF CALLED ADR
					:FINISHED CALLED ADDRESS
	LIS	R0,0
FETDS6
	CLHI	R7,7			:FILL WITH ZEROS IF ADR
	JGEFS	FETDS7			:IS LESS THAN 14 DIGITS
	STB	R0,DCBLKS+DCBCDA+1,RDCB,R7
	AIS	R7,1
	JBS	FETDS6
FETDS7
					:GET APPLICATION IDENTIFIER
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	FTDS07			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
FTDS07
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,DSPL3,R6		:ROW TO APPL-ID
	LB	R7,DSPL3+1,R6		:COLUMN TO APPL-ID
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,
	EI	(TERMIF)
	LIS	R0,1			:FIELD SEARCH INDICATOR
	STH	R0,FLDIND,,
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,		:GET APPLICATION ID
	IF	TERMIF&VHRSUP
	LB	R4,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	THI	R4,LUVHRF		:VHR FUNCTION?
	JN	FTDS18			:JUMP IF SO
	EI	(VHRSUP)
	IF	TERMIF
	LHI	R13,0FF			:ASSUME NO DATA(6/16/86/CHS)
	CLHI	R2,SP.			:A CONTROL CHAR?
	JL	FTDS16			:YES, SKIP
:	(6/16/86/CHS) TWO HEX BYTES FOR APP-ID FIELD
	JAL	R6,CHKHEX		:HEX CHECKING
	J	FETDSY			:ERROR
	LR	R13,R2			:SAVE INTO R13
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,		:GET 2ND DIGIT
	CLHI	R2,SP.			:NO DATA?
	JLFS	FTDS16
	JAL	R6,CHKHEX		:HEX CHECKING
	J	FETDSY			:ERROR
FTDS17
	SLHLS	R13,4
	OR	R13,R2
FTDS16
	STB	R13,DCBLKS+DCBRLN,RDCB,	:REMOTE LINE# INTO DCB AS EBCDIC(6/16/86/CHS)
	EI	(TERMIF)
	IF	TERMIF&VHRSUP
	J	FETDST
	EI	(TERMIF&VHRSUP)
	IF	VHRSUP
FTDS18	LIS	R0,0			:ASSUME NO DATA
	CLHI	R2,SP.			:A CONTROL CHAR?
	JLFS	FETDS8			:YES, SKIP
	JAL	R4,FETDSS		:CHECK IF VHR CONTROL INFO
	JFS	FETDS8			:JUMP IF VHR CONTROL
	HC	0			:PROVIDE FOR SKIP RETURN
	LR	R0,R2
	NHI	R0,0F
FETDS8
	STB	R0,DCBLKS+DCBRLN,RDCB,	:REMOTE LINE# INTO DCB AS EBCDIC
	JAL	R4,FETDSV		:FETCH SEMICOLON IF NECESSARY
					:GET DESTINATION CONTROL UNIT
:FOR LU PERFORMING VHR FUNCTION OBTAIN CONTROL UNIT AND DEVICE INFORMATION.
	LIS	R6,4			:PREPARE CU ERROR CODE
	JAL	R4,FETDSR		:FETCH CU INFORMATION
	STB	R0,DCBLKS+DCBRCU,RDCB,	:SAVE CU INFORMATION
	LIS	R6,5			:PREPARE DEVICE ERROR CODE
	JAL	R4,FETDSR		:FETCH DEVICE INFORMATION
	LR	R13,R0			:COPY IT
	J	FETDSC			:JUMP TO CONTINUE
FETDST	EQ	.
	EI

	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	FTDS08			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
FTDS08
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,DSPL4,R6		:ROW TO DEST CU ADDR
	LB	R7,DSPL4+1,R6		:COLUMN TO DEST CU ADDR
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,
	EI	(TERMIF)
	LIS	R0,1
	STH	R0,FLDIND,,
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,		:GET DEST CU ADDR
:	LHI	R13,0FF			:ASSUME NO DATA
	LIS	R13,0			:ASSUME NO DATA (01/23/87 MIA)
	CLHI	R2,SP.			:A CONTROL CHAR?
	JL	FETDSA			:YES, SKIP
	JAL	R6,CHKHEX		:HEX CHECKING
	J	FETDSY			:ERROR
	LR	R13,R2			:SAVE INTO R13
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,		:GET 2ND DIGIT
	CLHI	R2,SP.			:NO DATA?
	JLFS	FETDSA
	JAL	R6,CHKHEX		:HEX CHECKING
	J	FETDSY			:ERROR
FETDS9
	SLHLS	R13,4
	OR	R13,R2
FETDSA
	STB	R13,DCBLKS+DCBRCU,RDCB,	:REMOTE CU ADDR INTO DCB AS EBCDIC
					:GET DESTINATION DEVICE ADDRESS
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	FTDS0A			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
FTDS0A
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,DSPL5,R6		:ROW TO DEST LU ADDR
	LB	R7,DSPL5+1,R6		:COLUMN TO DEST LU ADDR
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,
	EI	(TERMIF)
	LIS	R0,1
	STH	R0,FLDIND,,
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,		:GET DEST LU ADDR
:	LHI	R13,0FF			:ASSUME NO DATA
	LIS	R13,0			:ASSUME NO DATA
	CLHI	R2,SP.			:A CONTROL CHAR?
	JL	FETDSC			:NO DATA, SKIP
	JAL	R6,CHKHEX		:HEX CHECKING
	J	FETDSZ			:ERROR
	LR	R13,R2			:SAVE INTO R13
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,		:GET 2ND DIGIT
	CLHI	R2,SP.			:A CONTROL CHAR?
	JLFS	FETDSC			:NO DATA, SKIP
	JAL	R6,CHKHEX		:HEX CHECKING
	J	FETDSZ			:ERROR
FETDSB
	SLHLS	R13,4
	OR	R13,R2
FETDSC
	STB	R13,DCBLKS+DCBRLU,RDCB,	:REMOTE LU ADDR INTO DCB AS EBCDIC
					:GET CHARACTER SET
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,7
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	FTDS0C			:NO, SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
FTDS0C
	IF	TERMIF
	LHI	R0,$A80			:ROW SIZE
	LB	R4,DSPL8,R6		:ROW TO CHAR SET
	LB	R7,DSPL8+1,R6		:COLUMN TO CHAR SET
	JAL	R6,SBADDR		:BAIO CODE
	STH	R0,FLDADR,,
	EI	(TERMIF)
	LIS	R0,1
	STH	R0,FLDIND,,
	LHL	R4,DCBLKS+DCBLGT,RDCB,
	JAL	R6,PSEG,R4,		:GET CHAR SET
	LB	R13,LUCTAB+LUCDIF,R11,	:ASSUME NO DATA, USE DEFAULT
	CLHI	R2,SP.			:A CONTROL CHAR?
	JL	FETDSD			:NO DATA, SKIP
	LR	R13,R2			:R13 = R2 = SELECTED CHAR SET
	NHI	R13,0F			:LEFT NIBBLE ONLY
	CLHI	R2,N0.			:0?
	JE	FETDSD			:YES, SKIP
	CLHI	R2,N4.			:4?
	JE	FETDSD			:YES, SKIP
	CLHI	R2,N5.			:5?
	JE	FETDSD			:YES, SKIP
	J	FETDSW			:ERROR
FETDSD
	STB	R13,DCBLKS+DCBDIF,RDCB,	:REMOTE CHAR SET INTO DCB
					:GET ANSWER TO TRANSPARENCY
:					:(DEFAULT IS "YES")
					:GET ANSWER TO COLOR (DEFAULT IS "YES")
	L	R6,FT6SAV,,
	J	4,R6

FETDSW					:ERROR - ILLEGAL CHAR SET
	LIS	R6,6
	J	FETDSX			:CONTINUE
FETDSZ					:ERROR - ILLEGAL DEVICE ADDR
	LIS	R6,5
	JFS	FETDSX

FETDSY					:ERROR - ILLEGAL CU ADDR
	LIS	R6,4

FETDSX					:ERROR - R6 = ERROR CODE
	IF	TERMIF&VHRSUP
	LHL	R13,DCBLKS+DCBLUC,RDCB,	:GET DCB POINTER
	LB	R13,LUCTAB+LUCVHR,R13,	:GET VHR STATE
	THI	R13,LUVHRF		:VHR FUNCTION?
	JEFS	FETDSE			:JUMP IF NOT
	EI
	IF	VHRSUP
	LHL	R13,FDSRER,R6,R6	:R13 - DSP/VHR ERROR MSG ADR
	EI
	IF	TERMIF&VHRSUP
	JFS	FETDSF			:JUMP TO CONTINUE
	EI
	IF	TERMIF
FETDSE	LHL	R13,FDSPER,R6,R6	:R13 = DSP DATA ERROR MSG ADR
	EI
FETDSF	AI	R13,PSEG		:GET FULL ADDR
	L	R6,FT6SAV,,
	JR	R6

	IF	TERMIF

:	FDSPER:	FETCH DSP DATA ERROR TABLE
:	------
FDSPER	HC	FDSPE0-PSEG		:0 - ILLEGAL CRM #
	HC	FDSPE1-PSEG		:1 - CRM 4 NOT SUPPORTED
	HC	FDSPE2-PSEG		:2 - ILLEGAL INTERFACE ADDR
	HC	FDSPE3-PSEG		:3 - ILLEGAL APPL-ID
	HC	FDSPE4-PSEG		:4 - ILLEGAL CU ADDR
	HC	FDSPE5-PSEG		:5 - ILLEGAL DEVICE ADDR
	HC	FDSPE6-PSEG		:6 - ILLEGAL CHAR SET

	EI

	IF	VHRSUP
:	FDSRER: FETCH DSP/VHR DATA ERROR TABLE
FDSRER	HC	DSPE0E-PSEG		:0 - ILLEGAL CRM #
	HC	DSPE1E-PSEG		:1 - CRM4 NOT SUPPORTED
	HC	DSPE2E-PSEG		:2 - ILLEGAL INTERFACE ADDR
	HC	DSPE3E-PSEG		:3 - ILLEGAL APPL ID
	HC	DSPE4E-PSEG		:4 - ILLEGAL CU ADDR
	HC	DSPE5E-PSEG		:5 - ILLEGAL DEVICE ADDR
	EI

	IF	VHRSUP
:THIS SUBROUTINE CHECK WHETHER THIS LU PERFORMS VHR FUNCTION.
:IF SO THE CHARACTER IN R0 IS COMPARED WITH SEMICOLON OR R2 WITH CONTROL CHAR
:AND SKIP RETURN +4 IS MADE IF NOT SEMICOLON OR CONTROL OR NOT VHR FUNCTION.
:ALSO SETS R13 IN CASE OF NORMAL RETURN AND CLEARS IT IN CASE OF SKIP RETURN.
FETDSS	EQ	.
	IF	TERMIF			:CHECK THAT THIS IS VHR
	LHL	R13,DCBLKS+DCBLUC,RDCB,	:GET DCB POINTER
	LB	R13,LUCTAB+LUCVHR,R13,	:GET VHR INFO
	THI	R13,LUVHRF		:VHR FUNCTION?
	JE	4,R4			:JUMP RETURN IF NOT
	EI				:IF NOT TERMIF ASSUME VHR
	LR	R0,R0			:CONTROL CHAR?
	JER	R4			:NORMAL RETURN IF SO
	CHI	R0,ASEMI.		:SEMICOLON?
	JER	R4			:NORMAL RETURN IF SO
	XR	R13,R13			:CLEAR RETURN REGISTER
	J	4,R4			:JUMP RETURN IF NOT

:FETCH NEXT CHARACTER IF LU PERFORMS VHR FUNCTION AND CHECK THAT
:THIS IS SEMICOLON OR CONTROL CHARACTER. RETURN TO CALLER IF SO,
:OTHERWISE JUMP TO ERROR HANDLING. ALSO REGISTER R13 COULD BE
:SET TO PREVENT FETCHING THE NEXT CHARACTER.
FETDSV	LR	R13,R13			:CHECK R13
	JNR	R4			:RETURN IF THE REGISTER IS SET
	IF	TERMIF			:CHECK THAT LU PERFORMS VHR FUNCTION
	LHL	R13,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R13,LUCTAB+LUCVHR,R13,	:GET VHR INFO
	THI	R13,LUVHRF		:VHR FUNCTION?
	JER	R4			:RETURN IF NOT
	EI				:OTHERWISE ASSUME VHR
	ST	R4,IBSSAV,,		:SAVE RETURN REGISTER
	LR	R13,R6			:SAVE R6
	LHL	R2,DCBLKS+DCBLGT,RDCB,	:GET POINTER TO FETCH ROUTINE
	JAL	R6,PSEG,R2,		:FETCH NEXT CHAR
	LR	R6,R13			:RESTORE R6
	L	R4,IBSSAV,,		:RESTORE RETURN REGISTER
	LR	R0,R0			:CONTROL CHARACTER?
	JER	R4			:RETURN IF SO
	CHI	R0,ASEMI.		:SEMICOLON?
	JER	R4			:RETURN IF SO
	J	FETDSX			:OTHERWISE ERROR

:FETCH 1-BYTE FIELD FROM DSP VTR/VHR INFORMATION. THE SEPARATOR IS SEMICOLON.
:THE ROUTINE RETURNS THE DSP INFORMATION IN R0 IF IT WAS SPECIFIED
:BY VHR, OTHERWISE X'FF' IS RETURNED IN R0. FECTH PROCESS IS ADVANCED
:TO THE NEXT FIELD.
FETDSR	ST	R4,IBSSAV,,		:SAVE RETURN REGISTER
	LR	R13,R6			:SAVE ERROR CODE
	LIS	R0,1			:PREPARE TO INDICATE NEW FIELD
	STH	R0,FLDIND,,		:UPDATE FIELD INDICATOR
	LHL	R2,DCBLKS+DCBLGT,RDCB,	:OBTAIN POINTER TO FETCH ROUTINE
	JAL	R6,PSEG,R2,		:FETCH NEXT CHARACTER
	LR	R0,R0			:CONTROL CHARACTER?
	JEFS	FETDSQ			:JUMP IF SO
	CHI	R0,ASEMI.		:SEMICOLON?
	JNFS	FETDSU			:JUMP IF NOT
FETDSQ	LIS	R0,0			:INDICATE DUMMY INFO
	L	R4,IBSSAV,,		:RESTORE RETURN REGISTER
	JR	R4			:AND RETURN
FETDSU	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE DSP INFORMATION
	LHL	R2,DCBLKS+DCBLGT,RDCB,	:OBTAIN POINTER TO FETCH ROUTINE
	JAL	R6,PSEG,R2,		:FETCH NEXT CHARACTER
	LR	R6,R13			:RESTORE ERROR CODE
	LR	R0,R0			:CONTROL CHARACTER?
	JEFS	FETDSL			:JUMP IF SO
	CHI	R0,ASEMI.		:SEMICOLON?
	JN	FETDSX			:ERROR IF NOT
FETDSL	LB	R0,DCBLKS+DCBTMP,RDCB,	:GET DSP INFORMATION BYTE
	L	R4,IBSSAV,,		:RESTORE RETURN REGISTER
	JR	R4			:AND RETURN

	EI

:	GETDSP:	GET DSP DATA FROM THE STORED AREA
:	------
:	INPUT:	RDCB, R11
:		LINK ON R6
GETDSP
	ST	R6,FT6SAV,,		:SAVE R6
	LHL	RBBA,DCBLKS+DCBLBA,RDCB,
	LB	R2,PSEG+PSTCRM-PSTDLN,RBBA, :GET CRM #
	CLHI	R2,MAXCRM		:WITHIN RANGE
	JG	GETDSX			:ERROR
	CLHI	R2,4			:CRM 4
	JNFS	GETDS1			:NO, SKIOP
	J	GETDSX			:CRM4 NOT SUPPORTED
GETDS1
	STB	R2,DCBLKS+DCBCRM,RDCB,	:SAVE CRM# INTO DCB
					:FETCH DESTI INTERTFACE ADDRESS
					:(TO BE IMPLEMENTED)
	LIS	R0,0
	LIS	R7,0
GETDS2
	CLHI	R7,8
	JGEFS	GETDS3
	STB	R0,DCBLKS+DCBCDA,RDCB,	:NO CALLED ADDRESSES
	AIS	R7,1
	JBS	GETDS2
GETDS3					:GET APPLICATION ID(=LIN#)
	LB	R0,PSEG,RBBA,		:GET LINE #
	STB	R0,DCBLKS+DCBRLN,RDCB,	:RMOTE LINE # INTO DCB
					:GET DESTI. CUA
	LB	R0,PSEG+1,RBBA,	:GET CUA
	STB	R0,DCBLKS+DCBRCU,RDCB,	:REMOTE CUA INTO DCB
					:GET DESTI. LUA
	LB	R0,PSEG+2,RBBA,	:GET LUA
	STB	R0,DCBLKS+DCBRLU,RDCB,	:REMOTE LUA SAVE INTO DCB
					:(ALL OTHERS, NOT IMPLEMENTED)
	L	R6,FT6SAV,,
	J	4,R6			:SKIP RETURN

GETDSX					:ERROR
	L	R6,FT6SAV,,
	JR	R6			:NORMAL RETURN

	EI	(TERMIF)

	IF	HOSTIF

:	ATTACH:	ATTACH CIRCUIT TO DEVICE
:	------
:	IT IS CALLED DURING THE LOGON PROCESS, EITHER IN NATIVE
:	MODE OR IN VIRTUAL HOST MODE.  VARIOUS PRIORITIZED
:	CONDITIONS ARE CHECKED AGAINST THE INFORMATION PROVIDED
:	BY THE REQUETING USES, E.G.
:	TYPE  IN DISEQ IS FROM DEFAULT C1920 (ASCII) OR
:		CALL USER DATA (DSP)
:	ADR   IN REQDEV IS FROM PROJECT CODE (ASCII) OR
:		CRM (DSP)
:	PRIORITY CORRESPONDS TO CONDITIONS OF GREATER IMPORTANCE,
:	AND MUST BE REFLECTED IN ORDER OF ERROR MESSAGES IN ATHTBL
:	AND IN THE ORDER IN WHICH ATHE CONDITIONS ARE CHECKED.
:	DESTROYS - R0,R3,R4,R7,R8,R9,R11,R10
:	LINK - R6
ATTACH

					:(F00/02/06/87/DB/START)
					: FOR CRM 4 IMPLEMENTATION
	LB	R0,DCBLKS+DCBCRM,RDCB,	:GET CRM TYPE
	CLHI	R0,CENCRM		:IS THIS CRM 4?
	JN	ATTH00			:NO, CRM 1, 2, OR 3

: SET-UP REGISTERS FOR CRM 4 PROCESSING

	LHL	R10,DCBLKS+DCBCRD,RDCB,	:GET CRT DCB IN R10
	LHL	R11,DCBLKS+DCBCRD,R10,	:GET PRT LUC IN R11
	LHL	R10,DCBLKS+DCBLUC,R10,	:GET CRT LUC IN R10,
	STH	R10,DCBLKS+DCBCRD,RDCB,	:STORE CRT LUC WHERE CRT DCB WAS
	LHL	R4,LUCTAB+LUCLNC,R11,	:GET LNCTAB ENTRY OF THIS PRT LU

: ASSOCIATED CRT NETWORK LOGON STATE MUST BE "BUSY"

	LHI	R3,0F			:GET ERROR CODE
	LB	R0,LUCTAB+LUNSTA,R10,	:GET NETWORK LOGON STATE OF ASSOC. CRT
	CLHI	R0,L.BUSY		:CRT BUSY?
	JN	ATTC20			:NO, ATTACH HAS FAILED

: ASSOCIATED DEVICE MUST BE A CRT (LU.T2)

	LHI	R3,10		:GET ERROR CODE
	LO	CBKDEF
	LB	R0,LUCTAB+LUCTYP,R10,	:GET ASSOC DEVICE TYPE
	CLHI	R0,LU.T2		:IS ASSOC DEVICE A CRT?
	JN	ATTC20			:NO, ATTACH HAS FAILED


: ASSOCIATED CRT DCB MUST POINT TO THIS PRT LUCB

	LHI	R3,10			:GET ERROR CODE
	LHL	R7,LUCTAB+LUCDCB,R10,	:GET DCB ENTRY FOR CRT
	CLH	R11,DCBLKS+DCBCRD,R7,	:CRT DCB POINT TO THIS PRT LUCB?
	JN	ATTC20			:NO, ATTACH FAILED

: THIS CRM 4 REQUEST MUST BE FOR A PRINTER DEVICE (LU.T1/3)

	LO	CBKDEF
	LHI	R3,10			:GET ERROR CODE
	LB	R0,LUCTAB+LUCTYP,R11,	:GET THIS DEVICE TYPE
	CHI	R0,LU.T1		:IS THIS AN LU.T1?
	JE	ATTC10			:YES
	CHI	R0,LU.T3		:NO, IS IT AN LU.T3?
	JN	ATTC20			:NO. NOT A PRINTER. ATTACH FAILED.


: PRT MUST BE IN "WAIT" STATE

ATTC10
	LHI	R3,0B			:GET ERROR CODE,"ASSOC. DEVICE
					:ALREADY IN USE"
:	LB	R0,LUCTAB+LUNSTA,R11	:GET PRT NETWORK LOGON STATE(04/07/87/CHS)
	LB	R0,LUCTAB+LUNSTA,R11,	:GET PRT NETWORK LOGON STATE(04/07/87/CHS)
	CHI	R0,L.WAIT		:PRT IN "WAIT" STATE?
	JN	ATTC20			:NO, ATTACH FAILED

: MATCH TRANSPARENCY CAPABILITY

	LHI	R3,05			:GET ERROR CODE
	LB	R0,LUCTAB+LUCFST,R11,	:GET DEVICE CONTROL BYTE
	NHI	R0,XPAREN		:GET TRANSPARENCY BIT
	LB	R8,DCBLKS+DCBFST,RDCB,	:GET REQUESTORS DEVICE CONTROL BYTE
	NHI	R8,XPAREN		:GET RQST TRANSPARENCY BIT
	XR	R0,R8			:ARE THEY THE SAME?
	JN	ATTC20			:NO, ATTACH FAILED

: MATCH DEVICE SIZE

	LHI	R3,05			:GET ERROR CODE
	LB	R0,LUCTAB+LUCFST,R11,	:GET DEVICE CONTROL BYTE
	NHI	R0,DEVFSZ		:GET DEVICE SIZE
	LB	R8,DCBLKS+DCBFST,RDCB,	:GET RQSTOR DEVICE CONTROL BYTE
	NHI	R8,DEVFSZ		:GET RQST DEVICE SIZE
	XR	R0,R8			:DEVICE SIZES MATCH?
	JN	ATTC20			:NO, ATTACH FAILED

: MATCH HOST NUMBERS

	LIS	R3,00			:GET ERROR CODE
	LH	R0,LNCTAB+LNHOST,R4,	:GET HOST NUMBER
	CLH	R0,DCBLKS+DCBAHS,RDCB,	:HOST NUMBERS MATCH?
	JN	ATTC20			:NO, ATTACH FAILED

	LHL	R10,LUCTAB+LUCPUC,R11,	:GET PUCB 
	LB	R7,PUCTAB+PULNKN,R10,	:GET LINE NUMBER
	J	ATTH70			:GO CHECK COLOR, CHARACTER SET ETC.

ATTH00
					:(F00/02/06/87/DB/END)
	
	LIS	R13,0			:INIT FINAL FAILURE CODE
	LIS	R7,0			:START FROM LINE 0
:	ATTH10:	R7 = LINE #, MATCH FOR HOST #
:	------
ATTH10
	LIS	R3,0			:FAIL REASON R3 = HOST NOT MATCHED
	LHL	R4,LNCPTR,R7,R7		:R4 = LNCTAB FOR CURRENT LINE #
	LH	R0,DCBLKS+DCBAHS,RDCB,	:GET REQUESTED HOST#
	CLH	R0,LNCTAB+LNHOST,R4,	:SAME AS THE HOST # IN THIS LINE?
	JE	ATTH20			:YES, GO TO MACTH NEXT ITEM
ATTH15
:	CR	R3,R13			:WHICH ONE IS LOWER?(4/8/86/CHS)
	LB	R0,RELFAI,R3		:..
	LB	R8,RELFAI,R13		:..
	CR	R0,R8			:WHICH ONE IS MORE CRITICAL?
	JLEFS	ATTH17			:SKIP
	LR	R13,R3			:NEW FINAL FAILURE CODE
ATTH17
	AIS	R7,1			:NEXT LINE
	CLHI	R7,NLINES		:ALL LINE CHECKED?
	JL	ATTH10			:REPEAT FOR NEXT LINE
					:(F00/02/06/87/DB/START)
					: CRM 4 IMPLEMENTATION
	LB	R0,DCBLKS+DCBDIF,RDCB,	:GET DEVICE INFO. BYTE
	THI	R0,ATTPRT		:ATTACHED PRT REQUESTED?
	JNFS	ATTH19			:YES, MUST ATTACH TO A LU WITH ATTPRT
	LH	R11,DCBLKS+DCBLUC,RDCB,	:DID AN UNATTACHED RQST FIND AN 
					:AVAILABLE ATTACHED CRT?
	JG	ATTHD0			:YES, ATTACH SUCCESSFULL
ATTH19
					:(F00/02/06/87/DB/END)
	LHL	R3,ATHTBL,R13,R13	:R3 = ATTACH FAIL MSG ADDR PTR
	LB	R0,DCBLKS+DCBDIF,RDCB,	:SEE IF REMOTE SUPPORT JAPANESE
	NHI	R0,07
	CLHI	R0,4
	JLFS	ATTH18			:NO, SKIP
	AIS	R3,2			:
ATTH18
	LHL	R3,PSEG,R3,,		:FAIL MSG ADDR
	AI	R3,PSEG			:GET FULL ADDRESS
	JR	R6			:NORMAL RETURN
: crm 4 ENTRY POINT ONLY
ATTC20					:(F00/03/24/87/DB/START)
	LR	R13,R3			:SETUP ERROR CODE REGISTER
	J	ATTH19			:(F00/03/24/87/DB/END)

:	ATTH20:	MATCH FOR APP-ID/LINE #
:	-------
:	R7 = LINE #, R4 = LNCTAB
ATTH20
	LB	R3,LNCTAB+LNRHST,R4,	:R3 = RELATIVE HOST
	LHL	R3,HSTPTR,R3,R3		:R3 = HOSTAB
	STH	R3,DCBLKS+DCBHST,RDCB,	:PUT INOT DCB
	LIS	R3,1			:FAILURE CODE = 1
	LB	R0,DCBLKS+DCBAPI,RDCB,	:IS THE APPL-ID/LINE# "WILD"?
	CLHI	R0,0FF			:YES, ALWAYS MATCH
	JEFS	ATTH25			:YES, AUTOMATIC MATCH
:IF TIMEOUT BY PHYSICAL TERMINAL USED APPL ID HAS 3-BIT LINE # IF
:WILDCARD BIT OF THIS BYTE IS ON (01/22/85 MIA).
	IF	PHTIMO
	THI	R0,APP.LW		:WILDCARD?
	JEFS	ATTH25			:MATCH IF SO
	NHI	R0,APP.LN		:LEAVE LINE # ONLY
	EI
	CR	R0,R7			:APPL-ID/LINE # MATCH ?
	JN	ATTH15			:NO, SEARCH NEXT LINE
ATTH25
	LHL	R10,LNCTAB+LNPUTB,R4,	:R10 = PUCTAB
	LIS	R8,0			:R8 = CU INDEX ON THIS LINE
ATTH27
	LB	R0,DCBLKS+DCBCUA,RDCB,	:R0 = REQUESTED CUA
	CLHI	R0,0FF			:"WILD"?
	JE	ATTH40			:YES, ALWAYS MATCH
:	ATTH30:	:MATCH REQUESTED CUA
:	------
:	R7 = LINE #, R4 = LNCTAB, R10 = PREVIOUS PUCTAB
:	R8 = CURRENT CU
ATTH30
	LIS	R3,2			:FAILURE REASON CODE = 2
	IF	LABLSW			:(03/25/85 MIA)
	CLB	R0,PUCTAB+PUCLAB,R10,	:CUA LABEL MATCH? (03/25/85 MIA)
	ELSE				:(03/25/85 MIA)
	CLB	R0,PUCTAB+PUPLAD,R10,	:CUA MATCH?
	EI				:(03/25/85 MIA)
	JEFS	ATTH40			:YES, SKIP
ATTH35
	AIS	R8,1			:NEXT CU
	AHI	R10,PUCLEN		:GET THE CURRENT PUCTAB
	CLB	R8,LNCTAB+LNMXPU,R4,	:ALL PU ON THIS LINE DONE?
	JL	ATTH27			:NO, REPEAT FOR ALL PU ON THIS LINE
	J	ATTH15			:ELSE, SEARCH NEXT LINE
ATTH40
	LHL	R11,PUCTAB+PUCLUC,R10,	:R11 = LUCTAB
	LIS	R3,0E			:FAIL REASON CODE = 0E
	LB	R0,DCBLKS+DCBRSY,RDCB,	:SNA/FNA/HNA
	CLB	R0,LUCTAB+LUCSYS,R11,	:SAME AS THIS CU
	JN	ATTH55			:NO, TRY NEXT CU
	LB	R2,PUCTAB+PUMLID,R10,	:R2 = MAX LU ID
	LHL	R9,LUCTAB+LUCT.D,R11,	:R9 =LU TOTAL ID#
	AR	R2,R9			:R2 = TOTAL MAX LU ID
	LB	R0,DCBLKS+DCBLUA,RDCB,	:R0 = REQUESTED LU (DVA)
	CLHI	R0,0FF			:"WILD"?
	JN	ATTH50			:NO, SPECIFIC REQUEST
	AIS	R9,1			:BY PASS LU 0
ATTH45					:FIND FIRST DEFINED LU
	AIS	R9,1			:NEXT ONE
	CR	R9,R2			:ALL DONE ON THIS CU
	JG	ATTH55			:YES, NEXT CU
	LH	R11,LUCPTR,R9,R9	:R11 = LUCTAB
	CLHI	R11,0FFFF		:NO SYSGEN'ED?
	JEBS	ATTH45			:TRY NEXT LU
	NHI	R11,0FFFF
	J	ATTH60			:FIND, AUTOMATIC MATCH
:	ATTH50:	MATCH REQUESTED DVA
:	------
:	R7 = LINE #, R4 = LNCTAB
:	R8 = CURRENT PU, R10 = CURRENT PUCTAB
:	R9 = CURRENT LU ID
ATTH50
	LIS	R3,3			:FAILURE REASON CODE = 3
	IF	LABLSW			:MATCH BY LU LABEL (03/25/85 MIA)
	AIS	R9,1			:SKIP LU 0
ATTH51	AIS	R9,1			:NEXT LU
	CR	R9,R2			:LAST LU?
	JGFS	ATTH55			:TRY NEXT CU IF SO
	LH	R11,LUCPTR,R9,R9	:SYSGEN'ED?
	JLBS	ATTH51			:NEXT LU IF NOT
	CLB	R0,LUCTAB+LUCLAB,R11,	:MATCH CU LABEL
	JNBS	ATTH51			:NEXT LU IF NO MATCH
	JFS	ATTH60			:OTHERWISE LU FOUND
	ELSE				:END OF MATCH BY LU LAB (03/25/85 MIA)
	CLB	R0,PUCTAB+PUMLID,R10,	:WITHIN "RANGE"?
	JG	ATTH55			:NO, NOT ON THIS CU
	AR	R9,R0			:CALCULATE 'LU ID'
	LH	R11,LUCPTR,R9,R9	:R11 = LUCTAB
	CLHI	R11,0FFFF		:NOT SYSGEN'ED?
	JE	ATTH55			:NO, SKIP
	NHI	R11,0FFFF		:ONLY HW
	CLB	R0,LUCTAB+LUCADR,R11,	:DOUBLE CHECK
	JEFS	ATTH60			:YES, MATCH
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
	EI				:(03/25/85 MIA)
ATTH55
	LB	R0,DCBLKS+DCBCUA,RDCB,
	CLHI	R0,0FF			:IF CUA IS 'WILD'
	JE	ATTH35			:THEN , SERARCH NEXT CU
	J	ATTH15			:ELSE, SEARCH NEXT LINE
:	ATTH60:	MATCH DEVICE TYPE
:	IF PRINTER IS REQUESTED LU TYPE 3 LUCB IS ASSIGNED,
:	IF CRT IS REQUESTED LU TYPE 2 LUCB IS ASSIGNED (05/07/85 MIA)
ATTH60
	LIS	R3,4			:FAILURE REASON CODE R3 = 4
:	LB	R0,DCBLKS+DCBFST,RDCB,	:GET DEVICE INF (05/07/85 MIA)
:	CLB	R0,LUCTAB+LUCFST,R11,	:SAME ? (05/07/85 MIA)
:	PRINTER ASSIGNMENT INSERTION (05/07/85 MIA)
	LB	R0,DCBLKS+DCBRFS,RDCB,	:GET DEVICE INFORMATION
	THI	R0,DVDPPR		:IS IT PRINTER?
	JE	ATTH61			:JUMP IF NOT
	LB	R0,LUCTAB+LUCTYP,R11,	:GET LU TYPE
	LO	CBKDEF
					:(F00/02/23/87/DB/START)
	CHI	R0,LU.T1		:LU TYPE 1?
	JEFS	ATTH62			:YES
					:(F00/02/23/87/DB/END)
	CHI	R0,LU.T3		:LU TYPE 3?
:
:BEGIN	(03/10/86 YLH)
:
:	JE	ATTH70			:MATCH IF SO
:	JFS	ATTH65			:OTHERWISE SEARCH NEXT LU
	JN	ATTH65			:NOT LU TYPE 3, SEARCH NEXT LU
ATTH62					:(F00/02/23/87/DB)
	XR	R0,R0			:LU TYPE 3, CLEAR THE SCREEN SUPPORT
	STB	R0,DCBLKS+DCBRUS,RDCB,	:INDICATOR
	J	ATTH70
:
:END 	(03/10/86 YLH)
:
ATTH61	LB	R0,LUCTAB+LUCTYP,R11,	:GET LU TYPE
	CHI	R0,LU.T2		:LU TYPE 2?

:	END OF PRINTER INSERTION (05/07/85 MIA)
	JE	ATTH70			:YES, SKIP
:
ATTH65
					:(F00/02/06/87/DB/START)
					: CRM 4 IMPLEMENTATION
	LB	R0,DCBLKS+DCBCRM,RDCB,	:GET CRM REQUEST TYPE
	CLHI	R0,CENCRM		:CRM 4?
	JE	ATTC20			:YES, ATTACH FAILED

					:(F00/02/06/87/DB/END)
	LB	R0,DCBLKS+DCBLUA,RDCB,	:IF REQUESTED LU 
	CLHI	R0,0FF			:IS WILD
	JE	ATTH45			:THEN SEARCH NEXT LU
	IF	LABLSW			:(03/25/85 MIA)
	J	ATTH51			:SEARCH NEXT LU (03/25/85 MIA)
	ELSE				:(03/25/85 MIA)
	J	ATTH55			:ELSE, DONE WITH THIS CU
	EI				:(03/25/85 MIA)

:	ATTH70:	MATCH COLOR
:	------
ATTH70
:VHR INSERTION. IF THIS LU OPERATES IN VHR MODE SKIP IT (01/14/86 MIA).
	IF	VHRSUP
	LB	R0,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	THI	R0,LUVHRF		:VHR FUNCTION?
	JN	ATTH65			:SKIP THIS LU IF SO
	EI
:END OF VHR INSERTION (01/14/86 MIA).
:	LIS	R3,5			:FAIL REASON CODE R3=5 (11/12/84 MIA)
	LB	R0,DCBLKS+DCBDIF,RDCB,	:GET REQUEST FST
	GL	DEVCOL
	NHI	R0,DEVCOL		:GET DEVICE COLOR BIT
:	LB	R8,LUCTAB+LUCDIF,R11,	:GET DEVICE COLOR BIT (11/12/84 MIA)
:	NHI	R8,DEVCOL		:(11/12/84 MIA)
:	XR	R0,R8			:COLOR MATCH? (11/12/84 MIA)
	LB	R3,LUCTAB+LUCDIF,R11,	:GET DEVICE COLOR BIT (11/12/84 MIA)
	NHI	R3,DEVCOL		:(11/12/84 MIA)
	XR	R0,R3			:COLOR MATCH? (11/12/84 MIA)
	LIS	R3,5			:FAILURE REASON 5 (11/12/84 MIA)
	LR	R0,R0			:COLOR MATCH? (11/12/84 MIA)
	JN	ATTH65			:NO, SERACH NEXT LU OR CU
:	ATTH75:	MATCH CHARACTER SET
:	------
ATTH75
	LB	R0,DCBLKS+DCBDIF,RDCB,	:GET REQUEST FST
	NHI	R0,CHRSET		:GET CHAR SET BITS
	LB	R3,LUCTAB+LUCDIF,R11,	:GET DEVICE CHAR SET BITS
	NHI	R3,CHRSET		:...
:	CR	R0,R3			:ACCEPT IT'S SUBSET(4/15/86/CHS)
:	JLEFS	ATTH80			:...(4/15/86/CHS)
	XR	R0,R3			:NSC DECIDE TOHAVE EXACT MATCH(4/15/86/CHS)
	JEFS	ATTH80			:MATCH.. (4/15/86/CHS)
	LIS	R3,0D			:FAILURE REASON 0D
	J	ATTH65			:TO SEARCH NEXT LU OR CU
:	ATTH80:	CHECK DEVICE READY, NOT ACTIVATED, NOT READY, IN USE
:	------
ATTH80
:	LB	R8,LUCTAB+LUPSTA,R11,	:GET DEVICE STATE (11/12/84 MIA)
:	LB	R3,DEVSTA,R8		:(11/12/84 MIA)
	LB	R3,LUCTAB+LUPSTA,R11,	:GET DEVICE STATE (11/12/84 MIA)
	LB	R3,DEVSTA,R3,		:(11/12/84 MIA)
	LR	R3,R3			:IF FAILURE CODE R3 NOT 0
	JN	ATTH65			:SEARCH NEXT LU OR CU
::::
:	CHECK IF THE HOST RESPONDED TO ALL OUR SSCP-LU MESSAGES.
:	SOMETIMES THE HOST DOES NOT REPOND, THE USER ZAPS MANUALLY AND
:	TRIES AGAIN. WE SHOULD PREVENT USING THIS LU UNTIL SSCP-LU
:	SESSION ALLOWS TO SEND DATA. (10/30/85 MIA)
	LO	CBKDEF
	BBLSCB	R3,LUCTAB+LUSSCB,R11,	:GET SCB POINTER
	JE	ATTH65			:SKIP LU IF NO SSCP-LU
	LH	R0,SCBBLK+SCTSNG,R3,	:GET GET PTR OF NORM SEND CT
	CLH	R0,SCBBLK+SCTSNR,R3,	:CORRELATION TABLE EMPTY?
	JEFS	ATTH81			:OK IF SO
	LIS	R3,9			:FAILURE REASON 9
	J	ATTH65			:TRY NEXT CU/LU

:	END OF INSERTION TO CHECK SSCP-LU. (10/30/85 MIA)

ATTH81	LIS	R3,7			:ASSUME IN USE
	LHL	R0,LUCTAB+LUCDCB,R11,	:ALREADY ATTACH
	JN	ATTH65			:SEARCH NEXT LU OR CU
:	ATTH90:	USER AUTHORIZED TO ATTACH?
:	------

:	ATTHA0:	ASSOCIATED DEVICE 
:	------


:	DEVICE FOUND, ATTACH DCB TO LU (DEVICE)
:	STH	RDCB,LUCTAB+LUCDCB,R11,	:(F03/11/12/87/DB)PUT DCB ADDR INTO LUCTAB
	STH	R4,DCBLKS+DCBLNC,RDCB,	:PUT LNCTAB INTO DCB
	STH	R10,DCBLKS+DCBPUC,RDCB,	:PUT PUCTAB INTO DCB
	STH	R11,DCBLKS+DCBLUC,RDCB,	:PUT PUCTAB INTO DCB
	STB	R7,DCBLKS+DCBLIN,RDCB,	:LINE #
					:(F00/02/06/87/DB/START)
:	ATTHC0:	ATTACHED PRINTER REQUEST CHECKING
:	-------

	LB	R0,DCBLKS+DCBCRM,RDCB,	:GET CRM REQUEST TYPE?
	CLHI	R0,CENCRM		:CRM 4?
	JN	ATTHC1			:NO, CHECK ATTACHED PRT BIT
	LHI	R0,L.BUSY		:YES
	STB	R0,LUCTAB+LUNSTA,R11,	:PRT LOGON STATE = "BUSY"
	J	ATTHD0			:COMPLETE SUCCESSFULL ATTACH
ATTHC1
	LB	R0,DCBLKS+DCBDIF,RDCB,	:GET DEVICE INFO BYTE
	THI	R0,ATTPRT		:ATTACHED PRINTER REQUESTED?
	JNFS	ATTHC2			:YES, CHECK IF ONE IS AVAILABLE
: REQUESTING DEVICE WITHOUT ATTACHED PRINTER
	LB	R0,LUCTAB+LUCDIF,R11,	:NO
	THI	R0,ATTPRT		:DOES THIS LU HAVE AN ATTACHED PRINTER?
	JE	ATTHD0			:NO, ATTACH SUCCESSFULL
	J	ATTH65			:YES, BEFORE ATTACHING THIS LU TRY TO
					:FIND ONE WITHOUT ATT PRT
: REQUESTING DEVICE WITH ATTACHED PRINTER
ATTHC2
	LHI	R3,0A			:GET ERROR CODE
	LB	R0,LUCTAB+LUCDIF,R11,	:GET DEVICE INFO BYTE
	THI	R0,ATTPRT			:PRINTER ATTACHED?
	JE	ATTH65			:NO, GO LOOK FOR ANOTHER CRT LU
:
:
:	FNDPRT: FIND AN AVAILABLE PRINTER ATTACHED TO THIS CRT LU.
:	-------

FNDPRT
	ST	R2,D2SAVE,,		:SAVE REGISTER
	ST	R8,D8SAVE,,		:...
	ST	R9,D9SAVE,,		:...
	LIS	R7,0			:START WITH FIRST LINE
FNDP00
	LIS	R8,0			:START WITH FIRST CONTROL UNIT
FNDPR0
	LHL	R4,LNCPTR,R7,R7		:GET LNCTAB ENTRY
	LHL	R10,LNCTAB+LNPUTB,R4,	:GET PUCTAB ENTRY

:FIND PU WITH SAME LABEL (IF LABLSW) OR ADDRESS AS REQUESTING CRT LU

FNDPR1
	LHL	R3,DCBLKS+DCBPUC,RDCB,	:GET PUCTAB FOR CRT LU
	IF	LABLSW	
	LB	R0,PUCTAB+PUCLAB,R3,	:GET CRT LU LABEL
	CLB	R0,PUCTAB+PUCLAB,R10,	:DOES RQST LU HAVE SAME PU LABEL?
	ELSE
	LB	R0,PUCTAB+PUPLAD,R3,	:GET CRT LU ADDRESS
	CLB	R0,PUCTAB+PUPLAD,R10,	:DOES RQST LU HAVE SAME PU ADDRESS?
	EI
	JE	FNDPR2			:YES, GO DO MORE CHECKS ON THIS LU

: ADVANCE TO NEXT CU
FNDPRC
	AIS	R8,1			:NEXT CU
	AHI	R10,PUCLEN		:GET PUCTAB ENTRY
	CLB	R8,LNCTAB+LNMXPU,R4,	:LAST CU?
	JL	FNDPR1			:NO, GO CHECK
	AIS	R7,1			:YES, GET NEXT LINE
	CLHI	R7,NLINES		:LAST LINE?
	JL	FNDP00			:NO, GO CHECK
	LIS	R3,0B			:GET ERROR CODE
	L	R2,D2SAVE,,		:RESTORE REGISTERS
	L	R8,D8SAVE,,		:...
	L	R9,D9SAVE,,		:...
	LB	R7,DCBLKS+DCBLIN,RDCB,	:GET LINE #
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCTAB ENTRY
	LHL	R10,DCBLKS+DCBPUC,RDCB,	:GET PUCTAB ENTRY
	LIS	R0,0
	STH	R0,LUCTAB+LUCDCB,R11,	:CLEAR DCB POINTER
	J	ATTH65			:GO CHECK NEXT CRT LU

:SET UP REGISTERS FOR FIRST LU ON THIS PU
FNDPR2
	LHL	R11,PUCTAB+PUCLUC,R10,	:GET LUCTAB ENTRY
	LB	R2,PUCTAB+PUMLID,R10,	:GET MAX LU ID
	LHL	R9,LUCTAB+LUCT.D,R11,	:GET LU TOTAL ID #
	AR	R2,R9			:FIND TOTAL MAX LU ID
	AIS	R9,1			:BYPASS LU(0)

: ADVANCE TO NEXT LU FOR CHECKING
	LHI	R3,0C			:GET ERROR CODE
FNDPRL
	AIS	R9,1			:NEXT LU
	CR	R9,R2			:LAST LU ON CU?
	JG	FNDPRC			:YES, FIND NEXT CU
	LH	R11,LUCPTR,R9,R9	:GET LUCTAB ENTRY FOR THIS LU
	CLHI	R11,0FFFF		:HAS IT BEEN DEFINED?
	JEBS	FNDPRL			:NO, GO TO NEXT LU
	NHI	R11,0FFF		:R11 = LUCTAB ENTRY FOR LU

:FIND LU WITH SAME LABEL (IF LABLSW) OR ADDRESS AS REQUESTING CRT LU
FNDPR4
	LHL	R3,DCBLKS+DCBLUC,RDCB,	:GET CRT LUCB 
	IF	LABLSW	
	LB	R0,LUCTAB+LUCLAB,R3,	:GET CRT LABEL
	CLB	R0,LUCTAB+LUCLAB,R11,	:DO LABELS MATCH?
	ELSE
	LB	R0,LUCTAB+LUCADR,R3,	:GET CRT ADDRESS
	CLB	R0,LUCTAB+LUCADR,R11,	:DO ADDRESSES MATCH?
	EI
	JN	FNDP0C			:NO, GO CHECK NEXT LU

: MAKE SURE LU FOUND IS LU.T1/3

	LO	CBKDEF
	LB	R3,LUCTAB+LUCTYP,R11,	:GET DEVICE TYPE
	CLHI	R3,LU.T1		:LU.T1?
	JE	FNDPR5			:YES
	CLHI	R3,LU.T3		:LU.T3?
	JN	FNDP0C			:NO, GO CHECK NEXT LU


: MAKE SURE PRT LU IS IN "IDLE" STATE
FNDPR5
	LB	R3,LUCTAB+LUNSTA,R11,	:GET LOGON STATE
	CLHI	R3,L.IDLE		:PRT LU IN IDLE?
	JE	FNDPR6			:YES, DONE CHECKING
FNDP0D
	LHI	R3,0D			:GET ERROR CODE
	J	FNDPRL		
FNDP0C
	LHI	R3,0C			:GET ERROR CODE
	J	FNDPRL
:	LINGRP: LINE GRAPHIC CHARACTER
:	------
:	IF WILDCARD( I.E. 0FF) RETURN PROPER LINE GRAPHIC CHARATER
LINGRP	BC	40,0C1,0C2,0C3,0C4,0C5,0C6,0C7
	
: AN AVAILABLE PRINTER DEVICE HAS BEEN FOUND TO ATTACH TO THE REQUESTING
: CRT DEVICE. PUT CRT IN BUSY STATE AND PRT IN IDLE STATE.
FNDPR6
	STH	R11,DCBLKS+DCBCRD,RDCB,	:SAVE PRT LUCB IN CRT DCB
	LHI	R0,L.WAIT		:PRT NETWORK LOGON STATE = WAIT
	STB	R0,LUCTAB+LUNSTA,R11,	:...
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET CRT LUCB
	LHI	R0,L.BUSY		:CRT LOGON STATE = BUSY
	STB	R0,LUCTAB+LUNSTA,R11,	:...
	L	R2,D2SAVE,,		:RESTORE REGISTERS
	L	R8,D8SAVE,,		:...
	L	R9,D9SAVE,,		:...

: ATTACH WAS SUCCESSFULL

ATTHD0
	LB	R7,DCBLKS+DCBLIN,RDCB,	:RESTORE LINE #
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:RESTORE LUCB
	STH	RDCB,LUCTAB+LUCDCB,R11,	:(F03/11/12/87/DB) STORE DCB PTR
	LHL	R10,DCBLKS+DCBPUC,RDCB,	:RESTORE PUCB
	LHL	R4,DCBLKS+DCBLNC,RDCB,	:RESTORE LNCB

					:(F00/02/06/87/DB/END)

:	STB	R7,DCBLKS+DCBAPI,RDCB,	:APPL ID (01/15/85 MIA)
:IF PHYSICAL TIMEOUT BY TERMINAL USED APPL ID IN DCB IS REPLACED
:BY 0 IF NO TIMEOUT OVERRIDE IS REQUIRED (01/2/85 MIA).
	IF	PHTIMO
	LB	R8,DCBLKS+DCBAPI,RDCB,	:GET APPL ID
:	STB	R8,DCBLKS+DCBLIN,RDCB,	:SAVE IT(6/24/86/CHS)
	CHI	R8,0FF			:WILDCARD?
:	JEFS	ATTHB0			:JUMP IF SO(6/24/86/CHS)
	JE	ATTHB0			:JUMP IF SO(6/24/86/CHS)
	STB	R8,DCBLKS+DCBLIN,RDCB,	:SAVE IT(6/24/86/CHS)
	NHI	R8,APP.US		:GET USER CLASS
	CHI	R8,APP.OV		:TIMEOUT OVERRIDE?
	JN	ATTHB0			:JUMP IF NOT
	LIS	R3,0			:SPECIFY TIMEOUT OVERRIDE
	J	ATTHB1			:JUMP TO CONTINUE
	EI				:(F02/10/05/87/DB)
ATTHB0	LIS	R3,1			:NO TIMEOUT OVERRIDE
ATTHB1	STB	R3,DCBLKS+DCBAPI,RDCB,	:STORE INDEX IN DCB
ATTHB2
:	LB	R0,LINGRP,R7,R7		:GET LINE # GRAPHIC (6/24/86/CHS)
					:(f03/11/12/87/db/start)
	NHI	R7,0F			:MASK UNEEDED BITS
	CLHI	R7,7			:IS THIS LINE WITHIN RANGE?
	JG	ATTHB3			:NO, DON'T CONVERT LINE #
					:(F03/11/12/87/DB/END)
	LB	R0,LINGRP,R7,		:(F02/10/05/87/DB)
	STB	R0,DCBLKS+DCBLIN,RDCB,	:SAVE INTO DCBLIN (6/24/86/CHS)
ATTHB3					:(F03/11/12/87/DB)
:	EI				:(F02/10/05/87/DB)
:IF SCREEN STATUS IS MAINTAINED (NEW VERSION OF CMT AND CRT DEVICE)
:INIT LUCSCN TO LUSCRN	(80). OTHERWISE INIT IT TO 0. (02/14/86 MIA)
:LOGIC TO INIT LUCSCN TO LUSCRN TO BE CODED LATER.
:BEGIN (03/10/86 YLH)
:
	LB	R0,DCBLKS+DCBRUS,RDCB,	:IF SCREEN CONTROL IS SUPPORTED
	STB	R0,LUCTAB+LUCSCN,R11,	:THE MSB OF DCBRUS IS SET TO 1
:
:END	(03/10/86 YLH)
:
	XR	R0,R0			:CLEAR THE REGISTER
:(F03/12/07/87/DB-HS/START)
:	STB	R0,DCBLKS+DCBRUS,R11,	:INIT DCBRUS (03/10/86 YLH)
	STB	R0,DCBLKS+DCBRUS,RDCB,
:(F03/12/07/87/DB-HS/END)

:(F02/10/02/87/DB/START) REWRITE FOR SENDING CU/LU ADDRESSES IN ADDI FIELD.
:	IF	LABLSW
:	LB	R0,LUCTAB+LUCLAB,R11,	:GET LU LABEL
:	ELSE
:	LB	R0,LUCTAB+LUCADR,R11,	:GET LU ADDR
:	EI
:	STB	R0,DCBLKS+DCBLUA,RDCB,	:LU ADDR
:	LB	R0,LUCTAB+LUCFST,R11,	:GET LU'S FST(6/24/86/CHS)
:	STB	R0,DCBLKS+DCBFST,RDCB,	:DEVICE'S FST(6/24/86/CHS)
:	LB	R0,LUCTAB+LUCDIF,R11,	:GET LU'S DIF(6/24/86/CHS)
:	STB	R0,DCBLKS+DCBDIF,RDCB,	:DEVICE'S DIF(6/24/86/CHS)
:	IF	LABLSW
:	LB	R0,PUCTAB+PUCLAB,R10,	:GET CU LABEL
:	ELSE
:	LB	R0,PUCTAB+PUPLAD,R10,	:GET CU ADDR
:	EI
	LB	R0,LUCTAB+LUCADR,R11,	:GET LU ADDRESS
	STB	R0,DCBLKS+DCBADR+1,RDCB, :LU ADDR ALWAYS SENT IN ADDI FIELD
	IF	LABLSW	
	LB	R0,LUCTAB+LUCLAB,R11,	:GET LABEL IF DEFINED
	EI
	STB	R0,DCBLKS+DCBLUA,RDCB,	:LU ADDR./LU LAB SENT IN DEST. DESIG.
	LB	R0,PUCTAB+PUPLAD,R10,	:GET CU ADDRESS
	STB	R0,DCBLKS+DCBADR,RDCB,	:CU ADDR. ALWAYS SENT IN ADDI FIELD
	IF	LABLSW
	LB	R0,PUCTAB+PUCLAB,R10,	:GET LABEL IF DEFINED
	EI
	STB	R0,DCBLKS+DCBCUA,RDCB,	:CU ADDR/CU LAB SENT IN DEST. DESIG.
:(F02/10/02/87/DB/END)
	J	4,R6			:SKIP RETURN FOR DEVICE ATTACHED

:
:	DEVSTA:	TABLE FOR XLATE DEVICE STATE INTO ATTACH FAILURE CODE
:	------
DEVSTA	BC	6			:IDLE- DEVICE NOT ACTIVE
	BC	9			:PEDING ACTIVE - TRY AGAIN
	BC	0			:ACTIVE - CHECK IN USE
	BC	9			:PENDING DEACTIVE/RESET - TRY AGAIN
	BC	9			:PENDING SNA ERROR RECOVERY -TRY AGAIN
	BC	6			:LINK DOWN IN RECOVERY
	BC	6			:LINK RESET IN RECOVERY

:	ATHTBL: TABLE FOR ATTCHMANET FAILURE MESSAGES
:	------
ATHTBL	HC	ATHER1-PSEG
	HC	ATHER2-PSEG
	HC	ATHER3-PSEG
	HC	ATHER4-PSEG
	HC	ATHER5-PSEG
	HC	ATHER6-PSEG
	HC	ATHER7-PSEG
	HC	ATHER8-PSEG
	HC	ATHER9-PSEG
	HC	ATHERA-PSEG
	HC	ATHERB-PSEG
	HC	ATHERC-PSEG
	HC	ATHERD-PSEG
	HC	ATHERE-PSEG
	HC	ATHERF-PSEG
	HC	ATHERG-PSEG		:(F00/02/09/87/DB)
	HC	ATHERH-PSEG		:(F00/02/09/87/DB)

:	ATTACHMENT FAILURE MESSAGES
:	--------------------------
ATHER1	EQ	ATER1T
			:INVALID HOST NUMBER
ATHER2	EQ	ATER2T
			:APPL-ID"2FLINE# NOT AVAILABLE
ATHER3	EQ	ATER3T
			:CONTROLL UNIT NOT AVAILABLE
ATHER4	EQ	ATER4T
			:DEVICE NOT AVAILABLE
ATHER5	EQ	ATER5T
			:DEVICE WITH SPECIFIED TYPE NOT AVAILABLE
ATHER6	EQ	ATER6T
			:DEVICE WITH SPECIFIED ATTRIBUTE NOT AVAILABLE
ATHER7	EQ	ATER7T
			:DEVICE NOT ACTIVATED
ATHER8	EQ	ATER8T
			:DEVICE AREADY IN USE
ATHER9	EQ	ATER9T
			:USER NOT AUTHORIZED
ATHERA	EQ	ATERAT
			:WAIT ONE MINUTE AND TRY AGAIN
ATHERB	EQ	ATERBT
			:NO ASSOCIATED DEVICE
ATHERC	EQ	ATERCT
			:ASOCIATED DEVICE ALREADY IN USE
ATHERD	EQ	ATERDT
			:PROTOCOL NOT SUPPORTED
ATHERE	EQ	ATERET
			:DEVICE WITH SPECIFIED CHARACTER SET NOT WAVAILABLE
ATHERF	EQ	ATERFT
			:EQUIPMENT TYPE NOT SUPPORT
ATHERG	EQ	ATERGT	:(F00/02/09/87/DB)
			:ASSOCIATED CRT UNATTACHED
ATHERH	EQ	ATERHT	:(F00/02/09/87/DB)
			:INVALID ASSOCIATION

:	RELATIVE IMPORTANCE OF FAILURE CODE
:	-----------------------------------
RELFAI	BC	0,4,5,6,7,8,9,0A
	BC	0B,0C,0D,0E,1,3,2
	BC	0F,10			:(F00/02/16/87/DB)
	HS	0

	EI	(HOSIF)



	IF	CRMGSW

:
:
:	TO IMPLEMENT SEND CRM ERROR MESSAGE
:
:

:	DEFINE MESSAGE ELEMENTS
:	-------------------------

	SEG	A.DATA

:	CRERXH:	IIX DATA HEADER
:	------
	HS	0
CRERXH	HC	0008
	BC	0C0,94,00,00,00,00,00,00

:	CRERHS:	SNA HEADER
:	------
	HS	0
CRERHS	HC	0009
	BC	2C,00,00,00,00,00,00,00,00

:	CRERHB:	BSC HEADER
:	------
	HS	0
CRERHB	HC	0001
	BC	ESC.

:	CRERSH:	3270 DS HEADER
:	------
	HS	0
CRERSH	HC	0006
	BC	WCMD,WCCK,SBA.,00,00,SF.

:	CRERAT:	ATTRIBUTE BYTE(S)
:	------
	HS	0
CRERAT	HC	0000
	BC	00,00

:	CREREX:	BSC TRAILER
:	------
	HS	0
CREREX	HC	0001
	BC	ETX

:	DEFINE SNA AND BSC MESSAGE CHAIN
:	--------------------------------


:	SNAMSG:	CRM ERR MSG FOR SNA NATIVE MODE
:	-------
SNAMSG	WC	CRERXH			:IIX HEADER
	WC	CRERHS			:SNA HEADER
	WC	CRERSH			:3270 DS HEADER
	WC	CRERAT			:ATTRIBUTE
	WC	00			:FOR ACTUAL MSG
	WC	00			:END OF SNA MSG

:	BSCMSG:	CRM ERR MSG FOR BSC VIRTUAL MODE
:	-------
BSCMSG	WC	CRERXH			:IIX HEADER
	WC	CRERHB			:BSC HEADER
	WC	CRERSH			:3270 DS HEADER
	WC	CRERAT			:ATTRIBUTE
	WC	00			:FOR ACTUAL MSG
	WC	CREREX			:ETX, BSC TRAILER
	WC	00			:END OF BCS MSG



	SEG	A.CODE

:	SNCRER:	SEND CRM ERROR MSG
:	------
:	INPUT:	R3 - ATTACH FAILURE MESSAGE POINTER (FULL ADDR)
:		RDCB
:	OUTPUT:
:	PRESERVED R5
SNCRER
					:(f00/03/31/87/db/start)
	ST	RDCB,DCSAVE,,		:SAVE DCB FOR EXIT
	LB	R0,DCBLKS+DCBCRM,RDCB,	:GET CRM TYPE?
	CLHI	R0,CENCRM		:CRM 4?
	JN	SNCRE7			:NO, SEND ON THIS DCB
	LH	R10,DCBLKS+DCBCRD,RDCB,	:GET CRT LUC 
	JE	SNCRE6			:NONE, DON'T SEND MESSAGE
	LH	RDCB,LUCTAB+LUCDCB,R10,	:GET CRT DCB
	JE	SNCRE6			:NONE, DONT SEND MESSAGE
SNCRE7
					:(F00/03/31/87/DB/START)
	LIS	R8,$A10			:LENGTH OF (CRERXH-5) + CRERSH + CRERAT
	LA	R10,SNAMSG,,		:ASSUME IT IS SNA
	LIS	R4,2			:MSG WILL BE ON LINE 3
	LIS	R9,9			:+CRERHS
	LIS	R0,D.BDSP		:SEE IF SNA OR BSC
	TBT	R0,DCBLKS+DCBMOD,RDCB,	:..
	JEFS	SNCRE1			:YES, SNA, SKIP
	LA	R10,BSCMSG,,		:IT IS BSC
	LHI	R4,$A21			:FOR BSC , MSG WILL BE ON LINE 22
	LIS	R9,2			:AND CRERHB+CREREX
SNCRE1
	AR	R8,R9			:TALLY LENGTH
	ST	R3,$A16,R10		:INSERT FAILURE MSG POINTER
	LHL	R0,0,R3			:GET FAILURE MSG LENGTH
	AR	R8,R0			:TALLY LENGTH
	LIS	R7,0			:START TO CALCULATE BUFFER ADDR
	LHI	R0,$A80			:ASSUME 80 COL
	MHR	R4,R0
	AR	R4,R7
	LR	R7,R4			:R4=R7 = ABSOLUTE CURSOR POSITION
	LB	R0,DCBLKS+DCBRSY,RDCB,	:SEE REMOTE IS HITACHI?
	CLHI	R0,HITACHI		:...
	JE	SNCRE2			:YES, SKIP
	NHI	R4,03F			:ONLY LAST 6 BITS
	LB	R0,BAIOIC,R4,		:2ND BYTE OF BUFF ADDR
	STB	R0,CRERSH+6,,		:..
	NHI	R7,0FC0			:GET FIRST 6 BITS
	SRHLS	R7,6			:ADJUST
	LB	R0,BAIOIC,R7,		:1ST GRAPHIC
	STB	R0,CRERSH+5,,		:..
	LIS	R0,1			:1 BYTE OF ATTRIBUTE CHAR
	STH	R0,CRERAT,,
	LHI	R0,ATPND
	STB	R0,CRERAT+2,,
	J	SNCRE3			:SKIP TO CONTINUE
SNCRE2
	NHI	R4,01F			:LAST 5 BITS ONLY
	OHI	R4,0E0			:TURN ON FIRST 3 BITS
	STB	R4,CRERSH+5,,		:1ST CHAR
	SRHLS	R7,5			:1ST 6 BITS
	OHI	R7,0C0			:TURN ON FIRST 2 BITS
	STB	R7,CRERSH+6,,		:2ND CHAR
	LIS	R0,2			:2 BYTES OF ATTRIBUTE CHARS
	STH	R0,CRERAT,,		:..
	LHI	R0,HAPND
	STH	R0,CRERAT+2,,
	AIS	R8,1			:TTALLY ONE MORE BYTE
SNCRE3
	STB	R8,CRERXH+6,,		:UPDATE ACTUAL DATA LENGTH
	LR	R0,R8
	EXBR	R0,R0
	STB	R0,CRERXH+5,,		:UPDATE ACTUAL DATA LENGTH
	LIS	R0,3			:ISIS LENGTH =3
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT
	LHI	R2,SIIX			:SIIX
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,
	LR	R0,R8
	AIS	R0,5			:TOTAL ISIS RCD LENGTH
	LHL	R1,DCBLKS+DCBIPR,RDCB,
	LR	R2,R0
	AIS	R0,2
	JAL	R4,SLOR,,
SNCRE4
	L	R3,0,R10		:CHECK AT MSG CMD CHAIN
	JEFS	SNCRE5			:NULL, DONE, SKIP
	LHL	R2,0,R3			:R2 = MSG ELEMENT LENGTH
	AIS	R3,2			:R3 POINT OR ACTUAL MSG ELEMNT TEXT
	JAL	R5,OBS,,		:OUTPUT
	AIS	R10,4			:POINT TO NEXT ELEMENT
	JBS	SNCRE4			:LOOP
SNCRE5
	JAL	R5,ELODR,,		:END ISIS RCD
SNCRE6					:(F00/03/31/87/DB)
	L	RDCB,DCSAVE,,		:RESTORE DCB FOR RETURN
	JR	R6


	EI	(CRMGSW)


	EM
   	SUBTTL	(SNA-GIIX) ISIS/IIX GLOBAL/DIALECT GERENAL ACTIVATIONS
:GIIX00.Z00

	RA	0

	MO	.,GIIX

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	
:	11/10/87 (JK) -- ZAP INSTEAD OF CRASH ON BAD IIX DIALECT
:	06/06/84 (NCS) -- ADD ENTRIES IN DCB FOR SNA HOST DSP
:	02/29/84 (CHS) 00 Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	LO	MAIN
	LO	GBLDEF
	LO	BSUB
	LO	CBKDEF
	GL	NINPDA,CLRCIR,SNDENA,NOUTIS,NINASC,UCPMSG

:
:	THIS FILE CONTAINS:
:	A. GENERAL IIX - GLOBAL/DIALECT - PROCESSES
:	B. ACTIVE MODE IIX PROCESSES
:	C. LOGON MODE IIX PROCESSES
:

:	DEFINE TURKEL LEVEL & PROTOCOL IDS
:	------------------------------
TURLEV	EQ	1			:LEVEL 1

:	DEFINE IIX GLOBAL MESSAGE/COMMAND
:	---------------------------------
:
:	8080 SELECT DIALECT COMMAND, A LIST OF 16 BIT DIALECT VALUES FOLLOWS.
:	     THIS IS TERMINATED BY A TIIX. DIALECT 8085 IS TEMPORATY DEFINED AS
:	     THE SDLC DIALECT PROTOCOL
:	8081 SELECTED DIALECT RESPONSE, A SINGLE 16 BIT DIALECT VALUE FOLLOWS.
:	     THIS MESSAGE IS SENT ONLY IN RESPONSE TO THE SELECT DIALECT
:	     COMMAND ABOVE. A RESPONSE DIALECT VALUE OF 8080 INDICATES
:	     THAT ALL DIALECTS HAVE BEEN REJECTED.
:	8082 GATEWAY REACHED SMART HOST
:	8083 GATEWAY REACHED DUMB HOST
:	8084 NORMAL LOGON STATUS, 8BIT STATUS FOLLOWS, FORMAT IS AS IN ISIS B4
:	     MESSAGE.
:	8085 RESYNCRONIZE INTERFACE EXCHANGE. DETAILS SEE IIX DOCUMENT.
:	8086 INTERFACE ID AND VERSION, THE NEXT 16 BITS IS THE INTERFACE ID.
:	     THE FOLLOWING 16 BITS ARE THE 8 BIT VERSION AND 8 BIT REVISION
:	     NUMBERS.
:	8087 REQUEST INTERFACE ID AND VERSION
:


:	HEADER OF IIX GLOBAL MESSAGES
:	-----------------------------
IIXGBL	EQ	080

:	IIX GBLOBAL MESSAGES
:	--------------------
SELDIA	EQ	8080			:SELECT DIALECT COMMAND
DIAREP	EQ	8081			:SELECTED DIALECT RESPONSE
GTYSMT	EQ	8082			:GATEWAY REACHED SMART HOST
GTYDUM	EQ	8083			:GATEWAY REACHED DUMB HOST
NLGSTA	EQ	8084			:NORMAL LOGON STATUS
RSNIIX	EQ	8085			:RESYNCRONIZE INTERFACE EXCHANGE
IDVRPS	EQ	8086			:INTERFACE ID AND VERSION
IDVREQ	EQ	8087			:REQUEST INTERFACE ID AND VERSION

:	SUPPORTED DIALECTS
:	-------------------
ASCDIA	EQ	8081			:ASCII DIALECT
GWYDIA	EQ	8082			:TYMNET GATEWAY
X25DIA	EQ	8083			:X.25/X.75 DIALECT
DSPDIA	EQ	8084			:SNA/DSP & BSC/DSP DIALECT
SNADIA	EQ	808A			:SNA DIALECT
NULDIA	EQ	8080			:NULL DIALECT RESPONSE

:	DIALECT BIT-PRIORITY TRANSLATION DEFINITON
:	-------------------------------------------
P.ASC	EQ	2			:8081 ASCII
P.GAT	EQ	0			:8082 GATEWAY
P.X25	EQ	3			:8083 X.25/X.75
P.DSP	EQ	1			:8084 BSC/DSP & SNA/DSP
P.ERR	EQ	1			:808X ERROR

:
:BEGIN (02/24/86 YLH)
:	DEFINE CMT PRODUCT ID AND VERSION NUMBER
:
CMTID	EQ	0052			:CMT PRODUCT ID
CMT400	EQ	0400			:THIS AND LATER VERSION SUPPORT SYS/RQ
SNA300	EQ	0300			:SNA VERSION 3.00
SYSRQS	EQ	0080			:SYS/RQ KEY IS SUPPORTED
:
:END (02/24/86 YLH)
:

:	DEFINE DIALECT FOR SNA NIF
:	----------------------------
:
:	IN THE FOLLOWING ,  N#/   INDICATES # OF BYTES
:
:	DIALECT FORMAT FOR SNA DIALECT
:	EACH DIALECT MESSAGE IS CONTAINED IN ONE OR MORE ISIS DATA MESSSAGES.
:	A TYPICAL DIALECT MESSAGE IN A ISIS FORMAT IS AS FOLLOWING:
:	PORT #, BF		(SIIX INDICATOR)
:	PORT #, LENGTH OF DATA, DIAL. CODE, LENGTH OF DIAL. MSG, DIAL. MSG 1
:	PORT #, LENGTH OF DATA2, DIAL. MSG 2
:	PORT #, LENGTH OF DATA3, DIAL. MSG 3
:
:	87	CALLED ADDRESS
:		1/# OF DIGITS,  1-7/ADDRESS DIGITS
:	88	CALLING ADDRESS
:		1/# OF DIGITS,  1-7/ADDRESS DIGITS
:	89	CALL USER DATA
:		1/LENGTH,  LENGTH/CALL USER DATA
:	8A	INTERRUPT
:		1/INTERRUPT BYTE
:	8B	INTERRUPT CONFIRMATION
:		NO DATA
:	8C	NETWORK UTILITY (NOT IMPLETED FOR SDLC  DIALECT)
:		1/LENGTH,  LENGTH/UTILITY FIELD
:	8D	FACILITY
:		1/LENGTH, LENGTH/FACILITY FIELD
:	8E-90	RESERVED
:	91	RESET CONFIRMATION
:		NO DATA
:	92	CALL ACCEPT
:		1/LENGTH,  LENGTH/CALL CONNECTED PACKET
:		(CALL CONNECTED PACKET MUST BE DEFINED EXACTLY AS THAT IN CCITT
:		 AND IT MUST INCLUDE THE LENGTH FIELD FOR THE UTILITY AND 
:		 FACILITY FIELDS EVEN THEY DON'T EXIST.)
:	93	TURKEY LEVEL
:		2/TURKEY LEVEL #
:	94	DATA PACKET
:		1/DATA FLAG, 2/LENGTH, LENGTH/DATA
:		DATA FLAG =  QDRRBRRM ???
:		WHERE	Q = DATA QUALIFIED FLAG
:			D = DELIVERY CONFIRMATION FLAG
:			M = MORE DATA FLAG
:			R = RESERVED FOR FUTURE EXPANSION
:
:	95	CLEAR INDICATION
:		1/CLEAR CAUSE,  1/CLEAR DIAGNOSTIC
:	96	RESET INDICATION
:		1/RESET CAUSE,  1/RESET DIAGNOSTIC
:	97	CLEAR INFORMATION
:		UNKNOW
:	98	ABNORMALITY REPORT
:		UNKNOW
:


:	HEADER OF IIX SNA DIALECT MESSAGES
:	-----------------------------------
IIXDIL	EQ	0C0			:DIALECT MESSAGES
DIALMG	EQ	0C000			:DIALECT MESSAGES

:	IIX SNA DIALECT MESSAGES
:	-------------------------
CLDADR	EQ	87			:CALLED ADDRESS
CLNADR	EQ	88			:CALLING ADDRESS
CUSDTA	EQ	89			:CALL USER DATA
INTRUP	EQ	8A			:INTERRUPT
INTCFM	EQ	8B			:INTERRUPT CONFIRMATION
NWKUTY	EQ	8C			:NETWORK UTILITY
FACLTY	EQ	8D			:FACILITY
					:8E-90 RESERVED
RSETCF	EQ	91			:RESET CONFIRMATION
CALACP	EQ	92			:CALL ACCEPT
TKYLVL	EQ	93			:TURKEY LEVEL
DATAPK	EQ	94			:DATA PACKET
CLRIND	EQ	95			:CLEAR INDICATION
RSETID	EQ	96			:RESET INDICATION

:	Q BYTE DEFINITION
:	----------------
QBIT	EQ	80			:Q-BIT
DBIT	EQ	40			:D-BIT
MBIT	EQ	01			:M-BIT

:	DEFINE LOCAL STORAGES
:	---------------------
	SEG	A.DATA
IIXSAV	WS	1
RDCBSV	WS	1			:(F00/04/01/87/DB)
	SEG	A.CODE

:	DEFINE SPECIAL IIX CONTROL MSGS
:	---------------------------------
SIIXMG	SC	/"BF/			:ISIS SIIX MSG
TIIXMG	SC	/"C0/			:ISIS TIIX MSG

:
:	CANNED IIX SNA/SDLC DIALECT MSGS
:

	BND	2			:HLAF-WORD BOUNDARY

:	
:	DEFINE GLOBAL IIX MSGS
:

:	SELECTED DIALECT RESPONSE - NULL RESPONSE
:	-----------------------------------------
	HC	0004			:LENGTH IS FOUR
NULDMG	HC	DIAREP			:SELECTED DIALECT RESPONSE
	HC	NULDIA			:NULL DIALECT RESPONSE

:	SELECTED DIALECT RESPONSE
:	-------------------------
	SEG	A.DATA
	HC	0004			:LENGTH IS FOUR
RPDIAM	HC	DIAREP			:SELECTED DIALECT RESPONSE
	BC	80			:...
RPDIAL	BC	0			:SELECTED DIALECT

	SEG	A.CODE

:	INTERFACE ID AND VERSION RESPONSE
:	---------------------------------
	HC	0006			:LENGTH IS SIX
IFIDMG	HC	IDVRPS			:INTERFACE ID AND VERSION RESPONSE
	HC	SNA.HI			:THIS IS SNA HIF(5/10/85/CHS)
	HC	(VERSION^8)!(REVLEV)	:VERSION AND REVISION LEVEL

:	(5/10/85/CHS)
:	INTERFACE ID AND VERSION RESPONSE
:	---------------------------------
	HC	0006			:LENGTH IS SIX
IFIDTM	HC	IDVRPS			:INTERFACE ID AND VERSION RESPONSE
	HC	SNA.TI			:THIS IS SNA TIF
	HC	(VERSION^8)!(REVLEV)	:VERSION AND REVISION LEVEL
:
:BEGIN (02/24/86 YLH)
:	REQUEST PRODUCT ID AND VERSION NUMBER
:	-------------------------------------
:
	HC	002
RQPVID	HC	IDVREQ
:
:END (02/24/86 YLH)
:

:	SELECT DIALECT COMMAND
:	----------------------
	HC	DSELLN			:LENGTH OF SELECT DIALECT COMMAND
DIALSL	HC	SELDIA			:SELECT DIALECT COMMAND
	HC	DSPDIA			:BSC/DSP DIECLET
:	HC	ASCDIA			:ASCII DIALECT
DSELLN	EQ	.-DIALSL


:	
:	DEFINE IIX DIALECT FOR SNA/SDLC
:


	SEG	A.DATA

:	CALLED ADDRESS DIALECT
:	----------------------
	HC	000A			:LENGTH
CALDMG	HC	DIALMG!CLDADR		:CALLED ADDRESS DIALECT
CLDDLN	BC	0E			:NO. OF DIGITS
CLDADF	BC	01,23,45,67,89,09,87	:CALLED ADDRESS FIELD

:	CALLING ADDRESS DIALECT
:	----------------------
	HC	000A			:LENGTH
CALGMG	HC	DIALMG!CLNADR		:CALLING ADDRESS DIALECT
CLNDLN	BC	0E			:NO. OF DIGITS
CLNADF	BC	01,23,45,67,89,09,87	:CALLING ADDRESS FIELD

:	INTERRUPT DIALECT
:	-----------------
	HC	003			:LENGTH
INTPMG	HC	DIALMG!INTRUP		:INTERRUPT
	BC	0			:INTERRUPT DATA

:	INTERRUPT CONFIRMATION DIALECT
:	------------------------------
	HC	0002			:LENGTH
ITCFMG	HC	DIALMG!INTCFM		:INTERRUPT CONFRMATION

:	FACILITY PACKET
:	---------------
	HC	0003			:LENGTH
FACLMG	HC	DIALMG!FACLTY		:FACILITY
	BC	0			:NO DATA

:	RESET CONFIRMATION DIALECT
:	--------------------------
	HC	0002			:LENGTH
RSCFMG	HC	DIALMG!RSETCF		:RESET CONFIRMATION

:	CALL ACCPET PACKET
:	-------------------
:	THIS FORMAT NEED FURTHER MODIFICAION ***
	HS	0
:	HC	2			:LENGTH OF CALL ACCEPT PACKET(11/24/86/CHS)
	HC	4			:LENGTH OF CALL ACCEPT PACKET(11/24/86/CHS)
CACPTM	HC	DIALMG+CALACP		:CALL ACCEPT DIALECT CODE
	HC	0			:(11/24/86/CHS)

:	TURKEY LEVEL DIALECT
:	--------------------
	HC	0004			:LENGTH
TURKMG	HC	DIALMG!TKYLVL		:TURKEY LEVEL
	HC	TURLEV			:TURKEY LEVEL

:	CALL USER'S DATA
:	----------------
CUDDSZ	EQ	10			:LENGTH OF CALL USER DATA FIELD
	HC	CUDDSZ+2		:LENGTH
CUDAMG	HC	DIALMG!CUSDTA		:CALL USER DATA
	BC	CUDDSZ			:LENGTH OF CALL USER DATA
CUDAFD	BS	CUDDSZ			:CALL USER DATA FIELD

:	CLEAR INDICATION DIALECT
:	------------------------
	HC	0005			:LENGTH
CLIDMG	HC	DIALMG!CLRIND		:CLEAR INDICATION
CLICAU	BC	0			:CLEAR CAUSE
CLIDIA	BC	0			:CLEAR DIAGNOSTIC

:	RESET INDICATION DIALECT
:	-----------------------
	HC	0005			:LENGTH
RSETMG	HC	DIALMG!RSETID		:RESET INDICATION
RSETCA	BC	0			:RESET CAUSE
RSETDG	BC	0			:RESETT DIAGNOSTIC

	SEG	A.CODE

:
:	CONFIGURATION MACRO FOR GLOBAL IIX & DIALECT IIX MSGS
:


:	GENGIX(TABNAM): MACRO TO GENERATE GLOBAL IIX PROC TABLE
:	----------
GENGIX	MACRO(TABNAM)[
	HS	0
TABNAM	HC	GG80M-PSEG		:8080 - SELECT DIALECT
	HC	GG81M-PSEG		:8081 - SELECTED DIALECT
	HC	GG82M-PSEG		:8082 - GATEWAY REACHED SMART HOST
	HC	GG83M-PSEG		:8083 - GATEWAY REACHED DUMB HOST
	HC	GG84M-PSEG		:8084 - LOGON STATUS
	HC	GG85M-PSEG		:8085 - RESYNCHRONIZE
	HC	GG86M-PSEG		:8086 - INTERFACE ID/VERSION
	HC	GG87M-PSEG		:8087 - REQUEST INTERFACE ID/VERSION
		]

:	CHGGIX(TABNAM,GBLIIX,ACTION)
:	-------
:	MACRO TO CHANGE ENTRY OF THE GLOBAL IIX PROC TABLE
:		TABNAM - GLOBAL IIX PROC TABLE NAME
:		GBLIIX - GLOBAL IIX MESSAGES (I.E. 8080, 8081 ETC..)
:		ACTION - ACTION ROUTINE
CHGGIX	MACRO(TABNAM,GBLIIX,ACTION)[
OLDORG	EQ	.
	ORG	TABNAM+(GBLIIX-SELDIA)*2
	HC	ACTION-PSEG
	ORG	OLDORG
		]

:	GENDIX(TABNAM): MACRO TO GENERATE DIALECT IIX PROC TABLE
:	--------------
GENDIX	MACRO(TABNAM)[
	HS	0
TABNAM	HC	GD87M-PSEG		:C087 - CALLED ADDRESS
	HC	GD88M-PSEG		:C088 - CALLING ADDRESS
	HC	GD89M-PSEG		:C089 - CALL USER DATA
	HC	GD8AM-PSEG		:C08A - INTERRUPT PACKET
	HC	GD8BM-PSEG		:C08B - INTERRUPT CONFIRMATION
	HC	GD8CM-PSEG		:C08C - NETWORK UTILITY
	HC	GD8DM-PSEG		:C08D - FACILITY
	HC	GD8EM-PSEG		:C08E - RESERVED
	HC	GD8FM-PSEG		:C08F - RESERVED
	HC	GD90M-PSEG		:C090 - RESERVED
	HC	GD91M-PSEG		:C091 - RESET CONFIRMATION
	HC	GD92M-PSEG		:C092 - CALL ACCEPT
	HC	GD93M-PSEG		:C093 - TURKEY LEVEL
	HC	GD94M-PSEG		:C094 - DATA
	HC	GD95M-PSEG		:C095 - CLEAR INDICATION
	HC	GD96M-PSEG		:C096 - RESET INDICATION
	HC	GD97M-PSEG		:C097 - CLEAR INFORMATION
	HC	GD98M-PSEG		:C098 - ABNORMALITY REPORT
		]

:	CHGDIX(TABNAM,DIAIIX,ACTION)
:	-------
:	MACRO TO CHANGE ENTRY OF THE DIALECT IIX PROC TABLE
:		TABNAM - DIALECT IIX PROC TABLE NAME
:		DIAIIX - DIALECT IIX MESSAGES (I.E. 0C087, 0C088 ETC..)
:		ACTION - ACTION ROUTINE
CHGDIX	MACRO(TABNAM,DIAIIX,ACTION)[
OLDORG	EQ	.
	ORG	TABNAM+(DIAIIX-CLDADR)*2
	HC	ACTION-PSEG
	ORG	OLDORG
		]

	SUBTTL (SNA-GIIX) GLOBAL IIX MSGS GENERAL PROCESSING ROUTINES

:
:	GENERAL EXECUTING ROUTINES FOR GLOBAL IIX MSGS
:

:	8080 = SELECT DIALECT COMMAND
:	--------
GG80M	J	FSHINP

:	8081 = SELECTED DIALECT RESPONSE
:	--------
GG81M	J	FSHINP

:	8082 = GATEWAY REACHED SMART HOST
:	-------
GG82M	J	FSHINP

:	8083 = GATEWAY REACHED DUMB HOST
:	-------
:	DEFINED IN LOGON MODULE
GG83M		J	FSHINP

:	8084 = NORMAL LOGON STATUS
:	-------
GG84M	J	FSHINP

:	8085 = RESYNCRONIZE INTERFACE EXCHANGE
:	-------
:	CLEAR CIRCUIT
GG85M
	AR	R14,R2			:FLUSH ISIS/IIX MSG
	J	CLRCIR			:TO CLEAR CIRCUIT

:	8086 = INTERFACE ID AND VERSION (FOR HIF PORT)
:	-------
:	SPURIOUS, JUST FLUSH THE MESSAGE
GG86M		J	FSHINP

:	(5/10/85/CHS)
:	8087 = REQUEST INTERFACE ID AND VERSION (FOR TIF PORT)
:	-------
:	RETURN DIALECT ID = DSPDIA, AND VERSION, REVISION LEVEL
GG87MT
	AR	R14,R2			:FLUSH ANY INPUT
	LA	R9,IFIDTM-1,,		:ADDR OF INTERFACE ID MESSAGE
	JAL	R6,SNDIIX		:SEND IT
	J	IXENDN			:RETURN (NO TIMOUT)

:	8087 = REQUEST INTERFACE ID AND VERSION
:	-------
:	RETURN DIALECT ID = DSPDIA, AND VERSION, REVISION LEVEL
GG87M
	AR	R14,R2			:FLUSH ANY INPUT
	LA	R9,IFIDMG-1,,		:ADDR OF INTERFACE ID MESSAGE
	JAL	R6,SNDIIX		:SEND IT
	J	IXENDN			:RETURN (NO TIMOUT)

	SUBTTL (SNA-GIIX) IIX DIALECT GENERAL PROCESSING ROUTINES


:
:	GENERAL EXECUTING ROUTINES FOR DIALECT IIX MESSAGES
:

:	C087 = CALLED ADDRESS
:	-------
GD87M	J	FSHINP

:	C088 = CALLING ADDRESS
:	-------
GD88M	J	FSHINP

:	C089 = CALL USER DATA
:	-------
GD89M	J	FSHINP

:	C08A = INTERUPT
:	-------
:	RETURN INTERRUPT CONFIRMATION
GD8AM
	AR	R14,R2			:FLUSH IIX INPUT DATA
	LA	R9,ITCFMG-1,,		:R9 = PTR TO INTER. CONF.
	JAL	R6,SNDIIX		:TO SEND
	J	IXENDN			:END OF IIX

:	C08B = INTERRUPT CONFIRMATION
:	-------
:	NOT IMPLEMENTED, FLUSH DATA
GD8BM		J	FSHINP

:	C08C = NETWORK UTILITY
:	-------
:	NOT IMPLEMENTED, FLUSH DATA
GD8CM		J	FSHINP

:	C08D = FACILITY
:	-------
:	NOT IMPLEMENTED, JUST FLUSH MESSAGE
GD8DM		J	FSHINP

:	C08E, 808F, 8090 : RESERVED
:	---------------
:	NOT IMPLEMENTED, CRASH
GD8EM;GD8FM;GD90M
	JAL	R10,CRASH,,
	BC	0,0,0,CRINVX

:	C091 = RESET CONFIRMATION
:	-------
:	NOT IMPPLEMENTED, FLUSH DATA
GD91M		J	FSHINP

:	C092 = CALL ACCEPT
:	-----
GD92M	J	FSHINP

:	C093 = TURKEY LEVEL
:	-------
:	CHECK TURKEY LEVEL
GD93M
	J	FSHINP

:	C094 = DATA PACKET
:	------------------
GD94M
	J	FSHINP

:	C095 = CLEAR INDICATION
:	-------
GD95M	J	FSHINP

:	C096 = RESET INDICATION
:	-------
GD96M

:	C097 = CLEAR INFORMATION
:	-----
:	CLEAR CIRCUIT
GD97M
	AR	R14,R2			:FLUSH ISIS/IIX MSG
	J	CLRCIR			:TO CLEAR CIRCUIT

:	C098 = ABNORMALITY REPORT
:	------
:	NOT IMPLEMENTED, FLUSH
GD98M
	J	FSHINP

	SUBTTL	(SNA-GIIX) MISC ROUTINES


:	SNDIIX:	SEND CANNED IIX MESSAGE WITH SIIX FIRST
:	-------
:	INPUT:
:	R6 = LINK REGISTER
:	R9 = CANNED IIX MESSAGE  ADDR
:	DESTROYED: R0, R2, R4
SNDIIX
	ST	R5,IIXSAV,,		:SAVE R5
	LHL	R2,DCBLKS+DCBIPR,RDCB,	:R2 = ISI PORT #
	LA	R3,SIIXMG,,		:R3 = ADDR OF SIIX MSG
	JAL	R5,OCM,,		:SEND SIIX
	LHL	R2,DCBLKS+DCBIPR,RDCB,	:SET R2
	LR	R3,R9			:R3 = CANNED IIX MSG ADDR
	JAL	R5,OCS,,		:SEND IIX MSG
	L	R5,IIXSAV,,		:RESTORE R5
	JR	R6

:	FSHINP:	FLUSH ISIS INPUT DATA
:	------
FSHINP
	AR	R14,R2			:FLUSH DATA
	LHL	R4,DCBLKS+DCBASC,RDCB,	:INIT SUB PROC.
	STH	R4,DCBLKS+DCBINP,RDCB,	:...
	L	R5,DCBLKS+DCBRET,RDCB,	:GET FRNTND LINK REG
	JR	R5			:RETURN

:	IXENDN/IXENDT: END OF IIX INPUT WITH/WITHOUT TIMER
:	----------
:	ENTER THESE ROUTINES, THE R14 HAS BEEN UPDATED.
:	END OF IIX INPUT, RESET SUB PROC TO 'DCBASC'
:	IF ENTER FORM IXENDT, R0 = TIMEOUT VALUE
IXENDN
	LIS	R0,0
IXENDT
	LHL	R4,DCBLKS+DCBASC,RDCB,	:INIT SUB PROC.
	STH	R4,DCBLKS+DCBINP,RDCB,	:...
	L	R5,DCBLKS+DCBRET,RDCB,	:GET FRNTND LINK REG
	J	4,R5			:RETRUN AND MODIFY TIMER

	IF	VHRSUP
:SEND DIALECT RESPONSE AND TURKEY MESSAGES.
VHRTUR	LHI	R0,DSPDIA		:DSP DIALECT
	STB	R0,RPDIAL,,		:PUT IT IN CANNED MESSAGE
	LA	R9,RPDIAM-1,,		:SELECTED DIALECT
	JAL	R6,SNDIIX		:SEND IIX MESSAGE
	LA	R9,TURKMG-1,,		:TURKEY LEVEL
	JAL	R6,SNDIIX		:SEND IIX MESSAGE
	LHI	R0,L.TRKL		:WAIT FOR TRUKEY LEVEL
	STB	R0,DCBLKS+DCBSTA,RDCB,	:UPDATE LOGON STATUS
	JR	R8			:AND RETURN
	EI

	SUBTTL	(SNA-GIIX) ACTIVE MODE IIX PROCESSOR


:
:	GENERATE ACTIVE MODE IIX PROCESSING TABLE
:

	IF	TERMIF!VHRSUP
:	GLOBAL IIX TABLE FORE ACTIVAE MODE
	GENGIX(GXTACT)

	CHGGIX(GXTACT,IDVREQ,GG87MT)
					:(5/10/85/CHS)
	EI	(TERMIF!VHRSUP)

	IF	TERMIF
:	DIALECT IIX TABLE FORE ACTIVE MODE
	GENDIX(DXTACT)

	CHGDIX(DXTACT,DATAPK,AD94M)
	CHGDIX(DXTACT,CLRIND,ADT95M)

	EI	(TERMIF)

	IF	HOSTIF
:	GLOBAL IIX TABLE FORE ACTIVAE MODE
	GENGIX(GXHACT)

:	DIALECT IIX TABLE FORE ACTIVE MODE
	GENDIX(DXHACT)

	CHGDIX(DXHACT,DATAPK,AD94M)
	CHGDIX(DXHACT,CLRIND,ADH95M)

	EI	(HOSTIF)




:	AD94M:	DATA PACKET
:	------
AD94M
	J	NINPDA			:TO PROCESS DATA DIALECT

	IF	TERMIF

:	ADT95M:	CLEAR INDICATION
:	-----
ADT95M
	LHI	R0,$A2			:'DROPPED BY HOST" REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,	:FOR DISCONNECT MSG
	J	CLRCIR			:TO CLEAR CIRCUIT

	EI	(TERMIF)

	IF	HOSTIF

:	ADH95M:	CLEAR INDICATION
:	-----
ADH95M
	LHI	R0,$A3			:'DROPPED BY USER" REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,	:FOR DISCONNECT MSG
	J	CLRCIR			:TO CLEAR CIRCUIT

	EI	(HOSTIF)

	SUBTTL	(SNA-GIIX) LOGON MODE IIX PROCESSOR


:
:	GENERATE LOGON MODE IIX PROCESSING TABLE
:

	IF	TERMIF!VHRSUP

:	GLOBAL IIX TABLE FORE LOGON MODE
	GENGIX(GXTLGN)

	CHGGIX(GXTLGN,SELDIA,LG80M)
	CHGGIX(GXTLGN,GTYSMT,LG82M)
	CHGGIX(GXTLGN,GTYDUM,LG83M)
	CHGGIX(GXTLGN,NLGSTA,LG84M)
	CHGGIX(GXTLGN,IDVREQ,GG87MT)
					:(5/10/85/CHS)

:	DIALECT IIX TABLE FOR LOGON MODE
	GENDIX(DXTLGN)

	CHGDIX(DXTLGN,CALACP,LD92M)
	CHGDIX(DXTLGN,TKYLVL,LD93M)
	CHGDIX(DXTLGN,DATAPK,LD94M)
	CHGDIX(DXTLGN,CLRIND,LDT95M)

	EI	(TERMIF!VHRSUP)

	IF	HOSTIF

:	GLOBAL IIX TABLE FORE LOGON MODE
	GENGIX(GXHLGN)

	CHGGIX(GXHLGN,DIAREP,LG81M)
	CHGGIX(GXHLGN,IDVRPS,LG86M)

:	DIALECT IIX TABLE FOR LOGON MODE
	GENDIX(DXHLGN)

	CHGDIX(DXHLGN,CLDADR,LD87M)
	CHGDIX(DXHLGN,CLNADR,LD88M)
	CHGDIX(DXHLGN,CUSDTA,LD89M)
	CHGDIX(DXHLGN,TKYLVL,LDH93M)
	CHGDIX(DXHLGN,DATAPK,LD94M)
	CHGDIX(DXHLGN,CLRIND,LDH95M)

	EI	(HOSTIF)




	IF	TERMIF!VHRSUP

:	LG80M:	SELECT DIALECT
:	-----
:	COLLECT A LIST OF DIALECTS AND SET THE CORRESPONDING
:	BIT IN DCB
LG80M
	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET STATE
	CLHI	R0,L.DIAL		:CORRECT STATE?
	JN	FSHINP			:NO, FLUSH MSG
	LHI	R4,LG80M1-PSEG		:SET UP TO READ NEXT BYTE
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
LG80M1					:R0 = 1ST BYTE OF DIALECT
	EXBR	RBCC,R0			:PUT INTO '1ST' BYTE POSITION
	LHI	R4,LG80M2-PSEG		:TO READ 2ND BYTE
	JR	R5			:TO GISDI1 TO CONTINUE READING
LG80M2					:R0 = 2ND BYTE OF DIALECT
	OR	RBCC,R0			:FORM THE WHOLE HW OF DIALECT
	SI	RBCC,ASCDIA		:GET THE ADJUST INDEX
	JLFS	LG80M3			:UN-SUPPORTED DIALECT
	CLHI	RBCC,DSPDIA-ASCDIA
	JLEFS	LG80M4			:DIALECT WITHIN RANGE
LG80M3
	JAL	R10,CRASH,,
	BC	0,0,0,0FF		:DIALECT ILLEGE
LG80M4
	LB	RBCC,DIAPTY,RBCC	:TRANSLATE INTO PRIOTITIZE-BIT
	CLHI	RBCC,4			:WITHIN RANGE
	JGBS	LG80M3			:NOT SUPPORT
	SBT	RBCC,DCBLKS+DCBDIA,RDCB, :SET PRIORITIZED-BIT
	LHI	R4,LG80M1-PSEG		:GET NEXT DIALECT
	JR	R5			:TO GISID1
:	DIAPTY:	DIALECT PRORITY-BIT TRANSLATION TABLE
:	------
DIAPTY
	BC	P.ASC,P.GAT,P.X25,P.DSP
	HS	0

	EI	(TERMIF!VHRSUP)


	IF	HOSTIF
:	LG81M:	SLECTED DIALECT (HOSTIF)
:	-----
LG81M
	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET STATE
	CLHI	R0,L.DRSP		:CORRECT STATE?
	JN	FSHINP			:NO, FLUSH MSG
	LHI	R4,LG81M1-PSEG		:TO READ 1ST BYTE OF DIALECT SELECTED
	JR	R5			:TO GISID1
LG81M1					:R0 = 1ST BYTE OF DIALECT SELECTED
	EXBR	RBCC,R0			:PUT INTO 1ST 'BYTE' POSITION
	LHI	R4,LG81M2-PSEG		:TO READ 2ND BYTE
	JR	R5			:TO GISID1
LG81M2					:R0 = 2ND BYTE
	OR	RBCC,R0			:FORM DIALECT SELECTED
	SI	RBCC,ASCDIA		:ADJUST INDEX
	JLFS	LG81M3			:ILLEGAL DIALECT
	CLHI	RBCC,DSPDIA-ASCDIA
	JLE	LG81M4			:DIALECT O.K.
LG81M3
: (F02/11/10/87/JK/START)

	GL	ZAPHST,DSCHPR
	LA	R3,UCPMSG
	LHL	R2,DCBLKS+DCBIPR,RDCB,	:RPORT NUMBER
	LR	R6,R5
	JAL	R5,OCS,,
	LR	R5,R6
	JAL	R6,DSCHPR		:SEND DETACH
	LHL	R7,DCBLKS+DCBHST,RDCB,
	JAL	R6,ZAPHST		:INC FREE RPORT,DEC ACTIVE RPORT
	JAL	R6,RELDCB,,
	J	IXENDN,,
:	JAL	R10,CRASH,,
:	BC	0,0,0,0FF		:SELCTED DIALECT BAD
: (END)

LG81M4
	LHL	R4,DIAHTB,RBCC,RBCC	:GET DIALECT PROC ROUTINE
	J	PSEG,R4,,

:	DIAHTB:	PROC TABLE FOR SELECTED DIALECT
:	------
DIAHTB	HC	DIHASC-PSEG		:8081 ASCII
	HC	DIHGAT-PSEG		:8082 GATEWAY
	HC	DIHX25-PSEG		:8083 X25/X75
	HC	DIHDSP-PSEG		:8084 BSC/DSP & SNA/DSP

:	DIHDSP:	SNA/DSP & BSC/DSP
:	-----
:	SAVE DIALECT, AND SEND TURKEY LEVEL
DIHDSP
	AR	R14,2			:FLUSH ISIS/IIX MSG
	AHI	RBCC,ASCDIA		:ADJUST
	STB	RBCC,DCBLKS+DCBDIA,RDCB, :SAVE
	GL	SNHDSP
	LHI	R0,SNHDSP-PSEG		:SET UP SNA/DSP PROC.
	STH	R0,DCBLKS+DCBDSP,RDCB,
	LA	R9,TURKMG-1,,		:SEND TURKEY LEVEL
	JAL	R6,SNDIIX
	LHI	R0,L.TURK
	STB	R0,DCBLKS+DCBSTA,RDCB,
	J	IXENDT			:END OF IIX MSG WITH TIMER

:	DIHASC:	ASCII DIALECT SELECTED
:	------
:	GO PROCESS PROJECT CODE AND ENTER ASC MODE
DIHASC
:	J	ASCINP			:TO PROCESS ASC INPUT

:	DIHX25,DIHGAT
:	-------------
:	SHOULD NOT OCCUR, CRASH
DIHX25;DIHGAT
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

	EI	(HOSTIF)

	IF	TERMIF!VHRSUP

:	LG82M:	GATEWAY REACH SMART HOST
:	-----

LG82M
	LIS	R0,D.GATE		:IN GATEWAY LOGON MODE?
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JNFS	LG82M1			:YES, KIP
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
LG82M1
	LIS	R0,0
	STB	R0,DCBLKS+DCBDIA,RDCB,	:CLEAR DCBDIA BYTE
	LHI	R0,L.DIAL		:ENTER 'WAIT FOR DIALECT' STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,
:	DISCARD ANY USERNAME ECHO, NEED TO BE IMPLEMENTED
	LHI	R0,LOGTM
	J	IXENDT			:END ISIS/IIX MSG WITH TIMER

:	LG83M:	GATEWAY REACH DUMB HOST
:	-----
LG83M
	LIS	R0,D.GATE		:IN GATEWAY LOGON MODE?
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JN	IXENDN			:YES, EXIT
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	LG84M:	LOGON STATUS
:	-----
LG84M
	LHI	R4,LG84M1-PSEG		:TO READ STATUS BYTE
	JR	R5			:TO GISID1
LG84M1					:R0 = STATUS BYTE
	NHI	R0,01F			:ISOLATE STATUS CODE
	JE	IXENDN			:IF 0, EXIT
	CLHI	R0,1			:RECEIVED A "PLEASE LOG IN"?
	JN	LG84M3			:NO, SKIP
:	GATEWAY LOGON STATUS = "PLEASE LOG IN"
	LHI	R0,L.USER		:ENTER 'USERNAME SENT' STATE
	STB	R0,DCBLKS+DCBSTAT,RDCB,
	LIS	R0,D.STOR
	TBT	R0,DCBLKS+DCBMOD,RDCB,	:SOTRED LOGON MODE?
	JE	LG84M2			:NO, SKIP
LG84M0	JAL	R6,SNDLFD		:SEND USERNAME
	LHI	R0,FSHINP-PSEG		:FLUSH ECHO USER NAME
	STH	R0,DCBLKS+DCBINP,RDCB,
	L	R5,DCBLKS+DCBRET,RDCB,	:GET FRNTND LINK REG
	JR	R5			:RETURN TO FRNTND
LG84M2					:MANUAL GATEWAY LOGON
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LIS	R0,D.LERR
	RBT	R0,DCBLKS+DCBMOD,RDCB,	:DID WE JUST GET A HOST ERROR?
	JN	LG84M3			:YES, TREAT AS USERNAME ERROR
	IF	VHRSUP
	LB	R6,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	EI	(VHRSUP)
	IF	TERMIF&VHRSUP
	THI	R6,LUVHRF		:VHR FUNCTION?
	JE	LG84M4			:MUST BE TIF IF NOT
	EI	(TERMIF&VHRSUP)
	IF	VHRSUP
	THI	R6,LUMNLG		:VTR MANUAL LOGON?
	JE	LG84M0			:JUMP IF NOT

:RELEASE BUFFERS WITH VTR LOGON INFORMATION.
LG84MU	BBL	R3,DCBLKS+DCBLBA,RDCB,	:GET POINTER TO LOGON BUFFERS
	JEFS	LG84MV			:JUMP IF NONE
	JAL	R6,DLODBB		:RELASE LOGON BUFFERS
	XR	R3,R3			:CLEAR THE REGISTER
	BBST	R3,DCBLKS+DCBLBA,RDCB,	:UPDATE LOGON POINTER

:FILL IN CADR1 AND CADR2 AND SEND LOGON REPLY RU TO VTR. THIS CODE ASSUMES
:THAT REPLY RU IS 1 SEGMENT 1 ELEMENT CHAIN. IF NOT THIS CODE SHOULD BE
:CHANGED LATER.
LG84MV	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET  POINTER TO PREPARED REPLY
	LIS	R6,VHRCNT		:PREPARE CONTINUE TO VTR
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA1,R3,	:FILL CADR1
	LIS	R6,VHRCDR		:PREPARE CADR2(CD)
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:FILL CADR2
	XR	R6,R6			:CLEAR THE REGISTER
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCDE,R3,	:CLEAR ERROR CODE
	BBST	R6,DCBLKS+DCBIBH,RDCB,	:UPDATE REPLY POINTER
	LHL	R8,DCBLKS+DCBALU,RDCB,	:GET MESSAGE LENGTH
	LHI	R2,NSETEM^8!NSDTCD	:ASSUME SINGLE SEG, SINGLE RU CHAIN
	JAL	R6,QDIFSN		:SEND IT TO SNA
	J	IXENDN			:END OF INPUT
	EI
	IF	TERMIF
LG84M4	JAL	R6,PTLBH
	LA	R1,LEM17,,		:ERASE STATUS LINE
	JAL	R6,PMLB
	LHI	R2,NSINTM^8
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN
	JAL	R6,PTLBH
	LA	R1,MLGS1,,		:TO ERASE THE USID FIELD
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN
	J	IXENDN			:END ISISI/IIX INPUT WITHOUT TIMER
	EI	(TERMIF)
LG84M3					:PROCESS ERROR LOGON STATUS
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET (04/03/86/CHS)
	STB	R0,DCBLKS+DCBTMP,RDCB,
	JAL	R6,LGNERR
	J	IXENDN			:END ISIS/IIX INPUT WITHOUT TIMER

	EI	(TERMIF!VHRSUP)

	IF	HOSTIF
:
:BEGIN (02/24/86 YLH)
:	LG86M:	PRODUCT ID AND VERSION (HOSTIF)
:	-----
:	SYS/RQ KEY IS SUPPORTED ONLY BY THE CMT 0400 OR SNATIF 0300 AND
:	LATTER VERSION.
:	HERE ONLY CMT 4.00 IS CHECKED.
:
LG86M	XR	R4,R4			:ASSUME SYS/RQ KEY IS NOT SUPPORTED (02/25/87 YLH)
	STB	R4,DCBLKS+DCBRUS,RDCB,	:(02/25/87 YLH)
	LHI	R4,LG86M1-PSEG		:SET UP REENTRY ADDR AND
	JR	R5			:READ THE 1ST BYTE OF THE PRODUCT ID
:
LG86M1	EXBR	RBCC,R0			:SAVE THE 1ST BYTE OF THE PRODUCT ID
	LHI	R4,LG86M2-PSEG		:SET UP REENTRY ADDR AND
	JR	R5			:READ THE 2ND BYTE OF THE PRODUCT ID
:
LG86M2	OR	RBCC,R0			:FORM THE HW OF PRODUCT ID
	CLHI	RBCC,CMTID		:IS CMT THE TIF?
	JN	FSHINP			:NO, FLUSH THE INPUT RING
:
:	THE TIF IS CMT
:	READ AND COMPARE THE CMT VERSION NUMBER
:
LG86M3	LHI	R4,LG86M4-PSEG		:SET UP REENTRY ADDR AND
	JR	R5			:READ THE 1ST BYTE OF THE VERSION #
:
LG86M4	EXBR	RBCC,R0			:SAVE THE 1ST BYTE OF THE VERSION #
	LHI	R4,LG86M5-PSEG		:SET UP REENTRY ADDR AND
	JR	R5			:READ THE 2ND BYTE OF THE VERSION #
:
LG86M5	OR	RBCC,R0			:FORM THE HW OF VERSOIN #
	CLHI	RBCC,CMT400		:DOES THIS CMT VERSION SUPPORT SYS/RQ KEY?
	JL	FSHINP			:NO, FLUSH THE INPUT RING
:
:	SET UP THE MSB OF THE DBCRUS TO INDICATE THAT THE SYS/RQ KEY IS
:	SUPPORTED
:
	LHI	R0,SYSRQS		:INDICATE THE SYS/RQ KEY IS SUPPORTED
	STB	R0,DCBLKS+DCBRUS,RDCB,
	J	FSHINP
:
:END (02/24/86 YLH)
:
	EI	(HOSTIF)

	IF	HOSTIF

:	LD87M:	CALLED ADDRESS (HOSTIF)
:	-----
LD87M
	LIS	RBCC,0			:INIT DIGIT CNT
LD87M1
	LHI	R4,LD87M2-PSEG		:TO READ NEXT BYTE
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
LD87M2					:R0 = DATA/DIGITS PAIR
	STB	R0,DCBLKS+DCBCDA,RDCB,RBCC :SAVE IN DCB
	AIS	RBCC,1			:INCREASE BYTE CNT
	CLHI	RBCC,8			:ALREADY COLLECT 8 BYTES?
	JLBS	LD87M1			:NO, REPEAT
	LHI	R0,L.CNAD
	STB	R0,DCBLKS+DCBSTA,RDCB,
	J	IXENDN

:	LD88M:	CALLING ADDRESS
:	-----
LD88M
	LIS	RBCC,0			:INIT DIGIT CNT
LD88M1
	LHI	R4,LD88M2-PSEG		:TO READ NEXT BYTE
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
LD88M2					:R0 = DATA/DIGITS PAIR
	STB	R0,DCBLKS+DCBCNA,RDCB,RBCC :SAVE IN DCB
	AIS	RBCC,1			:INCREASE BYTE CNT
	CLHI	RBCC,8			:ALREADY COLLECT 8 BYTES?
	JLBS	LD88M1			:NO, REPEAT
	LHI	R0,L.CUDA
	STB	R0,DCBLKS+DCBSTA,RDCB,
	J	IXENDN

:	LD89M:	CALL USER DATA (HOSTIF)
:	-----
:	SAVE INFORMATION FOR THE CIRCUIT ENABLE DSP/PACKET
:	PROCESS THE CRM'S
:	ASSIGN DEVICE TO PORT
:	"NOTIFY" HOST
LD89M
	LHI	R4,LD89M1-PSEG		:TO READ CALL USER DATA SIZE
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
LD89M1					:R0 = CALL USER DATA SIZE, IGNORE
	LHI	R4,LD89M2-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
LD89M2					:R0 = PROTOCOL ID
	LIS	R4,D.BDSP		:INDICATE EITHER SNA OR BSC
	RBT	R4,DCBLKS+DCBMOD,RDCB,
	CLHI	R0,DSP.TI		:IS IT A IBM TERMINAL ID?
	JE	LD89MX			:YES, SKIP
	CLHI	R0,FNA.TI		:IS IT A FUJITSU TERMINAL PROTOCOL?
	JE	LD89MX			:YES, SKIP
	CLHI	R0,HNA.TI		:IS IT A HITACHI TERMINAL PROTOCOL?
	JN	CLRCIR			:NO, TO CLEAR THE CIRCUIT
LD89MX
	SHI	R0,DSP.TI		:MAKE INDEX
	SRHLS	R0,4			:0=IBM,=1,FUJITSU,2=HITACHI
	STB	R0,DCBLKS+DCBRSY,RDCB,	:SAVE AT DCBRSY
	LHI	R4,LD89M3-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
LD89M3					:R0 = SOURCE CUA
	STB	R0,DCBLKS+DCBRCU,RDCB,	:SAVE INTO DCB(REMOTE CUA)
	LHI	R4,LD89M4-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
LD89M4					:R0 = SOURCE DVA
	STB	R0,DCBLKS+DCBRLU,RDCB,	:SAVE INTO DCB (REMOTE DVA)
	LHI	R4,LD89M5-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
LD89M5					:R0 = DEVICE FORMAT, SIZE AND TYPE
	THI	R0,CRUSAG+SMUCRQ+EADVRQ	:DISALLOW - CRQ,MULT,ASCII
	JN	CLRCIR			:IF SO, CLEAR CIRCUIT
:	NHI	R0,0DF			:THROW ALWAY XPRENT BIT IF ANY
	STB	R0,DCBLKS+DCBRFS,RDCB,	:SAVE INTO DCB (REMOTE FST)
	STB	R0,DCBLKS+DCBFST,RDCB,	:SAVE INTO DCB
	LHI	R4,LD89M6-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
LD89M6					:R0 = DEVICE ATTRIBUTE
	THI	R0,SNATIF		:CALLER SNA DEVICE?
	JEFS	LD89MZ			:NO, SKIP
	THI	R0,SNASRQ		:SNA DEVICE WITH SYS/RQ?
	JEFS	LD89MY			:JUMP IF NOT
	LHI	R4,SYSRQS		: (03/03/87 YLH)
	STB	R4,DCBLKS+DCBRUS,RDCB,	: (03/03/87 YLH)
LD89MZ	LIS	R4,D.BDSP		:SET TO DSP/VH MODE
	SBT	R4,DCBLKS+DCBMOD,RDCB,	:DSP/VH
LD89MY
	NHI	R0,@SNATIF		:MASK OFF SNATIF BIT
	STB	R0,DCBLKS+DCBRIF,RDCB,	:SAVE INTO DCB (REMOTE DIF)
	NHI	R0,@SNASRQ		:MASK OFF SNASRQ BIT
	STB	R0,DCBLKS+DCBDIF,RDCB,	:SAVE INTO DCB
	LHI	R4,LD89M7-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
LD89M7					:R0 = CRM#
	CLHI	R0,MAXCRM		:WITHIN RANGE
	JG	CRM0PR			:NO, ERROR
	STB	R0,DCBLKS+DCBCRM,RDCB,	:SAVE INTO DCB
	LR	R4,R0			:MOVE R0 TO R4
	LHI	R0,0FF			:0FF FOR WILD CARD SEARCH
	STB	R0,DCBLKS+DCBAPI,RDCB,	:SET CRM API
	STB	R0,DCBLKS+DCBCUA,RDCB,	:SET CRM DESTI. CUA
	STB	R0,DCBLKS+DCBLUA,RDCB,	:SET CRM DESTI. LUA
	LHL	R4,CRMTBL,R4,R4		:GET CRM PROC ROUTINE
	J	PSEG,R4,

:	CRMTBL:	CRM PROC TABLE
:	------
CRMTBL	HC	CRM0PR-PSEG		:CRM 0 - ILLEGAL
	HC	CRM1PR-PSEG		:CRM 1
	HC	CRM2PR-PSEG		:CRM 2
	HC	CRM3PR-PSEG		:CRM 3
	HC	CRM4PR-PSEG		:CRM 4

:	CRM0PR:	CRM0 - ILLEGAL
:	------
CRM0PR
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	CRM1PR:	CRM 1
:	------
:	APPL ID = LINE #, SOURCE(REMOTE) CUA AND SOURCE(REMOTE) DVA
:		AS CU & DEV ADDR
CRM1PR
	LHI	R4,CRM1P1-PSEG		:TO READ APPL ID
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
CRM1P1					:R0 = APPL ID
	IF	PHTIMO			:(6/13/86/CHS)
	LR	R0,R0			:APP ID = 0 ?
	JEFS	CRM1P2			:YES, AREADY SET 'WILD', SKIP
	EI
	STB	R0,DCBLKS+DCBAPI,RDCB,
CRM1P2
	LB	R0,DCBLKS+DCBRCU,RDCB,	:SOURCE ADDRE -> REQUEST ADDR
	STB	R0,DCBLKS+DCBCUA,RDCB,	:...
	LB	R0,DCBLKS+DCBRLU,RDCB,	:...
	STB	R0,DCBLKS+DCBLUA,RDCB,	:...
	J	LD89M8			:TO CONTINUE

:	CRM2PR/CRM3PR:	CRM 2 & CRM 3
:	---------------
:	FOR CRM 2, LINE , CU, DEVICE ARE SPECIFIED
:	FOR CRM 3, LINE OR CU OR DEVICE MAY BE WILD
CRM2PR;CRM3PR
	LHI	R4,CRM2P1-PSEG		:TO READ NEXT BYTE
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
CRM2P1					:R0 = CRM APP ID
	IF	PHTIMO			:(6/13/86/CHS)
	LR	R0,R0			:IF 0, THEN 'WILD'
	JEFS	CRM2P2			:YES, SKIP
	EI
	STB	R0,DCBLKS+DCBAPI,RDCB,
CRM2P2	LHI	R4,CRM2P3-PSEG
	JR	R5			:TO GISDI1 TO REAND NEXT BYTE
CRM2P3					:R0 = CRM CUA
	LR	R0,R0			:IF 0, THEN 'WILD'
	JEFS	CRM2P4			:YES, SKIP
	IF	1-LABLSW		:(09/23/85 MIA)
	LIS	R4,D.BDSP		:IF BSC/DSP, ALWAYS WILD
	TBT	R4,DCBLKS+DCBMOD,RDCB,
	JNFS	CRM2P4			:BSC/DSP, SKIP
	EI				:(09/23/85 MIA)
	STB	R0,DCBLKS+DCBCUA,RDCB,
CRM2P4	LHI	R4,CRM2P5-PSEG
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
CRM2P5					:R0 = CRM DEST DVA
	LR	R0,R0			:IF 0, THEN 'WILD'
	JEFS	CRM2P6			:YES, SKIP
	IF	1-LABLSW		:(03/26/85 MIA)
	LIS	R4,D.BDSP		:IF BSC/DSP, ALWAYS WILD
	TBT	R4,DCBLKS+DCBMOD,RDCB,
	JNFS	CRM2P6			:BSC/DSP, SKIP
	EI				:(03/26/85 MIA)
	STB	R0,DCBLKS+DCBLUA,RDCB,
CRM2P6	J	LD89M8

:	CRM4PR:	CRM 4
:	------
:(F00/02/04/87/DB/START) - WRITTEN FOR CRM 4 IMPLEMENTATION. THE LUCTAB
:	ENTRY FOR THE DESIRED PRINTER (PRT) IS STORED INTO 'DCBLUC'. THE
:	LUCTAB ENTRY FOR THE ASSOCIATED TERMINAL (CRT) IS STORED INTO
:	'DCBCRD'.
:	FOR CRM 4, DESTINATION DESIGNATOR IS 7 BYTES, THE FORMAT IS
:	AS FOLLOWS:
:	          <-------- DESTINATION DESIGNATOR ----------------------->
:                                               <-ADDITIONAL DEST. DESIG.->
:	 / CRM 4 / 00 / 00 / DEST. DEVICE (00) / CU &LU ADDR / CRT CB PTR /
:						   ENTRY        ENTRY
:LENGTH IN BYTES   1     1           1                2           2
:
CRM4PR
	LIS	R3,05			:LOOP COUNTER
CRM4P0
	LHI	R4,CRM4P1-PSEG		:GET FIRST 3 BYTES OF DEST. DESIGNATOR
	JR	R5			:
CRM4P1
	SIS	R3,01			:HAVE FIRST 5 BYTES BEEN PROCESSED?
	JN	CRM4P0			:NO, GO GET MORE
	LHI	R4,CRM4P2-PSEG		:YES
	JR	R5			:GET PRT LUCTAB ENTRY
CRM4P2
	STB	R0,DCBLKS+DCBCRD,RDCB,	:STORE FIRST BYTE OF CRT DCB
	LHI	R4,CRM4P3-PSEG		:GO GET LSB OF LUCTAB ENTRY FOR CRT
	JR	R5
CRM4P3
	STB	R0,DCBLKS+DCBCRD+1,RDCB, :STORE 2ND BYTE OF CRT DCB
	J	LD89M8			:RETURN TO USER DATA PROCESSING

:
					:(F00/02/04/87/DB/END)


LD89M8
	AR	R14,R2			:FLUSH REMAINING INPUT
	LIS	R0,D.BDSP		:IF BSC/DSP AND HDPSUP, THEN OK
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JEFS	LD89M9			:NOT BSC/DSP, OK
	IF	1-HDPSUP
:	LA	R3,ATHERD		:PROTOCOL NOT SUPPORTED
	LA	R3,ATERDE		:(F02/11/17/87/DB)
	J	LD89MB			:TO INFORM REMOTE
	EI	(1-HDPSUP)
LD89M9
	JAL	R6,ATTACH		:TO ATTCH DEVICE
	J	LD89MB			:ATTACH FAILURE, SKIP (R3= ERROR MSG)
	LA	R9,CACPTM-1,,		:SEND CALL ACCEPT
	JAL	R6,SNDIIX
	JAL	R6,SNDENA		:SEND CIRCUIT ENABLE
	LHI	R0,GXHACT-PSEG		:SET UP ACTIVE MODE IIX PROC
	STH	R0,DCBLKS+DCBGIX,RDCB,
	LCS	R0,1			:INIT DCBISQ AND DCBOSQ TO 0FF
	STB	R0,DCBLKS+DCBISQ,RDCB,
	STB	R0,DCBLKS+DCBOSQ,RDCB,
	LHI	R0,L.STAT		:WAIT FOR DSP/STATUS MESSAGE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LIS	R0,D.BDSP		:SEE IF BSC/DSP
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JNFS	LD89MA			:BSC.DSP, SKIP
	LHI	R0,DXHACT-PSEG
	STH	R0,DCBLKS+DCBLIX,RDCB,
	LHI	R0,NOUTIS-PSEG		:SET UP NATIVE/ACTIVE OUTPUT
	STH	R0,DCBLKS+DCBOUT,RDCB,
	J	IXENDN			:END ISIS/IIX WITH NO TIMER
LD89MA
	IF	HDPSUP
	GL	DDHACT,BSHDSP,AHDOUP
	LHI	R0,DDHACT-PSEG
	STH	R0,DCBLKS+DCBLIX,RDCB,
	LHI	R0,BSHDSP-PSEG		:SET UP BSC/DSP PROC.
	STH	R0,DCBLKS+DCBDSP,RDCB,
	LHI	R0,AHDOUP-PSEG		:SET UP DSP/ACTIVE OUTPUT
	STH	R0,DCBLKS+DCBOUT,RDCB,
	J	IXENDN			:END ISIS/IIX WITH NO TIMER
	ELSE
	JAL	R10,CRASH,,
	BC	0,0,0,99
	EI	(HDPSUP)

LD89MB
:	MSG WILL BE SENT IN EBCDIC, IF SWITCH IS ON
:	MSG WILL NOT BE SENT IN ASCII ANY MORE
:	LHL	R2,DCBLKS+DCBIPR,RDCB,	:(02/27/86/CHS)
:	LR	R6,R5			:SAVE R5 (02/27/86/CHS)
:	JAL	R5,OCS,,		:SEND MSG IN ASCII, SO REMOTE DISPLAY 
:					:IT AS LOGON ERROR MESSAGE
:	LR	R5,R6			:..(02/27/86/CHS)
	IF	CRMGSW
	JAL	R6,SNCRER		:SEND CRM ERROR MESSAGE
					:(F00/04/01/87/DB/START)
	ST	RDCB,RDCBSV,,		:SAVE THIS DCB
	LB	R0,DCBLKS+DCBCRM,RDCB,	:GET CRM TYPE
	CLHI	R0,CENCRM		:IS THIS A CRM4 CKT?
	JN	LD89MC			:NO, ONLY SEND ONE MSG
	LHL	R10,DCBLKS+DCBCRD,RDCB,	:YES, GET LUC FOR ASSOC. CRT
	JE	LD89MC			:NO LUC
	LHL	RDCB,LUCTAB+LUCDCB,R10,	:GET DCB OF ASSOC. CRT
	JE	LD89MC			:NO DCB
	GL	SNDICR
	LHI	R0,21			:FACILITY FAILURE
	JAL	R6,SNDICR		:SEND 'FACILITY FAILURE'
LD89MC					:(F01/09/02/87/DB)
	L	RDCB,RDCBSV,,		:RESTORE PRT DCB

					:(F00/04/01/87/DB/END)
	EI
	GL	SNDFCF
	JAL	R6,SNDFCF		:'FACILITY FAILURE'
	LHI	R0,30
	J	IXENDT			:END ISIS/IIX WITH TIMER

	EI	(HOSTIF)

	IF	TERMIF!VHRSUP

:	LD92M:	CALL ACCEPT (TERMIF)
:	-----
LD92M	AR	R14,R2			:ADVANCE GET POINTER (06/30/86 MIA)
	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET CURRENT CIRCUIT STATE
	CLHI	R0,L.CACP		:WAITING FOR CALL ACCEPT?
	JN	LD92M1			:NO, SKIP
	JAL	R6,RLOGBB,,		:DELETE LOGON BB, IF ANY(12/14/87 jk)
:	JAL	R6,RLOGBB		:DELETE LOGON BB, IF ANY
	LHI	R0,GXTACT-PSEG		:ENTER ACTIVE MODE IIX PROC.
	STH	R0,DCBLKS+DCBGIX,RDCB,
	IF	VHRSUP!VTISUP
	LHL	R6,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
:	LB	R6,LUCTAB+LUCVHR,RDCB,	:GET VHR STATE (05/07/86 YLH)
	LB	R6,LUCTAB+LUCVHR,R6,	:GET VHR STATE (05/07/86 YLH)
	THI	R6,LUVHRF!LUVTIF	:VHR OR VTI?
	JE	LD92MN			:JUMP IF NOT
	GL	DDTACT,ETXBIT
	LHI	R0,DDTACT-PSEG		:SET VIRTUAL MODE ACTIVE TABLE
	STH	R0,DCBLKS+DCBLIX,RDCB,	:SAVE IT IN DCB
	LHI	R0,ETXBIT		:INIT DSP INPUT STATUS
	STB	R0,DCBLKS+DCBICT,RDCB,	:UPDAT DCB
	THI	R6,LUVHRF		:VHR FUNCTION?
	JE	LD92ME			::JUMP IF NOT
	EI	(VHRSUP!VTISUP)
	IF	VHRSUP
	GL	SNRDSP
	LHI	R0,SNRDSP-PSEG		:SET UP VHR DSP PROCESSING TBL
	STH	R0,DCBLKS+DCBDSP,RDCB,	:SAVE IT IN DCB
	EI
	IF	TERMIF&VHRSUP
	JFS	LD92ME			:JUMP TO CONTINUE
	EI
LD92MN	EQ	.
	IF	TERMIF
	LHI	R0,DXTACT-PSEG		:...
	STH	R0,DCBLKS+DCBLIX,RDCB,
	EI
LD92ME	LHI	R0,NINASC-PSEG		:DISCARD ASCII DATA FROM NOW ON
	STH	R0,DCBLKS+DCBASC,RDCB,
	LHI	R0,L.CENA		:WAIT FOR CIRCUIT ENABLE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	J	IXENDT			:RETRUN WITH TIMER

:	CRASH NOW, NEED TO SEND CLEAR CAUSE AND REASON LATER
LD92M1
	JAL	R10,CRASH,,		:
	BC	0,0,0,80


:	LD93M:	TURKEY LEVEL (TERMIF)
:	-----
LD93M
	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET STATE
	CLHI	R0,L.TRKL		:'WAITING FOR TURKEY LEVEL'?
	JN	FSHINP			:NO, FLUSH MSG
	LHI	R4,LD93M0-PSEG		:READ IN 1ST BYTE OF TURLEV
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
LD93M0
	LHI	R4,LD93M1-PSEG		:READ THE 2ND BYTE OF TURLEV
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
LD93M1					:R0 = 2ND BYTE OF TURLEV
	CLHI	R0,TURLEV		:TURKY LEVEL MATCH?
	JN	CLRCIR			:NO, TO CLEAR CIRCUIT
:	SEND CALLED ADDRESS
	LIS	R6,0
LD93M2	LB	R0,DCBLKS+DCBCDA,RDCB,	:MOVE DATA FROM DCB TO ..
	STB	R0,CLDDLN,,
	AIS	R6,1
	CLHI	R6,8			:1/# OF DIGITS, 7/ADDR DIGITS
	JLBS	LD93M2
	LA	R9,CALGMG-1,,		:SEND CALLING ADDRESS
	JAL	R6,SNDIIX
:	SEND CALLING ADDRESS
	LIS	R6,0
LD93M3	LB	R0,DCBLKS+DCBCNA,RDCB,	:MOVE DATA FROM DCB TO ..
	STB	R0,CLNDLN,,
	AIS	R6,1
	CLHI	R6,8			:1/# OF DIGITS, 7/ADDR DIGITS
	JLBS	LD93M3
	LA	R9,CALDMG-1,,		:SEND CALLED ADDRESS
	JAL	R6,SNDIIX
:	SEND FACILITY
	LA	R9,FACLMG-1,,		:SEND FACILITY
	JAL	R6,SNDIIX
:	SEND CALL USER DATA
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC
	LB	R0,LUCTAB+LUCSYS,R11,	:R0 = SYSTEM TYPE
	SLHLS	R0,4			:S0 = 57, S1= 67, S3 = 77
	AHI	R0,DSP.TI		:TERMINAL INITIALTED CALL
	STB	R0,CUDAFD+CUDPID,,
	LB	R0,DCBLKS+DCBCUA,RDCB,	:GET CU ADDR
	STB	R0,CUDAFD+CUDSCU,,
	LB	R0,DCBLKS+DCBLUA,RDCB,	:GET LU (DEVICE) ADDR
	STB	R0,CUDAFD+CUDSLU,,
	LB	R0,DCBLKS+DCBFST,RDCB,	:GET FORMAT, SIZE & TYPE
	STB	R0,CUDAFD+CUDCBT,,
	LB	R0,DCBLKS+DCBDIF,RDCB,	:GET DEVICE ATTRIBUTES
:	IF	VHRSUP!VTISUP		: (02/26/87 YLH)
	IF	VHRSUP			: (02/26/87 YLH)
	LB	R4,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
:	THI	R4,LUVHRF!LUVTIF	:VHR OR VTI? (02/26/87 YLH)
	THI	R4,LUVHRF		:VHR? (02/26/87 YLH)
	JN	LD93MX			:JUMP IF SO
	EI
	IF	VTISUP			: (02/26/87 YLH)
	LB	R4,LUCTAB+LUCVTI,R11,	:GET VTI STATE BYTE (02/26/87 YLH)
	THI	R4,LUVTIF		:VTI? (02/26/87 YLH)
	JEFS	LD93M4			:NO (02/26/87 YLH)
	THI	R4,LUSRQF		:VTI WITH SYS/RQ SUPPORTED? (02/26/87 YLH)
	JEFS	LD93MX			:JUMP IF NO (02/26/87 YLH)
	OHI	R0,SNASRQ		:INDICATE IT IF YES. (02/26/87 YLH)
	EI
LD93M4	OHI	R0,SNATIF		:WE WANT TO TALK NATIVE (02/26/87 YLH)
:
LD93MX	STB	R0,CUDAFD+CUDDIF,,
	LB	R4,DCBLKS+DCBCRM,RDCB,	:GET CRM #
	STB	R4,CUDAFD+CUDCRM,,
	LHL	R4,DSP93D,R4,R4		:GET PROCESS ROUTINE
	J	PSEG,R4,

:	DSP93D:	CRM PROCESS TABLE
:	-------
DSP93D	HC	LD93M4-PSEG		:CRM 0 - ILLEGAL
	HC	LD93M5-PSEG		:CRM 1
	HC	LD93M6-PSEG		:CRM 2
	HC	LD93M6-PSEG		:CRM 3
	HC	LD93M7-PSEG		:CRM 4

:	CRM0 - ILLEGAL
LD93M4
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	CRM1
LD93M5
	LB	R0,DCBLKS+DCBAPI,RDCB,	:GET APPLICATION ID
	STB	R0,CUDAFD+CUDDDF+CRM1AP,,
	LIS	R6,7			:START INDEX TO FILL W/ZERO
	J	LD93M8

:	CRM2 & CRM 3
LD93M6
	LB	R0,DCBLKS+DCBAPI,RDCB,	:GET APPLICATION ID
	STB	R0,CUDAFD+CUDDDF+CRM2AP,,
	LB	R0,DCBLKS+DCBRCU,RDCB,	:DESTINATION CUA
	STB	R0,CUDAFD+CUDDDF+CRM2DC,,
	LB	R0,DCBLKS+DCBRLU,RDCB,	:DESTINATION DVA (LU)
	STB	R0,CUDAFD+CUDDDF+CRM2DD,,
	LIS	R6,9			:START INDEX TO FILL W/ZERO
	J	LD93M8

:	CRM4
LD93M7
	LIS	R0,0			:APPL ID = 0
	STB	R0,CUDAFD+CUDDDF+CRM4B0,,
	STB	R0,CUDAFD+CUDDDF+CRM4B1,, :DEST. CUA = 0
	LB	R0,DCBLKS+DCBRLU,RDCB,	:DEST. DVA FROM SCREEN
:	REMARK *** NEED TO COMPLETE


:	FILL REST OF CALL USER DATA FIELD WITH ZEROS
LD93M8
	LIS	R0,0
LD93M9
	CLHI	R6,CUDDSZ		:LENGTH OF CALL USER DATA FIELD
	JGEFS	LD93MA			:ALL DONE, SKIP
	STB	R0,CUDAFD,R6,
	AIS	R6,1
	JBS	LD93M9
LD93MA
	LA	R9,CUDAMG-1,,
	JAL	R6,SNDIIX
	LHI	R0,L.CACP		:WAIT FOR CALL ACCEPT
	STB	R0,DCBLKS+DCBSTA,RDCB,	:...
	LCS	R0,1			:INIT DCBISQ AND DCBOSQ (2/26/86/CHS)
	STB	R0,DCBLKS+DCBISQ,RDCB,	:.. (2/26/86/CHS)
	STB	R0,DCBLKS+DCBOSQ,RDCB,	:.. (2/26/86/CHS)
	LHI	R0,LOGTM
	J	IXENDT

	EI	(TERMIF)

	IF	HOSTIF

:	LDH93M:	TRUKEY LEVEL (HOSTIF)
:	------
LDH93M
	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET STATE
	CLHI	R0,L.TURK		:'WAITING FOR TURKEY LEVEL'?
	JN	FSHINP			:NO, FLUSH MSG
	LHI	R4,DH93M1-PSEG		:READ IN 1ST BYTE OF TURLEV
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
DH93M1
	LHI	R4,DH93M2-PSEG		:READ THE 2ND BYTE OF TURKLEVEL
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
DH93M2					:R0 = 2ND BYTE OF TURLEV
	CLHI	R0,TURLEV		:TURKY LEVEL MATCH?
	JN	CLRCIR			:NO, TO CLEAR CIRCUIT
	LHI	R0,L.CDAD
	STB	R0,DCBLKS+DCBSTA,RDCB,
	J	FSHINP

	EI	(HOSTIF)

:	LD94M:	DATA PACKET
:	-----
LD94M
	J	NINPDA			:TO PROCESS DATA DIALECT

	IF	TERMIF!VHRSUP

:	LDT95M:	CLEAR INDICATION
:	-----
:	IF CLEARING CAUSE 13 AND DIAGNOSTIC CODE 139, THEN
:	INVALID USERNAME AND LOGON FAILED.
:	SHOULD PRINT A MESSAGE ON SCREEN AND THEN CLEAR CIRCUIT.
LDT95M
	LIS	R0,$A2			:*** 'DROPPED BY HOST' REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,	:ZAP REASON FOR DISCONNENT MSG
	J	CLRCIR

	EI	(TERMIF!VHRSUP)

	IF	HOSTIF

:	LDH95M:	CLEAR INDICATION
:	-----
LDH95M
	LIS	R0,$A3			:*** 'DROPPED BY USER' REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,	:ZAP REASON FOR DISCONNENT MSG
	J	CLRCIR

	EI	(HOSTIF)

	FO	GBLDEF
	FO	CBKDEF

	EM
   	SUBTTL	(SNA) GDSP - IIX/DSP DIALECT GERENAL ACTIVATIONS
:GDSP00.Z00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	07/11/84 (NCS) -- MODIFY DSP(Q=1) PACKETS
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	RA	0

	MO	.,GDSP
	GL	FNLGFL

	LO	GIIX
	LO	GBLDEF
	LO	BSUB
	LO	FRNTND
	LO	MAIN
	LO	CBKDEF

:
:	THIS FILE CONTAINS:
:		A. SNA/DSP PROCESSES
:		B. BSC/DSP PROCESSES - MOVED OUT OF GDSP00 FILE
:

	SUBTTL	(SNA-GDSP) IIX/DSP DEFINITIONS


:	DEFINE SYMBOLS
:	--------------
UCN	EQ	0			:USER CIRCUIT # (ONLY 0 NOW)
BIT.FS	EQ	80			:1ST BIT OF UCN
					: 0 = NOT 1ST SEGEMENT
					: 1 = 1ST SEGMENT INDICATOR
DEVEND	EQ	0C240			:DEVICE END STATUS
NOTAVA	EQ	0C4D4			:NOT AVAILABLE (11/07/86 YLH)
SCRLST	EQ	0C4C4			:AVAILABLE AND SCREEN LOST (11/07/86 YLH)
:	DEFINE LOCAL STORAGES
:	---------------------
	SEG	A.DATA
DSPSAV	WS	1


	SEG	A.CODE

:	DEFINE SPECIAL DSP MSGS
:	------------------------

:	DSP INVITATION TO CLEAR MESSAGE
:	-------------------------------
	SEG	A.DATA
	HC	08
M.INVC	HC	DIALMG!DATAPK
	BC	80,00,03,00,01
INVCR	BC	0			:REASON FIELD

:	DSP CMD/RES UNDILIVERED
:	-----------------------
	HC	0009
M.ERR	HC	DIALMG!DATAPK
	BC	80,00,04,00
ERCODE	BC	0			:ERROR CODE
ERSSB0	BC	0			:ERROR SS BYTE 0
ERSSB1	BC	0			:ERROR SS BYTE 1

:	DSP STATUS MESSAGE
:	------------------
	HC	0009
M.STAT	HC	DIALMG!DATAPK
	BC	80,00,04,00,12
STSSB0	BC	0			:STATUS SS BYTE 0
STSSB1	BC	0			:STATUS SS BYTE 1

:	DSP ACK MESSAGE
:	---------------
	HC	0008
M.ACK	HC	DIALMG!DATAPK
	BC	80,00,03,00,14
ACKSQN	BC	0			:ACK SEQ NO

:	DSP CIRCUIT RESET MESSAGE
:	---------------------------
	HC	000A
M.CRST	HC	DIALMG!DATAPK
	BC	80,00,05,00,21
RSRPSQ	BC	0			:RESET RSP SEQ NO
RSCMSQ	BC	0			:RESET CMD SEQ NO
RSCODE	BC	0			:RESET REASON CODE

					:(F00/02/10/87/DB/START/CRM 4)
:	DSP CIRCUIT ENABLE MESSAGE LENGTHS
:	----------------------------------
:(F02/10/02/87/DB)
:CENLNG	EQ	0F			:LENGTH WITHOUT ADD. DEST. DESIG.
CEAPLN	EQ	13			:LENGTH WITH 4 BYTE ADDI.
					:(F00/02/10/87/DB/END)

:	DSP CIRCUIT ENABLE MESSAGE
:	--------------------------
:	HC	000F			:(F00/02/10/87/DB/CRM 4)
	BND	2
	BS	1			:FORCE TO ODD BOUNDARY
	BC	0
	BC	CEAPLN
M.CENA	BC	IIXDIL,DATAPK
	BC	80,00,0F,00,20
:CENADA	BS	8			:CIRCUIT ENABLE DATA
CENADA	BS	0C			:(F00/02/10/87/DB/CRM 4) 4 MORE BYTES
					:ARE NEEDED FOR ADDITIONAL DESTINATION
					:DESIGNATOR

:	DEFINE 3270/DSP CRMS FOR CIRCUIT ENABLE DATA FIELD
:	--------------------------------------------------
CENSCU	EQ	0			:+0  - SOURCE CU ADDR
CENSLU	EQ	CENSCU+1		:+1  - SOURCE DEVICE (LU) ADDR
CENCBT	EQ	CENSLU+1		:+2  - CONTROL BYTE
CENDIF	EQ	CENCBT+1		:+3  - DEVICE INFORMATION
CENCRM	EQ	CENDIF+1		:+4  - CRM
CENDDF	EQ	CENCRM+1		:+5  - DESTINATION DESIGNATOR

	SEG	A.CODE

:
:	CONFIGURATION MACRO FOR DSP MSGS
:


:	GENDSP(TABNAM): MACRO TO GENERATE DSP PROC TABLE
:	----------
GENDSP	MACRO(TABNAM)[
	HS	0
TABNAM	HC	NDINCL-PSEG		:01 - INVITATION TO CLEAR
	HC	NDUNDL-PSEG		:10 - CMD/RES UNDELIVERED
	HC	NDABRT-PSEG		:11 - CMD/RSP ABORTED
	HC	NDSTAT-PSEG		:12 - STATUS MSG
	HC	NDACKG-PSEG		:14 - ACK MESSAGE
	HC	NDCCEN-PSEG		:20 - CIRCUIT ENABLE
	HC	NDCCRS-PSEG		:21 - CIRCUIT RESET
	HC	NDCCRQ-PSEG		:22 - CIRCUIT REQUEST
	HC	NDCCDS-PSEG		:24 - CIRCUIT DISCONNECT
	HC	NDDATA-PSEG		:25 - DSP DATA
		]

:	CHGDSP(TABNAM,DSPINN,ACTION)
:	-------
:	MACRO TO CHANGE ENTRY OF THE DSP PROC TABLE
:		TABNAM - DSP PROC TABLE NAME
:		DSPINN - DSP MESSAGES (I.E. DSPI01, DSPI10, ETC..)
:		ACTION - ACTION ROUTINE
CHGDSP	MACRO(TABNAM,DSPINN,ACTION)[
OLDORG	EQ	.
	ORG	TABNAM+(DSPINN-DSPI01)*2
	HC	ACTION-PSEG
	ORG	OLDORG
		]

:	DEFINE SYMBOLS USED FOR CHGDSP
:	--------------------------------
DSPI01	EQ	0			:INVITATION TO CLEAR
DSPI10	EQ	1			:CMD/RSP UNDELIVERED
DSPI11	EQ	2			:CMD/RSP ABORTED
DSPI12	EQ	3			:STATUS MESSAGE
DSPI14	EQ	4			:ACK MESSAGE
DSPI20	EQ	5			:CIRCUIT ENABLE
DSPI21	EQ	6			:CIRCUIT RESET
DSPI22	EQ	7			:CIRCUIT REQUEST
DSPI24	EQ	8			:CIRCUIT DISCONNECT
DSPI25	EQ	9			:DATA MESSAGE


:	GDSPIX:	Q-PACKET & DSP
:	------
:	WHEN ENTER HERE, EXPECT FLAG BYTE RECEIVED
GDSPIX
	LHI	R4,GDSPI1-PSEG		:SET NEXT ENTRY POINT
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
GDSPI1					:R0 = UCN BYTE
	LHI	R4,GDSPI2-PSEG		:SET NEXT ENTRY POINT
	JR	R5			:TO GISDI1 TO GET NEXT BYTE
GDSPI2					:R0 = DSP MSG TYPE
	LIS	R4,8			:SEARCH FOR DSP MSG TYPE
GDSPI3
	CLB	R0,DSPTYP,R4		:SAME ?
	JEFS	GDSPI4			:YES, FOUND
	SIS	R4,1			:NEXT ONE
	JGEBS	GDSPI3			:NOT END, REPEAT
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,088
GDSPI4					:FOUND DSP MSG TYPE
	LHL	R9,DCBLKS+DCBDSP,RDCB,	:GET DSP RPOC TABLE
	JNFS	GDSPI5
	JAL	R10,CRASH,,
	BC	0,0,0,088
GDSPI5
	AR	R4,R4			:MAKE HW INDEX
	LHL	R4,PSEG,R9,R4		:GET PROC ROUTINE
	J	PSEG,R4,,		:TO PROC..

:	DSPTYP:	TABLE FOR FINDING DSP MSG
:	------
DSPTYP
	BC	01,10,11,12
	BC	14,20,21,22
	BC	24
	HS	0


	SUBTTL	(SNA) GDSP - DSP MSG GENERAL ACTIVE ROUTINE


:	NDINCL:	INVITATION TO CLEAR (01)
:	------
NDINCL	J	FSHINP

:	NDUNDL:	CMD/RSP UNDELIVERED (10)
:	-------
:	NOT SUPPORT, RETURN A FACILITY FAILURE PACKET
NDUNDL
	J	SNDFCF			:SEND FACILITY FAILURE (07/11/84 NCS)

:	NDABRT:	CMD/RSP ABORTED (11)
:	-------
:	NOT SUPPORT, RETURN A FACILITY FAILURE PACKET
NDABRT
	J	SNDFCF			:SEND FACILITY FAILURE (07/11/84 NCS)

:	NDSTAT:	STATUS MSG (12)
:	------
:	IF TERMINAL INTERFACE, INVALID
NDSTAT
	J	SNDIDQ			:SEND INVALID DQ FORMAT (07/11/84 NCS)

:	NDACKG:	ACK MSG (14)
:	------
:	IF	TERMINAL INTERFACE, INVALID
NDACKG
	J	SNDIDQ			:SEND INVALID DQ FORMAT (07/11/84 NCS)

:	NDCCEN:	CIRCUIT ENABLE (20)
:	------
:	IF HOST INTERFACE, INVALID
NDCCEN
	J	SNDIDQ			:SEND INVALID DQ FORMAT (07/11/84 NCS)

:	NDCCRS:	RECEIVED CIRCUIT RESET (21)
:	------
:	RETURN A CIRCUIT RESET DSP MSG AND
:	SET PROPER SEQ NO TO DCBISQ  AND DCBOSQ
NDCCRS
	LHI	R4,NDCCR1-PSEG		:SET TO NEXT ENTRY
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
NDCCR1					:R0 = RSP SEQ #
	STB	R0,RSRPSQ,,		:PUT INTO CIR. RESET MSG
	SIS	R0,1			:STOR SEQ #
	LB	R4,DCBLKS+DCBUTY,RDCB,
:	REMARK *** SEE IF HOST/TERMINAL
	JEFS	.+0A			:SKIP, IF HOSTIF
	STB	R0,DCBLKS+DCBISQ,RDCB,
	JFS	.+8
	STB	R0,DCBLKS+DCBOSQ,RDCB,
	LHI	R4,NDCCR2-PSEG		:SET NEXT ENTRY 
	JR	R5			:TO GISDI1 TO READ CMD SEQ #
NDCCR2					:R0 = CMD SEQ #
	STB	R0,RSCMSQ,,		:STORE INTO CIR REST DSP MSG
	SIS	R0,1			:SET UP EXPECTED CMD SEQ #
	LB	R4,DCBLKS+DCBUTY,RDCB,
:	REMARK *** SEE IF HOST/TERMINAL
	JEFS	.+0A			:SKIP, IF HOSTIF
	STB	R0,DCBLKS+DCBOSQ,RDCB,
	JFS	.+08
	STB	R0,DCBLKS+DCBISQ,RDCB,
	LHI	R4,NDCCR3-PSEG		:SET UP NEXT ENTRY
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
NDCCR3					:R0 = REASON CODE
	STB	R0,RSCODE,,		:RETURN IT
	LA	R9,M.CRST-1,,		:R9 = CIR RESET DSP MSG
	JAL	R6,SNDIIX		:SEND IT
:	REMARK RESET FLUSHING MODE FOR OUT OF SEQ DATA
	J	IXENDN			:END IIX INPUT, NO TIMER

:	NDCCRQ:	CIRCUIT REQUEST (22)
:	------
:	NO SUPPORT, INVALID
NDCCRQ
	J	SNDIDQ			:SEND INVALID DQ FORMAT (07/11/84 NCS)

:	NDCCDS:	CIRCUIT DISCONNECT (24)
:	------
:	IF HOST INTERFACE, INVALID
NDCCDS
	J	SNDIDQ			:SEND INVALID DQ FORMAT (07/11/84 NCS)

:	NDDATA:	DSP DATA MSG
:	------
NDDATA
	J	SNDIDQ			:SEND INVALID DQ FORMAT (07/11/84 NCS)


	SUBTTL	(SNA) GDSP - MISC ROUTINES


:	SNDENA:	SEND "A CIRCUIT ENABLE"
:	-------
:	R6 = LINK REGISTER
:	RDCB = DCB OFFSET
SNDENA
	ST	R6,DSPSAV,,
					:(F00/02/10/87/DB/START) - CRM 4
:	LHI	R0,CENLNG		:ASSUME LENGTH WITHOUT ADDI.
:	STB	R0,M.CENA-1,,
					:(F00/02/10/87/DB/END)
	LB	R0,DCBLKS+DCBRCU,RDCB,	:GET SOURCE CU ADDR
	STB	R0,CENADA+CENSCU,,
	LB	R0,DCBLKS+DCBRLU,RDCB,	:GET SOURCE LU ADDR
	STB	R0,CENADA+CENSLU,,
	LB	R0,DCBLKS+DCBFST,RDCB,	:GET SOURCE LU'S FST
	STB	R0,CENADA+CENCBT,,
	LB	R0,DCBLKS+DCBDIF,RDCB,	:GET SOURCE LU'S INF
	STB	R0,CENADA+CENDIF,,
	LB	R0,DCBLKS+DCBCRM,RDCB,	:GET CRM #
	STB	R0,CENADA+CENCRM,,
					:F02/10/05/87/DB/START)
:	LB	R0,DCBLKS+DCBAPI,RDCB,	:GET APPL ID
:	IF	PHTIMO			:(01/23/85)
	LB	R0,DCBLKS+DCBLIN,RDCB,	:GET APPL ID (01/23/85 MIA)
:	EI				:(F02/10/05/87/DB/END)
	STB	R0,CENADA+CENDDF+CRM2AP,,
	LB	R0,DCBLKS+DCBCUA,RDCB,	:GET CUA
	STB	R0,CENADA+CENDDF+CRM2DC,,
:	LB	R11,DCBLKS+DCBLUA,RDCB,	:(3.f01/06/25/87/DB)
	LB	R0,DCBLKS+DCBLUA,RDCB,	:(3.F01/06/25/87/DB)
	STB	R0,CENADA+CENDDF+CRM2DD,,
					:(F00/02/10/87/DB/START)
	LHL	R0,DCBLKS+DCBADR,RDCB,	:GET CU AND LU ADDRESSES
	STH	R0,CENADA+CENDDF+CRMADR,, :SEND IN ADDI FIELD ALWAYS

: ATTACHED PRINTER -SET UP ADDITIONAL DESTINATION DESIGNATOR (ADDI)
:   WITH CRT DCB PTR.
	LIS	R0,0
	STH	R0,CENADA+CENDDF+CRM4CB,, :ASSUME NOT ATTPTR
	LB	R0,DCBLKS+DCBDIF,RDCB,	:GET SOURCE LU'S INF
	THI	R0,ATTPRT		:ATTACHED PRINTER REQUEST?
	JE	SNDEN1			:NO, NO ADDI.
	STH	RDCB,CENADA+CENDDF+CRM4CB,,	:STORE DCB PTR FOR CRT

SNDEN1
					:(F00/02/10/87/DB/END)
	LA	R9,M.CENA-1,,
	JAL	R6,SNDIIX
	L	R6,DSPSAV,,
	JR	R6

:	SNDICR:	SEND AN 'INVITATION TO CLEAR'
:	------
:	R0 = REASON CODE
:	R6 = LINK REG.
SNDICR
	ST	R6,DSPSAV,,		:SAVE R6
	STB	R0,INVCR,,		:PUT REASON CODE INTO MSG
	LA	R9,M.INVC-1,,		:ADDR OF INV TO CLR MSG
	JAL	R6,SNDIIX		:SEND THIS MESSAGE
	L	R6,DSPSAV,,		:RESTORE R6
	JR	R6			:RETURN

:
:	SEND DSP INVITATION TO CLEAR MESSAGE WITH VARIOUS REASON CODE
:

:	SNDIDQ:	'INVALID DQ FORMAT'
:	------
SNDIDQ
	LHI	R0,12			:'INVALID DQ FORMAT'
	JAL	R6,SNDICR		:SEND IT
	LHI	R0,30
	J	IXENDT			:END ISIS/IIX WITH TIMER

:	SNDDAT:	'INVALID DATA PACKET FORMAT'
:	------
SNDDAT
	LHI	R0,13			:'INVALID DATA PACKET FORMAT'
	JAL	R6,SNDICR		:SEND IT
	LHI	R0,30
	J	IXENDT			:END ISIS/IIX WITH TIMER

:	SNAFCF:	'FACILITY FAILURE'
:	------
SNDFCF
	LHI	R0,21			:'FACILITY FAILURE'
	JAL	R6,SNDICR		:SEND IT
	LHI	R0,30
	J	IXENDT			:END ISIS/IIX WITH TIMER

:	NOUTIS - OUTPUT SNA DSP DATA MESSAGE
:	------
:	RECEIVED A SNA RQ/RSP RU FROM HOST/TERMINAL
:	CONVERT IT TO A DSP "CMD/RSP" MSG AND SEND IT OUT TO THE
:	TERMINAL/HOST PAD VIA THE TYMNET (I.E. ISIS ORING).
:	EXPECT:
:		RBBA = BUFFER CONTAINING DATA
:		R0   = SCC FROM CMDLST ELEMENT
:	REG USAGE:
:		RBBX = INDEX TO BUFFER CONTAINING DATA
:		RBCC = # OF BYTES IN MESSAGE
:		R2 = ISI RECORD BYTE COUNT
NOUTIS

	IF	BTRACE
	LIS	R4,BTROBT		:SEE IF TRACNG OUTPUT
	TBT	R4,BTRIOF,,		:...
	JE	NOUTI0			:NO, SKIP TRACE
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT #
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R4,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R4,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LR	R4,RBCC			:R4 = BYTE COUNT
	OHI	R4,BTROUT+BTRBEG	:OUTPUT AND BEGIN
	STH	R4,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R4,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R4,FASTC,,		:ELSE, MUST BE FASTC
	ST	R4,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

NOUTI0
	BBST	RBBA,DCBLKS+DCBOBA,RDCB, :SAVE BUFFER ADR OF DATA MSG
	STB	R0,DCBLKS+DCBSCC,RDCB,	:SAVE SCC
	LHI	RBBX,-BBFLSZ+BBFPSZ-1	:INIT BB INDEX
:	IF 1ST RU SEGM., DATA CNT= UCN(1)+CTL(1)+SEG(1)+DATA# = 3 + DATA#
:	AND PACKET LENGTH = C094(2)+FLAG(1)+DATA-CNT(2)+DATAS = 8 +DATA#
:	THE ISIS RECORD LENGTH = XLIMIT +2 OR PACKET LENGTH+2
:
:	IF SUBSEQUENT SEGMENT, THEN DATA COUNT = UCN(1) + DATA # = 1 + DATA#
:	AND PACKET LENGTH = C094(2)+FLAG(1)+DATA-CNT(2)+DATAS = 6 +DATA#
:	THE ISIS RECORD LENGTH = XLIMIT +2 OR PACKET LENGTH +2
	AIS	RBCC,6			:PACKET LENGTH, ASSUME NOT 1ST SEGM.
	NHI	R0,SNDTLS		:GET NON-1ST SEGMENT INDICATOR
	JNFS	NOUTI1			:NOT 1ST SEGMENT, SKIP
	AIS	RBCC,2			:ADJUST PACKET LENGTH
NOUTI1					:SEND SIIX 1ST
	LIS	R0,3			:SEND SIIX MSG
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT
	LHI	R2,SIIX
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,
	LB	R0,XLIMIT,R1,		:GET ISIS MAX XLIMIT
	SIS	R0,2
	CR	R0,RBCC			:SEE IF PACKET FIT INTO ONE ISIS RCD
	JLFS	NOUTI2			:NO, USE XLIMIT
	LR	R0,RBCC			:ELSE, USE PACKET LENGTH
NOUTI2
	LR	R2,R0			:R2 = ISIS RCD BYTE COUNT
	AIS	R0,2			:ADJUST WITH PORT
	JAL	R4,SLOR,,
	LHI	R0,IIXDIL		:DATA DIALECT CODE (C094)
	JAL	R4,PUTCH,,
	LHI	R0,DATAPK
	JAL	R4,PUTCH,,
	LIS	R0,0			:SEND IIX FLAGS (M=0,Q=0)
	JAL	R4,PUTCH,,
	SIS	R2,5			:C094 + FLAG + PACKET.LENGTH FILED
	SIS	RBCC,5
	EXBR	R0,RBCC			:SEND LEFT BYTE OF PACKET LENGTH
	JAL	R4,PUTCH,,
	LR	R0,RBCC			:SEND RIGHT BYTE OF LENGTH
	JAL	R4,PUTCH,,
					:SEND HEADER (UCN, CTL, SEQ)
	LB	R0,DCBLKS+DCBSCC,RDCB,	:GET SCC
	NHI	R0,SNDTLS		:GET NON-1ST SEGMENT INDICATOR
	JN	NOUTI3			:NO, SKIP
	LHI	R0,UCN			:Y - SET FS=0 IN UCN
	JAL	R4,PUTCH,,		:SEND UCN
	LIS	R0,0			:SEND NULL CTL BYTE
	JAL	R4,PUTCH,,		:SEND CONTROL BYTE
	LB	R0,DCBLKS+DCBOSQ,RDCB,	:GET OUT SEQ #
	AIS	R0,1			:INCREMENT SEQUENCE NUMBER
	STB	R0,DCBLKS+DCBOSQ,RDCB,	:UPDATE
	JAL	R4,PUTCH,,		:SEND SEQUENCE NUMBER
	SIS	RBCC,3			:DECREASE FOR UCN,CTR,SEQ #
	SIS	R2,3			:DECREASE FOR UCN,CTR,SEQ #
	JFS	NOUTI4			:SKIP TO CONTINUE
NOUTI3					:SUBSEGUENT SEGMENT
	LHI	R0,UCN			:SEND UCN ONLY
	OHI	R0,BIT.FS		:SEND UCN W/ FS=1
	JAL	R4,PUTCH,,
	SIS	RBCC,1			:DECREASE COUNT FOR UCN
	SIS	R2,1			:DECREASE COUNT FOR UCN
NOUTI4					:COPY DATA CHAR FROM OUTPUT BB
					:TO ISIS ORING
	JAL	R4,GETBC		:GET CHAR FROM BUFFER
	JAL	R4,PUTCH,,		:OUTPUT BYTE TO RING
	SIS	RBCC,1			:DECREMENT PACKET COUNT
	SIS	R2,1			:DECREMENT ISIS RCD COUNT
	JG	NOUTI4			:NOT FINISH THIS ISIS RCD, REPAET
	JAL	R4,ELODR,,		:END CURRENT ISIS RCD
	LR	RBCC,RBCC		:ALSO END OF PACKET?
	JN	NOUTI5			:NO, TO SAVE PARAMETERS, AND DISMISS
	LHI	R0,NOUTIS-PSEG		:SET OUTPUT PROC
	STH	R0,DCBLKS+DCBOUT,RDCB,
	JAL	R7,DLODTA		:FINISH PROCESS THIS CMD & BBS

	IF	BTRACE
	LIS	R4,BTROBT		:SEE IF TRACNG OUTPUT
	TBT	R4,BTRIOF,,		:...
	JER	R5			:END IIX/ISIS OUTPUT
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT #
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R4,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R4,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LR	R4,RBCC			:R4 = BYTE COUNT
	OHI	R4,BTROUT+BTREND	:OUTPUT AND END
	STH	R4,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R4,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R4,FASTC,,		:ELSE, MUST BE FASTC
	ST	R4,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

	JR	R5			:END ISIS/IIX OUTPUT
 
NOUTI5					:END OF ISIS RCD , BUT NOT FULL PACKET
	BBST	RBBA,DCBLKS+DCBOBA,RDCB, :SAVE BB ADDR
	STH	RBBX,DCBLKS+DCBOBX,RDCB, :SAVE BB INDEX
	STH	RBCC,DCBLKS+DCBOCC,RDCB, :SAVE REMAINING PACKET LENGTH
	LHI	R0,NOUTNX-PSEG		:SET UP NEXT ENTRY POINT
	STH	R0,DCBLKS+DCBOUT,RDCB,	:UPDATE
:	JR	R5			:RETURN (DISMISS) - ISIS/IIX OUTPUT(11/07/85/CHS)
	NOP	0			:(11/07/85/CHS) FOR LATER ONLINE PATCH

:	NOUTNX:	AFTER DISMISS, ENTER PROCESSING OUTPUT DSP DATA MSG HERE
:	------
:       BEGIN PROCESSING OUTPUT DATA MSG AGAIN AT THIS POINT
NOUTNX
	BBLOAD	RBBA,DCBLKS+DCBOBA,RDCB, :RESTORE BB ADDR
	LH	RBBX,DCBLKS+DCBOBX,RDCB, :RESTORE BB INDEX
	LHL	RBCC,DCBLKS+DCBOCC,RDCB, :RESTORE PARTIAL PACKET LENGTH
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISI PORT #
	LB	R0,XLIMIT,R1,		:GET MAX XLIMIT
	SIS	R0,2
	CR	R0,RBCC			:ASSUME PARTIAL PACKET LENGTH < XLIMT
	JLFS	NOUTN1			:NO, SKIP TO USE  XLIMIT
	LR	R0,RBCC			:ELSE, USE PARTIAL PACKET LENGTH
NOUTN1
	LR	R2,R0			:R2 = ISIS RCD LENGTH
	AIS	R0,2			:INCLUDE PORT # (2)
	JAL	R4,SLOR,,		:START A NEW ISIS OUTPUT RECORD
	J	NOUTI4			:TO CONTINUE COPY DATA INTO ISIS ORING
 
	SUBTTL	(SNA-GDSP) SNA/DSP PROCESSES


:
:	GENERATE 'SNA/DSP' MESSAGES PROCESSING TABLE
:

	IF	TERMIF

	GENDSP(SNTDSP)			:SNA/DSP PROCESS TABLE

	CHGDSP(SNTDSP,DSPI01,NDTIVC)	:01 - INVITATION TO CLEAR
	CHGDSP(SNTDSP,DSPI20,NDTCEN)	:20 - CIRCUIT ENABLE
	CHGDSP(SNTDSP,DSPI24,NDTCDS)	:24 - CIRCUIT DISCONNECT
	EI	(TERMIF)

	IF	HOSTIF

	GENDSP(SNHDSP)			:SNA/DSP PROCESS TABLE

	CHGDSP(SNHDSP,DSPI01,NDHIVC)	:01 - INVITATIONTO CLEAR
	CHGDSP(SNHDSP,DSPI12,NDHSTT)	:12 - STATUS MSG
	EI	(HOSTIF)


	IF	TERMIF

:	NDTIVC:	INVITATION TO CLEAR
:	-------
NDTIVC
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R1 = LUC OFFSET
	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET STATE
	CLHI	R0,L.NATV		:IN SNA/ACTIVE STATE?
	JE	NDTIV1			:YES, TO ...
	JAL	R6,RLOGBB,,		:DELETE LOGON DSP BB
	JAL	R6,ISIEND		:END ANY MESSAGE FROM THE NETWORK
	JAL	R6,PTLBH
	LA	R1,LEM15,,		:AND DISPLAY CONNECTION FAILED
	JAL	R6,PMLB
	BBL	R3,LUCTAB+LUCIBH,R11,
	LHI	R2,NSINTM^8!NSDTCD
	JAL	R6,QDIFSN
	JAL	R6,RSTTRM		:AND ZAP CIRCUIT
	LHI	R0,L.ERCK		:DSP ERROR STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC		:CLEAR ALL EXCEPT D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	J	IXENDN			:END ISIS/IIX INPUT

NDTIV1					:SNA/ACTIVE MODE
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

	EI
	IF	TERMIF!VHRSUP
:	NDTCEN:	CIRCUIT ENABLE
:	------
NDTCEN
	LB	R0,DCBLKS+DCBSTA,RDCB,	:IN RIGHT STATE?
	CLHI	R0,L.CENA
	JN	CLRCIR			:NO, TO CLEAR CIRCUIT
	LHI	R4,NDTCE1-PSEG
	JR	R5			:TO READ NEXT BYTE
NDTCE1					:R0 = SOURCE CUA
	CLB	R0,DCBLKS+DCBCUA,RDCB,	:COMPARE
	JN	CLRCIR			:NO THE SAME, ERROR
	LHI	R4,NDTCE2-PSEG
	JR	R5			:TO READ NEXT BYTE
NDTCE2					:R0 = SOURCE LUA
	CLB	R0,DCBLKS+DCBLUA,RDCB,	:COMPARE
	JN	CLRCIR			:NO THE SAME, ERROR
	LHI	R4,NDTCE3-PSEG
	JR	R5			:TO READ NEXT BYTE
NDTCE3					:R0 = SOURCE FST
	CLB	R0,DCBLKS+DCBFST,RDCB,	:COMPARE
	JN	CLRCIR			:NO THE SAME, ERROR
	LHI	R4,NDTCE4-PSEG
	JR	R5			:TO READ NEXT BYTE
NDTCE4					:R0 = SOURCE DIF
	NHI	R0,7F			:(03/07/86/CHS)
	CLB	R0,DCBLKS+DCBDIF,RDCB,	:COMPARE
	JN	CLRCIR			:NO THE SAME, ERROR
	LHI	R4,NDTCE5-PSEG
	JR	R5			:TO READ NEXT BYTE
NDTCE5					:R0 = CRM #
	CLB	R0,DCBLKS+DCBCRM,RDCB,	:COMPARE
	JN	CLRCIR			:NO THE SAME, ERROR
	LIS	R4,0			:INIT DCBCRD 1ST BYTE
	STB	R4,DCBLKS+DCBCRD,RDCB,
	CLHI	R0,4			:CRM TYPE 4?
	JN	NDTCEA			:NO, SKIP
	LHI	R4,NDTCE6-PSEG
	JR	R5			:TO READ NEXT BYTE
NDTCE6					:R0 = REMOTE APPL ID
	LHI	R4,NDTCE7-PSEG
	JR	R5			:TO READ NEXT BYTE
NDTCE7					:R0 = REMOTE CUA
	LHI	R4,NDTCE8-PSEG
	JR	R5			:TO READ NEXT BYTE
NDTCE8					:R0 = REMOTE LUA
	LHL	R0,DCBLKS+DCBIPL,RDCB,	:CALCULATE BYTE# OF ADDITIONAL INFOR
	SIS	R0,0A
	STB	R0,DCBLKS+DCBCRD,RDCB,	:SAVE INTO DCB
	STH	R0,DCBLKS+DCBIPL,RDCB,	:MODIFY DCBIPL
	LIS	R0,0
	STH	R4,DCBLKS+DCBICC,RDCB,	:INIT DCBICC
	LHI	R4,NDTCE9-PSEG
	JR	R5			:TO READ NEXT BYTE
NDTCE9
	STB	R0,DCBLKS+DCBCRD+1,RDCB,RBCC
	AIS	RBCC,1			:INCREASE BYTE CNT
	CLH	RBCC,DCBLKS+DCBIPL,RDCB, :ALL READ?
	JEFS	NDTCEA			:YES, SKIP
	LHI	R4,NDTCE9-PSEG
	JR	R5
NDTCEA
	AR	R14,2			:FLUSH ALL REAMINING DATA, IF ANY
	LHI	R0,L.NATV		:ENTER NATIVE MODE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	IF	VHRSUP!VTISUP
	LB	R0,LUCTAB+LUCVHR,R11,	:GET VHR/VTI STATE
	IF	TERMIF
	THI	R0,LUVHRF!LUVTIF	:VHR/VTI FUNCTION?
	EI
	IF	VTISUP
	JE	NDTCEB			:JUMP IF NOT
	THI	R0,LUVTIF		:VTI FUNCTION?
	JN	NDTCEV
	EI
	EI
	IF	VHRSUP
	GL	ATDOUP,NPHOSD,NPHOSC
	NHI	R0,LUVTIF!LUVHRF!LURPVC	:MASK NON-SYSGEN BITS
	STB	R0,LUCTAB+LUCVHR,R11,	:CLEAR VHR STATE BYTE
	LHI	R0,ATDOUP-PSEG		:GET OUTPUT ROUTINE
	STH	R0,DCBLKS+DCBOUT,RDCB,	:SAVE IT IN DCB
	LHI	R0,L.BDSP		:VIRTUAL DSP STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,	:SAVE IT IN DCB
	LHI	R0,NPHOSD-PSEG		:GET DATA QUEUE PROCESSING TABLE
	STH	R0,LUCTAB+LUODPR,R11,	:SAVE IT IN LUCB
	LHI	R0,NPHOSC-PSEG		:GET COMMADN QUEUE PROC TABLE
	STH	R0,LUCTAB+LUOCPR,R11,	:SAVE IT IN LUCB
	LHI	R0,DEVEND		:PREPARE TO SEND DEVICE END
	STB	R0,STSSB1,,		:SAVE LAST BYTE OF STATUS
	EXBR	R0,R0			:PREPARE FIRST BYTE OF STATUS
	STB	R0,STSSB0,,		:SAVE FIRST BYTE OF STATUS
	LA	R9,M.STAT-1		:POINT TO CANNED STATUS MESSAGE
	JAL	R6,SNDIIX		:SEND IT TO HIF

:RELEASE BUFFERS WITH VTR LOGON INFORMATION.
	BBL	R3,DCBLKS+DCBLBA,RDCB,	:GET POINTER TO LOGON BUFFERS
	JEFS	NDTCEX			:JUMP IF NONE
	JAL	R6,DLODBB		:RELASE LOGON BUFFERS
	XR	R3,R3			:CLEAR THE REGISTER
	BBST	R3,DCBLKS+DCBLBA,RDCB,	:UPDATE LOGON POINTER

:FILL IN CADR1 AND CADR2 AND SEND LOGON REPLY RU TO VTR. THIS CODE ASSUMES
:THAT REPLY RU IS 1 SEGMENT 1 ELEMENT CHAIN. IF NOT THIS CODE SHOULD BE
:CHANGED LATER.
NDTCEX	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET  POINTER TO PREPARED REPLY
	LHI	R6,SP.			:LOGON COMPLETED
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA1,R3,	:FILL CADR1
	LIS	R6,VHRCDR		:PREPARE CADR2(CD)
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:FILL CADR2
	XR	R6,R6			:CLEAR THE REGISTER
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCDE,R3,	:CLEAR ERROR CODE
	BBST	R6,DCBLKS+DCBIBH,RDCB,	:UPDATE REPLY POINTER
	LHL	R8,DCBLKS+DCBALU,RDCB,	:GET MESSAGE LENGTH
	LHI	R2,NSETEM^8!NSDTCD	:ASSUME SINGLE SEG, SINGLE RU CHAIN
	JAL	R6,QDIFSN		:SEND IT TO SNA
	LCS	R0,1			:PREPARE -1
	STB	R0,DCBLKS+DCBISQ,RDCB,	:INIT INPUT SEQ#
	STB	R0,DCBLKS+DCBOSQ,RDCB,	:INIT OUTPUT SEQ#
	J	IXENDN			:END OF INPUT
	EI	(VHRSUP)
:	EI	(TERMIF!VHRSUP)		:(04/09/87 YLH)

	IF	VTISUP
NDTCEV	LHI	R0,L.BDSP		:DSP STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,	:UPDATE STATE BYTE
	LHL	R4,LUCTAB+LUBNDP,R11,	:GET CANNED BIND POINTER
	LA	R4,PSEG+1,R4,		:GET BIND RU POINTER
	LB	R6,SCSLUP-SCFMPF+2,R4,	:GET SEC LU PROTOCOL BYTE
	THI	R6,80			:CHECK IF MULTIPLE CHAINS ALLOWED
	JNFS	NDTCES			:JUMP IF SO
	LHI	R0,RUNOMX		:PREPARE TO CLEAR RU LENGTH
	JNFS	NDTCET			:JUMP TO CONTINUE
NDTCES	LB	R6,SCSMRU-SCFMPF+2,R4,	:GET MUX RU SIZE FOR SEC
	LR	R0,R6			:COPY IT
	NHI	R6,0F			:GET EXPONENT
	SRLS	R0,4			:GET MUPLIPLIER FOR EXPONENT
	SLL	R0,0,R6			:CALCULATE RU LENGTH
NDTCET	STH	R0,DCBLKS+DCBRUL,RDCB,	:SAVE IT IN DCB
	LB	R6,LUCTAB+LUCPUN,R11,	:GET PU NUMBER
	LHL	R6,PUCPTR,R6,R6		:GET PUCTAB POINTER
	LHL	R6,PUCTAB+PUCLNC,R6,	:GET LNCTAB POINTER
	LHL	R6,LNCTAB+LNMXFM,R6,	:GET MAX FRAME SIZE
	SIS	R6,2			:ADJUST FOR ADDR AND CONTROL BYTE
	STH	R6,DCBLKS+DCBSGL,RDCB,	:SAVE MAX SEGMENT SIZE
	GL	ATDOUP
	LHI	R0,ATDOUP-PSEG		:OUTPUT ROUTINE
:
:BEGIN (03/18/87 YLH)
:
	STH	R0,DCBLKS+DCBOUT,RDCB,
	LCS	R0,1			:INIT DCBISQ AND DCBOSQ
	STB	R0,DCBLKS+DCBISQ,RDCB,
	STB	R0,DCBLKS+DCBOSQ,RDCB,
:
:SEND DEVICE END DSP STATUS TO THE HIF
:
	LHI	R0,DEVEND		:SEND DEVEND TO HOST IF
	STB	R0,STSSB1,,		:(TO BE COMPATIBLE WITH BSC/DSP)
	EXBR	R0,R0
	STB	R0,STSSB0,,
	LA	R9,M.STAT-1,,
	JAL	R6,SNDIIX,,		:(09/09/86/CHS) RX3
:
:SEND FINISH LOGON TO THE SNA_LU_SVC
:
	LHI	R2,NSFNLG^8!NSFNDP	:INFORM SNA.LU.SVC
	LIS	R3,0
	JAL	R6,QDIFSN,,
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,FNLGFL,,		:SET FLAG
	J	IXENDN			:JUMP TO CONTINUE
:
:END (03/18/87 YLH)
:
	EI

	IF	TERMIF		
NDTCEB	LHI	R0,NOUTIS-PSEG		:SET UP NATIVE/ACTIVE ISIS OUTPUT
NDTCEU	STH	R0,DCBLKS+DCBOUT,RDCB,
	LCS	R0,1			:INIT DCBISQ AND DCBOSQ
	STB	R0,DCBLKS+DCBISQ,RDCB,
	STB	R0,DCBLKS+DCBOSQ,RDCB,
:	LHI	R0,NSDTCD		:CHANGE DIRECTION
:	STH	R0,CDIND,,
:	JAL	R6,SNDNSS		:SEND NSM SCREEN AGAIN
:	LHI	R0,L.NSMN		:WAIT FOR NSC SELECTION
:	STB	R0,DCBLKS+DCBSTA,RDCB,
	JAL	R6,PTLBH
	LA	R1,ERASCN,,		:ERASE THE SCREEN
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTCD
	JAL	R6,QDIFSN
	LHL	R0,LUCTAB+LUCT.N,R11,
	GL	SNDFLG
	SBT	R0,SNDFLG,,		:SEND FINIFH LOGON NEXT TIME
	J	IXENDN			:END ISIS/IIX INPUT WITH NO TIMER
	EI	(TERMIF)		:(04/09/87 YLH)
	EI	(TERMIF!VHRSUP)		:(04/09/87 YLH)

	IF	TERMIF			:(04/09/87 YLH)
:	NDTCDS:	CIRCUIT DISCONNECT
:	------
NDTCDS
	LHI	R4,NDTCD1-PSEG		:TO READ REASON BYTE
	JR	R5
NDTCD1					:R0 = REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,
	GL	ZPTCKT,ZAPTLU
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	JAL	R6,ZPTCKT,,
	JAL	R6,ZAPTLU,,
	J	IXENDN

	EI	(TERMIF)

	IF	(HOSTIF)

:	NDHIVC:	INVITATION TO CLEAR
:	------
NDHIVC
	LHI	R4,NDHIV1-PSEG		:TO READ REASON BYTE
	JR	R5
NDHIV1					:R0 = REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,
	GL	ZPHCKT,ZAPHLU
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	CI	R11,0FFFF		:DEVICE WAS ATTACHED? (10/01/86 YLH)
	JE	NDHIV2			:NO, SKIP (10/01/86 YLH)
:	JE	NDHIV2			:NO DEVICE YET, SKIP (03/24/86/CHS)
	JAL	R6,ZPHCKT,,
	JAL	R6,ZAPHLU,,
	J	IXENDN
NDHIV2					:(03/24/86/CHS)
	GL	ZAPHST,DSCHPR
	JAL	R6,DSCHPR,,		:DISCONNECT HOST PORT
	LHL	R7,DCBLKS+DCBHST,RDCB,
	JAL	R6,ZAPHST,,
	JAL	R6,RELDCB,,
	J	IXENDN

:	NDHSTT:	STATUS MESSAGE
:	------
NDHSTT
	LB	R0,DCBLKS+DCBSTA,RDCB,	:IN RIGHT STATE?
	CLHI	R0,L.STAT
:	JN	CLRCIR			:NO, TO CLEAR CIRCUIT
	JN	FSHINP			:NO, TO DISCARD
	LHI	R4,NDHST1-PSEG		:TO READ NEXT BYTE
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
NDHST1					:R0 = S/S BYTE 0
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:(03/10/86/CHS)
	LB	R4,LUCTAB+LUCSYS,R11,	:SEE IF SNA/FNA OR HNA..
	LHI	R6,(DEVEND^-8)&0FF	:ASSUME SNA/FNA
	CLHI	R4,HITACHI		:...
	JNFS	NDHSTX			:HIT, SKIP
	LHI	R6,(DVENDH^-8)&0FF	:ELSE, HNA
NDHSTX
	CR	R0,R6			:DEVICE END? (03/10/86/CHS)
:	CLHI	R0,(DEVEND^-8)&0FF	:DEVICE END?(03/10/86/CHS)
	JN	CLRCIR			:NO, TO CLEAR CIRCUIT
	LHI	R4,NDHST2-PSEG		:TO READ NEXT BYTE
	JR	R5			:TO GISDI1
NDHST2					:R0 = S/S BYTE 1
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:(03/10/86/CHS)
	LB	R4,LUCTAB+LUCSYS,R11,	:SEE IF SNA/FNA OR HNA..
	LHI	R6,DEVEND&0FF		:ASSUME SNA/FNA
	CLHI	R4,HITACHI		:...
	JNFS	NDHSTY			:HIT, SKIP
	LHI	R6,DVENDH&0FF		:ELSE, HNA
NDHSTY
	CR	R0,R6			:DEVICE END? (03/10/86/CHS)
:	CLHI	R0,DEVEND&0FF		:DEVICE END?(03/10/86/CHS)
	JN	CLRCIR			:NO, TO CLEAR CIRCUIT
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCB PTR (06/04/05 MIA)
	JE	IXENDN			:IGNORE, NO PTR (06/04/85 MIA)
	LB	R0,LUCTAB+LUSSTA,R11,	:GET LU STATE (06/04/85 MIA)
	LO	CBKDEF
	CHI	R0,NN.ALU		:ACTIVE? (06/04/85 MIA)
	FO	CBKDEF
	JN	IXENDN			:IGNORE IF NOT (06/04/85 MIA)
	LHI	R0,L.NATV		:ENTER NATIVE MODE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LHI	R2,NSFNLG^8		:INFORM LU.SVC
	LIS	R3,0
	LIS	R8,0
:	LHL	R11,DCBLKS+DCBLUC,RDCB,	:(06/04/85 MIA)
	JAL	R6,QDIFSN
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,FNLGFL,,
:IF PHYSICAL TIMEOUT BY TERMINAL IS USED TIMEOUT VALUE IS DETERMINED
:BY DCBAPI FIELD (01/15/85 MIA).
	IF	PHTIMO
	LB	R6,DCBLKS+DCBAPI,RDCB,	:GET APPL ID
	JNFS	NDHSTA			:JUMP IF NOT 0
	LIS	R0,0			:OVERRRIDE THE TIMEOUT
	JFS	NDHSTB			:JUMP TO CONTINUE
NDHSTA	EQ	.
	EI
	LHL	R0,LUCTAB+LUIATO,R11,	:GET INACTIVITY TIMEOUT
	IF	PHTIMO
NDHSTB	EQ	.
	EI
	STH	R0,DCBLKS+DCBIA1,RDCB,	:SAVE IN DCB
	JEFS	NDHST3			:JUMP,IF NO TIMEOUT VALUE DEFINED
	GL	DHIATV
	LHI	R0,DHIATV-PSEG		:GET ENTRY FOR TIMEOUT
NDHST3
	STH	R0,DCBLKS+DCBIAT,RDCB,	:SAVE TIMEOUT ENTRY
	LHL	R0,LUCTAB+LUCT.N,R11,	:ENABLE TIMER (10/23/85/CHS)
	GL	BDPETE
	SBT	R0,BDPETE,,		:ENABLE INACTIVITY TIMER
					:(F00/02/12/87/DB/START/ CRM 4)
: IF THERE IS AN ATTACHED LU, THEN THE ATTACHED LU SHOULD HAVE THE
: INACTIVITY TIMER RESET ALSO.
	LHL	R11,DCBLKS+DCBCRD,RDCB,	:IS THERE AN ATTACHED LU?
	JE	NDHST5			:NO
	LHL	R2,LUCTAB+LUCDCB,R11,	:YES, GET DCB OF ATTACHED LU
	JE	NDHST5			:NO DCB DONE
	IF	PHTIMO
	LB	R6,DCBLKS+DCBAPI,R2,	:GET APPL ID
	JNFS	NDHSTC			:JUMP IF NOT 0
	LIS	R0,0			:OVERRRIDE THE TIMEOUT
	JFS	NDHSTD			:JUMP TO CONTINUE
NDHSTC	EQ	.
	EI
	LHL	R0,LUCTAB+LUIATO,R11,	:GET ATTACHED LU INACTIVITY TIMEOUT
	IF	PHTIMO
NDHSTD	EQ	.
	EI
	STH	R0,DCBLKS+DCBIA1,R2,	:SAVE IN ATTACHED DCB
	JEFS	NDHST4			:JUMP,IF NO TIMEOUT VALUE DEFINED
	GL	DHIATV
	LHI	R0,DHIATV-PSEG		:GET ENTRY FOR TIMEOUT
NDHST4
	STH	R0,DCBLKS+DCBIAT,R2,	:SAVE TIMEOUT ENTRY
	LHL	R0,LUCTAB+LUCT.N,R11,	:ENABLE TIMER (10/23/85/CHS)
	GL	BDPETE
	SBT	R0,BDPETE,,		:ENABLE INACTIVITY TIMER
NDHST5
					:(F00/02/12/87/DB/END)
	J	IXENDN
	EI	(HOSTIF)

:	SUBTTL	(SNA-GDSP) BSC/DSP PROCESSES
:
:
:
:	GENERATE 'BSC/DSP' MESSAGES PROCESSING TABLE
:
:
:	IF	TERMIF
:	GENDSP(BSTDSP)			:BSC/DSP PROCESS TABLE
:	EI	(TERMIF)
:
:	IF	HOSTIF
:	GENDSP(BSHDSP)			:BSC/DSP PROCESS TABLE
:	EI	(HOSTIF)

	FO	CBKDEF
	FO	GBLDEF

	EM
  	SUBTTL	(SNA-NNIO) NNIO - GENERAL PROCESSES & ROUTINES
:NNIO00.Z00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	RA	0

	MO	.,NIO
	GL	ISIEND

	LO	MAIN
	LO	GBLDEF
	LO	CMDLST
	LO	BSUB
	LO	GDSP
	LO	GIIX
	LO	FRNTND
	LO	CBKDEF

:
:	THIS FILE CONTAINS:
:		A. ISIS DATA INPUT GENERAL PROCESSSES
:		B. ISIS NATIVE SNA MODE DATA INPUT PROCESSES
:		C. ISIS LOGON MODE DATA INPUT PROCESSES
:

	SUBTTL	(SNA-NNIO) ISIS DATA INPUT GENERAL DEFINITIONS


:	DEFINE REGISTER'S USAGE
:	-----------------------
RBCC	EQ	R8			:BB DATA BYTE COUNT
RBBA	EQ	R10			:CURRENT BB ADDR
RBBX	EQ	R9			:CURRENT BB INDEX

:	DEFINE LOCAL STORAGES
:	----------------------
	SEG	A.DATA
ISCSAV	WS	1			:SAVE AREA

	SEG	A.CODE

	SUBTTL (SNA-NNIO) ISIS DATA INPUT DISPATCHER & PROCESSING ROUTINE


:	ISIS DATA INPUT DISPATCHER
:	--------------------------
:	LINKS R5, CALLED FROM FRNTND
:	RPORT(R1) - ISIS PORT
:	R2 - DATA MSG LENGTH
:	R5 IS SAVED IN DCB, SUBPROCESSOR IS CALLED THRU R5, AND
:	MAY RETURN THRU R5, OR DIRECT  JUMP IN EXIT ENTRY POINT
GISDIN
	ST	R5,DCBLKS+DCBRET,RDCB,	:SAVE FRNTND LINK R5
	RBT	RPORT,PTIME,,		:CLEAR FRNTND TIMER
	BBL	RBBA,DCBLKS+DCBIBA,RDCB, :SET UP RBBA
	LH	RBBX,DCBLKS+DCBIBX,RDCB, :SET UP RBBX
	LHL	RBCC,DCBLKS+DCBICC,RDCB, :SET UP RBCC
GISDI1
	JAL	R4,GETCH,,		:GET NEXT INPUT BYTE
	SIS	R2,1			:DECREASE BYTE CNT BY 1
	LHL	R4,DCBLKS+DCBINP,RDCB,	:GET INPUT DATA SUB PROC ROUTINE
	JAL	R5,PSEG,R4,		:PROC THIS BYTE
	STH	R4,DCBLKS+DCBINP,RDCB,	:IF RETURN THRU HERE, R4 SET UP
	LR	R2,R2			:END OF ISIS INPUT ?
	JNBS	GISDI1			:NO, REPEAT
:	ISEND:	END OF ISIS INPUT
:	-----
GISDI2;ISEND
	STH	RBCC,DCBLKS+DCBICC,RDCB, :SAVE RBCC
	STH	RBBX,DCBLKS+DCBIBX,RDCB, :SAVE RBBX
	BBST	RBBA,DCBLKS+DCBIBA,RDCB, :SAVE RBBA
	AR	R14,R2			:FLUSH REMAINNING DATA, IF ANY
	L	R5,DCBLKS+DCBRET,RDCB,	:YES, BUT NOT CHANGE SUB PROC.
	JR	R5			:AND TIMER, RETURN TO FRNTND

:	GINIIX: GLOBAL & DIALECT IIX DECODER
:	--------
:	SIIX RECEIVED LAST TIME
:	THE NEXT ISIS DATA RCD MUST BE IIX FORMATED
:	SET UP GLOBAL OR DIALECT IIX PROCESSING ROUTINE
GINIIX
	CLHI	R0,IIXGBL		:IS THIS A IIX GLOBAL MSG?
	JE	GINGBX			:YES, SKIP
	CLHI	R0,IIXDIL		:IS THIS A IIX DIALECT MSG?
	JE	GINDLX			:YES, SKIP
	JAL	R10,CRASH,,		:ELSE, ILLEGAL MSG OR PROGRAMMING
	BC	0,0,0,CRINVX		: ERROR

:	GINGBX:	DECODE GLOBAL IIX MSGS & DISPATCH
:	--------
GINGBX
	LHI	R4,GINGB0-PSEG		:SET NEW ENTRY POINT
	JR	R5			:RETURN TO GISDIN, TO GET IIX CODE
GINGB0					:R0 = IIX CODE
	CLHI	R0,SELDIA&0FF		:1ST ONE IS SELDIA
	JL	GINGB1			:ILLEAGEL GLOBAL IIX MSGS
	CLHI	R0,IDVREQ&0FF		:LAST ONE IS IDVREQ
	JG	GINGB1			:ILLEGAL
					:ELSE LEGAL IIX GLOBAL MSGS
	LR	R4,R0			:PUT COMMAND TO R4
	SHI	R4,SELDIA&0FF		:CALCULATE OFFSET
	SLHLS	R4,1			:MAKE HW INDEX
	LHL	R6,DCBLKS+DCBGIX,RDCB,	:GET GLOBAL IIX PROC TABLE
	LHL	R6,PSEG,R6,R4		:GET OFFSET OF PROC ROUTINE
	J	PSEG,R6,,		:GO TO PROC IT
GINGB1					:ILLEGAL GLOBAL IIX MSG
	JAL	R10,CRASH,,
	BC	0,0,0,CRINVX

:	GINDLX:	DIALECT IIX MSGS DECODER $ DISPATCH
:	--------
GINDLX
	LHI	R4,GINDL0-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:RETURN TO GISDIN TO GET IIX CODE
GINDL0					:R0 = IIX CODE
	CLHI	R0,CLDADR&0FF		:1ST ONE IS CLDADR
	JL	GINDL1			:ILLEAGEL DIALECT IIX MSGS
	CLHI	R0,RSETID&0FF		:LAST ONE IS RESET ONDICATOR
	JG	GINDL1			:ILLEGAL
					:ELSE, LEGAL IIX DIALECT MSGS
	LR	R4,R0			:PUT COMMAND TO R4
	SHI	R4,CLDADR&0FF		:CALCULATE OFFSET
	SLHLS	R4,1			:MAKE HW INDEX
	LHL	R6,DCBLKS+DCBLIX,RDCB,	:GET IIX DIALCET PROC TABLE
	LHL	R6,PSEG,R6,R4		:GET OFFSET OF ROUTINE
	J	PSEG,R6,,		:GO TO PROC IT
GINDL1					:ILLEGAL IIX DIALECT MSGS
	JAL	R10,CRASH,,
	BC	0,0,0,CRINVX


	SUBTTL	(SNA-NNIO) NATIVE MODE - INPUT ASCII DATA MSGS


:	NINASC:	RECEIVE ASCII DATA, DISCARD
:	-------
NINASC
	J	ISEND			:FLUSH DAT, RETURN TO GISDIN

	SUBTTL (SNA-NNIO) NATIVE MODE - INPUT DIALECT IIX DATA/DQ MSGS


:	C094 = DATA PACKET
:	-------
NINPDA
	LHI	R4,NINPD1-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO READ NEXT BYTE
NINPD1					:R0 = DIALECT DATA FLAG
	STB	R0,DCBLKS+DCBDFG,RDCB,	:SAVE IN TO DCB
	LHI	R4,NINPD2-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO READ NEXT BYTE
NINPD2					:R0 = THE 1ST BYTE OF MSG LENGTH
	STH	R0,DCBLKS+DCBICC,RDCB,	:SAVE TO DCBICC
	LR	RBCC,R0			:IN CASE DISMISS AT HERE
	LHI	R4,NINPD3-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO READ NEXT BYTE
NINPD3					:R0 = 2ND BYTE OF LENGTH
	LHL	R4,DCBLKS+DCBICC,RDCB,	:GET 1ST BYTE
	SLHLS	R4,8			:SHIFT BYTE LEFT
	OR	R0,R4			:GET LENGTH IN HW
	STH	R0,DCBLKS+DCBIPL,RDCB,	:SAVE IT INTO DCB
	LB	R0,DCBLKS+DCBDFG,RDCB,	:GET DATA PACKET FLAG
	THI	R0,QBIT			:DQ PACKET
	JN	NINPDQ			:YES, SPECAIL HANDLE
	IF	VHRSUP
:
:BEGIN (05/05/86 YLH)
:
	LHL	R11,DCBLKS+DCBLUC,RDCB, :SET UP THE CORRESPONDING LUCTAB PTR
	LB	R0,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	THI	R0,LUSVCP		:SVC LOGON IN PROGRESS?
	JE	NINPT5			:NO, NORMAL DATA PACKET PROCESSING
	LIS	R6,0C			:YES, LOGON ERROR
	AHM	R6,DCBLKS+DCBIPL,RDCB,
NINPT0	SIS	R6,1			:DECREMENT CHAR COUNT
	LR	R6,R6			:ALL STRIPPED?
	JEFS	NINPT1			:YES
	LHI	R4,NINPT0-PSEG		:STRIP OFF COMMAND HEADER
	JR	R5			:NO, DISCARD NEXT CHAR
:
:FILL IN CADR1 AND CADR2 AND SEND LOGON REPLY RU TO VTR. THIS CODE ASSUMES
:THAT REPLY RU IS 1 SEGMENT 1 ELEMENT CHAIN. IF NOT THIS CODE SHOULD BE
:CHANGED LATER.
:
NINPT1	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET  POINTER TO PREPARED REPLY
	LHI	R6,VHRCNT		:PREPARE CONTINUE LOGON
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA1,R3,	:FILL CADR1
	LIS	R6,VHRCDR		:PREPARE CADR2(CD)
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:FILL CADR2
	LHI	R6,VHREZP		:PREPARE ERROR CODE FOR VTR
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCDE,R3,	:SET ERROR CODE
:
:	PASS THE DSP TEXT TO THE SNA ONLY IF IT IS A MANUAL LOGON
:
	THI	R0,LUMNLG		:IS THIS A MANUAL LOGON?
	JE	NINPT4			:NO, SEND REPLY RU TO THE SNA
:
:	FOR MANUAL LOGON, THE DSP DATA IS PASSED TO THE SNA
:	CREATE 3270 WRITE COMMAND HEADER
:
	LR	RBBA,R3			:LET RBBA HAS THE BUFFER BASE ADDR.
	LHL	RBCC,DCBLKS+DCBALU,RDCB, 	:GET MESSAGE LENGTH
	LHI	RBBX,FID2LN+RHLENG+VHRCDE+1	:INDEXING BEYOND THE ERROR CODE
	JAL	R6,PTVHRH,,
NINPT2	LHI	R4,NINPT3-PSEG		:GET ERROR MSG
	JR	R5
NINPT3	JAL	R6,PTIBC,,		:PUT IT INTO THE BUFFER
	LCS	R0,1			:DECREMENT THE BYTE COUNT
	AHM	R0,DCBLKS+DCBIPL,RDCB,
	JGBS	NINPT2
NINPT4	LHI	R6,L.ERCK		:MAKE IT UNRECOVERABLE ERROR
	STB	R6,DCBLKS+DCBSTA,RDCB,
	LHI	R2,NSETEM^8!NSDTCD	:ASSUME SINGLE SEG, SINGLE RU CHAIN
	JAL	R6,QDIFSN,,		:SEND IT TO SNA
	JR	R5			:AND RETURN
:
:	NORMAL DATA PACKET HANDLING PROCEEDING HERE
:
:END (05/05/86 YLH)
:
	EI
NINPT5	LHI	R4,NINPD4-PSEG		:TO READ UCN
:
	IF	BTRACE
	LIS	R0,BTRIBT		:SEE IF TRACNG INPUT
	TBT	R0,BTRIOF,,		:...
	JER	R5			:NO, RETURN TO NIO DISPATCHER
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R0,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R0,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LHL	R0,DCBLKS+DCBIPL,RDCB,	:R0 = IPL COUNT
	OHI	R0,BTRINP+BTRBEG	:INPUT AND BEGIN
	STH	R0,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R0,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R0,FASTC,,		:ELSE, MUST BE FASTC
	ST	R0,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

	JR	R5			:TO READ NEXT BYTE
NINPD4					:R0 = UCN BYTE, IGNORE
	LHI	R4,NINPD5-PSEG		:TO READ CTL BYTE
	NHI	R0,BIT.FS
	JER	R5			:1ST SEG, EXIT
	LCS	R0,1			:NOT INCLUDE UCN BYTE
	J	NINPDX			:SKIP, TO CONINUTE
NINPD5					:R0 = CTL BYTE
	LHI	R4,NINPD6-PSEG		:TO READ ISQ BYTE
	JR	R5			:TO READ NEXT BYTE
NINPD6					:R0 = ISQ
	LB	R6,DCBLKS+DCBISQ,RDCB,	:GET EXPECTED ISQ-1
	AIS	R6,1			:R6 = EXPECTED ISQ
	NHI	R6,0FF			:ONE BYTE ONLY
	CR	R6,R0			:COMPARE
	JN	CLRCIR			:NOT THE SAME
	STB	R0,DCBLKS+DCBISQ,RDCB,	:SAVE NEW ISQ INTO DCB
	LCS	R0,3			:UCN+CTL+ISQ
NINPDX
	AHM	R0,DCBLKS+DCBIPL,RDCB,
	JAL	R6,SINPBB		:SET UP NEW BUFFERLET
	LHI	R4,NINPD7-PSEG		:SET UP NEW ENTRY
	JR	R5			:TO READ NEXT BYTE
NINPD7					:R0 = DATA BYTE
	AIS	RBCC,1			:INCREMENT INPUT CHAR COUNT
	AIS	RBBX,1
	STB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA
	JNFS	NINPD8			:BUFFERLET NOT FULL YET, SKIP
	JAL	R6,GINPBB		:ELSE, GET A NEW BUFFERLET
NINPD8
	CLH	RBCC,DCBLKS+DCBIPL,RDCB, :OVERFLOW/END OF FUL PACKET/ ..
	JEFS	NINPD9			:END OF PACKET
	JG	NOVFER			:OVERFLOW
	LHI	R4,NINPD7-PSEG		:SET UP NEW ENTRY
	JR	R5			:TO READ NEXT BYTE
NINPD9
	JAL	R6,PINDTA		:QUEUE IT TO NWKC->SNA DATA-Q

	IF	BTRACE
	LIS	R0,BTRIBT		:SEE IF TRACNG INPUT
	TBT	R0,BTRIOF,,		:...
	JE	NINPDY			:NO, SKIP
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R0,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R0,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LHL	R0,DCBLKS+DCBIPL,RDCB,	:R0 = IPL COUNT
	OHI	R0,BTRINP+BTREND	:INPUT AND END
	STH	R0,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R0,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R0,FASTC,,		:ELSE, MUST BE FASTC
	ST	R0,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

NINPDY
	LIS	R0,0
	BBST	R0,DCBLKS+DCBIBH,RDCB,
	BBST	R0,DCBLKS+DCBIBA,RDCB,
	STH	R0,DCBLKS+DCBICC,RDCB,
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
:	IF TIMEOUT BY PHYSICAL TERMINAL IS USED, TIMEOUT VALUE COULD
:	BE OVERRIDDEN BY APPLICATION IDENTIFIER.
	IF	PHTIMO
	LB	R6,DCBLKS+DCBAPI,RDCB,	:GET APPLICATION ID
	JNFS	NINPDZ			:JUMP IF NO OVERRIDE
	LIS	R0,0			:OVERRIDE TIMEOUT
	JFS	NINPDW			:JUMP TO CONTINUE
NINPDZ
	EI
	LHL	R0,LUCTAB+LUIATO,R11,	:GET SYSGEN INA. TIMEOUT VAL.
	IF	PHTIMO
NINPDW
	EI
	STH	R0,DCBLKS+DCBIA1,RDCB,	:SET INA. TIMEOUT IN DCB
:(F00/02/12/87/DB/START/CRM 4)
: IF THIS LU HAS AN ATTACHED LU, THEN THE ACTIVITY TIMER FOR THE ATTACHED
: LU MUST ALSO BE RESET.
	LHL	R11,DCBLKS+DCBCRD,RDCB,	:IS THERE AN ATTACHED LU?
	JE	NINPDD			:NO
	LHL	R4,LUCTAB+LUCDCB,R11,	:YES, GET DCB OF ATTACHED LU
	JE	NINPDD			:NO DCB DONE
	IF	PHTIMO
	LB	R6,DCBLKS+DCBAPI,R4,	:GET APPLICATION ID
	JNFS	NINPDB			:JUMP IF NO OVERRIDE
	LIS	R0,0			:OVERRIDE TIMEOUT
	JFS	NINPDC			:JUMP TO CONTINUE
NINPDB
	EI
	LHL	R0,LUCTAB+LUIATO,R11,	:GET SYSGEN INA. TIMEOUT VAL.
	IF	PHTIMO
NINPDC
	EI
	STH	R0,DCBLKS+DCBIA1,R4,	:SET INA. TIMEOUT IN DCB
NINPDD
					:(F00/02/12/87/DB/END)
	J	IXENDN			:END OF IIX INPUT

:
:	DQ PACKET HANDLING
:	-----------------
:
NINPDQ
	J	GDSPIX			:TO PROC Q-PACKET & DSP

:	NOVFER:	DATA OVERFLOW
:	-------
NOVFER
	JAL	R10,CRASH,,
	BC	0,0,0,088


	SUBTTL	(SNA-NNIO) LOGON MODE - INPUT ASCII DATA MSGS


	IF	TERMIF!VHRSUP

:	LINASC:	RECEIVE ASCII DATA
:	------
:	CONVERT IN TO PLU-SLU SESSION DATA
LINASC
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC
	NHI	R0,7F			:STRIP OFF PARITY BIT
	IF	VHRSUP
	LB	R4,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	THI	R4,LUVHRF		:VHR FUNCTION?
	JN	LINAVR			:JUMP IF SO
	EI
	EI
	IF	TERMIF
	CLHI	R0,ACR.			:IS IT A CR ?
	JE	LINAS4			:YES, SKIP
	CLHI	R0,ASP.			:SPECIAL CHAR?
	JGEFS	LINAS1			:NO, SKIP
	CLHI	R0,ALF.			:IS IT A LF?
	JE	LINAS5			:YES, IGNORE
	LHI	R0,ASTER.		:ELSE, CONVERT INTO '*'
LINAS1
	LIS	R4,D.ASCD		:SET ASCII DATA RCV'ED
	SBT	R4,DCBLKS+DCBMOD,RDCB,
	LR	R6,R0			:CONVERT INTO EBCDIC
	LB	R0,ASCBCD,R6,		:...
	BBL	R3,DCBLKS+DCBIBH,RDCB,	:MESSAGE STARTED YET ?
	JN	LINAS3			:YES, SKIP
	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE THE CHAR
	JAL	R6,PTIBH		:START MSG BB
	LHI	R0,WCMD			:WRITE WCMD
	JAL	R6,PTIBC		:...
	LIS	R0,D.INLK		:INTERLINK MESSAGE?
	RBT	R0,DCBLKS+DCBMOD,RDCB,
	JE	LINAS2			:REGULAR, SKIP
	LHI	R0,WCCK			:WCCK
	JAL	R6,PTIBC		:..
	LHI	R0,SBA.			:SBA.
	JAL	R6,PTIBC		:...
	LIS	R4,3			:ROW = 3
	LIS	R7,0			:COLUMN = 0
	LHI	R0,$A80			:ROW SIZE = 80
	JAL	R6,SBADDR		:CALCAULTE SBB ADDR
	J	LINASX			:SKIP
LINAS2
	LHI	R0,WCCAK		:WCCAK
	JAL	R6,PTIBC		:..
	LHI	R0,SBA.			:SBA.
	JAL	R6,PTIBC		:...
	LIS	R4,2			:ROW = 2
	LIS	R7,0			:COLUMN = 0
	LHI	R0,$A80			:ROW SIZE = 80
	JAL	R6,SBADDR		:CALCAULTE SBB ADDR
LINASX
	EXBR	R0,R0			:WRITE 1ST BYTE
	JAL	R6,PTIBC		:...
	EXBR	R0,R0			:WRITE 2ND BYTE
	JAL	R6,PTIBC		:...
	LHI	R0,SF.			:INSERT SF
	JAL	R6,PTIBC
	LHI	R0,ATPND		:ASSUME IBM/FUJITSU
	LB	R6,LUCTAB+LUCSYS,R11,	:SEE IF HITACHI
	CLHI	R6,HITACHI
	JNFS	LINASY			:NOT HITACHI, SKIP
	LHI	R0,HAPND		:INSERT HITACHI ATPND
	EXBR	R0,R0			:SET UP 1ST ATTRIBUTE BYTE
	JAL	R6,PTIBC		:...
	EXBR	R0,R0			:SET UP 2ND ATTRIBUTE BYTE
LINASY
	JAL	R6,PTIBC		:WRITE ATTRIBUTE BYTE
	LB	R0,DCBLKS+DCBTMP,RDCB,	:RESTORE R0 = CHAR
LINAS3
	JAL	R6,PTIBC
	LHI	R4,LINASC-PSEG	
	JR	R5			:TO READ NEXT BYTE
LINAS4
	LHI	R4,LINASC-PSEG	
	BBL	R3,DCBLKS+DCBIBH,RDCB,	:ALREADY HAV AS MSG ?
	JER	R5			:NO , TO READ NEXT BYTE
:	(04/07/86/CHS) INSERT NO-DISP ATTRIBUTE AT END OF MSG
	LHI	R0,SF.			:INSERT SF
	JAL	R6,PTIBC
	LHI	R0,ATPNN		:ASSUME IBM/FUJITSU
	LB	R6,LUCTAB+LUCSYS,R11,	:SEE IF HITACHI
	CLHI	R6,HITACHI
	JNFS	LINASZ			:NOT HITACHI, SKIP
	LHI	R0,HAPNN		:INSERT HITACHI ATPNN
	EXBR	R0,R0			:SET UP 1ST ATTRIBUTE BYTE
	JAL	R6,PTIBC		:...
	EXBR	R0,R0			:SET UP 2ND ATTRIBUTE BYTE
LINASZ
	JAL	R6,PTIBC		:WRITE ATTRIBUTE BYTE
:	(04/07/86/CHS) END
	LR	R10,R2			:SAVE R2
	BBL	R3,DCBLKS+DCBIBH,RDCB,
	LHI	R2,NSINTM^8
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	JAL	R6,QDIFSN		:QUEUE MSG TO NWKC->SNA DATA-Q
	LIS	R0,0
	BBST	R0,DCBLKS+DCBIBH,RDCB,
	BBST	R0,DCBLKS+DCBIBA,RDCB,
	STH	R0,DCBLKS+DCBICC,RDCB,
	LIS	R0,D.ASCD
	RBT	R0,DCBLKS+DCBMOD,RDCB,
	LR	R2,R10			:RESTORE R2
LINAS5
	LHI	R4,LINASC-PSEG	
	JR	R5			:TO READ NEXT BYTE

	EI	(TERMIF)

	IF	VHRSUP
:IF THIS LU PERFORMS VHR FUNCTION AND IS CURRENTLY IN VTR/MANUAL
:LOGON MODE, THE MESSAGES RECEIVED ARE PASSED TO VTR IN THE
:REPLY RU CHAIN. ALL MESSAGES ARE ACCUMULATED AND CONVERTED TO
:3270 DATA STREAM. REPLY RU WILL BE SEND UPON COMPLETEION OF
:THE LOGON STAGE.
LINAVR	THI	R4,LUSVCP		:SVC LOGON IN PORGRESS?
	JE	LINAVP			:JUMP IF NOT
	THI	R4,LUMNLG		:MANUAL LOGON FOR VTR?
	JE	ISEND			:THROW IT AWAY IF NOT
	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET POINTER TO MSG HEAD POINTER
	JE	ISEND			:DISCARD EVERYTHING IF NOT SET
	LHL	R4,DCBLKS+DCBALU,RDCB,	:GET MESSAGE COUNTER
	CLH	R4,DCBLKS+DCBSGL,RDCB, :TOO MANY CHAR ALREADY RECEIVED?
	JG	LINAVB			:JUMP IF SO
	CHI	R4,FID2LN+RHLENG+VHRCA2+1	:ANYTHING ALEARDY THERE?
	JG	LINAV1			:JUMP IF SO

:FIRST DATA BYTE AFTER VHR HEADER. PUT WCMD, WCC, SF AND SBA THERE.
	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE NEW CHARACTER
	JAL	R6,PTVHRH		:PUT 3270 WRITE HEADER
	LB	R0,DCBLKS+DCBTMP,RDCB,	:RESTORE NEW CHARACTER
LINAV1	CHI	R0,ASP.			:CONTROL CHARACTER?
	JGEFS	LINAV2			:JUMP IF NOT
	LHI	R0,ASTER.		:REPLEACE CONTROL CHAR BY *
LINAV2	LR	R6,R0			:COPY THE CHARACTER
	LB	R0,ASCBCD,R6		:TRANSLATE TO EBCDIC
	JAL	R6,PTIBC		:PUT IN THE BUFFER
	LHI	R4,LINASC-PSEG		:START FROM THE BEGINNING
	LIS	R6,1			:PREPARE 1
	AHM	R6,DCBLKS+DCBALU,RDCB,	:INCREASE MESSAGE COUNTER
	JR	R5			:AND RETURN

	GL	CR.TMP
LINAVP
LINAVB	JAL	R10,CRASH,,
	HC	0
	HC	4*R5,CR.TMP		:TEMPORARY CRASH

	EI

:	ISIEND:	END OF ISIS INPUT
:	--------
ISIEND
	ST	R6,ISCSAV,,		:SAVE R6
	BBL	R3,DCBLKS+DCBIBH,RDCB,
	JER	R6			:NO MSG YET, RETURN
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	LHL	R8,DCBLKS+DCBICC,RDCB,
	LIS	R0,D.ASCD		:ASCII OR IIX DATA
	RBT	R0,DCBLKS+DCBMOD,RDCB,
	JE	ISIEN1			:IIX DATA, SKIP
	LHI	R2,NSINTM^8
	JAL	R6,QDIFSN		:QUEUE MSG TO NWKC->SNA DATA-Q
	JFS	ISIEN2			:SKIP
ISIEN1					:IIX DATA
	JAL	R6,PINDTA
ISIEN2					:CLEAN UP
	LIS	R0,0
	BBST	R0,DCBLKS+DCBIBH,RDCB,
	BBST	R0,DCBLKS+DCBIBA,RDCB,
	STH	R0,DCBLKS+DCBICC,RDCB,
	L	R6,ISCSAV,,		:RESTOR
	JR	R6			:RETURN

	SUBTTL	(SNA-NNIO) LOGON MODE - INPUT DIALECT IIX DADTA/DQ MSGS


:	SAME AS NATIVE MODE

	FO	CBKDEF
	FO	GBLDEF
	EM
	SUBTTL	(SNA-NISC) ISIS CONTROL - GENERAL PROCESSES & ROUTINES
:NISC00.Z00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	06/06/84 (NCS) -- MODIFIED 'SNHZAP' ROUTINE FOR BSC/DSP
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	RA	0

	MO	.,ISISC
:	GL	DTHOSC,DTHOSD	(04/13/87 YLH)
	GL	UCPMSG

	LO	MAIN
	LO	GBLDEF
	LO	CMDLST
	LO	FRNTND
	LO	GIIX
	LO	GDSP
	LO	NIO
	LO	BSUB
	LO	CBKDEF

:
:	THIS FILE CONTAINS:
:		A. ISIS PORT ZERO MESSAGE PROCESSES
:		B. ISIS INACTIVE MODE CONTROL PROCESSES
:		C. ISIS NATIVE SNA MODE CONTROL PROCESSES
:		D. ISIS LOGON MODE CONTROL PROCESSES
:

	SUBTTL	(SNA-NISC) ISIS CONTROL GENERAL DEFINITIONS


	SEG	A.CODE

:	DEFINE REGISTER'S USAGE
:	-----------------------
RLINK	EQ	R5			:LINK FROM FRNTND
RBCC	EQ	R8			:BB DATA BYTE COUNT
RBBA	EQ	R10			:CURRENT BB ADDR
RBBX	EQ	R9			:CURRENT BB INDEX

:	PORT ZERO MESSAGES
:	-------------------
RESREQ	EQ	0			:RESTART REQUEST
RESREP	EQ	1			:RESTART RESPONSE
TAKOVR	EQ	2			:TAKE OVER (FROM SUP)
SUPREP	EQ	3			:REPORT TO SUP
HSTSTA	EQ	4			:HOST STATUS
RPTACT	EQ	5			:REPORT ACCOUNTING
TELTIM	EQ	6			:TELL HOST TIME
PSDREQ	EQ	7			:PSEUDO NEEDLE REQUEST
AUXREQ	EQ	8			:AUX CIRCUIT REQUEST
PSDREJ	EQ	9			:PSEUDO NEEDLE REJECT
HSTPOR	EQ	0A			:HOST PORT AVAILABILITY
HSTREJ	EQ	0B			:HOST REJECTED (UNACCEPTABLE)
HSTCST	EQ	0C			:REPORT HOST COST
NO.SUP	EQ	0D			:NO SUP
.1DOWN	EQ	0E			:ONE-DOWN MESSAGE
RPAHST	EQ	0F			:REPORT ALL HOSTS
EHSTST	EQ	10			:EXTENDED REPORT HOST STATUS

:	DEFINE LENGTH OF PORT ZERO MESSAGES
:	-----------------------------------
RREQLN	EQ	3			:0  - RESTART REQUEST
RREPLN	EQ	3			:1  - RESTART RESPONSE
TKOVLN	EQ	4			:2  - TAKE OVER (FROM SUP)
RSUPLN	EQ	9			:3  - RESPORT TO SUP
HSTALN	EQ	0C			:4  - HOST STATUS
RACTLN	EQ	08			:5  - REPORT ACCOUNTING
TTIMLN	EQ	08			:6  - TELL HOST TIME
NREQLN	EQ	0B			:7  - PSEUDO NEEDLE REQUEST
XREQLN	EQ	0B			:8  - AUX CIRCUIT REQUEST
PREJLN	EQ	07			:9  - PSEUDO NEEDLE REJECT
HPRALN	EQ	0A			:0A - HOST PORT AVAILABILITY
HREJLN	EQ	07			:0B - HOST UNACCEPTABLE
HCSTLN	EQ	0A			:0C - REPORT HOST COST
NSUPLN	EQ	03			:0D - NO SUP
.1DNLN	EQ	0E			:0E - ONE-DOWN MESSAGE
RAHSLN	EQ	03			:0F - REPORT ALL HOSTS
EHSTLN	EQ	0E			:10 - EXTENDED REPORT HOST STATUS

:	APPLICATION MESSAGES
:	---------------------
HOPMSG	SC	/"8A"8DHost out of ports. Please try again."8D"8A/
GOODBY	SC	/"8D"8AGOOD BYE..."8D"8A/
UCPMSG	SC	/"8A"8DLogon Failed or Un-compatible Host."8D"8ATry again or contact TYMNET Headquarter Technical Services."8D"8A/


:	DEFINE LOCAL STORAGES
:	----------------------
	SEG	A.DATA
IR5SAV	WS	1			:R5 SAVE AREA
IR6SAV	WS	1			:R6 SAVE AREA
IRBSAV	WS	1			:R11 SAVE AREA(F00/03/23/87/DB)
DCBSAV	WS	1			:RDCB SAVE AREA (F00/02/12/87/DB)
:	DEFINE REQUEST FOR NEEDLE ISIS FORMAT
:	-------------------------------------
RQNDLE  EQ      .                       :REQUEST FOR NEEDLE 
	HC	0000			:PORT ZERO
RQTYP   BC      PSDREQ,00		:PSEUDO NEEDLE REQUEST
RQLCKY	HC	0000,0C000		:LOCAL KEY, CIR IQ & EXT LOGON STATUS
RQHST   HC      0000			:ORIG. HOST #
        BC      TID			:TID

:	DEFINE LOGON CHAR ISIS MSG FORMAT
:	---------------------------------
RQNDL2  EQ      .
LOGCHR  BC      02                      :LOGON CHARACTER MESSAGE
        BC      NLOGCH			:NORMAL LOG CHAR (B3)
LGCHR   BC      0			:LOGON CHAR

:	STORAGE FOR ADDENDUM TO ACC DATA
:	----------------------------------
ACCDAT	WS	1

	SEG	A.CODE

	SUBTTL (SNA-NISC) ISIS PORT ZERO MESSAGES HANDLER


:	EMPTYI/EMPTYO
:	--------------
:	LINK ON R4
:	REQUIRED BY FRNTND MODULE
EMPTYI;EMPTYO
	JR	R4

:	PORT ZERO MESSAGE PROCESSING ROUTINE
:	-------------------------------
:	LINKS ON R5, R14 SET UP

:	PROLEN:	DEFINE PORT ZERO MESSAGES'S LENGTH
:	-------
PR0LEN
	BC	RREQLN-3,RREPLN-3
	BC	TKOVLN-3,RSUPLN-3
	BC	HSTALN-3,RACTLN-3
	BC	TTIMLN-3,NREQLN-3
	BC	XREQLN-3,PREJLN-3
	BC	HPRALN-3,HREJLN-3
	BC	HCSTLN-3,NSUPLN-3
	BC	.1DNLN-3,RAHSLN-3
	BC	EHSTLN-3
	HS	0

:	PR0ACT:	PORT ZERO ACTION TABLE
:	-------
PR0ACT
	HC	PR0AC2-PSEG		: 0  - RESTART REQUEST
	HC	PR0AC2-PSEG		: 1  - RESTART RESPONSE
	HC	PR0AC3-PSEG		: 2  - SUP TAKE OVER
	HC	PR0AC2-PSEG		: 3  - REPORT TO SUP
	HC	PR0AC2-PSEG		: 4  - HOST STATUS
	HC	PR0AC2-PSEG		: 5  - REPORT ACCOUNTING
	HC	PR0AC2-PSEG		: 6  - TELL HOST TIME
	HC	PR0AC2-PSEG		: 7  - PSUEDO NEEDLE REQUEST
	HC	PR0AC2-PSEG		: 8  - AUX CIRCUIT REQUEST
	HC	PR0AC4-PSEG		: 9  - PSEUDO NEEDLE REJECT
	HC	PR0AC2-PSEG		: 0A - HOST PORT AVAILABILITY
	HC	PR0AC1-PSEG		: 0B - HOST UNACCEPTABLE
	HC	PR0AC2-PSEG		: 0C - REPORT HOST COSE
	HC	PR0AC2-PSEG		: 0D - NO SUP
	HC	PR0AC2-PSEG		: 0E - ONE.DOWN MESSAGE
	HC	PR0AC1-PSEG		: 0F - REPORT ALL HOST
	HC	PR0AC2-PSEG		: 10 - EXTENDED REPORT HOST STATUS
PR0MSG	EQ	(.-PR0ACT)/2-1		:MAX PORT ZERO MSG TYPE

:	ACTIV0:	PORT ZERO PROCESSING ROUTINE
:	-------
ACTIV0;ACTI0V
	CLHI	R2,PR0MSG		:WITHIN RANGE
	JE	PR0AC1			:TO CRASH
	LHL	R4,PR0ACT,R2,R2		:GET PORT 0 ACTION ROUTINE
	J	PSEG,R4,,		:TO ...

:	PR0AC1:	ILLEAGE PORT ZERO MSGS
:	------
PR0AC1
	JAL	R10,CRASH,,
	BC	0,0,4*RLINK,0DD

:	PR0AC2:	IGNORE PORT ZERO MSGS
:	------
PR0AC2
	LB	R0,PR0LEN,R2		:GET MESSAGE LENGTH
	AR	R14,R0			:FLUSH MESSAGE
	JR	RLINK			:EXIT

:	PR0AC3:	SUP TAKE OVER, REPORT ALL HOST STATUS
:	------
PR0AC3
	LB	R0,PR0LEN,R2
	AR	R14,R0
	JAL	R6,HSTRPT,,		:SEND ALL HOSTS' STATUS
	JR	RLINK			:AND RETURN (NOT MODIFY TIMEOUT)

:	PR0AC4:	UNABLE TO PROVIDE NEEDLE
:	------
:	RECOVERY ACTIONS: IF WAITING FOR NEEDLE
:		NATIVE PVC PORT - WAIT THEN RETRY
:		NATIVE VC PORT - INFORM USER
:	ELSE, IGNORE
PR0AC4
	JAL	R4,GETCH,,		:PASS ISIS KEY
	JAL	R4,GETH,,		:GET LOCAL KEY
	LR	RDCB,R0			:SET RDCB = LOCAL KEY (DCB ADDR)
	JAL	R4,GETCH,,		:GET THE ERR CODE
:	DISPLAY ERROR AND RECOVERY
	JR	RLINK

:	RPTHST: REPORT HOST STATUS AND PORT AVAILBILITY
:	-------
:	REPORT HOST STATUS (NORMAL/ENTENDED FORMAT)
:	REPORT HOST PORT AVAILABLILITIES
:	SOFTWARE SHUT, IF NO PORTS AVAILABLE
:	INPUT:
:		R7 = HOST TABLE ADDR
:		R6 = LINK REGISTER
:	OUTPUT:
:	DESTROYED: R0,R1,R2,R3,R4

RPTHST

:	REPORT HOST STATUS
:	------------------
:	IF HSTIIX NOT 0, THEN REPORT WITH EXTENDED FORMAT
:	IF HOST UP PORTS = 0, THEN HOST DOWN
:	IF HOST UP PORTS > 0 AND FREE PORTS > 0, THEN HOST ANSWERED
:	IF HOST UP PORTS > 0 AND FREE PORTS = 0, REPORT HOST OUT OF PORTS.
:	REPORT HOST STATUS ONLY IF STATUS CHANGE.
::	IF HOST UP PORTS > 0 AND FREE PORTS = 0, THEN HOST SHUT

	LIS	R0,HSTDWN		:ASSUME HOST DOWN
	LHL	R4,HOSTAB+HSTPRT,R7,	:CHECK HOST UP PORTS
	JEFS	RPTHS1			:IF NO UP PORTS, THEN HOST DOWN
	LIS	R0,HSTANS		:ELSE ASSUME SET HOST ANSWERED
	LHL	R4,HOSTAB+HSTFPT,R7,	:CHECK HOST FREE PORTS
	JNFS	RPTHS1			:FREE PORTS > 0, HOST ANSWERED
:	LIS	R0,HSTSHT		:ELSE, FREE PORTS = 0, HOST SHUT (4/24/85/TTW)
	J	RPTHS5			:REPORT HOST OUT OF PORT (4/24/85/TTW)
RPTHS1
	CLB	R0,HOSTAB+HSTSTS,R7,	:HOST STATUS CHANGED?
	JER	R6			:NO, RETRUN
	STB	R0,HOSTAB+HSTSTS,R7,	:ELSE, UPDATE IT AND REPORT TO SUP
	LIS	R1,0			:MSG TO PORT 0
	LIS	R0,HSTALN		:ASSUME NO IIX (NORMAL FORMAT)
	LHI	R2,HSTSTA		:HOST STATUS ISIS MSG
	LB	R4,HOSTAB+HSTIIX,R7,	:GET HOST IIX IQ
	LR	R4,R4			:IIX IQ 0?
	JEFS	RPTHS2			:YES, SKIP
	LIS	R0,EHSTLN		:ELSE, LENGTH OF MESSAGE (EXTENDED)
	LHI	R2,EHSTST		:HOST STATUS MESSAGE(EXTENDED)
RPTHS2
	JAL	R4,SLOR,,		:START LOGICAL OUTPUT RECORD
	LIS	R0,0			:SEND NULL KEY
	JAL	R4,PUTCH,,		:
	LHL	R0,HOSTAB+HSTNUM,R7,	:GET HOST NUMBER
	JAL	R4,PUTH,,		:SEND IT
	LHL	R0,HOSTAB+HSTMPT,R7,	:GET MAXIMUM PORTS FOR HOST
	JAL	R4,PUTH,,		:SEND IT
	LB	R0,HOSTAB+HSTRID,R7,	:GET REL HOST #
	JAL	R4,PUTH,,		:SEND IT
	LB	R0,HOSTAB+HSTSTS,R7,	:GET HOST STATUS
	JAL	R4,PUTCH,,		:SEND IT
	LIS	R0,0			:SET MULTI BASE HOST KEY
	JAL	R4,PUTCH,,		: TO ZERO
	LB	R0,HOSTAB+HSTIIX,R7,	:GET HOST IIX IQ
	LR	R4,R4			:IIX IQ 0?
	JEFS	RPTHS3			:YES, SKIP
	JAL	R4,PUTCH,,		:EXTENDED FORMAT, SEND IT
	LHI	R0,PRODID		:SEND PRODUCT ID
	JAL	R4,PUTCH,,		:SEND IT
RPTHS3
	JAL	R4,ELOR,,		:END RECORD

:	REPORT HOST PORT AVAILABLITIES
:	------------------------------
RPTHS5
	LIS	R0,HPRALN		:LENGTH OF MESSAGE
	LIS	R1,0			:MSG TO PORT ZERO
	LIS	R2,HSTPOR		:HOST PORT AVAILABILITY
	JAL	R4,SLOR,,		:START LOGICAL OUTPUT RECORD
	LIS	R0,0			:SET NULL KEY
	JAL	R4,PUTCH,,		:SEND IT
	LHL	R0,HOSTAB+HSTNUM,R7,	:GET HOST NUMBER
	JAL	R4,PUTH,,		:SEND IT
	LIS	R0,0			:ASSUME SOFTWARE SHUT
	LHL	R4,HOSTAB+HSTFPT,R7,	:GET HOST FREE PORTS
	JLEFS	RPTHS4			:KIP, IF NO PORTS
	LIS	R0,1			:ELSE, SOFTWARE ANSWERED
RPTHS4
	JAL	R4,PUTH,,		:SEND IT
	LB	R0,HOSTAB+HSTRID,R7,	:GET REL HOST #
	JAL	R4,PUTH,,		:SEND IT
	JAL	R4,ELOR,,		:END LOGICAL RECORD
	JR	R6

:	HSTRPT:	REPORT ALL HOSTS' STATUS & PORT AVAILABILITY TO SUP
:	------
HSTRPT
	IF	MAXHST
	ST	R6,IR6SAV,,		:SAVE R6
	LIS	R8,0			:START FROM HOST 0
HSTPR1
	LHL	R7,HSTPTR,R8,R8		:R7 = HOST TABLE
	LCS	R0,1			:INIT HOST STATUS (4/24/85/TTW)
	STB	R0,HOSTAB+HSTSTS,R7,	:(4/24/85/TTW)
	JAL	R6,RPTHST		:REPORT THIS HOST
	AIS	R8,1			:NEXT HOST
	CLHI	R8,MAXHST		:ALL DONE?
	JLBS	HSTPR1			:NO, REPEAT
	L	R6,IR6SAV,,		:RESTORE R6
	EI	(MAXHST)
	JR	R6

	SUBTTL (SNA-NISC) ISIS NEEDLE HANDLING ROUTINE


:	ACTIVN:	NEEDLE HANDLING ROUTINE, CALLED FROM FRNTND
:	------
:	EXPECTS	R1 = PORT NUMBER
:		R2 = NUMBER OF CHARACTERS IN USERNAME
:		R6 = INVOICE #
:		R7 = DESTI. HOST #
:		R8 = SURCE NODE #
:		R9 = ORIGINAL HOST #
:		R10 = ORIGINAL PORT #
:		R11 = DIALECT CODE
:		R13 = TID
:		R14  = INPUT RING POINTER
ACTIVN;ACTINV
	IF	1-MAXHST
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

	ELSE				:(1-MAXHST)
	EXBR	R10,R11			:SAVE IIX TO R10

	LIS	R8,MAXHST-1		:SEARCH HOST TABLE
ACTVN0	LHL	R6,HSTPTR,R8,R8		:OFFSET TO HOSTAB
	CLH	R7,HOSTAB+HSTNUM,R6	:IF HOST # EQUAL
	JE	ACTVN1			:SKIP
	SIS	R8,1			:ELSE, NEXT HOST
	JGEBS	ACTVN0			:NOT OUT OF RANGE, LOOP

:	HOST NUMBER NOT FOUND
:	SHOULD NOT HAPPEN, CRASH NOW
	JAL	R10,CRASH,,
	BC	0,0,0,0AA		:*** TEMPORARY CRASH CODE

ACTVN1
	LB	R10,HOSTAB+HSTUSR,R6	:GET HOST USER TYPE
	LHL	R0,HOSTAB+HSTFPT,R6	:DOES HOST STILL HAVE PORT?
	JG	ACTVN2			:YES, SKIP
:	HOST OUT OF PORTS
	RBT	RPORT,ACP,,		:RESET THE PORT ACTIVE INDICATOR (11/06/86 YLH)
	AR	R14,R2			:FLUSH REMAINING DATA
	LA	R3,HOPMSG		:HOST OUT OF PORTS MSG
	LR	R6,R5			:SAVE RLINK
	LR	R7,R1			:SAVE PORT NUMBER (01/23/86 MIA)
	LR	R2,R1			:SET UP R2 = R1 = ISIS PORT
	JAL	R5,OCS,,		:SEND MSG
	LR	R2,R7			:SET PORT NUMBER (01/23/86 MIA)
	LA	R3,DETACH		:FOLLOW WITH DETACH 
	JAL	R5,OCM,,		:SEND IT
	LR	R5,R6			:RESTORE RLINK
	JR	RLINK			:AND RETURN (NOT MODIFY TIMEOUT)

:	HOST STILL HAS PORTS
ACTVN2
	LR	R7,R6			:MOVE HOST TABLE ADDR TO R7
:	ATTACH THIS PORT WITH A NEW DCB
	JAL	R6,GETDCB,,		:GET A DCB FOR PORT
	JNFS	ACTVN3			:SKIP IF SUCESSFUL
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,4*RLINK,CRDCB	:DCB PROBLEMS

ACTVN3
	SRHLS	R11,8			:SVAE IIX INDICATOR
	STB	R11,DCBLKS+DCBDIA,RDCB,	:SAVE IIX INDICATOR TO DCBDIA
	STH	R7,DCBLKS+DCBHST,RDCB,	:PUT HOSTAB ADDR INTO DCB
	LHL	R0,HOSTAB+HSTNUM,R7	:GET BACK HOST #
	STH	R0,DCBLKS+DCBAHS,RDCB,	:PUT HOST # INTO DCB
	STH	RPORT,DCBLKS+DCBIPR,RDCB,:PUT PORT NUMBER INTO DCB
	SBT	RPORT,TOISIS		:ALLOW OUTPUT TO ISIS(8/2/85/CHS)
	STB	R10,DCBLKS+DCBUTY,RDCB,	:PUT HOST TYPE INTO DCB
	STH	R9,DCBLKS+DCBRHT,RDCB,	:REMOTE HOST # (07/25/85 MIA)

:	READ THE USERNAME, AND SAVE IN DCB
	LIS	R3,0			:SET UP OFFSET FOR USERNAME CHARACTERS
ACTVN4
	JAL	R4,GETCH,,		:GET A CHARACTER
	OHI	R0,80			:TURN ON MSB
	STB	R0,DCBLKS+DCBUSR,RDCB,R3:STORE IT
	AIS	R3,1			:ADVANCE PTR
	SIS	R2,1			:DECREMENT COUNTER
	JGBS	ACTVN4			:REPEAT IF MORE
	LIS	R0,0			:CLEAR '8D' CHAR WITH NULL CHAR
	STB	R0,DCBLKS+DCBUSR,RDCB,R3:DO IT
:	UPDATE PORT TABLE
	STH	RDCB,PORTAB,R1,R1	:PUT DCB ADDR INTO PORT TABLE
:	HOST TABLE UPDATE
	LIS	R0,1			:INCREASE # OF ACTIVE PORTS BY 1
	AHM	R0,HOSTAB+HSTACT,R7	:UPDATE IT
	LCS	R0,1			:DECREASE THE # OF FREE PORTS BY 1
	AHM	R0,HOSTAB+HSTFPT,R7	:UPDATE IT
	JG	ACTVN5			:STILL HAS FREE PORTS, SKIP
	LCS	R0,1			:(9/9/85/CHS)
	STB	R0,HOSTAB+HSTSTS,R7,	:(9/9/85/CHS)
	JAL	R6,RPTHST		:REPORT HOST SHUT AND OUT OF PORT
	LHL	RPORT,DCBLKS+DCBIPR,RDCB,:RESTORE THE RPORT
ACTVN5
	LB	R11,DCBLKS+DCBUTY,RDCB,	:GET HOST TYPE
	LR	R11,R11			:CHECK THE TYPE ****
	IF	MONTOR
:	MONITOR HOST USER SETUP
	JE	SETUPM			:LOGON FROM TERMINAL INTERFACE
	ELSE				:MONTOR
	JN	ACTVN6			:IF NOT MONITOR, SKIP
	JAL	R10,CRASH,,		:
	BC	0,0,0,0AA		:SHOULD NOT HAPPEN
	EI	(MONTOR)

:	PROCESS LOGON INTO SNA HOST 
:	IF ORIGINATE FROM IIX SMART SLOT
:		THEN OFFER SNA, DSP AND ASCII DIALECT
:		ELSESET TO VITUAL SNA HOST MODE
:	R13 = TID
ACTVN6
	LB	R0,DCBLKS+DCBDIA,RDCB,	:GET IIX INDICATOR
	NHI	R0,80			:SMART OR DUMB?
	JE	ACTVN7			:DUMB, MUST BE VIRTUAL MODE
:	NATIVE MODE
	LHI	R0,GISDIN-PSEG		:GET INPUT PROCESSING ROUTINE
	STH	R0,DCBLKS+ACTIVD,RDCB,	:SET UP NEW DCB'S INPUT ROUTINE
	LHI	R0,NINASC-PSEG		:SET ASCII INPUT DATA PROC ROUTINE
	STH	R0,DCBLKS+DCBASC,RDCB,	:....
	LHI	R0,GXHLGN-PSEG		:SET UP LOGON GLOBAOL IIX PROC
	STH	R0,DCBLKS+DCBGIX,RDCB,
	LHI	R0,DXHLGN-PSEG		:SET UP LOGON LOCAL IIX PROC
	STH	R0,DCBLKS+DCBLIX,RDCB,
	LHI	R0,NHLTMO-PSEG		:HOST LOGON TIMEOUT
	STH	R0,DCBLKS+ACTIVT,RDCB,	:SET UP NEW TIMEOUT ROUTINE
	LHI	R0,SNHCTL-PSEG		:GET CONTROL PROCESSING ROUTINE
	STH	R0,DCBLKS+ACTIVC,RDCB,	:SET UP NEW DCB'S CONTROL ROUTINE
	LHI	R0,0FFFF		:INIT ENTRIES IN DCB
	STH	R0,DCBLKS+DCBLNC,RDCB,	:NON-ATTACHED LNCTAB
	STH	R0,DCBLKS+DCBPUC,RDCB,	:NON-ATTACHED PUCTAB
	STH	R0,DCBLKS+DCBLUC,RDCB,	:NON-ATTACHED LUCTAB
	STH	R0,DCBLKS+DCBALU,RDCB,	:NON-ATTACHED ASSOCIATED LUCTAB
:	SEND OUT SELECT DIALECT COMMAND
	LHI	R0,L.DRSP		:ENTER 'WAIT DIALECT RESPONSE'
	STB	R0,DCBLKS+DCBSTA,RDCB,	:...
	LIS	R0,D.ACTV		:MARK CIRCUIT UP
	SBT	R0,DCBLKS+DCBMOD,RDCB,
	LA	R9,DIALSL-1		:SEND SELECT DIALECT COMMAND
	JAL	R6,SNDIIX
	LA	R3,TIIXMG		:END WITH TIIX
	LHL	R2,DCBLKS+DCBIPR,RDCB,	:R2 = ISIS PORT
	LR	R6,R5
	JAL	R5,OCM,,		:...
	LR	R5,R6			:RESTORE R5
:
:BEGIN (02/24/86 YLH)
:	SEND REQUEST PRODUCT ID AND VERSION NUMBER TO THE TIF
:
	LA	R9,RQPVID-1		:LOAD CANNED MSG ADDR.
	JAL	R6,SNDIIX		:SEND THE REQUEST PRODUCT ID IIX MSG
:
:END (02/24/86)
:

	LHI	R0,LOGCTM		:SET TIMER TO WAIT FOR RESPONSE
	J	4,RLINK			:RETURN

ACTVN7					:VIRTUAL MODE
	IF	VM
	LII	R0,ASCDIA!0F		:SET DIALECT TO ASCII
	STB	R0,DCBLKS+DCBDIA,RDCB,	:..
	LIS	R0,L.PJCD		:ENTER 'WAIT FOR PROJECT CODE'
	STB	R0,DCBLKS+DCBSTA,RDCB,	:...
	LHI	R0,GISDIN-PSEG		:GET INPUT PROCESSING ROUTINE
	STH	R0,DCBLKS+ACTIVD,RDCB,	:SET UP NEW DCB'S INPUT ROUTINE
	LHI	R0,VINASC-PSEG		:SET ASCII DATA PROC ROUTINE
	STH	R0,DCBLKS+DCBASC,RDCB,	:....
	GL	VHLTMO
	LHI	R0,VHLTMO-PSEG		:VIRTUAL HOST LOGON TIME OUT
	STH	R0,DCBLKS+ACTIVT,RDCB,	:SET UP NEW TIMEOUT ROUTINE
	LHI	R0,ASCISC-PSEG		:ASC MODE CONTROL
	STH	R0,DCBLKS+ACTIVC,RDCB,	:SET UP NEW DCB'S CONTROL ROUTINE
	LHI	R0,0FFFF		:INIT ENTRIES
	STH	R0,DCBLKS+DCBLNC,RDCB,	:SET NON-ATTACHED LNCTAB
	STH	R0,DCBLKS+DCBPUC,RDCB,	:SET NON-ATTACHED PUCTAB
	STH	R0,DCBLKS+DCBLUC,RDCB,	:SET NON-ATTACHED LUCTAB
	STH	R0,DCBLKS+DCBALU,RDCB,	:SET NON-ATTACHED ASSOCIATED LUCTAB
	ELSE				:VM
	LA	R3,UCPMSG		:GET MESSAGE ADDRESS
	LHL	R2,DCBLKS+DCBIPR,RDCB,	:R2 = ISIS PORT #
	LR	R6,R5
	JAL	R5,OCS,,
	LR	R5,R6
	JAL	R6,DSCHPR		:DISCONNECT HOST PORT
	LHL	R7,DCBLKS+DCBHST,RDCB,	:R7 = HOSTAB
	JAL	R6,ZAPHST		:ZAP HSTACT, INC HSTFPT
	JAL	R6,RELDCB,,		:RELEASE DCB
	LIS	R0,0
	J	4,RLINK			:RETURN, NO TIMOUT
	EI	(VM)

	EI	(1-MAXHST)

	SUBTTL	(SNA-NISC) ISIS CONTROL - MISC ROUTINES


:	TRASHO:	NOT VALID FOR SNA
:	-------
TRASHO
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


:	EXNSM:	EXIT NSM MODE
:	-----
:	ISSUE FINISH LOGON TO LU.SVC, AND WAIT FOR THE RESPONSE
EXNSM
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUC OFFSET
	LHI	R2,NSFNLG		:FINISH LOGON
	EXBR	R2,R2
	LIS	R8,0
	LIS	R3,0			:R3 = 0 FOR CLARG FIELD
	JAL	R6,QDIFSN,,
	GL	FNLGFL
	SBT	R0,FNLGFL,,
	JR	R7

:	SPUPND:	RECEIVED A SPURIOUS PSEUDO NEEDLE
:	-------
:	RETURN A ZAPPER
SPUPND
	LHI	R2,ZAPMSG
	LIS	R0,3
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,
	JR	RLINK			:RETURN TO FRNTND

:	SNDM07:	SEND NORMAL NEEDLE REQUEST
:	------
:	R6 = LIK REG.
SNDM07
	LHI	R0,PSDHOS!4000		:SET TO PSEUDOHOST
	STH	R0,RQHST,,		:PUT HOST # TO REQUEST 
	LIS	R0,NREQLN		:MESSAGE SIZE
	JAL	R4,ROOM,,
	STH	RDCB,RQLCKY,,		:LOCAL KEY (PTR TO DCB ADDR)
	LIS	R2,NREQLN		:MESSAGE LENGTH
	LA	R3,RQNDLE,,		:REQUEST NEEDLE
	ST	R5,IR5SAV,,		:SAVE R5
	JAL	R5,OBS,,		:SEND OUT ISIS MSG
	L	R5,IR5SAV,,		:RESTORE R5
	JAL	R4,ELOR,,
	JR	R6

:	SNDMB7:	SEND ADDENDUM TO ACCOUNTING
:	------
:	R6 = LIK REG.
SNDMB7
	LHL	R1,DCBLKS+DCBIPR,RDCB,		:GET R1 = ISIS PORT #
	LHI	R2,ADACTG		:ADDENDUM TO ACCOUNTING
	LIS	R0,8			:MESSAGE SIZE
	JAL	R4,SLOR,,
	LIS	R0,0			:FIRST BYTE IGNORED
	JAL	R4,PUTCH,,
	LHL	R0,ACCDAT,,		:GET CODE AND SUBTYPE
	JAL	R4,PUTH,,
	LHL	R0,ACCDAT+2,,		:GET DATA
	JAL	R4,PUTH,,
	JAL	R4,ELOR,,
	JR	R6

:	SIIX0:	SIIX RECEIVED
:	------
:	CALLLED FROM FRNTND
SIIX0
	LIS	R0,D.ASCD		:SEE IF THERE ANY ASCII DATA
	TBT	R0,DCBLKS+DCBMOD,RDCB,	:(CAN NOT RESET)
	JEFS	SIIX01			:SKIP IF NONE
	JAL	R6,ISIEND		:END OF ANY ASCII INPUT
:	JFS	SIIX02			:SKIP (09/08/86 MIA)
	J	SIIX02			:SKIP
SIIX01					:SEE IF ANY OUTSTANDING IIX DATA
:FOR VHR IGNORE SIIX IF DCB IS IN L.ERCK STATE (09/08/86 MIA).
	IF	VHRSUP
	LB	R6,DCBLKS+DCBSTA,RDCB,	:GET VC STATUS
	CHI	R6,L.ERCK		:ERROR RECOVERY?
	JNFS	SIIX02			:JUMP IF NOT
	LHL	R6,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	JEFS	SIIX02			:JUMP IF NONE
	LB	R6,LUCTAB+LUCVHR,R6,	:GET VHR STATE BYTE
	THI	R6,LUVHRF		:VHR FUNCTION?
	JNFS	SIIX0E			:JUMP IF SO
	EI
:END OF INSERTION (09/08/86 MIA).

:	BBL	RBBA,DCBLKS+DCBIBH,RDCB,
:	JEFS	SIIX02			:O.K., SKIP
:	JAL	R10,CRASH,,		:PROGRAMMING ERROR
:	BC	0,0,0,0FF
SIIX02
	LHI	R0,GINIIX-PSEG		:SET TO IIX SUB PROC
	STH	R0,DCBLKS+DCBINP,RDCB,	:..
:	LHI	R0,LOGTM		:(09/08/86 MIA)
SIIX0E	LHI	R0,LOGTM		:SET TIMER (09/08/86 MIA)
	J	4,RLINK			:RETURN TO FRNTND WITH TIMER


	IF	TERMIF!VHRSUP

:	TIIXT0:	TIIX RECEIVED
:	-----
:	CALLED FROM FRNTND
TIIXT0
	LHL	R0,DCBLKS+DCBASC,RDCB,	:RESET INPUT SUB PROCE.
	STH	R0,DCBLKS+DCBINP,RDCB,
	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET DCB STATE
	CLHI	R0,L.DIAL		:WAITING FOR IIX DIALECT ?
	JN	TIIX2			:NO, SKIP
	AIS	R0,1			:ENTER NEXT STATE - TIIX RECEIVED
	STB	R0,DCBLKS+DCBSTA,RDCB,	:...
	LB	R3,DCBLKS+DCBDIA,RDCB,	:GET DIALECT SELECT LIST
	JFFOH	R3,TIIX1		:FIND LEFT-MOST BIT
	IF	TERMIF&VHRSUP
	LHL	R3,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R3,LUCTAB+LUCVHR,R3,	:GET VHR STATE BYTE
	THI	R3,LUVHRF		:VHR FUNCTION?
	JE	LOGFAI			:JUMP IF NOT
	EI
	IF	VHRSUP
	J	LORFAI			:JUMP IF VHR FUNCTION
	EI
	IF	TERMIF&(1-VHRSUP)
	J	LOGFAI			:IF NO DIALECT SELECT, ZAP & LOGON FAIL
	EI
TIIX1
	SHI	R4,8			:ADJUST
	RBT	R4,DCBLKS+DCBDIA,RDCB,	:DELETE DIALECT FROM LIST
	LHL	R6,DIATTB,R4,R4		:INDEX INTO DIALECT PROC TABLE
	J	PSEG,R6,		:...
TIIX2
	JR	RLINK			:RETURN TO FRNTND

:	DIATTB:	DIALECT PROC TABLE
:	-----
:	CORRESPONDS TO PRIORITIES OF DIALECTS
DIATTB
	HC	DITGAT-PSEG		:GATEWAY
	HC	DITDSP-PSEG		:SNA/DSP & BSC/DSP
	HC	DITASC-PSEG		:ASCII
	HC	DITX25-PSEG		:X25

:	DITGAT:	GATEWAY DIALECT
:	------
DITGAT
	LHI	R0,L.GTWY
	STB	R0,DCBLKS+DCBSTA,RDCB,	:WAIT FOR GATEWAY INTERLINK MSG
	LIS	R0,D.GATE		:GATEWAY LOGON MODE
	SBT	R0,DCBLKS+DCBMOD,RDCB,	:...
	LIS	R0,D.INLK		:SET TO WAIT FOR INTERLINK MSG
	SBT	R0,DCBLKS+DCBMOD,RDCB,
	JR	RLINK			:RETURN TO FRNTND

:	DITDSP: DSP DIALECT (SNA OR BSC 3270)
:	------
:	REMARK **** SET UP SNA/DSP MODE
DITDSP
	IF	TERMIF
	LHI	R0,SNTDSP-PSEG		:SET UP SNA/DSP PROC.
	STH	R0,DCBLKS+DCBDSP,RDCB,
	LIS	R0,D.STOR		:IF SOATORED LOGON, SKIP
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JN	DITSN1			:SKIP
	EI
	LHI	R0,L.LDSP		:SET TO WAIT FOR DSP STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET

	IF	VHRSUP
	LB	R6,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	IF	TERMIF
	THI	R6,LUVHRF		:VHR FUNCTION?
	JE	DITDS0			:MUST BE TIF IF NOT
	EI
	GL	SNRDSP
	LHI	R3,SNRDSP-PSEG		:GET VHR DSP PROCESSING TABLE
	STH	R3,DCBLKS+DCBDSP,RDCB,	:PUT IT IN DCB
	THI	R6,LUMNLG		:VTR MANUAL LOGON?
	JE	DITDS2			:JUMP IF NOT

:RELEASE BUFFERS WITH VTR LOGON INFORMATION.
	BBL	R3,DCBLKS+DCBLBA,RDCB,	:GET POINTER TO LOGON BUFFERS
	JEFS	DITDS1			:JUMP IF NONE
	JAL	R6,DLODBB		:RELASE LOGON BUFFERS
	XR	R3,R3			:CLEAR THE REGISTER
	BBST	R3,DCBLKS+DCBLBA,RDCB,	:UPDATE LOGON POINTER

:FILL IN CADR1 AND CADR2 AND SEND LOGON REPLY RU TO VTR. THIS CODE ASSUMES
:THAT REPLY RU IS 1 SEGMENT 1 ELEMENT CHAIN. IF NOT THIS CODE SHOULD BE
:CHANGED LATER.
DITDS1	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET  POINTER TO PREPARED REPLY
	LIS	R6,VHRCNT!VHRDSP	:PREPARE CONTINUE DSP TO VTR
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA1,R3,	:FILL CADR1
	LIS	R6,VHRCDR		:PREPARE CADR2(CD)
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:FILL CADR2
	XR	R6,R6			:CLEAR THE REGISTER
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCDE,R3,	:CLEAR ERROR CODE
	BBST	R6,DCBLKS+DCBIBH,RDCB,	:UPDATE REPLY POINTER
	LHL	R8,DCBLKS+DCBALU,RDCB,	:GET MESSAGE LENGTH
	LHI	R2,NSETEM^8!NSDTCD	:ASSUME SINGLE SEG, SINGLE RU CHAIN
	JAL	R6,QDIFSN,,		:SEND IT TO SNA
	JR	RLINK			:AND RETURN

:FOR VTR-PRESTORE LOGON FETCH DSP INFORMATION AND CONTINUE LOGON PROCESS.
DITDS2	JAL	R6,FETDSP		:FETCH DSP INFORMATION
	J	DITDSE			:JUMP IF ERROR
	JAL	R8,VHRTUR		:SEND DAIL RESP AND TURK
	JR	RLINK			:AND RETURN

:ERROR IN STORED DSP INFORMATION. SAME AS ERROR IN DSP COMING FROM SCREEN.
DITDSE	ST	RLINK,DSPSAV,,		:SAVE LINK REGISTER
	GL	RLNSCE
	JAL	R5,RLNSCE		:PERFORM ERROR RECOVERY
	L	RLINK,DSPSAV,,		:RESORE RLINK
	LHI	R0,LOGTM		:SET ISIS TIMER
	J	4,RLINK			:AND RETURN
	EI
	IF	TERMIF
DITDS0	JAL	R6,PTLBH,,
	LA	R1,DSPSCN		:SEND DSP SCREEN TO DEVICE
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTCD!NSDTFS :1ST SEGMENT
	BBL	R3,LUCTAB+LUCIBH,R11,	:R3 = BB HEAD
	JAL	R6,QDIFSN,,
	JAL	R6,PTLBN
	LA	R1,DSPEXT		:SEND 2ND PORTION OF DSP SCREEN
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTLS	:LAST SEGMENT
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	RLINK			:RETURN TO FRNTND

DITSN1					:STORED LOGON
	LIS	R0,D.PVC
	TBT	R0,DCBLKS+DCBMOD,RDCB,	:PVC MODE?
	JN	DITSNX			:YES, SKIP
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	LHL	R3,LUCTAB+LUCT.N,R11,
	LHI	R4,8
	MHR	R3,R4
	LHL	R4,PSTTBL+4,R3,		:R4 = PSDTBL OFFSET
	LB	R2,DCBLKS+DCBCRM,RDCB,	:GET PRESET SELECTION
	LHI	R3,PSTLEN
	MHR	R2,R3
	AR	R4,R2
	AIS	R4,PSTDLN		:R4 = PSTDLN OFSET
	BBST	R4,DCBLKS+DCBLBA,RDCB,	:SAVE INTO DCB
	JAL	R6,GETDSP		:TO GET STORED DSP DATA
	J	DITSN2			:ERROR
	LHI	R0,DSPDIA		:RESPONSE DSP/SNA SELECTED
	STB	R0,RPDIAL,,		:
	LA	R9,RPDIAM-1,,
	JAL	R6,SNDIIX
	LA	R9,TURKMG-1,,
	JAL	R6,SNDIIX
	LHI	R0,L.TRKL
	STB	R0,DCBLKS+DCBSTA,RDCB,
	JAL	R6,PTLBH,,
	LA	R1,LEM14,,		:CONNECTION IN PROGRESS
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTCD
	JAL	R6,QDIFSN,,
	JR	RLINK			:RETURN TO FRNTND
DITSN2;DITSNX
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
	EI

:	DITASC:	ASCII DIALECT, ENTER ASCII MODE
:	------
DITASC
	J	LGMB61			:NON-SNA HOST, FAIL
:	LIS	R0,ASCDIA&0F
:	STB	R0,RPDIAL,,		:SELECT ASC
:	LA	R9,RPDIAM-1,,		:SELECTED DIALECT REPONSE
:	JAL	R6,SNDIIX
:	JAL	R6,ENTASC
:	JR	RLINK			:RETURN TO FRNTND

:	DITX25:	X.25 DIALECT , CLEAR THE CALL
:	------
DITX25
	J	LGMB61			:LOGON FAILURE

	EI	(TERMIF!VHRSUP)

	IF	HOSTIF

:	TIIXH0:	TIIX RECEIVED
:	-----
:	CALLED FROM FRNTND
TIIXH0
	LHL	R4,DCBLKS+DCBASC,RDCB,	:RESET INPUT SUB PROCE.
	STH	R4,DCBLKS+DCBINP,RDCB,
	JR	RLINK			:RETURN TO FRNTND

	EI	(HOSTIF)

	IF	TERMIF

:	RSTTRM: RESET SNA/SDLC TERMINAL PORT/DCB
:	-------
:	INPUT: RDCB = DCB ADDR, R6 = LINK REG
:	OUTPUT:	RELEASE ALL INPUT AND OUTPUT DATA, AND
:		RESET DCB ENTRIE, ZAP ISIS PORT
:		PRESERVES ALL REGISTERS.
RSTTRM
	ST	R6,IR6SAV,,		:SAVE R6
	JAL	R6,ROUTQ,,		:RELEASE ALL ISIS OUTPUT Q
	JAL	R6,RINPBB		:RELEASE ALL ISIS INPUT BUFFER
	LIS	R0,L.IDLE		:SET TO IDLE STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	STB	R0,DCBLKS+DCBNTY,RDCB,	:CLEAN NTWRK MONTR CALL (02/09/87 MIA)
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:GET ISIS PORT
	JE	RSTTR1			:IF NO PORT, SKIP
	LIS	R0,0
	STH	R0,DCBLKS+DCBIPR,RDCB,	:ZERO-OUT PORT
	LIS	R2,DCB1ST-DCBLKS	:RESET PORTAB
	STH	R2,PORTAB,R1,R1		:DO IT
	RBT	R1,ACP,,		:RESET ACTIVE PORT ARRAY
	LIS	R0,3			:ZAP ISIS PORT
	LHI	R2,ZAPMSG		:...
	JAL	R4,SLOR,,		:...
	JAL	R4,ELOR,,		:...
RSTTR1
	L	R6,IR6SAV,,
	JR	R6			:RETURN

	EI	(TERMIF)

	IF	HOSTIF

:	DSCHST:	DISCONNECT HOST PORT
:	-------
:	INPUT:	RDCB SET UP
:	CALL:
:		JAL	R6,DSCHPR	:DISCONNECT HOST PORT FIRST
:		JAL	R6,ZAPHST	:RELEASE HSTACT AND INCREASE HSTFPT
:		JAL	R6,RELDCB	:FINALLY RELEASE DCB

:	DEFINE DETACH ISIS MSG
:	----------------------
DETACH	SC	/"9E/			:ISIS DETACH MSG


:	DSCHPR:	DISCONNECT HOST PORT
:	------
:	INPUT:	RDCB = DCB ADDR
:	OUTPUT:	RESET PORT TAB, CLEAR UP DCB ISIS INPUT & OUTPUT 
:		DETACH THE ISIS PORT.
:	DETROY R5
DSCHPR
	ST	R6,IR6SAV,,		:SAVE R6
	ST	R11,IRBSAV,,		:SAVE R11 (F00/03/23/87/DB)
	JAL	R6,RINPBB		: REEASE ANY PARTIAL INPUT
	JAL	R6,ROUTQ,,		:RELEASE ALL ISIS OUTPUT Q
	LHL	R2,DCBLKS+DCBIPR,RDCB,	:GET ISIS PORT #
	JEFS	DSCHP1			:JUMP IF NO PORT YET (08/14/86 MIA)
	LIS	R0,DCB1ST-DCBLKS	:RESET PORT TABLE
	STH	R0,PORTAB,R2,R2
	RBT	R2,ACP			:FRNTND SET IT WHEN NEEDLE ARRIVED
	LA	R3,DETACH		:GET DETACH MESSAGE
	LR	R6,R5
	JAL	R5,OCM,,		:OUTPUT THE MESSAGE
	LR	R5,R6
DSCHP1	L	R6,IR6SAV,,		:(08/14/86 MIA)
	RBT	R2,ACP			:SET PORT INACTIVE
:(F00/02/12/87/DB/START/CRM 4)
: IF THERE IS AN ATTACHED LU, IT SHOULD ALSO BE DISCONNECTED.
	LIS	R0,0	
	LH	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCTAB ENTRY
	JLEFS	DSCHP6			:NO LUC ENTRY
	STB	R0,LUCTAB+LUNSTA,R11,	:LOGON STATE = IDLE
	STH	R0,LUCTAB+LUCDCB,R11,	:CLEAR DCB POINTER
DSCHP6

	ST	RDCB,DCBSAV,,		:YES, SAVE ORIGINAL DCB PTR
	LHL	R2,DCBLKS+DCBCRD,RDCB,	:IS THERE AN ATTACHED LU?
	JE	DSCHP5			:NO, ALL DONE

	LHL	RDCB,LUCTAB+LUCDCB,R2,	:GET DCB OF ATTACHED LU
	JE	DSCHP5			:EXIT IF THERE ISN'T ONE

	JAL	R6,RINPBB		: REEASE ANY PARTIAL INPUT
	JAL	R6,ROUTQ,,		:RELEASE ALL ISIS OUTPUT Q
	LHL	R2,DCBLKS+DCBIPR,RDCB,	:GET ISIS PORT #
	JEFS	DSCHP2			:JUMP IF NO PORT YET (08/14/86 MIA)
	LIS	R0,DCB1ST-DCBLKS	:RESET PORT TABLE
	STH	R0,PORTAB,R2,R2
	RBT	R2,ACP			:FRNTND SET IT WHEN NEEDLE ARRIVED
	LA	R3,DETACH		:GET DETACH MESSAGE
	LR	R6,R5
	JAL	R5,OCM,,		:OUTPUT THE MESSAGE
	LR	R5,R6
DSCHP2
	RBT	R2,ACP			:SET PORT INACTIVE
	IF	VHRSUP
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCB
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	NHI	R7,LUVHRF		:VHR FUNCTION?
	JEFS	DSCHP3			:YES
	STB	R7,LUCTAB+LUCVHR,R11,	:NO, UPDATE VHR STATE BYTE
	JFS	DSCHP4			
	EI	
DSCHP3
	LHL	R7,DCBLKS+DCBHST,RDCB,	:GET HOSTAB OFFSET
	JAL	R6,ZAPHST		:RELEASE HOST PORT
DSCHP4
	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET E -T -E INDICATOR
	CLHI	R0,L.BDSP		:IS IT BSC/DSP MODE?
	JEFS	DSCHP7			:YES
	CLHI	R0,L.NATV		:NO
	JNFS	DSCHP8		
DSCHP7
	GL	ZAPHLU
	JAL	R6,ZAPHLU,,		:DISCONNECT LU
DSCHP8
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCTAB ENTRY
	LIS	R0,0		
	STB	R0,LUCTAB+LUNSTA,R11,	:LOGON STATE = IDLE
	STH	R0,LUCTAB+LUCDCB,R11,	:RELEASE LUC FROM DCB
	JAL	R6,RELDCB,,		:RELEASE DCB

DSCHP5
	L	RDCB,DCBSAV,,		:RESTORE ORIGINAL DCB POINTER
	L	R6,IR6SAV,,
	L	R11,IRBSAV,,	
					:(F00/02/12/87/DB/END)
	JR	R6			:AND RETURN

:	ZAPHST:	RELEASE HOST ACTIVE PORT - DECREASE HSTACT AD INC. HSTFPT
:	-------
:	INPUT:	R7 = HOSTAB, R6 = LINK REG
:	DESTROY: A LOT OF REGS
ZAPHST
	LCS	R1,1			:DECREASE THE # OF ACTIVE PORTS
	AHM	R1,HOSTAB+HSTACT,R7	:UPDATE IT
	LHL	R4,HOSTAB+HSTFPT,R7	:FREE PORTS
	LIS	R1,1
	AHM	R1,HOSTAB+HSTFPT,R7	:AND INCREASE FREE PORTS
	J	RLSHS2

:	RLSHST:	RELEASE HOST PORT - DECREASE HSTUPT AND HSTFPT
:	-------
:	INPUT:	R7 = HOSTAB, R6 = LINK REG
:	DESTROY: A LOT OF REGS
RLSHST
	LCS	R1,1			:DECREASE THE # OF UP PORTS
	AHM	R1,HOSTAB+HSTPRT,R7	:UPDATE IT
	LHL	R4,HOSTAB+HSTFPT,R7	:FREE PORTS
	AHM	R1,HOSTAB+HSTFPT,R7	:AND DECREASE FREE PORTS
	J	RLSHS2
:	LR	R4,R4			:CHECK OLD COUNT
:	JE	RLSHS2			:SKIP IF IT WAS ZERO
:	UPDATE HOST COST
:	----------------
	LHL	R9,HOSTAB+HSTACT,R7	:GET ACTIVE PORT COUNT
	LR	R8,R9			:COPY ACTIVE COUNT
	SLHLS	R9,5			:SCALE HOST COST
	AR	R8,R4			:ADD IN FREE COUNT
	DHR	R9,R8			:CALCULATE HOST COST
	LHI	R8,4,R10		:TEST IF CHANGE IN HOST COST > 4
	SH	R8,HOSTAB+HCOST,R7	:SUBTRACT PREVIOUS HOST COST
	JGR	R6			:CHANGE NOT SIGNIICANT, RETURN
	STH	R10,HOSTAB+HCOST,R7	:SAVE NEW COST
	LIS	R0,HCSTLN		:LENGTH OF MSG
	LIS	R1,0			:MSG TO PORT ZERO
	LIS	R2,HSTCST		:REPORT HOST COST
	JAL	R4,SLOR,,		:START LOGICAL OUTPUT RECORD
	LIS	R0,0			:SET NULL KEY
	JAL	R4,PUTCH,,		:SEND IT
	LHL	R0,HOSTAB+HSTNUM,R7	:GET HOST NUMBER
	JAL	R4,PUTH,,		:SEND IT
	LR	R0,R10			:REPORT HOST COST
	JAL	R4,PUTH,,		:SEND IT
	LB	R0,HOSTAB+HSTRID,R7	:GET REL HOST ID
	JAL	R4,PUTH,,		:SEND IT
	JAL	R4,ELOR,,		:END LOGICAL RECORD
	JR	R6			:RETURN
RLSHS2
	LR	R4,R4			:CHECK OLD COUNT(5/16/85/CHS)
	JN	RPTHST			:REPORT HOST NEW STATUS IF ANY(5/17/85/CHS)
	LCS	R0,1			:ENSURE THE STATUS BE REPORTED(5/16/85/CHS)
	STB	R0,HOSTAB+HSTSTS,R7,	:... (5/16/85/CHS)
	J	RPTHST			:REPORT HOST NEW STATUS
					:AND NEW PORT AVAILABILITY
					:(RETURN TO CALLER THRU R6 OF RPTHST)

	EI	(HOSTIF)

:	CLRCIR:	CLEAR CIRCUIT
:	------
:	TERMINAL AND HOST DIFFERENT
:	NEED TO ZAP CIRCUIT AND ERROR RECOVERY FOR SNA
CLRCIR
	JAL	R10,CRASH,,:TO BE IMPLEMENTED
	BC	0,0,0,0FF


	SUBTTL (SNA-NISC) INACTIVE CIRCUITS ACTIVATION ROUTINES


:
:	FOR INACTIVE CIRCUITS
:	ACTIVD - XTOSS, TOSS ANY INPUT DATA
:	ACTIVO - TRASHO, OUTPUT REQUEST INVALID
:	ACTIVT - INATMO, TIMEOUT INVALID
:	ACTIVC - INACTI, ISIS CONTROL MSG HANDLING TABLE
:


:	INACTI: ISIS CONTROL MESSAGE TABLE FOR INACTIVE CIRCUIT
:	--------

	HTABIA(INACTI)

	CHGTAB(INACTI,DETMSG,INADSC)
	CHGTAB(INACTI,ZAPMSG,INADSC)
	IF	TERMIF!VHRSUP			:(12/10/86 YLH)
	CHGTAB(INACTI,PNDMSG,LOGMB2)
	EI	(TERMIF!VHRSUP)			:(12/10/86 YLH)


	IF	(1-TERMIF)&(1-HDPSUP)
:	LOGMB2:	PSEUDO NEEDLE RECEIVED
:	------
LOGMB2
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
	EI	((1-TERMIF)&(1-HDPSUP))

:	INADSC:	DETACH OR ZAP MESSAGE RECEIVED
:	--------
:	INPUT:	RPORT SET UP
:		R5 = LINK REGISTER
:	OUTPUT:
:	CALLED FROM FRNTND
INADSC
	RBT	RPORT,DEM,,		:RESET DEM
	RBT	RPORT,PECHO,,		:RESET PECHO
	RBT	RPORT,PTIME,,		:CLEAR ANY TIMER
	J	TOSS,,			:TO TOSS THE DETACH OR ZAP MSG


:	INATMO: TIMEOUT ROUTINE FOR INACTIVE CIRCUITS
:	-------
:	SHOULD NOT HAPPEN, CRASH
INATMO
	JAL	R10,CRASH,,
	BC	0,0,0,066		:***TEMPORARY CRASH CODE

	SUBTTL	(SNA-NISC) ISISC - NATIVE SNA MODE ACTIVATION ROUTINES
:
:	FOR NATIVE SNA CIRCUITS
:	ACTIVD - ISIPUT
:	ACTIVO - TRASH, NOT USED
:	ACTIVT - SNATMO
:	ACTIVC - SNTCTL/SNHCTL, ISIS CONTROL MSG HANDLING TABLE
:

:	FOR SNA/SDLC ACTIVE CIRCUIT
:	--------------------------

	IF	TERMIF
	HTABVT(SNTCTL)

	CHGTAB(SNTCTL,DETMSG,SNTZAP)
	CHGTAB(SNTCTL,ZAPMSG,SNTZAP)
	CHGTAB(SNTCTL,SHGMSG,SNTZAP)
	CHGTAB(SNTCTL,HNGMSG,SNTZAP)
	CHGTAB(SNTCTL,BLKMSG,SNTZAP)
	CHGTAB(SNTCTL,GRYMSG,SNTZAP)
	CHGTAB(SNTCTL,PNDMSG,SPUPND)
	CHGTAB(SNTCTL,SIIX,SIIX0)
	CHGTAB(SNTCTL,TIIX,TIIXT0)
	EI	(TERMIF)

	IF	HOSTIF

	HTABVT(SNHCTL)

	CHGTAB(SNHCTL,DETMSG,SNHZAP)
	CHGTAB(SNHCTL,ZAPMSG,SNHZAP)
	CHGTAB(SNHCTL,SHGMSG,SNHZAP)
	CHGTAB(SNHCTL,HNGMSG,SNHZAP)
	CHGTAB(SNHCTL,BLKMSG,SNHZAP)
	CHGTAB(SNHCTL,GRYMSG,SNHZAP)
	CHGTAB(SNHCTL,PNDMSG,SPUPND)
	CHGTAB(SNHCTL,SIIX,SIIX0)
	CHGTAB(SNHCTL,TIIX,TIIXH0)
	EI	(HOSTIF)

:	FOR VHR FUNCTION
:	----------------

	IF	VHRSUP

	HTABVT(SNRCTL)

	CHGTAB(SNRCTL,DETMSG,SNRZAP)
	CHGTAB(SNRCTL,ZAPMSG,SNRZAP)
	CHGTAB(SNRCTL,SHGMSG,SNRZAP)
	CHGTAB(SNRCTL,HNGMSG,SNRZAP)
	CHGTAB(SNRCTL,BLKMSG,SNRZAP)
	CHGTAB(SNRCTL,GRYMSG,SNRZAP)
	CHGTAB(SNRCTL,PNDMSG,SPUPND)
	CHGTAB(SNRCTL,SIIX,SIIX0)
	CHGTAB(SNRCTL,TIIX,TIIXT0)
	EI	(VHRSUP)

	IF	TERMIF

:	SNTZAP: DETMSG, ZAPMSG, SHGMSG, HNGMSG BLKMSG, GRYMSG RCV'ED
:	-------
:	RESET THE PORT, AND RECOVER
SNTZAP
	ST	R5,IR5SAV,,
	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE ISIS CONTROL CODE
	LB	R0,DCBLKS+DCBSTA,RDCB,
	CLHI	R0,L.NATV
	IF	VTISUP
	JEFS	SNTZA0			:JUMP IF NATIVE
	CLHI	R0,L.BDSP		:DSP MODE?
	EI
	JN	SNTZA1			:IF IN LOCAL MODE, ???
	GL	ZAPTLU
SNTZA0	JAL	R6,ZAPTLU,,		:TO ZAP LU
	JAL	R6,RSTTRM		:RESET TERMINAL
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	L	R5,IR5SAV,,
	LIS	R0,0			:SET TO NO TIMEOUT
	J	4,RLINK			:RETURN, NO TIMOUT
SNTZA1					:LOCAL MODE
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	JAL	R6,PTLBH,,
	LA	R1,LEM1A,,		:DISPLAY 'CIRCUIT CLEARED' MSG ON CRT
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JAL	R6,RSTTRM		:AND ZAP DEVICE
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	LHI	R6,L.ERCK		:AND WAIT FOR ANY KEY
	STB	R6,DCBLKS+DCBSTA,RDCB,
	L	R5,IR5SAV,,
	LIS	R0,0			:RESET PORT TIMOUT INDICATOR
	J	4,RLINK			:RETURN TO FRNTND

	EI	(TERMIF)

	IF	HOSTIF

:	SNHZAP: DETMSG, ZAPMSG, SHGMSG, HNGMSG BLKMSG, GRYMSG RCV'ED
:	-------
:	RESET THE PORT, AND RECOVER
SNHZAP
	ST	R5,IR5SAV,,
	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE ISIS CONTROL CODE
	LB	R0,DCBLKS+DCBSTA,RDCB,	:IF NOT E-T-T, NOT TELL SNA
	CLHI	R0,L.BDSP		:IS IT BSC/DSP MODE?
	JEFS	SNHZA0			:JUMP,IF YES
	CLHI	R0,L.NATV
	JNFS	SNHZA1			:SKIP
SNHZA0
	GL	ZAPHLU
	JAL	R6,ZAPHLU,,		:ELSE, TELL SNA TO RECOVERY
SNHZA1
	LH	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	JLEFS	SNHZA2			:IF NO LUC, SKIP
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:ELSE DISCONNECT LUC/DCB
	LIS	R0,0
	STH	R0,LUCTAB+LUCDCB,R11,
SNHZA2
	L	R5,IR5SAV,,
	JAL	R6,DSCHPR		:DISCONNECT HOST PORT
	LHL	R7,DCBLKS+DCBHST,RDCB,	:R7 = HOSTAB OFFSET
	JAL	R6,ZAPHST		:RELEASE HOST PORT
	JAL	R6,RELDCB,,		:RELEASE DCB
	LIS	R0,0			:SET TO NO TIMEOUT
	J	4,RLINK			:RETURN, NO TIMOUT

	EI	(HOSTIF)

	IF	VHRSUP

:	SNHZAP: DETMSG, ZAPMSG, SHGMSG, HNGMSG BLKMSG, GRYMSG RCV'ED
:	-------
:	RESET THE PORT, AND RECOVER
SNRZAP
	ST	R5,IR5SAV,,
	GL	ZAPHLU
	JAL	R6,ZAPHLU,,		:ELSE, TELL SNA TO RECOVERY
	LH	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	JLEFS	SNRZA2			:IF NO LUC, SKIP
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:ELSE DISCONNECT LUC/DCB
	LHI	R0,LUVHRF		:PREPARE TO CLEAN VHR STATE BYTE
	STB	R0,LUCTAB+LUCVHR,R11,	:UPDATE LUCB
	LIS	R0,0
	STH	R0,LUCTAB+LUCDCB,R11,
SNRZA2
	L	R5,IR5SAV,,
	JAL	R6,DSCHPR		:DISCONNECT HOST PORT
	JAL	R6,RELDCB,,		:RELEASE DCB
	LIS	R0,0			:SET TO NO TIMEOUT
	J	4,RLINK			:RETURN, NO TIMOUT

	EI	(VHRSUP)

:	SNATMO:	TIMEOUT ROUTINE WHEN ACTIVE
:	-------
:	AFTER NEGOTIATION COMPLETE, GOT TIME OUT
:	(FOR BOTH HOST AND TERMINAL PORTS)
:	NO ACTION (NOW)
SNATMO
	LIS	R0,0
	J	4,RLINK			:RETURN, NO TIMOUT

	SUBTTL	(SNA-NISC) LOGON MODE ISIS CONTROL PROCESSOR


	IF	HOSTIF

:	NHLTMO:	TIMEOUT ROUTINE DURING CALL NEGOTIATION
:	-------
:	BEFORE DEVICE ATTACHED, GOT TIME OUT
:	SET ASCII MESSAGE - LOGON FAIL OR UNCOMPATABLE HOST. PLEASE TRY
:	 AGAIN OR CALL .... -
NHLTMO
	ST	R5,IR5SAV,,
	LH	R11,DCBLKS+DCBLUC,RDCB,
	JLEFS	NHLTM1			:NO DEVICE YET, SKIP
	LIS	R0,0
	STH	R0,LUCTAB+LUCDCB,R11,
NHLTM1
	LA	R3,UCPMSG		:GET MESSAGE ADDRESS
	LHL	R2,DCBLKS+DCBIPR,RDCB,	:R2 = ISIS PORT #
	JAL	R5,OCS,,
	JAL	R6,DSCHPR		:DISCONNECT HOST PORT
	LHL	R7,DCBLKS+DCBHST,RDCB,	:R7 = HOSTAB
	JAL	R6,ZAPHST		:ZAP HSTACT, INC HSTFPT
	JAL	R6,RELDCB,,		:RELEASE DCB
	L	R5,IR5SAV,,
	LIS	R0,0
	J	4,RLINK			:RETURN, NO TIMOUT

	EI				:HOSTIF

	IF	TERMIF

:	LOGON MODE - ISIS CONTROL MESSAGE ACTIVATION TABLE
:	----------
:	AFTER ISIS LOGON SUCCESS MAY SWITCH TO SNTCTL
:	AFTER PSEUDO NEEDLE ARRIVED UNTIL ISIS LOGON SUCCESS

	HTABIA(LOGCTL)

	CHGTAB(LOGCTL,DETMSG,LOGM9E)
	CHGTAB(LOGCTL,ZAPMSG,LOGM9F)
	CHGTAB(LOGCTL,PNDMSG,SPUPND)
	CHGTAB(LOGCTL,NLOGST,LOGMB4)
	CHGTAB(LOGCTL,LOGFAL,LOGMB5)
	CHGTAB(LOGCTL,LOGOK,LOGMB6)
	CHGTAB(LOGCTL,SHGMSG,LOGMB8)
	CHGTAB(LOGCTL,HNGMSG,LOGMAF)

	EI	(TERMIF)

	IF	VHRSUP

	HTABIA(LORCTL)

	CHGTAB(LORCTL,DETMSG,LORM9E)
	CHGTAB(LORCTL,ZAPMSG,LORM9F)
	CHGTAB(LORCTL,PNDMSG,SPUPND)
	CHGTAB(LORCTL,NLOGST,LORMB4)
	CHGTAB(LORCTL,LOGFAL,LORMB5)
	CHGTAB(LORCTL,LOGOK,LORMB6)
	CHGTAB(LORCTL,SHGMSG,LORMB8)
	CHGTAB(LORCTL,HNGMSG,LORMAF)

	EI	(VHRSUP)

	IF	TERMIF!VHRSUP

:	LOGMB2:	PSEUDO NEEDLE RECEIVED
:	------
LOGMB2
	JAL	R4,GETCH,,		:PASS ISIS KEY
	JAL	R4,GETH,,		:GET LOCAL KEY (DCB ADDR)
	LR	RDCB,R0			:SET UP RDCB
	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET CURRENT LOGON/CIRCUIT STATE
	CLHI	R0,L.PDNL		:'WAITING FOR PSEUDO NEEDLE' ?
	JN	SPUPND			:NO, GOT A SPURIOUS PSEUDO NEEDLE
	LIS	R0,L.USER		:ENTER 'WAIT FOR USER NAME'
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LIS	R0,D.ACTV		:MARK CIRCUIT UP
	SBT	R0,DCBLKS+DCBMOD,RDCB,
	STH	RDCB,PORTAB,RPORT,RPORT :LINK ISIS PORT AND DCB
	STH	RPORT,DCBLKS+DCBIPR,RDCB, :...
	SBT	RPORT,TOISIS,,		:ALLOW OUTPUT TO ISIS (8/2/85/CHS)
	LHI	R0,FIRST-1		:SET UP XMT LIMIT TO ISIS
	STB	R0,XLIMIT,RPORT,	:...
	IF	TERMIF&VHRSUP
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R0,LUCTAB+LUCVHR,R9,	:GET VHR STATE
	THI	R0,LUVHRF		:VHR FUNCTION?
	JEFS	LOGB2A			:JUMP IF NOT
	EI
	IF	VHRSUP
	LHI	R0,LORCTL-PSEG		:SET UP LOGON REFLECT MODE
	STH	R0,DCBLKS+ACTIVC,RDCB,	:SAVE IN DCB
	LHI	R0,LORTMO-PSEG		:SET UP LOGON REFLECT TIMEOUT ROUTINE
	JFS	LOGB2B			:JUMP TO CONTINUE
	EI
	IF	TERMIF
LOGB2A	LHI	R0,LOGCTL-PSEG		:SET UP LOGON MODE CONTROL
	STH	R0,DCBLKS+ACTIVC,RDCB,	:...
	LHI	R0,LOGTMO-PSEG		:SET UP LOGON TIMEOUT
	EI	(TERMIF)
LOGB2B	STH	R0,DCBLKS+ACTIVT,RDCB,	:...
	LHI	R0,GISDIN-PSEG		:SET UP DATA INPUT PROC.
	STH	R0,DCBLKS+ACTIVD,RDCB,	:...
	LHI	R0,LINASC-PSEG		:SET UP ASCII PROC
	STH	R0,DCBLKS+DCBASC,RDCB,	:SET UP INPUT SUB PROC.
	STH	R0,DCBLKS+DCBINP,RDCB,	:...
	JAL	R6,SNDLFD		:SEND USER NAME
	JR	RLINK			:RETURN TO FRNTND

	EI	(TERMIF!VHRSUP)

	IF	TERMIF

:	LOGMB4:	LOGON STATUS
:	-------
LOGMB4
	JAL	R4,GETCH,,		:GET LOGON STATUS BYTE
	NHI	R0,1F			:MASK OFF UNWANTED BITS
	JEFS	LOGB4A			:IF CONTINUE, SKIP
	CLHI	R0,5			:CONTINUE FOR PASSWORD?
	JN	LOGB4B			:NO, MUST BE ERROR
LOGB4A	JAL	R6,SNDLFD		:SEND PASSWORD
	LHI	R0,LOGTM		:SET UP TIMER
	J	4,RLINK			:RETURN TO FRNTND WITH TIMER
LOGB4B					:LOGON STATUS NOT CONTINUE
	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE ERROR CODE
	JAL	R6,LGNERR		:PROCESS LOGON ERROR
	LIS	R0,0			:CLEAR ISIS TIMER
	J	4,RLINK			:RETURN TO FRNTND
	
:
:	LOGON FAILURE
:
:	DETACH, ZAP, HANG UP, LOGON FAILURE, SUP HANG UP, AND TIMEOUT
:
:	ALL THE ABOVE CASES CAUSE LOGON FAILURE
:

:	LOGTMOLOGM9E/LOGM9F/LOGMAF/LOGMB8: LOGON FAILURE
:	----------------------------
LOGTMO;LOGM9E;LOGM9F;LOGMAF;LOGMB8
	LIS	R0,0			:ERROR CODE
	J	LOGFAI

:	LOGMB5: B5 MESSAGE (LOGON FAILURE)
:	------
LOGMB5
	JAL	R4,GETCH,,		:GET ERROR CODE
LOGFAI
	JAL	R6,RLOGBB,,		:DELETE LOGON BB
	JAL	R6,ISIEND		:END THE MESSAGE FROM NETWORK
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	JAL	R6,PTLBH,,
	LA	R1,LEM4,,		:DISPLAY 'LOGON FAILURE' MSG ON CRT
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JAL	R6,RSTTRM		:AND ZAP DEVICE
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	LHI	R6,L.ERCK		:AND WAIT FOR ANY KEY
	STB	R6,DCBLKS+DCBSTA,RDCB,
	LIS	R0,0			:RESET PORT TIMOUT INDICATOR
	J	4,RLINK			:RETURN TO FRNTND

	EI	(TERMIF)

	IF	TERMIF!VHRSUP

:	LOGMB6:	B6 MESSAGE  (LOGON SUCCESSFUL)
:	------
:	IF IIX CAPABLE, THEN ENTER 'WAIT IIX DIALECT' MODE
:	ELSE ENTER ASC (VTM) MODE
LORMB6
LOGMB6
	JAL	R4,GETCH,,		:GET IIX BYTE
	AIS	R14,7			:DISCARD REMAINING ISIS RECORD
	NHI	R0,7F			:NONE ZERO?
	JN	MSGB6A			:YES, IIX CAPABLE, SKIP
LGMB61
	IF	TERMIF&VHRSUP
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R6,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	THI	R6,LUVHRF		:VHR FUNCTION?
	JEFS	LGMB62			:JUMP IF NOT
	EI
	IF	VHRSUP
	LHI	R0,VHREHN		:PRETEND BAD HOST NUMBER
	J	LORFAI			:JUMP TO CONTINUE
	EI
	IF	TERMIF
LGMB62
	JAL	R6,RLOGBB,,		:DELETE LOGON BB
	JAL	R6,ISIEND		:END THE MESSAGE FROM NETWORK
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	JAL	R6,PTLBH,,
	LA	R1,LEM18,,		:DISPLAY 'NON SNA HOST' MSG ON CRT
	JAL	R6,PMLB
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JAL	R6,RSTTRM		:AND ZAP DEVICE
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	LHI	R6,L.ERCK		:AND WAIT FOR ANY KEY
	STB	R6,DCBLKS+DCBSTA,RDCB,
	LIS	R0,0			:RESET PORT TIMOUT INDICATOR
	J	4,RLINK			:RETURN TO FRNTND
:	LIS	R0,ASCDIA&0F		:SET TO ASC/VTM DIALECT
:	STB	R0,DCBLKS+DCBDIA,RDCB,	:...
:	LHI	R0,L.ASCI		:ASCII MODE
:	STB	R0,DCBLKS+DCBSTA,RDCB,	:...
:	JAL	R6,RLOGBB		:DELETE LOGON BB
:	JAL	R6,ENTASC		:ENTER ASC(VTM) MODE
:	JAL	R7,EXNSM		:EXIT NSM MODE
:	LIS	R0,0			:NO TIMEOUT
:	J	4,R5			:RETURN FRNTND
	EI	(TERMIF)
MSGB6A
	LHI	R0,L.DIAL		:ENTER 'WAIT FOR IIX DIALECT'
	STB	R0,DCBLKS+DCBSTA,RDCB,	:...
	LHI	R6,GXTLGN-PSEG		:LOGON MODE GLOBAL IIX
	STH	R6,DCBLKS+DCBGIX,RDCB,	:...
	LHI	R6,DXTLGN-PSEG		:LOGON MODE DIALECT IIX
	STH	R6,DCBLKS+DCBLIX,RDCB,	:...
	IF	VHRSUP&TERMIF
	LHL	R6,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R6,LUCTAB+LUCVHR,R6,	:GET VHR STATE BYTE
	THI	R6,LUVHRF			:VHR FUNCTION?
	JEFS	MSGB6B			:JUMP IF NOT
	EI
	IF	VHRSUP
	LHI	R6,SNRCTL-PSEG		:SET ISIS CONTROL PROCESSING TABLE
	STH	R6,DCBLKS+ACTIVC,RDCB,	:SET ACTIVC IN DCB
	LHI	R4,LOGTM		:SET UP LOGON TIMER
	J	4,R5			:AND RETURN WITH TIME
	EI
	IF	TERMIF
MSGB6B	LHI	R6,SNTCTL-PSEG
	STH	R6,DCBLKS+ACTIVC,RDCB,	:CONTROL
	JAL	R6,RLOGBB,,		:DELETE LOGON BB
	LHI	R0,LOGTM		:SET UP LOGON CIRCUIT TIMER
	J	4,R5			:RETURN WITH TIMEOUT TIMER
	EI

:	ENTASC:	TERMINAL ENTER ASC MODE
:	------
:	SET UP DCB INPUT AND LUCTAB OUTPUT DATA, CTL PROCESS TABLES
:	SEND PROJECT CODE TO HOST
:	SET UP THE 1ST ASC SCREEN TO CRT
ENTASC
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
:	GL	VISINP
:	LHI	R4,VISINP-PSEG		:SET UP ASC MODE INPUT PROC
:	STH	R4,DCBLKS+DCBINP,RDCB,	:SET UP INPUT SUBPROCESS
:	GL	ASCISC
:	LHI	R4,ASCISC-PSEG		:GET CONTROL ROUTINE
:	STH	R4,DCBLKS+ACTIVC,RDCB,	:SET UP ASC ISIS CONTROL TABLE
:SET UP OSCAN VOSC MODE

	EI	(TERMIF!VHRSUP)

	IF	VHRSUP

:	LORMB4:	LOGON STATUS
:	-------
LORMB4
	JAL	R4,GETCH,,		:GET LOGON STATUS BYTE
	NHI	R0,1F			:MASK OFF UNWANTED BITS
	JEFS	LORB4A			:IF CONTINUE, SKIP
	CLHI	R0,5			:CONTINUE FOR PASSWORD?
	JN	LORB4B			:NO, MUST BE ERROR
LORB4A	JAL	R6,SNDLFD		:SEND PASSWORD
	LHI	R0,LOGTM		:SET UP TIMER
	J	4,RLINK			:RETURN TO FRNTND WITH TIMER
LORB4B					:LOGON STATUS NOT CONTINUE
	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE ERROR CODE
	JAL	R6,LGNERR		:PROCESS LOGON ERROR
	LIS	R0,0			:CLEAR ISIS TIMER
:	LB	R6,DCBLKS+DCBSTA,RDCB,	:GET LOGON STATE (04/30/86 YLH)
:	CHI	R6,L.ERCK		:ERROR? (04/30/86 YLH)
:	JN	4,RLINK			:RETUNR WITHOUT TIMER IF NOT (04/30/86 YLH)
:	LHI	R0,LOGTM		:SET ISIS TIMER (04/30/86 YLH)
	J	4,RLINK			:RETURN TO FRNTND
	
:
:	LOGON FAILURE
:
:	DETACH, ZAP, HANG UP, LOGON FAILURE, SUP HANG UP
:
:	ALL THE ABOVE CASES CAUSE LOGON FAILURE
:

LORM9E
LORM9F
LORMB8
LORMAF	EQ	.
	LIS	R0,0			:CLEAR REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,
	JAL	R6,RLOGBB,,		:DELETE LOGON BUFFERLETS
	JAL	R6,ISIEND		:CLEAN UP ANY INPUT
	GL	ZPHCKT,ZAPHLU
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	JAL	R6,ZPHCKT,,		:VHR LOOKS TO NETWORK AS TERMIF
	JAL	R6,ZAPHLU,,		:VHR LOOKS TO SNA AS HOSTIF
	JR	R5			:AND RETURN

:	LOGON TIMEOUT.
:	IF ERROR STATE ZAP CIRCUIT AND INFORM SNA TO CLEAR THE SESSION.
:	OTHERWISE TRY TO INFORM VTR.
LORTMO	LB	R0,DCBLKS+DCBSTA,RDCB,	:GET LOGON STATE
	CHI	R0,L.ERCK		:ERROR?
	JE	LORM9E			:ZAP IF SO
	LIS	R0,6			:TIMEOUT
	JFS	LORFAI			:JUMP TO CONTINUE

:	LORMB5: B5 MESSAGE (LOGON FAILURE)
:	------
LORMB5
	JAL	R4,GETCH,,		:GET ERROR CODE
LORFAI	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE ERROR CODE

:RELEASE BUFFERS WITH VTR LOGON INFORMATION.
	BBL	R3,DCBLKS+DCBLBA,RDCB,	:GET POINTER TO LOGON BUFFERS
	JEFS	LORFA1			:JUMP IF NONE
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	JEFS	LORFA1			:JUMP IF NO LUCB
	JAL	R6,DLODBB		:RELASE LOGON BUFFERS
	XR	R3,R3			:CLEAR THE REGISTER
	BBST	R3,DCBLKS+DCBLBA,RDCB,	:UPDATE LOGON POINTER

:FILL IN CADR1 AND CADR2 AND SEND LOGON REPLY RU TO VTR. THIS CODE ASSUMES
:THAT REPLY RU IS 1 SEGMENT 1 ELEMENT CHAIN. IF NOT THIS CODE SHOULD BE
:CHANGED LATER.
LORFA1	LB	R7,DCBLKS+DCBTMP,RDCB,	:GET CODE OF LOGON ERROR
	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET  POINTER TO PREPARED REPLY
	LHI	R0,L.ERCK		:ERROR LOGON STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,	:UPDATE LOGON STATUS
	LHI	R6,SP.			:PREPARE LOGON COMPLETED
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA1,R3,	:FILL CADR1
	LIS	R6,VHRCDR		:PREPARE CADR2(CD)
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:FILL CADR2
	LB	R6,LORFAT,R7		:GET VHR ERROR CODE
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCDE,R3,	:PUT IT IN VHR HEADER
	XR	R6,R6			:CLEAR THE REGISTER
	BBST	R6,DCBLKS+DCBIBH,RDCB,	:UPDATE REPLY POINTER
	LHL	R8,DCBLKS+DCBALU,RDCB,	:GET MESSAGE LENGTH
	LHI	R2,NSETEM^8!NSDTCD	:ASSUME SINGLE SEG, SINGLE RU CHAIN
	JAL	R6,QDIFSN,,		:SEND IT TO SNA
	LHI	R0,FSHINP-PSEG		:PREPARE TO FLUSH INPUT
	STH	R0,DCBLKS+DCBINP,RDCB,	:UPDATE DCB
	LHI	R0,LOGTM		:PREPARE TIMEOUT
	JR	R5			:AND RETURN

:VTR ERROR CODE CONVERSION TABLE.
LORFAT	BC	VHREZP,VHREZP,VHREZP,VHREZP,VHREHN,VHREZP,
	BC	VHRETO,VHRENA,VHREZP,VHREBY,VHREZP,VHREZP
	BND	2

	EI	(VHRSUP)

	FO	FRNTND
	FO	CBKDEF

	EM




 	SUBTTL	(SNA-NOSC) SNA->NWKC OUTPUT-Q PROCESSORS
:NOSC00.Z00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- ORIGINAL CODE AND DESIGN FOR SNA NATIVE MODE
:	07/11/84 (NCS) -- UPDATE FOR SNA VH DSP 
:	07/17/84 (NCS) -- GENERALIZE TIMEOUT FUNCTIONS
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	RA	0

	MO	.,OSCAN

	GL	OSCAN,IFLRST,ILINIT,PL.RST

	LO	CMDLST
	LO	GBLDEF
	LO	BSUB
	LO	MAIN
	LO	FRNTND
	LO	ISISC
	LO	GIIX
	LO	GDSP
	LO	CBKDEF

:
:	THIS FILE CONTAINS:
:		A. OSCAN - OUTPUT QUEUE SCANNNER & DISPATCHER
:		B. DETACH MODE OUTPUT CMD/DATA-Q PROCESSES
:		C. NATIVE SNA TRANSPARENT MODE OUTPUT CMD/DATA-Q PROCESSES
:		D. NATIVE SNA LOGON MODE OUTPUT CMD/DATA-Q PROCESSES
:

:	DEFINE PU/LU STATE
:	------------------
PL.RST	EQ	0			:DEACTIVE STATE
PL.PAC	EQ	1			:PENDING ACTIVATE STATE
PL.ACT	EQ	2			:ACTIVE STATE
PL.DAC	EQ	3			:PENDING DEACTIVE STATE
PL.PRC	EQ	4			:PENDING SNA RECOVERY STATE
PL.PDN	EQ	5			:PENDING LINK DOWN RECOVERY STATE
PL.PLR	EQ	6			:PENDING LINK RESET STATE

:	EQU FOR IFC<->SNA COMMANDS/RESPONSE
:	-----------------------------------
XDOWN	EQ	XLNKDW			:LINK DOWN
XRESET	EQ	XCKTDW			:CIRCUIT DOWN

	SUBTTL	(SNA-NOSC) SNA->NWKC OUTPUT QUEUE SCANNER


:
:	DEFINE SNA->NWKC QUEUE PROCESSING TABLES
:

:	GENSNC(TABNAM)
:	------
:	TO GENERATE PROCESSING TABLE FOR SNA->NWKC CMD-Q TABLE
:		TABNAM - TABNAME
GENSNC	MACRO(TABNAM)[
	HS	0
	GL	TABNAM
TABNAM	HC	GOCCRH-PSEG		:0 - ILLEGAL
	HC	GOCFLH-PSEG		:1 - XINIT (ACTIVATE)
	HC	GOCFLH-PSEG		:2 - XCLOSE (DEACTIVATE)
	HC	GOCFLH-PSEG		:3 - XDOWN
	HC	GOCFLH-PSEG		:4 - XRESET
		]

:	CHGSNC(TABNAM,SNNWCM,BRLABL)
:	------
:	TO CHANGE THE SNA->NWKC CMD-Q PROCESSING TABLE
:		TABNAM - TABNAME
:		SNNWCM - SNA->NWKC CMD
:		BRLABL - BRANCH PROCESSING ROUTINE
CHGSNC	MACRO(TABNAM,SNNWCM,BRLABL)[
OLDORG	EQ	.
	ORG	SNNWCM*2+TABNAM
	HC	BRLABL-PSEG
	ORG	OLDORG
		]

:	GENSND(TABNAM)
:	------
:	TO GENERATE PROCESSING TABLE FOR SNA->NWKC DATA-Q TABLE
:		TABNAM - TABNAME
GENSND	MACRO(TABNAM)[
	HS	0
	GL	TABNAM
TABNAM	HC	GODCRH-PSEG		:0 - ILLEGAL
	HC	GODFLH-PSEG		:1 - SNETEM (END TO END MESSAGE)
	HC	GODFLH-PSEG		:2 - SNINTM (LOCALLY GENERATED MESSAGE)
	HC	GODFLH-PSEG		:3 - FD, SNRQLG(REQUEST TO START LOGON)
	HC	GODFLH-PSEG		:4 - FE, SNERR (ERROR)
	HC	GODFLH-PSEG		:5 - FF, SNPOSR(POS. RSP TO NSSTLG)
		]

:	CHGSND(TABNAM,SNNWDA,BRLABL)
:	------
:	TO CHANGE THE SNA->NWKC DATA-Q PROCESSING TABLE
:		TABNAM - TABNAME
:		SNNWDA - SNA->NWKC DATA
:		BRLABL - BRANCH PROCESSING ROUTINE
CHGSND	MACRO(TABNAM,SNNWDA,BRLABL)[
OLDORG	EQ	.
	IF	SNNWDA&80
	ORG	(SNNWDA-SNCMMX+SNDTMX+1)*2+TABNAM
	ELSE				:SNNWDA&80
	ORG	SNNWDA*2+TABNAM
	EI	(SNNWDA&80)
	HC	BRLABL-PSEG
	ORG	OLDORG
		]

	SEG	A.DATA
OSCSAV	WS	1			:LINK SAV AREA
OSCGPR	WS	1			:WORKING AREA
OR9SAV	WS	1			:R9 SAVE AREA
ORASAV	WS	1			:R10 SAVE AREA
STLGFL	HS	(MAXLUN+$A15)/$A16	:START NSM RQ SENT
FNLGFL	HS	(MAXLUN+$A15)/$A16	:FINISH NSM RQ SENT
SNDFLG	HS	(MAXLUN+$A15)/$A16	:SEND FINISH NSM 
BDPDLU	HS	(MAXLUN+$A15)/$A16	:SET FOR BSC DSP LOGOFF
BDPETE	HS	(MAXLUN+$A15)/$A16	:SET FOR BSC DSP ETE MODE

	SEG	A.CODE

:	OSCAN: SCAN SNA->NWKC OUTPUT QUEUE
:	------
OSCAN
	ST	R0,OSCSAV,,		:SAVE R0
:	SCAN SNA->NWKC OUTPUT CMD-Q FIRST
	LHI	R9,NGSLU*10
	LHI	R10,NGSLU*2
OSCAN1
	SHI	R9,10			:TO NEXT GROUP
	SIS	R10,2			:ALL DONE FOR ALL LUS' ?
	JL	OSCAN4			:YES, EXIT TO PROCESS SNA->NWKC DATA-Q
	LCS	R0,1			:INIT OSCGPR
	STH	R0,OSCGPR,,		:...
OSCAN2
	LH	R1,CPSNNW,R10,		:LUS' WITH SNA->NWKC CMD
	NH	R1,OSCGPR,,		:EXCLUDE LUS' ALREADY DONE
	JFFOH	R1,OSCAN3		:FIND THE 1ST 'AVAIL' LU IN THIS GROUP
	J	OSCAN1			:IF NONE TO PROCESS IN THIS GROUP, SKIP
OSCAN3
	RBT	R2,OSCGPR,,		:DON'T DO THIS LU AGAIN
	AR	R2,R9			:FORM THE LU #
	LHL	R11,LUBPTR,R2,R2	:R11 = LUCTAB ADDR
	JAL	R6,PKOCMD,,		:PEEK AT CMD(09/09/86/CHS) RX3
	J	OSCAN2			:NO CMD, SKIP TO NEXT ONE
	LHL	R4,LUCTAB+LUOCPR,R11,	:GET SNA->NWKC CMD-Q PROCESS TABLE
	SLHLS	R2,1			:MAKE HW INDEX
	LHL	R4,PSEG,R4,R2
	JAL	R5,PSEG,R4,		:TO PROCESS
	J	OSCAN2			:CONTINUE

OSCAN4
:	SCAN SNA->NWKC OUTPUT DATA-Q NEXT
	LHI	R9,NGSLU*10
	LHI	R10,NGSLU*2
OSCAN5
	SHI	R9,10			:TO NEXT GROUP
	SIS	R10,2			:ALL DONE FOR ALL LUS' ?
	JL	OSCAN8			:YES, EXIT
	ST	R9,OR9SAV,,
	ST	R10,ORASAV,,
	LCS	R0,1			:INIT OSCGPR
	STH	R0,OSCGPR,,		:...
OSCAN6
	L	R9,OR9SAV,,
	L	R10,ORASAV,,
	LH	R1,DPSNNW,R10,		:LUS' WITH SNA->NWKC DATA
	NH	R1,OSCGPR,,		:EXCLUDE LUS' ALREADY DONE
	JFFOH	R1,OSCAN7		:FIND THE 1ST 'AVAIL' LU IN THIS GROUP
	J	OSCAN5			:IF NONE TO PROCESS IN THIS GROUP, SKIP
OSCAN7
	RBT	R2,OSCGPR,,		:DON'T DO THIS LU AGAIN
	AR	R2,R9			:FORM THE LU #
	LHL	R11,LUBPTR,R2,R2	:R11 = LUCTAB ADDR
	JAL	R6,PKODTA,,		:PEEK AT THE DATA(09/09/86/CHS) RX3
	J	OSCAN6			:NO DATA, SKIP TO NEXT ONE
	LHL	R4,LUCTAB+LUODPR,R11,	:GET SNA->NWKC DATA-Q PROCESS TABLE
	AR	R2,R2			:MAKE HW INDEX
	LHL	R4,PSEG,R4,R2
	JAL	R5,PSEG,R4,		:TO PROCESS
	J	OSCAN6			:CONTINUE

OSCAN8
	L	R0,OSCSAV,,		:RESTORE R0
	JR	R0

	SUBTTL	(SNA-NOSC) OSCAN - GENERAL PROCESSING ROUTINES


:	GOCCRH:	ILEGAL CMD IN CMD-Q
:	------
GOCCRH
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	GODFLH:	DELETE OUTPUT CMD-Q
:	------
GOCFLH
	JAL	R7,DLOCMD,,		:(09/09/86/CHS) RX3
	JR	R5

:	GODRSH:	ILEGAL CMD IN DATA-Q
:	------
GODCRH
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	GOCFLH:	DELETE OUTPUT DATA-Q
:	------
GODFLH
:	JAL	R7,DLODTA		:(5/13/85/CHS)
	JAL	R7,FLODTA,,		:(5/13/85/CHS)(09/09/86/CHS) RX3
	JR	R5

	IF	TERMIF

:	ENTNSM:	ENTER NETWORK SERVICE MODE
:	------
:	SEND NETOWRK SERVICE SCREEN, AND ENTER NATIV SNA LOGON MODE
:	INPUT:	R11 = LUC OFFSET
:		R7 = LINK REG.
ENTNSM
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	LHI	R0,NSDTCD		:CHANGE DIRECTION
	STH	R0,CDIND,,
	JAL	R6,SNDNSS,,		:SEND NETWORK SERVICE SCREEN
	LHI	R0,NLOSCC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LHI	R0,NLOSCD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LIS	R0,L.NSMN		:NS SCREEN SENT
	STB	R0,DCBLKS+DCBSTA,R12,
	JR	R7

	IF	\FIRN
	IF	FIRN
:	ENTLGS:	ENTER NETWORK SERVICE MODE AND DISPLAY LOGON SLELECTION
:	------
:	SEND LOGON SELELCTION SCREEN, AND ENTER NATIV SNA LOGON MODE
:	INPUT:	R11 = LUC OFFSET
:		R7 = LINK REG.
ENTLGS
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	JAL	R6,SNDLGS,,		:SEND LOGON SELECTION  SCREEN
	LHI	R0,NLOSCC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LHI	R0,NLOSCD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LIS	R0,L.MENU		:LS SCREEN SENT
	STB	R0,DCBLKS+DCBSTA,R12,
	JR	R7
	EI	(FIRN)
	EI	(\FIRN)

	EI	TERMIF

	SUBTTL	(SNA-NOSC) FLUSH MODE - OUTPUT SCAN PROCESSING 


:
:	GENERATE 'FLUSH MODE' OUTPUT CMD-Q SCAN PROCESSING TABLE
:
:	TERMINAL -	FLUSH ALL CMD-Q
:
:	HOST     -	FLUSH ALL CMD-Q
:

	GENSNC(FLHOSC)			:FLUSH MODE CMD-Q

:
:	GENERATE 'FLUSH MODE' OUTPUT DATA-Q SCAN PROCESSING TABLE
:
:	TERMINAL -	FLUSH ALL ELEMENT IN DATA-Q
:
:	HOST     -	FLUSH ALL ELEMENT IN DATA-Q

	GENSND(FLHOSD)			:FLUSH MODE DATA-Q

	SUBTTL	(SNA-NOSC) DETACH MODE - OUTPUT SCAN PROCESSING 


:
:	GENERATE 'DETACH MODE' OUTPUT CMD-Q SCAN PROCESSING TABLE
:
:	TERMINAL -	IF RSP(XINIT) & PU, ISSUE RQ(XINIT) TO ALL LUS'
:			IF RSP(XINIT) & LU, ENTER NETWORK SERVICE MODE
:			IF RSP(XCLOSE) & PU, ISSUE RQ(XINIT)
:			IF RSP(XCLOSE) & LU, ISSUE RQ(XINIT)
:			IF RSP(XDOWN) & PU, CHANGE LINE STATE
:			IF RSP(XDOWN) & LU, ISSUE RQ(XINIT)
:			IF RSP(XRESET) & PU, ISSUE RQ(XINIT)
:			IF RSP(XRESET) & LU, ISSUE RQ(XINIT)
:
:	HOST     -	IF RQ(XINIT), UPDATE STATUS
:			IF RQ(XCLOSE), UPDATE STATUS
:			IF RQ(XDOWN), UPDATE STATUS
:			IF RSP(XRESET), UPDATE STATUS
:

	IF	TERMIF

	GENSNC(DTTOSC)			:DETACH MODE CMD-Q

	CHGSNC(DTTOSC,XINIT,DTOTIN)
	CHGSNC(DTTOSC,XCLOSE,DTOTCL)
	CHGSNC(DTTOSC,XDOWN,DTOTDN)
	CHGSNC(DTTOSC,XRESET,DTOTRS)
	EI	(TERMIF)

	IF	HOSTIF

	GENSNC(DTHOSC)			:DETACH MODE CMD-Q

	CHGSNC(DTHOSC,XINIT,DTOHIN)
	CHGSNC(DTHOSC,XCLOSE,DTOHCL)
	CHGSNC(DTHOSC,XDOWN,DTOHDN)
	CHGSNC(DTHOSC,XRESET,DTOHRS)
	EI	(HOSTIF)

:
:	GENERATE 'DETACH MODE' OUTPUT DATA-Q SCAN PROCESSING TABLE
:
:	TERMINAL -	FLUSH ALL ELEMENT IN DATA-Q, EXCEPT SNRQLG
:
:	HOST     -	NO ACTION

	IF	TERMIF

	GENSND(DTTOSD)			:DETACH MODE DATA-Q

	CHGSND(DTTOSD,SNETEM,GODFLH)
	CHGSND(DTTOSD,SNINTM,GODFLH)
	CHGSND(DTTOSD,SNRQLG,DTOTRQ)
	CHGSND(DTTOSD,SNERR,DTOTER)
	CHGSND(DTTOSD,SNPOSR,DTOTPR)
	EI	(TERMIF)

	IF	HOSTIF

	GENSND(DTHOSD)			:DETACH MODE DATA-Q

	CHGSND(DTHOSD,SNETEM,DTONUL)
	CHGSND(DTHOSD,SNINTM,DTONUL)
	CHGSND(DTHOSD,SNRQLG,DTHRLG)
	CHGSND(DTHOSD,SNERR,DTOHER)
	CHGSND(DTHOSD,SNPOSR,DTOHPR)
	EI	(HOSTIF)




	IF	TERMIF

:	DTOTIN:	RCV'ED ACTPU/ACTLU
:	------
:	PROCESS ACCORDINGLY
DTOTIN
	JAL	R6,GTOCMD,,		:FETCH CMD(09/09/86/CHS) RX3
	LB	R7,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	LHL	R4,DTOTIP,R7,R7		:GET ACTION ROUTINE
	J	PSEG,R4,		:TO PROCESS

DTOTIP	HC	DTI000-PSEG		:0 - DEACTIVE STATE
	HC	DTI100-PSEG		:1 - PENDING ACTIVATE STATE
	HC	DTI200-PSEG		:2 - ACTIVE STATE
	HC	DTI300-PSEG		:3 - PENDING DEACTIVATE STATE
	HC	DTI400-PSEG		:4 - PENDING SNA RECOVERY STATE
	HC	DTI500-PSEG		:5 - PENDING LINK DOWN RECOVERY STATE
	HC	DTI600-PSEG		:6 - PENDING LINK RESET STATE

:	DTI000:	RCV'ED XINIT AND AT IDLE STATE
:	------
DTI000;DTI200;DTI300;DTI400;DTI500;DTI600
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	DTI100:	RCV'ED XINIT AND AT PENDING ACTIVATE STATE
:	------
DTI100
	LR	R1,R0			:R1 = SCC CODE
	LHL	R3,DTI1PR,R1,R1		:GET SUB ACTION ROUTINE
	J	PSEG,R3,		:TO PROCESS

DTI1PR	HC	DTI101-PSEG		:0 - POSITIVE RESPONSE
	HC	DTI110-PSEG		:1 - NEGATIVE RESPONE
	HC	DTI120-PSEG		:2 - RESET
	HC	DTI130-PSEG		:3 - STATE ERROR

:	DTI101:	ACTIVE LU/PU WITH POSI AT PENDING ACTIVATE STATE
:	------
DTI101
	LIS	R0,PL.ACT		:SET UP ACTIVATE STATE
	STB	R0,LUCTAB+LUPSTA,R11,	:..
	LB	R0,LUCTAB+LUCTYP,R11,	:IS THIS LU'S/PU'S LUCTAB?
	NHI	R0,80			:IF BIT 0 = 1, IT IS A PU
	JNFS	DTI102			:SKIP, TO SEND RQ(INIT) FOR ALL LUS
	LHI	R2,NSSTLG^8+NSSTNW	:ISSUE START LOGON TO LU.SVC
	LIS	R3,0
	LIS	R8,0
	JAL	R6,QDIFSN,,		:ISSUE IT
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,STLGFL,,		:INDICATE STLG OUTSTANDING
	JR	R5
DTI102					:ISSUE RQ(XINIT) TO ALL LUS
	LHL	R12,LUCTAB+LUCPUC,R11,	:R12 = PUCTAB
	LIS	R1,1			:INIT LU CNT
DTI103
	LHL	R2,LUCTAB+LUCT.N,R11,	:GET LU # TO ALL
	AIS	R2,1			:NEXT LU
	LHL	R11,LUBPTR,R2,R2	:R11 = NEW LU'S LUCTAB
	LHI	R2,DTTOSD-PSEG
	STH	R2,LUCTAB+LUODPR,R11,
	LHI	R2,DTTOSC-PSEG
	STH	R2,LUCTAB+LUOCPR,R11,
	LIS	R0,PL.PAC		:PENDING FOR ACTIVATE
	STB	R0,LUCTAB+LUPSTA,R11,
	LIS	R2,XINIT		:CCC = XINIT, SCC= 0
	EXBR	R2,R2
	JAL	R6,QOPCMD,,		:RQ(XINIT)(09/09/86/CHS) RX3
	AIS	R1,1			:CNT ONE MORE
	CLB	R1,PUCTAB+PUMLUN,R12,	:ALL DONE?
	JN	DTI103			:NO, REPEAT
	JR	R5

:	DTI110: ACTPU/ACTLU WITH NEG STATUS AT PENDING ACTIVE
:	------
DTI110
	LIS	R0,PL.RST		:SET TO RESET STATE
	STB	R0,LUCTAB+LUPSTA,R11,	:...
:	DISMISS AND WAIT, THEN REISSUE RQ(XINIT)
	GL	TLACTV
	LA	R0,TLACTV,,		:ROUTINE TO ISSUE ACTIVATE
	STH	R0,LUCTAB+LUCATO,R11,
	LHI	R0,$A600		:WAIT 5 MIN
	STH	R0,LUCTAB+LUCTIM,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,LUTFLG,,		:START TIMER
	JR	R5

:	DTI120/DTI130:	ACTPU/ACTLU WITH RESET/ERROR AT PENDING ACTIVATE STATE
:	-----
DTI120;DTI130
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:
:BEGIN (01/14/87 YLH)
:	DETACH MODE RSP(XCLOSE) -
:
:	NOTIFY(POWER OFF) IS INFORMED TO THE NIO THROUGH SNA->NIO CMD_Q
:	CLOSE COMMAND WITH POWER OFF SUBCOMMAND.
:
DTOTCL	JAL	R6,GTOCMD,,			:FETCH COMMAND
	CLHI	R0,E.POFF			:SUBCOMMAND=POWER OFF?
	JN	DTOTC1				:NO, CONTINUE AS NORMAL CLOSE
	LHL	RDCB,LUCTAB+LUCDCB,R11,		:YES, SET UP RDCB
:
:	RELEASE ISIS RING BUFFER
:
	JAL	R6,ROUTQ,,			:RELEASE ISIS OUTPUT QUEUES
	JAL	R6,RINPBB,,			:RELEASE ISIS INPUT BUFFER
:
:	RESET LU/DEVICE
:
	LIS	R0,L.IDLE			:SET DEVICE IDLE STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LIS	R0,PL.PAC			:SET TO PENDING STATE (02/05/87 YLH)
	STB	R0,LUCTAB+LUPSTA,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,		:RETRIEVE THE RELATIVE LU #
	RBT	R0,STLGFL,,			:RESET CORRESPONDING FLAGS
	RBT	R0,FNLGFL,,
	RBT	R0,LUTFLG,,
	JR	R5				:AND RETURN
:
:END (01/14/87 YLH)
:
DTOTC1	LB	R7,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	LHL	R4,DTOTCP,R7,R7		:GET ACTION ROUTINE
	J	PSEG,R4,		:TO PROCESS

DTOTCP	HC	DTC000-PSEG		:0 - DEACTIVE STATE
	HC	DTC100-PSEG		:1 - PENDING ACTIVATE STATE
	HC	DTC200-PSEG		:2 - ACTIVE STATE
	HC	DTC300-PSEG		:3 - PENDING DEACTIVATE STATE
	HC	DTC400-PSEG		:4 - PENDING SNA RECOVERY STATE
	HC	DTC500-PSEG		:5 - PENDING LINK DOWN RECOVERY STATE
	HC	DTC600-PSEG		:6 - PENDING LINK RESET STATE

:	DTC000:	RCV'ED XCLOSE AND AT IDLE STATE
:	------
DTC000;DTC100;DTC200;DTC400;DTC500;DTC600
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	DTC300:	RCV'ED XCLOSE AND AT PENDING DEACTIVATE STATE
:	------
DTC300
	LR	R1,R0			:R1 = SCC CODE
	LHL	R3,DTC3PR,R1,R1		:GET SUB ACTION ROUTINE
	J	PSEG,R3,		:TO PROCESS

DTC3PR	HC	DTC301-PSEG		:0 - POSITIVE RESPONSE
	HC	DTC310-PSEG		:1 - NEGATIVE RESPONE
	HC	DTC320-PSEG		:2 - RESET
	HC	DTC330-PSEG		:3 - STATE ERROR

:	DTC301:	DACPU/DACLU WITH POSI AT PENDING DEACTIVATE STATE
:	------
DTC301
	LIS	R0,PL.RST		:SET UP DEACTIVATE STATE
	STB	R0,LUCTAB+LUPSTA,R11,	:..
:	DISMISS AND WAIT, THEN REISSUE RQ(XINIT)
	GL	TLACTV
	LA	R0,TLACTV,,		:ROUTINE TO ISSUE ACTIVATE
	STH	R0,LUCTAB+LUCATO,R11,
	LHI	R0,$A600		:WAIT 5 MIN
	STH	R0,LUCTAB+LUCTIM,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,LUTFLG,,		:START TIMER
	JR	R5

:	DTC310/DTC320/DTC330: DEACTPU/DEACTLU WITH WRONG SCC AT PENDING DEACT
:	-----
DTC310;DTC320;DTC330
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	DTOTDN:	RSP(DOWN), LINK DOWN RSP FROM SNA
:	------
DTOTDN
	JAL	R6,GTOCMD,,		:FETCH CMD(09/09/86/CHS) RX3
	LB	R7,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	LHL	R4,DTOTDP,R7,R7		:GET ACTION ROUTINE
	J	PSEG,R4,		:TO PROCESS

DTOTDP	HC	DTD000-PSEG		:0 - DEACTIVE STATE
	HC	DTD100-PSEG		:1 - PENDING ACTIVATE STATE
	HC	DTD200-PSEG		:2 - ACTIVE STATE
	HC	DTD300-PSEG		:3 - PENDING DEACTIVATE STATE
	HC	DTD400-PSEG		:4 - PENDING SNA RECOVERY STATE
	HC	DTD500-PSEG		:5 - PENDING LINK DOWN RECOVERY STATE
	HC	DTD600-PSEG		:6 - PENDING LINK RESET STATE

:	DTD000/DTD100/DTD200/DTD300/DTD400
:	------
DTD000;DTD100;DTD200;DTD300;DTD400
	JR	R5			:IGNORE (BUGS IN SSMV AND SPMV)
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	DTD500:	RCV'ED XLNKDN AND AT PENDING LINK DOWN STATE
:	------
:	IGNORE SCC
DTD500
	LB	R1,LUCTAB+LUCTYP,R11,	:MUST BE A PU.LUC
	NHI	R1,80
	JNFS	DTD501
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
DTD501
	LIS	R0,PL.RST		:SET UP DEACTIVATE STATE
	STB	R0,LUCTAB+LUPSTA,R11,	:..
	LHL	R13,LUCTAB+LUCPUC,R11,	:R13 = PUC OFFSET
	LIS	R1,1
DTD502
	LHL	R2,LUCTAB+LUCT.N,R11,
	AIS	R2,1
	LHL	R11,LUBPTR,R2,R2
	STB	R0,LUCTAB+LUPSTA,R11,
	AIS	R1,1
	CLB	R1,PUCTAB+PUMLUN,R13,
	JN	DTD502
	LB	R0,PUCTAB+PUCRID,R13,	:RESET BIT
	LB	R1,PUCTAB+PULNKN,R13,	:R1 = LINK #
	SLHLS	R1,1			:R1 = HW LINK INDEX
	RBT	R0,IFLRST,R1,R1		:
	JR	R5

:	DTD600:	RCV'ED XLNKDN RSP FROM SNA AND AT PENDING LINK RESET
:	------
:	IGNORE SCC
DTD600
	LB	R1,LUCTAB+LUCTYP,R11,	:MUST BE A PU.LUC
	NHI	R1,80
	JNFS	DTD601
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
DTD601
	LIS	R0,PL.RST		:SET UP DEACT STATE
	STB	R0,LUCTAB+LUPSTA,R11,
	LHL	R13,LUCTAB+LUCPUC,R11,	:R13 = PUC OFFSET
	LIS	R1,1
DTD602
	LHL	R2,LUCTAB+LUCT.N,R11,
	AIS	R2,1
	LHL	R11,LUBPTR,R2,R2
	STB	R0,LUCTAB+LUPSTA,R11,
	AIS	R1,1
	CLB	R1,PUCTAB+PUMLUN,R13,
	JN	DTD602
	JAL	R6,ILINIT,,		:RE-INIT DLC
	GL	IPWOP
	LHI	R0,IPWOP-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
:	GL	TPINIT
:	LA	R0,TPINIT		:RE-INIT DLC TIMOUT ROUTINE
:	STH	R0,PUCTAB+PUCATO,R13,
:	LHI	R0,$A120		:WAIT 1 MIN.
:	STH	R0,PUCTAB+PUCTIM,R13,
:	LB	R0,PUCTAB+PUCT.N,R13
:	SBT	R0,PUTFLG,,
	JR	R5

:	DTOTRS:	RSP(RESET), CIRCUIT ZAPPED, SNA CLEAN UP
:	------
DTOTRS
	JAL	R6,GTOCMD,,		:FETCH OUTPUT CMD(09/09/86/CHS) RX3
	LB	R7,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	LHL	R4,DTOTKP,R7,R7		:GET ACTION ROUTINE
	J	PSEG,R4,		:TO PROCESS

DTOTKP	HC	DTK000-PSEG		:0 - DEACTIVE STATE
	HC	DTK100-PSEG		:1 - PENDING ACTIVATE STATE
	HC	DTK200-PSEG		:2 - ACTIVE STATE
	HC	DTK300-PSEG		:3 - PENDING DEACTIVATE STATE
	HC	DTK400-PSEG		:4 - PENDING SNA RECOVERY STATE
	HC	DTK500-PSEG		:5 - PENDING LINK DOWN RECOVERY STATE
	HC	DTK600-PSEG		:6 - PENDING LINK RESET STATE

:	DTK000/DTK100/DTK200/DTK300/DTK500/DTK600
:	------
DTK000;DTK100;DTK200;DTK300;DTK500;DTK600
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	DTK400:	RCV'ED CKTDN AND AT PENDING SNA RECOVER STATE
:	------
DTK400
	LB	R0,LUCTAB+LUCTYP,R11,	:IS THIS LU'S/PU'S LUCTAB?
	NHI	R0,80			:IF BIT 0 = 1, IT IS A PU
	JEFS	DTK401			:IF LU, OK., WAIT AND ENTER LOCAL MODE
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
DTK401
	LIS	R0,PL.ACT		:STILL ACTIVE
	STB	R0,LUCTAB+LUPSTA,R11,	:..
	LHI	R2,NSSTLG^8+NSSTNW
	LIS	R3,0
	LIS	R8,0
	JAL	R6,QDIFSN,,
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,STLGFL,,
	JR	R5

	EI	(TERMIF)

	IF	HOSTIF

:	DTOHIN:	RCV'ED ACTPU/ACTLU
:	------
:	PROCESS ACCORDINGLY
DTOHIN
	JAL	R6,GTOCMD,,		:FETCH CMD(09/09/86/CHS) RX3
	LB	R7,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	LHL	R4,DTOHIP,R7,R7		:GET ACTION ROUTINE
	J	PSEG,R4,		:TO PROCESS

DTOHIP	HC	DHI000-PSEG		:0 - DEACTIVE STATE
	HC	DHI100-PSEG		:1 - PENDING ACTIVATE STATE
	HC	DHI200-PSEG		:2 - ACTIVE STATE
	HC	DHI300-PSEG		:3 - PENDING DEACTIVATE STATE
	HC	DHI400-PSEG		:4 - PENDING SNA RECOVERY STATE
	HC	DHI500-PSEG		:5 - PENDING LINK DOWN RECOVERY STATE
	HC	DHI600-PSEG		:6 - PENDING LINK RESET STATE

:	DHI100:	RCV'ED XINIT AND AT WRONG STATE
:	------
DHI100;DHI300;DHI600		:(08/06/86 MIA)
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

DHI500	JR	R5			:IGNORE (08/06/86 MIA)

:	DHI000:	RCV'ED XINIT AND AT IDLE OR PENDING SNA RECOVERY STATE
:	------
DHI000
DHI400					:(12/02/86 YLH)
	LR	R1,R0			:R1 = SCC CODE
	LHL	R3,DHI0PR,R1,R1		:GET SUB ACTION ROUTINE
	J	PSEG,R3,		:TO PROCESS

DHI0PR	HC	DHI001-PSEG		:0 - POSITIVE RESPONSE
	HC	DHI010-PSEG		:1 - NEGATIVE RESPONE
	HC	DHI020-PSEG		:2 - RESET
	HC	DHI030-PSEG		:3 - STATE ERROR

:	DHI001:	ACTIVE LU/PU WITH POSI AT PENDING ACTIVATE STATE
:	------
DHI001
	LIS	R0,PL.ACT		:SET UP ACTIVATE STATE
	STB	R0,LUCTAB+LUPSTA,R11,	:..
	LB	R0,LUCTAB+LUCTYP,R11,	:IS THIS LU'S/PU'S LUCTAB?
	NHI	R0,80			:IF BIT 0 = 1, IT IS A PU
	JE	DHI003			:LU, SKIP
	LHL	R12,LUCTAB+LUCPUC,R11,	:R12 = PUC OFFSET
	LIS	R1,1
DHI002
	LHL	R2,LUCTAB+LUCT.N,R11,
	AIS	R2,1
	LHL	R11,LUBPTR,R2,R2
	LHI	R2,DTHOSD-PSEG
	STH	R2,LUCTAB+LUODPR,R11,
	LHI	R2,DTHOSC-PSEG
	STH	R2,LUCTAB+LUOCPR,R11,
	AIS	R1,1
	CLB	R1,PUCTAB+PUMLUN,R12,
	JN	DHI002
	JR	R5
DHI003
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNR	R5			:RETURN IF SO
	EI
	LHL	R7,LUCTAB+LUCLNC,R11,	:R7 = LNC OFFSET
	LB	R7,LNCTAB+LNRHST,R7,	:R7 = REL HOST #
	LHL	R7,HSTPTR,R7,R7		:R7 = HOSTTAB OFFSET
	LIS	R6,1			:INCREASE HOST FREE PORTS
	AHM	R6,HOSTAB+HSTPRT,R7,	: AND HOST PORTS
	LHL	R0,HOSTAB+HSTFPT,R7,	:(9/9/85/CHS)
	AHM	R6,HOSTAB+HSTFPT,R7,
	LR	R0,R0			:(9/9/85/CHS)
	JNR	R5			:(9/9/85/CHS)
	LCS	R0,1			:(9/9/85/CHS)
	STB	R0,HOSTAB+HSTSTS,R7,	:(9/9/85/CHS)
	JAL	R6,RPTHST		:REPORT HOST UP, IF NECESSARY
	JR	R5

:	DHI010: ACTPU/ACTLU WITH NEG STATUS AT PENDING ACTIVE
:	------
DHI010
	JR	R5			:IGNORE

:						(F02/9/21/87/HS/BEGIN)
:	DHI020	:	ACTPU/ACTLU WITH RESET AT PENDING ACTIVATE STATE
:	-----
DHI020
	LIS	R0,PL.RST		:SET UP RESET STATE
	STB	R0,LUCTAB+LUPSTA,R11,
	JAL	R6,IFIACK,,		:SEND RESET.ACK TO SNA.INIT
	LB	R0,LUCTAB+LUCTYP,R11,	:IS THIS LU'S/PU'S LUCTAB?
	NHI	R0,80			:IF BIT 0=1, IT IS A PU
	JER	R5			:IF LU, RETURN
					:ELSE, CRASH

:	DHI020/DHI030:	ACTPU/ACTLU WITH RESET/ERROR AT PENDING ACTIVATE STATE
:	DHI030	:	ACTPU/ACTLU WITH ERROR AT PENDING ACTIVATE STATE
:	-----
:DHI020;DHI030					
DHI030					:(F02/9/21/87/HS/END)
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	DHI200:	RCV'ED XINIT AND AT ACTIVE STATE
:	---------
DHI200
	LR	R1,R0			:R1 = SCC CODE
	LHL	R3,DHI2PR,R1,R1		:GET SUB ACTION ROUTINE
	J	PSEG,R3,		:TO PROCESS

DHI2PR	HC	DHI201-PSEG		:0 - POSITIVE RESPONE
	HC	DHI210-PSEG		:1 - NEGATIVE RESPONSE
	HC	DHI220-PSEG		:2 - RESET
	HC	DHI230-PSEG		:3 - STATE ERROR

:	DHI201/DHI210/DHI230:	ACTPU/ACTLU AT ACTIVE STATE WITH WRONG SCC
:	----------
DHI201;DHI210;DHI230
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	DHI220:	ACTPU/ACTLU AT ACTIVE STATE WITH RESET SCC
:	------
DHI220
	LIS	R0,PL.RST		:WAITING FOR SNA TO ACTIVATE
	STB	R0,LUCTAB+LUPSTA,R11,
	JAL	R6,IFIACK,,		:(09/09/86/CHS) RX3
	LB	R0,LUCTAB+LUCTYP,R11,	:IF LU, ZAP 1 , IF PU, ZAP ALL
	NHI	R0,80
	JN	DHI221			:NO, TO ZAP ALL
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNR	R5			:RETURN IF SO
	EI
	J	DHC22Y			:JUMP TO PROCESS ACTLU (10/14/86 YLH)
					:AT DETACH, LU HAS NO DCB
:	LHL	R7,LUCTAB+LUCLNC,R11,	:RELEASE HSTPRT AND HSTFPT (10/14/86 YLH)
:	LB	R7,LNCTAB+LNRHST,R7, 	: (10/14/86 YLH)
:	LHL	R7,HSTPTR,R7,R7		: (10/14/86 YLH)
:	JAL	R6,RLSHST		: (10/14/86 YLH)
:	JR	R5			: (10/14/86 YLH)
DHI221
	LIS	R13,1			:INIT LU CNT
DHI222
	LHL	R2,LUCTAB+LUCT.N,R11,
	AIS	R2,1
	LHL	R11,LUBPTR,R2,R2	:R11 = NEW LU'S LUC
	LHI	R0,DTHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LHL	R12,LUCTAB+LUCDCB,R11,
	JE	DHI223
	JAL	R6,DSCHPR
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNFS	DHI22A			:JUMP IF SO
	EI
	LHL	R7,DCBLKS+DCBHST,RDCB,
	JAL	R6,ZAPHST,,		:(09/09/86/CHS) RX3
DHI22A	JAL	R6,RELDCB,,
DHI223
	LIS	R0,0
	STH	R0,LUCTAB+LUCDCB,R11,
	LB	R0,LUCTAB+LUPSTA,R11,
	CLHI	R0,PL.ACT
	JN	DHI224
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNFS	DHI224			:JUMP IF SO
	EI
	LHL	R7,LUCTAB+LUCLNC,R11,
	LB	R7,LNCTAB+LNRHST,R7,
	LHL	R7,HSTPTR,R7,R7
	JAL	R6,RLSHST
DHI224
	LIS	R0,PL.RST
	STB	R0,LUCTAB+LUPSTA,R11,
	AIS	R13,1
	LHL	R12,LUCTAB+LUCPUC,R11,
	CLB	R13,PUCTAB+PUMLUN,R12,
	JN	DHI222
	JR	R5

:	DTOHCL:	RSP(XCLOSE)
:	------
DTOHCL
	JAL	R6,GTOCMD,,		:FETCH CMD(09/09/86/CHS) RX3
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JEFS	DTOHC1			:JUMP IF NOT
	NHI	R7,LUVTIF!LUVHRF!LURPVC	:CLEAR NON-SYSGEN BITS
	STB	R7,LUCTAB+LUCVHR,R11,	:UPDATE VHR STATE BYTE
DTOHC1	EQ	.
	EI
	LB	R7,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	LHL	R4,DTOHCP,R7,R7		:GET ACTION ROUTINE
	J	PSEG,R4,		:TO PROCESS

DTOHCP	HC	DHC000-PSEG		:0 - DEACTIVE STATE
	HC	DHC100-PSEG		:1 - PENDING ACTIVATE STATE
	HC	DHC200-PSEG		:2 - ACTIVE STATE
	HC	DHC300-PSEG		:3 - PENDING DEACTIVATE STATE
	HC	DHC400-PSEG		:4 - PENDING SNA RECOVERY STATE
	HC	DHC500-PSEG		:5 - PENDING LINK DOWN RECOVERY STATE
	HC	DHC600-PSEG		:6 - PENDING LINK RESET STATE

:	DHC000:	RCV'ED XCLOSE AND AT IDLE STATE
:	------
DHC000
	LIS	R0,PL.RST
	STB	R0,LUCTAB+LUPSTA,R11,
	JR	R5			:IGNORE

:	DHC100/DHC400/DHC500/DHC600: RCV'ED XCLOSE AT WRONG STATE
:	-----
DHC100;DHC400;DHC500;DHC600
:	JAL	R10,CRASH,,		:(10/2/84 MIA)
:	BC	0,0,0,0FF		:(10/2/84 MIA)
	J	DHC200			:PROCESS CMD ANYWAY (10/2/84)

:	DHC200:	CV'ED XCLOSE AND AT ACTIVE STATE
:	------
DHC200
	LR	R1,R0			:R1 = SCC CODE
	LHL	R3,DHC2PR,R1,R1		:GET SB ACTION ROUTINE
	LB	R12,LUCTAB+LUPSTA,R11,	:GET CURRENT STATUS (11/12/84 MIA)
	J	PSEG,R3,		:TO PROCESS

DHC2PR	HC	DHC22X-PSEG		:0 - POSITIVE RESPONSE
	HC	DHC210-PSEG		:1 - NEGATIVE RESPONE
	HC	DHC220-PSEG		:2 - RESET
	HC	DHC230-PSEG		:3 - STATE ERROR

:	DHC210/DHC230:	DEACTPU/DEACTLU AT ACTIVE STATE
:	------
DHC210;DHC230
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	DHC220:	DEACTPU/DEACTLU AT ACTIVE STATE WITH RESET OR NO
:	------
DHC220
	JAL	R6,IFCACK,,		:(09/09/86/CHS) RX3
DHC22X
	LIS	R0,PL.RST		:WAITING FOR SNA TO ACTIVATE
	STB	R0,LUCTAB+LUPSTA,R11,
	LB	R0,LUCTAB+LUCTYP,R11,	:IF LU, RETURN, IF PU, ZAP ALL
	NHI	R0,80
	JN	DHC221
	CLHI	R12,PL.ACT		:ACTIVE? (11/12/84 MIA)
:	JNR	R5			:RETURN IF NOT (10/31/84 MIA)
	JN	DHC22Y			:JUMP IF NOT (04/10/85 MIA)
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNFS	DHC22Y			:JUMP IF SO
	EI
	LHL	R7,LUCTAB+LUCLNC,R11,	:RELEASE HSTPRT AND HSTFPT
	LB	R7,LNCTAB+LNRHST,R7,
	LHL	R7,HSTPTR,R7,R7
	JAL	R6,RLSHST
:IF DCB POINTER IN LUCB EXISTS, RELREASE DCB AND ZAP CIRCUIT (04/10/85 MIA)
DHC22Y	LHL	R12,LUCTAB+LUCDCB,R11,	:SET RDCB
	JER	R5			:RETURN (06/16/86)
	LIS	R6,0			:CLEAR THE REGISTER
	STH	R6,LUCTAB+LUCDCB,R11,	:CLEAR DCB POINTER
	JAL	R6,DSCHPR		:DISCONNECT HOST
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNFS	DHC22A			:JUMP IF SO
	EI
	LHL	R7,DCBLKS+DCBHST,RDCB,	:POINT TO HOST
	JAL	R6,ZAPHST,,		:ZAP CIRCUIT(09/09/86/CHS) RX3
DHC22A	JAL	R6,RELDCB,,		:RELEASE DCB
	JR	R5			:RETRUN
:END OF INSERTION (04/10/85 MIA)
DHC221
	LIS	R13,1			:INIT LU CNT
DHC222
	LHL	R2,LUCTAB+LUCT.N,R11,
	AIS	R2,1
	LHL	R11,LUBPTR,R2,R2	:R11 = NEW LU'S LUC
	LHI	R0,DTHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LHL	R12,LUCTAB+LUCDCB,R11,
	JE	DHC223
	JAL	R6,DSCHPR
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNFS	DHC22B			:JUMP IF SO
	EI
	LHL	R7,DCBLKS+DCBHST,RDCB,
	JAL	R6,ZAPHST,,		:(09/09/86/CHS) RX3
DHC22B	JAL	R6,RELDCB,,
DHC223
	LIS	R0,0
	STH	R0,LUCTAB+LUCDCB,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,	:GET OVERALL LU # (10/19/84 MIA)
	TBT	R0,BDPDLU,,		:ACTLU	PENDING? (10/19/84 MIA)
	JNFS	DHC22R			:JUMP IF SO (10/19/84 MIA)
	LB	R0,LUCTAB+LUPSTA,R11,
	CLHI	R0,PL.ACT
	JN	DHC224
DHC22R
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNFS	DHC224			:JUMP IF SO
	EI
	LHL	R7,LUCTAB+LUCLNC,R11,	:REL HSTPRT AND HSTFPT (10/19/84 MIA)
	LB	R7,LNCTAB+LNRHST,R7,
	LHL	R7,HSTPTR,R7,R7
	JAL	R6,RLSHST
DHC224
	LIS	R0,PL.RST
	STB	R0,LUCTAB+LUPSTA,R11,
	AIS	R13,1
	LHL	R12,LUCTAB+LUCPUC,R11,
	CLB	R13,PUCTAB+PUMLUN,R12,
	JN	DHC222
	JR	R5

:	DHC300:	RCV'ED XCLOSE AND AT PENDING DEACTIVATE STATE
:	------
DHC300
	LIS	R0,PL.RST		:SET UP DEACTIVATE STATE
	STB	R0,LUCTAB+LUPSTA,R11,	:..
	JR	R5

:	DTOHDN:	RSP(DOWN), LINK DOWN RSP FROM SNA
:	------
DTOHDN
	JAL	R6,GTOCMD,,		:FETCH CMD(09/09/86/CHS)
	LB	R7,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	LHL	R4,DTOHDP,R7,R7		:GET ACTION ROUTINE
	J	PSEG,R4,		:TO PROCESS

DTOHDP	HC	DHD000-PSEG		:0 - DEACTIVE STATE
	HC	DHD100-PSEG		:1 - PENDING ACTIVATE STATE
	HC	DHD200-PSEG		:2 - ACTIVE STATE
	HC	DHD300-PSEG		:3 - PENDING DEACTIVATE STATE
	HC	DHD400-PSEG		:4 - PENDING SNA RECOVERY STATE
	HC	DHD500-PSEG		:5 - PENDING LINK DOWN RECOVERY STATE
	HC	DHD600-PSEG		:6 - PENDING LINK RESET STATE

:	DHD000/DHD100/DHD200/DHD300/DHD400
:	------
DHD000;DHD100;DHD200;DHD300;DHD400
	JR	R5			:IGNORE (BUGS IN SSMV AND SPMV)
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	DHD500:	RCV'ED XLNKDN AND AT PENDING LINK DOWN STATE
:	------
:	IGNORE SCC
DHD500
	LB	R1,LUCTAB+LUCTYP,R11,	:MUST BE A PU.LUC
	NHI	R1,80
	JNFS	DHD501
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
DHD501
	LIS	R0,PL.RST		:SET UP DEACTIVATE STATE
	STB	R0,LUCTAB+LUPSTA,R11,	:..
	LHL	R13,LUCTAB+LUCPUC,R11,	:R13 = PUC OFFSET
	LIS	R1,1
DHD502
	LHL	R2,LUCTAB+LUCT.N,R11,
	AIS	R2,1
	LHL	R11,LUBPTR,R2,R2
	STB	R0,LUCTAB+LUPSTA,R11,
	AIS	R1,1
	CLB	R1,PUCTAB+PUMLUN,R13,
	JN	DHD502
	LB	R0,PUCTAB+PUCRID,R13,	:RESET BIT
	LB	R1,PUCTAB+PULNKN,R13,	:R1 = LINK #
	SLHLS	R1,1			:R1 = HW LINK INDEX
	RBT	R0,IFLRST,R1,R1		:RESET IFLRST
	JR	R5

:	DHD600:	RCV'ED XLNKDN RSP FROM SNA AND AT PENDING LINK RESET
:	------
:	IGNORE SCC
DHD600
	LB	R1,LUCTAB+LUCTYP,R11,	:MUST BE A PU.LUC
	NHI	R1,80
	JNFS	DHD601
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
DHD601
	LIS	R0,PL.RST		:SET UP DEACT STATE
	STB	R0,LUCTAB+LUPSTA,R11,
	LHL	R13,LUCTAB+LUCPUC,R11,	:R13 = PUC OFFSET
	JAL	R6,ILINIT,,		:RE-INIT DLC (09/09/86/CHS) RX3
	GL	ISWOP
	LHI	R0,ISWOP-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
:	GL	HPINIT
:	LA	R0,HPINIT		:RE-INIT DLC TIMOUT ROUTINE
:	STH	R0,PUCTAB+PUCATO,R13,
:	LHI	R0,$A120		:WAIT 1 MIN.
:	STH	R0,PUCTAB+PUCTIM,R13,
:	LB	R0,PUCTAB+PUCT.N,R13
:	SBT	R0,PUTFLG,,
	LIS	R3,1			:SET LU COUNTER
DHD602
	LHL	R2,LUCTAB+LUCT.N,R11,
	AIS	R2,1
	LHL	R11,LUBPTR,R2,R2	:R11 = NEW LU'S LUC OFFSET
	LIS	R0,PL.RST
	STB	R0,LUCTAB+LUPSTA,R11,
	AIS	R3,1
	CLB	R3,PUCTAB+PUMLUN,R13,
	JN	DHD602
	JR	R5

:	DTOHRS:	RSP(RESET), CIRCUIT ZAPPED, AND SNA CLEANED UP
:	------
DTOHRS
	JAL	R6,GTOCMD,,		:FETCH OUTPUT CMD(09/09/86/CHS) RX3
	LB	R7,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	LHL	R4,DTOHKP,R7,R7		:GET ACTION ROUTINE
	J	PSEG,R4,		:TO PROCESS

DTOHKP	HC	DHK000-PSEG		:0 - DEACTIVE STATE
	HC	DHK100-PSEG		:1 - PENDING ACTIVATE STATE
	HC	DHK200-PSEG		:2 - ACTIVE STATE
	HC	DHK300-PSEG		:3 - PENDING DEACTIVATE STATE
	HC	DHK400-PSEG		:4 - PENDING SNA RECOVERY STATE
	HC	DHK500-PSEG		:5 - PENDING LINK DOWN RECOVERY STATE
	HC	DHK600-PSEG		:6 - PENDING LINK RESET STATE

:	DHK000/DHK100/DHK200/DHK300/DHK500/DHK600
:	------
DHK000;DHK100;DHK200;DHK300;DHK500;DHK600
:	JAL	R10,CRASH,,		:(10/2/84 MIA)
:	BC	0,0,0,0FF		:(10/2/84 MIA)
	JR	R5			:IGNORE (10/2/84 MIA)

:	DHK400:	RCV'ED CKTDN AND AT PENDING SNA RECOVER STATE
:	------
:	        R0 HAS THE SCC WHICH DETERMINES THE NEXT LUPSTA
DHK400
:
:BEGIN (04/03/87 YLH)
:
:	LIS	R0,PL.ACT		:SET UP ACTIVATE STATE
:	LB	R6,LUCTAB+LUSSTA,R11,	:GET SNA STATE (11/07/85 MIA)
:	CHI	R6,NN.ALU		:LU ACTIVE? (11/07/85 MIA)
	CLHI	R0,NN.ALU		:LU ACTIVE?
	JEFS	DHK401			:JUMP IF SO (11/07/85 MIA)
	LIS	R0,PL.RST		:OTHERWISE RESET (11/07/85 MIA)
	JFS	DHK402
DHK401	LIS	R0,PL.ACT
:DHK401	STB	R0,LUCTAB+LUPSTA,R11,	:..
DHK402	STB	R0,LUCTAB+LUPSTA,R11,	:..
:
:END (04/03/87 YLH)
:
	LB	R0,LUCTAB+LUCTYP,R11,	:IS THIS LU'S/PU'S LUCTAB?
	NHI	R0,80			:IF BIT 0 = 1, IT IS A PU
	JER	R5			:IF LU, OK, RETURN
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

	EI	(TERMIF)


	IF	TERMIF

:	DTOTRQ:	DETACH MODE RCV'ED RQ NSM
:	------
:	CRASH NOW
DTOTRQ
	J	GOCCRH

:	DTOTER:	PROCESSING ERRORS
:	------
DTOTER
	JAL	R6,GTODTA,,
	LR	R7,R0
	LHL	R6,DTOTRR,R7,R7
	J	PSEG,R6,

DTOTRR	HC	DTTE10-PSEG		:0 - REDISPLAY THE SCREEN
	HC	DTTE20-PSEG		:1 - BIND FAILURE (POWER OFF)
	HC	DTTE30-PSEG		:2 - BIND FAILURE
	HC	DTTE40-PSEG		:3 - TIME OUT IN LU.SVC
	HC	DTTE50-PSEG		:4 - UNABLE TO CONTINUE DUE TO LU/PU
	HC	DTTE60-PSEG		:5 - UNABLE TO CONTINUE DUE TO INF/SNA
	HC	DTTE70-PSEG		:6 - UNEXECUTABLE FOR LU.SVC

DTTE10
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

DTTE20
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,STLGFL,,
	RBT	R0,FNLGFL,,
	RBT	R0,LUTFLG,,
	JR	R5

DTTE30;DTTE40;DTTE50;DTTE60;DTTE70
	LHL	R12,LUCTAB+LUCDCB,R11,	:SET UP R12
	JAL	R6,ZAPTLU,,
	JR	R5

:	DTOTPR:	DETACHED MODE RCV'ED STLG POS RSP
:	------
DTOTPR
	JAL	R6,GTODTA,,
	LR	R7,R0
	LHL	R6,DTOTRP,R7,R7
	J	PSEG,R6,

DTOTRP	HC	DTOTP0-PSEG		:POS RSP TO STLG
	HC	DTOTP1-PSEG		:POS RSP TO FINI LOGON
	HC	DTOTP2-PSEG		:LOGON SCREEN XMT O.K.

DTOTP0
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,STLGFL,,
	JEFS	DTOTP1
	IF	\FIRN
	IF	FIRN
	JAL	R7,ENTLGS		:ENETER LOGON SELECTION  MODE
	ELSE
	JAL	R7,ENTNSM		:ENETER NETWORK SERVICE MODE
	EI	(FIRN)
	EI	(\FIRN)
	JR	R5
DTOTP1;DTOTP2
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


	EI	(TERMIF)

	IF	HOSTIF

:	DTONUL:	HOST AT DETACHED MODE, NO ACTION(OR DISCARD MSG)
:	-------
DTONUL
:	JR	R5			:RETURN TO OSCAN(10/2/84/CHS)
	J	GODFLH			:DISCARD MSG(10/2/84/CHS)

DTOHER
	JAL	R6,GTODTA,,
	LR	R7,R0
	LHL	R6,DTOHRR,R7,R7
	J	PSEG,R6,

DTOHRR	HC	DTHE10-PSEG		:0 - REDISPLAY THE SCREEN
	HC	DTHE20-PSEG		:1 - BIND FAILURE (POWER OFF)
	HC	DTHE30-PSEG		:2 - BIND FAILURE
	HC	DTHE40-PSEG		:3 - TIME OUT IN LU.SVC
	HC	DTHE50-PSEG		:4 - UNABLE TO CONTINUE DUE TO LU/PU
	HC	DTHE60-PSEG		:5 - UNABLE TO CONTINUE DUE TO INF/SNA
	HC	DTHE70-PSEG		:6 - UNEXECUTABLE FOR LU.SVC

DTHE10
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

DTHE20;DTHE30;DTHE40;DTHE50;DTHE60;DTHE70
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
	JAL	R6,ZAPHLU,,		:(09/09/86/CHS) RX3
	JR	R5

:	DTOHPR:	HOST AT DETACHED MODE, RECEIVE POSTIVE RESPONE
:	-------
DTOHPR
	JAL	R6,GTODTA,,
	LR	R7,R0
	LHL	R6,DTOHRP,R7,R7
	J	PSEG,R6,

DTOHRP	HC	DTOHP0-PSEG		:0 - POS RSP TO ST LOGON
	HC	DTOHP1-PSEG		:1 - POS RSP TO FINI LOGON
	HC	DTOHP2-PSEG		:2 - POS ACK TO LOGON SCREEN

DTOHP0;DTOHP2
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

DTOHP1
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,FNLGFL,,
	JNFS	DTOHPX
:	JAL	R10,CRASH,,		:(03/01/85 MIA)
:	BC	0,0,0,0FF
	JR	R5			:IGNORE (03/01/85 MIA)
DTOHPX					:ENTER PASS THRU MODE
	LHI	R0,NPHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,NPHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	JR	R5

:IF LU OPERATES IN REFLECT MODE SNA LAYER WILL USE SNRQLG COMMAND
:TO INFORM NIO OF THE ARRIVAL OF LOGON REQUEST (BIND) OR LOGOFF
:REQUEST (UNBIND). SUBCOMMAND (SNRQBD OR SNRQUB) WILL INDICATE
:IF NIO NEEDS TO BUILD OR ZAP THE CIRCUIT (02/10/86 MIA).
	IF	VHRSUP
DTHRLG	LB	R6,LUCTAB+LUCVHR,R11,	:GET VHR INFORMATION
	JE	DTHE10			:ERROR IF NOT VHR
	JAL	R6,GTODTA,,		:GET THE COMMAND(09/09/86/CHS) RX3
	CHI	R0,SNRQBD		:REQUEST TO BUILD VC?
	JEFS	DTHRL0			:JUMP IF SO
	JAL	R6,DTHUBR,,		:SEND UNBIND RESPONSE TO SNA(09/09/86/CHS) RX3
	JR	R5			:AND RETURN
DTHRL0	JAL	R6,DTHBDR,,		:SEND BIND RESPONSE TO SNA(09/09/86/CHS) RX3
	LHI	R0,RLOSCC-PSEG		:PREPARE LOGON STATE FOR COMMAND
	STH	R0,LUCTAB+LUOCPR,R11,	:UPDATE LUCB
	LHI	R0,RLOSCD-PSEG		:PREPARE LOGON STATE FOR DATA
	STH	R0,LUCTAB+LUODPR,R11,	:UPDATE LUCB
	LB	R0,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	OHI	R0,LUSVCP		:SHOW THAT SVC BUILDING IN PROGRESS
	STB	R0,LUCTAB+LUCVHR,R11,	:UPDATE VHR STATE BYTE
	LHL	R0,LUCTAB+LUCDCB,R11,	:GET DCB POINTER
	JNR	R5			:RETURN IF THERE IS DCB ALREADY
	JAL	R6,GETDCB,,		:OBTAIN DCB
	JNFS	DTHRL1			:JUMP IF SUCCESSFUL
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	BC	0,0,4*RLINK,CRDCB	:DCB PROBLEMS
DTHRL1	STH	RDCB,LUCTAB+LUCDCB,R11,	:SAVE DCB POINTER IN LUCB
	STH	R11,DCBLKS+DCBLUC,RDCB,	:SAVE LUCB POINTER IN DCB
	BBLSCB	R4,LUCTAB+LULSCB,R11,	:GET SCB POINTER
	LB	R6,SCBBLK+SCSLUP,R4,	:GET SEC LU PROTOCOL BYTE
	THI	R6,80			:CHECK IF MULTIPLE CHAINS ALLOWED
	JNFS	DTHRL2			:JUMP IF SO
	LHI	R0,RUNOMX		:PREPARE TO CLEAR RU LENGTH
	JNFS	DTHRL3			:JUMP TO CONTINUE
DTHRL2	LB	R6,SCBBLK+SCSMRU,R4,	:GET MUX RU SIZE FOR SEC
	LR	R0,R6			:COPY IT
	NHI	R6,0F			:GET EXPONENT
	SRLS	R0,4			:GET MUPLIPLIER FOR EXPONENT
	SLL	R0,0,R6			:CALCULATE RU LENGTH
DTHRL3	STH	R0,DCBLKS+DCBRUL,RDCB,	:SAVE IT IN DCB
	LB	R6,LUCTAB+LUCPUN,R11,	:GET PU NUMBER
	LHL	R6,PUCPTR,R6,R6		:GET PUCTAB POINTER
	STH	R6,DCBLKS+DCBPUC,RDCB,	:SAVE IT IN DCB
	LB	R0,PUCTAB+PUPLAD,R6,	:GET PU ADDR
	STB	R0,DCBLKS+DCBCUA,RDCB,	:SAVE IT IN DCB
	LB	R0,LUCTAB+LUCADR,R11,	:GET DEVICE ADDR
	STB	R0,DCBLKS+DCBLUA,RDCB,	:SAVE IT IN DCB
:TEMPORARY VTR SUPPORTS ONLY CRT'S OF REGULAR SIZE.
	LHI	R0,4			:TEMPORARY - CRT OF REGULAR SIZE
	STB	R0,DCBLKS+DCBFST,RDCB,	:SAVE FORMAT/SIZE IN DCB
	LHL	R6,PUCTAB+PUCLNC,R6,	:GET LNCTAB POINTER
	STH	R6,DCBLKS+DCBLNC,RDCB,	:SAVE IT IN DCB
	LHL	R6,LNCTAB+LNMXFM,R6,	:GET MAX FRAME SIZE
	SIS	R6,2			:ADJUST FOR ADDR AND CONTROL BYTE
	STH	R6,DCBLKS+DCBSGL,RDCB,	:SAVE MAX SEGMENT SIZE
	LHI	R0,L.LSTR		:SET WAITING FOR LOGON STREAM
	STB	R0,DCBLKS+DCBSTA,RDCB,	:UPDATE CURRENT STATUS
	JR	R5			:AND RETURN
	ELSE
DTHRLG	J	DTHE10			:ERROR IF NOT VHR
	EI
:END OF VHR INSERTION (02/10/86 MIA).

	EI	(HOSTIF)

	SUBTTL	(SNA-NOSC) SNA/PTHRU MODE - OUTPUT SCAN PROCESSING


:
:	GENERATE 'SNA/PTHRU MODE' OUTPUT CMD-Q SCAN PROCESSING TABLE
:
:	TERMINAL -	IF RSP(XINIT) & PU, RECOVERY & ENTER DETACH MODE
:			IF RSP(XINIT) & LU, ENTER NETWORK SERVICE MODE
:			IF RSP(XCLOSE) & PU, NWK RECOVERY & ENTER DETACH MODE
:			IF RSP(XCLOSE) & LU, CRT RECOVERY & ISSUE RQ(XINIT)
:			IF RSP(XDOWN), CRASH
:			IF RSP(XRESET), ????
:
:	HOST     -	IF RQ(XINIT), UPDATE STATUS
:			IF RQ(XCLOSE), ENTER DETACH MODE
:			IF RSP(XDOWN), ENTER DETACH MODE
:			IF RSP(XRESET), ENTER DETACH MODE
:

	IF	TERMIF

	GENSNC(NPTOSC)			:SNA/PTHRU MODE CMD-Q

	CHGSNC(NPTOSC,XINIT,NPOTIN)
	CHGSNC(NPTOSC,XCLOSE,NPOTCL)
	CHGSNC(NPTOSC,XDOWN,NPOTDN)
	CHGSNC(NPTOSC,XRESET,NPOTRS)
	EI	(TERMIF)

	IF	HOSTIF

	GENSNC(NPHOSC)			:SNA/PTHRU MODE CMD-Q

	CHGSNC(NPHOSC,XINIT,NPOHIN)
	CHGSNC(NPHOSC,XCLOSE,NPOHCL)
	CHGSNC(NPHOSC,XDOWN,NPOHDN)
	CHGSNC(NPHOSC,XRESET,NPOHRS)
	EI	(HOSTIF)

:
:	GENERATE 'SNA/PTHRU MODE' OUTPUT DATA-Q SCAN PROCESSING TABLE
:
:	TERMINAL -	PASS THRU SNETEM MESSAGE, INTERCEPT SNRQLG
:			CRASH ALL OTHER CASES
:
:	HOST     -	PASS THRU SNETEM MESSAGE
:			CRASH ALL OTHER CASES

	IF	TERMIF

	GENSND(NPTOSD)			:SNA/PTHRU MODE DATA-Q

	CHGSND(NPTOSD,SNETEM,NPOGPT)
	CHGSND(NPTOSD,SNINTM,NPOGLO)
	CHGSND(NPTOSD,SNRQLG,NPOTRQ)
	CHGSND(NPTOSD,SNERR,NPOTER)
	CHGSND(NPTOSD,SNPOSR,NPOTPR)

	EI	(TERMIF)

	IF	HOSTIF

	GENSND(NPHOSD)			:SNA/PTHRU MODE DATA-Q

	CHGSND(NPHOSD,SNETEM,NPOGPT)
	CHGSND(NPHOSD,SNINTM,NPOGLO)
	CHGSND(NPHOSD,SNRQLG,NPOHLG)
	CHGSND(NPHOSD,SNERR,NPOHER)
	CHGSND(NPHOSD,SNPOSR,GOCCRH)

	EI	(HOSTIF)




	IF	TERMIF

:	NPOTIN:	XINIT
:	-------
:	RECOVERY, AND ENTER DETACH MODE
:	BUT CRASH NOW
:	NOTE: LU ONLY, SINCE PU.LUC ALWAYS AT DETACHED MODE
NPOTIN
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
:
:BEGIN (01/14/87 YLH)
:
:	PASS THRU MODE RSP(XCLOSE) -
:
:	NOTIFY(POWER OFF) IS INFORMED TO THE NIO THROUGH SNA->NIO CMD_Q
:	CLOSE COMMAND WITH POWER OFF SUBCOMMAND.
:
NPOTCL	ST	R5,IR5SAV,,			:SAVE THE RETURN ADDR
	JAL	R6,GTOCMD,,			:FETCH COMMAND
	CLHI	R0,E.POFF			:SUBCOMMAND=POWER OFF?
	JN	NPOTC1				:NO, CRASH
	LHL	RDCB,LUCTAB+LUCDCB,R11,		:YES, SET UP RDCB
	JAL	R6,ZPTCKT,,			:ZAP CIRCUIT
:
:	RESET LU/DEVICE
:
	LHI	R0,DTTOSD-PSEG			:SET THE NOSC TO DETACH MODE
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTTOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LIS	R0,PL.PAC			:SET TO PENDING STATE (02/05/87 YLH)
	STB	R0,LUCTAB+LUPSTA,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,		:RETRIEVE THE RELATIVE LU #
	RBT	R0,STLGFL,,			:RESET CORRESPONDING FLAGS
	RBT	R0,FNLGFL,,
	RBT	R0,LUTFLG,,
	L	R5,IR5SAV,,			:RETRIEVE THE RETURN ADDR.
	JR	R5
:
:END (01/14/87 YLH)
:
:	NPOTDN:	CRASH NOW
:	------
NPOTC1
NPOTDN
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	NPOTRS:	CRASH NOW
:	------
NPOTRS
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


	EI	(TERMIF)

	IF	HOSTIF

:	NPOHIN:	STILL ACTIVE, BUT ZAP CIRCUIT AND ENTER DETACH MODE
:	------
:	NOTE: PUC.LUC ALWAYS AT DETACH MODE
NPOHIN
	JAL	R6,GTOCMD,,		:FETCH OUTPUT CMD
	CLHI	R0,E.REST		:IF RESET, THEN NEED TO ACK
	JE	NPOHI1			:NO RESET, SKIP
	IF	VHRSUP
	LB	R6,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R6,LUVHRF		:VHR FUNCTION?
	JN	NPOHI2			:JUMP IF SO
	EI
	LHL	R6,LUCTAB+LULATO,R11,	:GET APPLICATION LOGOFF TIMER
	JE	NPOHI2			:JUMP,IF NO TIMER SPECIFIED
	LHL	R6,LUCTAB+LUCT.N,R11,	:GET RELATIVE LU #
:	IF	HDPSUP
:	GL	BDPDLU
:	TBT	R6,BDPDLU		:IS DACTLU PENDING? (10/8/84 MIA)
	RBT	R6,BDPDLU,,		:IS DACTLU PENDING? (10/8/84 MIA)
	JE	NPOHI0			:NO,JUMP
:	EI
NPOHI2
:	LHI	R0,DTHOSD-PSEG		:(10/8/84 MIA)
	LHI	R0,NPHOSD-PSEG		:PASS THRU MODE (10/8/84 MIA)
	STH	R0,LUCTAB+LUODPR,R11,
:	LHI	R0,DTHOSC-PSEG		:(10/8/84 MIA)
	LHI	R0,NPHOSC-PSEG		:PASS THRU (10/8/84 MIA)
	STH	R0,LUCTAB+LUOCPR,R11,
	LIS	R0,PL.ACT		:SET UP ACTIVATE STATE
	STB	R0,LUCTAB+LUPSTA,R11,	:..
	JR	R5			:RETURN
NPOHI0
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
NPOHI1
	GL	IFIACK
	JAL	R6,IFIACK,,		:RETURN INIT ACK TO SNA(09/09/86/CHS) RX3
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	JAL	R6,DSCHPR		:DISCONNECT ISIS PORT
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNFS	NPOHIA			:JUMP IF SO
	EI
	LHL	R7,DCBLKS+DCBHST,RDCB,	:SET UP R7 = HOST OFFSET
	JAL	R6,ZAPHST,,		:RELEASE HOST PORT(09/09/86/CHS) RX3
	JAL	R6,RLSHST		:RELEASE HSTPRT AND HSTFPT
NPOHIA	JAL	R6,RELDCB,,		:RELEASE DCB
	LHI	R0,DTHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LIS	R0,PL.RST		:SNA WILL SEND INIT AGAIN
	STB	R0,LUCTAB+LUPSTA,R11,
	LIS	R0,0			:DETACH DCB AND LUC
	STH	R0,LUCTAB+LUCDCB,R11,
	JR	R5

:	NPOHCL:	ZAP CIRCUIT AND ENTER DETACH MODE, DEACTIVE STATE
:	------
:	NOTE:	PU.LUC ALWAYS AT DETACH MODE
NPOHCL
	JAL	R6,GTOCMD,,		:FETCH OUTPUT CMD
	CLHI	R0,E.REST		:IF SNA RESET, HAVE TO ACK
	JEFS	NPOHC1			:NO, DONT ACK
	LIS	R0,PL.RST		:RESET STATE (10/15/84 MIA)
	STB	R0,LUCTAB+LUPSTA,R11,	:UPDATE LU STATUS (10/15/84 MIA)
	J	NPOHC2
NPOHC0
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
NPOHC1
	GL	IFCACK
	JAL	R6,IFCACK,,		:(09/09/86/CHS) RX3
NPOHC2
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	JE	NPOHC3			:NO DCB,JMP (8/6/84/CHS) (10/8/84 MIA)
:	J	NPOHC3			:JUMP (8/6/84/CHS) (10/8/84 MIA)
:	07/17/84 NCS -- GENERALIZE TIMEOUT FUNCTION
	IF	VHRSUP
	LB	R6,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R6,LUVHRF		:VHR FUNCTION?
	JEFS	NPOHCA			:JUMP IF NOT
	JAL	R6,DSCHPR		:DISCONNECT ISIS PORT
	J	NPOHCB			:JUMP TO CONTINUE
	EI
NPOHCA	LHL	R6,LUCTAB+LULATO,R11,	:GET TIMEOUT VALUE
	JE	NPOHC3			:JUMP IF NOT TIMEOUT (10/10/84 MIA)
	STH	R6,DCBLKS+DCBLA1,R12,	:SET LOGOFF TIMEOUT IN DCB
:	JE	NPOHC4			:JUMP,IF NO TIMEOUT (10/10/84 MIA)
	GL	DHLFTV
	LHL	R7,LUCTAB+LUCT.N,R11,	:GET RELATIVE LU #
	SBT	R7,BDPDLU,,		:SET TO INF. TIMEOUT LOGICAL
	LHI	R6,DHLFTV-PSEG		:GET APPLICATION LOGOFF TIMEOUT
NPOHC4
	STH	R6,DCBLKS+DCBLAT,R12,	:SAVE TIMEOUT PROCESS
	JR	R5			:RETURN
NPOHC3
	JAL	R6,DSCHPR		:DISCONNECT ISIS PORT
	LHL	R7,DCBLKS+DCBHST,RDCB,	:SET UP R7 = HOST OFFSET
	JAL	R6,ZAPHST,,		:RELEASE HOST PORT(09/09/86/CHS) RX3
	JAL	R6,RLSHST		:RELEASE HSTPRT AND HSTFPT
NPOHCB	JAL	R6,RELDCB,,		:RELEASE DCB
	LHI	R0,DTHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LIS	R0,PL.RST
	STB	R0,LUCTAB+LUPSTA,R11,
	LIS	R0,0			:DETACH DCB AND LUC
	STH	R0,LUCTAB+LUCDCB,R11,
	JR	R5

:	NPOHDN:	PROGRAMMING ERROR
:	-----
NPOHDN
:	NPOHRS:	PROGRAMMING ERROR
:	-----
NPOHRS
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

	EI	(HOSTIF)




:	NPOGPT:	PASS THRU THE DATA TO NETWORK(BOTH TERMIF/HOSTIF)
:	------
NPOGPT
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	LHL	R0,DCBLKS+DCBIPR,R12,	:R0 = ISIS PORT
	TBT	R0,TOISIS,,		:BACKPRESSURE FROM TYMNET?
	JER	R5			:YES, EXIT
	JAL	R6,PKODTA,,		:PEEK AGAIN
	NOP	0
	LR	RBBA,R3			:SET UP RBBA
	LHL	R12,LUCTAB+LUCDCB,R11,	:SET TUP R12 = RDCB
	LHL	R4,DCBLKS+DCBOUT,RDCB,	:GET ISIS OUTPUT PROCESS
	JN	PSEG,R4,
	JAL	R10,CRASH,,
	BC	0,0,0,088

:	NPOGLO:	DISCARD (BOTH TERMIF/HOSTIF)
:	------
NPOGLO
	JAL	R7,DLODTA,,
	JR	R5

	IF	TERMIF

:	NPOTRQ:	PASS THRU MODE, RCV'ED RQ STLG
:	------
NPOTRQ
	JAL	R6,GTODTA,,
:MARK DCB IF LOGON WAS REQUESTED DURING END-TO-END DSP SESSION
:TO BE ABLE TO RETURN TO CONVERSATION AFTER LOGON (02/10/87 MIA).
	IF	VTISUP
	LB	R0,LUCTAB++LUCVTI,R11,	:GET VTI STATE BYTE
	THI	R0,LUVTIF		:VTI FUNCTION?
	JEFS	NPOTR1			:JUMP IF NOT
	LHL	R12,LUCTAB+LUCDCB,R11,	:GET DCB POINT
	LHL	R0,DCBLKS+DCBIPR,R12,	:GET ISIS PORT NUMBER
	JEFS	NPOTR1			:JUMP IF NO PORT
	LIS	R0,NSSTTR		:LOGON WAS INITIATED ON REQUEST
	STB	R0,DCBLKS+DCBNTY,R12,	:SAVE IT
NPOTR1	EQ	.
	EI
:END OF INSERTION (02/10/87 MIA).
	LHI	R2,NSSTLG^8!NSSTTR
	LIS	R3,0
	LIS	R8,0
	JAL	R6,QDIFSN,,		:ISSUE START NSM TO LU.SVC
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,STLGFL,,		:INDICATE STLG OUTSTANDING
	JR	R5
	GL	ZPTCKT
:
:	NPOTER:	ZAP CIRCUIT AND DEVICE
:	------
:BEGIN (11/07/86 YLH)
:
NPOTER
	JAL	R6,GTODTA,,		:GET SUBCOMMAND
	LHL	RDCB,LUCTAB+LUCDCB,R11,	:GET DCB POINTER
	LR	R7,R0			:LET R7 HAS THE ERROR SUBCOMMAND
	LHL	R7,NERTBL,R7,R7		:VECTOR EXECUTION
	J	PSEG,R7,
:
NERTBL	HC	NPTE10-PSEG		:RECOVERABLE STATUS
	HC	NPTE20-PSEG		:SHORT TERM UNAVAILABLE STATUS
	HC	NPTE30-PSEG		:LONG TERM UNAVAILABLE STATUS
	HC	NPTE40-PSEG		:TIMEOUT IN LU.SVC
	HC	NPTE50-PSEG		:UNABLE TO CONTINUE DUE TO PU/LU
	HC	NPTE60-PSEG		:UNABLE TO CONTINUE DUE TO INF/SNA
	HC	NPTE70-PSEG		:UNEXECUTABLE FOR LU.SVC
:
:SEND 'AVAILABLE AND SCREEN LOST' DSP MESSAGE TO THE HOST INTERFACE
:
NPTE10	LHI	R0,SCRLST		:SEND 'AVAILABLE AND SCREEN LOST'
	STB	R0,STSSB1,,		:DSP STATUS TO THE HOST INTERFACE
	EXBR	R0,R0
	STB	R0,STSSB0,,
	LA	R9,M.STAT-1,,		:LOAD MESSAGE LENGTH
	JAL	R6,SNDIIX,,		:(09/09/86/CHS) RX3
	JR	R5
:
:SEND 'NOT AVAILABLE' DSP MESSAGE TO THE HOST INTERFACE
:
NPTE20	LHI	R0,NOTAVA		:SEND 'NOT AVAILABLE' DSP STATUS
	STB	R0,STSSB1,,		:TO THE HOST INTERFACE
	EXBR	R0,R0
	STB	R0,STSSB0,,
	LA	R9,M.STAT-1,,		:LOAD MESSAGE LENGTH
	JAL	R6,SNDIIX,,		:(09/09/86/CHS) RX3
	JR	R5
:
:BREAK THE CIRCUIT
:
NPTE30	JAL	R6,ZPTCKT,,		:ZAP CIRCUIT(09/09/86/CHS) RX3
	JAL	R6,ZAPTLU,,		:ZAP DEVICE
	JR	R5			:RETURN TO OSCAN

NPTE40
NPTE50
NPTE60
NPTE70	JAL	R10,CRASH,,
	BC	0,0,0,0FF
:
:END (11/07/86 YLH)
:

:	NPOTPR:	PASS THRU MODE, RCV'ED POS RSP
:	-------
NPOTPR
	JAL	R6,GTODTA,,
	LR	R7,R0
	LHL	R6,NPOTRP,R7,R7
	J	PSEG,R6,

NPOTRP	HC	NPOTP0-PSEG		:0 - POS TO ST LOGON
	HC	NPOTP1-PSEG		:1 - POS RSP TO FINI LOGON
	HC	NPOTP2-PSEG		:2 - POS ACK TO LOGON SCREEN

NPOTP0
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,STLGFL,,
	JEFS	NPOTP1
	IF	\FIRN
	IF	FIRN
	JAL	R7,ENTLGS		:ENTER LS MODE
	ELSE
	JAL	R7,ENTNSM		:ENTER NS MODE
	EI	(FIRN)
	EI	(\FIRN)
	JR	R5

NPOTP1;NPOTP2
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
	EI	(TERMIF)

	IF	HOSTIF

:	NPOHLG: LOGON/LOGOFF REQUEST FROM SNA. VALID ONLY FOR
:	VHR FUNCTION. ONLY LOGOFF REQUEST (SUBCOMMAND SNRQUB)
:	IS VALID IN PASS-TROUGH MODE OF OPERATION.
NPOHLG
	IF	VHRSUP
	LB	R6,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	JE	GOCCRH			:CRASH IF NOT VHR
	JAL	R6,GTODTA,,		:GET COMMAND FROM SNA
	CHI	R0,SNRQUB		:UNBIND FROM SNA?
	JE	RLOTL1			:CONTINUE AS IN LOGON MODE IF SO
	J	GOCCRH			:OTHERWISE CRASH
	ELSE
	J	GOCCRH			:CRASH IF NOT VHR
	EI
	GL	ZPHCKT
:
:	NPOHER:	ZAP CIRCUIT AND DEVICE
:	------
:BEGIN (11/07/86 YLH)
:
NPOHER
	JAL	R6,GTODTA,,		:GET SUBCOMMAND
	CLHI	R0,SNERPO		:IF BIND IS NOT FORTHCOMING, THEN
	JNFS	NPOHE1
	JAL	R6,ZPHCKT,,		:ZAP CIRCUIT
	JAL	R6,ZAPHLU,,		:ZAP DEVICE(09/09/86/CHS) RX3
	JR	R5			:RETURN TO OSCAN
NPOHE1	JAL	R10,CRASH,,
	BC	0,0,0,0FF
:
:END (11/07/86 YLH)
:
	EI	(HOSTIF)

	SUBTTL	(SNA-NOSC) NATIVE SNA NS MODE - OUTPUT SCAN PROCESSING

	IF	TERMIF

:
:	GENERATE 'SNA LOGON MODE' OUTPUT CMD-Q SCAN PROCESSING TABLE
:
:	TERMINAL -	IF RSP(XINIT) & PU, RECOVERY & ENTER DETACH MODE
:			IF RSP(XINIT) & LU, ENTER NETWORK SERVICE MODE
:			IF RSP(XCLOSE) & PU, NWK RECOVERY & ENTER DETACH MODE
:			IF RSP(XCLOSE) & LU, CRT RECOVERY & ISSUE RQ(XINIT)
:			IF RSP(XDOWN), CRASH
:			IF RSP(XRESET), CRASH
:
:	HOST     -	NO LOGON MODE
:

	GENSNC(NLOSCC)			:SNA LOGON MODE CMD-Q

	CHGSNC(NLOSCC,XINIT,NLOTIN)
	CHGSNC(NLOSCC,XCLOSE,NLOTCL)
	CHGSNC(NLOSCC,XDOWN,NLOTDN)
	CHGSNC(NLOSCC,XRESET,NLOTRS)

:
:	GENERATE 'NATIVE SNA LOGON MODE' OUTPUT DATA-Q SCAN PROCESSING TABLE
:
:	TERMINAL -	PASS THRU SNETEM MESSAGE,
:			INTERPRET SNINTM MESSAGE, CRASH ON SNRQLG
:		PROCESS SNERR, AND SNPOSR
:
:	HOST     -	NO LOGON MODE

	GENSND(NLOSCD)			:NATIVE SNA LOGON MODE DATA-Q

	CHGSND(NLOSCD,SNETEM,NLOTPT)
	CHGSND(NLOSCD,SNINTM,NLOTLO)
	CHGSND(NLOSCD,SNRQLG,GOCCRH)
	CHGSND(NLOSCD,SNERR,NLOTER)
	CHGSND(NLOSCD,SNPOSR,NLOTPR)




:
:BEGIN (01/14/87 YLH)
:	LOGON MODE RSP(XCLOSE)-
:
:	NOTIFY(POWER OFF) IS INFORMED TO THE NIO THROUGH SNA->NIO CMD_Q
:	CLOSE COMMAND WITH POWER OFF SUBCOMMAND.
:
NLOTCL	JAL	R6,GTOCMD,,			:FETCH COMMAND
	CLHI	R0,E.POFF			:SUBCOMMAND=POWER OFF?
	JN	NLOTC1				:NO, CONTINUE AS NORMAL CLOSE
	LHL	RDCB,LUCTAB+LUCDCB,R11,		:YES, SET UP RDCB
:
:	RELEASE ISIS RING BUFFER
:
	JAL	R6,ROUTQ,,			:RELEASE ISIS OUTPUT QUEUES
	JAL	R6,RINPBB,,			:RELEASE ISIS INPUT BUFFER
:
:	RESET LU/DEVICE
:
	LHI	R0,DTTOSD-PSEG			:SET THE NOSC TO DETACH MODE
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTTOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LIS	R0,L.IDLE			:SET DEVICE IDLE STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LIS	R0,PL.PAC			:SET TO PENDING STATE (02/05/87 YLH)
	STB	R0,LUCTAB+LUPSTA,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,		:RETRIEVE THE RELATIVE LU #
	RBT	R0,STLGFL,,			:RESET CORRESPONDING FLAGS
	RBT	R0,FNLGFL,,
	RBT	R0,LUTFLG,,
	JR	R5
:
NLOTC1	JAL	R10,CRASH,,
	BC	0,0,0,0FF
:
:END (01/14/87 YLH)
:
:	NLOTIN:	PROGRAMMING ERROR
:	------
NLOTIN
:	NLOTDN:	PROGRAMMING ERROR
:	------
NLOTDN
:	NLOTRS:	PROGRAMMING ERROR
:	------
NLOTRS
	JAL	R10,CRASH,,
	BC	0,0,0,0FF




:	NLOTPT:	PASS THRU DATA
:	------
NLOTPT
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	LHL	R0,DCBLKS+DCBIPR,R12,	:R0 = ISIS PORT
	TBT	R0,TOISIS,,		:BACKPRESSURE FROM TYMNET?
	JER	R5			:YES, EXIT
	JAL	R6,PKODTA,,		:PEEK AGAIN
	NOP	0
	LR	RBBA,R3			:SET UP RBBA
	LHL	R12,LUCTAB+LUCDCB,R11,	:SET TUP R12 = RDCB
	LHL	R4,DCBLKS+DCBOUT,RDCB,	:GET ISIS OUTPUT PROCESS
	JN	PSEG,R4,
	JAL	R7,DLODTA,,		:ELSE, DISCARD CMD & BBS
	JR	R5

:	NLOTLO:	SCAN DATA
:	------
NLOTLO
	JAL	R6,GTODTA,,		:FETCH OUTPUT DATA
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	LB	R4,DCBLKS+DCBSTA,R12,	:R4 = NSM STATE
	CLHI	R4,L.GTWY		:WITHIN RANGE?
	JG	GOCCRH			:NO, CRASH
	LB	R6,BBUFER+FID2LN+RHLEN,R3,	:GET AID KEY
	CLHI	R6,AIDENT		:IF NOT 'ENTER' KEY, THEN ABORT
	JN	NLOTL1			: AND RE-DISPLAY NSM SCREEN
	LHL	R4,NLOTLP,R4,R4		:GET PROC. ROUTINE
	J	PSEG,R4,		:TO PROC

NLOTL1					:"ABORT", R3 = LOCAL INPUT DATA BB
	JAL	R6,DLODBB,,		:DELETE ANY LOGON DATA BB
NLOTL2
	JAL	R6,ISIEND		:END ANY ISIS INPUT
	JAL	R6,PTLBH,,
	LA	R1,LEM16,,		:DISPLAY "PROCEDURE ABORTED"
	JAL	R6,PMLB,,
	BBL	R3,LUCTAB+LUCIBH,R11,
	LHI	R2,NSINTM^8!NSDTCD
	JAL	R6,QDIFSN,,
	JAL	R6,RSTTRM		:AND ZAP CIRCUIT
	LHI	R0,L.ERCK
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	JR	R5

:	NLOTLP:	NSM MODE, LOCAL DATA PROC TBALE
:	------
:	INDEXED BY DCBSTA
NLOTLP	HS	0
	HC	NLNS00-PSEG		:00 - IDEL, CRASH
	HC	NLNS10-PSEG		:01 - NS SLECTTION, PROCESS
	HC	NLNS20-PSEG		:02 - LG SLECTTION, PROCESS
	HC	NLNS30-PSEG		:03 - LOGON DATA, REQUEST NEEDLE
	HC	NLNS40-PSEG		:04 - PSUDLE NEEDEL, DELETE
	HC	NLNS50-PSEG		:05 - USER NAME, IF ERC SEND USERNAME
	HC	NLNS60-PSEG		:06 - USER NAME SENT, DELETE
	HC	NLNS70-PSEG		:07 - PSWD, IF ERC SEND PASSWORD
	HC	NLNS80-PSEG		:08 - PSWD SENT, DELETE
	HC	NLNS90-PSEG		:09 - LOGON STRING SENT, DELETE
	HC	NLNSA0-PSEG		:0A - DIALECT, DELETE
	HC	NLNSB0-PSEG		:0B - TIIX, DELETE
	HC	NLNSC0-PSEG		:0C - DSP, PROCESS
	HC	NLNSD0-PSEG		:0D - DSP & ASC, PROCESS
	HC	NLNSE0-PSEG		:0E - TURKEY, DELETE
	HC	NLNSF0-PSEG		:0F - CALL ACCEPT, DELETE
	HC	NLNSG0-PSEG		:10 - CIRCUIT ENABLE, DELETE
	HC	NLNSH0-PSEG		:11 - EROR/ABORT
	HC	NLNSI0-PSEG		:12 - GATEWAY, PROCESS

:	NLNS00:	IDLE STATE
:	------
NLNS00
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	NLNS10:	NS SELECTION
:	------
NLNS10
	NHI	R0,SNDTIS		:SEE IF SINGLE SEGMENT
	JEFS	NLNS11			:YES, SKIP
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,0FF
NLNS11
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,07
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	NLNS1V			:SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
NLNS1V
	LHI	R0,$A80
	LB	R4,NETSF1,R6,		:GET ROW #
	LB	R7,NETSF1+1,R6,		:GET COLUMN #
	JAL	R6,SBADDR,,		:GET BBUF ADDR
	STH	R0,FLDADR,,
	LIS	R6,1
	STH	R6,FLDIND,,		:SERACH FIELD 1ST
	LR	RBBA,R3
	BBST	RBBA,DCBLKS+DCBLBA,R12,	:SET UP DCBLBA
	STB	R8,DCBLKS+DCBLLV,R12,	:SAVE DATA LENGTH IN DCBLLV
	JAL	R6,GETFB,,		:TO FIND THE DATA
	LR	R2,R0			:R2 = 1ST CHAR OF DATA
	JE	NLNS15			:IF 0, NO DATA
	CLHI	R2,37			:WITHIN RANGE?
	JG	NLNS15			:NO, TO DISPLAY ERROR MSG
	CLHI	R2,31
	JL	NLNS15			:NO, TO DISPLAY ERROR MSG
	NHI	R2,0F			:CONVERT INTO BINARY DATA
	LHL	R4,NLSN1T,R2,R2		:GET PROC
	J	PSEG,R4,		:TO PROC

:	NLSN1T:	PROC FOR NS SELECTION
:	------
NLSN1T	HS	0
	HC	NLNS15-PSEG		:0 - ILLEGAL
	HC	NLNS16-PSEG		:1 - CRT MANUAL LOGON
	HC	NLNS17-PSEG		:2 - CRT PRESET LOGON
	HC	NLNS18-PSEG		:3 - PRT MANUAL LOGON
	HC	NLNS19-PSEG		:4 - PRT PRESET LOGON
	HC	NLNS1A-PSEG		:5 - CRT LOGOFF
	HC	NLNS1B-PSEG		:6 - PRT LOGOFF
	HC	NLNS1C-PSEG		:7 - EXIT NSM

NLNS15					:ILLEGAL
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELETE OUTPUT LOGON DATA BB
	JAL	R6,PTLBH,,
	LA	R1,NNSE1,,
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	R5

NLNS16					:CRT MANUAL LOGON
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELETE OUTPUT LOGON DATA BB
NLNS1W
	JAL	R6,PTLBH,,
	LIS	R0,D.ACTV
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JN	NLNS1X			:CRT ALREAY CONNECTED
	LA	R1,MLGSCN,,		:SEND MANUAL LOGON SCREEN
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	LHI	R0,L.LSTR
	STB	R0,DCBLKS+DCBSTA,R12,
	LIS	R0,D.STOR		:SET TO MANUAL LOGON MODE
	RBT	R0,DCBLKS+DCBMOD,R12,
	JR	R5
NLNS1Y
	JAL	R6,PTLBH,,
NLNS1X					:CRT ALREAY CONNECTED
	LA	R1,LEM20,,
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	R5

NLNS17					:CRT PRESET LOGON
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELETE OUTPUT LOGON DATA BB
	LIS	R0,D.ACTV
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JN	NLNS1Y			:TO DISPLAY ERROR
	JAL	R6,SNDLGS,,		:SEND LOGON SELECTION MENU(09/09/86/CHS) RX3
	LIS	R0,L.MENU
	STB	R0,DCBLKS+DCBSTA,R12,
	JR	R5

NLNS18					:PRT MANUAL LOGON
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELETE OUTPUT LOGON DATA BB
	J	NLNS1E			:NOT SUPPORT YET

NLNS19					:PRT PRESET LOGON
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELETE OUTPUT LOGON DATA BB
	J	NLNS1E			:NOT SUPPORT YET

NLNS1A					:CRT LOGOFF
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELETE OUTPUT LOGON DATA BB
	LIS	R0,D.ACTV		:SEE IF CIRCUIT THERE
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JE	NLNS1Z			:NO, SKIP
	LIS	R0,4			:LOGOFF BY USER
	STB	R0,DCBLKS+DCBTMP,RDCB,
	JAL	R6,RSTTRM		:RESET TERMINAL
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	IF	\FIRN
	IF	FIRN
	JAL	R7,ENTLGS
	ELSE
	JAL	R7,ENTNSM
	EI	(FIRN)
	EI	(\FIRN)
	JR	R5
NLNS1Z					:ERASE LINE 1
	JAL	R6,PTLBH,,
	LA	R1,NNSE2,,		:ERASE LINE 1 AND RESET CURSOR
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	R5

NLNS1B					:PRT LOGOFF
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELETE OUTPUT LOGON DATA BB
	J	NLNS1E			:NOT SUPPORT YET

NLNS1C					:EXIT NSM MODE
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELETE OUTPUT LOGON DATA BB
	LIS	R0,D.ACTV
	TBT	R0,DCBLKS+DCBMOD,RDCB,
	JE	NLNS1D			:NO, CAN NOT EXIT NSM
	JAL	R6,PTLBH,,
	LA	R1,ERASCN,,		:ERASE THE SCREEN
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
:
:SEND FINISH LOGON TO THE LU_SVC_MGR
:
	LHI	R2,NSFNLG^8		:INFORM SNA.LU.SVC
	IF	VTISUP
	LB	R3,LUCTAB+LUCVTI,R11,	:GET VTI BYTE
	THI	R3,LUVTIF		:VTI FUNCTION?
	JEFS	NLNS1F			:JUMP IF NOT
	OHI	R2,NSFNDP		:INDICATE DSP
	EI
NLNS1F	LIS	R3,0
	JAL	R6,QDIFSN,,
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,FNLGFL,,		:SET FLAG
:	LHL	R0,LUCTAB+LUCT.N,R11,
:	SBT	R0,SNDFLG,,		:SEND FINIFH LOGON NEXT TIME
	JR	R5

NLNS1D					:DISPLAY "CRT NOT CONNECTED,
					: EXIT NOT ALLOWED"
	JAL	R6,PTLBH,,
	LA	R1,NNSE6,,		:ERROR MSG
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	R5
	
NLNS1E					:DISPLAY "FUNCTION NOT SUPPORTED"
	JAL	R6,PTLBH,,
	LA	R1,NNSE7,,		:ERROR MSG
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	R5
	
:	NLNS20:	LG SELECTION
:	------
NLNS20
	NHI	R0,SNDTIS		:SEE IF SINGLE SEGMENT
	JEFS	NLNS21			:YES, SKIP
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,0FF
NLNS21
	LIS	R6,0			:ASSUME ENGLISH
	LB	R0,LUCTAB+LUCDIF,R11,	:SEE IF ENGLISH OR JAPANESE
	NHI	R0,07
	CLHI	R0,4			:4 = KATAKANA, 5 = KANJI
	JLFS	NLNS2X			:SKIP
	LIS	R6,2			:ELSE, MUST BE JAPANESE
NLNS2X
	LHI	R0,$A80
	LB	R4,LOGSF1,R6,		:GET ROW #
	LB	R7,LOGSF1+1,R6,		:GET COLUMN #
	JAL	R6,SBADDR,,		:GET BBUF ADDR
	STH	R0,FLDADR,,
	LIS	R6,1
	STH	R6,FLDIND,,		:FIELD SERACH 1ST
	LR	RBBA,R3
	BBST	RBBA,DCBLKS+DCBLBA,R12,	:SET UP DCBLBA
	STB	R8,DCBLKS+DCBLLV,R12,	:SAVE DATA LENGTH IN DCBLLV
	JAL	R6,GETFB,,		:TO FIND THE DATA
	LR	R2,R2			:R2 = 1ST CHAR OF DATA
	JE	NLNS24			:NOT FIND, TO DISCARD DATA
	NHI	R2,0F			:BINARY INDEX
	SIS	R2,1			:ADJUST
	STB	R2,DCBLKS+DCBCRM,RDCB,	:TEMPORARY SAVE IN DCBCRM
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELETE OUTPUT ATA BB.
	LHL	R3,LUCTAB+LUCT.N,R11,
	LHI	R4,8
	MHR	R3,R4
	LHL	R4,PSTTBL+4,R3,		:R4 = PSDTBL OFFSET
	CLB	R2,PSTTBL+6,R3,		:WITHIN RANGE?
	JGE	NLNS22			:NO, TO DISPLAY ERROR MSG
	LHI	R3,PSTLEN
	LB	R2,DCBLKS+DCBCRM,RDCB,
	MHR	R2,R3			:R2 = OFFSET INTO PSDTBL
	LB	R0,PSEG+1,R2,R4		:R0 = MANUAL/PRESET MODE
	LR	R0,R0			:R0 = 0, MANUAL
	JE	NLNS1W			:MANUAL, SKIP
:	JE	NLNS22			:MANUAL, SKIP
	LIS	R0,D.STOR		:INDICATE THIS IS A STORED LOGON
	SBT	R0,DCBLKS+DCBMOD,R12,
	LHL	R0,PSEG+6,R2,R4		:R0 = LOGON STRING OFFSET
	BBST	R0,DCBLKS+DCBLBA,R12,	:SAVE INTO DCB
	LB	R0,PSEG+8,R2,R4		:R0 = LOGON STRING LEVEL
	STB	R0,DCBLKS+DCBLLV,R12,	:SAVE INTO DCB
	LIS	R0,0
	STB	R0,DCBLKS+DCBLLS,R12,	:INIT LEVEL
	STH	R0,DCBLKS+DCBLBX,R12,
	LA	R0,GETSC,,
	STH	R0,DCBLKS+DCBLGT,R12,
	JAL	R6,SNDM07		:SEND REQUEST FOR PSUEDO NEEDEL
	LIS	R0,L.PDNL
	STB	R0,DCBLKS+DCBSTA,R12,
	JAL	R6,PTLBH,,
	LA	R1,LEM3,,		:LOGIN IN PROGRESS
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	R5

NLNS22					:MANUAL LOGON/ILLEGAL
	JAL	R6,PTLBH,,
	LA	R1,NNSE1,,
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	R5			:RETURN TO OSCAN

NLNS24					:NO DESIRED DATA, DISCARD AND RE-TRY
	LR	R3,RBBA
	JAL	R6,DLODBB,,		:DELET OUTPUT DATA BB
	J	NLNS22			:TO DISPLAY ERROR MSG

:	NLNS30:	LOGON DATA
:	------
NLNS30
	BBST	R3,DCBLKS+DCBLBA,R12,
	STB	R8,DCBLKS+DCBLLV,R12,
	LA	R0,GETFB,,		:SET UP LOGON DATA GET ROUTINE
	STH	R0,DCBLKS+DCBLGT,R12,
	JAL	R6,SNDM07		:REQUEST PSEUDO NEEDLE
	LIS	R0,L.PDNL		:WAIT FOR PSEUDO NEEDLE
	STB	R0,DCBLKS+DCBSTA,R12,
	JAL	R6,PTLBH,,
	LA	R1,LEM3,,		:LOGIN IN PROGRESS
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	R5

:	NLNS40:	PSEUDO NEEDLE, DELETE
:	------
NLNS40
	J	NLNSB0			:TO DELETE LOGON DATA

:	NLNS50:	USER NAME, IF ERC SEND USER NAME
:	------
NLNS50
	BBST	R3,DCBLKS+DCBLBA,R12,
	STB	R8,DCBLKS+DCBLLV,R12,
	LA	R0,GETFB,,
	STH	R0,DCBLKS+DCBLGT,R12,
	JAL	R6,PTLBH,,
	LA	R1,LEM3,,		:LOGIN IN PROGRESS
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JAL	R6,SNDLFD,,
	LIS	R0,D.GATE		:IF GATEWAY LOGON DATA
	TBT	R0,DCBLKS+DCBMOD,RDCB,	:THEN, DISABLE ECHO
	JER	R5			:NOT GATEWAY,RETURN
:DELETE LOGON BUFFERLETS (02/17/87 MIA)
	BBL	R3,DCBLKS+DCBLBA,RDCB,	:GET POINTER TO LOGON BUFFER
	JEFS	NLNS51			:JUMP IF NONE
	JAL	R6,DLODBB,,		:RELEASE LOGON BUFFER
	XR	R3,R3			:CLEAR THE REGISTER
	BBST	R3,DCBLKS+DCBLBA,RDCB,	:UPDATE POINTER TO LOGON BUFFER
NLNS51	EQ	.
:END OF INSERTION (02/17/87 MIA)
	LHI	R0,FSHINP-PSEG
	STH	R0,DCBLKS+DCBINP,RDCB,
	JR	R5

:	NLNS60:	USERNAME SENT, DELETE
:	------
NLNS60
	J	NLNSB0			:TO DELETE LOGON DATA

:	NLNS70:	PSWD, IF ERC  SEND PASSWORD
:	------
NLNS70
	J	NLNS50			:SAME AS NLNS50

:	NLNS80:	PSWD SENT, DELETE
:	------
NLNS80
:	NLNS90:	LOGON STRING SENT, DELETE
:	------
NLNS90
:	NLNSA0:	DIALECT, DELETE
:	------
NLNSA0
:	NLNSB0:	TIIX, DELETE
:	------
NLNSB0
:	LR	R3,RBBA			:DELETE ANY DATA
	JAL	R6,DLODBB,,		:DELETE OUTPUT DATA
	JAL	R6,ISIEND		:END ANY ISIS INPUT
	JAL	R6,PTLBH,,
	LA	R1,LEM19,,		:INPUT STATE ERROR
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JAL	R6,RSTTRM		:AND ZAP CIRCUIT
	LHI	R0,L.ERCK
	STB	R0,DCBLKS+DCBSTA,RDCB,
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	JR	R5

:	NLNSC0:	DSP
:	------
NLNSC0
	NHI	R0,SNDTIS		:SEE IF SINGLE SEG DATA
	JEFS	NLNSC1			:YES, SKIP
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
NLNSC1
	BBST	R3,DCBLKS+DCBLBA,R12,
	STB	R8,DCBLKS+DCBLLV,R12,
	LA	R0,GETFB,,
	STH	R0,DCBLKS+DCBLGT,R12,
	JAL	R6,FETDSP,,		:TO FETCH DSP DATA(09/09/86/CHS)
	J	NLNSC2			:ERROR, RE-DISPLAY
	LHI	R0,DSPDIA		:RESPONSE DSP/SNA SELECTED
	STB	R0,RPDIAL,,
	LA	R9,RPDIAM-1,,		:SEND IIX "SELECTED DIALECT"
	JAL	R6,SNDIIX,,		:(09/09/86/CHS) RX3
	LA	R9,TURKMG-1,,		:AND TURKEY LEVEL
	JAL	R6,SNDIIX,,		:(09/09/86/CHS) RX3
	LHI	R0,L.TRKL		:UPDATE CKT STATE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	JAL	R6,PTLBH,,
	LA	R1,LEM14,,		:CONNECTION IN PROGRESS
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	BBL	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,
	JR	R5

NLNSC2					:RE-DISPLAY DSP SCREEN
	BBL	R3,DCBLKS+DCBLBA,RDCB,	:DELETE INPUT DATA
	JAL	R6,DLODBB,,
	JAL	R6,PTLBH,,
	LR	R1,R13			:DISPLAY ERROR MSG
	JAL	R6,PMLB,,
	LHI	R2,NSINTM^8!NSDTCD
	JAL	R6,QDIFSN,,
	JR	R5

:	NLNSD0:	DSP & ASC
:	------
:	NOT IMPLEMENTED, CRASH NOW
NLNSD0
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	NLNSE0:	TURKEY LEVEL, DELETE
:	------
NLNSE0
:	NLNSF0:	CALL ACCEPT, DELETE
:	------
NLNSF0
:	NLNSG0:	CIRCUIT ENABLE
:	------
NLNSG0
	J	NLNSB0

:	NLNSH0:	DSP IN ERROR STATE OR ABORT
:	-------
:	ANY KEY ALWAYS CLEAR DSP ERROR STATE, TO NSS
NLNSH0					:R3 = LOCAL INPUT DATA BB
	JAL	R6,DLODBB,,		:DELETE ANY LOGON DATA
	IF	\FIRN
	IF	FIRN
	JAL	R7,ENTLGS
	ELSE
	JAL	R7,ENTNSM
	EI	(FIRN)
	EI	(\FIRN)
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	JR	R5

:	NLNSI0:	GATEWAY LOGON
:	------
NLNSI0
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	NLOTER:	PROCESSING ERRORS
:	------
NLOTER
	JAL	R6,GTODTA,,
	LR	R7,R0
	LHL	R6,NLOTRR,R7,R7
	J	PSEG,R6,

NLOTRR	HC	NLOTE1-PSEG		:0 - REDISPLAY THE SCREEN
	HC	NLOTE2-PSEG		:1 - BIND FAILURE (POWER OFF)
	HC	NLOTE3-PSEG		:2 - BIND FAILURE
	HC	NLOTE4-PSEG		:3 - TIME OUT IN LU.SVC
	HC	NLOTE5-PSEG		:4 - UNABLE TO CONTINUE DUE TO LU/PU
	HC	NLOTE6-PSEG		:5 - UNABLE TO CONTINUE DUE TO INF/SNA
	HC	NLOTE7-PSEG		:6 - UNEXECUTABLE FOR LU.SVC

:	NLOTE1:	REDISPLAY THE SCREEN
:	------
NLOTE1
	LHL	R12,LUCTAB+LUCDCB,R11,
	J	NLOTL1			:ABORT (7/9/84/CHS)
	LB	R6,DCBLKS+DCBSTA,R12,
	LHL	R6,RTYTBL,R6,R6		:RE-DISPLAY TABLE
	J	PSEG,R6,		:TO RECOVER

RTYTBL
	HC	NLER00-PSEG		:00 - L.IDLE
	HC	NLER10-PSEG		:01 - L.NSMN
	HC	NLER20-PSEG		:02 - L.MENU
	HC	NLER30-PSEG		:03 - L.LSTR
	HC	NLER40-PSEG		:04 - L.PDNL
	HC	NLER50-PSEG		:05 - L.USER
	HC	NLER60-PSEG		:06 - L.USNT
	HC	NLER70-PSEG		:07 - L.PSWD
	HC	NLER80-PSEG		:08 - L.PSNT
	HC	NLER90-PSEG		:09 - L.LGOK
	HC	NLERA0-PSEG		:0A - L.DIAL
	HC	NLERB0-PSEG		:0B - L.TIIX
	HC	NLERC0-PSEG		:0C - L.LDSP
	HC	NLERD0-PSEG		:0D - L.DASC
	HC	NLERE0-PSEG		:0E - L.TRKL
	HC	NLERF0-PSEG		:0F - L.CACP
	HC	NLERG0-PSEG		:10 - L.CENA
	HC	NLERH0-PSEG		:11 - L.ERCK
	HC	NLERI0-PSEG		:12 - L.GTWY

:	NLER00:	IDLE STATE
:	------
NLER00
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	NLER10:	NSM SCREEN SENT
:	-------
NLER10
	JAL	R7,ENTNSM
	JR	R5

:	NLER20:	LOGON SELETION SEND
:	------
NLER20
	JAL	R6,SNDLGS,,
	JR	R5

:	NLER30:	MANUAL LOGON 
:	-----
NLER30
	J	NLNS16

:	NLER40/NLER50/NLER60/NLER70/NLER80:
:	------
:	PSEUDO NEEDEL WAIT, USER NAME WAIT, USER NAME SENT
:	PSWD WAIT, PSWD SENT
NLER40;NLER50;NLER60;NLER70;NLER80
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	NLER90:LOGON O.K.
:	------
NLER90
	J	GOCCRH

:	NLERA0:	DIALECT 
:	------
NLERA0
	J	GOCCRH

:	NLERB0:	TIIX
:	-----
NLERB0
	J	GOCCRH

:	NLERC0:	DSP
:	------
NLERC0
	J	GOCCRH

:	NLERD0:	DSP & ASC
:	------
NLERD0
	J	GOCCRH

:	NLERE0:	TURKEY LEVEL
:	------
NLERE0
	J	GOCCRH

:	NLERF0:	CALL ACCPET
:	------
NLERF0
	J	GOCCRH

:	NLERG0:	CIRCUIT ENABLE
:	------
NLERG0
	J	GOCCRH

:	NLERH0:	DSP ERROR STATE
:	------
NLERH0
	J	GOCCRH

:	NLERI0:	GATEWAY
:	------
NLERI0
	J	GOCCRH

:	NLOTE2:	BIND FAILURE (POWER OFF)
:	------
NLOTE2
:	JAL	R10,CRASH,,		:(7/9/84/CHS)
:	BC	0,0,0,0FF		:(7/9/84/CHS)

:	NLOTE3/NLOTE4/NLOTE5/NLOTE6/NLOTE7:	ERROR
:	----------------------------------
NLOTE3;NLOTE4;NLOTE5;NLOTE6;NLOTE7
:	JAL	R10,CRASH,,		:(7/9/84/CHS)
:	BC	0,0,0,0FF		:(7/9/84/CHS)
	JAL	R6,ZPTCKT
	JAL	R6,ZAPTLU,,
	JR	R5

:	NLOTPR:	PROCESSING POS RSP
:	------
NLOTPR
	JAL	R6,GTODTA,,
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	LR	R7,R0
	LHL	R6,NLOTRP,R7,R7
	J	PSEG,R6,

NLOTRP	HC	NLOTP0-PSEG		:0 - POS RSP TO ST LOGON
	HC	NLOTP1-PSEG		:1 - POS RSP TO FINI LOGON
	HC	NLOTP2-PSEG		:2 - POS ACK TO LOGON SCREEN

NLOTP0
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:
:POSITIVE RESPONSE TO FINISH LOGON AT LOGON MODE
:
NLOTP1
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,FNLGFL,,
	JER	R5			:IGNORE (03/01/85 MIA)
NLOTPX	LIS	R0,D.ACTV		:IF D.ACTV IN DCB MODE, ENTER PASS THRU
	TBT	R0,DCBLKS+DCBMOD,RDCB,	:ELSE, ENTER DETACH MODE
	JN	NLOTPY			:CIRCUIT THERE, ENTER PASS THRU MODE
	LHI	R0,DTTOSD-PSEG		:ELSE, ENTER DETACH MODE
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTTOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LHI	R0,L.IDLE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	JR	R5
:
NLOTPY	LHI	R0,NPTOSD-PSEG		:ENTER PASS THRU MODE
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,NPTOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
:
:GO INTO DSP STATE IF VTI IS SUPPORTED
:
	IF	VTISUP
	LB	R6,LUCTAB+LUCVTI,R11,	:GET VTI STATE BYTE
	THI	R6,LUVTIF		:VTI FUNCTION?
	JEFS	NLOTPU			:JUMP IF NOT
	LHI	R0,L.BDSP
	J	NLOTPV
	EI
:
NLOTPU	LB	R6,LUCTAB+LUCSYS,R11,	:SEE IF SNA/FNA OR HNA(03/10/86/CHS)
	LHI	R0,DEVEND		:SEND DEVEND TO HOST IF
	CLHI	R6,HITACHI		:HITACHI? (03/10/86/CHS)
	JNFS	NLOTPZ			:NO, SKIP
	LHI	R0,DVENDH		:ELSE, MUST BE HNA
NLOTPZ
	STB	R0,STSSB1,,		:(TO BE COMPATIBLE WITH BSC/DSP)
	EXBR	R0,R0
	STB	R0,STSSB0,,
	LA	R9,M.STAT-1,,
	JAL	R6,SNDIIX,,		:(09/09/86/CHS) RX3
	LHI	R0,L.NATV		:ENTER NATIVE MODE
NLOTPV	STB	R0,DCBLKS+DCBSTA,RDCB,
	JR	R5

:
:POSITIVE RESPONSE TO LOGON SCREEN ACK.
:
NLOTP2
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,SNDFLG,,
	JER	R5			:NO, ACTION NOW
:
	LHI	R2,NSFNLG^8		:INFORM SNA.LU.SVC
:
:	LIS	R8,0
:	IF	VTISUP
:	LB	R3,LUCTAB+LUCVTI,R11,	:GET VTI BYTE
:	THI	R3,LUVTIF		:VTI FUNCTION?
:	JEFS	NLOTP3			:JUMP IF NOT
:	OHI	R2,NSFNDP		:INDICATE DSP
:	LB	R8,DCBLKS+DCBNTY,R12,	:CONTINUE CONVERSATION OR START IT
:	LIS	R3,0			:CLEAR THE REGISTER
:	STB	R3,DCBLKS+DCBNTY,R12,	:RESET CONTINUE CONVERSATION
:NLOTP3	EQ	.
:	EI
	LIS	R3,0
	JAL	R6,QDIFSN,,
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,FNLGFL,,		:SET FLAG
	JR	R5


	EI	(TERMIF)

	SUBTTL	(SNA - NOSC) VHR LOGON MODE, OUTPUT SCAN PROCESSING

	IF	VHRSUP

:	GENERATE VHR LOGON MODE COMMAND PROCESSING TABLE
	GENSNC(RLOSCC)

	CHGSNC(RLOSCC,XINIT,NPOHIN)
	CHGSNC(RLOSCC,XCLOSE,NPOHCL)
	CHGSNC(RLOSCC,XDOWN,NPOHDN)
	CHGSNC(RLOSCC,XRESET,NPOHRS)

:	GENERATE VHR LOGON MODE DATA PROCESSING TABLE
	GENSND(RLOSCD)

	CHGSND(RLOSCD,SNETEM,RLOTPT)
	CHGSND(RLOSCD,SNINTM,RLOTLO)
	CHGSND(RLOSCD,SNRQLG,RLOTLG)
	CHGSND(RLOSCD,SNERR,RLOTER)
	CHGSND(RLOSCD,SNPOSR,RLOTPR)

:LOGON DATA.
RLOTPT	JAL	R6,GTODTA,,		:GET OUTPUT DATA
	LHL	R12,LUCTAB+LUCDCB,R11,	:GET DCB POINTER
	THI	R0,SNDTIS!SNDTIC	:CHECK IF THE WHOLE MSG
	JN	RLOTAS			:JUMP NO ASSEMBLE MSG IF NOT
	LB	R4,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	THI	R4,LUSVCP		:SVC BUIDING IN PROGRESS?
	JE	GOCCRH			:ERROR IF NOT
	THI	R4,LUPVCP		:PVC BUILDING IN PROGRESS?
	JN	RLOTPV			:JUMP IF SO
	LB	R6,DCBLKS+DCBSTA,R12,	:GET LOGON STATUS
	LHL	R6,RLOTLP,R6,R6		:GET PROCESSING ROUTINE
	J	PSEG,R6,		:JUMP TO PROCESS

:LOGON MODE PROCESSING ROUTINE TABLE FOR VHR.
RLOTLP	HC	GOCFLH-PSEG		:00 - INVALID
	HC	GOCFLH-PSEG		:01 - NS SELECTION, INVALID
	HC	GOCFLH-PSEG		:02 - LG SELECTION, INVALID
	HC	RLNS30-PSEG		:03 - LOGON DATA, REQUEST NEEDLE
	HC	GOCFLH-PSEG		:04 - PSEUDO NEEDLE, INVALID
	HC	RLNS50-PSEG		:05 - USERNAME
	HC	GOCFLH-PSEG		:06 - USER NAME SENT, INVLID
	HC	RLNS50-PSEG		:07 - PASSWORD, SAME AS USERNAME
	HC	GOCFLH-PSEG		:08 - PWRD SENT, INVALID
	HC	GOCFLH-PSEG		:09 - LOGON SENT, INVALID
	HC	GOCFLH-PSEG		:0A - DIALECT, INVALID
	HC	GOCFLH-PSEG		:0B - TIIX, INVLID
	HC	RLNSC0-PSEG		:0C - DSP INFORMATION
	HC	GOCFLH-PSEG		:0D - DSP&ASCII, INVALID
	HC	GOCFLH-PSEG		:0E - TURKEY, INVALID
	HC	GOCFLH-PSEG		:0F - CALL ACCEPT, INVALID
	HC	GOCFLH-PSEG		:10 - CIRCUIT ENABLE, INVALID
	HC	RLNS1E-PSEG		:11 - ERROR
	HC	GOCFLH-PSEG		:12 - GATEWAY, INVALID

:FIRST RU CHAIN WITH LOGON DATA. SEND REQUEST FOR PSEUDO NEEDLE,
:SAVE WCC CONTROL INFORMATION AND SET UP TO WAIT FOR PSEUDO NEEDLE.
RLNS30	BBST	R3,DCBLKS+DCBLBA,R12,	:SAVE HEAD TO BUFFER CHAIN
	STB	R8,DCBLKS+DCBLLV,R12,	:SAVE MSG LENGTH
	LA	R0,GETRFB,,		:PREPARE LOGON DATA FETCH ROUTINE
	STH	R0,DCBLKS+DCBLGT,R12,	:SAVE IT IN DCB
	LIS	R0,L.PDNL		:SET WAITING FOR PSEUDO NEEDLE
	STB	R0,DCBLKS+DCBSTA,R12,	:SAVE NEW STATE IN DCB
	LB	R4,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	LB	R0,BBUFER+FID2LN+RHLENG+VHRWCC,R3,	:GET WCC FROM DATA
	NHI	R0,VHRMSL		:GET MANUAL/PRE-STORED BIT
	OR	R4,R0			:PUT IT IN VHR STATE BYTE
	STB	R4,LUCTAB+LUCVHR,R11,	:SAVE VHR STATE IN LUCB
	LHI	R0,FID2LN+RHLENG+1	:PREPARE TO FETCH FIRST BYTE OF USNM
	STH	R0,DCBLKS+DCBLBX,R12,	:SAVE IT IN DCB
	JAL	R6,SNDM07		:SEND REQUEST FOR PSEUDO NEEDLE
	JAL	R6,SINPBB,,		:GET BUFFER FOR REPLY RU
	JAL	R6,SINVHR,,		:INIT IT FOR VHR
	JR	R5			:AND RETURN

:USERNAME.
RLNS50	BBST	R3,DCBLKS+DCBLBA,R12,	:SAVE HEAD TO BUFFER CHAIN
	STB	R8,DCBLKS+DCBLLV,R12,	:SAVE MSG LENGTH
	LA	R0,GETRFB,,		:PREPARE LOGON DATA FETCH ROUTINE
	STH	R0,DCBLKS+DCBLGT,R12,	:SAVE IT IN DCB
	LHI	R0,FID2LN+RHLENG+1	:PREPARE TO FETCH FIRST BYTE OF USNM
	STH	R0,DCBLKS+DCBLBX,R12,	:SAVE IT IN DCB
	JAL	R6,SNDLFD,,		:SEND USERNAME
	JAL	R6,SINPBB,,		:GET BUFFER FOR REPLY RU
	JAL	R6,SINVHR,,		:INIT IT FOR VHR
	LIS	R0,D.GATE		:IF GATEWAY
	TBT	R0,DCBLKS+DCBMOD,RDCB,	:LOGON DATA FOR GATEWAY?
	JER	R5			:RETURN IF NOT
	LHI	R0,FSHINP-PSEG		:OTHERWISE
	STH	R0,DCBLKS+DCBINP,RDCB,	:DISABLE ECHO
	JR	R5			:AND RETURN

:DSP INFORMATION
RLNSC0	BBST	R3,DCBLKS+DCBLBA,R12,	:SAVE HEAD TO BUFFER CHAIN
	STB	R8,DCBLKS+DCBLLV,R12,	:SAVE MSG LENGTH
	LHI	R0,FID2LN+RHLENG+1	:PREPARE TO FETCH FIRST BYTE OF DSP
	STH	R0,DCBLKS+DCBLBX,R12,	:SAVE IT IN DCB
	JAL	R6,SINPBB,,		:GET BUFFER FOR REPLY RU
	JAL	R6,SINVHR,,		:INIT IT FOR VHR
	JAL	R6,FETDSP,,		:FETCH DSP INFORMATION(09/09/86/CHS) RX3
	J	RLNSCE			:JUMP IF DSP ERROR
	JAL	R8,VHRTUR		:OTHERWISE SEND DIAL RSP AND TURKEY
	JR	R5			:END RETURN

:WRONG DSP INFORMATION.
:RELEASE BUFFERS WITH VTR LOGON INFORMATION.
RLNSCE	BBL	R3,DCBLKS+DCBLBA,RDCB,	:GET POINTER TO LOGON BUFFERS
	JEFS	RLNSC1			:JUMP IF NONE
	JAL	R6,DLODBB,,		:RELASE LOGON BUFFERS
	XR	R3,R3			:CLEAR THE REGISTER
	BBST	R3,DCBLKS+DCBLBA,RDCB,	:UPDATE LOGON POINTER

:FILL IN CADR1 AND CADR2 AND SEND LOGON REPLY RU TO VTR. THIS CODE ASSUMES
:THAT REPLY RU IS 1 SEGMENT 1 ELEMENT CHAIN. IF NOT THIS CODE SHOULD BE
:CHANGED LATER.
RLNSC1	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET  POINTER TO PREPARED REPLY
	LHI	R6,SP.			:PREPARE LOGON COMPLETED
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA1,R3,	:FILL CADR1
	LIS	R6,VHRCDR		:PREPARE CADR2(CD)
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:FILL CADR2
	LHI	R6,VHREDP		:PREPARE DSP ERROR CODE FOR VTR
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCDE,R3,	:CLEAR ERROR CODE
	XR	R6,R6			:CLEAR THE REGISTER
	BBST	R6,DCBLKS+DCBIBH,RDCB,	:UPDATE REPLY POINTER
	LHL	R8,DCBLKS+DCBALU,RDCB,	:GET MESSAGE LENGTH
	LHL	R6,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R6,LUCTAB+LUCVHR,R6,	:GET VHR STATE BYTE
	THI	R6,LUMNLG		:MANUAL LOGON FOR VTR?
	JE	RLNSCR			:JUMP IF NOT
	LHI	R6,L.LDSP		:IF PRESTORED LOGON MAKE THE ERROR (05/05/86 YLH)
	STB	R6,DCBLKS+DCBSTA,RDCB,	:UNRECOVERABLE (05/05/86 YLH)
	CLHI	RBCC,FID2LN+RHLENG+VHRCA2+1	:ANYTHING ALEARDY THERE?
	JGFS	RLNSC2			:JUMP IF THERE IS
	JAL	R6,PTVHRH,,		:PUT 3270 WRITE HEADER
	AIS	RBCC,7			:LEHGTH OF 3270 WRITE HEADER
RLNSC2	LR	R1,R13			:COPY POINTER TO ERROR MSG
	LHL	R13,0,R1		:LENGTH OF ERROR MSG
	AR	R13,RBCC		:LENGTH AFTER THE ERROR MSG
	CLH	R13,DCBLKS+DCBRUL,RDCB, :TOO MANY CHARARACTERS?
	JG	RLNSCR			:JUMP IF SO
	LR	RBCC,R13		:OTHERWISE NEW RU LENGTH
	JAL	R6,PTLBS,,		:PUT ERROR MSG IN BUFFER
	JFS	RLNSC3			: (05/05/86 YLH)
RLNSCR	LHI	R6,L.ERCK		:IF PRESTORED LOGON MAKE THE ERROR (05/05/86 YLH)
	STB	R6,DCBLKS+DCBSTA,RDCB,	:UNRECOVERABLE (05/05/86 YLH)
RLNSC3	LHI	R2,NSETEM^8!NSDTCD	:ASSUME SINGLE SEG, SINGLE RU CHAIN
	JAL	R6,QDIFSN,,		:SEND IT TO SNA
	JR	R5			:AND RETURN

:DATA MESSAGE RECEIVED FROM VTR AFTER UNRECOVERABLE ERROR. ZAP CIRCUIT AND
:INFORM SNA TO CLEAR SESSION (VTR IS SUPPOSED TO UNBIND ITSELF WITHOUT
:VHR FORING IT).
RLNS1E	LIS	R0,0			:CLEAR REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,
	JAL	R6,RLOGBB,,		:DELETE LOGON BUFFERLETS
	JAL	R6,ISIEND		:CLEAN UP ANY INPUT
	GL	ZPHCKT,ZAPHLU
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	JAL	R6,ZAPHLU,,		:VHR LOOKS TO SNA AS HOSTIF(09/09/86/CHS) RX3
	JAL	R6,ZPHCKT,,		:VHR LOOKS TO NETWORK AS TERMIF
	LHI	R6,LUVHRF		:PREPARE TO CLEAN VHR STATE
	STB	R6,LUCTAB+LUCVHR,R11,	:UPDATE VHR STATE BYTE
	JR	R5			:AND RETURN

:LOGON/LOGOFF REQUEST FROM SNA IN LOGON MODE. TEMPORARY CRASH IF LOGON
:REQUEST (MAY HAPPEN FOR PVC SUPPORT). PROCESS IF LOGOFF REQUEST.
RLOTLG	JAL	R6,GTODTA,,		:GET COMMAND FROM SNA
	CLHI	R0,SNRQUB		:LOGOFF REQUEST?
	JN	GOCCRH			:CRASH IF NOT
RLOTL1	JAL	R6,ZPHCKT,,		:ZAP CIRCUIT
	JAL	R6,DTHUBR,,		:UNBIND RESPONSE TO SNA
	LHI	R6,DTHOSD-PSEG		:PREPARE DETACH ROUTINE FOR DATA Q
	STH	R6,LUCTAB+LUODPR,R11,	:SAVE IT IN LUCB
	LHI	R6,DTHOSC-PSEG		:DETACH MODE ROUTINE FOR CMD Q
	STH	R6,LUCTAB+LUOCPR,R11,	:SAVE IT IN LUCB
	LHI	R6,LUVHRF		:PREPARE TO CLEAN VHR STATE
	STB	R6,LUCTAB+LUCVHR,R11,	:UPDATE VHR STATE BYTE
	JR	R5			:AND RETURN
	
RLOTAS					:MESSAGE ASSEMBLY, TEMPORARY CRASH
RLOTPV					:PVC IN PROGRESS, TEMPORARY CRASH
RLOTLO
RLOTER
RLOTPR	EQ	.
	J	GOCCRH

	EI	(VHRSUP)

	FO	CBKDEF

	EM

	SUBTTL	MISCELLANEOUS ROUTINES FOR TIMEOUT HANDLER
:	MUDULE NAME IN COMMAND FILE -- DHTO00.F00

:	*******************************************
:	REVISION HISTORY --
:	05/24/84 (NCS) - ORIGINAL DESIGN AND CODE
:	*******************************************

	RA	0
	MO	.,SMISCL

	LO	MAIN
	LO	GBLDEF
	LO	GIIX
	LO	GDSP
	LO	BSUB
	LO	CBKDEF
	LO	ISISC
	LO	FRNTND
	LO	OSCAN

	IF	HOSTIF			:(01/18/85 MIA)
	SEG	A.DATA
IT6SAV	WS	1			:SAVE REG 6 FOR IDLE TIMEOUT

	SEG	A.CODE

:	DHIATV	:INACTIVE TIMEOUT ROUTINE
:	------
DHIATV
	JAL	R6,DSHZAP,,		:ZAP CKT FOR INACTIVE DEVICE
	JR	R5			:RETURN

DSHZAP
	ST	R6,IT6SAV,,
	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE ISIS CONTROL CODE
:	LB	R0,DCBLKS+DCBSTA,RDCB,	:IF NOT E-T-T, NOT TELL SNA(11/12/85/CHS)
:	CLHI	R0,L.BDSP		:(11/12/85/CHS)
:	JNFS	DSHZA1			:SKIP(11/12/85/CHS)
	GL	ZAPHLU
	JAL	R6,ZAPHLU,,		:ELSE, TELL SNA TO RECOVERY
DSHZA1
	LH	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
:	JLEFS	DSHZA2			:IF NO LUC, SKIP (01/27/87 YLH)
	JLE	DSHZA2			:IF NO LUC, SKIP (01/27/87 YLH)
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:ELSE DISCONNECT LUC/DCB
	LIS	R0,0
	STH	R0,LUCTAB+LUCDCB,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,BDPETE,,		:RESET BSC DSP ETE MODE
	RBT	R0,BDPDLU,,		:RESET BSC DSP APPLICATION LOGOFF
DSHZA2
	JAL	R6,DSCHPR		:DISCONNECT HOST PORT
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	NHI	R7,LUVHRF		:VHR FUNCTION?
	JEFS	DSHZAA			:JUMP IF SO
	STB	R7,LUCTAB+LUCVHR,R11,	:UPDATE VHR STATE BYTE
	JFS	DSHZAB			:JUMP TO CONTINUE
	EI
DSHZAA	LHL	R7,DCBLKS+DCBHST,RDCB,	:R7 = HOSTAB OFFSET
	JAL	R6,ZAPHST		:RELEASE HOST PORT
DSHZAB	JAL	R6,RELDCB,,		:RELEASE DCB
	L	R6,IT6SAV,,
	JR	R6

:	DHLFTV	:APPLICATION LOGOFF TIMEOUT
:	------
DHLFTV
	LHL	R6,LUCTAB+LUCT.N,R11,	:GET RELATIVE LU #
	RBT	R6,BDPDLU,,		:RESET BIT ARRAY
	LB	R6,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	CLHI	R6,PL.ACT		:IS LU BACK TO ACTIVE?
	JE	DHLFT1			:YES,JUMP
	JAL	R6,DSCHPR		:DISCONNECT ISIS PORT
	LHL	R7,DCBLKS+DCBHST,RDCB,	:SET UP R7 = HOST OFFSET
	JAL	R6,ZAPHST		:RELEASE HOST PORT
	JAL	R6,RLSHST		:RELEASE HSTPRT AND HSTFPT
	JAL	R6,RELDCB,,		:RELEASE DCB
	LHI	R0,DTHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LIS	R0,PL.RST
	STB	R0,LUCTAB+LUPSTA,R11,
	LIS	R0,0			:DETACH DCB AND LUC
	STH	R0,LUCTAB+LUCDCB,R11,
	JR	R5
DHLFT1
	LHI	R2,NSFNLG^8		:INFORM LU.SVC
	IF	HDPSUP			:(9/5/84, MIA)
	LIS	R0,D.BDSP		:POINT TO DSP/NATIVE BIT (9/5/84,MIA)
	TBT	R0,DCBLKS+DCBMOD,RDCB,	:DSP MODE? (9/5/84, MIA)
	JEFS	DHLFT2			:JUMP IF NATIVE (9/5/84, MIA)
	OHI	R2,NSFNDP		:SETUP SUBCMD TO DSP MODE
	EI				:(9/5/84, MIA)
DHLFT2	LIS	R3,0
	LIS	R8,0
:	JAL	R6,QDIFSN
:: 9/5/84, MIA
:: FINISH LOGON MUST BE QUEUED IN THE HEAD OF CMD LIST (LIFO).
:: DATA MESSAGES WHICH COULD COME FROM THE TERMINAL DURING APPLICATION
:: TIMEOUT WHERE RETAINED IN THE DATA QUEUE BY SNA LU SERVICE MANAGER.
	LO	CMDLST			:(9/5/84, MIA)
	JAL	R4,GETCL,,		:GET CMD LINK (9/5/84, MIA)
	J	PUTCR,,			:JUMP IF NONE AVAILABLE (9/5/84,MIA)
	LHL	R4,LUCTAB+LUSNDG,R11,	:GET CURRENT GET POINTER (9/5/84,MIA)
	STH	R6,LUCTAB+LUSNDG,R11,	:REPLACE IT BY NEW PTR (9/5/84, MIA)
	STH	R4,CMDBLK+CLPTR,R6,	:CHAIN OLD LINK TO NEW (9/5/84, MIA)
	STH	R2,CMDBLK+CLCMD,R6,	:PUT COMMAND CODE (9/5/84, MIA)
	STH	R8,CMDBLK+CLLNG,R6,	:PUT LENGTH IN THE LINK (9/5/84,MIA)
	BBST	R3,CMDBLK+CLARG,R6,	:PUT BUFFER POINTER (9/5/84, MIA)
	FO	CMDLST			:(9/5/84, MIA)
	LHL	R0,LUCTAB+LUCT.N,R11,
	SBT	R0,DPNWSN,,		:SHOW DATA PRESENT (9/5/84, MIA)
	SBT	R0,FNLGFL,,
	JR	R5

	EI	(HOSTIF)		:(01/18/85 MIA)

	FO	MAIN
	FO	GBLDEF
	FO	GIIX
	FO	GDSP
	FO	BSUB
	FO	CBKDEF
	FO	ISISC
	FO	FRNTND
	FO	OSCAN

	EM

   
	SUBTTL	SNA/HDSP UTILITY ROUTINES PACKSGE
:	MUDULE NAME IN COMMAND FILE -- DHRT00.F00

:	*******************************************
:	REVISION HISTORY --
:	05/24/84 (NCS) - ORIGINAL DESIGN AND CODE
:	*******************************************

:	THIS MODULE IS DESIGNED TO SUPPORT SNA/HOST DSP INTERFACE
:	COMMON UTILITY ROUTINES
:	-----------------------------------------------------------

	RA	0
	MO	.,SHDPKG

	LO	MAIN
	LO	GBLDEF

:	IF	(HOSTIF&HDPSUP)	:(3.F00/10/14/87/DB)

	SEG	A.DATA
 
	 RA	0

 
:	CONSTANTS
:	=========
STATMK	EQ	5F5F		:MASK FOR STATUS HWORD
				:( SETS BITS 0,1,8,9 TO ZERO)
IRSTAT	EQ	4050		:INTERVENTION REQUIRED STATUS
COPSTA	EQ	40D1		:COPY UNSUCCESSFUL STATUS
				:( FROM DEVICE UNAVAIL. )
DBSTAT	EQ	0C840		:DEVICE BUSY STATUS
OPCHK	EQ	40C1		:OPERATION CHECK STATUS
PSBIT	EQ	8		:PRINTER START BIT IN WCC
DQTE.	EQ	7F		:EBCDIC DOUBLE QUOTE
EWACMD	EQ	7E		:ERASE/WRITE ALTERNATE CMD
WCMD	EQ	0F1		:WRITE CMD
EWCMD	EQ	0F5		:ERASE/WRITE CMD
RBCMD	EQ	0F2		:READ BUFFER CMD
WSFCMD	EQ	0F3		:WRITE STRUCTURE FIELD CMD
RMCMD	EQ	0F6		:READ MODIFIED CMD
CPCMD	EQ	0F7		:COPY CMD
EAUCMD	EQ	06F		:ERASE ALL UNPROTECTED CMD
PERC.	EQ	6C		:PER CENT SIGN
ESC.	EQ	27		:ESCAPE
R.	EQ	0D9		:LETTER R
 
 
:	ERROR TYPE CODES (MESSAGE ID, ERROR CODE)
:	================
:
:	COMMAND/RESPONSE UNDELIVERED (MESSAGE ID = 10)
:	---------------------------------------
XMTEOT	EQ	1001		:GOT EOT TO OUR XMT
XMTRVI	EQ	1002		:GOT RVI TO OUR SELECT (TI)
XMTFF	EQ	1003		:DETECTED FACILITIES FAILURE
XMTTO	EQ	1004		:REPEATED TIMEOUT IN RESPONSE TO OUR XMTS
XMTNAK	EQ	1005		:REPEATED NAKS TO OUR XMTS 
XMTWAK	EQ	1006		:REPEATED WACKS TO OUR XMTS (SELECTS FOR TI)
XMTINV	EQ	1008		:INVALID MESSAGE FORMAT
XMTUR	EQ	1009		:UNRECOGNIZABLE RESPONSE FROM REMOTE
:	COMMAND/RESPONSE ABORTED (MESSAGE ID = 11)
:	-----------------------------------------
RCVFF	EQ	1103		:FACILITIES FAILURE
RCVTO	EQ	1104		:TIMEOUT
RCVNAK	EQ	1105		:N NAKS SENT
RCVSTE	EQ	110A		:GOT REPEATED DATA ABORT (STX...SUB...ENQ)
RCVERR	EQ	0100		:TEST BIT INDICATING A "RCV" TYPE ERROR

	IF	(HOSTIF&HDPSUP)	:(3.F00/10/14/87/DB)

	BND	2
TB.BSC	
	BC	ETX,ETB,ENQ,ITB
TB.BSL	EQ	.-TB.BSC

	SEG	A.CODE
:	THIS ROUTINE IS USED TO SUPPORT BSC TRAILER SEARCH
:	-----------------------------------------------------------
:	INPUT	-R0 (BSC TRAILER)
:	LINK	-R4
:	OUTPUT	-R3 (INDEX TO TB.BSC)
R.BSSH
	LHI	R3,TB.BSL-1
R.BSS1
	CLB	R0,TB.BSC,R3,		:CHECK CURRENT SC RQ_CODE TO TABLE
	JER	R4			:YES,RETURN
	SIS	R3,1
	JGEBS	R.BSS1
	LHI	R3,TB.BSL
	JR	R4			:RETURN


	EI	(HOSTIF&HDPSUP)

	FO	MAIN
	FO	GBLDEF

	EM

   
	SUBTTL	SNA/HDSP NETWORK I/O HANDLER
:	MUDULE NAME IN COMMAND FILE -- DHIO00.F00

:	*******************************************
:	REVISION HISTORY --
:	05/24/84 (NCS) - ORIGINAL DESIGN AND CODE
:	*******************************************

:	THIS MODULE IS DESIGNED TO SUPPORT SNA/HOST DSP INTERFACE
:	NETWORK INPUT/OUTPUT SUPPORTING FUNCTIONS
:	-----------------------------------------------------------

	RA	0
	MO	.,SHDPKG

	LO	MAIN
	LO	GBLDEF
	LO	GIIX
	LO	GDSP
	LO	BSUB
	LO	CBKDEF
	LO	ISISC
	LO	FRNTND
	LO	SMISCL

:	BIT DEFINITION FOR DSP HEADER CONTROL BYTE
:	------------------------------------------
FIRBIT	EQ	01			:FIRST SEGMENT INDICATOR IN UCN
ETXBIT	EQ	04			:PREVIOUS ETX RCVED IND.
KBRBIT	EQ	02			:KEYBOARD RESTORE IN WCC
:CDRBIT	EQ	01			:CHANGE DIRECT (10/04/86 MIA)
CDRBIT EQ	08			:CHANGE DIRECT (10/04/86 MIA)
TRQBIT	EQ	10			:TEST REQUEST BIT FROM DSP
XPRBIT	EQ	20			:TRANSPARENT STATE FROM DSP
ACKBIT	EQ	40			:E-T-E ACK STATE
LCMBIT	EQ	80			:LIMITED CONVERSION MODE

:	BIT DEFINITION FOR SNA HEADER INPUT STATE
:	-----------------------------------------
DSHSEG	EQ	01			:SEGMENT STATE (0=FIRST,1=NON-FIRST)
DSHCHN	EQ	02			:CHAINING STATE (0=FIRST,1=NON-FIRST)
DSHCEL	EQ	04			:CANCEL STATE(DSP END WITH ENQ)
DSHDRU	EQ	08			:DUMMY RU NEEDED
DSHCNT	EQ	10			:CONTINUATION TO FOLLOW
DSHWRT	EQ	20			:3270 CMD TO FOLLOW
DSHKBR	EQ	40			:WCC TO FOLLOW
DSHMBY	EQ	80			:CONTINUATION PACKET (12/4/86 MIA)

:	BYTES REQUIRED IN DCB FOR SNA HOST DSP
:	--------------------------------------
:DCBOCT	BS	1			:BYTE FOR OUTPUT DSP HEADER INF.
					:BIT 5,6,7 -- DSP-TRAILER
					:BIT 5,6,7 --1=ETB,2=ETX,3=ITB,4=ENQ
					:BIT 4     -- END-DSP
					:BIT 3     -- SUB-DSP
					:BIT 2     -- FIRST-DSP
					:BIT 1     -- M-BIT FLAG
DSHETB	EQ	1			:ETB FOR DSP-TRAILER
DSHETX	EQ	2			:ETX FOR DSP-TRAILER
DSHITB	EQ	3			:ITB FOR DSP-TRAILER
DSHENQ	EQ	4			:ENQ FOR DSP-TRAILER
DSHTRA	EQ	07			:BIT 5,6,7 MASK FOR DSP-TRAILER
DSHEDP	EQ	08			:BIT 4,MASK FOR END-DSP
DSHSDP	EQ	10			:BIT 3,MASK FOR SUB-DSP
DSH1DP	EQ	20			:BIT 2,MASK FOR FIRST-DSP
DSHMBT	EQ	40			:BIT 1,MASK FOR MBIT
:DCBICT	BS	1			:BYTE FOR INPUT (DSP->SNA) HEADER INF.
:DCBTSG	BS	1			:BYTE FOR TEMP-SYSGEN (ETB,ETX,ITB)
					:0=ETX ONLY,1=ETX AND ETB
					:2=ETX,ETB AND ITB
ETXBIY	EQ	2			:ETX,ETB AND ITB FOR DSP-TRAILER
ETXBYY	EQ	1			:ETX AND ETB ONLY
ETXYYY	EQ	0			:ETX ONLY
:DCBDSH	BS	1			:BYTE FOR SNA STATE INF.

RSPMSS	EQ	101			:MAX DSP RSP LGT (11/5/84 MIA)

:READ MODIFIED ALL IS NOT IMPLEMENTED ON SOME OF 3270 CU'S.
:THE CODE ASSEMBLED WITH RMDALL SWITCH EMULATED RMA OPERATION BY
:SENDING READ BUFFER TO CU INSTEAD OF RMA AND THEN RECONSTRUCTING RMA
:OPERATION FROM READ BUFFER INPUT. THIS SWITCH WILL BE TURNED OFF IF
:RMA EMULATION IS IMPEMENTED AT TERMINAL INTERFACES (01/28/85 MIA).

	IF	RMDALL

:DCB FIELDS USED FOR RMA EMULATION
:DCBLBX	HS				:MESSAGE CHARACTER COUNT
:DCBLLV	BS				:BIT FLAGS/STATUS
:DCBLLS	BS				:COPY COUNT
:DCBLGT	HS				:SCREEN ADDRESS

:STRUCTURE OF DCBLLV
RMDAON	EQ	80			:RMA OUTSTANDING FROM HOST
RMDASK	EQ	40			:SKIP THE FIELD
RMDAFP	EQ	20			:FIRST CHAR OF PAIR
RMDAFN	EQ	10			:NEXT CHAR - FIELD ATTRIBUTE
RMDAST	EQ	0F			:STATE BITS

:RMA EMULATION STATES
RMDACS	EQ	0			:COPY DCBLLS CHARS
RMDANS	EQ	1			:REGULAR CHARACTER OF FIELD
RMDAFS	EQ	2			:START FIELD FOUND
RMDAES	EQ	3			:START FIELD EXTENDED FOUND
RMDAPS	EQ	4			:ATTRIBUTE PAIR

:MISCELENEOUS CONSTANTS
RMDAFA	EQ	0C0			:FIELD ATTRIBUTE FOR SFE
RMDAMT	EQ	01			:MODIFIED DATA TAG ATTRIBUTE

:THERE IS A CHANCE THAT AFTER RMA WAS REPLACED BY RB THE NEXT MESSAGE
:FROM TIF IS NOT THE RESPONSE FOR RB. THE TERMINAL OPERATOR MIGHT HAVE
:RESET THE KEYBOARD MANUALLY. THIS CODE WILL THINK THAT THIS WAS THE CASE
:IF THE RESPONSE MESSAGE IS SHORTER THAN CERTAIN MINIMUM (RMDAMN).
RMDAMN	EQ	80			:MINIMUM LENGTH OF RB RESPONSE
	EI

	SEG	A.CODE

	SUBTTL	(SNA-GIIX) ACTIVE DSP MODE IIX PROCESSOR

:	GENERATE ACTIVE DSP MODE IIX PROCESSING TABLE
:	=============================================

	IF	HOSTIF&HDPSUP

:	DIALECT IIX TABLE FORE ACTIVE DSP MODE
	GENDIX(DDHACT)
	CHGDIX(DDHACT,DATAPK,AHD94M)
	CHGDIX(DDHACT,CLRIND,ADH95M)




:	AHD94M:	DATA PACKET
:	------
AHD94M
	J	AHDINP			:TO PROCESS DATA DIALECT

:	AHD95M:	CLEAR INDICATION
:	-----
AHD95M
	LHI	R0,$A3			:'DROPPED BY USER" REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,	:FOR DISCONNECT MSG
	J	CLRCIR			:TO CLEAR CIRCUIT

	EI	(HOSTIF&HDPSUP)

	SUBTTL	(BSC-GDSP) BSC/DSP PROCESSES
:
:	GENERATE 'BSC/DSP' MESSAGES PROCESSING TABLE
:
	IF	(HOSTIF)&(HDPSUP)

	GENDSP(BSHDSP)			:BSC/DSP PROCESS TABLE

	CHGDSP(BSHDSP,DSPI01,DDHIVC)	:01 - INVITATIONTO CLEAR
	CHGDSP(BSHDSP,DSPI10,DDHUND)	:10 - CMD/RSP UNDELIVERED
	CHGDSP(BSHDSP,DSPI11,DDHABT)	:11 - CMD/RSP ABORTED
	CHGDSP(BSHDSP,DSPI12,DDHSTT)	:12 - STATUS MSG
	CHGDSP(BSHDSP,DSPI14,DDHACK)	:14 - ACK MESSAGE




:	DDHIVC:	INVITATION TO CLEAR
:	------
DDHIVC
	LHI	R4,DDHIV1-PSEG		:TO READ REASON BYTE
	JR	R5
DDHIV1					:R0 = REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,
	GL	ZPHCKT,ZAPHLU
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	CI	R11,0FFFF		:DEVICE WAS ATTACHED? (10/01/86 YLH)
	JE	DDHIV2			:NO, SKIP (10/01/86 YLH)
:	JE	DDHIV2			:SKIP, NI LU YET
	JAL	R6,ZPHCKT,,
	JAL	R6,ZAPHLU
	J	IXENDN,,
DDHIV2					:(03/27/86/CHS)
	GL	ZAPHST,DSCHPR
	JAL	R6,DSCHPR,,		:DISCONNECT HOST PORT
	LHL	R7,DCBLKS+DCBHST,RDCB,
	JAL	R6,ZAPHST,,
	JAL	R6,RELDCB,,
	J	IXENDN,,

:	DDHUND:	CMD/RSP UNDELIVERED
:	------
DDHUND
	J	NDUNDL			:JUMP (TEMPORARY!!)

:	DDHABT:	CMD/RSP ABORTED
:	------
DDHABT
	J	NDABRT			:JUMP (TEMPORARY!!)

:	DDHSTT:	STATUS MESSAGE
:	------
DDHSTT
	LB	R0,DCBLKS+DCBSTA,RDCB,	:IN RIGHT STATE?
	CLHI	R0,L.BDSP		:IS IT IN BSC.DSP MODE?
	JE	DDHST3			:JUMP,IF YES
	CLHI	R0,L.STAT
	JN	CLRCIR			:NO, TO CLEAR CIRCUIT
	LHI	R4,DDHST1-PSEG		:TO READ NEXT BYTE
	JR	R5			:TO GISDI1 TO READ NEXT BYTE
DDHST1					:R0 = S/S BYTE 0
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:(03/10/86/CHS)
	LB	R4,LUCTAB+LUCSYS,R11,	:SEE IF SNA/FNA OR HNA
	LHI	R6,(DEVEND^-8)&0FF	:ASSUME SNA/FNA
	CLHI	R4,HITACHI		:...
	JNFS	DDHSTX			:HIT, SKIP
	LHI	R6,(DVENDH^-8)&0FF	:ELSE, MUST BE HNA
DDHSTX
	CR	R0,R6			:DEVICE END? (03/10/86/CHS)
:	CLHI	R0,(DEVEND^-8)&0FF	:DEVICE END?(03/10/86/CHS)
	JN	CLRCIR			:NO, TO CLEAR CIRCUIT
	LHI	R4,DDHST2-PSEG		:TO READ NEXT BYTE
	JR	R5			:TO GISDI1
DDHST2					:R0 = S/S BYTE 1
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:(03/10/86/CHS)
	LB	R4,LUCTAB+LUCSYS,R11,	:SEE IF SNA/FNA OR HNA
	LHI	R6,DEVEND&0FF		:ASSUME SNA/FNA
	CLHI	R4,HITACHI		:...
	JNFS	DDHSTY			:HIT, SKIP
	LHI	R6,DVENDH&0FF		:ELSE, MUST BE HNA
DDHSTY
	CR	R0,R6			:DEVICE END? (03/10/86/CHS)
:	CLHI	R0,DEVEND&0FF		:DEVICE END?(03/10/86/CHS)
	JN	CLRCIR			:NO, TO CLEAR CIRCUIT
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCB PTR (06/04/05 MIA)
	JE	IXENDN,,			:IGNORE, NO PTR (06/04/85 MIA)
	LB	R0,LUCTAB+LUSSTA,R11,	:GET LU STATE (06/04/85 MIA)
	CHI	R0,NN.ALU		:ACTIVE? (06/04/85 MIA)
	JN	IXENDN,,			:IGNORE IF NOT (06/04/85 MIA)
	LHI	R0,L.BDSP		:ENTER BSC/DSP MODE
	STB	R0,DCBLKS+DCBSTA,RDCB,
	XR	R0,R0			:CLEAR THE REGISTER (11/5/84 MIA)
	STH	R0,DCBLKS+DCBRUS,RDCB,	:CLEAR RU LENGTH (11/5/84 MIA)
	IF	RMDALL
	STB	R0,DCBLKS+DCBLLV,RDCB,	:CLEAR RMA STATE BYTE (02/11/85 MIA)
	EI
	LHI	R0,ETXBIT		:SET PREVIOUS END WITH ETX
	STB	R0,DCBLKS+DCBICT,RDCB,	:SAVE IN DCB
	LHI	R2,NSFNLG^8		:INFORM LU.SVC
	OHI	R2,NSFNDP		:SETUP SUBCMD TO DSP MODE
	LIS	R3,0
	LIS	R8,0
:	LHL	R11,DCBLKS+DCBLUC,RDCB,	:(06/04/85 MIA)
	JAL	R6,QDIFSN,,
:IF TIMEOUT BY PHYSICAL TERMINAL IS USED THE TIMEOUT VALUE COULD BE
:OVERRIDDEN BY APPLICATION ID (01/15/85 MIA).
	IF	PHTIMO
	LB	R6,DCBLKS+DCBAPI,RDCB,	:GET APPLICATION ID
	JNFS	DDHSTA			:JUMP IF NO OVERRIDE
	LIS	R0,0			:OVERRIDE TIMEOUT
	JFS	DDHSTB			:JUMP TO CONTINUE
DDHSTA	EQ	.
	EI
	LHL	R0,LUCTAB+LUIATO,R11,	:GET SYSGEN INA. TIMEOUT VAL.
	IF	PHTIMO
DDHSTB	EQ	.
	EI
	STH	R0,DCBLKS+DCBIA1,RDCB,	:SET INA. TIMEOUT IN DCB
	JEFS	DDHST0			:JUMP,IF NOT TIMER SPECIFIED
	LHI	R0,DHIATV-PSEG		:GET INCATIVE TIMEOUT ENTRY
DDHST0
	STH	R0,DCBLKS+DCBIAT,RDCB,	:SAVE INACTIVE TIMEOUT PRO.
	LHL	R0,LUCTAB+LUCT.N,R11,
	LO	OSCAN
	SBT	R0,FNLGFL,,
	SBT	R0,BDPETE,,		:SET BSC DSP ETE MODE
	FO	OSCAN
:(F00/02/12/87/DB/START/CRM 4)
: IF THERE IS AN ATTACHED LU, THEN THE INACTIVITY TIMER FOR THE ATTACHED
: LU SHOULD ALSO BE RESET.
	LHL	R11,DCBLKS+DCBCRD,RDCB,	:IS THERE AN ATTACHED LU?
	JE	DDHSTF			:NO
	LHL	R2,LUCTAB+LUCDCB,R11,	:YES, GET DCB FOR ATTACHED LU
	JE	DDHSTF			:NO DCB DONE
	IF	PHTIMO
	LB	R6,DCBLKS+DCBAPI,R2,	:GET APPLICATION ID
	JNFS	DDHSTC			:JUMP IF NO OVERRIDE
	LIS	R0,0			:OVERRIDE TIMEOUT
	JFS	DDHSTD			:JUMP TO CONTINUE
DDHSTC	EQ	.
	EI
	LHL	R0,LUCTAB+LUIATO,R11,	:GET SYSGEN INA. TIMEOUT VAL.
	IF	PHTIMO
DDHSTD	EQ	.
	EI
	STH	R0,DCBLKS+DCBIA1,R2,	:SET INA. TIMEOUT IN DCB
	JEFS	DDHSTE			:JUMP,IF NOT TIMER SPECIFIED
	LHI	R0,DHIATV-PSEG		:GET INCATIVE TIMEOUT ENTRY
DDHSTE
	STH	R0,DCBLKS+DCBIAT,R2,	:SAVE INACTIVE TIMEOUT PRO.
	LHL	R0,LUCTAB+LUCT.N,R11,
	LO	OSCAN

	SBT	R0,BDPETE,,		:SET BSC DSP ETE MODE
	FO	OSCAN
DDHSTF
					:(F00/02/12/87/DB/END)
	J	IXENDN,,
DDHST3
	LHI	R4,DDHST4-PSEG		:TO READ NEXT BYTE
	JR	R5			:TO GIISD FOR NEXT BYTE
DDHST4
	STB	R0,DCBLKS+DCBTMP,RDCB,	:SAVE STATUS BYTE 1
	LHI	R4,DDHST5-PSEG		:TO READ NEXT BYTE
	JR	R5			:TO GIISD FOR NEXT BYTE
DDHST5
					:(F02/12/16/87/DB/START)
:	LB	R8,DCBLKS+DCBTMP,RDCB,	:GET STATUS BYTE 1
:	SLHLS	R8,8			:GET PROPER POSITION FOR S/S
:	OR	R8,R0			:COMBINE S/S BYTES
:	LHI	R2,NSSTAT^8+NSTRST	:SET UP SCC
:	LIS	R3,0			:CLEAR BUFFER PTR
:	LHL	R11,DCBLKS+DCBLUC,RDCB,
:	JAL	R6,QDIFSN,,		:QUEUE CMD TO DATA QUEUE
					:(F02/12/16/87/DB/END)
	J	IXENDN,,			:GOTO FINISH INPUT

:	DDHACK:	ACK MESSAGE
:	------
DDHACK
	J	NDACKG			:JUMP (TEMPORARY!!)

	EI	(HOSTIF&HDPSUP)

	SUBTTL (SNA-NNIO) BSC/DSP MODE - INPUT IIX DATA/DQ MESSAGES

	IF	(HOSTIF)&(HDPSUP)

:	C094 DATA PACKET HANDLER
:	========================
:	AHDINP:	INPUT DATA HANDLER
:	------
:	INPUT HANDLER --
:	(1) MOVES IRING DATA INTO BUFFER
:	    (A) ACCORDING SEGMENT INFORMATION BIT TO ASSIGN TH AND RH
:	    (B) CONVERT STX,ETB AND ETX TO SNA PROTOCOL
:	    (C) STRIP OFF SOME SPECIAL CHARACTERS (SUCH AS ESC)
:	    (D) STORES BUFFER PTR INTO DCB
:	    (E) QUEUES BUFFER PTR INTO LUCB DATA QUEUE COMMAND LIST
:	(2) PERFORMS SOME FUNCTIONS FOR DSP PROTOCOLS
:	    (A) DATA PACKET WITH Q BIT ON (SUCH AS
:	        BACK PRESSURE,ERROR MESSAGE,STATUS MESSAGE,ACK MESSAGE...
:	    (B) CONVERTS PARTICULAR 3270BSC MESSAGES INTO SNA RU OR LOCALLY
:	        GENERATES RESPONSE TO THAT MESSAGE.
:	(3)
:	DEFINITION --
:	DCBICT - CONTAINS LAXTYEYF
:		WHERE L IS INPUT LCM BIT
:		WHERE A IS INPUT ACK BIT
:		WHERE X IS INPUT XPR BIT
:		WHERE T IS INPUT TRQ BIT
:		WHERE E IS PREVIOUS ETX FRAME INDICATOR
:		WHERE F IS FIRST SEGMENT INDICATOR
:		WHERE Y IS RESERVED
:	DCBDSH - CONTAINS YYYYDQCS
:		WHERE D IS DUMMY RU REQUIRED
:		WHERE Q IS FORWARD ABORT (WHEN DATA END WITH 'ENQ')
:		WHERE C IS CHAINING STATE FOR INPUT (FIRST=0,CONTINUE=1)
:		WHERE S IS SEGMENT STATE FOR INPUT (FIRST=0,CONTINUE=1)
AHDINP
	LHI	R4,AHDIN0-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO READ NEXT BYTE
AHDIN0					:R0 = DIALECT DATA FLAG
	STB	R0,DCBLKS+DCBDFG,RDCB,	:SAVE IN TO DCB
	LHI	R4,AHDIN1-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO READ NEXT BYTE
AHDIN1					:R0 = THE 1ST BYTE OF MSG LENGTH
	STH	R0,DCBLKS+DCBICC,RDCB,	:SAVE TO DCBICC
	LR	RBCC,R0			:IN CASE DIMISS AT HERE (8/14/84/CHS)
	LHI	R4,AHDIN2-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO READ NEXT BYTE
AHDIN2					:R0 = 2ND BYTE OF LENGTH
	IF	RMDALL
	XR	R4,R4			:CLEAR THE REGISTER (02/12/85 MIA)
	STH	R4,DCBLKS+DCBLBX,RDCB,	:CLEAR RMA MSG COUNT (02/12/85 MIA)
	EI
	LHL	R4,DCBLKS+DCBICC,RDCB,	:GET 1ST BYTE
	SLHLS	R4,8			:SHIFT BYTE LEFT
	OR	R0,R4			:GET LENGTH IN HW
	STH	R0,DCBLKS+DCBIPL,RDCB,	:SAVE IT INTO DCB
	LB	R0,DCBLKS+DCBDFG,RDCB,	:GET DATA PACKET FLAG
	THI	R0,QBIT			:DQ PACKET
	JN	AHDINQ			:YES, SPECAIL HANDLE
	XR	R0,R0			:PREPARE FOR NO UCN (12/4/86/MIA)
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET DSP STATE BYTE (12/4/86 MIA)
	THI	R4,DSHMBY		:CONTINUATION PACKET? (12/4/86 MIA)
	JN	AHDI11			:JUMP IF SO
	LHI	R4,AHDIN3-PSEG		:TO READ UCN

	IF	BTRACE
	LIS	R0,BTRIBT		:SEE IF TRACNG INPUT
	TBT	R0,BTRIOF,,		:...
	JER	R5			:NO, RETURN TO NIO DISPATCHER
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R0,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R0,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LHL	R0,DCBLKS+DCBIPL,RDCB,	:R0 = IPL COUNT
	OHI	R0,BTRINP+BTRBEG	:INPUT AND BEGIN
	STH	R0,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R0,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R0,FASTC,,		:ELSE, MUST BE FASTC
	ST	R0,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

	JR	R5			:TO READ NEXT BYTE
AHDIN3					:R0 = UCN BYTE, IGNORE
	NHI	R0,BIT.FS
	JE	AHDIN4			:JUMP,IF IT IS 1ST SEG
	LB	R6,DCBLKS+DCBICT,RDCB,	:GET INPUT CONTROL BYTE
	NHI	R6,@FIRBIT		:TURN OFF 1ST SEGMENT BIT
	STB	R6,DCBLKS+DCBICT,RDCB,	:REPLACE IT IN DCB
	LCS	R0,1			:NOT INCLUDE UCN BYTE
	J	AHDI11			:SKIP, TO CONINUTE
AHDIN4
	LB	R6,DCBLKS+DCBICT,RDCB,	:GET INPUT CONTROL BYTE
	THI	R6,ETXBIT		:IS PREVIOUS ETX?
	JN	AHDIN5			:JUMP,IF PREVIOUS IS END WITH ETX
:	ERROR,SEND CMD/RSP UNDELIVERED??????
:	-----------------------------
	AR	R14,R2			:FLUSH THE REMANING CHAR (10/6/84 MIA)
	LB	R6,DCBLKS+DCBISQ,RDCB,	:GET EXPECTED ISQ-1
:	STB	R6,M.ERR+8,,		:STORE SEQ OF PREVIOUS DATA
	STB	R6,M.ERR+7,,		:STORE SEQ OF PREV DATA (10/6/84 MIA)
	LHI	R6,XMTINV		:SET 'XMT INVALID' FORMAT
:	STB	R6,M.ERR+9,,		:STORE ERROR CODE
	STB	R6,M.ERR+8,,		:STORE ERROR CODE
	EXBR	R6,R6
:	STB	R6,M.ERR+7,,		:STORE MSG ID FOR XMT
	STB	R6,M.ERR+6,,		:STORE MSG ID (10/6/84 MIA)
:	LA	R9,M.ERR,,		:GET CANNED MSG PTR(9/11/84/CHS)
	LA	R9,M.ERR-1,,		:GET CANNED MSG PTR(9/11/84/CHS)
	JAL	R6,SNDIIX,,		:JUMP TO SEND IIX MSG
	J	IXENDN,,			:END OF IIX DATA (10/6/84 MIA)
AHDIN5
	LIS	R4,0
	STB	R4,DCBLKS+DCBDSH,RDCB,	:CLEAR DCBDSH
	STH	R4,DCBLKS+DCBRUS,RDCB,	:INIT RU LENGTH (11/6/84 MIA)
	LHI	R4,AHDIN6-PSEG		:TO READ CONTROL BYTE
:READ MODIFIED ALL CODE. IF INPUT MESSAGE IS LONG ENOUGH IT IS
:CONSIDERED AS A REPONSE FOR RB REPLACING RMA PROVIDING THAT RMA
:STATE BYTE IS NOT 0. RMDAON IS TURNED ON TO SWITCH EMULATION LOGIC,
:RMA STATE IS SET TO COPY NEXT 3 CHARACTERS (AID AND CURSOR POSITION).
:(02/11/85 MIA)
	IF	RMDALL
	LB	R6,DCBLKS+DCBLLV,RDCB,	:GET RMA STATE BYTE
	JER	R5			:JUMP IF NO PREVIOUS RMA
	LHL	R6,DCBLKS+DCBIPL,RDCB,	:GET MESSAGE LENGTH
	CHI	R6,RMDAMN		:COMPARE WITH MIN LENGTH
	JLR	R5			:SKIP IF LESS
	LHI	R6,RMDACS!RMDAON!RMDASK	:SET RMA STATE TO COPY
	STB	R6,DCBLKS+DCBLLV,RDCB,	:UPDATE RMA STATE
	XR	R6,R6			:CLEAR THE REGISTER (12/06/85 MIA)
	STH	R6,DCBLKS+DCBLGT,RDCB,	:CLEAR SCREEN POS (12/06/85 MIA)
	LIS	R6,3			:3 BYTES TO COPY
	STB	R6,DCBLKS+DCBLLS,RDCB,	:SAVE IT IN DCB
	EI
:END OF RMA CODE (02/11/85 MIA).
	JR	R5			:RETURN FOR NEXT BYTE
AHDIN6
	THI	R0,TRQBIT		:IS IT TEST REQUEST MESSGAE?
	JN	DPICR1			:JUMP,NOT SUPPORT TRQBIT
	THI	R0,LCMBIT		:IS IT LCM RESPONSE
	JE	AHDIN7			:JUMP,IF NOT LCM
	LB	R4,DCBLKS+DCBDST,RDCB,	:GET DCB BSCDSP STATE
:	THI	R4,LCMBIT		:WAITING FOR LCM RESP? (10/31/84 MIA)
:	JE	DPICR1			:CRASH,IF NOT RGHT STAT (10/31/84 MIA)
	NHI	R4,@LCMBIT		:RESET LCMBIT
	STB	R4,DCBLKS+DCBDST,RDCB,	:RESET STATE TO INIT
AHDIN7
	THI	R0,ACKBIT		:IS IT ACKBIT ON?
	JE	AHDIN8			:JUMP,IF NOT
	LB	R4,DCBLKS+DCBDST,RDCB,	:GET DCB BSCDSP STATE
	OHI	R4,ACKBIT		:SET TO WAIT FOR ACK RSP
	STB	R4,DCBLKS+DCBDST,RDCB,	:RESET STATE TO INIT
AHDIN8
	NHI	R0,LCMBIT!ACKBIT!XPRBIT	:MASK OFF UNWANTED BITS
	OHI	R0,FIRBIT		:THIS IS 1ST SEGMENT MESSAGE
	STB	R0,DCBLKS+DCBICT,RDCB,	:SAVE IT IN DCB
	LHI	R4,AHDIN9-PSEG		:TO READ ISQ BYTE
	JR	R5			:RETURN FOR NEXT BYTE
AHDIN9					:R0 = ISQ
	LB	R6,DCBLKS+DCBISQ,RDCB,	:GET EXPECTED ISQ-1
	AIS	R6,1			:R6 = EXPECTED ISQ
	NHI	R6,0FF			:ONE BYTE ONLY
	CR	R6,R0			:COMPARE
	JN	CLRCIR			:NOT THE SAME
	STB	R0,DCBLKS+DCBISQ,RDCB,	:SAVE NEW ISQ INTO DCB
	LCS	R0,3			:UCN+CTL+ISQ
AHDI11
	AHM	R0,DCBLKS+DCBIPL,RDCB,
	JAL	R6,SINPBB,,		:SET UP NEW BUFFERLET
	AIS	RBBX,FID2LN		:UPDATE TH OFFSET
	LB	R6,DCBLKS+DCBDSH,RDCB,	:GET CURRENT SNA HEADER STATE
	NHI	R6,DSHSEG		:IS IT FIRST?
	JN	AHDI12			:JUMP,IF NOT 1ST SEGMENT STATE
	AIS	RBBX,RHLENG		:1ST SEGMENT,UPDATE RH OFFSET
AHDI12
	LHI	R4,AHDI13-PSEG		:SET UP NEW ENTRY
	JR	R5			:TO READ NEXT BYTE
AHDI13					:R0 = DATA BYTE
	AIS	RBCC,1			:INCREMENT INPUT CHAR COUNT
	AIS	RBBX,1
	LB	R6,DCBLKS+DCBICT,RDCB,	:GET CONTROL BYTE
	THI	R6,XPRBIT		:IS IT TRANSPARENT?
	JE	AHDI14			:JUMP,IF NOT
AHDI14
:READ MODIFIED ALL EMULATION CODE.
:READ MODIFIED ALL IS REPLACED BY READ BUFFER IN OUTPUT LOGIC.
:HERE, IN INPUT LOGIC, INPUT DATA FROM READ BUFFER IS CONVERTED
:TO LOOK AS READ MODIFIED ALL (01/27/85 MIA).
	IF	RMDALL
	LB	R4,DCBLKS+DCBLLV,RDCB,	:GET FLAGS/STATUS BYTE
	THI	R4,RMDAON		:RMA RECEIVED FROM HOST?
	JE	RMDAEE			:JUMP IF NOT
	CLH	RBCC,DCBLKS+DCBIPL,RDCB,	:LAST CHAR?
	JNFS	RMDAB1			:JUMP IF NOT
	LB	R6,DCBLKS+DCBDFG,RDCB,	:GET PKT FLAG BYTE
	THI	R6,MBIT			:END OF X.25 PKT?
	JE	RMDAEN			:JUMP IF SO
RMDAB1	NHI	R4,RMDAST		:GET RMA STATE
	LHL	R4,RMDATB,R4,R4		:GET JUMP POINTER
	J	PSEG,R4,		:JUMP TO PROCESSING ROUTINE

RMDATB	HC	RMDACP-PSEG		:COPY STATE
	HC	RMDANM-PSEG		:CHAR WITHIN A FIELD
	HC	RMDAFL-PSEG		:START FIELD FOUND
	HC	RMDAEF-PSEG		:START FIELD EXTENDED FOUND
	HC	RMDAPR-PSEG		:ATTRIBUTE PAIR FOR SFE

:COPY STATE.
:COPY DCBLLV CHARS INTO RMA MESSAGE. THEN GO TO RMDANM STATE.
RMDACP	LB	R4,DCBLKS+DCBLLS,RDCB,	:GET COPY COUNT
	SIS	R4,1			:DECREASE IT
	JNFS	RMDAC1			:JUMP IF NOT LAST
	LB	R4,DCBLKS+DCBLLV,RDCB,	:GET STATE BYTE
	NHI	R4,@RMDAST		:CLEAR STATE BITS
	OHI	R4,RMDANS		:GO TO NEXT STATE
	STB	R4,DCBLKS+DCBLLV,RDCB,	:UPDATE STATE BYTE
	J	RMDAEN			:JUMP TO COPY CHARACTER
RMDAC1	STB	R4,DCBLKS+DCBLLS,RDCB,	:UPDATE COPY COUNTER
	J	RMDAEN			:JUMP TO COPY CHARACTER

:REGULAR FIELD CHARACTER IS EXPECTED.
:SF, SFE OR SA MIGHT BE RECEIVED INSTEAD. IF SO GO TO START FIELD,
:START FIELD EXTENDED OR COPY STATE. OTHERWISE CHARACTER IS COPIED
:OR THROWN AWAY DEPENDING ON SKIP BIT. NULLS ARE ALWAYS SUPPRESSED.
RMDANM	CHI	R0,SF.			:START FIELD?
	JE	RMDAN3			:JUMP IF SO
	CHI	R0,SFE.			:START FIELD EXTENDED?
	JE	RMDAN2			:JUMP IF SO
	CHI	R0,SA.			:SET ATTRIBUTES?
	JE	RMDAN1			:JUMP IF SO
	LIS	R4,1			:PREPARE 1
	AHM	R4,DCBLKS+DCBLGT,RDCB,	:NEXT SCREEN LOCATION
	LR	R0,R0			:NULL CHARACTER?
	JE	RMDANN			:DO NOT COPY IT IF SO
	LB	R4,DCBLKS+DCBLLV,RDCB,	:GET STATE BYTE
	THI	R4,RMDASK		:MODIFIED FIELD?
	JN	RMDANN			:JUMP IF NOT
	J	RMDAEN			:JUMP TO COPY CHARACTER

:SET ATTRIBUTE. PREPARE TO COPY NEXT 2 CHARACTERS.
RMDAN1	LB	R4,DCBLKS+DCBLLV,RDCB,	:GET STATE BYTE
	NHI	R4,@RMDAST		:CLEAR STATE BITS
	OHI	R4,RMDACS		:GO TO COPY STATE
	STB	R4,DCBLKS+DCBLLV,RDCB,	:UPDATE STATE BYTE
	LIS	R4,2			:PREPARE TO COPY 2 BYTES
:	STB	R4,DCBLKS+DCBLGT,RDCB,	:UPDATE COPY COUNTER (12/06/85 MIA)
	STB	R4,DCBLKS+DCBLLS,RDCB,	:UPDATE COPY COUNTER (12/06/85 MIA)
	J	RMDAEN			:JUMP TO COPY SA ORDER

:START FIELD EXTENDED. UPDATE STATE BYTE.
RMDAN2	LHI	R4,RMDAES!RMDASK!RMDAON	:PREPARE NEW STATE
	STB	R4,DCBLKS+DCBLLV,RDCB,	:UPDATE STATE BYTE
	J	RMDANN			:DO NOT COPY SFE ORDER

:START FIELD. UPDATE STATE BYTE.
RMDAN3	LHI	R4,RMDAFS!RMDAON	:PREPARE NEW STATE
	STB	R4,DCBLKS+DCBLLV,RDCB,	:UPDATE STATE BYTE
	J	RMDANN			:DO NOT COPY SF ORDER

:START FIELD WAS RECEIVED AS PREVIOUS CHARACTER.
:THIS CHARACTER IS FIELD ATTRIBUTE.
RMDAFL	LIS	R4,1			:PREPARE 1
	AHM	R4,DCBLKS+DCBLGT,RDCB,	:NEXT SCREEN POSITION
	THI	R0,RMDAMT		:CHECK MODIFIED TAG
	JNFS	RMDAF2			:JUMP IF FIELD MODIFIED

:FIELD WAS NOT MODIFIED. GO TO REGULAR STATE AND TURN SKIP BIT ON.
RMDAF1	LHI	R4,RMDANS!RMDASK!RMDAON	:PREPARE NEW STATE
	STB	R4,DCBLKS+DCBLLV,RDCB,	:UPDATE STATE BYTE
	J	RMDANN			:DO NOT COPY ATTRIBUTE

:FIELD WAS MODIFIED. GO TO REGULAR STATE. ALSO PUT SBA ORDER AND SCREEN
:POSITION IN THE MESSAGE GENERATED.
RMDAF2	LHI	R4,RMDANS!RMDAON	:PREPARE NEW STATE
	STB	R4,DCBLKS+DCBLLV,RDCB,	:UPDATE STATE BYTE
	LHI	R0,SBA.			:PREPARE SBA ORDER
	STB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBA,RBBX	:PUT IT IN BUFFER
	LR	RBBX,RBBX		:ANY ROOM IN BUFFER?
	JNFS	RMDAF3			:JUMP IF SO
	JAL	R6,GINPBB,,		:OTHERWISE AQUIRE NEW BUFFER
RMDAF3	LHL	R4,DCBLKS+DCBLGT,RDCB,	:GET SCREEN POSITION
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC
	LB	R6,LUCTAB+LUCSYS,R11,	:SEE IF HITACHI
	CLHI	R6,HITACHI		:...
	JEFS	RMDAFX			:YES, SKIP
	SRHLS	R4,6			:GET HIGH 6 BITS OF POSITION
	LB	R0,BAIOIC,R4,		:CONVERT TO GRAPHIC
	J	RMDAFY			:SKIP
RMDAFX
	LR	R0,R4			:R0 = R4
	NHI	R0,01F			:LAST 5 BITS ONLY
	OHI	R0,0E0			:TURN ON FIRST 3 BITES
RMDAFY
	STB	R0,BBUFER+BBFLSZ-BBFPSZ+1,RBBA,RBBX	:PUT IT IN BUFFER
	AIS	RBBX,1			:INCREASE BUFFER INDEX
	JNFS	RMDAF4			:JUMP IF NOT END OF BUFFER
	JAL	R6,GINPBB,,		:OTHERWISE AQUIRE NEW BUFFER
RMDAF4	AIS	RBBX,1			:INCREASE BUFFER INDEX
	LIS	R0,2			:PREPARE 2
	AHM	R0,DCBLKS+DCBLBX,RDCB,	:INCREASE MSG CHAR COUNT
	LHL	R4,DCBLKS+DCBLGT,RDCB,	:GET SCREEEN POSITION
	LB	R6,LUCTAB+LUCSYS,R11,	:SEE IF HITACHI
	CLHI	R6,HITACHI		:...
	JEFS	RMDAFW			:YES, SKIP
	NHI	R4,3F			:LAST 6 BITS
	LB	R0,BAIOIC,R4,		:CONVERT TO GRAPHIC
	J	RMDAEN			:JUMP TO COPY IT
RMDAFW
	LR	R0,R4			:R0 = R4
	SRHLS	R0,5			:NOT LAST 5 BITS
	OHI	R0,0C0			:TURN ON FIRST 2 BITS
	J	RMDAEN			:SKIP TO CONTINUE

:START FIELD EXTENDED WAS FOUND.
:THIS CHARACTER IS THE NUMBER OF ATTRIBUTE PAIRS.
RMDAEF	STB	R0,DCBLKS+DCBLLS,RDCB,	:SAVE NUMBER OF ATTRIBUTE PAIRS
	LB	R4,DCBLKS+DCBLLV,RDCB,	:GET STATE BYTE
	NHI	R4,@RMDAST		:CLEAR STATE BITS
	OHI	R4,RMDAPS		:GO TO NEW STATE
	STB	R4,DCBLKS+DCBLLV,RDCB,	:UPDATE STATE BYTE
	J	RMDANN			:DO NOT COPY THE CHARACTER

:PROCESSING OF ATTRIBUTE PAIRS.
:THE NUMBER OF PAIRS IS IN DCBLLV. AFTER THE LAST PAIR IS PROCESSED
:GO TO REGULAR STATE.
:IF ODD CHAR OF THE PAIR IS BEING PROCESSED LOOK FOR FIELD ATTRIBUTE.
:IF IT WAS FOUND DETRMINE IF MODIFIED DATA TAG IS ON.
RMDAPR	LB	R4,DCBLKS+DCBLLV,RDCB,	:GET STATE BYTE
	THI	R4,RMDAFP		:ATTRIBUTE OR ITS VALUE?
	JN	RMDAP2			:JUMP IF VALUE
	OHI	R4,RMDAFP		:NEXT WILL BE VALUE
	CHI	R0,RMDAFA		:FIELD ATTRIBUTE?
	JNFS	RMDAP1			:JUMP IF NOT
	OHI	R4,RMDAFN		:FIELD ATTRIBUTE VALUE IS NEXT
RMDAP1	STB	R4,DCBLKS+DCBLLV,RDCB,	:SAVE STATE BYTE
	J	RMDANN			:DO NOT SAVE THIS CHARACTER
RMDAP2	NHI	R4,@RMDAFP		:NEXT WILL BE ATTRIBUTE ITSELF
	THI	R4,RMDAFN		:IS IT FIELD ATTR VALUE?
	JEFS	RMDAP4			:JUMP IF NOT
	THI	R0,RMDAMT		:MODIFIED DATA TAG ON?
	JNFS	RMDAP3			:JUMP OF SO
	OHI	R4,RMDASK		:SKIP NEXT FIELD
	JFS	RMDAP4			:JUMP TO CONTINUE
RMDAP3	NHI	R4,@RMDASK		:FIELD WAS MODIFIED
RMDAP4	LB	R6,DCBLKS+DCBLLS,RDCB,	:GET NUMBER OF ATTR PAIRS
	SIS	R6,1			:DECREASE BY 1
	JEFS	RMDAP5			:JUMP IF THE LAST PAIR
	STB	R4,DCBLKS+DCBLLV,RDCB,	:UPDATE STATE BYTE
	STB	R6,DCBLKS+DCBLLS,RDCB,	:UPDATE PAIR COUNTER
RMDAP5	THI	R4,RMDASK		:FIELD MODIFIED?
	JE	RMDAF2			:JUMP IF SO
	J	RMDAF1			:JUMP TO CONTINUE

:END OF PROCESSING FOR A CHARACTER. DO NOT COPY IT IN EMULATED RMA
:MESSAGE.
RMDANN	SIS	RBBX,1			:RETURN BACK BUFFER INDEX
	J	AHDI15			:JUMP TO CONTINUE

:END OF PROCESSING FOR THE CHARACTER.
:COUNT IT AND COPY TO RMA EMULATION MESSAGE.
RMDAEN	LIS	R4,1			:PREPARE 1
	AHM	R4,DCBLKS+DCBLBX,RDCB,	:INCREASE MSG COUNT
RMDAEE	EQ	.
	EI

:END OF CODE FOR RMA EMULATION (01/28/85 MIA).

	STB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA
	LR	RBBX,RBBX		:CHECK BUFFERLET FULL OR NOT
	JNFS	AHDI15			:BUFFERLET NOT FULL YET, SKIP
	JAL	R6,GINPBB,,		:ELSE, GET A NEW BUFFERLET
AHDI15
	CLH	RBCC,DCBLKS+DCBIPL,RDCB,:OVERFLOW/END OF FUL PACKET/ ..
	JEFS	AHDI16			:END OF PACKET
	JG	DOVFER			:OVERFLOW
	LHI	R4,AHDI13-PSEG		:SET UP NEW ENTRY
	JR	R5			:TO READ NEXT BYTE
AHDI16
	LB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA
	LB	R6,DCBLKS+DCBICT,RDCB,	:GET CONTROL BYTE
	THI	R6,XPRBIT		:IS IT TRANSPARENT?
	JE	AHDI17			:JUMP,IF NOT
AHDI17
	JAL	R6,DINDTX		:QUEUE IT TO NWKC->SNA DATA-Q
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET SNA STATE INF.
	THI	R4,DSHDRU		:IS IT NEED TO SEND DUMMY RU?
	JE	AHDI18			:JUMP, IF NOT
	JAL	R6,SINPBB,,		:GET NEW BUFFERLET
	LHI	RBCC,FID2LN+RHLENG	:SET UP BYTE COUNT
	JAL	R6,DINDTX		:QUEUE IT TO NWKC->SNA DATA-Q
AHDI18
AHDI19

	IF	BTRACE
	LIS	R0,BTRIBT		:SEE IF TRACNG INPUT
	TBT	R0,BTRIOF,,		:...
	JE	AHDI20			:NO, SKIP
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R0,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R0,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LHL	R0,DCBLKS+DCBIPL,RDCB,	:R0 = IPL COUNT
	OHI	R0,BTRINP+BTREND	:INPUT AND END
	STH	R0,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R0,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R0,FASTC,,		:ELSE, MUST BE FASTC
	ST	R0,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

AHDI20
	LIS	R0,0
	BBST	R0,DCBLKS+DCBIBH,RDCB,
	BBST	R0,DCBLKS+DCBIBA,RDCB,
	STH	R0,DCBLKS+DCBICC,RDCB,
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
:IF TIMEOUT BY PHYSICAL TERMINAL IS USED TIMEOUT VAULE COULD BE OVERRIDDEN
:BY APPLICATION IDENTIFIER (01/15/85 MIA).
	IF	PHTIMO
	LB	R6,DCBLKS+DCBAPI,RDCB,	:GET APPLICATION ID
	JNFS	AHDIA0			:JUMP IF NO OVERRIDE
	LIS	R0,0			:OVERRIDE TIMEOUT
	JFS	AHDIB0			:JUMP TO CONTINUE
AHDIA0	EQ	.
	EI
	LHL	R0,LUCTAB+LUIATO,R11,	:GET SYSGEN INA. TIMEOUT VAL.
	IF	PHTIMO
AHDIB0	EQ	.
	EI
	STH	R0,DCBLKS+DCBIA1,RDCB,	:SET INA. TIMEOUT IN DCB
:(F00/02/12/87/DB/START/CRM 4)
: IF THERE IS AN ATTACHED LU, THEN THE INACTIVITY TIMER FOR THE ATTACHED
: LU SHOULD ALSO BE RESET.
	LHL	R11,DCBLKS+DCBCRD,RDCB,	:IS THERE AN ATTACHED LU?
	JE	AHDIE0			:NO
	LHL	R4,LUCTAB+LUCDCB,R11,	:GET ATTACHED DCB
	JE	AHDIE0			:NO DCB DONE

	IF	PHTIMO
	LB	R6,DCBLKS+DCBAPI,R4,	:GET APPLICATION ID
	JNFS	AHDIC0			:JUMP IF NO OVERRIDE
	LIS	R0,0			:OVERRIDE TIMEOUT
	JFS	AHDID0			:JUMP TO CONTINUE
AHDIC0	EQ	.
	EI
	LHL	R0,LUCTAB+LUIATO,R11,	:GET SYSGEN INA. TIMEOUT VAL.
	IF	PHTIMO
AHDID0	EQ	.
	EI
	STH	R0,DCBLKS+DCBIA1,R4,	:SET INA. TIMEOUT IN DCB
AHDIE0
					:(F00/02/12/87/DB/END)
	J	IXENDN,,		:END OF IIX INPUT

:
:	DQ PACKET HANDLING
:	-----------------
:
AHDINQ
	J	GDSPIX			:TO PROC Q-PACKET & DSP

:	DOVFER:	DATA OVERFLOW
:	-------
DOVFER
	JAL	R10,CRASH,,
	BC	0,0,0,088

:	DPICR1:	INPUT DSP CONTROL ERROR
:	-------
DPICR1
	JAL	R10,CRASH,,
	BC	0,0,0,088

	EI	(HOSTIF&HDPSUP)

	SUBTTL (SNA-NNIO) BSC/DSP MODE - NWKC->SNA DATA-Q

	IF	(HOSTIF)&(HDPSUP)

:	DINDTX:	QUEUE ISIS/INPUT (DSP)DATA TO NWKC->SNA DATA-Q
:	------
:	INPUT:	RDCB, DCBIBH SET UP
:		RBCC(R8) = BYTE COUNT
:		R6 = LINK REGISTER
:	OUTPUT:
:	DESTROYED: R0, R2, R3, R4, R7, R11
DINDTX
:RMA CODE. IF RMA CONVERSION WAS PERFORMED OBTAIN BYTE COUNT FROM DCBLBX.
:(02/12/85 MIA).
	IF	RMDALL
	LB	R4,DCBLKS+DCBLLV,RDCB,	:GET RMA STATUS
	THI	R4,RMDAON		:RMA CONVERSION?
	JEFS	DINDTP			:JUMP IF NOT
	LHL	RBCC,DCBLKS+DCBLBX,RDCB,	:GET BYTE COUNT
DINDTP	EQ	.
	EI
:END OF RMA CODE (02/12/85 MIA).
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUC OFFSET
	LHL	R4,LUCTAB+LUCT.N,R11,
	LO	OSCAN			:(01/27/87 YLH)
	TBT	R4,FNLGFL,,
	FO	OSCAN			:(01/27/87 YLH)
	JN	DIND71			:JUMP,IF NOT RCV FINISH LOGON FROM LU
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET CURRENT SNA HEADER STATE
	THI	R4,DSHDRU		:IS IT NEED TO SEND DUMMY RU?
	JN	DINDTA			:JUMP,IF YES
	LR	R2,RBCC			:COPY THE REGISTER (11/8/84 MIA)
	SIS	R2,1			:ADJUST FOR BSC TRLER (11/8/84 MIA)
	AHM	R2,DCBLKS+DCBRUS,RDCB, :CALC RU LENGTH (11/7/84 MIA)
	AIS	RBCC,FID2LN		:ADD TH CNT TO BYTE CNT
	NHI	R4,DSHSEG		:IS IT FIRST?
	JN	DINDT0			:JUMP,IF NOT 1ST SEGMENT STATE
	AIS	RBCC,RHLENG		:ADD RH COUNT TO BYTE CNT
DINDT0
	LIS	R2,0			:INIT VALUE FOR CMD
	LB	R7,DCBLKS+DCBDFG,RDCB,	:GET DATA PACKET CONTROL BYTE
	THI	R7,MBIT			:IS M-BIT ON?
	JE	DINDT3			:JUMP,IF M-BIT=0
DINDTZ	OHI	R2,NSDTFS		:DEFAULT TO 1ST/NOT LAST SEGMENT
	LHL	R7,DCBLKS+DCBRUL,RDCB,	:SINGLE RU CHAIN?(3.F01/06/22/87/DB)
	JEFS	DINDTV			:YES, (3.F01/6/22/87/DB)
	OHI	R2,NSDTFC		:DEFAULT TO 1ST/NOT LAST CHAIN
DINDTV					:(3.F01/06/22/87/DB)
:	LR	R4,R4			:IS SEGMENT STATE=FRST? (11/13/84 MIA)
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET DSP STATE BYTE (11/14/84 MIA)
	NHI	R4,DSHSEG		:IS SEGMENT STATE=FRST? (11/14/84 MIA)
	JEFS	DINDT1			:JUMP,IF IT IS 1ST SEGMENT
	OHI	R2,NSDTIS		:SET TO INTERMEDIATE SEGMENT
DINDT1
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET SNA HEADER INF.
	NHI	R4,DSHCHN		:GET CHAIN STATE INF.
	JEFS	DINDT2			:JUMP,IF IT IS 1ST CHAIN
	OHI	R2,NSDTIC		:SET TO INTERMEDIATE CHAIN
DINDT2
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET SNA HEADER INF. BYTE
:	OHI	R4,DSHSEG		:SET SEGMENT TO CONTINUE
	OHI	R4,DSHSEG!DSHMBY	:SET SEGMENT TO CONTINUE (12/4/86 MIA)
	STB	R4,DCBLKS+DCBDSH,RDCB,	:SET VALUE IN DCB
	LIS	R4,1			:PREPARE +1 (11/8/84 MIA)
	AHM	R4,DCBLKS+DCBRUS,RDCB,	:ADJUST LNGT FOR NO TRL (11/8/84 MIA)
:	J	DINDTB			:JUMP TO SET CMD IN QUE (11/8/84 MIA)
	J	DINDTE			:JUMP TO SET CMD IN QUE (11/8/84 MIA)
:	M-BIT=0 CONDITION
:	-----------------
DINDT3
	JAL	R4,R.BSSH,,		:GOTO FIND DSP TRAILER INDEX
	LIS	R2,0
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET CURRENT SNA HEADER STATE
	NHI	R4,@DSHMBY		:SET PACKET TO CONTINUE (12/4/86 MIA)
	THI	R4,DSHSEG		:IS IT FIRST?
	JEFS	DIND60			:JUMP,IF FIRST SEGMENT
	OHI	R2,NSDTLS		:DEFAULT TO LAST/NOT FIRST SEGMENT
:	JFS	DIND61			:JUMP TO SET BCI=0 (11/28/84 MIA)
DIND60
	THI	R4,DSHCHN		:IS IT FIRST CHAIN?
	JEFS	DIND62			:JUMP,IF NOT FIRST CHAIN
DIND61
	OHI	R2,NSDTLC		:SET BCI=0
DIND62
:	NHI	R4,@DSHSEG		:SET SEGM STATE TO FRST (11/14/84 MIA)
:	STB	R4,DCBLKS+DCBDSH,RDCB,	:STORE NEW SNA STATE (11/14/84 MIA)
	LHL	R4,DINDT4,R3,R3		:GET ENTRY PTR
	J	DINDT4,R4,
DINDT4	HS
	HC	DINDT5-DINDT4		:BSC TRAILER=ETX
	HC	DINDT6-DINDT4		:BSC TRAILER=ETB
	HC	DINDT7-DINDT4		:BSC TRAILER=ENQ
	HC	DINDT8-DINDT4		:BSC TRAILER=ITB
	HC	DINDT9-DINDT4		:BSC TRAILER=ERROR

:	M-BIT=0,BSC-TRAILER=ETX
:	-----------------------
DINDT5
:IF RMA CONVERSION WAS ON ZERO OUT RMA STATUS (02/12/85 MIA).
	IF	RMDALL
	LB	R4,DCBLKS+DCBLLV,RDCB,	:GET RMA STATE BYTE
	THI	R4,RMDAON		:RMA CONVERSION ON?
	JEFS	DINDTQ			:JUMP TO CONTINUE IF NOT
	XR	R4,R4			:CLEAR THE REGISTER
	STB	R4,DCBLKS+DCBLLV,RDCB,	:UPDATE RMA STATE BYTE
DINDTQ	EQ	.
	EI
:END OF RMA CODE (02/12/85 MIA).
	LB	R4,DCBLKS+DCBICT,RDCB,	:GET INPUT CONTROL BYTE
	OHI	R4,ETXBIT		:SET TO ETXBIT RCVED
	STB	R4,DCBLKS+DCBICT,RDCB,	:STORE INTO DCB
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET CURRENT SNA STATE
:	THI	R4,DSHCHN		:IS IT FIRST CHAIN? (11/8/84 MIA)
:	JN	DIND53			:JUMP,IF NOT (11/8/84 MIA)
	THI	R4,DSHSEG		:IS IT FIRST SEGMENT?
	JN	DIND53			:JUMP,IF NOT
	NHI	R2,@NSDTFC		:SET ECI=1
	OHI	R2,NSDTCD		:SET TO CHANGE DIRECTION
:	NHI	R4,@(DSHCHN!DSHCEL)	:SET,CHN=FRST,RST CANC (11/14/84 MIA)
	NHI	R4,@(DSHCHN!DSHSEG!DSHCEL) :RESET CHN,SEGM&CANC (11/14/84 MIA)
	STB	R4,DCBLKS+DCBDSH,RDCB,	:SET NEW SNA STATE
	J	DINDTB			:JUMP TO SEND DATA TO QUEUE
DIND53
	LHL	R7,DCBLKS+DCBRUL,RDCB,	:SINGLE RU CHAIN?(3.F01/6/22/87/DB)
	JEFS	DIND54			:YES (3.F01/06/22/87/DB)
	OHI	R2,NSDTFC		:SET ECI=0
	OHI	R4,DSHDRU		:SET FOR DUMMY RU SEND
DIND54					:(3.F01/06/22/87/DB)
	NHI	R4,@(DSHCHN!DSHCEL!DSHSEG)
	STB	R4,DCBLKS+DCBDSH,RDCB,	:SET NEW SNA STATE
	J	DINDTB			:JUMP TO SEND DATA TO QUEUE
:	M-BIT=0,BSC-TRAILER=ETB
:	-----------------------
DINDT6
	LHL	R4,DCBLKS+DCBRUL,RDCB,	:GET MAX RU SIZE (11/5/84 MIA)
	JNFS	DINDTU			:JUMP IF MULT RU ALLOWED (11/5/84 MIA)
DINDTY	LIS	R2,0			:CLEAR THE REGISTER (11/5/84 MIA)
	SIS	RBCC,1			:DISCARD THE TRAILER (11/15/84 MIA)
	J	DINDTZ			:JUMP TO CREATE SEGM (11/5/84 MIA)
DINDTU	SH	R4,DCBLKS+DCBRUS,RDCB,	:SUBTR CURRENT RU LGT (11/5/84 MIA)
	SHI	R4,RSPMSS		:LEAVE SPACE FOR NXT MSG (11/5/84 MIA)
	JGEBS	DINDTY			:SEGM IF NOT LIMIT (11/5/84 MIA)
	XR	R4,R4			:PREP TO START NEW RU (11/5/84 MIA)
	STH	R4,DCBLKS+DCBRUS,RDCB,	:CLEAR RU LENGTH(11/5/84 MIA)
	OHI	R2,NSDTFC		:SET ECI=0
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET CURRENT SNA STATE
	OHI	R4,DSHCHN		:SET CHAIN STATE TO CONTINUE
:	NHI	R4,@DSHCEL		:RESET CANCEL STATE
	NHI	R4,@(DSHSEG!DSHCEL)	:RESET CANC AND SEGM ST (11/14/84 MIA)
	STB	R4,DCBLKS+DCBDSH,RDCB,	:STORE IN DCB
	J	DINDTB			:JUMP TO SEND DATA TO QUEUE
:	M-BIT=0,BSC-TRAILER=ENQ
:	-----------------------
DINDT7
	XR	R4,R4			:CLEAR THE REGISTER (11/5/84 MIA)
	STH	R4,DCBLKS+DCBRUS,RDCB,	:CLEAR RU LENGTH (11/5/84 MIA)
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET CURRENT SNA STATE
	OHI	R4,DSHCEL		:SET CANCEL STATE
	STB	R4,DCBLKS+DCBDSH,RDCB,	:STORE IN DCB
	OHI	R2,NSDTCN		:CANCEL CURRENT DATA
	J	DINDTB			:JUMP TO SEND DATA TO QUEUE
:
:	DO WE HAVE TO UPDATE DCBISQ?
DIND71
	JAL	R6,RINPBB,,		:RELEASE ALL INPUT BUFFERS
	J	AHDI18			:RESET DCB PTR
:	M-BIT=0,BSC-TRAILER=ITB
:	-----------------------
DINDT8
:	M-BIT=0,BSC-TRAILER=ERROR
:	-----------------------
DINDT9
	J	HDPCR1			:JUMP TO CRASH,IF TRAILER ERROR

DINDTA
	NHI	R4,@DSHDRU		:MASK OFF DUMMY RU SEND
	STB	R4,DCBLKS+DCBDSH,RDCB,	:SAVE SNA STATE INF.
	LHI	R2,NSDTCD!NSDTLC	:SET TO LAST/NOT 1ST CHAIN&CHANGE DIR.
	JFS	DINDTE
DINDTB
	SIS	RBCC,1			:TAKE DSP-TRAILER OFF
DINDTE
	LB	R4,DCBLKS+DCBICT,RDCB,	:GET INPUT CONTROL BYTE
	NHI	R4,ACKBIT		:IS IT E-T-E ACK?
	JEFS	NINDTF			:JUMP,IF NOT
	OHI	R2,NSDTAK		:SET ACK BIT ON
NINDTF
	LHI	R0,SNETEM^8		:E-T-E DATA
	OR	R2,R0			:MAKE THE WHOLE CMD
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	BBLOAD	R3,DCBLKS+DCBIBH,RDCB,	:GET THE BB HEADER PTR
	J	QDIFSN,,		:TO COMMON ROUTINE

:	HDPCR1:	HOST DSP INPUT TRAILER ERROR
:	-------
HDPCR1
	JAL	R10,CRASH,,
	BC	0,0,0,0A0

	EI	(HOSTIF&HDPSUP)

	SUBTTL (SNA-NNIO) BSC/DSP MODE - SNA->NWKC DATA-Q

	IF	(HOSTIF)&(HDPSUP)

:	OUTPUT HANDLER --
:	RECEIVED A SNA RQ/RSP RU FROM HOST, CONVERT IT TO A DSP
:	'CMD/RSP' MSG AND SEND IT OUT TO THE 3270BSC TERMINAL PAD
:	VIA THE ISIS ORING.
:	(1) GET BUFFER PTR FROM LUCB DATA QUEUE COMMAND LIST
:	    (A) ACCORDING TO SUBCOMMAND TYPE FROM LU.SVC TO ADJUST
:		BSC HEADER AND TRAILER
:		(THE INFORMATION IN SUBCOMMAND SUCH AS CHANGE DIRECTION BIT,
:		FIRST/LAST SEGMENT INDICATOR AND OTHER PROTOCOL RULES WILL
:		BE USED TO ASSIGN BSC HEADER,TRAILER AND DSP PACKET
:		INFORMATION BITS CONTENTS)
:	(2) ASSIGN THE DATA COUNT
:	    (A) FIRST RU SEGMENT,
:		DATA COUNT=UCN(1)+CTL(1)+SEG(1)+DATA BYTES-TH(6)-RH(3)
:			  +BSC HEADER/TRAILER(2)
:		PACKET LENGTH=C094(2)+FLAG(1)+DATACNT(2)+DATA COUNT
:	    (B) THE SUBSEQUENT SEGMENTS,
:		DATA COUNT=UCN(1)+DATA BYTES-TH(6)+BSC HEADER/TRAILER(2)
:		PACKET LENGTH=C094(2)+FLAG(1)+DATACNT(2)+DATA COUNT
:	EXPECT:
:		RBBA = BUFFER CONTAINING DATA
:		R0   = SCC FROM CMDLST ELEMENT
:	REG USAGE:
:		RBBX = INDEX TO BUFFER CONTAINING DATA
:		RBCC = # OF BYTES IN MESSAGE
:		R2 = ISIS RECORD BYTE COUNT
:	DO WE HAVE TO COUNT DATA AMOUNT ACCORDING TO BIND
:	PARAMETERS???
AHDOUP

	IF	BTRACE
	LIS	R4,BTROBT		:SEE IF TRACNG OUTPUT
	TBT	R4,BTRIOF,,		:...
	JE	AHDOUX			:NO, SKIP TRACE
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT #
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R4,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R4,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LR	R4,RBCC			:R4 = BYTE COUNT
	OHI	R4,BTROUT+BTRBEG	:OUTPUT AND BEGIN
	STH	R4,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R4,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R4,FASTC,,		:ELSE, MUST BE FASTC
	ST	R4,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

AHDOUX

	IF	WSFQRP

:	(3/21/86/CHS) TO LOCALLY REPLY TO WSF QUERY COMMAND
	LHL	R11,DCBLKS+DCBLUC,RDCB, :R11 = LUC
	LIS	RBBX,9			:POINT TO CMD BYTE
	LB	R7,BBUFER,RBBA,RBBX,	:FETCH CMD
	CLHI	R7,0F3			:WSF CMD?
	JN	AHDOUZ			:NO, SKIP
	LB	R7,BBUFER+1,RBBA,RBBX,	:FETCH 1ST LENGHT FIELD
	CLHI	R7,0			:IS IT '00'?
	JN	AHDOUZ			:NO, SKIP
	LB	R7,BBUFER+2,RBBA,RBBX,	:FETCH 2ND BYTE OF LENGTH FIELD
	CLHI	R7,5			:IS IT '05'?
	JN	AHDOUZ			:NO, SKIP
	LB	R7,BBUFER+3,RBBA,RBBX,	:FETCH WSF ID
	CLHI	R7,1			:IS IT '01'?
	JN	AHDOUZ			:NO, SKIP
	LB	R7,BBUFER+4,RBBA,RBBX,	:FETCH NEXT BYTE
	CLHI	R7,0FF			:IS IT 'FF'?
	JN	AHDOUZ			:NO, SKIP
	LB	R7,BBUFER+5,RBBA,RBBX,	:FETCH LAST BYTE
	CLHI	R7,02			:IS IT '0'?
	JN	AHDOUZ			:NO, SKIP
	LB	R6,DCBLKS+DCBICT,RDCB,	:GET INPUT CONTROL BYTE
	THI	R6,ETXBIT		:IS PREVIOUS ETX?
	JER	R5			:NO, DISMISS
	JAL	R7,DLODTA,,		:YES, DELETE THIS DATA STREAM
	JAL	R6,PTLBH,,		:WSF REPLY SNA HEADER
	LB	R7,DCBLKS+DCBDIF,RDCB,	:REMOTE SUPPORT KANJI?
	NHI	R7,07			:GET CHAR SET BITS
	LA	R1,WSFRP1		:ASSUME DONT SUPPORT KANJI
	CLHI	R7,4
	JLEFS	AHDOUY			:HIT, SKIP
	LA	R1,WSFRP2		:ELSE, FETCH WSF REPLY 2
AHDOUY
	JAL	R6,PTLBS,,		:..
	LHI	R2,NSETEM^8+NSDTCD	:CHANGE DIRECTION
	BBLOAD	R3,LUCTAB+LUCIBH,R11,
	JAL	R6,QDIFSN,,		:SEND WSF REPLY TO SNA LAYER
	JR	R5			:EXIT

WSFRP1	HC	WSFR1L
	XC	880017818101000050
	XC	001800000200890002
	XC	008509100780001181		:(11/19/86/CHS)
	XC	A600000B0100005000
	XC	1800500018
WSFR1L	EQ	.-WSFRP1-2

WSFRP2	HC	WSFR2L
	XC	880017818101000050
	XC	001800006527100065
	XC	27100D1D0780002381
	XC	858E000C1800000000
	XC	0B0000000000000001
	XC	4C01228020F8181841
	XC	7F0172012C000A818C
	XC	000000000000000B81
	XC	910003018003020100
	XC	078188000102000C81
	XC	950000080008000101
	XC	00168186000800F4F1
	XC	00F200F300F400F500
	XC	F600F700000D818704
	XC	00F0F1F1F2F2F4F400
	XC	1181A600000B010000
	XC	50001800500018
WSFR2L	EQ	.-WSFRP2-2
	HS	0
AHDOUZ
	EI	(WSFQRP)


	BBST	RBBA,DCBLKS+DCBOBA,RDCB,:SAVE BUFFER ADR OF DATA MSG
	STB	R0,DCBLKS+DCBSCC,RDCB,	:SAVE SCC
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUC OFFSET
	LB	R4,LUCTAB+LUBPSG,R11,	:GET DSP TRAILER SELECTION
	LB	R2,DCBLKS+DCBRFS,RDCB,	:GET CRM INF
	NHI	R2,XPRBIT		:IS IT TRANSPARENT?
	JNFS	AHDOU0			:JUMP,IF YES
	CLHI	R4,ETXBIY		:IS ETX,ETB AND ITB SELECTED?
	JNFS	AHDOU0			:JUMP,IF NOT
	LHI	R4,ETXBYY		:SET SELECTION TO ETB,ETX
AHDOU0
	STB	R4,DCBLKS+DCBTSG,RDCB,	:STORE INTO DCB
	LR	RBBA,RBBA		:CHECK BUFFER PTR
	JE	AHDOAK			:JUMP,IF NO BUFFER PTR
	LHI	RBBX,-BBFLSZ+BBFPSZ-1	:INIT BB INDEX
					:(F00/02/27/87/DB/START) LU_T1
	LB	R4,DCBLKS+DCBSCC,RDCB,	:GET SUB COMMAND CODE
	THI	R4,SNDOFF		:DOES THIS MSG CONATIN SCS DATA?
	JEFS	AHDOUD			:NO
:  THE FIRST HALF WORD OF THE BUFFER CONTAINS THE MSG OFFSET.
:  RBCC ALREADY EQUAL TO THE # OF MSG BYTES. IT DOESN'T NEED
:  ADJUSTING.
	AH	RBBX,BBUFER+BBFLSZ-BBFPSZ+1,RBBX,RBBA	:ADD OFFSET OF MSG TO INDEX
AHDOUD
					:(F00/02/27/87/DB/END)
	NHI	R0,SNDTIS		:GET SEGMENT INDICATOR
	JE	AHDOU1			:JUMP,IF IT IS ONE-SEGMENT PIU
	CLHI	R0,SNDTFS		:IS IT (BBIU,NOT EBIU)
	JE	AHDOU1			:JUMP,IF IT IS (BBIU,NOT EBIU)
:	SIS	RBCC,FID2LN		:GET RU LENGTH(F00/02/27/87/DB)
:	AIS	RBBX,FID2LN		:UPDATE BUFFER INDEX(F00/02/27/87/DB)
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	NHI	R0,@DSH1DP		:SET FIRST-DSP TO FALSE
	STB	R0,DCBLKS+DCBOCT,RDCB,	:STORE IT INTO DCB
					:(F00/02/27/87/DB/START)
	THI	R4,SNDOFF		:OFFSET MSG?
	JN	AHDOU5			:YES, RBBX AND RBCC ALREADY SETUP
	SIS	RBCC,FID2LN		:GET RU LENGTH
	AIS	RBBX,FID2LN		:UPDATE BUFFER INDEX
					:(F00/02/27/87/DB/END)
	J	AHDOU5			:JUMP TO SEND DSP HEADER
AHDOU1
					:(F00/02/27/87/DB/START)
	THI	R4,SNDOFF		:OFFSET MSG?
	JN	AHDOUE			:YES, RBBX AND RBCC ALREADY SETUP
					:(F00/02/27/87/DB/END)
	SIS	RBCC,FID2LN+RHLENG	:GET RU LENGTH
	AIS	RBBX,FID2LN+RHLENG	:UPDATE BUFFER INDEX
AHDOUE					:(F00/02/27/87/DB)
:	LB	R4,DCBLKS+DCBSCC,RDCB,	:GET SCC
	NHI	R4,SNDTIC		:MASK OTHER BITS EXCEPT BCI,ECI
	JE	AHDOU2			:JUMP,IF IT IS SINGLE ELEMENT CHAIN
	CLHI	R4,SNDTLC		:IS IT (NOT BCI,ECI)?
	JE	AHDOU2			:JUMP,IF IT IS (NOT BCI,ECI)
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	NHI	R0,@DSHEDP		:SET END-DSP TO FALSE
	JFS	AHDOU3			:GOTO CHECK BCI
AHDOU2
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	OHI	R0,DSHEDP		:SET END-DSP TO TRUE
AHDOU3
	STB	R0,DCBLKS+DCBOCT,RDCB,	:SAVE CONTROL BYTE IN DCB
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	LB	R4,DCBLKS+DCBSCC,RDCB,	:GET SCC
	NHI	R4,SNDTIC		:MASK OTHER BITS EXCEPT BCI,ECI
	JE	AHDOU4			:JUMP,IF IT IS SINGLE ELEMENT CHAIN
	CLHI	R4,SNDTFC		:IS IT (BCI,NOT ECI)?
	JE	AHDOU4			:JUMP,IF IT IS (BCI,NOT ECI)
	NHI	R0,@DSHSDP		:SET SUB-DSP TO FALSE
	LB	R4,DCBLKS+DCBTSG,RDCB,	:GET TEMP-SYSGEN (DSP TRAILER)
	CLHI	R4,ETXBIY		:IS IT ETX,ETB AND ITB?
	JN	AHDOU5			:JUMP IF NOT
	OHI	R0,DSHSDP		:SET SUBSEG-DSP TO TRUE
	AIS	RBCC,1			:ADD UCN FOR SUB-SEG.
	J	AHDOU5			:JUMP
AHDOU4
	OHI	R0,DSH1DP		:SET FIRST-DSP TO TRUE
	AIS	RBCC,4			:ADD UCN+CNTL+SEQ+ESC FOR 1ST SEG.
AHDOU5					:SEND SIIX 1ST
	STB	R0,DCBLKS+DCBOCT,RDCB,	:SAVE CONTROL BYTE IN DCB
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	NHI	R0,DSHEDP		:IS IT END-DSP?
	JE	AHDOU6			:JUMP,IF NOT
	LB	R0,DCBLKS+DCBSCC,RDCB,	:GET SCC
	NHI	R0,SNDTIS		:MASK FOR SEGMENT INF.
	JE	AHDOU9			:JUMP,IF (BBIU,EBIU)
	CLHI	R0,SNDTLS		:IS IT (NOT BBIU,EBIU)
	JE	AHDOU9			:JUMP,IF YES
:	IF NOT ((EBIU) AND (END-DSP))
:	-----------------------------
AHDOU6
	LB	R4,DCBLKS+DCBTSG,RDCB,	:GET TEMP-SYSGEN (DSP TRAILER)
	CLHI	R4,ETXBIY		:IS IT ETX,ETB AND ITB?
	JN	AHDOU7			:JUMP,IF NOT SYSGENED AS 
	LB	R0,DCBLKS+DCBSCC,RDCB,	:GET SCC
	NHI	R0,SNDTIS		:MASK FOR SEGMENT INF.
	JE	AHDOU8			:JUMP,IF (BBIU,EBIU)
	CLHI	R0,SNDTLS		:IS IT (NOT BBIU,EBIU)
	JE	AHDOU8			:JUMP,IF YES
:	SUB - IF NOT (TEMP-SYSGN=3 AND EBIU)
:	-----------------------------------
AHDOU7
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	OHI	R0,DSHMBT		:SET M-BIT=1
	NHI	R0,@DSHTRA		:MASK OFF TRAILER BITS
	STB	R0,DCBLKS+DCBOCT,RDCB,	:SAVE CONTROL BYTE
	J	AHDO10			:JUMP TO SEND IIX
:	IF TEMP-SYSGEN=3 AND EBIU
:	-------------------------
AHDOU8
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	NHI	R0,@DSHMBT		:SET M-BIT=0
	NHI	R0,@DSHTRA		:MASK OFF TRAILER
	OHI	R0,DSHITB		:SET TRAILER TO ITB
	STB	R0,DCBLKS+DCBOCT,RDCB,	:UPDATE DCB
	J	AHDO10			:JUMP TO SEND IIX
:	IF	(EBIU) AND (END-DSP)
:	------------------------
AHDOU9
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	NHI	R0,@DSHTRA		:MASK OFF TRAILER
	LB	R4,DCBLKS+DCBSCC,RDCB,	:GET SCC
	THI	R4,SNDTCN		:IS CANCEL IND. ON?
	JN	AHDOCN			:JUMP,IF CANCEL IND. ON
	LB	R4,DCBLKS+DCBTSG,RDCB,	:GET TEMP-SYSGEN (DSP TRAILER)
	CLHI	R4,ETXBIY		:IS IT ETX,ETB AND ITB?
	JEFS	AHDOUA			:IF TEMP-SYSGN=3
	CLHI	R4,ETXBYY		:IS IT ETX AND ETB?
	JN	AHDOUB			:NO,IF SYSGEN NOT FOR ETX AND ETB
AHDOUA
	LB	R4,DCBLKS+DCBSCC,RDCB,	:GET HEADER INF FROM DCB
	NHI	R4,SNDTCD		:IS IT CDI=1?
	JN	AHDOUB			:JUMP,IF CDI SET
	OHI	R0,DSHETB		:SET DSP-TRAILER=ETB
	JFS	AHDOUC			:JUMP
AHDOUB
	OHI	R0,DSHETX		:SET DSP-TRAILER=ETX
AHDOUC
	NHI	R0,@DSHMBT		:MASK OFF M-BIT
	STB	R0,DCBLKS+DCBOCT,RDCB,	:SET OUTPUT CONTROL BYTE
	AIS	RBCC,1			:ADD DSP-TRAILER FOR PACKET LENGTH
AHDO10
	AIS	RBCC,5			:C094+FLAG+DATA CNT
	LIS	R0,3			:SEND SIIX MSG
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT
	LHI	R2,SIIX
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,
	LB	R0,XLIMIT,R1,		:GET ISIS MAX XLIMIT
	SIS	R0,2
	CR	R0,RBCC			:SEE IF PACKET FIT INTO ONE ISIS RCD
	JLFS	AHDO11			:NO, USE XLIMIT
	LR	R0,RBCC			:ELSE, USE PACKET LENGTH
AHDO11
	LR	R2,R0			:R2 = ISIS RCD BYTE COUNT
	AIS	R0,2			:ADJUST WITH PORT
	JAL	R4,SLOR,,
	LHI	R0,IIXDIL		:DATA DIALECT CODE (C094)
	JAL	R4,PUTCH,,
	LHI	R0,DATAPK
	JAL	R4,PUTCH,,
	LIS	R0,0
	LB	R4,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL
	NHI	R4,DSHMBT		:IS M-BIT ON?
	JEFS	AHDO12			:JUMP,IF NOT
	OHI	R0,MBIT			:SET M-BIT=1
AHDO12
	JAL	R4,PUTCH,,
	SIS	R2,5			:C094 + FLAG + PACKET.LENGTH FILED
	SIS	RBCC,5
	EXBR	R0,RBCC			:SEND LEFT BYTE OF PACKET LENGTH
	JAL	R4,PUTCH,,
	LR	R0,RBCC			:SEND RIGHT BYTE OF LENGTH
	JAL	R4,PUTCH,,
					:SEND HEADER (UCN, CTL, SEQ)
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL
	THI	R0,DSH1DP		:IS IT FIRST-DSP?
	JE	AHDO17			:NO, SKIP
	NHI	R0,@DSH1DP		:SET FIRST-DSP TO FALSE
	STB	R0,DCBLKS+DCBOCT,RDCB,	:STORE IT INTO DCB
	LHI	R0,UCN			:Y - SET FS=0 IN UCN
	JAL	R4,PUTCH,,		:SEND UCN
	LIS	R0,0			:SET NULL CTL BYTE
	LB	R4,DCBLKS+DCBRFS,RDCB,	:GET CRM BYTE
	NHI	R4,XPRBIT		:IS IT TRANSPARENT?
	JEFS	AHDO13			:JUMP,IF NOT
	OHI	R0,XPRBIT		:SET XPR BIT ON
AHDO13
:	LB	R7,BBUFER+BBFLSZ-1,RBBA,RBBX	:GET CMD CODE (10/31/84 MIA)
	LB	R7,BBUFER+BBFLSZ-BBFPSZ+1,RBBA,RBBX :GET CMD CD (10/31/84 MIA)
	CLHI	R7,RMCMD		:IS IT READ MODIFIED?
	JE	AHDO14			:YES,JUMP
:RMA CONVERSION CODE. IF RMA CAME FROM HOST REPLACE IT BY RB (02/12/85 MIA).
	IF	RMDALL
	CLHI	R7,RMACMD		:IS IT READ MODIFIED ALL?
	JNFS	AHDO1A			:JUMP IF NOT
	LHI	R7,RMDASK		:INDICATE RMA RECEIVED
	STB	R7,DCBLKS+DCBLLV,RDCB,	:UPDATE RMA STATE BYTE
	LHI	R7,RBCMD		:GET READ BUFFER COMMAND CODE
	STB	R7,BBUFER+BBFLSZ-BBFPSZ+1,RBBA,RBBX :UPDATE CMD CODE
	JFS	AHDO14			:JUMP TO CONTINUE
AHDO1A	EQ	.
	EI
:END OF RMA CODE (02/12/85 MIA).
	CLHI	R7,RBCMD		:IS IT READ BUFFER CMD?
	JNFS	AHDO15			:JUMP,IF NOT
AHDO14
	OHI	R0,LCMBIT		:SET LCM BIT ON
	LHI	R4,LCMBIT		:SET TO LCM WAIT RSP
	STB	R4,DCBLKS+DCBDST,RDCB,	:SET DCB STATE TO WAIT LCM
AHDO15
:IF SCREEN SIZE 1920 E/W ALT IS REPLACED BY E/W TO BE COMPATIBLE WITH
:CMT (03/29/85 MIA).
	IF	EWALSW
	CLHI	R7,EWACMD		:IS IT E/W ALT?
	JNFS	AHDO1B			:JUMP IF NOT
	LB	R4,DCBLKS+DCBRFS,RDCB,	:GET DSP BYTE WITH SCREEN SIZE
	NHI	R4,SCRNSZ		:LEAVE SCREEN SIZE ONLY
	CHI	R4,SCRNS2		:SIZE 2 (1920)?
	JNFS	AHDO1B			:JUMP IF NOT
	LHI	R7,EWCMD		:REPLACE WITH E/W
	STB	R7,BBUFER+BBFLSZ-BBFPSZ+1,RBBA,RBBX :UPDATE THE BUFFER
AHDO1B	EQ	.
:END OF INSERTION FOR E/W ALT (03/29/85 MIA).
	EI
	LB	R4,DCBLKS+DCBSCC,RDCB,	:SAVE SCC
	NHI	R4,SNDTAK		:IS IT E-T-E ACK?
	JEFS	AHDO16			:JUMP,IF NOT ACK BIT ON
	OHI	R0,ACKBIT		:SET ACK BIT ON DSP HEADER
AHDO16
	JAL	R4,PUTCH,,		:SEND CONTROL BYTE
	LB	R0,DCBLKS+DCBOSQ,RDCB,	:GET OUT SEQ #
	AIS	R0,1			:INCREMENT SEQUENCE NUMBER
	STB	R0,DCBLKS+DCBOSQ,RDCB,	:UPDATE
	JAL	R4,PUTCH,,		:SEND SEQUENCE NUMBER
	LHI	R0,ESC.			:GET ESCAPE CHARACTER
	JAL	R4,PUTCH,,		:SEND ESC.
	SIS	RBCC,4			:DECREASE FOR UCN,CTR,SEQ #,ESC
	SIS	R2,4			:DECREASE FOR UCN,CTR,SEQ #,ESC
	J	AHDO20			:SKIP TO CONTINUE
AHDO17					:SUBSEGUENT SEGMENT
	THI	R0,DSHSDP		:IS IT SUBSEG-DSP?
	JE	AHDO20			:JUMP,IF NOT SUBSEG-DSP
	NHI	R0,@DSHSDP		:SET SUBSEG-DSP TO FALSE
	STB	R0,DCBLKS+DCBOCT,RDCB,	:UPDATE DCB
	LHI	R0,UCN			:SEND UCN ONLY
	OHI	R0,BIT.FS		:SEND UCN W/ FS=1
	JAL	R4,PUTCH,,
	SIS	RBCC,1			:DECREASE COUNT FOR UCN
	SIS	R2,1			:DECREASE COUNT FOR UCN
AHDO20					:COPY DATA CHAR FROM OUTPUT BB
					:TO ISIS ORING
	LB	R4,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	NHI	R4,DSHTRA		:MASK OFF TRAILER
	JEFS	AHDO27			:JUMP,IF NO NEED DSP-TRAILER
	CLHI	RBCC,1
	JE	AHDO23			:JUMP,IF IT IS DSP-TRAILER
AHDO27
	LR	RBCC,RBCC		:NO MORE DATA?(6/28/85/CHS)
	JLE	AHDO22			:YES, TO END (6/28/85/CHS)
	JAL	R4,GETBC,,		:GET CHAR FROM BUFFER
	SIS	RBCC,1			:DECREMENT PACKET COUNT
	JE	AHDO23			:JUMP,IF END OF DATA
AHDO21
	JAL	R4,PUTCH,,		:OUTPUT BYTE TO RING
	SIS	R2,1			:DECREMENT ISIS RCD COUNT
	JG	AHDO20			:NOT FINISH THIS ISIS RCD, REPAET
	LR	RBCC,RBCC		:ALSO END OF PACKET?
	JN	AHDO24			:NO, TO SAVE PARAMETERS, AND DISMISS
AHDO22
	JAL	R4,ELODR,,		:END CURRENT ISIS RCD
	LHI	R0,AHDOUP-PSEG		:SET OUTPUT PROC
	STH	R0,DCBLKS+DCBOUT,RDCB,
	JAL	R7,DLODTA,,		:FINISH PROCESS THIS CMD & BBS
					:(3.F01/06/04/87/DB/BEGIN)
:	RESET INACTIVITY TIMEOUT TIMER WHEN A COMPLETE OUTPUT IS MADE
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCTAB ENTRY
	LHL	R0,LUCTAB+LUIATO,R11,	:GET INACTIVITY TIMEOUT VALUE
	STH	R0,DCBLKS+DCBIA1,RDCB,	:RESET TIMER
					:(3.F01/06/04/87/DB/END)
	IF	BTRACE
	LIS	R4,BTROBT		:SEE IF TRACNG OUTPUT
	TBT	R4,BTRIOF,,		:...
	JER	R5			:NO, END OF ISIS/IIX OUTPUT
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT #
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R4,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R4,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LR	R4,RBCC			:R4 = BYTE COUNT
	OHI	R4,BTROUT+BTREND	:OUTPUT AND END
	STH	R4,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R4,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R4,FASTC,,		:ELSE, MUST BE FASTC
	ST	R4,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

	JR	R5			:END ISIS/IIX OUTPUT
 
AHDO23
	LB	R4,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL BYTE
	NHI	R4,DSHTRA		:MASK OFF TRAILER
	JE	AHDO21			:JUMP,IF NO NEED DSP-TRAILER
	CLHI	R4,DSHENQ		:IS IT OUT OF RANGE
	JG	AHDCRA,,		:CRASH,IF OUT OF RANGE
	LB	R0,DSPTLT,R4		:GET DSP TRAILER
	JAL	R4,PUTCH,,		:PUT DSP-TRAILER INTO ISIS
	SIS	R2,1			:UPDATE ISIS RCD CNT
	J	AHDO22			:JUMP TO END OF THE ISIS RCD

AHDO24					:END OF ISIS RCD , BUT NOT FULL PACKET
	JAL	R4,ELODR,,		:END CURRENT ISIS RCD
	BBST	RBBA,DCBLKS+DCBOBA,RDCB,:SAVE BB ADDR
	STH	RBBX,DCBLKS+DCBOBX,RDCB,:SAVE BB INDEX
	STH	RBCC,DCBLKS+DCBOCC,RDCB,:SAVE REMAINING PACKET LENGTH
	LHI	R0,AHDO25-PSEG		:SET UP NEXT ENTRY POINT
	STH	R0,DCBLKS+DCBOUT,RDCB,	:UPDATE
	JR	R5			:RETURN (DISMISS) - ISIS/IIX OUTPUT

:	AHDO25:	AFTER DISMISS, ENTER PROCESSING OUTPUT DSP DATA MSG HERE
:	------
:       BEGIN PROCESSING OUTPUT DATA MSG AGAIN AT THIS POINT
AHDO25
	BBLOAD	RBBA,DCBLKS+DCBOBA,RDCB,:RESTORE BB ADDR
	LH	RBBX,DCBLKS+DCBOBX,RDCB,:RESTORE BB INDEX
	LHL	RBCC,DCBLKS+DCBOCC,RDCB,:RESTORE PARTIAL PACKET LENGTH
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISI PORT #
	LB	R0,XLIMIT,R1,		:GET MAX XLIMIT
	SIS	R0,2
	CR	R0,RBCC			:ASSUME PARTIAL PACKET LENGTH < XLIMT
	JLFS	AHDO26			:NO, SKIP TO USE  XLIMIT
	LR	R0,RBCC			:ELSE, USE PARTIAL PACKET LENGTH
AHDO26
	LR	R2,R0			:R2 = ISIS RCD LENGTH
	AIS	R0,2			:INCLUDE PORT # (2)
	JAL	R4,SLOR,,		:START A NEW ISIS OUTPUT RECORD
	J	AHDO20			:TO CONTINUE COPY DATA INTO ISIS ORING
 
DSPTLT	BC	0,ETB,ETX,ITB,ENQ,0,0,0

:	AHDOCN	:RECEIVE CANCEL FROM SNA HOST
:	------
AHDOCN
	OHI	R0,DSHENQ		:SET DSP TRAILER TO ENQ
	IF	1-BSC503		:NOT BSC VERSION 503 (05/20/86 YLH)
	LB	R2,DCBLKS+DCBOSQ,RDCB,  : (05/20/86 YLH)
	SIS	R2,1			:DECREMENT SEQUENCE NUMBER (05/20/86 YLH)
	STB	R2,DCBLKS+DCBOSQ,RDCB,  : (05/20/86 YLH)
	EI				: (05/20/86 YLH)
	J	AHDOUC			:JUMP TO UPDATE DSP PACKET

:	AHDOAK	:RECEIVE E-T-E RSP FROM SNA
:	------
AHDOAK
	THI	R0,SNDTAK		:IS IT E-T-E ACK?
	JE	AHDCRA			:JUMP,IF IT IS NOT ACK RSP
	LB	R4,DCBLKS+DCBDST,RDCB,	:GET DCB BSCDSP STATE
	NHI	R4,@ACKBIT		:RESET ACK WAIT BIT
	STB	R4,DCBLKS+DCBDST,RDCB,	:RESET STATE TO INIT
	LB	R0,DCBLKS+DCBISQ,RDCB,	:GET EXPECTED ISQ-1
	STB	R0,M.ACK+8,,		:INSERT SEQ #
	LA	R9,M.ACK,,		:GET CANNED MSG PTR
	JAL	R6,SNDIIX,,		:JUMP TO SEND IIX MSG
	LHI	R0,AHDOUP-PSEG		:SET OUTPUT PROC
	STH	R0,DCBLKS+DCBOUT,RDCB,
	JAL	R7,DLODTA,,		:FINISH PROCESS THIS CMD & BBS
	JR	R5			:END ISIS/IIX OUTPUT
 
:	AHDCRA	:CRASH FOR THE NIO OUTPUT PROCESS
:	------
AHDCRA
	JAL	R10,CRASH,,
	BC	0,0,0,0A0


	EI	(HOSTIF&HDPSUP)

	FO	MAIN
	FO	GBLDEF
	FO	GIIX
	FO	GDSP
	FO	BSUB
	FO	CBKDEF
	FO	ISISC
	FO	FRNTND

	EM

   
	SUBTTL	SNA/HDSP NETWORK I/O HANDLER
:	MUDULE NAME IN COMMAND FILE -- DTIO00.F00

:	*******************************************
:	REVISION HISTORY --
:	*******************************************

:	THIS MODULE IS DESIGNED TO SUPPORT SNA/TIF DSP INTERFACE
:	NETWORK INPUT/OUTPUT SUPPORTING FUNCTIONS
:	-----------------------------------------------------------

	RA	0
	MO	.,STDPKG

	LO	MAIN
	LO	GBLDEF
	LO	GIIX
	LO	GDSP
	LO	BSUB
	LO	CBKDEF
	LO	ISISC
	LO	FRNTND
	LO	SMISCL
	LO	SHDPKG

	SEG	A.DATA

DTIOSV	HS	2			:DTIO SAVE AREA
TDSPMX	EQ	100			:MAX LENGTH OF TERMIANL DSP SEG

	SEG	A.CODE

	SUBTTL	(SNA-GIIX) ACTIVE DSP MODE IIX PROCESSOR

:	GENERATE ACTIVE DSP MODE IIX PROCESSING TABLE
:	=============================================

	IF	VHRSUP!VTISUP

:	DIALECT IIX TABLE FORE ACTIVE DSP MODE
	GENDIX(DDTACT)
	CHGDIX(DDTACT,DATAPK,ATD94M)
	CHGDIX(DDTACT,CLRIND,ATD95M)




:	ATD94M:	DATA PACKET
:	------
ATD94M
	J	ATDINP			:TO PROCESS DATA DIALECT

:	ATD95M:	CLEAR INDICATION
:	-----
ATD95M
	LHI	R0,$A3			:'DROPPED BY USER" REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,	:FOR DISCONNECT MSG
	J	CLRCIR			:TO CLEAR CIRCUIT

	EI	(VHRSUP!VTISUP)

	SUBTTL	(BSC-GDSP) BSC/DSP PROCESSES
:
:	GENERATE 'BSC/DSP' MESSAGES PROCESSING TABLE
:
	IF	VHRSUP

	GENDSP(SNRDSP)			:BSC/DSP PROCESS TABLE

	CHGDSP(SNRDSP,DSPI01,SNRIVC)	:01 - INVITATION TO CLEAR
	CHGDSP(SNRDSP,DSPI20,NDTCEN)	:20 - CIRCUIT ENABLE
	CHGDSP(SNRDSP,DSPI24,SNRCDS)	:24 - CIRSUIT DISCONNECT




:	SNRIVC:	INVITATION TO CLEAR
:	------
SNRCDS
SNRIVC
	LHI	R4,SNRIV1-PSEG		:TO READ REASON BYTE
	JR	R5
SNRIV1					:R0 = REASON CODE
	STB	R0,DCBLKS+DCBZAP,RDCB,
	JAL	R6,RLOGBB,,		:DELETE LOGON BUFFERLETS
	JAL	R6,ISIEND		:CLEAN UP ANY INPUT
	GL	ZPHCKT,ZAPHLU
	LHL	R11,DCBLKS+DCBLUC,RDCB,
	JAL	R6,ZPHCKT,,		:VHR LOOKS TO NETWORK AS TERMIF
	JAL	R6,ZAPHLU		:VHR LOOKS TO SNA AS HOSTIF
	J	IXENDN,,

	EI	(VHRSUP)

	SUBTTL (SNA-NNIO) BSC/DSP MODE - INPUT IIX DATA/DQ MESSAGES

	IF	VHRSUP!VTISUP

:	C094 DATA PACKET HANDLER
:	========================
:	ATDINP:	INPUT DATA HANDLER
:	------
:	INPUT HANDLER --
:	(1) MOVES IRING DATA INTO BUFFER
:	    (A) ACCORDING SEGMENT INFORMATION BIT TO ASSIGN TH AND RH
:	    (B) CONVERT STX,ETB AND ETX TO SNA PROTOCOL
:	    (C) STRIP OFF SOME SPECIAL CHARACTERS (SUCH AS ESC)
:	    (D) STORES BUFFER PTR INTO DCB
:	    (E) QUEUES BUFFER PTR INTO LUCB DATA QUEUE COMMAND LIST
:	(2) PERFORMS SOME FUNCTIONS FOR DSP PROTOCOLS
:	    (A) DATA PACKET WITH Q BIT ON (SUCH AS
:	        BACK PRESSURE,ERROR MESSAGE,STATUS MESSAGE,ACK MESSAGE...
:	    (B) CONVERTS PARTICULAR 3270BSC MESSAGES INTO SNA RU OR LOCALLY
:	        GENERATES RESPONSE TO THAT MESSAGE.
:	(3)
:	DEFINITION --
:	DCBICT - CONTAINS LAXTYEYF
:		WHERE L IS INPUT LCM BIT
:		WHERE A IS INPUT ACK BIT
:		WHERE X IS INPUT XPR BIT
:		WHERE T IS INPUT TRQ BIT
:		WHERE E IS PREVIOUS ETX FRAME INDICATOR
:		WHERE F IS FIRST SEGMENT INDICATOR
:		WHERE Y IS RESERVED
:	DCBDSH - CONTAINS YYYYDQCS
:		WHERE D IS DUMMY RU REQUIRED
:		WHERE Q IS FORWARD ABORT (WHEN DATA END WITH 'ENQ')
:		WHERE C IS CHAINING STATE FOR INPUT (FIRST=0,CONTINUE=1)
:		WHERE S IS SEGMENT STATE FOR INPUT (FIRST=0,CONTINUE=1)
:	(4)	FOR VHR CREATES 3 HEADER BYTES WITH DUMMY AID AND
:		CURSOR POSITION. SECOND CURSOR POSITION BYTE IS
:		USED TO REQUEST CHANGE DIRECTION IF DSP COMMAND
:		FINISHED WITH ETX.
ATDINP
	LHI	R4,ATDIN0-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO READ NEXT BYTE
ATDIN0					:R0 = DIALECT DATA FLAG
	STB	R0,DCBLKS+DCBDFG,RDCB,	:SAVE IN TO DCB
	LHI	R4,ATDIN1-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO READ NEXT BYTE
ATDIN1					:R0 = THE 1ST BYTE OF MSG LENGTH
	STH	R0,DCBLKS+DCBICC,RDCB,	:SAVE TO DCBICC
	LR	RBCC,R0			:IN CASE DIMISS AT HERE (8/14/84/CHS)
	LHI	R4,ATDIN2-PSEG		:SET UP NEW ENTRY POINT
	JR	R5			:TO READ NEXT BYTE
ATDIN2					:R0 = 2ND BYTE OF LENGTH
	LHL	R4,DCBLKS+DCBICC,RDCB,	:GET 1ST BYTE
	SLHLS	R4,8			:SHIFT BYTE LEFT
	OR	R0,R4			:GET LENGTH IN HW
	STH	R0,DCBLKS+DCBIPL,RDCB,	:SAVE IT INTO DCB
	LB	R0,DCBLKS+DCBDFG,RDCB,	:GET DATA PACKET FLAG
	THI	R0,QBIT			:DQ PACKET
	JN	ATDINQ			:YES, SPECAIL HANDLE

	IF	BTRACE
	LIS	R0,BTRIBT		:SEE IF TRACNG INPUT
	TBT	R0,BTRIOF,,		:...
	JE	ATDINN			:NO, JUMP
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R0,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R0,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LHL	R0,DCBLKS+DCBIPL,RDCB,	:R0 = IPL COUNT
	OHI	R0,BTRINP+BTRBEG	:INPUT AND BEGIN
	STH	R0,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R0,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R0,FASTC,,		:ELSE, MUST BE FASTC
	ST	R0,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

ATDINN
:
:BEGIN (05/05/86 YLH)
:
	IF	VTISUP&VHRSUP
	LHL	R11,DCBLKS+DCBLUC,RDCB, :SET UP THE CORRESPONDING LUCTAB PTR
	LB	R0,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	THI	R0,LUVTIF		:VTI FUNCTION?
	JN	ADTIP5			:JUMP IF SO
	EI
	IF	VHRSUP
	THI	R0,LUSVCP		:SVC LOGON IN PROGRESS?
	JE	ADTIP5			:NO, NORMAL DATA PACKET PROCESSING
	LIS	R6,0C			:YES, LOGON ERROR
	AHM	R6,DCBLKS+DCBIPL,RDCB,
ADTIP0	SIS	R6,1			:DECREMENT CHAR COUNT
	LR	R6,R6			:ALL STRIPPED?
	JEFS	ADTIP1			:YES
	LHI	R4,ADTIP0-PSEG		:STRIP OFF COMMAND HEADER
	JR	R5			:NO, DISCARD NEXT CHAR
:
:FILL IN CADR1 AND CADR2 AND SEND LOGON REPLY RU TO VTR. THIS CODE ASSUMES
:THAT REPLY RU IS 1 SEGMENT 1 ELEMENT CHAIN. IF NOT THIS CODE SHOULD BE
:CHANGED LATER.
:
ADTIP1	BBL	R3,DCBLKS+DCBIBH,RDCB,	:GET  POINTER TO PREPARED REPLY
	LHI	R6,VHRCNT		:PREPARE CONTINUE LOGON
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA1,R3,	:FILL CADR1
	LIS	R6,VHRCDR		:PREPARE CADR2(CD)
	LB	R6,BAIOIC,R6		:6/8 BIT CONVERSION
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:FILL CADR2
	LHI	R6,VHREZP		:PREPARE ERROR CODE FOR VTR
	STB	R6,BBUFER+FID2LN+RHLENG+VHRCDE,R3,	:SET ERROR CODE
:
:	PASS THE DSP TEXT TO THE SNA ONLY IF IT IS A MANUAL LOGON
:
	THI	R0,LUMNLG		:IS THIS A MANUAL LOGON?
	JE	ADTIP4			:NO, SEND REPLY RU TO THE SNA
:
:	FOR MANUAL LOGON, THE DSP DATA IS PASSED TO THE SNA
:	CREATE 3270 WRITE COMMAND HEADER
:
	LR	RBBA,R3			:LET RBBA HAS THE BUFFER BASE ADDR.
	LHL	RBCC,DCBLKS+DCBALU,RDCB, 	:GET MESSAGE LENGTH
	LHI	RBBX,FID2LN+RHLENG+VHRCDE+1	:INDEXING BEYOND THE ERROR CODE
	JAL	R6,PTVHRH,,
ADTIP2	LHI	R4,ADTIP3-PSEG		:GET ERROR MSG
	JR	R5
ADTIP3	JAL	R6,PTIBC,,		:PUT IT INTO THE BUFFER
	LCS	R0,1			:DECREMENT THE BYTE COUNT
	AHM	R0,DCBLKS+DCBIPL,RDCB,
	JGBS	ADTIP2
ADTIP4	LHI	R6,L.ERCK		:MAKE IT UNRECOVERABLE ERROR
	STB	R6,DCBLKS+DCBSTA,RDCB,
	LHI	R2,NSETEM^8!NSDTCD	:ASSUME SINGLE SEG, SINGLE RU CHAIN
	JAL	R6,QDIFSN,,		:SEND IT TO SNA
	JR	R5			:AND RETURN
:
:	NORMAL DATA PACKET HANDLING PROCEEDING HERE
:
:END (05/05/86 YLH)
:
	EI	(VHRSUP)

ADTIP5	LB	R0,DCBLKS+DCBDSH,RDCB,	:GET DSP STATUS BYTE
	THI	R0,DSHCNT		:M-BIT IN PREVIOUS PACKET?
	JN	ATDI1Y			:JUMP IF SO

	LHI	R4,ATDIN3-PSEG		:TO READ UCN
	JR	R5			:TO READ NEXT BYTE
ATDIN3					:R0 = UCN BYTE, IGNORE
	NHI	R0,BIT.FS
	JE	ATDIN4			:JUMP,IF IT IS 1ST SEG
	LB	R6,DCBLKS+DCBICT,RDCB,	:GET INPUT CONTROL BYTE
	NHI	R6,@FIRBIT		:TURN OFF 1ST SEGMENT BIT
	STB	R6,DCBLKS+DCBICT,RDCB,	:REPLACE IT IN DCB
	LCS	R0,1			:NOT INCLUDE UCN BYTE
	J	ATDI11			:SKIP, TO CONINUTE
ATDIN4
	LB	R6,DCBLKS+DCBICT,RDCB,	:GET INPUT CONTROL BYTE
	THI	R6,ETXBIT		:IS PREVIOUS ETX/ETB?
	JN	ATDIN5			:JUMP,IF PREVIOUS IS END WITH ETX
:	ERROR,SEND CMD/RSP UNDELIVERED
:	-----------------------------
	AR	R14,R2			:FLUSH THE REMANING CHAR (10/6/84 MIA)
	LB	R6,DCBLKS+DCBISQ,RDCB,	:GET EXPECTED ISQ-1
	STB	R6,M.ERR+7,,		:STORE SEQ OF PREV DATA (10/6/84 MIA)
	LHI	R6,XMTINV		:SET 'XMT INVALID' FORMAT
	STB	R6,M.ERR+8,,		:STORE ERROR CODE
	EXBR	R6,R6
	STB	R6,M.ERR+6,,		:STORE MSG ID
	LA	R9,M.ERR-1,,		:GET CANNED MSG PTR
	JAL	R6,SNDIIX,,		:JUMP TO SEND IIX MSG
	J	IXENDN,,		:END OF IIX DATA
ATDIN5
	NHI	R6,@ETXBIT		:TURN OFF ETX/ETB
	STB	R6,DCBLKS+DCBICT,RDCB,	:UPDATE INPUT CONTROL BIT
	LIS	R4,0
	STB	R4,DCBLKS+DCBDSH,RDCB,	:CLEAR DCBDSH
	LHL	R4,DCBLKS+DCBRUL,RDCB,	:GET RU LENGTH
	STH	R4,DCBLKS+DCBRUS,RDCB,	:INIT CURRENT RU LENGTH
	LHL	R4,DCBLKS+DCBSGL,RDCB,	:GET SEGMENT LENGTH
	STH	R4,DCBLKS+DCBSGS,RDCB,	:INIT CURRENT SEGMENT LENGTH
	LHI	R4,ATDIN6-PSEG		:TO READ CONTROL BYTE
	JR	R5			:RETURN FOR NEXT BYTE
ATDIN6
	THI	R0,LCMBIT		:IS IT LCM RESPONSE
	JE	ATDIN7			:JUMP,IF NOT LCM
	LB	R4,DCBLKS+DCBDST,RDCB,	:GET DCB BSCDSP STATE
	NHI	R4,@LCMBIT		:RESET LCMBIT
	STB	R4,DCBLKS+DCBDST,RDCB,	:RESET STATE TO INIT
ATDIN7
	THI	R0,ACKBIT		:IS IT ACKBIT ON?
	JE	ATDIN8			:JUMP,IF NOT
	LB	R4,DCBLKS+DCBDST,RDCB,	:GET DCB BSCDSP STATE
	OHI	R4,ACKBIT		:SET TO WAIT FOR ACK RSP
	STB	R4,DCBLKS+DCBDST,RDCB,	:RESET STATE TO INIT
ATDIN8
	NHI	R0,LCMBIT!ACKBIT!XPRBIT	:MASK OFF UNWANTED BITS
	OHI	R0,FIRBIT		:THIS IS 1ST SEGMENT MESSAGE
	STB	R0,DCBLKS+DCBICT,RDCB,	:SAVE IT IN DCB
	LHI	R4,ATDIN9-PSEG		:TO READ ISQ BYTE
	JR	R5			:RETURN FOR NEXT BYTE
ATDIN9					:R0 = ISQ
	LB	R6,DCBLKS+DCBISQ,RDCB,	:GET EXPECTED ISQ-1
	AIS	R6,1			:R6 = EXPECTED ISQ
	NHI	R6,0FF			:ONE BYTE ONLY
	CR	R6,R0			:COMPARE
	JN	CLRCIR			:NOT THE SAME
	STB	R0,DCBLKS+DCBISQ,RDCB,	:SAVE NEW ISQ INTO DCB
	LCS	R0,3			:UCN+CTL+ISQ
ATDI11
	AHM	R0,DCBLKS+DCBIPL,RDCB,
ATDI1Y	JAL	R6,SINPBB,,		:SET UP NEW BUFFERLET
	AIS	RBBX,FID2LN		:UPDATE TH OFFSET
	LCS	R0,FID2LN		:PREPARE -6
	AHM	R0,DCBLKS+DCBSGS,RDCB,	:ADJUST REMAINING SEGMENT LENGTH
	LB	R6,DCBLKS+DCBDSH,RDCB,	:GET CURRENT SNA HEADER STATE
	THI	R6,DSHSEG		:IS IT FIRST?
	JN	ATDI12			:JUMP,IF NOT 1ST SEGMENT STATE
	AIS	RBBX,RHLENG		:1ST SEGMENT,UPDATE RH OFFSET
	LCS	R0,RHLENG		:PREPARE -3
	AHM	R0,DCBLKS+DCBSGS,RDCB,	:ADJUST REMAINING SEGMENT LENGTH
	THI	R6,DSHCHN		:FIRST IN CHAIN?
	JN	ATDI12			:JUMP IF NOT
	IF	VHRSUP&VTISUP
	LHL	R6,DCBLKS+DCBLUC,RDCB,	:GET POINTER TO LUCB
	LB	R6,LUCTAB+LUCVHR,R6,	:GET VHR STATE BYTE
	THI	R6,LUVHRF		:VHR FUNCTION?
	JE	ATDI1B			:JUMP IF NOT
	EI
	IF	VHRSUP
:CREATE VHR HEADER FOR THE FIRST RU IN THE CHAIN.
	LHI	R0,AIDENT		:GET ENTER AID
	STB	R0,BBUFER+BBFLSZ-BBFPSZ+VHRAID+1,RBBX,RBBA :PUT IT IN THE BUF
	LHI	R0,SP.			:DUMMY CADR1&CADR2
	STB	R0,BBUFER+BBFLSZ-BBFPSZ+VHRCA1+1,RBBX,RBBA :INIT CADR1
	STB	R0,BBUFER+BBFLSZ-BBFPSZ+VHRCA2+1,RBBX,RBBA :INIT CADR2
	AIS	RBBX,VHRCA2+1		:ADVANCE BUFFER INDEX
	LCS	R0,VHRCA2+1		:PREPARE -3
	AHM	R0,DCBLKS+DCBSGS,RDCB,	:COUNT SEGM SIZE
	AHM	R0,DCBLKS+DCBRUS,RDCB,	:COUNT RU SIZE
	EI
ATDI1A	LHI	R4,ATDI1B-PSEG		:SET UP FOR ESCAPE
	JR	R5			:AND RETURN

:NEXT CHARACTER MUST BE ESCAPE.
ATDI1B	LCS	R4,1			:PREPARE -1
	AHM	R4,DCBLKS+DCBIPL,RDCB,	:LESS 1 CHAR IN PACKET
	CHI	R0,ESC.			:ESCAPE
	JN	CLRCIR			:JUMP IF NOT
	IF	KBRTSW
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET SNA STATE BYTE
	NHI	R4,@DSHKBR		:RESET KEYBOARD RESTORE BIT
	OHI	R4,DSHWRT		:SET CHECK FOR CMD BIT
	STB	R4,DCBLKS+DCBDSH,RDCB,	:UPDATE SNA STATE BYTE
	EI
ATDI12
	LHI	R4,ATDI13-PSEG		:SET UP NEW ENTRY
	JR	R5			:TO READ NEXT BYTE
ATDI13					:R0 = DATA BYTE
	IF	KBRTSW
:FIRST 2 BYTES AFTER ESCAPE ARE CHECKED. IF THIS IS A WRITE TYPE
:COMMAND WCC IS CHECKED FOR KEYBOARD RESTORE.
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET SNA STATE BYTE
	THI	R4,DSHWRT!DSHKBR	:ONE OF FIRST 2 BYTES?
	JE	ATDI1K			:JUMP IF NOT
	THI	R4,DSHKBR		:WCC BYTE?
	JN	ATDI1R			:JUMP IF SO

:THIS IS 3270 COMMAND. IF THIS IS A WRITE TYPE COMMAND PREPARE FOR
:WCC.
	NHI	R4,@DSHWRT		:RESET CMD BIT
	CHI	R0,WCMD			:WRITE COMMAND?
	JEFS	ATDI1W			:JUMP IF SO
	CHI	R0,EWCMD		:ERASE/WRITE?
	JEFS	ATDI1W			:JUMP IF SO
	CHI	R0,EWACMD		:ERASE/WRITE ALTERNATE?
	JN	ATDI1P			:JUMP IF NOT
ATDI1W	OHI	R4,DSHKBR		:NEXT BYTE IS WCC
	J	ATDI1P			:JUMP TO CONTINUE

:THIS IS WCC. CHECK KEYBOARD RESTORE AND SHOW IT IN DSP STATE BYTE.
ATDI1R	LB	R6,DCBLKS+DCBICT,RDCB,	:GET DSP INPUT STATE BYTE
	NHI	R6,@KBRBIT		:ASSUME NO KEYBOARD RESTORE
	NHI	R4,@DSHKBR		:CLEAR WCC INDICATION
	THI	R0,WCCKBR		:WCC WITH KEYBOARD RESTORE?
	JEFS	ATDI1Q			:JUMP IF NOT
	OHI	R6,KBRBIT		:SHOW KEYBOARD RESTORE
ATDI1Q	STB	R6,DCBLKS+DCBICT,RDCB,	:UPDATE DSP INPUT STATE BYTE
ATDI1P	STB	R4,DCBLKS+DCBDSH,RDCB,	:UPDATE SNA STATE BYTE
ATDI1K	EQ	.
	EI	(KBRTSW)

	AIS	RBCC,1			:INCREMENT INPUT CHAR COUNT
	AIS	RBBX,1
	LB	R6,DCBLKS+DCBICT,RDCB,	:GET CONTROL BYTE
	THI	R6,XPRBIT		:IS IT TRANSPARENT?
	JE	ATDI14			:JUMP,IF NOT
ATDI14
	STB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA
	LR	RBBX,RBBX		:CHECK BUFFERLET FULL OR NOT
	JNFS	ATDI15			:BUFFERLET NOT FULL YET, SKIP
	JAL	R6,GINPBB,,		:ELSE, GET A NEW BUFFERLET
ATDI15
	LHL	R4,DCBLKS+DCBIPL,RDCB,	:GET PACKET LENGTH
	SR	R4,RBCC			:END OF PACKET?
	JE	ATDI16			:END OF PACKET
	JL	DOVFER			:OVERFLOW
	LR	R6,R4			:COPY # OF REMAINING CHARS IN PKT
	SIS	R4,1			:TEST IF NEXT WILL BE LAST IN PACKET
	JNFS	ATDI1V			:JUMP IF NOT
	LB	R4,DCBLKS+DCBDFG,RDCB,	:GET DSP FLAG BYTE
	THI	R4,MBIT			:M-BIT ON?
	JE	ATDI1Z			:NO NEED TO END SEGM IF NOT
ATDI1V	LCS	R4,1			:PREPARE -1
	AHM	R4,DCBLKS+DCBRUS,RDCB,	:ADJUST REMAINING RU LENGTH
	JG	ATDI1X			:JUMP IF NOT EXHAUSTED
	STH	R6,DCBLKS+DCBIPL,RDCB,	:ADJUST NUMBER OF REMIANING CHARS
	LHL	RBCC,DCBLKS+DCBSGL,RDCB, :GET MAX SEG SIZE
	SH	RBCC,DCBLKS+DCBSGS,RDCB, :NUMBER OF CHARS IN SEGM
	AIS	RBCC,1			:DID NOT COUNT LAST CHAR YET
	ST	R2,DTIOSV,,		:SAVE THE REGISTER
	JAL	R6,DINRUX		:OTHERWISE FINISH WITH RU
	L	R2,DTIOSV,,		:RESTORE THE REGISTER
	J	ATDI1Y			:JUMP TO CONTINUE
ATDI1X	AHM	R4,DCBLKS+DCBSGS,RDCB,	:ADJUST REMAINING SEGM LENGTH
	JG	ATDI1Z			:JUMP IF NOT EXHAUSTED
	STH	R6,DCBLKS+DCBIPL,RDCB,	:ADJUST CURRENT LENGHT OF PKT
	LHL	RBCC,DCBLKS+DCBSGL,RDCB, :GET MAX SEGM LENGTH
	SH	RBCC,DCBLKS+DCBSGS,RDCB, :LENGHT TO SEND
	ST	R2,DTIOSV,,		:SAVE THE REGISTER
	JAL	R6,DINSGX		:FINISH WITH THE SEGMENT
	L	R2,DTIOSV,,		:RESTORE THE REGISTER
	J	ATDI1Y			:JUMP TO CONTINUE
ATDI1Z	LHI	R4,ATDI13-PSEG		:SET UP NEW ENTRY
	JR	R5			:TO READ NEXT BYTE
ATDI16
	LB	R0,BBUFER+BBFLSZ-BBFPSZ,RBBX,RBBA
	LB	R6,DCBLKS+DCBICT,RDCB,	:GET CONTROL BYTE
	THI	R6,XPRBIT		:IS IT TRANSPARENT?
	JE	ATDI17			:JUMP,IF NOT
ATDI17
	JAL	R6,DINTTX		:QUEUE IT TO NWKC->SNA DATA-Q
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET SNA STATE INF.
	THI	R4,DSHDRU		:IS IT NEED TO SEND DUMMY RU?
	JE	ATDI18			:JUMP, IF NOT
	JAL	R6,SINPBB,,		:GET NEW BUFFERLET
	LHI	RBCC,FID2LN+RHLENG	:SET UP BYTE COUNT
	JAL	R6,DINTTX		:QUEUE IT TO NWKC->SNA DATA-Q

:FOR VHR FUNCTION SEND A DUMMY VHR HEADER WITH CHANGE DIRECTION IF
:CHANGE DIRECTION IS REQUESTED.
	IF	VTISUP&VHRSUP
	LHL	R4,DCBLKS+DCBLUC,RDCB,	:GET POINTER TO LUCB
	LB	R4,LUCTAB+LUCVHR,R4,	:GET VHR STATE
	THI	R4,LUVHRF		:VHR FUNCTION?
	JE	ATDI18			:JUMP IF NOT
	EI
	IF	VHRSUP
	LB	R4,DCBLKS+DCBICT,RDCB,	:GET DSP INFO BYTE
	THI	R4,CDRBIT		:CHANGE DIRECTION?
	JE	ATDI18			:JUMP IF NOT
	NHI	R4,@CDRBIT		:CLEAR CHANGE DIRECTION
	STB	R4,DCBLKS+DCBICT,RDCB,	:UPDATE DSP INFO BYTE
	JAL	R6,SINPBB,,		:GET NEW BUFFERLET
	LHI	R4,AIDENT		:GET ENTER AID
	STB	R4,BBUFER+FID2LN+RHLENG+VHRAID,R3,	:PUT IT IN BUFFER
	LHI	R4,SP.			:GET DUMMY CADR1
	STB	R4,BBUFER+FID2LN+RHLENG+VHRCA1,R3,	:PUT IT IN BUFFER
	LIS	R4,VHRCDR		:GET CHANGE DIRECTION FOR VHR HEADER
	LB	R4,BAIOIC,R4,		:6/8 BIT CONVERSION
	STB	R4,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:PUT IT IN BUFFER
	LHI	RBCC,FID2LN+RHLENG+VHRCA2+1	:LENGTH OF RU
	JAL	R6,DINFRU		:SEND 1 SEGMENT RU
	EI

ATDI18
ATDI19

	IF	BTRACE
	LIS	R0,BTRIBT		:SEE IF TRACNG INPUT
	TBT	R0,BTRIOF,,		:...
	JE	ATDI20			:NO, SKIP
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R0,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R0,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LHL	R0,DCBLKS+DCBIPL,RDCB,	:R0 = IPL COUNT
	OHI	R0,BTRINP+BTREND	:INPUT AND END
	STH	R0,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R0,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R0,FASTC,,		:ELSE, MUST BE FASTC
	ST	R0,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

ATDI20
	LIS	R0,0
	BBST	R0,DCBLKS+DCBIBH,RDCB,
	BBST	R0,DCBLKS+DCBIBA,RDCB,
	STH	R0,DCBLKS+DCBICC,RDCB,
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R0,LUCTAB+LUIATO,R11,	:GET SYSGEN INA. TIMEOUT VAL.
	STH	R0,DCBLKS+DCBIA1,RDCB,	:SET INA. TIMEOUT IN DCB
	J	IXENDN,,		:END OF IIX INPUT

:
:	DQ PACKET HANDLING
:	-----------------
:
ATDINQ
	J	GDSPIX,,			:TO PROC Q-PACKET & DSP

:	DOVFER:	DATA OVERFLOW
:	-------
DOVFER
	JAL	R10,CRASH,,
	BC	0,0,0,088

:	DPICR1:	INPUT DSP CONTROL ERROR
:	-------
DPICR1
	JAL	R10,CRASH,,
	BC	0,0,0,088

	EI	(VHRSUP!VTISUP)

	SUBTTL (SNA-NNIO) BSC/DSP MODE - NWKC->SNA DATA-Q

	IF	VHRSUP!VTISUP

:	DINFRU.
:	THIS ROUTINE SENDS A COMPLETE 1-SEGMENT RU CHAN WITH CHANGE DIRECTION.
DINFRU	IF	BRKTSW			:FOR HALF-DUPLEX VTI
	LHI	R2,NSDTCD!NSDTEB	:BRAKET TERMINATION PROHIBITED
	ELSE
	LHI	R2,NSDTCD		:1 SEGMENT RU WITH CHANGE DIRECTION
	EI
	J	DINTTE			:JUMP TO SEND IT

:	DINRUX.
:	THIS ROUTINE IS USED TO SEND THE LAST SEGMENT OF RU WHICH IS NOT LAST.
DINRUX	LHL	R2,DCBLKS+DCBRUL,RDCB,	:GET MAX RU LENGTH
	STH	R2,DCBLKS+DCBRUS,RDCB,	:INIT CURRENT RU LENGTH
	LHI	R2,NSDTFC		:ASSUME FIRST, NOT LAST CHAIN
	JFS	DINSG0			:JUMP TO CONTINUE

:	DINSGX.
:	THIS ROUTINE IS USED TO SEND AN INTERMEDIATE SEGMENT TO SNA.
DINSGX	LHI	R2,NSDTFS!NSDTFC	:ASSUME 1ST/NOT LST SEGM&CHAIN
DINSG0	LHL	R4,DCBLKS+DCBSGL,RDCB,	:GET MAX SEGM SIZE
	STH	R4,DCBLKS+DCBSGS,RDCB,	:INIT CURRENT SEGM SIZE
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET DSP STATUS BYTE
	THI	R4,DSHSEG		:1ST SEGMENT IN RU?
	JEFS	DINSG1			:JUMP IF SO
	OHI	R2,NSDTLS		:INDICATE NOT 1ST SEGMENT
DINSG1	THI	R4,DSHCHN		:1ST RU IN CHAIN
	JEFS	DINSG2			:JUMP IF SO
	OHI	R2,NSDTLC		:INDICATE NOT 1ST IN CHAIN
DINSG2	THI	R2,NSDTFS		:LAST SEGMENT?
	JEFS	DINSG3			:JUMP IF SO
	OHI	R4,DSHSEG		:NEXT IS NOT 1ST SEGM
	JFS	DINSG4			:JUMP TO CONTINUE
DINSG3	NHI	R4,@DSHSEG		:NEXT SEGM IS THE FIRST
	OHI	R4,DSHCHN		:BUT NOT 1ST IN CHAIN
DINSG4	STB	R4,DCBLKS+DCBDSH,RDCB,	:UPDATE DSP STATUS
	J	DINTTE			:AND SEND DATA TO SNA

:	DINTTX:	QUEUE ISIS/INPUT (DSP)DATA TO NWKC->SNA DATA-Q
:	------
:	INPUT:	RDCB, DCBIBH SET UP
:		R6 = LINK REGISTER
:	OUTPUT:
:	DESTROYED: R0, R2, R3, R4, R7, R11
DINTTX	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET DSP STATUS
	THI	R4,DSHDRU		:REQUEST FOR DUMMY RU?
	JN	DINTTA			:JUMP IF SO
	LHL	RBCC,DCBLKS+DCBSGL,RDCB,	:GET MAX SEGM SIZE
	SH	RBCC,DCBLKS+DCBSGS,RDCB,	:LENGTH TO SEND NOW
	AIS	RBCC,1			:LAST DATA BYTE WAS NOT COUNTED YET
	LB	R7,DCBLKS+DCBDFG,RDCB,	:GET DSP FLAG BYTE
	THI	R7,MBIT			:PACKET TO CONTINUE
	JE	DINTT4			:JUMP IF NOT

:M-BIT IS SET. MESSAGE WILL BE CONTINUED. SEND THE ACCUMULATED DATA
:AS SNA SEGMENT IF RU SIZE IS NOT EXHAUSTED.
	OHI	R4,DSHCNT		:INDACATE M-BIT FOR NEXT PKT
	STB	R4,DCBLKS+DCBDSH,RDCB,	:UPDATE DSP STATUS BYTE
	LCS	R4,1			:PREPARE -1
	AHM	R4,DCBLKS+DCBRUS,RDCB,	:COUNT LAST BYTE IN RU LENGTH
DINTT1	ST	R6,DTIOSV,,		:SAVE LINK REGISTER
	LHL	R4,DCBLKS+DCBRUS,RDCB,	:GET REMAINING RU LENGTH
	JGFS	DINTT2			:JUMP IF NOT EXHAUSTED
	JAL	R6,DINRUX		:OTHERWISE FINISH THIS RU
	JFS	DINTT3			:JUMP TO CONTINUE
DINTT2	JAL	R6,DINSGX		:FINISH WITH THIS SEGMENT
DINTT3	L	R6,DTIOSV,,		:RESTORE LINK REGISTER
	JR	R6			:AND RETURN

:M-BIT IS NOT SET. THIS IS THE LAST X-25 PACKET. LAST CHARACTER IS
:IN R0 AND MUST BE ONE OF VALID DSP TRAILERS (ETX, ETB, ITB, OR ENQ).
DINTT4	CHI	RBCC,FID2LN+1		:TRAILER-ONLY PACKET?
	JNFS	DINTT5			:JUMP IF NOT
	SIS	RBCC,1			:ADJUST THE COUNTER
DINTT5	NHI	R4,@DSHCNT		:RESET M-BIT FOR NEXT PACKET
	STB	R4,DCBLKS+DCBDSH,RDCB,	:UPDATE DSP STATUS
	CHI	R0,ETX			:TRAILER EXT?
	JEFS	DINTTT			:JUMP IF SO
	CHI	R0,ETB			:TRAILER ETB?
	JE	DINTTB			:JUMNP IF SO
	CHI	R0,ITB			:TRAILER ITB?
	JE	DINTT1			:JUMP IF SO
	CHI	R0,ENQ			:TRAILER ENQ?
	JE	DINTT7			:JUMP IF SO
	J	CLRCIR			:OTHERWISE INVALID TRAILER

:ETX WAS THE TRAILER. IT IS DIFFERENT FROM ETB IN ONLY ONE RESPECT:
:CHANGE DIRECTION MUST BE INDICATED TO SNA. FOR NOW SHOW CHANGE
:DIRECTION IN DSP INFO BYTE. ALSO, IF KBRTSW IS ON CHANGE DIRECTION
:IS GENERATED ONLY IF WCC INDICATED KEYBOARD RESTORE.
DINTTT	LB	R4,DCBLKS+DCBICT,RDCB,	:GET DSP INFO BYTE
	IF	KBRTSW			:IF KEYBOARD RESET SWITCH ENABLED
	THI	R4,KBRBIT		:KB RESET IN WCC?
	JEFS	DINTTB			:JUMP IF NOT
	EI
	OHI	R4,CDRBIT		:SHOW CHANGE DIRECTION
	STB	R4,DCBLKS+DCBICT,RDCB,	:UPDATE DSP INFO BYTE

:TRAILER WAS ETB. CLEAR DSP STATUS BYTE. INDIIATE TO SEND DUMMY RU
:IF THIS IS NOT FIRST SEGEMNT OF THE FIRST RU IN CHAIN. FOR THE FIRST SEGEMENT
:OF THE FIRST CHAIN INDICATE CHANGE DIRECTION TO SNA IF INDICATED
:IN DSP INFORMATION BYTE.
DINTTB	LB	R4,DCBLKS+DCBICT,RDCB,	:GET INPUT CONTROL BYTE
	OHI	R4,ETXBIT		:FINISHED WITH THIS DSP MSG
	STB	R4,DCBLKS+DCBICT,RDCB,	:UPDATE INPUT CONTROL BYTE
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET DSP STATUS BYTE
	THI	R4,DSHCHN!DSHSEG	:1ST SEGM OF 1ST RU IN CHAIN
	JE	DINTTF			:JUMP IF SO
	ST	R6,DTIOSV,,		:SAVE LINK REGISTER
	JAL	R6,DINRUX		:SEND THIS RU
	L	R6,DTIOSV,,		:RESTORE LINK REGISTER
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET DSP STATUS
	NHI	R4,@(DSHCHN!DSHSEG!DSHCEL)	:CLEAR STATE BITS
	OHI	R4,DSHDRU		:OTHERWISE INDICATE DUMMY RU
	STB	R4,DCBLKS+DCBDSH,RDCB,	:UPDATE DSP STATUS
	JR	R6			:AND RETURN

:FIRST SEGMENT OF FIRST RU IN CHAIN. ALSO LAST SEGMENT OF LAST RU.
:ALSO CHAGE DIRECTION MIGHT BE REQUIRED. FOR VHR CHANGE DIRECTION
:IS ALWAYS INDICATED TO SNA, BUT IT SHOULD ALSO BE SET IN VHR
:HEADER IF THE CHANGE OF DIRCTION IS SHOWN IN DSP INFORMATION BYTE.
DINTTF	NHI	R4,@(DSHCHN!DSHSEG!DSHCEL)	:CLEAR STATE BITS
	STB	R4,DCBLKS+DCBDSH,RDCB,	:UPDATE DSP STATUS
	IF	VTISUP&VHRSUP
	LHL	R4,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R4,LUCTAB+LUCVHR,R4,	:GET VHR STATE
	THI	R4,LUVHRF		:VHR FUNCTION?
	JN	DINTTV			:JUMP IF SO
	EI
	IF	VTISUP
	XR	R2,R2			:ASSUME NO CHANGE DIRECTION
	LB	R4,DCBLKS+DCBICT,RDCB,	:GET DSP INFO BYTE
	THI	R4,CDRBIT		:CHANGE DIRECTION?
	JE	DINTTE			:JUMP IF NOT
	NHI	R4,@CDRBIT		:CLEAR CHANGE DIRECTION
	STB	R4,DCBLKS+DCBICT,RDCB,	:UPDATE DSP INFO BYTE
	IF	BRKTSW			:FOR HALF-DUPLEX VTI
	LHI	R2,NSDTCD!NSDTEB	:BRACKET TERMINATION PROHIBITED
	ELSE
	LHI	R2,NSDTCD		:SET CHANGE DIRECTION
	EI
	J	DINTTE			:JUMP TO CONTINUE
	EI
	IF	VHRSUP
DINTTV	LHI	R2,NSDTCD		:SET CHANGE DIRECTION
	LB	R4,DCBLKS+DCBICT,RDCB,	:GET DSP INFO BYTE
	THI	R4,CDRBIT		:CHANGE DIRECTION?
	JE	DINTTE			:JUMP IF NOT
	NHI	R4,@CDRBIT		:CLEAR CHANGE DIRECTION
	STB	R4,DCBLKS+DCBICT,RDCB,	:UPDATE DSP INFO BYTE
	BBLOAD	R3,DCBLKS+DCBIBH,RDCB,	:GET POINTER TO HEAD BUFFER
	LIS	R4,VHRCDR		:CHANGE DIRECTION IN VHR HEADER
	LB	R4,BAIOIC,R4,		:6/8 BIT TRANSLATION
	STB	R4,BBUFER+FID2LN+RHLENG+VHRCA2,R3,	:PUT IT IN CADR2
	J	DINTTE			:JUMP TO CONTINUE
	EI

:THE TRAILER IS ENQ. INDICATE CANCEL TO SNA.
DINTT7
	LB	R4,DCBLKS+DCBDSH,RDCB,	:GET CURRENT SNA STATE
	OHI	R4,DSHCEL		:SET CANCEL STATE
	STB	R4,DCBLKS+DCBDSH,RDCB,	:STORE IN DCB
:
:BEGIN (03/31/87 YLH)
:
	LR	R2,R4			:COPY CURRENT SNA STATE
	NHI	R2,DSHSEG		:NEED SEG. INFO. ONLY
	SLLS	R2,1			:PUT IT IN THE RIGHT PLACE
	NHI	R4,DSHCHN		:NEED CHAIN INFO. ONLY
	SLLS	R4,2			:PUT IT IN THE RIGHT PLACE
	OR	R2,R4			:PUT SEG. AND CHAIN INFO. IN R2
:
:END (03/31/87 YLH)
:
	OHI	R2,NSDTCN		:CANCEL CURRENT DATA
	J	DINTTE			:JUMP TO SEND DATA TO QUEUE

DINTTA
	NHI	R4,@DSHDRU		:MASK OFF DUMMY RU SEND
	STB	R4,DCBLKS+DCBDSH,RDCB,	:SAVE SNA STATE INF.
	LHI	R2,NSDTLC		:SET TO LAST/NOT 1ST CHAIN
	IF	VTISUP&VHRSUP
	LHL	R4,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R4,LUCTAB+LUCVHR,R4,	:GET VHR STATE
	THI	R4,LUVHRF		:VHR FUNCTION?
	JN	DINTTU			:JUMP IF SO
	EI
	IF	VTISUP
	LB	R4,DCBLKS+DCBICT,RDCB,	:GET DSP INFO BYTE
	THI	R4,CDRBIT		:CHANGE DIRECTION?
	JE	DINTTE			:JUMP IF NOT
	NHI	R4,@CDRBIT		:CLEAR CHANGE DIRECTION
	STB	R4,DCBLKS+DCBICT,RDCB,	:UPDATE DSP INFO BYTE
	IF	BRKTSW			:FOR HALF-DUPLEX VTI
	OHI	R2,NSDTCD!NSDTEB	:BREACKET TERMINATION PROHIBITED
	ELSE
	OHI	R2,NSDTCD		:SET CHANGE DIRECTION
	EI
	EI
	IF	VTISUP&VHRSUP
	JFS	DINTTL			:JUMP TO CONTINUE
	EI
	IF	VHRSUP
DINTTU	OHI	R2,NSDTCD		:SET CHANGE DIRECTION
	EI

DINTTL	LHL	R4,DCBLKS+DCBRUL,RDCB,	:GET RU LENGTH
	CHI	R4,RUNOMX		:MAXIMUM?
	JGER	R6			:RETURN IF SO
	JFS	DINTTK			:OTHERWISE SEND DATA

:END OF ROUTINE.  SEND DATA TO SNA.
DINTTE
	LHL	R4,DCBLKS+DCBRUL,RDCB,	:GET RU LENGTH
	CHI	R4,RUNOMX		:MAXIMUM?
	JLFS	DINTTK			:JUMP IF SO
	NHI	R2,@NSDTIC		:CLEAR CHAINING
	IF	BRKTSW			:FOR HALF-DUPLEX VTI
	OHI	R2,NSDTCD!NSDTEB	:BRACKET TERMINATION PROHIBITED
	ELSE
	OHI	R2,NSDTCD		:INDICATE CHANGE DIRECTION
	EI
DINTTK
	LB	R4,DCBLKS+DCBICT,RDCB,	:GET INPUT CONTROL BYTE
	NHI	R4,ACKBIT		:IS IT E-T-E ACK?
	JEFS	DINTTZ			:JUMP,IF NOT
	OHI	R2,NSDTAK		:SET ACK BIT ON
DINTTZ
	LHI	R0,SNETEM^8		:E-T-E DATA
	OR	R2,R0			:MAKE THE WHOLE CMD
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	BBLOAD	R3,DCBLKS+DCBIBH,RDCB,	:GET THE BB HEADER PTR
	J	QDIFSN,,		:TO COMMON ROUTINE

	EI	(VHRSUP)

	SUBTTL (SNA-NNIO) BSC/DSP MODE - SNA->NWKC DATA-Q

	IF	VHRSUP!VTISUP

:	OUTPUT HANDLER --
:	RECEIVED A SNA RQ/RSP RU FROM TERMINAL OR HOST VHR,
:	CONVERT IT TO A DSP RESPONSE MESSAGE
:	AND SEND IT OUT TO THE 3270BSC OR SNA HOST PAD
:	VIA THE ISIS ORING.
:	(1) GET BUFFER PTR FROM LUCB DATA QUEUE COMMAND LIST
:	    (A) ACCORDING TO SUBCOMMAND TYPE FROM LU.SVC ADJUST
:		DSP STATUS BYTE
:		(THE INFORMATION IN SUBCOMMAND SUCH AS CHANGE DIRECTION BIT,
:		FIRST/LAST SEGMENT INDICATOR AND OTHER PROTOCOL RULES WILL
:		BE USED TO ASSIGN DSP HEADER,TRAILER AND DSP PACKET
:		INFORMATION BITS CONTENTS)
:	(2) ASSIGN THE DATA COUNT
:	    (A) FIRST RU SEGMENT,
:		DATA COUNT=UCN(1)+CTL(1)+SEG(1)+DATA BYTES-TH(6)-RH(3)
:			  +BSC HEADER/TRAILER(2)
:		PACKET LENGTH=C094(2)+FLAG(1)+DATACNT(2)+DATA COUNT
:	    (B) THE SUBSEQUENT SEGMENTS,
:		DATA COUNT=UCN(1)+DATA BYTES-TH(6)+BSC HEADER/TRAILER(2)
:		PACKET LENGTH=C094(2)+FLAG(1)+DATACNT(2)+DATA COUNT
:	FOR VHR 2 ADDITIONAL DATA BYTES (VHR HEADER) ARE DISCARDED
:		IN ADDITION TO SNA HEADER
:	(3) SNA MESSAGE IS SENT TO HPAD IN ONE OR A FEW DSP SEGMENTS
:		DEPENDING ON DATA COUNT VALUE. MAXIMUM LENGTH
:		OF DSP RESPONSE SEGMENT IS 256 BYTES. THE LAST SEGMENT
:		CORRENSPONDING TO GIVEN SNA MESSAGE COULD BE SHORTER.
:	(4) DSP SEGMENTS ARE SENT TO HPAD IN ONE X.25 PACKET
:		THAT IS M-BIT IS NOT USED FOR THIS DIRECTION OF TRANSMISSION.
:	EXPECT:
:		RBBA = BUFFER CONTAINING DATA
:		R0   = SCC FROM CMDLST ELEMENT
:	REG USAGE:
:		RBBX = INDEX TO BUFFER CONTAINING DATA
:		RBCC = # OF BYTES IN MESSAGE
:		R2 = ISIS RECORD BYTE COUNT
:	DO WE HAVE TO COUNT DATA AMOUNT ACCORDING TO BIND
:	PARAMETERS???
ATDOUP

	IF	BTRACE
	LIS	R4,BTROBT		:SEE IF TRACNG OUTPUT
	TBT	R4,BTRIOF,,		:...
	JE	ATDOUX			:NO, SKIP TRACE
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT #
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R4,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R4,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LR	R4,RBCC			:R4 = BYTE COUNT
	OHI	R4,BTROUT+BTRBEG	:OUTPUT AND BEGIN
	STH	R4,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R4,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R4,FASTC,,		:ELSE, MUST BE FASTC
	ST	R4,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

:SET UP DSP OUT STATUS BYTE ACCORDING TO THE SUBCOMMAND RECEIVED FROM SNA.
ATDOUX	LR	RBBA,RBBA		:CHECK BUFFER POINTER
	JE	ATDOAK			:MUST BE ACK ACKNOLEDGMENT IF 0
	BBST	RBBA,DCBLKS+DCBOBA,RDCB, :SAVE BUFFER CHAIN HEAD POINTER
	STB	R0,DCBLKS+DCBSCC,RDCB,	:SAVE SUBCOMMAND FROM SNA
	LHI	RBBX,-BBFLSZ+BBFPSZ-1	:INIT BUFFER INDEX
	LB	R4,DCBLKS+DCBOCT,RDCB,	:GET PREVIOUS OUTPUT DSP STATUS
	THI	R0,SNDTLS		:SUBCOMMAND INDICATES 1ST SNA SEGMENT?
	JEFS	ATDOU0			:JUMP IF SO
	SIS	RBCC,FID2LN		:6 DATA BYTES LESS FROM SNA
	AIS	RBBX,FID2LN		:ADJUST BUFFER INDEX FOR TH
	THI	R4,DSHEDP		:PREPARED TO END DSP DATA?
	JE	ATDOU6			:JUMP IF NOT
	J	ATDOU5			:OTHERWISE JUMP TO CHECK FOR LAST SGM

:FIRST SNA SEGMENT.
ATDOU0	SIS	RBCC,FID2LN+RHLENG	:TH AND RH NOT TO BE INCLUDED
	AIS	RBBX,FID2LN+RHLENG	:ADJUST BUFFER INDEX FOR TH AND RH
	THI	R0,SNDTLC		:SNA INDICATES 1ST IN CHAIN?
	JEFS	ATDOU2			:JUMP IF SO
	NHI	R4,@DSHSDP		:TURN OFF START DSP
	JFS	ATDOU3			:AND CONTINUE

:1ST SEGMENT AND 1ST IN CHAIN.
ATDOU2	OHI	R4,DSHSDP!DSH1DP!DSHMBT	:START DSP&1ST DSP SGM&NXT SGM TO COME
	IF	TERMIF&VHRSUP
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:GET LUCB POINTER
	LB	R11,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R11,LUVHRF		:VHR FUNCTION?
	JEFS	ATDOU3			:JUMP IF NOT
	EI
	IF	VHRSUP
	SIS	RBCC,2			:DO NOT INCLUDE VHR HEADER
	AIS	RBBX,2			:ADJUST BUFFER INDEX FOR VHR HEADER
	EI

:IF LAST IN CHAIN INDICATE READY TO END DSP (THAT IS WAIT NOW ONLY
:FOR THE LAST SEGMENT).
ATDOU3	THI	R0,SNDTFC		:LAST IN CHIAN?
	JEFS	ATDOU4			:JUMP IF SO
	NHI	R4,@DSHEDP		:NOT READY TO END DSP YET
	JFS	ATDOU6			:JUMP TO CONTINUE
ATDOU4	OHI	R4,DSHEDP		:READY TO END DSP

:FOR THE LAST SEGMENT AND LAST IN CHAIN INDICATE NO CONTINUATION FOR DSP
:RESPONSE.
ATDOU5	THI	R0,SNDTFS		:LAST SEGMENT?
	JNFS	ATDOU6			:JUMP IF NOT
	NHI	R4,@DSHMBT		:NOT CONTINUATION AFTER THAT

:SAVE DSP OUTPUT STATUS AND CONTINUE.
ATDOU6	STB	R4,DCBLKS+DCBOCT,RDCB,	:SAVE DSP OUTPUT STATE
	JFS	ATDOUA			:JUMP TO CONTINUE

:ENTRY POINT TO START A NEW DSP RESPONSE SEGMENT.
ATDOU7	BBLOAD	RBBA,DCBLKS+DCBOBA,RDCB, :GET POINTER TO DATA BUFFER
	LH	RBBX,DCBLKS+DCBOBX,RDCB, :GET INDEX TO DATA IN BUFFER
	LHL	RBCC,DCBLKS+DCBOCC,RDCB, :GET LENGTH OF REMAINING DATA
	LB	R4,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT DSP STATE

:FIGURE OUT HOW MUCH OF DATA WILL FIT THIS DSP SEGMENT AND HOW
:MUCH WILL REMAIN (IF ANYTHING) FOR THE NEXT ONE.
:AFTER THIS ROUTINE R7 WILL CONTAIN LENGTH OF DSP HEADER AND TRAILER,
:RBCC - LENGHT OF DATA BYTES WITHIN THIS SEGMENT, R4 - LENGTH
:OF REMIANING DATA BYTES.
ATDOUA	LIS	R7,4			:ASSUME 3 HEADER AND 1 TRAILER BYTES
	LHI	R11,TDSPMX-4		:MAX LENGTH OF DATA IN THIS CASE
	THI	R4,DSH1DP		:1ST DSP SEGMENT?
	JNFS	ATDOU8			:JUMP IF SO
	LIS	R7,2			:OTHERWISE 1 HEADER AND 1 TRAILER BYTE
	AIS	R11,2			:AND 2 BYTES MORE OF DATA
ATDOU8	LR	R4,RBCC			:COPY LENGTH OF REMAINING DATA
	SR	R4,R11			:THAT MUCH WILL REMAIN AFTER CURR SGM
	JLEFS	ATDOU9			:JUMP IF NOTHING WILL REMAIN
	LR	RBCC,R11		:LENGTH OF DATA IN THIS SEGM
	JFS	ATDO10			:JUMP TO CONTINUE
ATDOU9	XR	R4,R4			:NOTHING WILL REMAIN AFTER THIS SEGM

:SAVE PACKET INFORMATION, ISSUE SIIX AND PREPARE LENGTH OF TYMNET PACKET.
ATDO10	STH	R4,DCBLKS+DCBOCC,RDCB,	:SAVE REMAINING DATA LENGTH
	LR	R11,RBCC		:COPY CURRENT DATA LENGTH
	AR	R11,R7			:PLUS LENGTH OF HEADER&TRAILER
	AIS	R11,5			:C094+FLAG+DATA CNT
	AIS	RBCC,1			:LENGTH OF DATA&DSP TRAILER
	LIS	R0,3			:SEND SIIX MSG
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT
	LHI	R2,SIIX
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,
	LB	R0,XLIMIT,R1,		:GET ISIS MAX XLIMIT
	CR	R0,R11			:SEE IF PACKET FIT INTO ONE ISIS RCD
	JLFS	ATDO11			:NO, USE XLIMIT
	LR	R0,R11			:ELSE, USE PACKET LENGTH
ATDO11
	LR	R2,R0			:R2 = ISIS RCD BYTE COUNT
	AIS	R0,2			:ADJUST WITH PORT
	JAL	R4,SLOR,,
	LHI	R0,IIXDIL		:DATA DIALECT CODE (C094)
	JAL	R4,PUTCH,,
	LHI	R0,DATAPK
	JAL	R4,PUTCH,,
:M-BIT IS NOT USED FOR DSP RESPONSES.
	LIS	R0,0
	JAL	R4,PUTCH,,
	SIS	R2,5			:C094 + FLAG + PACKET.LENGTH FILED
	SIS	R11,5
	EXBR	R0,R11			:SEND LEFT BYTE OF PACKET LENGTH
	JAL	R4,PUTCH,,
	LR	R0,R11			:SEND RIGHT BYTE OF LENGTH
	JAL	R4,PUTCH,,
					:SEND HEADER (UCN, CTL, SEQ)
	LB	R0,DCBLKS+DCBOCT,RDCB,	:GET OUTPUT CONTROL
	THI	R0,DSH1DP		:IS IT FIRST-DSP?
	JE	ATDO17			:NO, SKIP
	NHI	R0,@DSH1DP		:SET FIRST-DSP TO FALSE
	STB	R0,DCBLKS+DCBOCT,RDCB,	:STORE IT INTO DCB
	LHI	R0,UCN			:Y - SET FS=0 IN UCN
	JAL	R4,PUTCH,,		:SEND UCN
	LIS	R0,0			:SET NULL CTL BYTE
	LB	R4,DCBLKS+DCBRFS,RDCB,	:GET CRM BYTE
	NHI	R4,XPRBIT		:IS IT TRANSPARENT?
	JEFS	ATDO13			:JUMP,IF NOT
	OHI	R0,XPRBIT		:SET XPR BIT ON
ATDO13
	LB	R4,DCBLKS+DCBSCC,RDCB,	:GET SCC
	NHI	R4,SNDTAK		:IS IT E-T-E ACK?
	JEFS	ATDO16			:JUMP,IF NOT ACK BIT ON
	OHI	R0,ACKBIT		:SET ACK BIT ON DSP HEADER
ATDO16
	JAL	R4,PUTCH,,		:SEND CONTROL BYTE
	LB	R0,DCBLKS+DCBOSQ,RDCB,	:GET OUT SEQ #
	AIS	R0,1			:INCREMENT SEQUENCE NUMBER
	STB	R0,DCBLKS+DCBOSQ,RDCB,	:UPDATE
	JAL	R4,PUTCH,,		:SEND SEQUENCE NUMBER
	SIS	R2,3			:DECREASE FOR UCN,CTR,SEQ #
	JFS	ATDO20			:SKIP TO CONTINUE
ATDO17					:SUBSEGUENT SEGMENT
	LHI	R0,UCN			:SEND UCN ONLY
	OHI	R0,BIT.FS		:SEND UCN W/ FS=1
	JAL	R4,PUTCH,,
	SIS	R2,1			:DECREASE COUNT FOR UCN
ATDO20					:COPY DATA CHAR FROM OUTPUT BB
					:TO ISIS ORING
	SIS	RBCC,1			:DECREASE DATA COUNT
	JLEFS	ATDO22			:JUMP IF NO MORE DATA
	JAL	R4,GETBC,,		:GET CHAR FROM BUFFER
	JAL	R4,PUTCH,,		:OUTPUT BYTE TO RING
	SIS	R2,1			:DECREMENT ISIS RCD COUNT
	JGBS	ATDO20			:NOT FINISH THIS ISIS RCD, REPEAT
	J	ATDO24			:JUMP TO SAVE PARAMETERS AND DISMISS

:END OF DSP SEGMENT. PREPARE AND SEND DSP TRAILER.
ATDO22	LHI	R0,ETB			:PREPARE TO SEND ETB
	LHL	R11,DCBLKS+DCBOCC,RDCB,	:ANY DATA REMAINED
	JN	ATDO2A			:JUMP IF SO
	LB	R4,DCBLKS+DCBOCT,RDCB,	:GET DSP OUTPUT STATE
	THI	R4,DSHMBT		:RESPONSE TO CONTINUE?
	JNFS	ATDO2A			:JUMP IF SO
	LHI	R0,ETX			:OTHERWISE PREPARE TO SEND ETX
	LB	R4,DCBLKS+DCBSCC,RDCB,	:GET SAVED SUBCOMMAND
	THI	R4,SNDTCN		:CANCEL?
	JEFS	ATDO2A			:JUMP IF NOT
	LHI	R0,ENQ			:OTHERWISE PREPARE TO SEND ENQ
ATDO2A	JAL	R4,PUTCH,,		:OUTPUT DSP TRAILER
	JAL	R4,ELODR,,		:END CURRENT ISIS RCD
	LR	R11,R11			:ANY DATA REMAINING?
	JEFS	ATDO2B			:JUMP IF NOT
	BBST	RBBA,DCBLKS+DCBOBA,RDCB, :SAVE POINTER TO CURRENT BUFFER
	STH	RBBX,DCBLKS+DCBOBX,RDCB, :SAVE CURRENT INDEX
	LHI	R0,ATDOU7-PSEG		:SET NEXT ENTRY POINT
	STH	R0,DCBLKS+DCBOUT,RDCB,	:UPDATE DCB
	JR	R5			:AND RETURN
ATDO2B	LHI	R0,ATDOUP-PSEG		:SET OUTPUT PROC
	STH	R0,DCBLKS+DCBOUT,RDCB,
	LHL	R11,DCBLKS+DCBLUC,RDCB,, :GET LUCB POINTER
	JAL	R7,DLODTA,,		:FINISH PROCESS THIS CMD & BBS

	IF	BTRACE
	LIS	R4,BTROBT		:SEE IF TRACNG OUTPUT
	TBT	R4,BTRIOF,,		:...
	JER	R5			:NO, END OF ISIS/IIX OUTPUT
	LHL	R6,BTRSIX,,		:GET BG TRACE INDEX PTR
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISIS PORT #
	STB	R1,BTRSBF+0,R6,		:SAVE INTO TRACE BUFFER
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	LHL	R4,LUCTAB+LUCT.N,R11,	:R0 = LUCTAB REL ID#
	STB	R4,BTRSBF+1,R6,		:SAVE INTO TRACE BUFFER
	LR	R4,RBCC			:R4 = BYTE COUNT
	OHI	R4,BTROUT+BTREND	:OUTPUT AND END
	STH	R4,BTRSBF+2,R6,		:SAVE INTO TRACE BUFFER
	L	R4,GMT,,		:ASSUME GMT
	LO	FGGBDF
	LHL	R7,FTGMTL,,		:GET CLOCK SOURCE INDICATOR
	FO	FGGBDF
	JNFS	.+8			:GMT, SKIP
	L	R4,FASTC,,		:ELSE, MUST BE FASTC
	ST	R4,BTRSBF+4,R6,		:SAVE INTO TRACE BUFFER
	AIS	R6,8			:ADVANCE INDEX
	CLHI	R6,BTRACE*BTRBFL	:WRAP AROUND?
	JLFS	.+4			:NO, SKIP
	LIS	R6,0			:ELSE, RESET TRACE INDEX
	STH	R6,BTRSIX,,		:UPDATE NEW TRACE INDEX
	EI	(BTRACE)

	JR	R5			:END ISIS/IIX OUTPUT

ATDO24					:END OF ISIS RCD , BUT NOT FULL PACKET
	JAL	R4,ELODR,,		:END CURRENT ISIS RCD
	BBST	RBBA,DCBLKS+DCBOBA,RDCB,:SAVE BB ADDR
	STH	RBBX,DCBLKS+DCBOBX,RDCB,:SAVE BB INDEX
	STB	RBCC,DCBLKS+DCBTSG,RDCB,:SAVE REMAINING DATA LENGTH
	LHI	R0,ATDO25-PSEG		:SET UP NEXT ENTRY POINT
	STH	R0,DCBLKS+DCBOUT,RDCB,	:UPDATE
	JR	R5			:RETURN (DISMISS) - ISIS/IIX OUTPUT

:	ATDO25:	AFTER DISMISS, ENTER PROCESSING OUTPUT DSP DATA MSG HERE
:	------
:       BEGIN PROCESSING OUTPUT DATA MSG AGAIN AT THIS POINT
ATDO25
	BBLOAD	RBBA,DCBLKS+DCBOBA,RDCB,:RESTORE BB ADDR
	LH	RBBX,DCBLKS+DCBOBX,RDCB,:RESTORE BB INDEX
	LB	RBCC,DCBLKS+DCBTSG,RDCB,:RESTORE PARTIAL DATA LENGTH
	LHL	R1,DCBLKS+DCBIPR,RDCB,	:R1 = ISI PORT #
	LB	R0,XLIMIT,R1,		:GET MAX XLIMIT
	CR	R0,RBCC			:ASSUME PARTIAL DATA LENGTH < XLIMT
	JLFS	ATDO26			:NO, SKIP TO USE  XLIMIT
	LR	R0,RBCC			:ELSE, USE PARTIAL DATA LENGTH
ATDO26
	LR	R2,R0			:R2 = ISIS RCD LENGTH
	AIS	R0,2			:INCLUDE PORT # (2)
	JAL	R4,SLOR,,		:START A NEW ISIS OUTPUT RECORD
	J	ATDO20			:TO CONTINUE COPY DATA INTO ISIS ORING
 
:	ATDOAK	:RECEIVE E-T-E RSP FROM SNA
:	------
ATDOAK
	THI	R0,SNDTAK		:IS IT E-T-E ACK?
	JE	ATDCRA			:JUMP,IF IT IS NOT ACK RSP
	LB	R4,DCBLKS+DCBDST,RDCB,	:GET DCB BSCDSP STATE
	NHI	R4,@ACKBIT		:RESET ACK WAIT BIT
	STB	R4,DCBLKS+DCBDST,RDCB,	:RESET STATE TO INIT
	LB	R0,DCBLKS+DCBISQ,RDCB,	:GET EXPECTED ISQ-1
	STB	R0,M.ACK+8,,		:INSERT SEQ #
	LA	R9,M.ACK,,		:GET CANNED MSG PTR
	JAL	R6,SNDIIX,,		:JUMP TO SEND IIX MSG
	LHI	R0,ATDOUP-PSEG		:SET OUTPUT PROC
	STH	R0,DCBLKS+DCBOUT,RDCB,
	JAL	R7,DLODTA,,		:FINISH PROCESS THIS CMD & BBS
	JR	R5			:END ISIS/IIX OUTPUT
 
:	ATDCRA	:CRASH FOR THE NIO OUTPUT PROCESS
:	------
ATDCRA
	JAL	R10,CRASH,,
	BC	0,0,0,0A0


	EI	(VHRSUP!VTISUP)

	FO	MAIN
	FO	GBLDEF
	FO	GIIX
	FO	GDSP
	FO	BSUB
	FO	CBKDEF
	FO	ISISC
	FO	FRNTND
	FO	SHDPKG

	EM

  	SUBTTL	(SNA) DLC LAYER PROCESSOR - DLCPRO
:DLCD00.Z00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	MO	.,DLCPRO
	GL	DLCPRO

	LO	GBLDEF
	LO	CBKDEF
	LO	CMDLST
	LO	MAIN

:	DEFINE XID FROMATS
:	------------------
:	XID HAS FORMATS 0, 1, AND 2

	SEG	A.CODE
OLDORG	EQ	.

	ORG	0
XIDFM0	BS	1			:0-3, FORMAT
					:4-7, PU.TYPE
XIDLGH	BS	1			:LENGTH
XIDNID	BS	6			:NODE.ID
					:0-11, BLOCK.NUM
					:12-31, ID.NUM
					:32-47, RESERVED
XIDNUM	BS	1			:XID.NUMBERS
XF0LEN	EQ	.

:	FORMAT2 CONTINUE
:	----------------
	ORG	XIDNUM
XIDFM1	BS	1			:0-1, RESERVED

:	FORMAT3 CONTINUE
:	----------------
	ORG	XIDNUM
XIDFM2	BS	1			:

	ORG	OLDORG

	SUBTTL	(SNA) DLC LAYER - DISPATCHER - DLCPRO

	SEG	A.DATA
	BND	4

:	DEFINE LOCAL VARIABLES
:	----------------------
DLCSAV	WS	1			:TEMPORAY SAVE WORD
LR5SAV	WS	1			:SAVE AREA FOR R5
LR9SAV	WS	1			:ROUTINE LINK SAVE AREA
DLCGPR	WS	1			:WORKING STORAGE

	SEG	A.CODE

:	DEFINE PROCESSING STATE TABLES
:	-------------------------------
DLCCPR	EQ	0
DLCXPR	EQ	2
DLCRPR	EQ	4

:	DLCPRO:	DLC LAYER PROCESSOR
:	--------
:	LINK REGISTER - R0
:	REGISTER USAGE:
:	R0
DLCPRO
	ST	R0,DLCSAV,,		:SAVE RETURN ADDR

:***************************************************************:
:								:
:	PROCESSING LKS RCV QUEUE (DLC -> PC)			:
:								:
:***************************************************************:
DLCRCV
	LIS	R10,NLINES
DLCRC1
	SIS	R10,1			:
	JL	DLCCMD			:IF ALL DONE, GO TO PROCESS CMD
	LCS	R0,1			:INIT DLCGPR WORD
	ST	R0,DLCGPR,,		:...
DLCRC2
	LHL	R7,LCBPTR,R10,R10	:R7=LCB ADDR
	LHL	R8,LNCPTR,R10,R10	:R8=LNCTAB ADDR
	LHL	R11,LNCTAB+LNPUTB,R8,	:R11=PUCTAB ADDR (1ST ONE ON THIS)
	L	R1,LCBTAB+LDARCV,R7,	:GET THE LDARCV BIT ARRAY
	N	R1,DLCGPR,,		:ANY RCV DATA/CMD?
	JFFO	R1,DLCRCX		:FIND
	J	DLCRC1			:NO, GO TO NEXT LINE
DLCRCX
	RBT	R2,DLCGPR,,		:RESET 
	LHI	R4,PUCLEN		:CALCULATE TO GET THE PUCTAB ADDR
	MHR	R4,R2			:GET THE OFFSET
	AR	R11,R4			:GET THE PUCTAB ADDR FOR THIS PU
	LHL	R12,PUCTAB+PUCLSC,R11,	:R12=LSC ADDR
:	LH	R6,LSCLKS+SGPRCV,R12,	:SEE IF RCV DATA QUED (01/02/85 MIA)
:	CLH	R6,LSCLKS+SRPRCV,R12,	:COMPARE GET & REL PTR (01/02/85 MIA)
	LHL	R6,LSCLKS+SGPRCV,R12,	:SEE IF RCV DATA QUED (01/02/85 MIA)
	LHL	R3,LSCLKS+SRPRCV,R12,	:GET RELEASE PTR (01/02/85 MIA)
	CR	R6,R3			:COMP GET AND REL PTR (01/02/85 MIA)
	JE	DLCRC2			:IF SAME, SKIP TO NEXT PU
	LB	R3,CMDBLK+CLCMD,R6,	:GET THE CCC
:	REMARK PROCESS THE CMD
	CLHI	R3,DLCLNK		:DLC LINK FRAME?
	JN	DLCRSH			:NO, TO CRASH
	LB	R4,CMDBLK+CLCMDS,R6,	:GET SCC
	CLHI	R4,CSTATE+UPBUSY	:WITHIN RANGE?
	JG	DLCRSH			:NO, CRASH
	SLHLS	R4,1			:MAKE HALF WORD INDEX
	LHL	R2,PUCTAB+PULSNM,R11,	:GET CURRENT PU LINK DLC STATE
	LHL	R2,PSEG+DLCRPR,R2,	:GET THE RCV PROC TABLE
	LHL	R2,PSEG,R4,R2		:GET RCV ROUTINE
	JAL	R5,PSEG,R2,		:GO TO PROCESS THIS SCC
	J	DLCRC2			:NEXT PU

:***************************************************************:
:								:
:	PROCESSING THE PUCB CMD QUEUES (NWKC->DLC)		:
:								:
:***************************************************************:
DLCCMD
	LHI	R14,NGSPU*10
	LHI	R15,NGSPU*2
DLCCM1
	SHI	R14,10			:...
	SIS	R15,2			:ALL DONE?
	JL	DLCXMT			:YES, GO TO PROCESS XMT
:	(5/20/85/CHS)
:	ALL THE CMDS ALREADY QUEUED MUST BE PROCESSED AT ONCE TO 
:	AVOID RACE CONDITION.
:	LCS	R0,1			:INIT DLCGPR(5/20/85/CHS)
:	STH	R0,DLCGPR		:...(5/20/85/CHS)
DLCCM2
	LH	R1,CPNWDL,R15,		:PU'S WITH NWKC TO DLC CMD QUEUED
:	NH	R1,DLCGPR		:EXCLUDE PU'S ALREADY PROCESSED(5/20/85/CHS)
	JFFOH	R1,DLCCMY		:FIND THE 1ST PU
	J	DLCCM1			:SKIP, IF NONE TO PROCESS IN THIS GROUP
DLCCMY
:	RBT	R2,DLCGPR,,		:DON'T DO THIS ONE AGAIN(5/20/85/CHS)
	AR	R2,R14			:FORM THE BIT NUMBER
	LHL	R11,PUCPTR,R2,R2,	:R11=PUCTAB ADDR
:	LH	R6,PUCTAB+PUDLCG,R11,	:SEE IF ANY CMD QUEUED (01/02/85 MIA)
;	CLH	R6,PUCTAB+PUDLCR,R11,	:... (01/02/85 MIA)
	LHL	R6,PUCTAB+PUDLCG,R11,	:SEE IF ANY CMD QUEUED (01/02/85 MIA)
	LHL	R3,PUCTAB+PUDLCR,R11,	:GET RELEASE POINTER (01/02/85 MIA)
	CR	R6,R3			:COMP GET AND REL PTR (01/02/85 MIA)
	JE	DLCCM2			:IF SAME, SKIP TO NEXT PU
	LB	R3,CMDBLK+CLCMD,R6,	:GET THE CCC
:	REMARK PROCESS THE CMD
	CLHI	R3,DLCCTL		:DLC CONTROL CMD
	JN	DLCRSH			:NO, TO CRASH
	LB	R4,CMDBLK+CLCMDS,R6,	:GET SCC
	CLHI	R4,INITCD		:WITHIN RANGE?
	JG	DLCRSH			:NO, TO CRASH
	SLHLS	R4,1			:MAKE HALF WORD INDEX
	LHL	R2,PUCTAB+PULSNM,R11,	:GET CURRENT PU DLC LINK STATE
	LHL	R2,PSEG+DLCCPR,R2,	:GET CMD PROC TABLE
	LHL	R2,PSEG,R4,R2		:GET THE CMD ROUTINE
	JAL	R5,PSEG,R2,		:GO TO PROCESS THIS CMD
	J	DLCCM2			:NEXT PU

:***************************************************************:
:								:
:	PROCESSING THE PCCB DATA QUEUES (PC->DLC)		:
:								:
:***************************************************************:
DLCXMT
	LHI	R14,NGSPU*10
	LHI	R15,NGSPU*2
DLCXM1
	SHI	R14,10			:...
	SIS	R15,2			:ALL DONE?
	JL	DLCRET			:YES, RETURN
	LCS	R0,1			:INIT DLCGPR
	STH	R0,DLCGPR,,		:...
DLCXM2
	LH	R1,DPPCDL,R15,		:PU'S WITH NWKC TO DLC CMD QUEUED
	NH	R1,DLCGPR,,		:EXCLUDE PU'S ALREADY PROCESSED
	JFFOH	R1,DLCXMZ		:FIND THE 1ST PU
	J	DLCXM1			:SKIP, IF NON TO PROCESS IN THIS GROUP
DLCXMZ
	RBT	R2,DLCGPR,,		:DON'T DO THIS ON AGAIN
	AR	R2,R14			:FORM THE BIT NUMBER
	LHL	R11,PUCPTR,R2,R2,	:R11=PUCTAB ADDR
	LHL	R13,PCBPTR,R2,R2,	:R13=PCBPTR
:	LH	R6,PCBBLK+PCPUSG,R13,	:SEE IF ANY DATA QUEUED (01/02/85 MIA)
:	CLH	R6,PCBBLK+PCPUSR,R13,	:... (01/02/85 MIA)
	LHL	R6,PCBBLK+PCPUSG,R13,	:SEE IF ANY DATA QUEUED (01/02/85 MIA)
	LHL	R3,PCBBLK+PCPUSR,R13,	:GET RELEASE PTR (01/02/85 MIA)
	CR	R6,R3			:COMP GET AND REL PTR (01/02/85 MIA)
	JE	DLCXM2			:IF SAME, SKIP TO NEXT PU
	LB	R3,CMDBLK+CLCMD,R6,	:GET THE CCC
:	REMARK PROCESS THE CMD
	CLHI	R3,DLCLNK		:DLC LINK/DATA FRAME?
	JN	DLCRSH			:NO, TO CRASH
	LB	R4,CMDBLK+CLCMDS,R6,	:GET SCC
	CLHI	R4,CDATA		:FORMAT CORRECTED?
	JN	DLCRSH			:NO, CRASH
	SLHLS	R4,1			:MAKE HALF WORD INDEX
	LHL	R2,PUCTAB+PULSNM,R11,	:GET CURRENT PU DLC LINK STATE
	LHL	R2,PSEG+DLCXPR,R2,	:GET XMT PROC TABLE
	LHL	R2,PSEG,R4,R2		:GET XMT ROUTINE
	JAL	R5,PSEG,R2,		:GO TO PROCESS THIS XMT-CMD
	J	DLCXM2			:NEXT PU

:	DLC LAYER RETURN TO EXEC
:	------------------------
DLCRET
	L	R0,DLCSAV,,		:RESTORE RETURN ADDR
	JR	R0			:RETURN

:	DLC LAYER DISPATCHER CRASH
:	---------------------------
DLCRSH
	JAL	R10,CRASH,,		:...
	BC	0,0,0,088		:..

	SUBTTL	(SNA) DLC LAYER - MISCELLANEOUSS ROUTINES


:	QUFRMR:	QUEUE A FRMR FRAME TO XMT QUEUE
:	-------
:	INPUT:
:
:	OUTPUT:
:	DESTROYED:
QUFRMR


:	SCAXID:	SCAN THE XID FRAME
:	--------
:	CHECK THE CONTENTS OF THE XID FRAME
:	INPUT:
:
:	OUTPUT:	NORMAL RETURN - O.K. AND SUPPORTED
:		SKIP RETURN - BAD, OR NOT SUPPORTED
:	DESTROED:
SCAXID


:	QUXID:	QUEUE AN XID FRAME TO THE XMT QUEUE
:	--------
:	INPUT:
:
:	OUTPUT:
:	DESTROYED:
QUXID


:	RCVDLT:	DELETE RCV DATA BUFFER
:	--------
:	INPUT:	R3 = BB HEAD
:		R11 = PUCTAB
RCVDLT
	LR	R3,R3			:DOUBLE CHECK
	JER	R9			:RETURN
	ST	R5,LR5SAV,,		:SAVE R5
RCVDL1
	BBL	R5,BBUFER+BBFLSZ-BBFPSZ,R3,	:GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE THIS BB
	LHL	R4,PUCTAB+PUCLNC,R11,	:GET LNCTAB
	LIS	R0,1
	AHM	R0,LNCTAB+LNRBUS,R4,	:INCREASE BB USAGE BY 1 IN LNC
	AHM	R0,PUCTAB+PURBUS,R11,	:INCREASE BB USAGE BY 1 IN PUC
	LR	R3,R5			:NEXT BB ADDR TO R3, AND SEE IF MORE
	JN	RCVDL1			:MORE, LOOP
	L	R5,LR5SAV,,		:RESTORE R5
	JR	R9			:ELSE, RETURN


:	XMTDLT:	DELETE XMT DATA BUFFER
:	--------
:	INPUT:	R3 = BB HEAD
:		R11 = PUCTAB
XMTDLT
	LR	R3,R3			:DOUBLE CHECK
	JER	R9			:RETURN
	ST	R5,LR5SAV,,
XMTDL1
	BBL	R5,BBUFER+BBFLSZ-BBFPSZ,R3, :GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE THIS BB
	LHL	R4,PUCTAB+PUCLNC,R11,	:GET LNCTAB
	LIS	R0,1
	AHM	R0,LNCTAB+LNXBUS,R4,	:INCREASE BB USAGE BY 1 IN LNC
	AHM	R0,PUCTAB+PUXBUS,R11,	:INCREASE BB USAGE BY 1 IN PUC
	LR	R3,R5			:NEXT BB ADDR TO R3, AND SEE IF MORE
	JN	XMTDL1			:MORE, LOOP
	L	R5,LR5SAV,,
	JR	R9			:ELSE, RETURN


:	GTRCV:	GET RCV FROM FG (LKSCB)
:	--------
:	INPUT:	R7 = LCB
:		R11 = PUCB
:		R12 = LKSCB
:	OUTPUT:	R1 = SCC CODE
:		R2 = CLLNG DATA
:		R3 = CLARG DARA
GTRCV
	LHL	R6,LSCLKS+SGPRCV,R12,	:GET GET PTR
:	CLH	R6,LSCLKS+SRPRCV,R12,	:COMP WITH RELEASE PTR (01/02/85 MIA)
	LHL	R3,LSCLKS+SRPRCV,R12,	:GET RELASE PTR (01/02/85 MIA)
	CR	R6,R3			:COMP GET AND REL PTR (01/02/85 MIA)
	JNFS	GTRCV1			:QUEUE NOT EMPTY, SKIP
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,0FF
GTRCV1
	BBL	R3,CMDBLK+CLARG,R6,	:GET CLARG DATA
	LB	R1,CMDBLK+CLCMDS,R6,	:GET SCC DATA
	LHL	R2,CMDBLK+CLLNG,R6,	:GET CLLNG DATA
:	LHL	R4,CMDBLK+CLPTR,R6,	: (01/02/85 MIA)
	LH	R4,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK (01/02/85 MIA)
	JE	CLERR,,			:CRASH, IF ADVANCING AN EMPTY LIST
	STH	R4,LSCLKS+SGPRCV,R12,	:ADVANCE TO NEXT
	LB	R0,LSCLKS+LSCRID,R12,	:GET REL LKS ID#
	RBT	R0,LCBTAB+LDARCV,R7,	:FIRST TURN OFF DATA PRESENT FIRST
	CLH	R4,LSCLKS+SRPRCV,R12,	:SEE IF MORE RCV PRESENT
	JEFS	.+08			:SKIP, IF NONE
	SBT	R0,LCBTAB+LDARCV,R7,	:ELSE, TURN ON PRESENT BIT
	JAL	R4,RELCL,,		:RELEASE THE CMD CELL
	JR	R9			:RETURN


:	GTCMD:	GET CMD FROM NWKC (PUCB)
:	--------
:	INPUT:
:		R11 = PUCB
:	OUTPUT:	R1 = SCC CODE
:		R2 = CLLNG DATA
:		R3 = CLARG DARA
GTCMD
	LHL	R6,PUCTAB+PUDLCG,R11,	:GET GET PTR
:	CLH	R6,PUCTAB+PUDLCR,R11,	:COMP WITH RELEASE PTR (01/02/85 MIA)
	LHL	R3,PUCTAB+PUDLCR,R11,	:GET RELEASE PTR (01/02/85 MIA)
	CR	R6,R3			:COMP GET AND REL PTR (01/02/85 MIA)
	JNFS	GTCMD1			:QUEUE NOT EMPTY, SKIP
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,0FF
GTCMD1
	BBL	R3,CMDBLK+CLARG,R6,	:GET CLARG DATA
	LB	R1,CMDBLK+CLCMDS,R6,	:GET SCC DATA
	LHL	R2,CMDBLK+CLLNG,R6,	:GET CLLNG DATA
:	LHL	R4,CMDBLK+CLPTR,R6,	: (01/02/85 MIA)
	LH	R4,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK (01/02/85 MIA)
	JE	CLERR,,			:CRASH, IF ADVANCING AN EMPTY LIST
	STH	R4,PUCTAB+PUDLCG,R11,	:ADVANCE TO NEXT
	LB	R0,PUCTAB+PUCT.N,R11,	:GET REL PU ID#
	RBT	R0,CPNWDL,,		:FIRST TURN OFF DATA PRESENT FIRST
	CLH	R4,PUCTAB+PUDLCR,R11,	:SEE IF MORE CMD PRESENT
	JEFS	.+08			:SKIP, IF NONE
	SBT	R0,CPNWDL,,		:ELSE, TURN ON PRESENT BIT
	JAL	R4,RELCL,,		:RELEASE THE CMD CELL
	JR	R9			:RETURN


:	GTXMT:	GET XMT FROM PC (PCCB)
:	-------
:	INPUT:
:		R11 = PUCB
:		R13 = PCCB
:	OUTPUT:	R1 = SCC CODE
:		R2 = CLLNG DATA
:		R3 = CLARG DARA
GTXMT
	LHL	R6,PCBBLK+PCPUSG,R13,	:GET GET PTR
:	CLH	R6,PCBBLK+PCPUSR,R13,	:COMP WITH RELEASE PTR (01/02/85 MIA)
	LHL	R3,PCBBLK+PCPUSR,R13,	:GET RELEASE PTR (01/02/85 MIA)
	CR	R6,R3			:COMP GET AND REL PTR (01/02/85 MIA)
	JNFS	GTXMT1			:QUEUE NOT EMPTY, SKIP
	JAL	R10,CRASH,,		:ELSE, CRASH
	BC	0,0,0,0FF
GTXMT1
	BBL	R3,CMDBLK+CLARG,R6,	:GET CLARG DATA
	LB	R1,CMDBLK+CLCMDS,R6,	:GET SCC DATA
	LHL	R2,CMDBLK+CLLNG,R6,	:GET CLLNG DATA
:	LHL	R4,CMDBLK+CLPTR,R6,	: (01/02/85 MIA)
	LH	R4,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK (01/02/85 MIA)
	JE	CLERR,,			:CRASH, IF ADVANCING AN EMPTY LIST
	STH	R4,PCBBLK+PCPUSG,R13,	:ADVANCE TO NEXT
	LB	R0,PUCTAB+PUCT.N,R11,	:GET REL PU ID#
	RBT	R0,DPPCDL,,		:FIRST TURN OFF DATA PRESENT FIRST
	CLH	R4,PCBBLK+PCPUSR,R13,	:SEE IF MORE XMT PRESENT
	JEFS	.+08			:SKIP, IF NONE
	SBT	R0,DPPCDL,,		:ELSE, TURN ON PRESENT BIT
	JAL	R4,RELCL,,		:RELEASE THE CMD CELL
	JR	R9			:RETURN


:	PTCMD:	PUT CMD INTO LKSCB
:	--------
:	INPUT:
:		R1 = CLCMDS DATA
:		R2 = CLLNG  DATA
:		R3 = CLARG  DATA
:		R11 = PUCTAB
PTCMD
	LHL	R12,PUCTAB+PUCLSC,R11,	:R12 = LSCLKS
	JAL	R4,GETCL,,		:GET A CMD CELL
	J	DLCCL
	LHL	R4,LSCLKS+SPPCMD,R12,	:GET PUT PTR
	LIS	R0,DLCCTL		:DLC CONTROL
	STB	R0,CMDBLK+CLCMD,R4,	:PUT IN CLCMD
	STB	R1,CMDBLK+CLCMDS,R4,	:PUT IN CLCMDS
	STH	R2,CMDBLK+CLLNG,R4,	:PUT IN CLLNG
	BBST	R3,CMDBLK+CLARG,R4,	:PUT IN CLARG
	STH	R6,CMDBLK+CLPTR,R4,	:LINK NEW CMD CELL
	STH	R6,LSCLKS+SPPCMD,R12,	:UPDATE PUT PTR
	STH	R6,LSCLKS+SRPCMD,R12,	:RELEASE CMD
	LB	R7,PUCTAB+PULNKN,R11,	:GET LINE #
	LHL	R7,LCBPTR,R7,R7		:R7 = LCB ADDR
	LB	R0,LSCLKS+LSCRID,R12,	:GET LKS REL ID#
	SBT	R0,LCBTAB+LDACMD,R7,	:SET CMD PRESENT
	JR	R9			:RETURN


:	PTXMT:	PUT XMT INTO LKSCB
:	--------
:	INPUT:
:		R1 = CLCMDS DATA
:		R2 = CLLNG  DATA
:		R3 = CLARG  DATA
:		R11 = PUCTAB
:		R13 = PCCB
PTXMT
	LHL	R12,PUCTAB+PUCLSC,R11,	:R12 = LSCLKS
	JAL	R4,GETCL,,		:GET A CMD CELL
	J	DLCCL
	LHL	R4,LSCLKS+SPPXMT,R12,	:GET PUT PTR
	LIS	R0,DLCLNK		:DLC CONTROL
	STB	R0,CMDBLK+CLCMD,R4,	:PUT IN CLCMD
	STB	R1,CMDBLK+CLCMDS,R4,	:PUT IN CLCMDS
	STH	R2,CMDBLK+CLLNG,R4,	:PUT IN CLLNG
	BBST	R3,CMDBLK+CLARG,R4,	:PUT IN CLARG
	STH	R6,CMDBLK+CLPTR,R4,	:LINK NEW CMD CELL
	STH	R6,LSCLKS+SPPXMT,R12,	:UPDATE PUT PTR
	STH	R6,LSCLKS+SRPXMT,R12,	:RELEASE CMD
	LB	R7,PUCTAB+PULNKN,R11,	:GET LINE #
	LHL	R7,LCBPTR,R7,R7		:R7 = LCB ADDR
	LB	R0,LSCLKS+LSCRID,R12,	:GET LKS REL ID#
	SBT	R0,LCBTAB+LDAXMT,R7,	:SET XMT PRESENT
	JR	R9			:RETURN


:	PTRSP:	PUT RSP INTO PUCB
:	--------
:	INPUT:
:		R1 = CLCMDS DATA
:		R2 = CLLNG  DATA
:		R3 = CLARG  DATA
:		R11 = PUCTAB
PTRSP
	JAL	R4,GETCL,,		:GET A CMD CELL
	J	DLCCL
	LHL	R4,PUCTAB+PUNWCP,R11,	:GET PUT PTR
	LIS	R0,DLCCTL		:DLC CONTROL
	STB	R0,CMDBLK+CLCMD,R4,	:PUT IN CLCMD
	STB	R1,CMDBLK+CLCMDS,R4,	:PUT IN CLCMDS
	STH	R2,CMDBLK+CLLNG,R4,	:PUT IN CLLNG
	BBST	R3,CMDBLK+CLARG,R4,	:PUT IN CLARG
	STH	R6,CMDBLK+CLPTR,R4,	:LINK NEW CMD CELL
	STH	R6,PUCTAB+PUNWCP,R11,	:UPDATE PUT PTR
	STH	R6,PUCTAB+PUNWCR,R11,	:RELEASE CMD
	LB	R0,PUCTAB+PUCT.N,R11,	:GET PU ID#
	SBT	R0,CPDLNW,,		:SET RSP PRESENT
	JR	R9			:RETURN


:	PTRCV:	PUT RCV INTO PCCB
:	--------
:	INPUT:
:		R1 = CLCMDS DATA
:		R2 = CLLNG  DATA
:		R3 = CLARG  DATA
:		R11 = PUCTAB
PTRCV
	LB	R4,PUCTAB+PUCT.N,R11,	:GET REL PU #
	LHL	R13,PCBPTR,R4,R4	:GET PCB OFFSET
:	LHL	R13,PCBPTR,R10,R10	:GET PCB OFFSET
	JAL	R4,GETCL,,		:GET A CMD CELL
	J	DLCCL
	LHL	R4,PCBBLK+PCQBRP,R13,	:GET PUT PTR
	LIS	R0,DLCLNK		:DLC DATA FRAME
	STB	R0,CMDBLK+CLCMD,R4,	:PUT IN CLCMD
	STB	R1,CMDBLK+CLCMDS,R4,	:PUT IN CLCMDS
	STH	R2,CMDBLK+CLLNG,R4,	:PUT IN CLLNG
	BBST	R3,CMDBLK+CLARG,R4,	:PUT IN CLARG
	STH	R6,CMDBLK+CLPTR,R4,	:LINK NEW CMD CELL
	STH	R6,PCBBLK+PCQBRP,R13,	:UPDATE PUT PTR
	STH	R6,PCBBLK+PCQBRR,R13,	:RELEASE RCV
	LB	R0,PUCTAB+PUCT.N,R11,	:GET PU ID#
	SBT	R0,DPDLPC,,		:SET RCV PRESENT
	JR	R9			:RETURN


:	DLTXMT:	DELETE XMT DATA&BUFFER
:	--------
DLTXMT
	ST	R9,LR9SAV,,		:SAVE R9
	JAL	R9,GTXMT		:GET THE CMD
	LR	R3,R3			:SEE IF XMT WITH DATA BUFFER
	JE	DLTXM1			:NO DATA BUFFER
	JAL	R9,XMTDLT		:DELETE XMT DATA BUFFER
DLTXM1
	L	R9,LR9SAV,,		:GET RETRUN LINK REGISTER
	JR	R9


:	DLTRCV:	DELETE RCV DATA&BUFFER
:	--------
DLTRCV
	ST	R9,LR9SAV,,		:SAVE R9
	JAL	R9,GTRCV		:GET THE RCV CMD
	LR	R3,R3			:SEE IF RCV WITH DATA BUFFER
	JE	DLTRC1			:NO DATA BUFFER
	JAL	R9,RCVDLT		:DELETE RCV DATA BUFFER
DLTRC1
	L	R9,LR9SAV,,		:GET RETRUN LINK REGISTER
	JR	R9


:	DLTCMD: DELETE CMD DATA&BUFFER
:	--------
:	ASSUME CONTROL CMD HAS NO DATA BUFFER NOW
DLTCMD
	J	GTCMD			:SAME AS FETCH CMD


:	FLHXMT: FLUSH XMT QUEUE
:	--------
FLHXMT
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


:	FLHRCV: FLUSH RCV QUEUE
:	--------
FLHRCV
FLHRC0
	LHL	R6,LSCLKS+SGPRCV,R12,	:GET GET PTR
:	CLH	R6,LSCLKS+SRPRCV,R12,	:COMP WITH RELEASE PTR (01/02/85 MIA)
	LHL	R3,LSCLKS+SRPRCV,R12,	:GET RELEASE PTR (01/02/85 MIA)
	CR	R6,R3			:COMP GET AND REL PTR (01/02/85 MIA)
	JER	R9			:QUEUE EMPTY, DONE
	BBL	R3,CMDBLK+CLARG,R6,	:GET CLARG DATA
	LB	R1,CMDBLK+CLCMDS,R6,	:GET SCC DATA
	LHL	R2,CMDBLK+CLLNG,R6,	:GET CLLNG DATA
:	LHL	R4,CMDBLK+CLPTR,R6,	: (01/02/85 MIA)
	LH	R4,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK (01/02/85 MIA)
	JE	CLERR,,			:CRASH, IF ADVANCING AN EMPTY LIST
	STH	R4,LSCLKS+SGPRCV,R12,	:ADVANCE TO NEXT
	LB	R0,LSCLKS+LSCRID,R12,	:GET REL LKS ID#
	RBT	R0,LCBTAB+LDARCV,R7,	:FIRST TURN OFF DATA PRESENT FIRST
	CLH	R4,LSCLKS+SRPRCV,R12,	:SEE IF MORE RCV PRESENT
	JEFS	.+08			:SKIP, IF NONE
	SBT	R0,LCBTAB+LDARCV,R7,	:ELSE, TURN ON PRESENT BIT
	JAL	R4,RELCL,,		:RELEASE THE CMD CELL
	LR	R3,R3			:DOUBLE CHECK
	JE	FLHRC0			:REPEAT
	ST	R5,LR5SAV,,		:SAVE R5
FLHRC1
	BBL	R5,BBUFER+BBFLSZ-BBFPSZ,R3,	:GET NEXT BB ADDR
	JAL	R4,PBB,,		:RELEASE THIS BB
	LHL	R4,PUCTAB+PUCLNC,R11,	:R4 = LNC OFFSET
	LIS	R0,1
	AHM	R0,LNCTAB+LNRBUS,R4,	:INCREASE BB USAGE BY 1 IN LNC
	AHM	R0,PUCTAB+PURBUS,R11,	:INCREASE BB USAGE BY 1 IN PUC
	LR	R3,R5			:NEXT BB ADDR TO R3, AND SEE IF MORE
	JN	FLHRC1			:MORE, LOOP
	L	R5,LR5SAV,,		:RESTORE R5
	J	FLHRC0			:ELSE, NEXT Q-ELEMENT

:	DLCCL:	CMD ELEMENT EMPTY
:	------
DLCCL
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

	SEG	A.DATA
SAVREG	HS	20			:SAVE REGISTER.

	SEG	A.CODE
	
:	RECINF: INFORMATION TRACE, TRACE 16 BYTES.
:	------------------------------------------
:	INPUT	
:		R0 = RCV, XMT OR DISCARD CODE
:		R3 = CLARG DARG
:		R11 = PUCB

RECINF
	LB	R4,PUCTAB+PULNKN,R11,	:GET LINE #
	TBT	R4,INFTLN,,		:RECORD LINE? (12/02/86 YLH) RX3
	JNFS	RECIN4			:Y - RECORD IT
	LB	R4,PUCTAB+PUCT.N,R11,	:GET REL. ID
	TBT	R4,INFTCU,,		:NEED TO RECORD THIS CU? (12/02/86 YLH) RX3
	JER	R9			:N - RETURN
RECIN4	STM	R0,SAVREG,,		:SAVE IT (12/01/86 YLH)
	LHL	R4,IFTRIX,,		:GET TRACE INDEX (12/02/86 YLH) RX3
	STB	R0,IFTRBF,R4,		:RECORD XMT/RCV/DISCARD CODE
	LIS	R8,0			:INIT COUNTER
RECIN5	LB	R0,BBUFER,R8,R3		:GET DATA
	STB	R0,IFTRBF+1,R8,R4	:RECORD DATA
	CHI	R8,IFTLEN*INTRLG-2	:RECORD ALL DATA NEEDED?
	JGEFS	RECIN7			:Y - SKIP
	AIS	R8,1			:INCREMENT COUNTER
	J	RECIN5			:CONTINUE
RECIN7	AHI	R4,IFTLEN		:UPDATE INDEX
	CLHI	R4,IFTBUF*INTRCE	:WRAP AROUND
	JLFS	RECIN9			:N - SKIP
	LIS	R4,0			:ELSE RESET INDEX
RECIN9
	STH	R4,IFTRIX,,		:UPDATE INDEX (12/02/86 YLH) RX3
	LM	R0,SAVREG,,		:RESTORE REG. (12/01/86 YLH)
	JR	R9

	FO	CMDLST
	FO	GBLDEF
	FO	MAIN
	EM
 	SUBTTL	(SNA) LOCAL DLC LAYER PRIMARY PROCESSING ROUTINES - DLCPRO
:DLCP00.Z00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	MO	.,DLCPRO

	LO	CBKDEF			:(12/02/86 YLH)
	LO	DLCPRO
	LO	GBLDEF
	LO	CMDLST
	LO	MAIN
	LO	BSUB

	SEG	A.CODE

	SUBTTL	(SNA) LOCAL DLC LAYER - PRIMARY - STATE TABLES


:	LPNDM:	DLC AT NDM STATE
:	-------------------------
:	DISCARD ALL DATA RCV'ED FROM F.G.
:	LOOK FOR HIGHER-LEVEL COMMANDS
	HS	0
LPNDM	HC	LPCNDM-PSEG	:CMD PROC TABLE
	HC	LPXNDM-PSEG	:XMT PROC TABLE
	HC	LPRNDM-PSEG	:RCV PROC TABLE

:	IFNC->DLC
LPCNDM	HC	LPCNCL-PSEG	:00 - CLR, SET CLR & CMD<CLR> I.N.
	HC	LPCNTM-PSEG	:01 - TRM, SET TRM & CMD<TRM> I.N.
	HC	LPCNIN-PSEG	:02 - INIT, XMT<XID>/LPXID
				:	OR XMT<SNRM>/LPWOP

:	PC->DLC
LPXNDM	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPXNDA-PSEG	:1  - INFORMATION, DISCARD
	HC	LPXNSN-PSEG	:2  - SNRM, CRASH
	HC	LPXNUA-PSEG	:3  - UA, CRASH
	HC	LPXNDS-PSEG	:4  - DISC, CRASH
	HC	LPXDDM-PSEG	:5  - DM, CRASH
	HC	LPXNSM-PSEG	:6  - SIM, CRASH
	HC	LPXNXD-PSEG	:7  - XID, CRASH
	HC	LPXNTS-PSEG	:8  - TEST, CRASH
	HC	LPXNFR-PSEG	:9  - FRMR, CRASH

:	DLC->NWKC/PC
LPRNDM	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPRNDA-PSEG	:1  - INFORMATION, DISCARD
	HC	LPRNSN-PSEG	:2  - SNRM, CRASH
	HC	LPRNUA-PSEG	:3  - UA, DISCARD
	HC	LPRNRD-PSEG	:4  - RD, DISCARD
	HC	LPRNDM-PSEG	:5  - DM, DISCARD
	HC	LPRNRM-PSEG	:6  - RIM, CRASH
	HC	LPRNXD-PSEG	:7  - XID, CRASH NOW (XMT<XID> LPXID?)
				:	DISCARD IF CLR/TRM ON
	HC	LPRNTS-PSEG	:8  - TEST, XMT<TEST> (DISCARD, IF CLR/TRM ON)
	HC	LPRNFR-PSEG	:9  - FRMR, CRASH
	HC	LPRNCL-PSEG	:0A - RSP<CLR>,RST CLR & RSP<CLR> I.N.
	HC	LPRNTM-PSEG	:0B - RSP<TRM>,RST TRM & RSP<TRM> I.N.
	HC	LPRNDS-PSEG	:0C - RSP<DISC>, LPNDM
	HC	LPRNXE-PSEG	:0D - RSP<XMT>, RECOVER
	HC	LPRNNF-PSEG	:0E - RSP<NEF>, CRASH NOW
	HC	LPRNNO-PSEG	:0F - RSP<INOP>, RECOVER
	HC	LPRNBY-PSEG	:10 - RSP<BUSY>, CRASH NOW

:	LPXID:	DLC AT XID STATE
:	-------------------------
:	DISCARD ALL DATA RCV'ED FROM F.G., EXCEPT XID/FRMR AND RSP
	HS	0
LPXID	HC	LPCXID-PSEG	:CMD PROC TABLE
	HC	LPXXID-PSEG	:XMT PROC TABLE
	HC	LPRXID-PSEG	:RCV PROC TABLE

:	IFNC->DLC
LPCXID	HC	LPCXCL-PSEG	:00 - CLR, SET CLR & CMD<CLR> & LPNDM
	HC	LPCXTM-PSEG	:01 - TRM, SET TRM & CMD<TRM> & LPNDM
	HC	LPCXIN-PSEG	:02 - INIT, CRASH

:	PC->DLC
LPXXID	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPXXDA-PSEG	:1  - INFORMATION, CRASH NOW
	HC	LPXXSN-PSEG	:2  - SNRM, CRASH
	HC	LPXXUA-PSEG	:3  - UA, CRASH
	HC	LPXXDS-PSEG	:4  - DISC, CRASH
	HC	LPXXDM-PSEG	:5  - DM, CRASH
	HC	LPXXSM-PSEG	:6  - SIM, CRASH
	HC	LPXXXD-PSEG	:7  - XID, CRASH
	HC	LPXXTS-PSEG	:8  - TEST, CRASH
	HC	LPXXFR-PSEG	:9  - FRMR, CRASH

:	DLC->NWK/PC
LPRXID	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPRXDA-PSEG	:1  - INFORMATION, DISCARD
	HC	LPRXSN-PSEG	:2  - SNRM, CRASH
	HC	LPRXUA-PSEG	:3  - UA, CRASH NOW
	HC	LPRXRD-PSEG	:4  - RD, CRASH NOW
	HC	LPRXDM-PSEG	:5  - DM, CRASH NOW
	HC	LPRXRM-PSEG	:6  - RIM, CRASH NOW
	HC	LPRXXD-PSEG	:7  - XID, RSP<INIT> & LPNDM
	HC	LPRXTS-PSEG	:8  - TEST, CRASH NOW
	HC	LPRXFR-PSEG	:9  - FRMR, RSP<INIT> & LPNDM
	HC	LPRXCL-PSEG	:0A - RSP<CLR>, CRASH
	HC	LPRXTM-PSEG	:0B - RSP<TRM>, CRASH
	HC	LPRXDS-PSEG	:0C - RSP<DISC>, LPNDM
	HC	LPRXXE-PSEG	:0D - RSP<XMT>, RECOVER
	HC	LPRXNF-PSEG	:0E - RSP<NEF>, CRASH NOW
	HC	LPRXNO-PSEG	:0F - RSP<INOP>, RECOVER
	HC	LPRXBY-PSEG	:10 - RSP<BUSY>, CRASH NOW

:	LPWOP: PRIMARY AT WOP STATE
:	---------------------------
:	FROM F.G., LOOKING FOR UA, DM, RSP
:	FROM NETWORK, LOOKING FOR HCMD
	HS	0
LPWOP	HC	LPCWOP-PSEG	:CMD PROC TABLE
	HC	LPXWOP-PSEG	:XMT PROC TABLE
	HC	LPRWOP-PSEG	:RCV PROC TABLE

:	IFNC->DLC
LPCWOP	HC	LPCPCL-PSEG	:00 - CLR, SET CLR & CMD<CLR> & LPNDM
	HC	LPCPTM-PSEG	:01 - TRM, SET TRM & CMD<TRM> & LPNDM
	HC	LPCPIN-PSEG	:02 - INIT, CRASH NOW

:	PC->DLC
LPXWOP	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPXPDA-PSEG	:1  - INFORMATION, DISMISS
	HC	LPXPSN-PSEG	:2  - SNRM, CRASH
	HC	LPXPUA-PSEG	:3  - UA, CRASH
	HC	LPXPDS-PSEG	:4  - DISC, CRASH
	HC	LPXPDM-PSEG	:5  - DM, CRASH
	HC	LPXPSM-PSEG	:6  - SIM, CRASH
	HC	LPXPXD-PSEG	:7  - XID, CRASH
	HC	LPXPTS-PSEG	:8  - TEST, CRASH
	HC	LPXPFR-PSEG	:9  - FRMR, CRASH

:	DLC->NWKC/PC
LPRWOP	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPRPDA-PSEG	:1  - INFORMATION, CRASH
	HC	LPRPSN-PSEG	:2  - SNRM, CRASH
	HC	LPRPUA-PSEG	:3  - UA, RSP<OP> & LPOP
	HC	LPRPRD-PSEG	:4  - RD, CRASH
	HC	LPRPDM-PSEG	:5  - DM, RSP<DM> & LPNDM
	HC	LPRPRM-PSEG	:6  - RIM, CRASH
	HC	LPRPXD-PSEG	:7  - XID, CRASH NOW
	HC	LPRPTS-PSEG	:8  - TEST, CRASH NOW
	HC	LPRPFR-PSEG	:9  - FRMR, CRASH NOW
	HC	LPRPCL-PSEG	:0A - RSP<CLR>, CRASH
	HC	LPRPTM-PSEG	:0B - RSP<TRM>, CRASH
	HC	LPRPDS-PSEG	:0C - RSP<DISC>, RSP<DM> & LPNDM
	HC	LPRPXE-PSEG	:0D - RSP<XMT>, RECOVER
	HC	LPRPNF-PSEG	:0E - RSP<NEF>, CRASH NOW
	HC	LPRPNO-PSEG	:0F - RSP<INOP>, RECOVER
	HC	LPRPBY-PSEG	:10 - RSP<BUSY>, CRASH NOW

:	LPOP: PRIMARY AT OP STATE
:	---------------------------
:	FROM F.G., LOOKING ALL CMD
:	FROM NETWORK, LOOKING FOR HCMD
	HS	0
LPOP	HC	LPCOP-PSEG	:CMD PROC TABLE
	HC	LPXOP-PSEG	:XMT PROC TABLE
	HC	LPROP-PSEG	:RCV PROC TABLE

:	IFNC->DLC
LPCOP	HC	LPCOCL-PSEG	:00 - CLR, SET CLR & CMD<CLR> & LPNDM
	HC	LPCOTM-PSEG	:01 - TRM, SET TRM & CMD<TRM>
	HC	LPCOIN-PSEG	:02 - INIT, CRASH

:	PC->DLC
LPXOP	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPXODA-PSEG	:1  - INFORMATION, XMT<INF>(DISCARD, IF TRM ON)
	HC	LPXOSN-PSEG	:2  - SNRM, CRASH
	HC	LPXOUA-PSEG	:3  - UA, CRASH
	HC	LPXODS-PSEG	:4  - DISC, CRASH
	HC	LPXODM-PSEG	:5  - DM, CRASH
	HC	LPXOSM-PSEG	:6  - SIM, CRASH
	HC	LPXOXD-PSEG	:7  - XID, CRASH
	HC	LPXOTS-PSEG	:8  - TEST, CRASH
	HC	LPXOFR-PSEG	:9  - FRMR, CRASH

:	DLC->NWKC/PC
LPROP	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPRODA-PSEG	:1  - INFORMATION, RCV<INF>
	HC	LPROSN-PSEG	:2  - SNRM, CRASH
	HC	LPROUA-PSEG	:3  - UA, CRASH NOW
	HC	LPRORD-PSEG	:4  - RD, XMT<DISC> & RSP<DISC> & LPWNDM
	HC	LPRODM-PSEG	:5  - DM, RSP<DM> & LPNDM
	HC	LPRORM-PSEG	:6  - RIM, XMT<SIM> & RSP<SIM> & LPNDM
	HC	LPROXD-PSEG	:7  - XID, CRASH NOW
	HC	LPROTS-PSEG	:8  - TEST, XMT<TEST>
	HC	LPROFR-PSEG	:9  - FRMR, CRASH NOW (RECOVERY)
	HC	LPROCL-PSEG	:0A - RSP<CLR>, CRASH
	HC	LPROTM-PSEG	:0B - RSP<TRM>, XMT<DISC> & RSP<TRM> & LPWNDM
	HC	LPRODS-PSEG	:0C - RSP<DISC>, RSP<DM> & LPNDM
	HC	LPROXE-PSEG	:0D - RSP<XMT>, RECOVER
	HC	LPRONF-PSEG	:0E - RSP<NEF>, CRASH NOW
	HC	LPRONO-PSEG	:0F - RSP<INOP>, RECOVER
	HC	LPROBY-PSEG	:10 - RSP<BUSY>, CRASH NOW

:	LPWNDM: PRIMARY AT WNDM STATE
:	-----------------------------
:	FROM F.G., LOOKING ALL CMD
:	FROM NETWORK, LOOKING FOR HCMD
	HS	0
LPWNDM	HC	LPCWND-PSEG	:CMD PROC TABLE
	HC	LPXWND-PSEG	:XMT PROC TABLE
	HC	LPRWND-PSEG	:RCV PROC TABLE

:	IFNC->DLC
LPCWND	HC	LPCWCL-PSEG	:00 - CLR, SET CLR & CMD<CLR> & LPNDM
	HC	LPCWTM-PSEG	:01 - TRM, RSP<TRM>
	HC	LPCWIN-PSEG	:02 - INIT, CRASH 

:	NWKC/PC->DLC
LPXWND	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPXWDA-PSEG	:1  - INFORMATION, DISCARD
	HC	LPXWSN-PSEG	:2  - SNRM, CRASH
	HC	LPXWUA-PSEG	:3  - UA, CRASH
	HC	LPXWDS-PSEG	:4  - DISC, CRASH
	HC	LPXWDM-PSEG	:5  - DM, CRASH
	HC	LPXWSM-PSEG	:6  - SIM, CRASH
	HC	LPXWXD-PSEG	:7  - XID, CRASH
	HC	LPXWTS-PSEG	:8  - TEST, CRASH
	HC	LPXWFR-PSEG	:9  - FRMR, CRASH

:	DLC->NWKC/PC
LPRWND	HC	LPCRSH-PSEG	:0  - CRASH
	HC	LPRWDA-PSEG	:1  - INFORMATION, DISCARD
	HC	LPRWSN-PSEG	:2  - SNRM, CRASH
	HC	LPRWUA-PSEG	:3  - UA, RSP<DM> & LPNDM
	HC	LPRWRD-PSEG	:4  - RD, XMT<DISC>
	HC	LPRWDM-PSEG	:5  - DM, RSP<DM> & LPNDM
	HC	LPRWRM-PSEG	:6  - RIM, CRASH
	HC	LPRWXD-PSEG	:7  - XID, CRASH
	HC	LPRWTS-PSEG	:8  - TEST, CRASH
	HC	LPRWFR-PSEG	:9  - FRMR, CRASH
	HC	LPRWCL-PSEG	:0A - RSP<CLR>, CRASH
	HC	LPRWTM-PSEG	:0B - RSP<TRM>, CRASH
	HC	LPRWDS-PSEG	:0C - RSP<DISC>, RSP<DM> & LPNDM
	HC	LPRWXE-PSEG	:0D - RSP<XMT>, RECOVER
	HC	LPRWNF-PSEG	:0E - RSP<NEF>, CRASH NOW
	HC	LPRWNO-PSEG	:0F - RSP<INOP>, RECOVER
	HC	LPRWBY-PSEG	:10 - RSP<BUSY>, CRASH NOW

:	LPCRSH:	CRASH ROUTINE FOR LOCAL PRIMARY
:	-----------------------------------------
LPCRSH
	JAL	R10,CRASH,,
	BC	0,0,0,088

	SUBTTL	(SNA) LOCAL DLC LAYER - PRIMARY - ROUTINES AT LPNDM STATE


:	INF FRAME, DISCARD
:	------------------
LPXNDA
	JAL	R9,GTXMT
	LIS	R0,IFTDIS		:INF DISCARD(10/15/85/TTW)
	JAL	R9,RECINF		:RECORD IT(10/15/85/TTW)
	JAL	R9,XMTDLT
	JR	R5

:	ILLEGAL CMDS, CRASH
:	-------------------
LPXNSN;LPXNUA;LPXNDS;LPXDDM;LPXNSM;LPXNXD;LPXNTS;LPXNFR
	LIS	R15,0
	J	LPCRSH

:	CLR/TRM CMD
:	---------
:	SET CLR/TRM & CMD<CLR/TRM> IF NECESSARY & RESET INNWDL
LPCNCL
	LA	R8,CLNWDL,,
	JFS	LPXNT1
LPCNTM
	LA	R8,TMNWDL,,
LPXNT1
	JAL	R9,GTCMD
	LB	R0,PUCTAB+PUCT.N,R11,
	RBT	R0,INNWDL,,
	SBT	R0,0,R8
	JNR	R5			:IF TRM/CLR ON, RETURN
	JAL	R9,PTCMD		:ELSE, CMD<CLR/TRM> TO FG
	JR	R5

:	INIT CMD
:	--------
:	DEPENDS ON THE SYSGEM EITHER XMT A SNRM FRAME AND ENTER LPWOP STATE
:	OR XMT AN XID FRAME AND ENTER LPXID STATE
LPCNIN
	JAL	R9,GTCMD
:CASE 1 TRANSMIT SNRM FRAME AND ENTER LPWOP STATE
LPXNI0
	LHI	R0,LPWOP-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
:LPXNI1					:(07/24/86 YLH)
	LIS	R1,CSNRM
LPXNI1					:(07/24/86 YLH)
	LIS	R2,0
	LIS	R3,0
	JAL	R9,PTXMT
	JR	R5

:	CASE 2 TRANSMIT XID FRAME AND ENTER LPXID STATE
LPXNI2
	JAL	R9,QUXID
	LHI	R0,LPXID-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	JR	R5

:	SPURIOUS FRAMES RCV'ED
:	----------------------
LPRNDA;LPRNUA;LPRNRD;LPRNDM
	JAL	R9,DLTRCV
	JR	R5

:	ILLEGAL FRAMES RCV'ED
:	---------------------
LPRNSN;LPRNRM;LPRNFR
	LIS	R15,01
	J	LPCRSH

:	XID FRAME RCV'ED
:	----------------
:	**** CRASH NOW
LPRNXD
	LIS	R15,02
	J	LPCRSH

:	TEST FRAMES RCV'ED
:	-------------------
:	RETURN THE RCV'ED FRAME
LPRNTS
	JAL	R9,GTRCV
	JAL	R9,PTXMT
	LR	R3,R3			:IF NO BB
	JR	R5
	LHL	R12,PUCTAB+PUCLNC,R11,
	LIS	R0,1
	AHM	R0,LNCTAB+LNRBUS,R12,
	AHM	R0,PUCTAB+PURBUS,R11,
	LCS	R0,1
	AHM	R0,LNCTAB+LNXBUS,R12,
	AHM	R0,PUCTAB+PUXBUS,R11,
	JR	R5

:	FG XMT ERROR OR INOP
:	--------------------
:	DO THE RECOVERY
LPRNXE
	LHI	R3,UPXMT
	JFS	LPRNN1
LPRNNO
	LHI	R3,UPINOP
LPRNN1
	LIS	R0,0
LPRNN2
	LIS	R1,1			:DLC ERROR
	JAL	R6,SEVLOG,,
	LHI	R0,LPNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	JAL	R9,GTRCV
	JAL	R9,RCVDLT
	LIS	R1,ERRRSP
	LIS	R2,0
	LIS	R3,0
	JAL	R9,PTRSP		:INFORM IFNC
	JR	R5
	
:	RSP<CLR/TRM>
:	--------------
:	RESET CLR/TRM FLAG, IF ON BEFORE, RSP<CLR/TRM> TO NWKC
LPRNCL
	LA	R8,CLNWDL,,
	JFS	LPRNM1
LPRNTM
	LA	R8,TMNWDL,,
LPRNM1
	JAL	R9,GTRCV
	LB	R0,PUCTAB+PUCT.N,R11,
	RBT	R0,0,R8
	JER	R5
	SHI	R1,CSTATE
	JAL	R9,PTRSP
	JR	R5

:	NOT EXPECTED FRAME OR BUSY
:	-------------------------
:	CRASH NOW
LPRNNF;LPRNBY
	LIS	R15,03
	J	LPCRSH

:	FG ENTER NDM MODE RSP
:	------------------------
LPRNDS
	JAL	R9,GTRCV
	LIS	R1,DISRSP
	LIS	R2,0
	LIS	R3,0
	JAL	R9,PTRSP
	LHI	R0,LPNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	JR	R5

	SUBTTL	(SNA) LOCAL DLC LAYER - PRIMARY - ROUTINES AT LPXID STATE


:	DATA CMD, CRASH
:	-----------------
LPXXDA
	LHI	R15,10
	J	LPCRSH

:	SPURIOUS CMDS IN THE XMT QUEUE, CRASH
:	------------------------------
LPXXSN;LPXXUA;LPXXDS;LPXXDM;LPXXSM;LPXXXD;LPXXTS;LPXXFR
	LHI	R15,11
	J	LPCRSH

:	CMD<CLR/TRM> FROM NWKC
:	---------
:	SET CRL/TRM FLAG, RESET INIT FLAG, SEND CMD<CLR/TRM> ENTER LPNDM STATE
LPCXCL
	LA	R8,CLNWDL,,
	JFS	LPXXT1
LPCXTM
	LA	R8,TMNWDL,,
LPXXT1
	LB	R0,PUCTAB+PUCT.N,R11,
	RBT	R0,INNWDL,,
	SBT	R0,0,R8
	JAL	R9,GTCMD
	JAL	R9,PTCMD
	LHI	R0,LPNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	JR	R5

:	INIT CMD ISSUED FROM HIGHER LAYER, CRASH
:	---------------------------------
LPCXIN
	LHI	R15,12
	J	LPCRSH

:	SPURIOUS RCV IN RCV QUEUE, DISCRAD
:	--------------------------
LPRXDA
	J	LPRNDA

:	ILLEGAL CMD IN RCV QUEUE
:	------------------------
LPRXSN;LPRXUA;LPRXRD;LPRXDM;LPRXRM;LPRXTS
	LHI	R15,13
	J	LPCRSH

:	XID FRAME RCV'ED
:	----------------
:	SCAN XID, IF O.K., RSP<+???>, ELSE RSP<-???>
:	ENTER LPNDM STATE
LPRXXD
	JAL	R9,GTRCV
	JAL	R9,SCAXID
	J	LPRXX1
:	RSP<+???>
:	LHI	R1,
	JFS	LPRXX2
LPRXX1
:	RSP<-???>
:	LHI	R1,
LPRXX2
	JAL	R9,PTRSP
	JR	R5

:	FRMR RCV'ED
:	-----------
:	DECIDE TO 1. ENTER LPNDM
:		2. SEND SNRM
LPRXFR
:CASE 1
	J	LPRPFR
:CASE 2
	J	LPXNI0

:	RSP<CLR/TRM> IN RCV QUEUE, DISCARD
:	--------------------------
LPRXCL;LPRXTM
	JAL	R9,GTRCV
	JR	R5

:	XMT ERROR , RECOVER
:	-------------------------
LPRXXE
	J	LPRNXE

:	RSP<INOP>, RECOVER
:	------------------
LPRXNO
	J	LPRNNO

:	NEF OR BUSY, CRASH NOW
:	-----------------------
LPRXNF
LPRXBY
	LHI	R15,14
	J	LPCRSH

:	DISC RSP, RSP<DISC> TO NWKC, AND ENTER LPNDM
:	------------
LPRXDS
	J	LPRNDS

	SUBTTL	(SNA) LOCAL DLC LAYER - PRIMARY - ROUTINES AT LPWOP STATE


:	INF CMD, DISCARD
:	-----------------
LPXPDA
	JAL	R9,GTXMT
	LIS	R0,IFTDIS		:INF DIISCARD(10/15/85/TTW)
	JAL	R9,RECINF		:RECORD IT(10/15/85/TTW)
	JAL	R9,XMTDLT
	JR	R5

:	ILLEGAL CMDS
:	--------------
LPXPSN;LPXPUA;LPXPDS;LPXPDM;LPXPSM;LPXPXD;LPXPTS;LPXPFR
	LHI	R15,20
	J	LPCRSH

:	CMD<CLR/TRM> FROM NWKC
:	---------
LPCPCL
	J	LPCXCL			:CMD<CLR>
LPCPTM
	J	LPCXTM			:CMD<TRM>

:	INIT CMD AGAIN, CRASH
:	---------------------
LPCPIN
	LHI	R15,21
	J	LPCRSH

:	INF FRAME RCV'ED , DISCARD
:	--------------------------
LPRPDA
	JAL	R9,GTRCV
	LIS	R0,IFTDIS		:INF DISCARD(10/15/85/TTW)
	JAL	R9,RECINF		:RECORD IT(10/15/85/TTW)
	JAL	R9,RCVDLT
	JR	R5

:	SNRM FRAME RCV'ED, CRASH
:	------------------------
LPRPSN
	LHI	R15,22
	J	LPCRSH

:	UA FRAME RCV'ED, ENTER LPOP
:	---------------------------
LPRPUA
	JAL	R9,GTRCV
	LIS	R1,INIRSP
	JAL	R9,PTRSP		:INFORM IFNC
	LHI	R0,LPOP-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	JR	R5

:	ILLEGAL FRAMES RCV'ED
:	---------------------
LPRPRD;LPRPRM;LPRPXD;LPRPTS
	LHI	R15,23
	J	LPCRSH

:	DM FRAME OR DISC RSP RCV'ED
:	-------------------------------
:	RSP<DISC> TO NWKC, ENTER LPNDM STATE
LPRPDM;LPRPDS
	J	LPRNDS

:	FRMR FRAME RCV'ED
:	-----------------
:	GET FRMRM PARAMETE FROM BB
LPRPFR
	LHL	R6,LSCLKS+SGPRCV,R12,
	BBL	R3,CMDBLK+CLARG,R6,
	LB	R1,CMDBLK+CLCMDS,R6,
	LHL	R2,CMDBLK+CLLNG,R6,
	LHI	R4,-BBFLSZ+BBFPSZ+2
	LB	R3,BBUFER+BBFLSZ-BBFPSZ,R3,R4
	AIS	R4,2
	LB	R0,BBUFER+BBFLSZ-BBFPSZ,R3,R4
	J	LPRNN2

:	XMT ERROR OR INOP
:	-----------------
LPRPXE
	J	LPRNXE
LPRPNO
	J	LPRNNO

:	CLR OR TRM RSP
:	--------------------
LPRPCL
	J	LPRNCL
LPRPTM
	J	LPRNTM

:	NEF OR BUSY, CRASH NOW
:	----------------------
LPRPNF;LPRPBY
	LHI	R15,24
	J	LPCRSH

	SUBTTL	(SNA) LOCAL DLC LAYER - PRIMARY - ROUTINES AT LPOP STATE


:	INF FRAME, TO F.G.
:	-------------------
LPXODA
	LHL	R12,PUCTAB+PUCLSC,R11,
	LIS	R0,1
	AHM	R0,LSCLKS+LSCIFC,R12,
	JAL	R9,GTXMT
	LIS	R0,IFTXMT		:TRACE INF XMT(10/15/85/TTW)
	JAL	R9,RECINF		:RECORD IT(10/15/85/TTW)
	JAL	R9,PTXMT
	JR	R5

:	ILLEGAL CMDS , CRASH
:	--------------------
LPXOSN;LPXOUA;LPXODS;LPXODM;LPXOSM;LPXOXD;LPXOTS;LPXOFR
	LHI	R15,40
	J	LPCRSH

:	SPURIOUS CMD, CRASH NOW
:	-----------------------
LPCOIN
	LHI	R15,41
	J	LPCRSH

:	CLR CMD OR TRM CMD
:	----------
LPCOCL
	J	LPCXCL
LPCOTM
	J	LPCXTM

:	INF FRAME
:	---------
LPRODA
	JAL	R9,GTRCV
	LIS	R0,IFTRCV		:TRACE INF RCVED(10/15/85/TTW)
	JAL	R9,RECINF		:RECORD INF. (10/15/85/TTW)
	JAL	R9,PTRCV
	JR	R5

:	SNRM FRAME, CRASH
:	-----------------
LPROSN
	LHI	R15,32
	J	LPCRSH

:	UA OR XID FRAME, CRASH NOW
:	----------------------------
LPROUA
LPROXD
	LHI	R15,33
	J	LPCRSH

:	RD FRAME
:	--------
:	RETURN DISC FRAME, RSP<DISC> TO NWKC,  AND ENTER LPWNDM
LPRORD
	JAL	R9,GTRCV
	LIS	R1,DISRSP
	LIS	R2,0
	LIS	R3,0
	JAL	R9,PTRSP
	LHI	R0,LPWNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	LIS	R1,CDISC
	J	LPXNI1

:	DM FRAME OR DISC RSP
:	-----------------------
:	RSP<DISC> TO NWKC, AND ENTER LPNDM STATE
LPRODM;LPRODS
	J	LPRNDS

:	RIM FRAME RCV'ED
:	-----------------
:	RETURN SIM, RSP<???> TO NWKC,  AND ENTER LPNDM
LPRORM
	JAL	R9,GTRCV
	LHI	R0,LPNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	LIS	R1,CSIM
	J	LPXNI1

:	TESET FRAME RCV'ED, RETURN TEST
:	--------------------------------
LPROTS
	J	LPRNTS

:	FRMR FRAME RCV'ED
:	------------------
LPROFR
	J	LPRPFR

:	XMT ERROR OR INOP
:	-----------------
LPROXE
	J	LPRNXE
LPRONO
	J	LPRNNO

:	CLR OR TRM  RSP
:	---------------------
LPROCL
	J	LPRNCL
LPROTM
	J	LPRNTM

:	NEF OR BUSY, CRASH NOW
:	----------------------
LPRONF;LPROBY
	J	LPCOIN

	SUBTTL	(SNA) LOCAL DLC LAYER - PRIMARY - ROUTINES AT LPWNDM STATE


:	INF FRAME, DISCARD
:	-------------------
LPXWDA
	JAL	R9,GTXMT
	LIS	R0,IFTDIS		:TRACE INF DISCARD(10/15/85/TTW)
	JAL	R9,RECINF		:RECORD IT(10/15/85/TTW)
	JAL	R9,XMTDLT
	JR	R5

:	ILLEGAL FRAMES
:	--------------
LPXWSN;LPXWUA;LPXWDS;LPXWDM;LPXWSM;LPXWXD;LPXWTS;LPXWFR
	LHI	R15,40
	J	LPCRSH

:	CLR CMD
:	----------
LPCWCL
	J	LPCXCL

:	TRM CMD
:	----------
LPCWTM
	J	LPCXTM

:	INIT CMD AGAIN, CRASH NOW
:	--------------------------
LPCWIN
	LHI	R15,41
	J	LPCRSH


:	INF FRAME RCV'ED, DISCARD
:	-------------------------
LPRWDA
	JAL	R9,GTRCV
	LIS	R0,IFTDIS		:TRACE INF DISCARD(10/15/85/TTW)
	JAL	R9,RECINF		:RECORD IT(10/15/85/TTW)
	JAL	R9,RCVDLT
	JR	R5

:	SNRM FRAME RCV'ED, CRASH
:	------------------------
LPRWSN
	LHI	R15,42
	J	LPCRSH

:	UA OR DM FRAME OR DISC RSP RCV'ED
:	----------------------------------
:	ENTER LPNDM STATE
LPRWUA;LPRWDM;LPRWDS
	J	LPRNDS

:	RD FRAME RCV'ED, RESEND DISC
:	---------------------------
LPRWRD
	JAL	R13,GTRCV
	LIS	R1,CDISC
	J	LPXNI1

:	ILLEGAL FRAME RCV'ED, CRASH NOW
:	-------------------------------
LPRWRM;LPRWXD;LPRWTS;LPRWFR
	LHI	R15,43
	J	LPCRSH

:	XMT ERROR OR INOP
:	-----------------
LPRWXE
	J	LPRNXE
LPRWNO
	J	LPRNNO

:	CLR OR TRM RSP
:	--------------------
LPRWCL
	J	LPRNCL
LPRWTM
	J	LPRNTM

:	NEF OR BUSY, CRASH NOW
:	----------------------
LPRWNF;LPRWBY
	LHI	R15,44
	J	LPCRSH


	FO	CMDLST
	FO	GBLDEF
	FO	MAIN
	FO	DLCPRO
	EM
	SUBTTL	(SNA) SNA DLC LAYER PROCESSOR FOR SECONDARY STATION - DLCPRO
:DLCP00.H00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	MO	.,DLCPRO

	LO	CBKDEF			:(12/02/86 YLH)
	LO	DLCPRO
	LO	BSUB
	LO	GBLDEF
	LO	CMDLST
	LO	MAIN

	SEG	A.CODE

	SUBTTL	(SNA) LOCAL DLC LAYER - SECONDARY - STATE TABLES


:	NSINIT:	SECONDARY AT NDM STATE
:	------------------------------
:	DISCARD ALL DATA RCV'ED FROM F.G., EXCEPT SNRM, DISC, SIM, XID AND TEST
:	LOOK FOR INITCD FROM HIGHER-LEVEL PROCESS, AND SET INIT FLAG ON
	HS	0
LSNDM	HC	LSCNDM-PSEG	:CMD PROC TABLE
	HC	LSXNDM-PSEG	:XMT PROC TABLE
	HC	LSRNDM-PSEG	:RCV PROC TABLE

:	IFNC->DLC
LSCNDM	HC	LSCDCL-PSEG	:00 - CLR, SET CLR & CMD<CLR> I.N.
	HC	LSCDTM-PSEG	:0B - TRM, SET TRM & CMD<TRM> & LSNDM
	HC	LSCDIN-PSEG	:0C - INIT, CMD<INIT>

:	/PC->DLC
LSXNDM	HC	LSCRSH-PSEG	:0  - CRASH
	HC	LSXDDA-PSEG	:1  - INFORMATION, DISCARD
	HC	LSXDSN-PSEG	:2  - SNRM, CRASH
	HC	LSXDUA-PSEG	:3  - UA, CRASH
	HC	LSXDRD-PSEG	:4  - RD, CRASH
	HC	LSXDDM-PSEG	:5  - DM, CRASH
	HC	LSXDRM-PSEG	:6  - RIM, CRASH
	HC	LSXDXD-PSEG	:7  - XID, CRASH
	HC	LSXDTS-PSEG	:8  - TEST, CRASH
	HC	LSXDFR-PSEG	:9  - FRMR, CRASH

:	DLC->NWKC/PC
LSRNDM	HC	LSCRSH-PSEG	:0  - CRASH
	HC	LSRDDA-PSEG	:1  - INFORMATION, DISCARD & XMT<DM>
	HC	LSRDSN-PSEG	:2  - SNRM, XMT<DM> IF INIT OFF /XMT<UA>
	HC	LSRDUA-PSEG	:3  - UA, CRASH
	HC	LSRDDS-PSEG	:4  - DISC, XMT<DM>
	HC	LSRDDM-PSEG	:5  - DM, CRASH
	HC	LSRDSM-PSEG	:6  - SIM, XMT<UA> IF INIT ON/XMT<DM>
	HC	LSRDXD-PSEG	:7  - XID, XMT<XID> IF INIT ON/XMT<DM>
	HC	LSRDTS-PSEG	:8  - TEST, XMT<TEST> IF INIT ON/XMT<DM>
	HC	LSRDFR-PSEG	:9  - FRMR, CRASH
	HC	LSRDCL-PSEG	:0A - RSP<CLR>, RST CLR & RSP<CLR>
	HC	LSRDTM-PSEG	:0B - RSP<TRM>, RST TRM & RSP<TRM>
	HC	LSRDDC-PSEG	:0C - RSP<DISC>, IGNORE
	HC	LSRDXE-PSEG	:0D - RSP<XMT>, RECOVER
	HC	LSRDFS-PSEG	:0E - RSP<FRMR>, RECORD
	HC	LSRDNO-PSEG	:0F - RSP<INOP>, RECOVERY (5/1/0/85/CHS)

:	LSOP:	SECONDARY AT OP STATE
:	-----------------------------
	HS	0
LSOP	HC	LSCOP-PSEG	:CMD PROC TABLE
	HC	LSXOP-PSEG	:XMT PROC TABLE
	HC	LSROP-PSEG	:RCV PROC TABLE

:	IFNC->DLC
LSCOP	HC	LSCOCL-PSEG	:00 - CLR, SET CLR & CMD<CLR> & LSNDM
	HC	LSCOTM-PSEG	:01 - TRM, SET TRM & CMD<TRM> & LSNDM
	HC	LSCOIN-PSEG	:02 - INIT, CRASH

:	/PC->DLC
LSXOP	HC	LSCRSH-PSEG	:0  - CRASH
	HC	LSXODA-PSEG	:1  - INFORMATION, XMT<INF>
	HC	LSXOSN-PSEG	:2  - SNRM, CRASH
	HC	LSXOUA-PSEG	:3  - UA, CRASH
	HC	LSXORD-PSEG	:4  - RD, CRASH
	HC	LSXODM-PSEG	:5  - DM, CRASH
	HC	LSXORM-PSEG	:6  - RIM, CRASH
	HC	LSXOXD-PSEG	:7  - XID, CRASH
	HC	LSXOTS-PSEG	:8  - TEST, CRASH
	HC	LSXOFR-PSEG	:9  - FRMR, CRASH

:	DLC->NWKC/PC
LSROP	HC	LSCRSH-PSEG	:0  - CRASH
	HC	LSRODA-PSEG	:1  - INFORMATION, RCV<INF>
	HC	LSROSN-PSEG	:2  - SNRM, RSP<INIT> & XMT<DM> & ENTER LSNDM
	HC	LSROUA-PSEG	:3  - UA, CRASH
	HC	LSRODS-PSEG	:4  - DISC, XMT<UA> & RSP<DM> & LSNDM
	HC	LSRODM-PSEG	:5  - DM, CRASH
	HC	LSROSM-PSEG	:6  - SIM, XMT<UA>
	HC	LSROXD-PSEG	:7  - XID, XMT<ID>
	HC	LSROTS-PSEG	:8  - TEST, XMT<TEST>
	HC	LSROFR-PSEG	:9  - FRMR, CRASH
	HC	LSROCL-PSEG	:0A - RSP<CLR>, CRASH
	HC	LSROTM-PSEG	:0B - RSP<TRM>, CRASH
	HC	LSRODS-PSEG	:0C - RSP<DISC>, RSP<DM> & LSNDM
	HC	LSROXE-PSEG	:0D - RSP<XMT>, RECOVER
	HC	LSROFS-PSEG	:0E - RSP<FRMR>, RSP<DM> & RECORD & LSNDM
	HC	LSRONO-PSEG	:0F - RSP<INOP>, RECOVER (5/10/85/CHS)


:	LSCRSH: CRASH ROUTINE FOR LOCAL SECONDARY
:	------------------------------------------
LSCRSH
	JAL	R10,CRASH,,
	BC	0,0,0,088

	SUBTTL	(SNA) LOCAL DLC LAYER - SECONDARY - ROUTINES AT LSNDM STATE


:	INF FRAME
:	------------
:	DISCARD
LSXDDA
	JAL	R9,GTXMT		:DISCARD XMT CMD & BBS
	LIS	R0,IFTDIS		:INF FRAME DISCARDED.(10/9/85/TTW)
	JAL	R9,RECINF		:TRACE 10H BYTES(10/9/85/TTW)
	JAL	R9,XMTDLT		:...
	JR	R5

:	ILLEGAL CMDS
:	------------
LSXDSN;LSXDUA;LSXDRD;LSXDDM;LSXDRM;LSXDXD;LSXDTS;LSXDFR
	LIS	R15,0
	J	LSCRSH

:	CLR/TRM CMDS
:	---------------
:	RESET INNWDL FLAG
:	SET CRNWDL/TMNWDL FLAG, IF ALREADY SET, IGNORE
:	ELSE, CMD<CLR/TRM>
LSCDCL
	LA	R8,CLNWDL,,		:R8 = ADD OF FLAG
	JFS	LSXDT1			:SKIP TO CONTINUE
LSCDTM
	LA	R8,TMNWDL,,		:R8 = ADDR OF FLAG
LSXDT1
	JAL	R9,GTCMD		:GET THE CMD
	LB	R0,PUCTAB+PUCT.N,R11,
	RBT	R0,INNWDL,,		:RESET THE INIT FLAG
	SBT	R0,0,R8			:SET CLR/TRM FLAG
	JNR	R5			:IF ALREADY ON, RETURN
	JAL	R9,PTCMD		:ELSE, CMD<CLR/TRM>
	JAL	R9,FLHRCV		:FLUSH RCV-Q (1/4/85/CHS)
	JR	R5

:	INIT CMD
:	--------
:	RESET THE CLR/TRM FLAGS
:	SET INIT FLAG ON, IF NOT ON BEFORE, CMD<INIT>
LSCDIN
	JAL	R9,GTCMD
	LB	R9,PUCTAB+PUCT.N,R11,
	RBT	R9,CLNWDL,,
	RBT	R9,TMNWDL,,
	SBT	R9,INNWDL,,
	JR	R5

:	INF FRMAE, DISCARD
:	------------------
LSRDDA
	JAL	R9,GTRCV		:DISCARD RCV DATA
	LIS	R0,IFTDIS		:INF FRAME DISCARDED(10/9/85/TTW)
	JAL	R9,RECINF		:RECORD 10H BYTES(10/9/85/TTW)
	JAL	R9,RCVDLT		:..
	JR	R5

:	SNRM/SIM FRAME RCV'ED
:	-----------------
:	IF INIT FLAG ON, RETURN UA, ELSE RETURN DM
LSRDSN;LSRDSM
	JAL	R9,GTRCV
	LB	R0,PUCTAB+PUCT.N,R11,
	LIS	R1,CDM			:ASSUME NOT READY
	TBT	R0,INNWDL,,		:TEST IT
	JEFS	LSRDS1			:HIT, TO SENT DM
	LIS	R1,INIRSP
	JAL	R9,PTRSP		:INFORM IFNC
	LHI	R0,LSOP-PSEG
	STH	R0,PUCTAB+PULSNM,R11,	:...
	JAL	R9,FLHRCV		:FLUSH RCV-Q
	LIS	R1,CUA			:INFORM FG WITH UA
LSRDS1
	LIS	R2,0			:R2 = 0
	JAL	R9,PTXMT
	JR	R5

:	DISC FRAME RCV'ED
:	-----------------
:	IF INIT FLAG ON, RETURN UA, ELSE RETURN DM
LSRDDS
	JAL	R9,GTRCV
	LB	R0,PUCTAB+PUCT.N,R11,
	LIS	R1,CDM			:ASSUME NOT READY
:	TBT	R0,INNWDL		:TEST IT(4/26/85/CHS)
:	JEFS	LSRDD1			:HIT, TO SENT DM(4/26/85/CHS)
:	LIS	R1,CUA			:INFORM FG WITH UA(4/26/85/CHS)
LSRDD1
	LIS	R2,0			:R2 = 0
	JAL	R9,PTXMT
	JR	R5

:	ILLEGAL FRAMES
:	--------------
:	UA, DM , FRAM ARE ILLEGAL FRAMES
LSRDUA;LSRDDM;LSRDFR
	LIS	R15,1
	J	LSCRSH

:	XID CMD
:	-------
:	IF INIT OFF, RETURN DM
:	ELSE, SCAN XID AND RETURN FRMR/XID
LSRDXD
	JAL	R9,GTRCV
	LB	R0,PUCTAB+PUCT.N,R11,
	TBT	R0,INNWDL,,
	JNFS	LSRDX1
	JAL	R9,RCVDLT		:DELETE RCV'ED XID
	LIS	R1,CDM			:AND RETURN DM
	J	LSRDS1
LSRDX1
	JAL	R9,SCAXID
	J	LSRDX2			:XID O.K. AND SUPPORTED
	JAL	R9,RCVDLT		:DELETE RCV'ED XID
	LHI	R2,XID			:AND REPONSE WITH FRMR
	LHI	R3,80
	JAL	R9,QUFRMR
	JR	R5
LSRDX2
	JAL	R9,RCVDLT		:DELETE RCV'ED XID
	JAL	R9,QUXID
	JR	R5

:	TEST CMD
:	--------
:	IF INIT OFF, RETURN DM
:	ELSE, RETURN THS TEST CMD
LSRDTS
	JAL	R9,GTRCV
	LB	R0,PUCTAB+PUCT.N,R11,
	TBT	R0,INNWDL,,
	JNFS	LSRDT1
	LIS	R1,CDM
	J	LSRDS1
LSRDT1
:	UPDATE LNRBUS & LNXBUS
	JAL	R9,PTXMT
	LR	R3,R3			:IF NO BB
	JR	R5
	LHL	R12,PUCTAB+PUCLNC,R11,
	LIS	R0,1
	AHM	R0,LNCTAB+LNRBUS,R12,
	AHM	R0,PUCTAB+PURBUS,R11,
	LCS	R0,1
	AHM	R0,LNCTAB+LNXBUS,R12,
	AHM	R0,PUCTAB+PUXBUS,R11,
	JR	R5
	
:	XMT ERROR
:	----------
:	RECOVER
LSRDXE
:	LB	R0,PUCTAB+PUCT.N,R11,	:(10/07/85/CHS)(2/2/87/CHS)
:	RBT	R0,INNWDL		:(10/07/85/CHS) (2/2/87/CHS)
	JAL	R9,GTRCV
	LIS	R1,ERRRSP
	JAL	R9,PTRSP
	LHI	R3,USXMT
	LIS	R0,0
LSRDE1
	LIS	R1,1			:DLC ERROR
	JAL	R6,SEVLOG,,
	JR	R5

:	CLR/TRM RSP
:	--------------
:	RST CLR/TRM FLAG
LSRDCL
	LA	R8,CLNWDL,,
	JFS	LSRDM1
LSRDTM
	LA	R8,TMNWDL,,
LSRDM1
	LB	R0,PUCTAB+PUCT.N,R11,
	RBT	R0,0,R8
	JAL	R9,GTRCV
	SHI	R1,CSTATE
	JAL	R9,PTRSP
	JR	R5

:	FRMR REJECT SENT BY FG
:	-----------------------
:	RECORD
LSRDFS
	JAL	R9,GTRCV
	LIS	R1,ERRRSP
	JAL	R9,PTRSP
	LB	R0,R2			:GET 'C' BYTE
	EXBR	R3,R2			:GET THE REASON BYTE
	J	LSRDE1

:	DISC RSP
:	--------------
:	RSP<DISC> & ENTER LSNDM STATE
LSRDDC
:	LHL	R0,PUCTAB+PUCT.N,R11,	:RESET INNWCL FLAG(5/20/85/CHS)(4/30/86/CHS)
:	LB	R0,PUCTAB+PUCT.N,R11,	:RESET INNWCL FLAG(4/30/86/CHS)(2/2/87/CHS)
:	RBT	R0,INNWDL		:... (5/20/85/CHS) (2/2/87/CHS)
	JAL	R9,GTRCV
	LIS	R1,DISRSP
	JAL	R9,PTRSP
	LHI	R0,LSNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	JR	R5

:	(5/10/85/CHS)
:	INOP RSP
:	--------
:	RECOVER
LSRDNO
	JAL	R9,GTRCV
	LIS	R1,ERRRSP
	JAL	R9,PTRSP
	LHI	R3,USINOP
	LIS	R0,0
LSRDN1
	LIS	R1,1			:DLC ERROR
	JAL	R6,SEVLOG,,
	JR	R5

	SUBTTL	(SNA) LOCAL DLC LAYER - SECONDARY - ROUTINES AT LSOP STATE


:	INF FRAME
:	---------
LSXODA
	LHL	R12,PUCTAB+PUCLSC,R11,
	LIS	R0,1			:INCREASE IC COUNT
	AHM	R0,LSCLKS+LSCIFC,R12,	:...
	JAL	R9,GTXMT		:PASS TO F.G.
	LIS	R0,IFTXMT		:INF XMT CODE(10/9/85/TTW)
	JAL	R9,RECINF		:RECORD 10H BYTES(10/9/85/TTW)
	JAL	R9,PTXMT		:...
	JR	R5

:	ILLEAGE CMDS
:	------------
LSXOSN;LSXOUA;LSXORD;LSXODM;LSXORM;LSXOXD;LSXOTS;LSXOFR
	LHI	R15,10
	J	LSCRSH

:	SPURIOUS CMD
:	-------------
LSCOIN
	LHI	R15,10
	J	LSCRSH

:	CLR/TRM CMD
:	----------
LSCOCL
	LA	R8,CLNWDL,,
	JFS	LSXDT2
LSCOTM
	LA	R8,TMNWDL,,
LSXDT2
	LHI	R0,LSNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	J	LSXDT1

:	INF FRAME, SEND TO PCCB RCV Q
:	-----------------------------
LSRODA
	JAL	R9,GTRCV
	LIS	R0,IFTRCV		:INF RCV CODE(10/9/85/TTW)
	JAL	R9,RECINF		:RECORD 10H BYTES(10/9/85/TTW)
	JAL	R9,PTRCV
	JR	R5

:	SNRM OR SIM, RSP<INIT> & XMT<DM>
:	CORRECTION: RSP<DISC>,XMT<DM> AND ENTER LSNDM (03/30/85 MIA)
:	-----------------------
LSROSN;LSROSM
:	LHL	R0,PUCTAB+PUCT.N,R11,	:RESET INNWCL FLAG(5/20/85/CHS)(4/30/86/CHS)
	LB	R0,PUCTAB+PUCT.N,R11,	:RESET INNWCL FLAG(4/30/86/CHS)
	RBT	R0,INNWDL,,		:... (5/20/85/CHS)
:	LHI	R1,INIRSP		:(03/30/85 MIA)
	LHI	R1,DISRSP		:INFORM NIO (03/30/85 MIA)
	LHI	R2,LSNDM-PSEG		:GET LSNDM PTR (03/30/85 MIA)
	STH	R2,PUCTAB+PULSNM,R11,	:UPDATE STATE (03/30/85 MIA)
	LIS	R2,0
	LIS	R3,0
	JAL	R9,PTRSP
	JAL	R9,GTRCV
	LIS	R1,CDM
	J	LSRDS1

:	UA , DM AND FRMR ARE ILLEGAL
:	----------------------------
LSROUA;LSRODM;LSROFR
	LHI	R15,11
	J	LSCRSH

:	DISC RCV'ED, RETURN UA AND ENTER LSNDM STATE
:	--------------------------------------------
LSRODS
:	LHL	R0,PUCTAB+PUCT.N,R11,	:RESET INNWCL FLAG(5/20/85/CHS)(4/30/86/CHS)
	LB	R0,PUCTAB+PUCT.N,R11,	:RESET INNWCL FLAG(4/30/86/CHS)
	RBT	R0,INNWDL,,		:... (5/20/85/CHS)
	LHI	R1,DISRSP
	LIS	R2,0
	LIS	R3,0
	JAL	R9,PTRSP
	LHI	R0,LSNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	JAL	R9,GTRCV
	LIS	R1,CUA
	J	LSRDS1

:	RCV'ED XID
:	--------------
:	SCAN, AND RETURN XID/FRMR
LSROXD
	J	LSRDXD

:	RCV'ED TEST, RETURN THE SAME TEST FRAME
:	---------------------------------------
LSROTS
	J	LSRDTS

:	XMT ERROR, RECORD, AND ENTER LSNDM
:	----------------------------------------
LSROXE
	LB	R0,PUCTAB+PUCT.N,R11,	:RESET INNWCL FLAG(2/2/87/CHS)
	RBT	R0,INNWDL,,		:... (2/2/87/CHS)
	LHI	R0,LSNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	J	LSRDXE

:	CLR/TRM RSP, RST CLR/TRM
:	-------------------------
LSROCL;LSROTM
	LHI	R0,LSNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	J	LSRDTM

:	RSP<FRMR>, RECORD, AND ENTER LSNDM STATE & RSP<DISC>
:	-------------------------------------------
LSROFS
	LHI	R0,LSNDM-PSEG
	STH	R0,PUCTAB+PULSNM,R11,
	J	LSRDFS

:	RCV'ED RSP<DISC>
:	-----------------
:	ENTER LSNDM STATE
LSRODC
	LB	R0,PUCTAB+PUCT.N,R11,	:RESET INNWCL FLAG(2/2/87/CHS)
	RBT	R0,INNWDL,,		:... (2/2/87/CHS)
	J	LSRDDC

:	(5/10/85/CHS)
:	INOP RSP
:	------------
:	RECOVERY
LSRONO
	LB	R0,PUCTAB+PUCT.N,R11,	:RESET INNWCL FLAG(2/2/87/CHS)
	RBT	R0,INNWDL,,		:... (2/2/87/CHS)
	LHI	R0,LSNDM-PSEG		:ENTER LSNDM STATE
	STH	R0,PUCTAB+PULSNM,R11,
	J	LSRDNO

	FO	CMDLST
	FO	GBLDEF
	FO	BSUB
	FO	MAIN
	FO	DLCPRO
	EM
    	SUBTTL	(SNA-IFNC) INTERFACE CONTRL MODULE - IFNCTL
:IFNC00.Z00

	MO	.,IFCNTL

:	***********************************************
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	06/06/84 (NCS) -- ADD TIMEOUT ROUTINES FOR SNA HOST DSP
:	********************************************************

	GL	IFCNTL

	LO	GBLDEF
	LO	CMDLST
	LO	BSUB
	LO	ISISC
	LO	OSCAN
	LO	FRNTND
	LO	MAIN
	LO	CBKDEF
:	REGISTERS USAGES
:	----------------
:	R0	- WORK REGISTER
:	R1	- WORK REGISTER (OR ISIS PORT#)
:	R2	- WORK REGISTER
:	R3	- WORK REGISTER
:	R4	- WORK REGISTER
:	R5	- WORK REGISTER
:	R6	- SUBROUTINE LINK REGISTER
:	R7	- WORK REGISTER
:	R9	- WORK REGISTER
:	R8	- LINE NUMBER
:	R10	- RGRP
:	R11	- LUC
:	R12	- DCB/LNC
:	R13	- PUC
:	R14	- TEMPORARY WORK REGISTER
:	R15	- TEMPORARY WORK REGISTER
RGRP	EQ	R10

:	STATE FOR PU NODE OR LU DEVICES
:	-------------------------------
IFIDLE	EQ	00			:RESET(IDLE) STATE
IFPNDA	EQ	01			:PENDING FOR ACTIVE
IFACTV	EQ	02			:ACTIVATED
IFPNDD	EQ	03			:PENDING FOR DEACTIVE
IFPNSR	EQ	04			:PENDING FOR SNA RESET
IFPNLD	EQ	05			:PENDING FOR LINK DOWN
IFPNLR	EQ	06			:PENDING FOR LINK RESET

:	EQU FOR COMMANDS
:	---------------
XDOWN	EQ	XLNKDW			:LINK DOWN
XRESET	EQ	XCKTDW			:CIRCUIT DOWN

:	BIT DEFINITION FOR LNSFLG BYTE IN LNCTAB
:	----------------------------------------
DSRBIT	EQ	0			:BIT 0 - DSR UP/DOWN
DSRDRP	EQ	1			:BIT 1 - DSP DROPPED THEN BACK
DTRBIT	EQ	2			:BIT 2 - DTR UP/DOWN
IDLBIT	EQ	3			:BIT 2 - PTP IDLE
LERBIT	EQ	4			:BIT 2 - LINK ERROR BIT

:	DEFINE LOCAL VARIABLES
:	----------------------
	SEG	A.DATA
	BND	4
IFCLER	WS	NLINES
IFLRST	WS	NLINES
IFTERM	WS	NLINES
IFCSAV	WS	1			:TEMPORARY SAVE WORD
IFCGPR	WS	1			:WORKING STORAGE
IF6SAV	WS	1			:SAVE AREA FOR REG 6
IL6SAV	WS	1			:SAVE AREA FOR REG 6
IZ6SAV	WS	1			:SAVE AREA FOR REG 6
IW6SAV	WS	1			:SAVE AREA FOR REG 6
IW1SAV	WS	1			:SAVE AREA FOR REG 1
IK6SAV	WS	1			:SAVE AREA FOR REG 6
IF10SV	WS	1			:SAVE AREA FOR REG 10
LINSTT	HS	NLINES			:LINE STATE (FOR EASY ACCESS FROM DDT)

:	GLOBAL VARIABLES
:	----------------
	BND	4
BLSHUT	HS	(NLINES+0F)/10		:BIT ARRAY TO INDICATE LINE SHUT
BCSHUT	WS	NLINES			:BIT ARRAY TO INDICATE PU SHUT
BDSHUT	WS	NLINES			:BIT ARRAY TO INDICATE DEVICE SHUT

:	CONFIGURE DTR/DSR HANDSHAKE LINES
:	---------------------------------
:	THE FOLLOWING CODE CREATES A BIT ARRAY DTRDSR FROM USER INPUT
:	SDTR0,SDTR1,...,SDTR|NLINES| WHICH THE CODE TESTS TO DETERMINE
:	IF DTR/DSR HANDSHAKE MUST BE PERFORMED BEFORE DATA IS TRANSMITTED
:	OR RECEIVED (HANDSHAKE IS PERFORMED BY BACKGROUND AND IS
:	TYPICALLY RAISE DTR, WAIT FOR DSR, USE LINE, LOWER DTR, WAIT
:	FOR DSR TO DROP, RAISE DTR, ...).  BIT ARRAY IS INDEXED BY RL,
:	1 = HANDSHAKE REQUIRED.

	SEG	A.CODE
DTRDSR	HS	0
QQ	EQ	0			:WORK SYMBOL
Q	EQ	0
	RE	NLINES
QQ	EQ	QQ+(SDTR|Q|&1)^(0F-(Q&0F))
Q	EQ	Q+1
	IF	Q&0F;	ELSE;
	HC	QQ;QQ	EQ	0;	EI
	ER
	IF	Q&0F;	HC	QQ;	EI

:	CONFIGURE SPECIAL HOST PORT ARRAY
:	---------------------------------
:	THE FOLLOWING CODE CREATES A BIT ARRAY DIALUP FROM USER INPUT
:	DIAL0,DIAL1,...,DIAL|NLINES| WHICH THE CODE TESTS TO DETERMINE
:	IF DTR MUST BE DROPPED TO INFORM EXTERNAL SYSTEM (TO THE EXTERNAL
:	SYSTEM THE SIGNAL IS DSR) THAT THE SNA NETWORK INTERFACE HAS
:	DETECT DSR DRROPPED, AND THE SNA NETWORK INTERFACE WILL DROP ITS
:	DTR TO ACKNOWLEDGE SUCH AN EVENT.

	SEG	A.CODE
DIALUP	HS	0
QQ	EQ	0			:WORK SYMBOL
Q	EQ	0
	RE	NLINES
QQ	EQ	QQ+(DIAL|Q|&1)^(0F-(Q&0F))
Q	EQ	Q+1
	IF	Q&0F;	ELSE;
	HC	QQ;QQ	EQ	0;	EI
	ER
	IF	Q&0F;	HC	QQ;	EI

:	CONFIGURE LINE INITIAL ACTIVE/SHUT ARRAY
:	-----------------------------------------
:	THE FOLLOWING CODE CREATES A BIT ARRAY ILSHUT FROM USER INPUT
:	ISTS0,ISTS1,...,ISTS|NLINES| WHICH THE CODE TESTS TO DETERMINE
:	IF THE LINE MUST BE SHUT WHEN FIRST TIME THE SLOT IS UP, OR
:	THE SLOT IS RESTART FROM CRASH.
:	A REMOVE SHUT LINE COMMAND IS REQUIRED THROUGH THE MONITOR
:	TO ACTIVATE A SHUT LINE. A REMOVE SHUT STATION COMMAND CAN
:	ALSO ACHIEVE TO ACTIVATE INDIVIDUAL STATION ON A SHUT LINE.

	SEG	A.CODE
ILSHUT	HS	0
QQ	EQ	0			:WORK SYMBOL
Q	EQ	0
	RE	NLINES
	IF	\ISTS|Q|
QQ	EQ	$A QQ+(ISTS|Q|&1)^(15-(Q&15))
	EI	(\ISTS|Q|)
Q	EQ	Q+1
	IF	Q&0F;	ELSE;
	HC	QQ;QQ	EQ	0;	EI
	ER
	IF	Q&0F;	HC	QQ;	EI

:	CONFIGURE PU INITIAL ACTIVE/SHUT ARRAY
:	-------------------------------------------------
:	THE FOLLOWING CODE CREATES A BIT ARRAY ICSHUT FROM USER INPUT
:	IL0S0,IL0S1,..,IL1S0,IL1S1,...,IL|NLINES|S0,.. WHICH THE CODE TEST
:	TO DETERMINE THAT A STATION MUST BE ACTIVE/SHUT INITIALLY.
:	A REMOVE SHUT STATION COMMAND THROUGH MONITOR IS REQUIRED
:	TO ACTIVATE A SHUT STATION.  A REMOVE SHUT LINE COMMAND REMOVE
:	AND ACTIVATE ALL SHUT STATIONS ON A LINE.

	SEG	A.CODE
	WS	0
ICSHUT	WS	0
Y	EQ	0
	RE	NLINES
QQ	EQ	0		:WORK SYMBOL
Z	EQ	0
	RE	MAXPUN|Y|
	IF	\IL|Y|S|Z|
QQ	EQ	$A QQ+(IL|Y|S|Z|&1)^(31-(Z&31))
	EI	(\IL|Y|S|Z|)
Z	EQ	Z+1
	ER
	WC	QQ
Y	EQ	Y+1
	ER

:	REMARK ***** HAVE TO RE-DEFINE
:	CONFIGURE LU(DEVICE) INITIAL ACTIVE/SHUT ARRAY
:	-------------------------------------------------
:	THE FOLLOWING CODE CREATES A BIT ARRAY IDSHUT FROM USER INPUT
:	IL0S0,IL0S1,..,IL1S0,IL1S1,...,IL|NLINES|S0,.. WHICH THE CODE TEST
:	TO DETERMINE THAT A STATION MUST BE ACTIVE/SHUT INITIALLY.
:	A REMOVE SHUT STATION COMMAND THROUGH MONITOR IS REQUIRED
:	TO ACTIVATE A SHUT STATION.  A REMOVE SHUT LINE COMMAND REMOVE
:	AND ACTIVATE ALL SHUT STATIONS ON A LINE.

	SEG	A.CODE
	WS	0
IDSHUT	WS	0
Y	EQ	0
	RE	NLINES
QQ	EQ	0			:WORK SYMBOL
Z	EQ	0
	RE	MAXPUN|Y|
	IF	\IL|Y|S|Z|
QQ	EQ	$A QQ+(IL|Y|S|Z|&1)^(31-(Z&31))
	EI	(\IL|Y|S|Z|)
Z	EQ	Z+1
	ER
	WC	QQ
Y	EQ	Y+1
	ER

	SUBTTL	(SNA) - IFNC - HSEC - 1/2 SECOND TIMOUT HANDLEING 


	SEG	A.CODE
:	HSEC:	HALF-SECOND TIMOUT LOGIC
:	-----
HSEC	AHI	R1,RATE/2
	JAL	R5,TOPUT,,		:RUN AGAIN IN 1/2 SECOND

	SUBTTL	(SNA) - IFNC - LINK STATE AND STATUS HANDLING


:	LKHSEC:	MONITOR LINE STATUS (DTR/DSR, ETC)
:	------------------------------------
:	CHECK DSR SIGNAL, AND UPDATE LNCTAB.LNSFLG
LKHSEC
	LIS	R8,NLINES-1
LKHSE1
	LHL	R12,LNCPTR,R8,R8	:GET LNCTAB OFFSET
	LO	SFGPTP
	JAL	R4,CHKINT,,		:(3.F01/07/27/87/DB) CHECK OVERRUN
	JAL	R4,CHKDSR,,		:CHECK DSR
	FO	SFGPTP
	LIS	R0,DSRBIT
	LO	FGGBDF
	TBT	R8,SIODSR,,		:
	FO	FGGBDF
	JEFS	LKHSE2			:DSR DOWN
	SBT	R0,LNCTAB+LNSFLG,R12,	:INDICATE DSR UP
	JFS	LKHSE3			:AND  SKIP
LKHSE2
	RBT	R0,LNCTAB+LNSFLG,R12,	:INDICATE DSP DOWN
	JEFS	LKHSE3			:IF ALREADY DOWN, SKIP
	LIS	R0,DSRDRP		:ELSE, INDICATE DSP NEW DROP
	RBT	R0,LNCTAB+LNSFLG,R12,	:..
LKHSE3
	LHL	R4,LNCTAB+LNSTAT,R12,	:GET PROC
	JAL	R5,PSEG,R4,		:TO PROC IT
	STB	R0,LNCTAB+LNSTAN,R12,	:UPDATE STATE
	STH	R4,LNCTAB+LNSTAT,R12,	:UPDATE NEXT STATE PROC
	STH	R4,LINSTT,R8,R8		:LINE STATE
	SIS	R8,1			:NEXT LINE
	JGE	LKHSE1			:REPEAT

	SUBTTL	(SNA) IFNC - HSEC - PU LEVEL TIMEOUT HANDLING


:	PUHSEC:	HALF-SECOND TIMER FOR PU LEVEL
:	------
PUHSEC
	LHI	RGRP,NGSPU*2		:INIT HALFWORD GROUP INDEX
PUHSE1
	SIS	RGRP,2			:DO FOR ALL GROUPS
	JL	LUHSEC			:SKIP IF ALL DONE
	LCS	R0,1			:
	STH	R0,IFCGPR,,		:SET NO PUCTAB PROCESSED (12/01/86 YLH)
	ST	RGRP,IF10SV,,
PUHSE2
	L	RGRP,IF10SV,,
	LH	R1,PUTFLG,RGRP,		:PUCTAB IN TIMEOUT
	NH	R1,IFCGPR,,		:EXCLUDE PUC'S ALREADY PROCESSED
	JE	PUHSE1			:SKIP IF NONE TO PROCESS IN THIS GROUP
	JFFOH	R1,PUHSE3		:FIND 1ST PUC
	J	PUHSE1			:IF NONE, THEN NEXT GROUP
PUHSE3
	RBT	R2,IFCGPR,,		:DON'T DO THIS ONE AGAIN
	LR	R1,RGRP
	SLHLS	R1,3			:EACH GROUP = 16
	AR	R1,R2
	LHL	R13,PUCPTR,R1,R1	:GET THE PUCTAB
	LCS	R0,1			:TICKE THE CLOCK
	AHM	R0,PUCTAB+PUCTIM,R13,	:...
	JGE	PUHSE2			:TIMER NOT EXPIRED, SKIP 
	RBT	R1,PUTFLG,,		:RESET TIMER
	LHL	R4,PUCTAB+PUCATO,R13,	:GET ACTIVATION ADDR
	JE	PUHSE2			:BYPASS IF UNDEFINED
	JAL	R5,PSEG,R4,		:ACTIVATE IT
	J	PUHSE2			:REPEAT

	SUBTTL	(SNA) IFNC - HSEC - LU LEVEL TIMEOUT HANDLING


:	LUHSEC:	HALF-SECOND TIMER FOR LU LEVEL
:	------
LUHSEC
	LHI	RGRP,NGSLU*2		:INIT HALFWORD GROUP INDEX
LUHSE1
	SIS	RGRP,2			:DO FOR ALL GROUPS
	JL	LUHSE4			:SKIP IF ALL DONE
	LCS	R0,1			:
	STH	R0,IFCGPR,,		:SET NO LUCTAB PROCESSED
	ST	RGRP,IF10SV,,
LUHSE2
	L	RGRP,IF10SV,,
	LH	R1,LUTFLG,RGRP,		:LUCTAB IN TIMEOUT
	NH	R1,IFCGPR,,		:EXCLUDE LUC'S ALREADY PROCESSED
	JE	LUHSE1			:SKIP IF NONE TO PROCESS IN THIS GROUP
	JFFOH	R1,LUHSE3		:FIND 1ST LUC
	J	LUHSE1			:IF NONE, THEN NEXT GROUP
LUHSE3
	RBT	R2,IFCGPR,,		:DON'T DO THIS ONE AGAIN
	LR	R1,RGRP
	SLHLS	R1,3			:EACH GROUP = 16
	AR	R1,R2
	LHL	R11,LUBPTR,R1,R1	:GET THE LUCTAB
	LCS	R0,1			:TICKE THE CLOCK
	AHM	R0,LUCTAB+LUCTIM,R11,	:...
	JGE	LUHSE2			:TIMER NOT EXPIRED, SKIP 
	RBT	R1,LUTFLG,,		:RESET TIMER
	LHL	R4,LUCTAB+LUCATO,R11,	:GET ACTIVATION ADDR
	JE	LUHSE2			:BYPASS IF UNDEFINED
	JAL	R5,PSEG,R4,		:ACTIVATE IT
	J	LUHSE2			:REPEAT

LUHSE4
	IF	(HOSTIF)
	J	LUHIAT			:JUMP TO HANDLE IDLE TIMEOUT
	ELSE
	J	RELBP			:JUMP TO HANDLE BACKPRESSURE
	EI

	SUBTTL	(SNA) IFNC - INACTIVE TIMEOUT - LU LEVEL TIMEOUT HANDLING

	IF	(HOSTIF)
	LO	SHDPKG

:	LUHIAT:	HALF-SECOND TIMER FOR LU LEVEL
:	------
LUHIAT
	LHI	RGRP,NGSLU*2		:INIT HALFWORD GROUP INDEX
LUHIA1
	SIS	RGRP,2			:DO FOR ALL GROUPS
	JL	LUHLAT			:SKIP IF ALL DONE
	LCS	R0,1			:
	STH	R0,IFCGPR,,		:SET NO LUCTAB PROCESSED
	ST	RGRP,IF10SV,,
LUHIA2
	L	RGRP,IF10SV,,
	LH	R1,BDPETE,RGRP,		:LUCTAB IN BSC DSP ETE MODE
	NH	R1,IFCGPR,,		:EXCLUDE LUC'S ALREADY PROCESSED
	JE	LUHIA1			:SKIP IF NONE TO PROCESS IN THIS GROUP
	JFFOH	R1,LUHIA3		:FIND 1ST LUC
	J	LUHIA1			:IF NONE, THEN NEXT GROUP
LUHIA3
	RBT	R2,IFCGPR,,		:DON'T DO THIS ONE AGAIN
	LR	R1,RGRP
	SLHLS	R1,3			:EACH GROUP = 16
	AR	R1,R2
	LHL	R11,LUBPTR,R1,R1	:GET THE LUCTAB
	LHL	RDCB,LUCTAB+LUCDCB,R11,	:SET UP RDCB
	JE	LUHIA2			:JUMP,IF NO DCB
	LCS	R0,1			:TICKE THE CLOCK
	AHM	R0,DCBLKS+DCBIA1,RDCB,	:...
	JGE	LUHIA2			:TIMER NOT EXPIRED, SKIP 
	LHL	R4,DCBLKS+DCBIAT,RDCB,	:GET ACTIVATION ADDR
	JE	LUHIA2			:BYPASS IF UNDEFINED
	JAL	R5,PSEG,R4,		:ACTIVATE IT
	J	LUHIA2			:REPEAT

:	LUHLAT:	HALF-SECOND TIMER FOR LU LEVEL (APPLICATION LOGOFF)
:	------
LUHLAT
	LHI	RGRP,NGSLU*2		:INIT HALFWORD GROUP INDEX
LULHA1
	SIS	RGRP,2			:DO FOR ALL GROUPS
	JL	RELBP			:SKIP IF ALL DONE
	LCS	R0,1			:
	STH	R0,IFCGPR,,		:SET NO LUCTAB PROCESSED
	ST	RGRP,IF10SV,,
LULHA2
	L	RGRP,IF10SV,,
	LH	R1,BDPDLU,RGRP,		:LUCTAB IN BSC DSP ETE MODE
	NH	R1,IFCGPR,,		:EXCLUDE LUC'S ALREADY PROCESSED
	JE	LULHA1			:SKIP IF NONE TO PROCESS IN THIS GROUP
	JFFOH	R1,LULHA3		:FIND 1ST LUC
	J	LULHA1			:IF NONE, THEN NEXT GROUP
LULHA3
	RBT	R2,IFCGPR,,		:DON'T DO THIS ONE AGAIN
	LR	R1,RGRP
	SLHLS	R1,3			:EACH GROUP = 16
	AR	R1,R2
	LHL	R11,LUBPTR,R1,R1	:GET THE LUCTAB
	LHL	RDCB,LUCTAB+LUCDCB,R11,	:SET UP RDCB
	JE	LULHA4			:JUMP,IF NO DCB
	LCS	R0,1			:TICKE THE CLOCK
	AHM	R0,DCBLKS+DCBLA1,RDCB,	:...
	JL	LULHA5			:TIMER EXPIRED
	LB	R0,LUCTAB+LUPSTA,R11,	:GET CURRENT STATE
	CLHI	R0,PL.ACT		:IS LU BACK TO ACTIVE
	JEFS	LULHA5			:JUMP,IF YES
	J	LULHA2			:CONTINUE FOR THE TIMER
LULHA5
	LHL	R4,DCBLKS+DCBLAT,RDCB,	:GET ACTIVATION ADDR
	JE	LULHA2			:BYPASS IF UNDEFINED
	JAL	R5,PSEG,R4,		:ACTIVATE IT
	J	LULHA2			:REPEAT
LULHA4
	LHL	R0,LUCTAB+LUCT.N,R11,	:GET LUCTAB REL ID #
	RBT	R0,BDPDLU,,		:RESET BIT ARRAY,IF NO DCB
	J	LULHA2
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


	FO	SHDPKG
	EI	(HOSTIF)

	SUBTTL	(SNA-IFNC) NETWORK/ISIS BACKPRESSURE RELEASE LOGIC


:	RELBP:	RELEASE BACK PRESSURE
:	-----------------------------
:	CHECK IF BACKPRESSURE CAN BE RELEASED ON ANY ISIS PORTS
RELBP
	LHI	R5,NGRP*2		:SET UP POINTERS
	LHI	R6,NGRP*10		:...
RELBP1
	SIS	R5,2			:DECREMENT POINTERS
	SHI	R6,10			:ALL DONE?
	JL	HSECEX			:YES, EXIT
	LCS	R7,1			:INIT R7 TO ALL 1'S
	XH	R7,FRISIS,R5,		:CHECK IF BACKPRESSURE APPLIED
	NH	R7,ACP,R5,		:AND PORT ACTIVE
RELBP2
	LR	R1,R7			:SET R1=R7
	JFFOH	R1,RELBP3		:FIND '1ST' PORT ON GROUP NEEDS SERVICE
	J	RELBP1			:SKIP IF NONE TO PROCESS IN THIS GROUP
RELBP3
	XH	R7,HMASK,R2,R2		:MARK PORT AS SERVICED
	AR	R2,R6			:FORM PORT NUMBER
	LR	RPORT,R2		:COPY IT TO RPORT(=R1)
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB ADD FROM PORT TABLE
	LHL	R4,DCBLKS+DCBPUC,RDCB,	:R4 = PUC OFFSET
:	LB	R0,PUCTAB+PUXBUS,R4,	:CHECK BB XT USE IN LUC (02/22/85 MIA)
	LH	R0,PUCTAB+PUXBUS,R4,	:CHECK BB XT USE IN PUC (02/22/85 MIA)
	SHI	R0,10			:COMPARE
	JL	RELBP2			:BB QUOTA TOO LOW, SKIP
	SBT	RPORT,FRISIS,,		:ELSE, RELEASE BACKPRESSURE
	LIS	R0,3			:FORM 3 BYTE MESSAGE
	LHI	R2,SNDMSG		:POINT TO MESSAGE
	JAL	R4,SLOR,,		:START THIS ISIS LOGICAL OUTPUT RCD
	JAL	R4,ELOR,,		:END IT
	J	RELBP2			:ANS CONTINUE WITH NEXT AVAIL PORT
	
:	HSECEX:	EXIT HALF-SECOND LOGIC
:	------
HSECEX
	J	TORET,,			:EXIT HALF SECOND LOGIC

	SUBTTL	(SNA-IFNC) INTERFACE CONTROL MODULE


:	IFCNTL: INTERFACE CONTROL MODULE
:	--------------------------------
:	LING REGISTER: R0
IFCNTL
	ST	R0,IFCSAV,,		:SAVE RETURN ADDRESS

:***************************************************************:
:								:
:	PROCESSING THE PUCB RSP QUEUES (IFC->NWKC)		:
:								:
:***************************************************************:

IFCCMD
	LHI	RGRP,NGSPU*2
IFCCM1
	SIS	RGRP,2			:ALL DONE?
	JL	IFCRET			:YES, EXIT
	LCS	R0,1			:INIT IFCGPR
	STH	R0,IFCGPR,,		:...
IFCCM2
	LH	R1,CPDLNW,RGRP,		:PU'S WITH NWKC TO IFC CMD QUEUED
	NH	R1,IFCGPR,,		:EXCLUDE PU'S ALREADY PROCESSED
	JFFOH	R1,IFCCM3		:FIND THE 1ST PU
	J	IFCCM1			:SKIP, IF NONE TO PROCESS IN THIS GROUP
IFCCM3
	RBT	R2,IFCGPR,,		:DON'T DO THIS ONE AGAIN (12/01/86 YLH)
	LR	R1,RGRP
	SLHLS	R1,3			:EACH GROUP = 16
	AR	R1,R2
	LHL	R13,PUCPTR,R2,R2,	:R13= PUC OFFSET
:	LH	R6,PUCTAB+PUNWCG,R13,	:SEE IF ANY CMD QUEUED (01/02/85 MIA)
:	CLH	R6,PUCTAB+PUNWCR,R13,	:(01/02/85 MIA)
	LHL	R6,PUCTAB+PUNWCG,R13,	:GET GET PTR (01/02/85 MIA)
	LHL	R3,PUCTAB+PUNWCR,R13,	:GET RELEASE PTR (01/02/85 MIA)
	CR	R6,R3			:COMP GET AND REL PTR (01/02/85 MIA)
	JE	IFCCM2			:IF SAME, SKIP TO NEXT PU
	LB	R3,CMDBLK+CLCMD,R6,	:GET THE CCC
	CLHI	R3,IFCDLC		:IFC<->DLC CONTROL CMD/RSP?
	JN	IFCRSH			:NO, TO CRASH
	LB	R2,CMDBLK+CLCMDS,R6,	:GET SCC
	CLHI	R2,INIRSP		:WITHIN RANGE?
	JG	IFCRSH			:NO, TO CRASH
	LH	R7,CMDBLK+CLPTR,R6,	:ADVANCE CMD
	JE	CLERR,,			:ERROR, IF ADVANCE EMPTY LIST
	STH	R7,PUCTAB+PUNWCG,R13,	:ADVANCE IT
	LB	R0,PUCTAB+PUCT.N,R13,
	RBT	R0,CPDLNW,,
	CLH	R7,PUCTAB+PUNWCR,R13,	:NO CMD  ANY MORE?
	JEFS	IFCCM4			:IF NO, SKIP
	SBT	R0,CPDLNW,,		:INIDICATE MORE CMD
IFCCM4
	JAL	R4,RELCL,,		:RELEASE CMD ELEMENT
	SLHLS	R2,1			:MAKE HALF WORD INDEX
	LHL	R4,PUCTAB+PUIFNC,R13,
	LHL	R4,PSEG,R4,R2		:GET PROC ROUTINE
	JAL	R5,PSEG,R4,		:GO TO PROCESS THIS CMD/DATA
	J	IFCCM2			:NEXT PU

:	RETURN TO EXEC FROM IFNC PROCESS
:	--------------------------------
IFCRET
	L	R0,IFCSAV,,		:RESTORE RETURN ADDR
	JR	R0			:RETURN TO EXEC


:	IFCRSH: CRASH
:	------
IFCRSH
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


	SUBTTL	(SNA) LINK.SVC - PRIMARY - STATE TABLES

	IF	TERMIF

:	IPNDM:	IFNC.LINK AT NDM STATE
:	-------
:	PROCESS RSP
	HS	0
IPNDM
	HC	IPRNCL-PSEG	:00 - RSP<CLR>, RESET IFCLER, ENTER LINK INIT
	HC	IPRNTM-PSEG	:01 - RSP<TRM>, CRASH NOW
	HC	IPRNDM-PSEG	:02 - RSP<DM>, NO ACTION
	HC	IPRNER-PSEG	:03 - RSP<ERR>, CRASH
	HC	IPRNOP-PSEG	:04 - RSP<OP>, CRASH

:	IPWOP: PRIMARY AT WOP STATE
:	-----
	HS	0
IPWOP
	HC	IPRPCL-PSEG	:00 - RSP<CLR>, CRASH
	HC	IPRPTM-PSEG	:01 - RSP<TRM>, CRASH
	HC	IPRPDM-PSEG	:02 - RSP<DM>, INIT AGAIN
	HC	IPRPER-PSEG	:03 - RSP<ERR>, CRASH
	HC	IPRPOP-PSEG	:04 - RSP<OP>, ACTPU & ENTER IPOP STATE

:	IPOP: PRIMARY AT OP STATE
:	----
	HS	0
IPOP
	HC	IPROCL-PSEG	:00 - RSP<CLR>, CRASH
	HC	IPROTM-PSEG	:01 - RSP<TRM>, RESET TRM & ENTER IPWNDM
	HC	IPRODM-PSEG	:02 - RSP<DM>, LINK DOWN TO SNA, ENTER IPNDM
	HC	IPROER-PSEG	:03 - RSP<ERR>, LINK DOWN TO SNA, ENTER ISNDM
	HC	IPROOP-PSEG	:04 - RSP<OP>, CRASH

:	IPWNDM: PRIMARY AT WNDM STATE
:	-------
	HS	0
IPWNDM
	HC	IPRWCL-PSEG	:00 - RSP<CLR>, CRASH
	HC	IPRWTM-PSEG	:01 - RSP<TRM>, CRASH
	HC	IPRWDM-PSEG	:02 - RSP<DM>, INIT AND ENTER IPWOP
	HC	IPRWER-PSEG	:03 - RSP<ERR>, CRASH
	HC	IPRWOP-PSEG	:04 - RSP<OP>, CRASH

:	IPCRSH:	CRASH ROUTINE FOR LOCAL PRIMARY
:	-----
IPCRSH
	JAL	R10,CRASH,,
	BC	0,0,0,088

	SUBTTL	(SNA) LINK.SVC LAYER - PRIMARY ROUTINES


::
::	IPNDM STATE
::

:	IPRNCL:	RSP<CLR>, RESET IFCLER, ENTER LINIT STATE IF IFCLER FW = 0
:	------
IPRNCL
:	LHL	R4,PUCTAB+PULNKN,R13,	:R4 = LINK # (12/20/84 MIA)
	LB	R4,PUCTAB+PULNKN,R13,	:R4 = LINK # (12/20/84 MIA)
	SLHLS	R4,1			:HW INDEX
	LB	R0,PUCTAB+PUCRID,R13,	:RESET IFCLER
	RBT	R0,IFCLER,R4,R4
:	L	R0,IFCLER,R4,R4		:ALL PU CLEARED?
:	JNR	R5			:NO, RETURN
:	LHL	R12,LNCPTR,R4,		:R12 = LNC  OFFSET
:	LHI	R0,LINIT-PSEG		:ENTER LINIT STATE
:	STH	R0,LNCTAB+LNSTAT,R12,
:	STH	R0,LINSTT,R4,R4
	JR	R5
	
:	IPRNTM:	RSP<TRM>, CRASH
:	------
IPRNTM
	LIS	R15,02			:CRASH AT IPRNTM
	J	IPCRSH

:	IPRNDM:	RSP<DM>, NO ACTION
:	------
IPRNDM
	JR	R5

:	IPRNER:	RSP<ERR>, NO ACTIVON
:	------
IPRNER
:	LIS	R15,03			:CRASH AT IPRNER
:	J	IPCRSH
	JR	R5

:	IPRNOP:	RSP<OP>, CRASH
:	------
IPRNOP
	LIS	R15,04			:CRASH AT IPRNOP
	J	IPCRSH

::
::	IPWOP STATE
::

:	IPRPCL:	RSP<CLR>, CRASH
:	------
IPRPCL
	LHI	R15,10			:CRASH AT IPRPCL
	J	IPCRSH

:	IPRPTM:	RSP<TRM>, CRASH
:	------
IPRPTM
	LHI	R15,11			:CRASH AT IPRPTM
	J	IPCRSH

:	IPRPDM:	RSP<DM>, RE-INIT DATA LINK
:	-----
IPRPDM
	LB	R4,PUCTAB+PULNKN,R13,	:GET LINK #
	LHL	R12,LNCPTR,R4,R4	:R12 = LNC OFFSET
	TBT	R4,DIALUP		:DIAL-UP LINE?
	JN	IPRPD1			:YES, SKIP
	JAL	R6,ILINIT		:RE-INIT DLC
	JR	R5
IPRPD1
	LIS	R4,LERBIT		:(2/26/86/CHS)
	SBT	R4,LNCTAB+LNSFLG,R12,	:SET LINK ERROR FLAG
:	LHI	R0,IPNDM-PSEG		:ENTER NDM (2/28/86/CHS)
:	STH	R0,PUCTAB+PUIFNC,R13,	:...(2/28/86/CHS)
	JR	R5

:	IPRPER:	RSP<ERR>, CRASH NOW
:	------
IPRPER
	LB	R4,PUCTAB+PULNKN,R13,	:GET LINK #
	LHL	R12,LNCPTR,R4,R4	:R12 = LNC OFFSET
	TBT	R4,DIALUP		:DIAL-UP LINE?
	JN	IPRPE1			:YES, SKIP
	JAL	R6,ILINIT		:INIT AGAIN
	JR	R5
IPRPE1
	LIS	R4,LERBIT		:(2/26/86/CHS)
	SBT	R4,LNCTAB+LNSFLG,R12,	:SET LINK ERROR FLAG
:	LHI	R0,IPNDM-PSEG		:ENTER NDM(2/28/86/CHS)
:	STH	R0,PUCTAB+PUIFNC,R13,	:...(2/28/86/CHS)
	JR	R5

:	IPRPOP:	RSP<OP>, ISSUE ACTPU, ENTERY IPOP STATE
:	-------
IPRPOP
	LB	R4,PUCTAB+PULNKN,R13,
	LHL	R12,LNCPTR,R4,R4	:R12 = LNC OFFSET
	LHI	R0,LACTIVE-PSEG
	STH	R0,LNCTAB+LNSTAT,R12,
	STH	R0,LINSTT,R4,R4
	LHL	R11,PUCTAB+PUCLUC,R13,
	LHI	R0,DTTOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTTOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	JAL	R6,IFACPU
	LHI	R0,IPOP-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	JR	R5

::
::	IPOP STATE
::

:	IPROCL:	RSP<CLR>, CRASH
:	------
IPROCL
	LHI	R15,20			:CRASH AT IPROCL
	J	IPCRSH

:	IPROTM:	RSP<TRM>, CRASH
:	------
IPROTM
	LHI	R15,21			:CRASH AT IPROTM
	J	IPCRSH

:	IPRODM:	RSP<DM>, LINK DOWN TO SNA, AND ENTER IPNDM
:	-------
IPRODM
	LB	R4,PUCTAB+PULNKN,R13,	:GET LINK #
	LHL	R12,LNCPTR,R4,R4	:R12 = LNC OFFSET
	TBT	R4,DIALUP		:DIAL-UP LINE?
	JN	IPROD1			:YES, SKIP
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,DWNTLU		:ZAP ALL CIRCUITS
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,IFLKRS		:LINK RESET TO SNA
	LHI	R0,IPNDM-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	JR	R5
IPROD1
	LIS	R4,LERBIT
	SBT	R4,LNCTAB+LNSFLG,R12,	:SET LINK ERROR FLAG
	LHI	R0,IPNDM-PSEG		:ENTER NDM
	STH	R0,PUCTAB+PUIFNC,R13,	:...
	JR	R5

:	IPROER:	RSP<ERR>, CRASH
:	-------
IPROER
	LB	R4,PUCTAB+PULNKN,R13,	:GET LINK #
	LHL	R12,LNCPTR,R4,R4	:R12 = LNC OFFSET
	TBT	R4,DIALUP		:DIAL-UP LINE?
	JN	IPROE1			:YES, SKIP
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,DWNTLU		:ZAP ALL CIRCUITS
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,IFLKRS		:ISSUE LINK RESET
	LHI	R0,IPNDM-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	JR	R5
IPROE1
	LIS	R4,LERBIT
	SBT	R4,LNCTAB+LNSFLG,R12,	:SET LINK ERROR FLAG
	LHI	R0,IPNDM-PSEG		:ENTER NDM
	STH	R0,PUCTAB+PUIFNC,R13,	:...
	JR	R5

:	IPROOP:	RSP<OP>, CRASH
:	-------
IPROOP
	LHI	R15,23			:CRASH AT IPROOP
	J	IPCRSH

::
::	IPWNDM STATE
::

:	IPRWCL:	RSP<CL>, CRASH
:	------
IPRWCL
	LHI	R15,30			:CRASH AT IPRWCL
	J	IPCRSH

:	IPRWTM:	RSP<TRM>, CRASH
:	-------
IPRWTM
	LHI	R15,31			:CRASH AT IPRWTM
	J	IPCRSH

:	IPRWDM:	RSP<DM>, INIT AGAIN, AND ENTER IPWOP STATE
:	------
IPRWDM
	JAL	R6,ILINIT		:INIT AGAIN
	LHI	R0,IPWOP-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	JR	R5

:	IPRWER:	RSP<ERR>, CRASH NOW
:	------
IPRWER
	LHI	R15,33			:CRASH AT IPRWER
	J	IPCRSH

:	IPRWOP:	RSP<OP>, CRASH
:	-------
IPRWOP
	LHI	R15,34			:CRASH AT IPRWOP
	J	IPCRSH

	EI	(TERMIF)

	SUBTTL	(SNA) LINK.SVC LAYER - SECONDARY - STATE TABLES

	IF	HOSTIF


:	ISNDM:	SECONDARY AT NDM STATE
:	-----
	HS	0
ISNDM
	HC	ISRDCL-PSEG	:00 - RSP<CLR>, RESET IFCLER, ENTER LINIT STATE
	HC	ISRDTM-PSEG	:01 - RSP<TRM>, CRASH
	HC	ISRDDS-PSEG	:02 - RSP<DISC>, NO ACTION
	HC	ISRDER-PSEG	:03 - RSP<ERR>, CRASH
	HC	ISRDOP-PSEG	:04 - RSP<OP>, CRASH

:	ISWOP: SECONDARY AT WOP STATE
:	-----
	HS	0
ISWOP
	HC	ISRPCL-PSEG	:00 - RSP<CLR>, CRASH
	HC	ISRPTM-PSEG	:01 - RSP<TRM>, CRASH
	HC	ISRPDM-PSEG	:02 - RSP<DISC>, INIT AND STAY AT ISWOP STATE
	HC	ISRPER-PSEG	:03 - RSP<ERR>, IGNORE AND RE-INIT
	HC	ISRPOP-PSEG	:04 - RSP<OP>, IPOP STATE, ENTER LACTIVE STATE

:	ISOP:	SECONDARY AT OP STATE
:	----
	HS	0
ISOP
	HC	ISROCL-PSEG	:00 - RSP<CLR>, CRASH
	HC	ISROTM-PSEG	:01 - RSP<TRM>, CRASH
	HC	ISRODS-PSEG	:02 - RSP<DISC>, LINK RESET TO SNA, ENTER ISNDM
	HC	ISROER-PSEG	:03 - RSP<ERR>, LINK DOWN TO SNA, ENTER ISNDM
	HC	ISROOP-PSEG	:04 - RSP<OP>, CRASH

:	ISCRSH: CRASH ROUTINE FOR LOCAL SECONDARY
:	-------
ISCRSH
	JAL	R10,CRASH,,
	BC	0,0,0,088

	SUBTTL	(SNA) LINK.SVC LAYER - SECONDARY ROUTINES


::
::	ISNDM STATE HANDLERS
::

:	ISRDCL:	RSP<CLR>, RESET IFCLER, ENTER LINIT STATE IF IFCLER FW = 0
:	------
ISRDCL
:	LHL	R4,PUCTAB+PULNKN,R13,	:R4 = LINK # (12/20/84 MIA)
	LB	R4,PUCTAB+PULNKN,R13,	:R4 = LINK # (12/20/84 MIA)
	SLHLS	R4,1			:HW INDEX
	LB	R0,PUCTAB+PUCRID,R13,	:RESET IFCLER
	RBT	R0,IFCLER,R4,R4
:	L	R0,IFCLER,R4,R4		:ALL PU CLEARED?
:	JNR	R5			:NO, RETURN
:	LHL	R12,LNCPTR,R4,		:R12 = LNC  OFFSET
:	LHI	R0,LINIT-PSEG		:ENTER LINIT STATE
:	STH	R0,LNCTAB+LNSTAT,R12,
:	STH	R0,LINSTT,R4,R4
	JR	R5
	
:	ISRDTM:	RSP<TRM>, CRASH
:	------
ISRDTM
	LIS	R15,02			:CRASH AT ISRDTM
	J	ISCRSH

:	ISRDDS:	RSP<DISC>, NO ACTION
:	------
ISRDDS
	JR	R5

:	ISRDER:	RSP<ERR>, NO ACTIVON
:	------
ISRDER
:	LIS	R15,03			:CRASH AT ISRDER
:	J	ISCRSH
	JR	R5

:	ISRDOP:	RSP<OP>, CRASH
:	------
ISRDOP
	LIS	R15,04			:CRASH AT ISRDOP
	J	ISCRSH


::
::	ISWOP STATE
::

:	ISRPCL:	RSP<CLR>, CRASH
:	------
ISRPCL
	LHI	R15,10			:CRASH AT ISRPCL
	J	ISCRSH

:	ISRPTM:	RSP<TRM>, CRASH
:	------
ISRPTM
	LHI	R15,11			:CRASH AT ISRPTM
	J	ISCRSH

:	ISRPDM:	RSP<DISC>, RE-INIT DATA LINK
:	-----
ISRPDM
	JAL	R6,ILINIT		:RE-INIT DLC
	JR	R5

:	ISRPER:	RSP<ERR>, IGNORE AND RE-INIT
:	------
ISRPER
:	LHI	R15,13			:CRASH AR ISRPER(1/3/85/CHS)
:	J	ISCRSH			:(1/3/85/CHS)
	JAL	R6,ILINIT		:RE-INIT DLC(1/3/85/CHS)
	JR	R5			:(1/3/85/CHS)

:	ISRPOP:	RSP<OP>, ENTER ISOP STATE
:	------
ISRPOP
	LB	R4,PUCTAB+PULNKN,R13,
	LHL	R12,LNCPTR,R4,R4	:R12 = LNC OFFSET
	LHI	R0,LACTIVE-PSEG
	STH	R0,LNCTAB+LNSTAT,R12,
	STH	R0,LINSTT,R4,R4
	LHI	R0,ISOP-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	LHL	R11,PUCTAB+PUCLUC,R13,
	LHI	R0,DTHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LHI	R0,DTHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	JR	R5

::
::	ISOP STATE
::

:	ISROCL:	RSP<CLR>, CRASH
:	-----
ISROCL
	LHI	R15,20			:CRASH AT ISROCL
	J	ISCRSH

:	ISROTM:	RSP<TRM>, CRASH
:	------
ISROTM
	LHI	R15,21			:CRASH AR ISROTM
	J	ISCRSH

:	ISRODS:	RSP<DISC>, LINK RESET TO SNA, ENTER ISNDM
:	------
ISRODS
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,DWNHLU		:ZAP ALL CIRCUITS
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,IFLKRS		:ISSUE LINK RESET
	LHI	R0,ISNDM-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	JR	R5

:	ISROER:	RSP<ERR>, LINK DOWN TO SNA, ENTER ISNDM
:	------
:	WHEN RCV RSP FROM SNA, THEN RE-ISSUE INIT
ISROER
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,DWNHLU
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,IFLKRS		:ISSUE LINK RESET
	LHI	R0,ISNDM-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	JR	R5

:	ISROOP:	RSP<OP>, CRASH
:	------
ISROOP
	LHI	R15,24			:CRASH AT ISRROP
	J	ISCRSH

	EI	(HOSTIF)

	SUBTTL	(SNA-IFNC) INTERFACE CONTROL - SUBROUTINES


:	IFACPU/IFACLU:	SEND ACTPU/ACTLU TO IFC->SNA CMD-Q
:	--------------
:	INPUT:	R13 = PUCTAB, R11 = LUCTAB
IFACPU;IFACLU
	LIS	R0,IFPNDA		:SET TO PENDING FOR ACTIVE
	LIS	R1,XINIT		:SET TO ACTIVATE
	J	IFSNQ			:TO COMMON ROUTINE

:	IFDAPU/IFDALU:	SEND DACTPU/DACTLU TO IFC->SNA CMD-Q
:	--------------
:	INPUT:	R13 = PUCTAB, R11 = LUCTAB
IFDAPU;IFDALU
	LIS	R0,IFPNDD		:SET TO PENDING FOR DEACTIVE
	LIS	R1,XCLOSE		:SET TO DE-ACTIVATE
	J	IFSNQ			:TO COMMON ROUTINE

:	IFDOWN:	SEND DOWN CMD TO IFC->SNA CMD-Q
:	------
:	INPUT:	R13 = PUCTAB, R11 = LUCTAB
IFDOWN
	LIS	R0,IFPNLD		:SET TO PENDING FOR LINK DOWN
	LIS	R1,XDOWN		:SET TO DOWN
	J	IFSNQ			:TO COMMON ROUTINE

:	IFLKRS:	SEND DOWN CMD TO IFC->SNA CMD-Q
:	------
:	CALLED WHEN LINK RESET (NOT DOWN)
:	INPUT:	R13 = PUCTAB, R11 = LUCTAB
IFLKRS
	LIS	R0,IFPNLR		:SET TO PENDING FOR LINK RESET
	LIS	R1,XDOWN		:SET TO DOWN
	J	IFSNQ			:TO COMMON ROUTINE

:	IFRSET:	SEND RESET CMD TO IFC->SNA CMD-Q
:	------
:	INPUT:	R13 = PUCTAB, R11 = LUCTAB
IFRSET
	LIS	R0,IFPNSR		:SET TO PENDING FOR SNA RESET
	LIS	R1,XRESET		:SET TO RESET
	J	IFSNQ			:TO COMMON ROUTINE

:	IFSNQ:	SEND CMD TO IFC->SNA CMD-Q
:	-------
:	INPUT:	R13 = PUCTAB, R11 = LUCTAB
:		R0 = NEW PU/LU ACT/DACT STATE
:		R1 = CCC CODE
IFSNQ
	ST	R6,IF6SAV,,		:SAVE R6
	STB	R0,LUCTAB+LUPSTA,R11,	:SET TO NEW STATE
	JAL	R4,GETCL,,		:GET A FREE LINK
	J	IFSNQ1			:NO AVAILABLE CMD CELL
	LHL	R4,LUCTAB+LUSNCP,R11,	:GET INFC->SNA COMD-Q PUT PTR
	STB	R1,CMDBLK+CLCMD,R4,	:PUT IN CMD CODE
					:ALL OTHER FIELDS SHOULD ALREAY 0
	STH	RARG,CMDBLKD+CLPTR,R4,	:LINK NEW ENTRY
	STH	RARG,LUCTAB+LUSNCP,R11,	:...
	STH	RARG,LUCTAB+LUSNCR,R11,	:GIVE IT TO SNA
	LHL	R0,LUCTAB+LUCT.N,R11,	:GET LUCTAB REL ID #
	SBT	R0,CPNWSN,,		:INDICATE INFC->SNA CMD-Q AVAIL.
	L	R6,IF6SAV,,		:RESTORE R6
	JR	R6
IFSNQ1
	J	CLMPTY,,		:..

:	IFIACK:	SEND RESET.ACK TO SNA.INIT IN IFC->SNA CMD-Q
:	------
:	CALLED WHEN AFTER RCV'ED INIT.RESET FROM SNA
:	INPUT:	R13 = PUCTAB, R11 = LUCTAB
IFIACK
	LIS	R0,IFIDLE		:SET TO RESET(IDLE) STATE
	LIS	R1,XINIT		:SET TO INIT
	LIS	R2,E.REST		:ACK INIT.RESET
	J	IFSACK			:TO COMMON ROUTINE

:	IFCACK:	SEND DEACTIVATE.RESET ACK TO SNA/DEACTIVATE IN IFC->SNA CMD-Q
:	------
:	INPUT:	R13 = PUCTAB, R11 = LUCTAB
IFCACK
	LIS	R0,IFIDLE		:SET TO RESET(IDLE)
	LIS	R1,XCLOSE		:SET TO ACK DEACTIVE
	LIS	R2,E.REST		:SET TO ACK RESET
	J	IFSACK			:TO COMMON ROUTINE

:	IFSACK:	SEND ACK CMD TO IFC->SNA CMD-Q
:	-------
:	INPUT:	R13 = PUCTAB, R11 = LUCTAB
:		R0 = NEW PU/LU ACT/DACT STATE
:		R1 = CCC CODE
:		R2 = SCC CODE
IFSACK
	ST	R6,IF6SAV,,		:SAVE R6
	STB	R0,LUCTAB+LUPSTA,R11,	:SET TO NEW STATE
	JAL	R4,GETCL,,		:GET A FREE LINK
	J	IFSAC1			:NO AVAILABLE CMD CELL
	LHL	R4,LUCTAB+LUSNCP,R11,	:GET INFC->SNA COMD-Q PUT PTR
	STB	R1,CMDBLK+CLCMD,R4,	:PUT IN CMD CODE
	STB	R2,CMDBLK+CLCMDS,R4,	:PUT IN SUB CMD CODE
					:ALL OTHER FIELDS SHOULD ALREAY 0
	STH	RARG,CMDBLKD+CLPTR,R4,	:LINK NEW ENTRY
	STH	RARG,LUCTAB+LUSNCP,R11,	:...
	STH	RARG,LUCTAB+LUSNCR,R11,	:GIVE IT TO SNA
	LHL	R0,LUCTAB+LUCT.N,R11,	:GET LUCTAB REL ID #
	SBT	R0,CPNWSN,,		:INDICATE INFC->SNA CMD-Q AVAIL.
	L	R6,IF6SAV,,		:RESTORE R6
	JR	R6
IFSAC1
	J	CLMPTY,,		:..

:	ILINIT:	SEND INIT CMD TO IFC->DLC CMD-Q
:	------
:	R13 = PUCTAB
ILINIT
	LIS	R0,DLCCTL		:
	LIS	R1,INITCD
	J	ILSNQ

:	ILCLR:	SEND CLEAR CMD TO DLC
:	-----
:	R13 = PUCTAB
ILCLR
	LIS	R0,DLCCTL
	LIS	R1,CLRCD
	J	ILSNQ

:	ILTRM:	SEND TERM CMD TO DLC
:	-----
ILTRM
	LIS	R0,DLCCTL
	LIS	R1,TRMCD
	J	ILSNQ

:	ILSNQ:	SEND CMD TO IFC->DLC CMD-Q
:	-----
:	R13 = PUCTAB ADDR
:	R0 = CCC
:	R1 - SCC
ILSNQ
	ST	R6,IL6SAV,,		:SAVE R6
	JAL	R4,GETCL,,
	J	ILSNQ1
	LHL	R4,PUCTAB+PUDLCP,R13,
	STB	R0,CMDBLK+CLCMD,R4,
	STB	R1,CMDBLK+CLCMDS,R4,
	STH	RARG,CMDBLK+CLPTR,R4,
	STH	RARG,PUCTAB+PUDLCP,R13,
	STH	RARG,PUCTAB+PUDLCR,R13,
	LB	R0,PUCTAB+PUCT.N,R13,
	SBT	R0,CPNWDL,,
	L	R6,IL6SAV,,		:RESTORE R6
	JR	R6
ILSNQ1
	J	CLMPTY,,

:	ILFLUH:	FLUSH DLC->IFC CMD-Q
:	------
:	R13 = PUCTAB
ILFLUH
	ST	R6,IL6SAV,,
ILFLU1
	LHL	R6,PUCTAB+PUNWCG,R13,	:SEE IF ANY CMD QUEUED
	LHL	R4,PUCTAB+PUNWCR,R13,	:...
	CR	R6,R4			:COMPARE GET AND REL PTR
	JE	ILFLU2			:SAME, SKIP
	LH	R0,CMDBLK+CLPTR,R6,	:ADVANCE CMD
	STH	R0,PUCTAB+PUNWCG,R13,	:ADVANCE IT
	JAL	R4,RELCL,,		:RELEASE CMD
	J	ILFLU1			:REPEAT
ILFLU2
	LB	R0,PUCTAB+PUCT.N,R13,	:RESET CPDLNW
	RBT	R0,CPDLNW,,
	L	R6,IL6SAV,,
	JR	R6
	
	IF	TERMIF

:	TLACTV:	RE-ISSUE XINIT FROM TIME OUT 
:	------
TLACTV
	LHI	R0,DTTOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTTOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	JAL	R6,IFACLU		:ACTIVATE LU/PU
	JR	R5			:RETURN TO LU HSEC

:	TPINIT:	RE-INIT DLC LAYER
:	------
TPINIT
	JAL	R6,ILINIT
	LHI	R0,IPWOP-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	JR	R5

:	ZAPTLU:	ZAP AND RESET LU/DEVICE
:	------
:	R12 = DCB OFFSET
ZAPTLU
	ST	R6,IZ6SAV,,		:SAVE R6
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	JAL	R6,IFRSET		:SEND CKTDW COMMAND TO SNA
	LHI	R0,DTTOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTTOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LIS	R0,IFPNSR
	STB	R0,LUCTAB+LUPSTA,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,STLGFL,,
	RBT	R0,FNLGFL,,
	RBT	R0,LUTFLG,,
	L	R6,IZ6SAV,,
	JR	R6

:	DWNTLU:	DOWN LU/DEVICE
:	------
:	R13 = PUC ADDR
DWNTLU
	ST	R6,IW6SAV,,		:SAVE R6
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	LHI	R0,DTTOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTTOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
:	LIS	R0,PL.PDN		:DELETE THESE 2 INS. (12/16/86 YLH)
:	STB	R0,LUCTAB+LUPSTA,R11,	:(12/16/86 YLH)
	LIS	R1,1			:INIT LUC CNT
DWNTL1
	LHL	R2,LUCTAB+LUCT.N,R11,
	AIS	R2,1			:NEXT LU
	LHL	R11,LUBPTR,R2,R2	:R11 = NEW LU'S LUCTAB
	ST	R1,IW1SAV,,
	JAL	R6,ZPTCKT		:ZAP CIRCUIT, IF ANY
	L	R1,IW1SAV,,
	LHI	R0,DTTOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTTOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LIS	R0,PL.PDN
	STB	R0,LUCTAB+LUPSTA,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,STLGFL,,
	RBT	R0,FNLGFL,,
	RBT	R0,LUTFLG,,
	AIS	R1,1			:ALL DONE ?
	CLB	R1,PUCTAB+PUMLUN,R13,	:NO, REPEAT
	JN	DWNTL1
	L	R6,IW6SAV,,
	JR	R6

:	ZPTCKT:	ZAP CIRCUIT
:	------
ZPTCKT
	ST	R6,IK6SAV,,
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	JAL	R6,RSTTRM,,		:RESET TERMINAL CIRCUIT
	LB	R0,DCBLKS+DCBMOD,RDCB,
	NHI	R0,D.PVC
	STB	R0,DCBLKS+DCBMOD,RDCB,
	L	R6,IK6SAV,,
	JR	R6

	EI	(TERMIF)

	IF	HOSTIF

:	HPINIT:	RE-INIT DLC LAYER
:	------
HPINIT
	JAL	R6,ILINIT
	LHI	R0,ISWOP-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	JR	R5

:	ZAPHLU:	ZAP AND RESET LU/DEVICE
:	------
ZAPHLU
	ST	R6,IZ6SAV,,		:SAVE R6
	LHL	R11,DCBLKS+DCBLUC,RDCB,	:R11 = LUC OFFSET
	JAL	R6,IFRSET		:SEND CKTDW COMMAND TO SNA
	LHI	R0,DTHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	LIS	R0,0			:(F00/04/01/87/DB/START)
	STB	R0,LUCTAB+LUNSTA,R11,	:CLEAR LOGON STATE
	STH	R0,LUCTAB+LUCDCB,R11,	:CLEAR DCB POINTER
					:(F00/04/01/87/DB/END)
	LIS	R0,IFPNSR
	STB	R0,LUCTAB+LUPSTA,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,STLGFL,,
	RBT	R0,FNLGFL,,
	RBT	R0,LUTFLG,,
	LO	SHDPKG
	RBT	R0,BDPETE,,
	RBT	R0,BDPDLU,,
	FO	SHDPKG
	L	R6,IZ6SAV,,
	JR	R6

:	DWNHLU:	DOWN LU/DEVICE
:	------
:	R13 = PUC ADDR
DWNHLU
	ST	R6,IW6SAV,,		:SAVE R6
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	LHI	R0,DTHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
:	LIS	R0,PL.PDN		:DELETE THESE 2 INS. (12/16/86 YLH)
:	STB	R0,LUCTAB+LUPSTA,R11,	:(12/16/86 YLH)
	LIS	R1,1			:INIT LUC CNT
DWNHL1
	LHL	R2,LUCTAB+LUCT.N,R11,
	AIS	R2,1			:NEXT LU
	LHL	R11,LUBPTR,R2,R2	:R11 = NEW LU'S LUCTAB
	ST	R1,IW1SAV,,
	JAL	R6,ZPHCKT		:ZAP CIRCUIT, IF ANY
	LHI	R0,DTHOSD-PSEG
	STH	R0,LUCTAB+LUODPR,R11,
	LHI	R0,DTHOSC-PSEG
	STH	R0,LUCTAB+LUOCPR,R11,
	XR	R0,R0			:CLEAR THE REGISTER (03/18/85 MIA)
	STB	R0,LUCTAB+LUCSCC,R11,	:NON-CLEAR LUSVC BYTE (03/18/85 MIA)
	LB	R0,LUCTAB+LUPSTA,R11,
	CLHI	R0,PL.ACT
	JN	DWNHL2
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE BYTE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JNFS	DWNHL2			:JUMP IF SO
	EI
	LHL	R7,LUCTAB+LUCLNC,R11,
	LB	R7,LNCTAB+LNRHST,R7,
	LHL	R7,HSTPTR,R7,R7
	JAL	R6,RLSHST,,
DWNHL2
	LIS	R0,PL.PDN
	STB	R0,LUCTAB+LUPSTA,R11,
	LHL	R0,LUCTAB+LUCT.N,R11,
	RBT	R0,STLGFL,,
	RBT	R0,FNLGFL,,
	RBT	R0,LUTFLG,,
	L	R1,IW1SAV,,
	AIS	R1,1			:ALL DONE ?
	CLB	R1,PUCTAB+PUMLUN,R13,	:NO, REPEAT
	JN	DWNHL1
	L	R6,IW6SAV,,
	JR	R6

:	ZPHCKT:	ZAP CIRCUIT
:	------
ZPHCKT
	LHL	R12,LUCTAB+LUCDCB,R11,	:R12 = DCB OFFSET
	JER	R6			:IF NO DCB , RETURN
	ST	R6,IK6SAV,,
	JAL	R6,DSCHPR,,		:DISCONNECT HOST PORT
	IF	VHRSUP
	LB	R7,LUCTAB+LUCVHR,R11,	:GET VHR STATE
	THI	R7,LUVHRF		:VHR FUNCTION?
	JEFS	ZPHCK0			:JUMP IF NOT
	LO	CBKDEF
	NHI	R7,LUVTIF!LUVHRF!LURPVC	:MASK NON-SYSGENED BITS

	STB	R7,LUCTAB+LUCVHR,R11,	:CLEAR VHR STATE
	JFS	ZPHCK1			:JUMP TO CONTINUE
ZPHCK0	EQ	.
	EI
	LHL	R7,DCBLKS+DCBHST,RDCB,
	JAL	R6,ZAPHST,,
ZPHCK1	JAL	R6,RELDCB,,
	LIS	R0,0
	STH	R0,LUCTAB+LUCDCB,R11,	:ZAP
	L	R6,IK6SAV,,
	JR	R6

	EI	(HOSTIF)

	SUBTTL	(SNA) IFNC - LINK STATE PROCESSING ROUTINES


:	LINIT:	LINE AT INITIAL STATE
:	------
:	WAIT UNTIL LINE IS IDLE, OR TIMER EXPIRED
:	THEN DROP DTR AND GO TO NEXT STATE
LINIT
	LIS	R0,IDLBIT		:LINE HALT FLAG
	TBT	R0,LNCTAB+LNSFLG,R12,	:SEE IF LINK HALT/STOP
	JNR	R5			:IF NOT, EXIT
	L	R0,LNCTAB+LNTIME,R12,	:GET TIMER
	S	R0,SLOWC,,		:WAIT ENOUGH?
	JGR	R5			:NO, EXIT TO CONTINUE WAITING
	LIS	R0,0			:INIT LINE INACTIVE TIMER (12/30/86 YLH)
	ST	R0,LNCTAB+LNITME,R12,	: (12/30/86 YLH)
	L	R0,SLOWC,,		:SET TIMER
	AHI	R0,OFFTIM		:ADD MAX OFFTIME
	ST	R0,LNCTAB+LNTIME,R12,	:PUT INTO LNCTAB
	LHI	R4,LDOWN-PSEG		:R4 = NEXT NEW STATE
	JR	R5			:RETURN

:	LDOWN:	LINE AT DOWN STATE
:	------
:	CHECK DSR DROP OR HAS DROPPED
:	IF YES, RAISE DTR AND MONITOR DSR FOR SPECIFIED PERIOD
LDOWN
	TBT	R8,DTRDSR		:DTR/DSR HANDSHAKING REQUIRED?
	JE	LDOWN1			:NO, SKIP TO CONTINUE
	LIS	R0,DSRBIT		:CHECK DSR
	TBT	R0,LNCTAB+LNSFLG,R12,	:..
	JEFS	LDOWN1			:DSR DOWN,FORGET TIMER,SKIP TO CONTINUE
	LIS	R0,DSRDRP		:THE DSR MIGHT DROPPED AND BACK AGAIN
	TBT	R0,LNCTAB+LNSFLG,R12,	:
	JEFS	LDOWN1			:IF SO, FORGET TIMER, SKIP TO CONTINUE
	L	R0,LNCTAB+LNTIME,R12,	:ELSE IF TIMER EXPIRED?
	S	R0,SLOWC,,		:..
	JGR	R5			:TIME NOT EXPIRED, EXIT
LDOWN1					:RAISE DTR, AND MONITOR DSR
	LIS	R0,1			:ISSUE RAISE DTR CCOMMAND
	LO	SFGPTP
	JAL	R4,DTRCTL,,		:DO IT
	FO	SFGPTP
	LIS	R0,DTRBIT		:MARK DTR UP
	SBT	R0,LNCTAB+LNSFLG,R12,
LDOWN2
	L	R0,FASTC,,		:SAMPLE DSR FOR A PERIOD OF TIME
	AI	R0,ONTIME*RATE
	ST	R0,LNCTAB+LNTIME,R12,
	LHI	R4,LWDSR-PSEG		:NEXT NEW STATE
	JR	R5

:	LWDSR:	LINE WAITING FOR DSR TO BE UP
:	-----
:	WATCH DSR UP FOR SPECIFIED PERIOD
:	IF DSR UP, THE INIT LINE (FOREGROUND PTPS)
:	AND ENTER LREADY STATE
LWDSR
	TBT	R8,DTRDSR		:DTR/DSR ?
	JE	LWDSR1			:NO, SKIP
	LIS	R0,DSRBIT		:MONITOR DSR SIGNAL
	TBT	R0,LNCTAB+LNSFLG,R12,
	JE	LDOWN2			:IF NOT UP, RESET AD KEEP MONITORING
	L	R0,LNCTAB+LNTIME,R12,	:DSR UP, BUT KEEP SAMPLING FOR
	S	R0,FASTC,,		: THE NECESSARY PERIOD
	JGR	R5			:NOT END OF SAMPLEING PERIORD, RETURN
	LIS	R0,DSRDRP		:MARK DSR DROPED AND THEN UP
	SBT	R0,LNCTAB+LNSFLG,R12,
LWDSR1
:	INIT PTP
:	LR	R14,R5			:SAVE R5 INTO R14(10/01/85/CHS)
:	LR	R13,R12			:SAVE R12 INTO R13(10/01/85/CHS)
:	LO	SFGPTP			:(10/01/85/CHS)
:	JAL	R5,PTPINI,,		:INIT LINE PROTOCOL(10/01/85/CHS)
:	FO	SFGPTP			:(10/01/85/CHS)
:	LR	R5,R14			:RESTORE R5(10/01/85/CHS)
:	LR	R12,R13			:RESTORE R12(10/01/85/CHS)
:	ISSUE INITCD TO DLC LAYER
	LB	R10,LNCTAB+LNMXPU,R12,	:R10 = TOTAL # OF PU ON THIS LINE
	LHL	R13,LNCTAB+LNPUTB,R12,	:R13 = 1ST PUCTAB OFFSET
LWDSR2
	JAL	R6,ILINIT		:SEND INITCD TO DLC
	LHL	R0,PUCTAB+PUIFNC,R13,
	AIS	R0,0A
	STH	R0,PUCTAB+PUIFNC,R13,
	SIS	R10,1			:ALL DONE?
	JLEFS	LWDSR3			:YES, SKIP
	AHI	R13,PUCLEN		:NEXT PUC
	JBS	LWDSR2			:REPAET
LWDSR3
:	ENTER LREADY STATE
	LHI	R4,LREADY-PSEG	
	JR	R5

:	LREADY: LINE READY STATE
:	------
:	IF TERMINAL LINE, SNRM/UA EXCHANGE SUCCESSFUL, ENTER LACTIVE
:	IF HOST LINE, RECEIVE SNRM RETURN UA, ENTER LACTIVE
:	THE CHANGE OF STATE UNDER THE ABOVE CONDITIONS ARE PERFORMED
:	BY THE IFCCMD PROCESSOR
:	IF DSR DROP, ERROR RECOVERY
LREADY
	LIS	R0,LERBIT		:MONITOR LINK ERROR BIT
	TBT	R0,LNCTAB+LNSFLG,R12,
	JN	LREAD1			:LINK ERROR , TO RECOVERY
	TBT	R8,DTRDSR
	JER	R5
	LIS	R0,DSRBIT		:MONITOR DSR SIGNAL
	TBT	R0,LNCTAB+LNSFLG,R12,
	JNR	R5			:DSR OK, RETURN
					:ELSE, SEND CLEARCD TO DLC LAYER
LREAD1
	LB	R10,LNCTAB+LNMXPU,R12,	:R10 = TOTAL # OF PU ON THIS LINE
	LHL	R13,LNCTAB+LNPUTB,R12,	:R13 = 1ST PUCTAB OFFSET
LREAD2
	JAL	R6,ILCLR		:SEND CLRCD TO DLC
	JAL	R6,ILFLUH		:FLUSH DLC->IFC CMD-Q
	LHL	R0,PUCTAB+PUIFNC,R13,
	SIS	R0,0A
	STH	R0,PUCTAB+PUIFNC,R13,
	LB	R0,PUCTAB+PUCRID,R13,	:R0 = REL PUC #
	LB	R6,PUCTAB+PULNKN,R13,	:R6 = LINE #
	SLHLS	R6,1			:R6 = HW LINE INDEX
	SBT	R0,IFCLER,R6,R6		:SET IFCLER BIT
	SIS	R10,1			:ALL DONE?
	JLEFS	LREAD3			:YES, SKIP
	AHI	R13,PUCLEN		:NEXT PUC
	J	LREAD2			:REPAET
LREAD3
:	ENTER LINE CLEAR STATE
	LHI	R4,LCLEAR-PSEG		:ENTER LINE CLEAR STATE
	JR	R5

:	LACTIVE: LINE ACTIVE
:	--------
:	IF	DSR DROP, ERROR RECOVERY
LACTIVE
	LIS	R0,LERBIT		:MONITOR LINK ERROR BIT
	TBT	R0,LNCTAB+LNSFLG,R12,
	JN	LACTI2			:LINK ERROR, TO RECOVERY
	L	R0,LNCTAB+LNITME,R12,	:LINK INACT?
	JEFS	LACTI1			:NO, SKIP
	CL	R0,SLOWC,,		:SEE IF TIME UP
	JLFS	LACTI2			:TIME OUT, TO DISCONNECTED
LACTI1
	TBT	R8,DTRDSR
	JER	R5
	LIS	R0,DSRBIT		:MONITOR DSR SIGNAL
	TBT	R0,LNCTAB+LNSFLG,R12,
	JNR	R5			:DSR OK, RETURN
LACTI2
					:ELSE, SEND XDOWN TO SNA AND
					: CLEAR TO DLC
	LB	R10,LNCTAB+LNMXPU,R12,	:R10 = TOTAL # OF PU ON THIS LINE
	LHL	R13,LNCTAB+LNPUTB,R12,	:R13 = 1ST PUCTAB OFFSET
	LH	R0,LNCTAB+LNHOST,R12,	:SEE IF HOST OR TERMINAL
	JG	LACTI4			:HOST, SKIP
LACTI3
	IF	TERMIF
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,DWNTLU
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,IFDOWN		:SEND DOWN TO SNA.SSCP
	JAL	R6,ILCLR		:SEND CLRCD TO DLC
	JAL	R6,ILFLUH		:FLUSH DLC->IFC CMD-Q
	LHI	R0,IPNDM-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	LB	R0,PUCTAB+PUCRID,R13,	:R0 = REL PUC #
	LB	R6,PUCTAB+PULNKN,R13,	:R6 = LINE #
	SLHLS	R6,1			:R6 = HW LINE INDEX
	SBT	R0,IFLRST,R6,R6		:SET IFLRST BIT
	SBT	R0,IFCLER,R6,R6		:SET IFCLER BIT
	SIS	R10,1			:ALL DONE?
	JLE	LACTI5			:YES, SKIP
	AHI	R13,PUCLEN		:NEXT PUC
	J	LACTI3			:REPAET
	ELSE
	JAL	R10,CRASH,,
	BC	0,0,0,099
	EI	(TERMIF)

LACTI4
	IF	HOSTIF
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,DWNHLU
	LHL	R11,PUCTAB+PUCLUC,R13,	:R11 = LUC OFFSET
	JAL	R6,IFDOWN		:SEND DOWN TO SNA.SSCP
	JAL	R6,ILCLR		:SEND CLRCD TO DLC
	JAL	R6,ILFLUH		:FLUSH DLC->IFC CMD-Q
	LHI	R0,ISNDM-PSEG
	STH	R0,PUCTAB+PUIFNC,R13,
	LB	R0,PUCTAB+PUCRID,R13,	:R0 = REL PUC #
	LB	R6,PUCTAB+PULNKN,R13,	:R6 = LINE #
	SLHLS	R6,1			:R6 = HW LINE INDEX
	SBT	R0,IFLRST,R6,R6		:SET IFLRST BIT
	SBT	R0,IFCLER,R6,R6		:SET IFCLER BIT
	SIS	R10,1			:ALL DONE?
	JLE	LACTI5			:YES, SKIP
	AHI	R13,PUCLEN		:NEXT PUC
	J	LACTI4			:REPAET
	ELSE
	JAL	R10,CRASH,,
	BC	0,0,0,099
	EI	(HOSTIF)

LACTI5
:	ENTER LINE CLEAR STATE
	LB	R8,PUCTAB+PULNKN,R13,	:RESTORE R8 = LINE #
	LHL	R12,LNCPTR,R8,R8	:R12 = LNC TAB
	LHI	R4,LCLEAR-PSEG
	JR	R5

:	LCLEAR: LINE CLEAR STATE
:	------
:	THE EXIT OF LINE STATE FROM LCLEAR INTO LINIT IS
:	UNDER THE CONTROL OF THE OSCAN PROCESS
LCLEAR
	LR	R6,R8			:R6 = LINE #
	SLHLS	R6,1			:R6 = HW LINE INDEX
	L	R0,IFLRST,R6,R6		:ALL PU RESET?
	JNR	R5			:NO, EXIT
	L	R0,IFCLER,R6,R6		:ALL LSC RESET?
	JNR	R5			:NO, EXIT
:	RBT	R8,LNCTAB+LNSFLG,R12,	:RESET LINK ERR FLG
	LIS	R4,LERBIT		:LOAD ERROR BIT OFFSET (12/30/86 YLH)
	RBT	R4,LNCTAB+LNSFLG,R12,	:RESET LINK ERR FLG (12/30/86 YLH)
	TBT	R8,DIALUP		:A DIA-UP LINE?
	JEFS	LCLEA1			:NO, SKIP
	LIS	R0,0			:ISSUE DROP DTR COMMAND
	LO	SFGPTP
	JAL	R4,DTRCTL,,		:DROP DTR FOR A WHILE
	FO	SFGPTP
LCLEA1
	LHL	R0,LNCTAB+LNDSCT,R12,	:GET DISC(DROP DTR) DURATION
	A	R0,SLOWC,,
	ST	R0,LNCTAB+LNTIME,R12,
	LHI	R4,LINIT-PSEG		:ELSE, ENTER LINIT STATE
	JR	R5

	FO	GBLDEF
	FO	CMDLST
	FO	FRNTND
	EM
   	SUBTTL	(SNA) DATA STORAGES ALLOCATION - GBLDEF
:STOR00.G00

	MO	.,GBLDEF

:	**************************************************
:	REVISION HISTORY --
:	06/06/84 (NCS) -- ADD STORAGE ALLOCATION IN LUCTAB FOR DSP
:			  AND UPDATE 
:	************************************************************

	RA	0			:RADIX IS HEX

	LO	MAIN
	LO	GBLDEF
	LO	CBKDEF

	SEG	A.DATA			:(01/20/87 YLH)

	BND	10
LUCTAB	EQ	.-2
	BS	MAXLUN*LUCLEN
OLDORG	EQ	.
QX	EQ	0
QY	EQ	0
Q	EQ	0
QR1	EQ	0
	RE	NLINES
QR	EQ	0
	RE	MSTN|Q|
PX|Q||QR|	EQ	QX*LUCLEN+2
QQ	EQ	0
	RE	MLU|Q||QR|
	ORG	LUCTAB+2+QX*LUCLEN
	HC	QY+LX|Q||QR||QQ|
	HC	QX
	BC	QQ			:REL#/LUSON SAME PU
	BC	LX|Q||QR||QQ|		:LU ADDR
	BC	01
	IF	\LT|Q||QR||QQ|
	BC	LT|Q||QR||QQ|		:LU TYPE
	ELSE
	BC	G.LUTY
	EI
	IF	\LP|Q||QR||QQ|
	BC	LINK|Q|+LP|Q||QR||QQ|
	ELSE
	BC	0			:LU NS MODE
	EI
	BC	LV|Q||QR||QQ|		:LU SYS
	BC	0			:LU FST
	BC	LL|Q||QR||QQ|		:LU DIF
	BC	QR1			:PU#
	BC	0			:LU CKT ST
	BC	0,0			:SNA ST
	BC	0,0,0,0			:SNA LU.SVC ST
	BC	0			:OCSN ST
	BND	2
QX	EQ	QX+1
QQ	EQ	QQ+1
	ER
QY	EQ	QY+MLID|Q||QR|+1
QR	EQ	QR+1
QR1	EQ	QR1+1
	ER
Q	EQ	Q+1
	ER

X	EQ	0
Z	EQ	0
Q	EQ	0
	RE	NLINES
P	EQ	0
	RE	MSTN|Q|
Y	EQ	0
	RE	MLU|Q||P|
	ORG	LUCTAB+2+X*LUCLEN+LUPRIA
	HC	0
	HC	0
	HC	0,0
	HC	0
	HC	0
	IF	FWSCB
	WC	0,0,0
	ELSE
	HC	0,0,0
	EI
	HC	Q*LNCLEN+2
	HC	Z*PUCLEN+2
	IF	LINK|Q|
	IF	Y
	HC	BM|Q||P||Y|-PSEG
	ELSE
	HC	-1
	EI
	HC	AM|Q||P||Y|-PSEG
	HC	DM|Q||P||Y|-PSEG
	ELSE
	HC	0,AM|Q||P||Y|-PSEG,0
	EI
	HC	0,0
	HC	0,0,0
	HC	0,0,0
	HC	0,0,0
	HC	0,0,0
	HC	0,0
	ORG	LUCTAB+2+X*LUCLEN+LUCLAB
	IF	\LB|Q||P||Y|
	BC	LB|Q||P||Y|
	ELSE
	IF	\G.LLAB
	BC	G.LLAB
	ELSE
	BC	0
	EI
	EI
X	EQ	X+1
Y	EQ	Y+1
	ER
Z	EQ	Z+1
P	EQ	P+1
	ER
Q	EQ	Q+1
	ER

:THESE VHR/VTI DEFINITIONS ARE USED WITHIN THE NEXT LOOPS
LUVHRF	EQ	40
LUVTIF	EQ	80

:	THIS LOOP IS FOR INACTIVE TIMEOUT,APPLICATION LOGOFF

PX	EQ	0
PZ	EQ	0
PQ	EQ	0
	RE	NLINES
PP	EQ	0
	RE	MSTN|PQ|
PY	EQ	0
	RE	MLU|PQ||PP|
	ORG	LUCTAB+2+PX*LUCLEN+LUIATO
	IF	(\LD|PQ||PP||PY|)
	HC	2*LD|PQ||PP||PY|
	ELSE
	HC	2*G.ITIM
	EI
	IF	(\LO|PQ||PP||PY|)
	HC	2*LO|PQ||PP||PY|
	ELSE
	HC	2*G.ATIM
	EI
	IF	FWBBF
	WC	0
	ELSE
	HC	0
	EI
	IF	(\LZ|PQ||PP||PY|)
	BC	LZ|PQ||PP||PY|
	ELSE
	BC	0
	EI
	IF	VHRSUP
	ORG	LUCTAB+2+PX*LUCLEN+LUCVHR
	IF	\VR|PQ||PP||PY|
	IF	VR|PQ||PP||PY|
	BC	LUVHRF
	ELSE
	BC	0
	EI
	ELSE
	IF	\G.VHR
	IF	G.VHR
	BC	LUVHRF
	ELSE
	BC	0
	EI
	ELSE
	BC	0
	EI
	EI
	EI
PX	EQ	PX+1
PY	EQ	PY+1
	ER
PZ	EQ	PZ+1
PP	EQ	PP+1
	ER
PQ	EQ	PQ+1
	ER


:	THIS LOOP IS FOR VTI FUNCTION

PX	EQ	0
PZ	EQ	0
PQ	EQ	0
	RE	NLINES
PP	EQ	0
	RE	MSTN|PQ|
PY	EQ	0
	RE	MLU|PQ||PP|
	ORG	LUCTAB+2+PX*LUCLEN+LUCFST
	IF	\LS|PQ||PP||PY|
	BC	LS|PQ||PP||PY|^1
	ELSE
	IF	\G.SIZE
	BC	G.SIZE^1
	EI
	EI
	IF	VTISUP
	ORG	LUCTAB+2+PX*LUCLEN+LUCVTI
	IF	\VT|PQ||PP||PY|
	IF	VT|PQ||PP||PY|
QQQQQQ	EQ	LUVTIF
	ELSE
QQQQQQ	EQ	0
	EI
	ELSE
	IF	\G.VTI
	IF	G.VTI
QQQQQQ	EQ	LUVTIF
	ELSE
QQQQQQ	EQ	0
	EI
	ELSE
QQQQQQ	EQ	0
	EI
	EI
	IF	\SR|PQ||PP||PY|
	IF	SR|PQ||PP||PY|
QQQQQQ	EQ	QQQQQQ!LUSRQF
	EI
	ELSE
	IF	\G.SRQ
	IF	G.SRQ
QQQQQQ	EQ	QQQQQQ!LUSRQF
	EI
	EI
	EI
	BC	QQQQQQ
	EI
PX	EQ	PX+1
PY	EQ	PY+1
	ER
PZ	EQ	PZ+1
PP	EQ	PP+1
	ER
PQ	EQ	PQ+1
	ER
	LIST
	ORG	OLDORG

:	PU CONTROL BLOCK TABLE
:	---------------------------
:	SEG	A.BDAT			:(01/20/87 YLH)
	SEG	A.DATA			:(01/20/87 YLH)

	BND	10
PUCTAB	EQ	.-2
	BS	MAXPUN*PUCLEN
OLDORG	EQ	.
:	NOLIST
PP	EQ	0
Q	EQ	0
	RE	NLINES
:PY|Q|	EQ	PP*PUCLEN+2
QQ	EQ	0
	RE	MSTN|Q|
	ORG	PUCTAB+2+PP*PUCLEN
	BC	PP
	BC	CUAD|Q||QQ|
	BC	Q
	BC	QQ
	BC	MLU|Q||QQ|
	BC	MLID|Q||QQ|
	BC	0
	BC	0
	BND	2
	HC	Q*LNCLEN+2
	HC	PP*LSCLEN+2
	HC	PX|Q||QQ|
	HC	0
	HC	0,0,0
	HC	0,0,0
	HC	0
	HC	0,0
	HC	40 BBQA
	HC	40 BBQA
	HC	0,0
	ORG	PUCTAB+PP*PUCLEN+PUCLAB+2
	IF	\PLB|Q||QQ|
	BC	PLB|Q||QQ|
	ELSE
	IF	\G.PLAB
	BC	G.PLAB
	ELSE
	BC	0
	EI
	EI
PP	EQ	PP+1
QQ	EQ	QQ+1
	ER
Q	EQ	Q+1
	ER
	LIST
	ORG	OLDORG

	FO	MAIN
	FO	CBKDEF

	EM
   
	SUBTTL	SNA COMMON ROUTINES AREA FOR ALL LAYERS
:	MODULE NAME IN COMMAND FILE -- SRTN02.F00

:	***********************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	***************************************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT FAPL UTILITY ROUTINES
:	(SEE FAPL APPENDIX-B,N)
:	-------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CBKDEF
	LO	BBUFER
	LO	CMDLST
	LO	GBLDEF
	LO	MAIN
	GL	FSMSBL,FSMTBL,FSMPBL

	SEG	A.DATA

	BND	4
IZSAVG	WS	10			:REGISTERS SAVE AREA FOR ALL
LSTSAV	WS	1			:SAVE AREA FOR SCB SCANNING
SCASAV	WS	1			:SAVE AREA FOR SCB SCANNING
RGSAV3	WS	1			:STORAGE FOR REG. 3
RGSAV4	WS	1			:STORAGE FOR REG. 4
RGSAV5	WS	1			:STORAGE FOR REG. 5
RGSAV6	WS	1			:STORAGE FOR REG. 6
RGSAV7	WS	1			:STORAGE FOR REG. 7
RGSAV8	WS	1			:SAVE AREA FOR R8
RGSAV9	WS	1			:SAVE AREA FOR R9
RGSAVA	WS	1			:SAVE AREA FOR R10 (8/30/85/CHS)
RGSAVC	WS	1			:SAVE AREA FOR RETURN ADDRESS
RGSAVF	WS	1			:SAVE AREA FOR R15
GBB4SV	WS	1			:SAVE RETURN ADDRESS FOR GBB
LSTEND	BS	1			:STORAGE FOR SCB_LST SCANE POINTER
LSTTIM	BS	1			:STORAGE FOR SCB_LST SCANE LOOP
SCAEND	BS	1			:STORAGE FOR SCB_LST SCANE POINTER
SCATIM	BS	1			:STORAGE FOR SCB_LST SCANE LOOP

	BND	2
TB.SCP	
	BC	ACTPU,ACTLU,BIND,ACCDRM,DACTPU,DACTLU,UNBIND,DACDRM
TB.SCL	EQ	.-TB.SCP
	BND	2
TB.FDP	
	BC	FID0^4,FID1^4,FID2^4,FID3^4,FID4^4,FIDF^4
TB.FDL	EQ	.-TB.FDP

	SEG	A.CODE

:	(09/09/86/CHS)
:	R.CODE	: REFERENCE POINT FOR SRTN ROUTINES IN CREATING
:	-------
:		JUMP TABLES TO MAKE THE ENTRIES OF THE TABLE FITTED AS
:		HALF-WORD PER ENTRY.
R.CODE	EQ	.

:	(09/09/86/CHS) END


:	SEND	:THIS ROUTINE CAUSES A MESSAGE UNIT OR CHARACTER-STRING
:	SIGNAL TO BE SENT TO ANOTHER PROCEDURE BY CREATING A
:	DISPATCHING QUEUE ENTRY (DQE) AND INSERTING IT ON THE
:	DISPATCHING QUEUE.
:	-------------------------------------------------------------
:	INPUT	:R0 (INPUT SIGNAL) R1 (SENDING PROC.) R2 (DESTINATION PROC.)
:		 R3 (DQE ENTRY) RNODE (NODE #)
:	LINK	:R8
:	OUTPUT	:
:	DESTROY	:R3,R4,R5,R6,R7,R15,R9

SEND
:	LR	R4,RNODE
:	SLHLS	R4,1			:SET FULLWORD BASE
:	ST	R8,RTNSAV,R4,R4		:SAVE RETURN ADDRESS
	STB	R0,BBUFER+DQISIG,R3,	:STORE INPUT SIGNAL INTO DQE
	STB	R1,BBUFER+DQSPRO,R3,	:STORE SEND_PROCEDURE INTO DQE
	STB	R2,BBUFER+DQDPRO,R3,	:STORE DESTINATION INTO DQE
	LCS	R7,1			:FOR INITIAL VALUE
	ST	R7,BBUFER+DQTGCB,R3,	:INIT TGCB PTR
:	ST	R7,BBUFER+DQERCB,R3,	:INIT ERCB PTR
:	ST	R7,BBUFER+DQVRCB,R3,	:INIT VRCB PTR
:	ST	R7,BBUFER+DQDRCB,R3,	:INIT DRCB PTR
:	ST	R7,BBUFER+DQNRCB,R3,	:INIT NRCB PTR
:	THE DQE(R6) IS PLACED LAST ON THE DISPATCHING QUEUE
:	-------------------------------------------------
	JAL	R4,GETCL,,		:GET QUEUE ENTRY IN THE DPQ
	JAL	R4,QUEMPT		:JUMP,IF NO ENTRY AVAILABLE
	LHL	R4,NCBPTR,RNODE,RNODE	:GET NCBPTR FOR THIS NODE
	LHL	R7,NCBBLK+NDDQRP,R4,	:GET RELEASE PTR FOR DPQ
	BBSTOR	R3,CMDBLK+CLARG,R7,	:SAVE DQE PTR
	STH	R6,CMDBLK+CLPTR,R7,
	STH	R6,NCBBLK+NDDQRP,R4,	:UPDATE RELEASE PTR
:	LR	R4,RNODE
:	SLHLS	R4,1			:SET FULLWORD BASE
:	L	R8,RTNSAV,R4,R4		:SAVE RETURN ADDRESS
	JR	R8			:RETURN TO CALLING PROCEDURE


:	THIS ROUTINE IS USED TO SUPPORT FID TYPE SEARCH
:	-----------------------------------------------------------
:	INPUT	-R0 (FID FIELD CONTAINS FROM RU)
:	LINK	-R4
:	OUTPUT	-R2 (INDEX TO TB.FDP)
R.FDSH
	LHI	R2,TB.FDL-1
R.FDS1
	CLB	R0,TB.FDP,R2,		:CHECK CURRENT SC RQ_CODE TO TABLE
	JER	R4			:YES,RETURN
	SIS	R2,1
	JGEBS	R.FDS1
	LHI	R2,TB.FDL
	JR	R4			:RETURN

:	THIS ROUTINE IS USED TO SUPPORT SC (ACTIVATION/DEACTIVATION) SEARCH
:	-----------------------------------------------------------
:	INPUT	-R0 (SC RQ_CODE TYPE)
:	LINK	-R4
:	OUTPUT	-R2 (INDEX TO TB.SCP)
R.SCSH
	LHI	R2,TB.SCL-1
R.SCS1
	CLB	R0,TB.SCP,R2,		:CHECK CURRENT SC RQ_CODE TO TABLE
	JER	R4			:YES,RETURN
	SIS	R2,1
	JGEBS	R.SCS1
	LHI	R2,TB.SCL
	JR	R4			:RETURN

	SUBTTL	MU (MESSAGE UNIT) FORMATS RELATED UTILITY ROUTINES

:	R.MFCN	-(MAP_FROM_CANONICAL) TO TRANSLATE AN OUTGOING PIU FROM
:	CANONICAL FORMAT TO LINK FORMAT.
:	PAGE B-16 ON FAPL
:	---------------------------------------------------------------
:	INPUT	:R10 (MUCB PTR),R15 (PCCB PTR) R9 (SCB PTR) R13 (NCB PTR)
:	LINK	:R8
:	OUTPUT	:R1 (PIU PTR) R0 (PIU_LENGTH)
:*****NOTE, THE PIU PTR CAN BE TREATED AS THE PTR (MUCBTU) IN THE MUCB
:****IF (1) MU CONTAINTS WAS NOT MODIFIED (2) TH+RH+RU IS THE FRAME
:****WHICH GOES THRU THE NETWORK
R.MFCN
:	CANONICAL_PIU_PTR=MU_PTR=(R10)
:	CREATE MU
:	THN_ADDR=NEW MU_PTR=(R3)
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PRE_SEGEMENTING ADDR. FOR TH
	JLE	R.CRAS,,		:CRASH
:	JAL	R4,GBB,,		:GET BIG BUFFERLET FOR MU
:	J	NOENT5,,		:CRASH,IF NOT AVAILABLE BUFFER
	LR	R1,R3			:SAVE MU_PTR IN R1
:	R3 (THN_ADDR)
:	-------------
	LIS	R5,0
	LB	R0,BBUFER+MUBIUF,R10,	:GET MUBIUF FROM MUCB FOR TH(1ST BYTE)
	NHI	R0,MU.FID		:TO GET FID TYPE FROM TH
	JAL	R4,R.FDSH		:CALL FID TYPE SEARCH
	LHL	R4,R.MFCF,R2,R2		:GET DIFFERENT ENTRY FOR FID


:	(09/09/86/CHS)
:	SOME OF THE ROUTINES MAY NOT RESIDE IN SEG 1 WHEN
:	A LOT OF OPTIONS ARE TURNED ON.
:	USE R.CODE TO REPLACE SEG|A.CODE| AS THE REFERENCE POINT.
:	J	SEG|A.CODE|,R4,
:R.MFCF	HS
:	HC	R.MFC0-SEG|A.CODE|	:FID0
:	HC	R.MFC1-SEG|A.CODE|	:FID1
:	HC	R.MFC2-SEG|A.CODE|	:FID2
:	HC	R.MFC3-SEG|A.CODE|	:FID3
:	HC	R.MFC4-SEG|A.CODE|	:FID4
:	HC	R.MFC5-SEG|A.CODE|	:FIDF
:	HC	R.CRAS-SEG|A.CODE|	:ERROR FID

	J	R.CODE,R4,
R.MFCF	HS
	HC	R.MFC0-R.CODE		:FID0
	HC	R.MFC1-R.CODE		:FID1
	HC	R.MFC2-R.CODE		:FID2
	HC	R.MFC3-R.CODE		:FID3
	HC	R.MFC4-R.CODE		:FID4
	HC	R.MFC5-R.CODE		:FIDF
	HC	R.CRAS-R.CODE		:ERROR FID

:	(09/09/86/CHS) END OF MODIFICATION

:	FID0 - TH HEADER HANDLER
:	------------------------
R.MFC0
	AHI	R3,10			:SET RUN_ADDR
	J	R.MFC6
:	FID1 - TH HEADER HANDLER
:	------------------------
R.MFC1
	AHI	R3,10			:SET RUN_ADDR
	J	R.MFC6
:	FID2 - TH HEADER HANDLER
:	------------------------
R.MFC2
	LB	R0,BBUFER+MUBIUF,R10,	:GET FID BYTE FROM MUCB
	STB	R0,BBUFER,R3,		:STORE FID BYTE INTO MU_PTR
	LIS	R0,0			:CLEAR 2ND BYTE OF TH
	STB	R0,BBUFER+1,R3,		:CLEAR 2ND BYTE OF TH
	LB	R0,BBUFER+MUDADP,R10,	:GET DAFPRIME FROM MUCB
	STB	R0,BBUFER+2,R3,		:STORE DAF INTO MU_PTR
	LB	R0,BBUFER+MUOADP,R10,	:GET DAFPRIME FROM MUCB
	STB	R0,BBUFER+3,R3,		:STORE DAF INTO MU_PTR
	LHL	R0,BBUFER+MUSNF,R10,	:GET SNF
	STH	R0,BBUFER+4,R3,		:STORE SNF INTO MU_PTR
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF
	AIS	R0,6			:SET PIU_LENGTH TO DCF+6
	AHI	R3,6			:SET RUN_ADDR
	J	R.MFC6
:	FID3 - TH HEADER HANDLER
:	------------------------
R.MFC3
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF
	AIS	R0,2			:SET PIU_LENGTH TO DCF+2
	AHI	R3,2			:SET RUN_ADDR
	J	R.MFC6
:	FID4 - TH HEADER HANDLER
:	------------------------
R.MFC4
	AHI	R3,26			:SET RUN_ADDR
	J	R.MFC6
:	FIDF - TH HEADER HANDLER
:	------------------------
R.MFC5
	J	R.MFC9			:JUMP TO DISCARD CANONICAL_PIU_PTR
:	MOVE RH TO LINK FORMAT MU
:	--------------------------
:	R3 (PTR TO RHN_ADDR)
R.MFC6
	LHL	R2,BBUFER+MUDCF,R10,	:GET DCF
	LB	R4,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R4,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	R.MFC7			:JUMP,IF IT IS NOT SET (NOT BBIU)
	LB	R7,BBUFER+MURHF1,R10,	:GET RH 1ST BYTE FROM CANONICAL_PIU_PTR
	STB	R7,BBUFER,R3,		:SET 1ST BYTE OF RH INTO MU_PTR
	AIS	R3,1			:MOVE ONE BYTE FOR NEXT RH BYTE
	LB	R7,BBUFER+MURHF2,R10,	:GET RH 2ND BYTE FROM CANONICAL_PIU_PTR
	STB	R7,BBUFER,R3,		:SET 2ND BYTE OF RH INTO MU_PTR
	AIS	R3,1			:MOVE ONE BYTE FOR NEXT RH BYTE
	LB	R7,BBUFER+MURHF3,R10,	:GET RH 3RD BYTE FROM CANONICAL_PIU_PTR
	STB	R7,BBUFER,R3,		:SET 3RD BYTE OF RH INTO MU_PTR
	AIS	R3,1			:MOVE ONE BYTE FOR NEXT RH BYTE
	SIS	R2,3			:GET LENGTH OF RU
:	RUN_ADDR=(R3)
:	-------------
R.MFCB
	LB	R7,BBUFER+MURHF1,R10,	:GET CONTAINTS OF 1ST RH BYTE
	NHI	R7,MU.SDI		:MASK OFF OTHER BITS ,FOR SDI BIT
	JE	R.MFC7			:JUMP,IF SENSE INDICATOR IS OFF
	L	R7,BBUFER+MURHSN,R10,	:GET SENSE DATA FROM MUCB
	EXHR	R4,R7			:REPLACE BIT 16:31 WITH BIT 0:15
	STB	R7,BBUFER+3,R3,		:STORE BIT 24:31 SENSE DATA INTO RU
	EXBR	R7,R7			:REPLACE BIT 8:15 WITH BIT 0:7
	STB	R7,BBUFER+2,R3,		:STORE BIT 16:23 OF SENSE DATA INTO RU
	STB	R4,BBUFER+1,R3,		:STORE BIT 8:15 OF SENSE DATA INTO RU
	EXBR	R4,R4			:REPLACE BIT 8:15 WITH BIT 0:7
	STB	R4,BBUFER,R3,		:STORE BIT 0:7 OF SENSE DATA INTO RU
	AIS	R3,4			:RUN_ADDR=RUN_ADDR+4
R.MFC7
:	LB	R7,BBUFER+MURHF1,R10,	:GET CONTAINTS OF 1ST RH BYTE
:	NHI	R7,MU.SDI		:MASK OFF OTHER BITS ,FOR SDI BIT
:	JEFS	R.MFCA			:JUMP,IF SENSE INDICATOR IS OFF
:	SIS	R2,4			:MU.DCF-8 WHEN SDI IS ON
:R.MFCA
:	LIS	R5,0
:R.MFC8
:	LB	R7,BBUFER+MURUPT,R5,R10	:GET RU FROM MUCB
:	STB	R7,BBUFER,R5,R3		:STORE IT INTO NEW MU
:	AIS	R5,1
:	CR	R5,R2			:IS IT END OF DCF?
:	JL	R.MFC8			:CONTINUE,IF NOT FINISH
::	THE END OF MOVEMENT FOR THE RU DATA
::	-----------------------------------
::	DISCARD CANONICAL_PTR
R.MFC9
:	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU PTR
:	JAL	R4,PBB,,		:DISCARD BTU DATA
	LR	R3,R10			:SET MUCB PTR FOR R3
	JAL	R4,PBB,,		:DISCARD MUCB PTR
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	JR	R8			:RETURN

:	R.MTCN	-(MAP_TO_CANONICAL) TO TRANSLATE AN INCOMING MESSAGE
:	UNIT (MU) FROM LINK FORMAT TO CANONICAL FORMAT
:	PAGE B-18 ON FAPL
:	---------------------------------------------------------------
:	INPUT	:RNODE (NODE NUMBER) R3 (MUCB PTR) 
:		:R10 (BTU DATA BUFFER PTR) R7 (PIU LENGTH)
:	LINK	:R8
:	OUTPUT	:R10 (MUCB PTR)
:	DESTROY	:R1,R2,R5,R7
:	SPECIAL	:R6 (RHN_ADDR) R10 (THN_ADDR, BTU DATA BUFFER PTR)
R.MTCN
	BBSTOR	R10,BBUFER+MUCBTU,R3,	:SAVE TH+RH+RU PTR IN MUCB
	LIS	R1,0
	STB	R1,BBUFER+MUMISC,R3,	:CLEAR MISCELLANEOUS
	STB	R1,BBUFER+MUSCHK,R3,	:CLEAR SEND_CHECK
	ST	R1,BBUFER+MURHSN,R3,	:CLEAR SENSE DATA
	ST	R1,BBUFER+MUSCKS,R3,	:CLEAR SEND_CHECK_SENSE
	ST	R1,BBUFER+MURCKS,R3,	:CLEAR RCV_CHECK_SENSE
	LHI	R1,RCV			:SET DIRECTION TO RCV
	STB	R1,BBUFER+MUDIRE,R3,	:SET UP MUCB.DIRECTION CONTAINTS
	LR	R6,R10
	LB	R0,BBUFER,R10,		:GET 1ST BYTE OF TH
	LR	R1,R0			:SAVE 1ST BYTE OF TH
	NHI	R0,MU.FID		:TO GET FID TYPE FROM TH
	JAL	R4,R.FDSH		:SEARCH FOR FID TYPE
	LHL	R5,FIDTBL,R2,R2		:GET ENTRY FOR FID

:	(09/09/86/CHS)
:	SOME OF THE ROUTINES MAY NOT RESIDE IN SEG 1 WHEN
:	A LOT OF OPTIONS ARE TURNED ON.
:	USE R.CODE TO REPLACE SEG|A.CODE| AS THE REFERENCE POINT.
:	J	SEG|A.CODE|,R5,		:JUMP TO DIFFERENT ROUTINE
:
:FIDTBL	HS
:	HC	R.MTC0-SEG|A.CODE|	:FID TYPE 0
:	HC	R.MTC0-SEG|A.CODE|	:FID TYPE 1
:	HC	R.MTC1-SEG|A.CODE|	:FID TYPE 2
:	HC	R.MTC2-SEG|A.CODE|	:FID TYPE 3
:	HC	R.MTC3-SEG|A.CODE|	:FID TYPE 4
:	HC	R.MTC5-SEG|A.CODE|	:FID TYPE F
:	HC	R.CRAS-SEG|A.CODE|	:ERROR FID

	J	R.CODE,R5,		:JUMP TO DIFFERENT ROUTINE

FIDTBL	HS
	HC	R.MTC0-R.CODE		:FID TYPE 0
	HC	R.MTC0-R.CODE		:FID TYPE 1
	HC	R.MTC1-R.CODE		:FID TYPE 2
	HC	R.MTC2-R.CODE		:FID TYPE 3
	HC	R.MTC3-R.CODE		:FID TYPE 4
	HC	R.MTC5-R.CODE		:FID TYPE F
	HC	R.CRAS-R.CODE		:ERROR FID


:	(09/09/86/CHS) END OF MODIFICATION

:	MOVE TH TO CANONICAL MU ACCORDING TO FID TYPE
:	---------------------------------------------
:	FID TYPE 0,AND 1 -- RHN_ADDR=PTR_ADD(THN_ADDR,10)
:	                    CANONICAL_PTR->TH=FID1_TH,BY NAME
R.MTC0
:	R0 (1ST BYTE OF TH)
	AIS	R6,$A10			:SET UP RHN_ADDR IN R6
	STB	R1,BBUFER+MUBIUF,R3,	:SET UP TH.DAF CONTAINTS
	LHL	R1,BBUFER+2,R10,	:GET DAF FROM TH
	STH	R1,BBUFER+MUDADF,R3,	:SET UP TH.DAF CONTAINTS
	LHL	R1,BBUFER+4,R10,	:GET OAF FROM TH
	STH	R1,BBUFER+MUOADF,R3,	:SET UP TH.OAF CONTAINTS
	LHL	R1,BBUFER+6,R10,	:GET SNF FROM TH
	STH	R1,BBUFER+MUSNF,R3,	:SET UP TH.SNF CONTAINTS
	LHL	R1,BBUFER+8,R10,	:GET DCF FROM TH
	STH	R1,BBUFER+MUDCF,R3,	:SET UP TH.DCF CONTAINTS
	J	R.MTC7			:JUMP TO HANDLE RH AND RU
:	FID TYPE 2 ----- -- RHN_ADDR=PTR_ADD(THN_ADDR,6)
:	                    CANONICAL_PTR->TH=FID2_TH,BY NAME
:	                    CANONICAL_PTR->MU.DCP=PIULNTH-6
R.MTC1
:	R0 (1ST BYTE OF TH)
	AIS	R6,$A06			:SET UP RHN_ADDR IN R6
	STB	R1,BBUFER+MUBIUF,R3,	:SET UP TH.DAF CONTAINTS
	LB	R1,BBUFER+2,R10,	:GET DAF FROM TH
	STB	R1,BBUFER+MUDADP,R3,	:SET UP TH.DAFPRIME CONTAINTS
	LB	R1,BBUFER+3,R10,	:GET OAF FROM TH
	STB	R1,BBUFER+MUOADP,R3,	:SET UP TH.OAFPRIME CONTAINTS
	LHL	R1,BBUFER+4,R10,	:GET SNF FROM TH
	STH	R1,BBUFER+MUSNF,R3,	:SET UP TH.SNF CONTAINTS
	SIS	R7,6			:DCF=PIU_LENGTH-6
	STH	R7,BBUFER+MUDCF,R3,	:SETUP DCF CONTAINTS
	J	R.MTC7			:JUMP TO HANDLE RH AND RU
:	FID TYPE 3 ----- -- RHN_ADDR=PTR_ADD(THN_ADDR,2)
:	                    CANONICAL_PTR->TH=FID3_TH,BY NAME
:	                    CANONICAL_PTR->MU.DCP=PIULNTH-2
R.MTC2
:	(R0) CONTAINS 1ST BYTE OF TH
	AIS	R6,$A02			:SET UP RHN_ADDR IN R6
	STB	R1,BBUFER+MUBIUF,R3,	:SET UP TH.DAF CONTAINTS
	J	R.MTC7			:JUMP TO HANDLE RH AND RU
:	FID TYPE 4--------- RHN_ADDR=PTR_ADD(THN_ADDR,26)
:	                    CANONICAL_PTR->TH=FID4_TH,BY NAME
R.MTC3
	AI	R6,$A26			:SET UP RHN_ADDR IN R6
	J	R.MTC7			:JUMP TO HANDLE RH AND RU
:	FID TYPE F----------CANONICAL_PTR->TH=FIDF_TH,BY NAME
:	                    RETURN
R.MTC5
	J	R.MTC8

:	R.MTC7	-CHECK BIU INDICATOR AND MOVE RH,RU INTO MU
:	---------------------------------------------------
R.MTC7
	LB	R1,BBUFER+MUBIUF,R3,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	R.MTC9			:JUMP,IF IT IS NOT SET (NOT BBIU)
	LB	R1,BBUFER,R6,		:GET 1ST BYTE OF RH
	STB	R1,BBUFER+MURHF1,R3,	:SET UP MURHF1 CONTAINTS
	LB	R1,BBUFER+1,R6,		:GET 2ND BYTE OF RH
	STB	R1,BBUFER+MURHF2,R3,	:SET UP MURHF2 CONTAINTS
	LB	R1,BBUFER+2,R6,		:GET 3RD BYTE OF RH
	STB	R1,BBUFER+MURHF3,R3,	:SET UP MURHF3 CONTAINTS
	AIS	R6,3			:RUN_ADDR=RHN_ADDR+3
	LB	R1,BBUFER+MURHF1,R3,	:GET CONTAINTS OF 1ST RH BYTE
:	NHI	R1,MU.SDI		:MSK OTHER BITS FOR SDI (11/16/84 MIA)
	THI	R1,MU.SDI		:SDI? (11/16/84 MIA)
	JE	R.MTC8			:JUMP,IF SENSE INDICATOR IS OFF
::IBM PC SENDS -RSP WITH BIU,-EIU WHICH IS A PROBLEM. COMPENSATE FOR
::THIS PROBLEM BY FORCING EIU IN MUCB.
	THI	R1,MU.RRI		:RSP? (11/16/84 MIA)
	JEFS	R.MTCX			:JUMP IF NOT (11/16/84 MIA)
	LB	R1,BBUFER+MUBIUF,R3,	:GET 1ST BYTE OF TH (11/16/84 MIA)
	OHI	R1,MU.EIU		:FORCE EIU (11/16/84 MIA)
	STB	R1,BBUFER+MUBIUF,R3,	:UPDATE 1ST BYTE OF TH (11/16/84 MIA)
R.MTCX	LB	R1,BBUFER,R6,		:GET 1ST BYTE OF SENSE DATA FROM RU
	LB	R2,BBUFER+1,R6,		:GET 2ND BYTE OF SENSE DATA FROM RU
	EXBR	R1,R1			:MOVE 1ST BYTE 8 BITS AHEAD
	OR	R1,R2			:COMBINE 1ST AND 2ND BYTE
	LB	R2,BBUFER+2,R6,		:GET 3RD BYTE OF SENSE DAT FROM RU
	LB	R4,BBUFER+3,R6,		:GET 4TH BYTE OF SENSE DAT FROM RU
	EXBR	R2,R2			:MOVE 3RD BYTE 8 BITS AHEAD
	OR	R2,R4			:COMBINE 3RD AND 4TH BYTE
	EXHR	R4,R1			:SHIFT 1ST,2ND BYTE
	OR	R4,R2			:COMBINE 1ST,2ND,3RD AND 4TH BYTE
	ST	R4,BBUFER+MURHSN,R3,	:UPDATE SENSE DATA IN MU
	AIS	R6,4			:RUN_ADDR=RUN_ADDR+4
R.MTC9
:	RUN_ADDR=RHN_ADDR
:	CANONICAL_PTR->RU=RUN(0:(CANONICAL_PTR->MU.DCF)-1)
R.MTC8
	BBSTOR	R6,BBUFER+MURUPT,R3,	:SET UP RU PTR IN MU
	LR	R10,R3			:SETUP MUCB PTR TO R10
	JR	R8			:RETURN

:	R.MUEX	-(CHANGE_MU_TO_EXR) THIS PROCEDURE CONVERTS THE CURRENT
:	MU TO AN EXCEPTION REQUEST BY CHANGING THE SDI,EBIUI,BBIUI BITS
:	AND THE SNC FIELD. THE RU IS TRUNCATED TO THREE BYTES IF IT IS
:	LONGER THAN THAT AND THE DCF FIELD IS SET TO THE LENGTH OF THE
:	RU (INCLUDING THE 4 BYTES FOR THE SENSE DATA)
:	PAGE B-2 ON FAPL
:	---------------------------------------------------------------
:	INPUT	-R10 (MUCB PTR) R0 (32-BIT FOR SNC)
:	OUTPUT	-THE CURRENT MU IS CHANGED TO AN EXCEPTION REQ.
:	LINK	-R5 IS LINK REGISTER
R.MUEX
	LB	R3,BBUFER+MUBIUF,R10,	:GET THAT BYTE
	OHI	R3,MU.BIU+MU.EIU
	STB	R3,BBUFER+MUBIUF,R10,	:STORE IT INTO MUCB
:	(07/24/84/CHS) WHEN CHANGE MU TO EXR, OAF AND DAF NOT AFFECTED.
:	LB	R3,SCBBLK+SCOTID,R9,	:GET PARTNER_ID FROM SCB
:	STB	R3,BBUFER+MUDADP,R10,	:SET DAFPRIME TO SCB.PARTNER_ID
:	LB	R3,SCBBLK+SCMYID,R9,	:GET SCB.THIS_ID
:	STB	R3,BBUFER+MUOADP,R10,	:SET OAFPRIME TO SCB.THIS_ID
	LB	R3,BBUFER+MURHF1,R10,	:GET THAT BYTE
	OHI	R3,MU.SDI		:SET SDI TO SD
	STB	R3,BBUFER+MURHF1,R10,	:STORE IT INTO MUCB

	STH	R0,BBUFER+MURHSN,R10,	:STORE SENSE DATA INTO MUCB(f03/12/16/87/db)

	JR	R5			:RETURN (7/24/84/CHS)
:	(7/24/84/CHS) THE EXR MAY PASS END-TO-END, IT NO NEED TO 
:		TRUNCATE THE RU
	LHL	R3,BBUFER+MUDCF,R10,	:GET DCF
	LR	R1,R3			:SAVE DCF
	SIS	R1,RHLENG		:GET DCF-RH_LENGTH
	CLHI	R1,3			:CHECK DCF-RH_LENGTH >3?
	JL	R.MUE1			:JUMP IF LESS
	LHI	R3,RHLENG		:SET RH_LENGTH
	AIS	R3,3			:RH_LENGTH+3
R.MUE1
	AIS	R3,SNLENG		:DCF=DCF+SENSE_LENGTH
	STH	R3,BBUFER+MUDCF,R10,	:STORE DCF INTO MUCB
	JR	R5



:	R.MUNR	-(CHANGE_MU_TO_NEG_RSP) THIS PROCEDURE CONVERTS THE CURRENT
:	MU TO A NEGATIVE RESPONSE  BY CHANGING THE RRI,RTI,SDI BITS
:	AND THE SNC FIELD. SDI IS SET TO INDICATE THAT NO SENSE DATA
:	IS INCLUDED. BCI AND ECI INDICATE THAT THE MU CONSTITUTES A 
:	SINGLE-ELEMENT CHAIN AND BBIUI AND EBIUI INDICATES THE RESPONSE
:	IS A WHOLE BIU. ALL OF BYTE 2 OF THE TH IS SET TO ZERO.
:	THE RU IS TRUNCATED TO THREE BYTES IF IT IS 
:	LONGER THAN THAT AND THE DCF FIELD IS SET TO THE LENGTH OF THE
:	RU (INCLUDING THE 4 BYTES FOR THE SENSE DATA)
:	PAGE B-3 ON FAPL
:	---------------------------------------------------------------
:	INPUT	-R10 (MUCB PTR) R0 (32-BIT FOR SNC)
:	OUTPUT	-THE CURRENT MU IS CHANGED TO A NEGATIVE RESPONSE.
:	LINK	-R5 IS LINK REGISTER
R.MUNR
	STM	R0,IZSAVG,,
	JAL	R8,R.DSRU,,		:CALL ROUTINE TO UPDATE RU
	LM	R0,IZSAVG,,		:GET PREVIOUS REGS BACK
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:LOAD BTU PTR FROM MUCB
	AIS	R3,FID2LN+RHLENG	:UPDATE RU PTR
	BBSTOR	R3,BBUFER+MURUPT,R10,	:STORE RU PTR IN MUCB
	LB	R3,BBUFER+MUBIUF,R10,	:GET THAT BYTE
	OHI	R3,MU.BIU+MU.EIU
	STB	R3,BBUFER+MUBIUF,R10,	:STORE IT INTO MUCB
	LB	R3,BBUFER+MUOADP,R10,	:GET OAFPRIME FROM MUCB
	LB	R1,BBUFER+MUDADP,R10,	:GET DAPF FROM MUCB
	STB	R3,BBUFER+MUDADP,R10,	:SET DAFPRIME TO SCB.PARTNER_ID
	STB	R1,BBUFER+MUOADP,R10,	:SET OAFPRIME TO SCB.THIS_ID
	LB	R3,BBUFER+MURHF1,R10,	:GET THAT BYTE
	OHI	R3,MU.SDI+MU.RRI+MU.BCI+MU.ECI
	STB	R3,BBUFER+MURHF1,R10,	:STORE IT INTO MUCB
	LB	R3,BBUFER+MURHF2,R10,	:GET THAT BYTE
	OHI	R3,MU.ERI		:SET RTI TO NEGATIVE
	STB	R3,BBUFER+MURHF2,R10,	:STORE IT INTO MUCB
	STH	R0,BBUFER+MURHSN,R10,	:STORE SENSE DATA INTO MUCB(f03/12/16/87/db)

	LB	R3,BBUFER+MURHF3,R10,	:GET THAT BYTE
:	SET BBI=<>BB,EBI=<>EB,CDI=<>CD,EDI=<>ED,PDI=<>PD,CSI=CODE0
	NHI	R3,@(MU.BBI+MU.EBI+MU.CDI+MU.EDI+MU.PDI+MU.CSI)
	STB	R3,BBUFER+MURHF3,R10,	:STORE IT INTO MUCB
					:(4/24/85/CHS, START)
:	LB	R1,BBUFER+MURHF1,R10,	:GET THE 1ST BYTE OF RH(8/28/86/CHS)
:	NHI	R1,MU.CTG		:SEE IF FMD(8/28/86/CHS)
:	JN	R.MUN0			:NO, SKIP(8/28/86/CHS)
	LB	R1,BBUFER+MURHF1,R10,	:SEE IF FI ON
	THI	R1,MU.FI		:
	JE	R.MUN0			:NO, SKIP
	BBLOAD	R3,BBUFER+MURUPT,R10,	:R3 = RU FIELD, SHIFT RQ CODE
	LB	R1,BBUFER+2,R3,		:
	STB	R1,BBUFER+6,R3,		:
	LB	R1,BBUFER+1,R3,		:
	STB	R1,BBUFER+5,R3,		:
	LB	R1,BBUFER+0,R3,		:
	STB	R1,BBUFER+4,R3,		:
R.MUN0					:(4/24/85/CHS, END)
	LHL	R3,BBUFER+MUDCF,R10,	:GET DCF INTO MUCB
	LR	R1,R3			:SAVE DCF
	SIS	R1,RHLENG		:GET DCF-RH_LENGTH
	CLHI	R1,3			:CHECK DCF-RH_LENGTH >3?
	JL	R.MUN1			:JUMP IF LESS
	LHI	R3,RHLENG		:SET RH_LENGTH
	AIS	R3,3			:RH_LENGTH+3
R.MUN1
	AIS	R3,SNLENG		:DCF=DCF+SENSE_LENGTH
	STH	R3,BBUFER+MUDCF,R10,	:STORE DCF INTO MUCB
	LHI	R3,SENT
	STB	R3,BBUFER+MUDIRE,R10,	:SET DIRECTION TO SEND
	JR	R5

:	R.MUPR	-(CHANGE_MU_TO_POS_RSP) THIS PROCEDURE CONVERTS THE CURRENT
:	MU TO A POSITIVE RESPONSE  BY CHANGING THE RRI,RTI BITS.
:	SDI IS SET TO INDICATE THAT NO SENSE DATA
:	IS INCLUDED. BCI AND ECI INDICATE THAT THE MU CONSTITUTES A 
:	SINGLE-ELEMENT CHAIN AND BBIUI AND EBIUI INDICATES THE RESPONSE
:	IS A WHOLE BIU. ALL OF BYTE 2 OF THE TH IS SET TO ZERO.
:	IF INPUT SPECIFY 'TRUNCATION'.THE DCF IS UPDATED
:	PAGE B-4 ON FAPL
:	---------------------------------------------------------------
:	INPUT	-R10 (MUCB PTR) R0 (TRUNCATION INDICATOR)
:		R9 (SCB_PTR)
:	OUTPUT	-THE CURRENT MU IS CHANGED TO A POSITIVE RESPONSE.
:	LINK	-R5 IS LINK REGISTER
R.MUPR
	STM	R0,IZSAVG,,
	JAL	R8,R.DSRU,,		:CALL ROUTINE TO UPDATE RU
	LM	R0,IZSAVG,,		:GET PREVIOUS REGS BACK
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:LOAD BTU PTR FROM MUCB
	AIS	R3,FID2LN+RHLENG	:UPDATE RU PTR
	BBSTOR	R3,BBUFER+MURUPT,R10,	:STORE RU PTR IN MUCB
	LB	R3,BBUFER+MUBIUF,R10,	:GET THAT BYTE
	OHI	R3,MU.BIU+MU.EIU
	STB	R3,BBUFER+MUBIUF,R10,	:STORE IT INTO MUCB
	LB	R3,SCBBLK+SCOTID,R9,	:GET PARTNER_ID FROM SCB
	STB	R3,BBUFER+MUDADP,R10,	:SET DAFPRIME TO SCB.PARTNER_ID
	LB	R3,SCBBLK+SCMYID,R9,	:GET SCB.THIS_ID
	STB	R3,BBUFER+MUOADP,R10,	:SET OAFPRIME TO SCB.THIS_ID
	LB	R3,BBUFER+MURHF1,R10,	:GET THAT BYTE
	NHI	R3,@MU.SDI		:SET SDI TO <>SD
	OHI	R3,MU.RRI+MU.BCI+MU.ECI
	STB	R3,BBUFER+MURHF1,R10,	:STORE IT INTO MUCB
	LB	R3,BBUFER+MURHF2,R10,	:GET THAT BYTE
	NHI	R3,@MU.ERI		:SET RTI TO POSITIVE
	STB	R3,BBUFER+MURHF2,R10,	:STORE IT INTO MUCB
	LB	R3,BBUFER+MURHF3,R10,	:GET THAT BYTE
:	SET BBI=<>BB,EBI=<>EB,CDI=<>CD,EDI=<>ED,PDI=<>PD,CSI=CODE0
	NHI	R3,@(MU.BBI+MU.EBI+MU.CDI+MU.EDI+MU.PDI+MU.CSI)
	STB	R3,BBUFER+MURHF3,R10,	:STORE IT INTO MUCB
	LHI	R3,SENT
	STB	R3,BBUFER+MUDIRE,R10,	:SET DIRECTION TO SEND
	CLHI	R0,TRUNCA		:IS IT NEED TRUNCATE?
	JNR	R5			:RETURN,IF NOT TRUNCATE
	LHI	R3,RHLENG		:GET RH_LENG
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	LR	R4,R0
	NHI	R0,MU.CTG		:MASK FOR RU_CTGY
	JN	R.MUP1			:JUMP,IF IT IS NOT FMD
:	RU_CTGY=(FMD)
:	--------------
	NHI	R4,MU.FI		:MASK OFF OTHER BITS
	JE	R.MUP2			:JUMP,IF FI<>NSH
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU PTR
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,NSH101		:IS NS HEADER 1ST BYTE='01'?
	JE	R.MUP0			:JUMP,IF IT IS 01
	CLHI	R0,NSH141		:IS NS HEADER 1ST BYTE='41'?
	JE	R.MUP0			:JUMP,IF IT IS 41
	CLHI	R0,NSH181		:IS NS HEADER 1ST BYTE='81'
	JN	R.MUP2			:JUMP,IF IT IS NOT 81
R.MUP0
	LB	R1,SCBBLK+SCSSTY,R9,	:GET SCB.TYPE_OF_SESSION
	CLHI	R1,LULU			:IS IT LU_LU SESSION?
:	JNFS	R.MUP2			:JUMP,IF IT IS NOT LU_LU (02/05/87 YLH)
	JEFS	R.MUP2			:JUMP,IF IT IS LU_LU (02/05/87 YLH)
	AIS	R3,3			:SET DCF=RH_LENGTH+3
	JFS	R.MUP2
:	RU_CTGY=(NC | SC | DFC)
:	------------------------
R.MUP1
	AIS	R3,1			:DCF=RH_LENGTH+1
R.MUP2
	STH	R3,BBUFER+MUDCF,R10,	:STORE NEW DCF VALUE
	JR	R5

:	R.DSM1	-ROUTINE TO DISCARD MU DATA
:	--------------------------------------------
:	INPUT	-R10 (MUCB PTR)
:	LINK	-R8
R.DSM1
:	DISCARD MUCB PTR
:	--------------------------------------
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU PTR
	JLE	R.CRAS,,		:CRASH
	JAL	R5,R.PBBC,,		:DISCARD BTU DATA
	LIS	R3,0
	BBSTOR	R3,BBUFER+MUCBTU,R10,	:CLEAR BTU PTR
	BBSTOR	R3,BBUFER+MURUPT,R10,	:CLEAR RU PTR
	JR	R8			:RETURN

:	R.DSMU	-ROUTINE TO DISCARD MU DATA AND MUCB
:	--------------------------------------------
:	INPUT	-R10 (MUCB PTR)
:	LINK	-R8
R.DSMU
:	DISCARD MUCB PTR AND INPUT DATA FRAME
:	--------------------------------------
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU PTR
	JLE	R.CRAS,,		:CRASH
	LB	R2,BBUFER+MUDIRE,R10,	:SET UP MU.DIRECTION BYTE
	JN	R.DSM2			:JUMP,IF RECEIVING
	JAL	R5,R.PBBC,,		:DISCARD BTU DATA
	LR	R3,R10			:SET MUCB PTR FOR R3
	JAL	R4,PBB,,		:DISCARD MUCB PTR
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	JR	R8			:RETURN
:	ROUTINE TO UPDATE RECEIVING BUFFER COUNT
:	----------------------------------------
R.DSM2
	JAL	R5,R.PBRC,,		:DISCARD BTU DATA
	LR	R3,R10			:SET MUCB PTR FOR R3
	JAL	R4,PBB,,		:DISCARD MUCB PTR
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	JR	R8			:RETURN

:	R.DSRU	-ROUTINE TO DISCARD MU DATA BUT KEEP 1ST BB
:	--------------------------------------------
:	INPUT	-R10 (MUCB PTR)
:	LINK	-R8
R.DSRU
:	DISCARD INPUT DATA FRAME EXCEPT 1ST BB
:	--------------------------------------
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU PTR
	JLE	R.CRAS,,		:CRASH
	LB	R2,BBUFER+MUDIRE,R10,	:SET UP MU.DIRECTION BYTE
	JN	R.DSR2			:JUMP,IF RECEIVING
	BBLOAD	R4,BBUFER+MUCBTU,R10,	:GET BTU PTR
	BBLOAD	R3,BBUFER+BBFLSZ-BBFPSZ,R4, :DISCARD FROM 2ND BB
	LIS	R5,0
	BBSTOR	R5,BBUFER+BBFLSZ-BBFPSZ,R4, :CLEAR BB LINK
	JAL	R5,R.PBBC,,		:DISCARD BTU DATA (XMT)
	JR	R8			:RETURN
:	ROUTINE TO UPDATE RECEIVING BUFFER COUNT
:	----------------------------------------
R.DSR2
	JAL	R4,R.PBR,,		:INCREASE RCV BB CNT
	JAL	R4,R.GBB,,		:DECREASE XMT BB CNT
	BBLOAD	R4,BBUFER+MUCBTU,R10,	:GET BTU PTR
	BBLOAD	R3,BBUFER+BBFLSZ-BBFPSZ,R4, :DISCARD FROM 2ND BB
	LIS	R5,0
	BBSTOR	R5,BBUFER+BBFLSZ-BBFPSZ,R4, :CLEAR BB LINK
	JAL	R5,R.PBRC,,		:DISCARD BTU DATA (RCV)
	JR	R8			:RETURN

:	R.CTRH	-ROUTINE TO SETUP TH & RH FOR USER DATA
:	-----------------------------------------------
:	INPUT	-R10 (MU_PTR) R0 (DESTINATION ADDRESS) R1 (ORIGINATION)
:	LINK	-R8
R.CTRH
	JAL	R4,GBB,,		:GET A BUFFERLET
	J	NOBUF			:FAILURE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	BBSTOR	R3,BBUFER+MUCBTU,R10,	:STORE BTU PTR IN MUCB
	STB	R0,BBUFER+MUDADP,R10,	:STORE(DAF) INTO MUCB
	STB	R0,2+BBUFER,R3,		:STORE INTO BUFFER AREA
	STB	R1,BBUFER+MUOADP,R10,	:STORE(OAF) INTO MUCB
	STB	R1,3+BBUFER,R3,		:STORE INTO BUFFER AREA
	LIS	R0,FID2			:GET FID TYPE
	SLHLS	R0,AD.FID		:GET PROPER POSITION FOR FID
	OHI	R0,MU.BIU+MU.EIU+MU.EFI
	STB	R0,BBUFER+MUBIUF,R10,	:STORE INTO MUCB
	STB	R0,0+BBUFER,R3,		:STORE INTO BUFFER AREA
	LIS	R0,0			:SET INIT VALUE
	STB	R0,1+BBUFER,R3,		:STORE INTO BUFFER AREA
	STH	R0,BBUFER+MUSNF,R10,	:STORE INTO MUCB
	STH	R0,4+BBUFER,R3,		:STORE INTO BUFFER AREA
	AIS	R3,6			:SETUP PTR TO BEG. OF RH
	LHI	R0,MU.CTG+MU.FI+MU.BCI+MU.ECI
	STB	R0,BBUFER+MURHF1,R10,	:STORE INTO MUCB
	STB	R0,0+BBUFER,R3,		:STORE INTO BUFFER AREA
	LIS	R0,0			:SET INIT VALUE
	OHI	R0,MU.DR1		:SETUP DR1I
	STB	R0,BBUFER+MURHF2,R10,	:STORE INTO MUCB
	STB	R0,1+BBUFER,R3,		:STORE INTO BUFFER AREA
	LIS	R0,0			:SET INIT VALUE
	STB	R0,BBUFER+MURHF3,R10,	:STORE INTO MUCB
	STB	R0,2+BBUFER,R3,		:STORE INTO BUFFER AREA
	AIS	R3,3			:SET PTR TO BEG. OF RU
	BBSTOR	R3,BBUFER+MURUPT,R10,	:STORE RU PTR IN MUCB
	JR	R8			:RETURN

:	R.CRUU	-ROUTINE TO CREATE RU AND MOVE RU_PTR INTO MUCB
:	-------------------------------------------------------
:	INPUT	:R14 (1ST LEVEL LINK) R10 (MU_PTR) R2 (LENGTH OF RU)
:		 R8 (PTR OF RU DATA) R3 (RU_PTR IN MUCB)
:	LINK	:R7 (LINK)
R.CRUU
	ST	R7,RGSAV7,,
	LR	R4,R2			:GET RU LENGTH
	AIS	R4,3			:GET RH+RU LENGTH FOR FID2
	STH	R4,BBUFER+MUDCF,R10,	:SAVE BIU LENGTH
	LR	R13,R3			:COPY BUFFERLET BASE ADDRESS
:	NOW COPY CHARACTERS TO BUFFERLET(S)
:	========================================
	LHI	R12,-BBFLSZ+BBFPSZ-1	:INIT BUFFERLET INDEX
R.CRU2
	SIS	R2,1			:DECREMENT LENGTH
	JL	R.CRU4			:YES, SKIP
R.CRU3	AIS	R8,1			:INCREMENT POINTER TO NEXT CHARACTER
	LB	R4,0,R8,		:GET A CHARACTER
	AIS	R12,1			:INCREMENT BUFFERLET INDEX
:					:STORE CHARACTER IN BUFFERLET
	STB	R4,BBUFER+BBFLSZ-BBFPSZ,R12,R13
	JN	R.CRU2			:BUFFERLET DID NOT OVERFLOW...LOOP
	JAL	R6,GBBMOR,,		:GET ANOTHER BUFFERLET ROUTINE
	J	R.CRU2			:LOOP
R.CRU4
	LHI	R1,SENT			:SET MU DIRECTION TO SEND
	STB	R1,BBUFER+MUDIRE,R10,	:UPDATE MUCB
	L	R7,RGSAV7,,
	JR	R7			:RETURN

:	GBBMOR	-ROUTINE TO GET NEXT BUFFERLET FOR BIG BUFFERS
:		 DESIRED CONDITION
:	--------------------------------------------------------------
GBBMOR
	ST	R6,RGSAV6,,
	JAL	R4,GBB,,		:GET BIG BUFFERLET
	J	NOBUF			:CRASH,NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LHL	R0,BBUFER+BBFLSZ-BBFPSZ,R13,
	BBSTOR	R3,BBUFER+BBFLSZ-BBFPSZ,R13,
	LR	R13,R3
	LHI	R12,-BBFLSZ+BBFPSZ
	STH	R0,BBUFER+BBFLSZ-BBFPSZ,R12,R13
	L	R6,RGSAV6,,
	JR	R6			:RETURN

:	R.GBB	-ROUTINE TO DECREASE BIG BUFFERLET COUNT
:	---------------------------------------------------
:	INPUT	-RNODE
:	LINK	-R4
:	OUTPUT	-
:	WORKING	-R4,R0
R.GBB
	ST	R4,GBB4SV,,		:SAVE RETURN ADDRESS
	LHL	R4,PUCPTR,RNODE,RNODE	:GET PTR TO PUCTAB
	LCS	R6,1			:COUNT TO BE DECREASED
	AHM	R6,PUCTAB+PUXBUS,R4,	:DECREASE BUFFER CNT IN PUC
	LHL	R4,PUCTAB+PUCLNC,R4,	:GET PTR TO LNCTAB
	AHM	R6,LNCTAB+LNXBUS,R4,	:DECREASE BUFFER CNT IN LNC
	L	R4,GBB4SV,,		:GET RETURN ADDRESS
	JR	R4			:RETURN

:	R.GBR	-ROUTINE TO DECREASE BIG BUFFERLET COUNT (RECEIVE)
:	---------------------------------------------------
:	INPUT	-RNODE
:	LINK	-R4
:	OUTPUT	-
:	WORKING	-R4,R0
R.GBR
	ST	R4,GBB4SV,,		:SAVE RETURN ADDRESS
	LHL	R4,PUCPTR,RNODE,RNODE	:GET PTR TO PUCTAB
	LCS	R6,1			:COUNT TO BE INCREASED
	AHM	R6,PUCTAB+PURBUS,R4,	:DECREASE BUFFER CNT IN PUC
	LHL	R4,PUCTAB+PUCLNC,R4,	:GET PTR TO LNCTAB
	AHM	R6,LNCTAB+LNRBUS,R4,	:DECREASE BUFFER CNT IN LNC
	L	R4,GBB4SV,,		:GET RETURN ADDRESS
	JR	R4			:RETURN

:	R.PBR	-ROUTINE TO INCREASE BIG BUFFERLET COUNT (RECEIVE)
:	---------------------------------------------------
:	INPUT	-RNODE
:	LINK	-R4
:	OUTPUT	-
:	WORKING	-R4,R0
R.PBR
	ST	R4,GBB4SV,,		:SAVE RETURN ADDRESS
	LHL	R4,PUCPTR,RNODE,RNODE	:GET PTR TO PUCTAB
	LIS	R6,1			:COUNT TO BE INCREASED
	AHM	R6,PUCTAB+PURBUS,R4,	:INCREASE BUFFER CNT IN PUC
	LHL	R4,PUCTAB+PUCLNC,R4,	:GET PTR TO LNCTAB
	AHM	R6,LNCTAB+LNRBUS,R4,	:INCREASE BUFFER CNT IN LNC
	L	R4,GBB4SV,,		:GET RETURN ADDRESS
	JR	R4			:RETURN

:	R.PBRC	-ROUTINE TO DISCARD BBUFER CHAIN AND UPDATE BBUFER 
:	CNT (RECEIVE)
:	------------------------------------------------------
:	INPUT	R3 (BBUFER PTR)
:	LINK	R5
:	WORKING	R4,R10,
R.PBRC
	LR	R3,R3			:CHECK BBUFER PTR
	JER	R5			:NOT SETUP ,RETURN
R.PBR0
	BBLOAD	R2,BBUFER+BBFLSZ-BBFPSZ,R3,
	JAL	R4,PBB,,
	JAL	R4,R.PBR,,
	LR	R3,R2			:GET NEXT BBUFER PTR
	JN	R.PBR0			:CONTINUE,IF  NEED
	JR	R5			:RETURN

:	R.PBB	-ROUTINE TO DECREASE BIG BUFFERLET COUNT
:	---------------------------------------------------
:	INPUT	-RNODE
:	LINK	-R4
:	OUTPUT	-
:	WORKING	-R4,R0
R.PBB
	ST	R4,GBB4SV,,		:SAVE RETURN ADDRESS
	LHL	R4,PUCPTR,RNODE,RNODE	:GET PTR TO PUCTAB
	LIS	R6,1			:COUNT TO BE INCREASED
	AHM	R6,PUCTAB+PUXBUS,R4,	:INCREASE BUFFER CNT IN PUC
	LHL	R4,PUCTAB+PUCLNC,R4,	:GET PTR TO LNCTAB
	AHM	R6,LNCTAB+LNXBUS,R4,	:INCREASE BUFFER CNT IN LNC
	L	R4,GBB4SV,,		:GET RETURN ADDRESS
	JR	R4			:RETURN

:	R.PBBC	-ROUTINE TO DISCARD BBUFER CHAIN AND UPDATE BBUFER 
:	CNT
:	------------------------------------------------------
:	INPUT	R3 (BBUFER PTR)
:	LINK	R5
:	WORKING	R4,R10,
R.PBBC
	LR	R3,R3			:CHECK BBUFER PTR
	JER	R5			:NOT SETUP ,RETURN
R.PBB0
	BBLOAD	R2,BBUFER+BBFLSZ-BBFPSZ,R3,
	JAL	R4,PBB,,
	JAL	R4,R.PBB,,
	LR	R3,R2			:GET NEXT BBUFER PTR
	JN	R.PBB0			:CONTINUE,IF  NEED
	JR	R5			:RETURN

	SUBTTL	UTILITY ROUTINES FOR THE MESSAGE CHECKING

:	R.LNRS	-(LOCATE_NODE_RESOURCE) SEARCHS THE NRCB_LIST TO FIND THE
:	ENTRY CORRESPONDING TO THE ADDRESS PASSED IN THE INPUT (R0). IT
:	RETURNS THE POINTER TO THE RESOURCE TO THE INVOKING PROCEDURE.
:	PAGE B-14 ON FAPL
:	-----------------------------------------------------------------
:	THE USAGE OF REGISTERS --
:	INPUT	-R0 (RESOURCE_ADDR)
:	OUTPUT	-R15 (NRCB)
:	LINK	-R5
R.LNRS
	JR	R5			:RETURN

:	R.RQD	-(RQD) THIS PROCEDURE DETERMINES WHETHER THE MESSAGE
:	IDENTIFIED BY MU_PTR REQUESTS THAT A DEFINITE RESPONSE BE MADE.
:	PAGE B-21 ON FAPL
:	-----------------------------------------------------------
:	INPUT	-R10 (MUCB PTR)
:	OUTPUT	-SKIP RETURN IF OK,ELSE NORMAL RETURN
:	LINK	-R7 IS LINK REGISTER
R.RQD
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE
	NHI	R0,MU.RRI		:CHECK RRI BIT IS RQ OR NOT
	JNR	R7			:JUMP IF IT IS NOT RQ
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE FROM MUCB
	THI	R0,MU.DR1		:CHECK DR1I BIT
	JN	R.RQD0			:JUMP IF IT IS DR1
	THI	R0,MU.DR2		:CHECK DR2I BIT
	JER	R7			:JUMP IF IT IS NOT DR2
R.RQD0
	THI	R0,MU.ERI		:CHECK ERI BIT
	JNR	R7			:JUMP IF IT IS ER
	J	4,R7			:SKIP RETURN WHEN IT IS OK

:	R.RQE	-(RQE) THIS PROCEDURE DETERMINES WHETHER THE MESSAGE
:	IDENTIFIED BY MU_PTR IS AN EXCEPTION REQUEST.
:	PAGE B-21 ON FAPL
:	-----------------------------------------------------------
:	INPUT	-R10 (MUCB PTR)
:	OUTPUT	-SKIP RETURN IF OK,ELSE NORMAL RETURN
:	LINK	-R7 IS LINK REGISTER
R.RQE
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE
	NHI	R0,MU.RRI		:CHECK RRI BIT IS RQ OR NOT
	JN	R.RQE1			:JUMP IF IT IS NOT RQ
R.RQE0
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE FROM MUCB
	NHI	R0,MU.ERI		:CHECK ERI BIT
	JE	R.RQE1			:JUMP IF IT IS NOT ER
	J	4,R7			:SKIP RETURN WHEN IT IS OK
R.RQE1
	JR	R7			:NORMAL RETURN WHEN NOT OK

:	R.RQN	-(RQN) THIS PROCEDURE DETERMINES WHETHER THE MESSAGE
:	IDENTIFIED BY MU_PTR REQUESTS THAT NO RESPONSE BE MADE.
:	PAGE B-22 ON FAPL
:	-----------------------------------------------------------
:	INPUT	-R10 (MUCB PTR)
:	OUTPUT	-SKIP RETURN IF OK,ELSE NORMAL RETURN
:	LINK	-R7 IS LINK REGISTER
R.RQN
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE
	NHI	R0,MU.RRI		:CHECK RRI BIT IS RQ OR NOT
	JNR	R7			:JUMP IF IT IS NOT RQ
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE FROM MUCB
	THI	R0,MU.DR1		:CHECK DR1I BIT
	JNR	R7			:JUMP IF IT IS DR1
	THI	R0,MU.DR2		:CHECK DR2I BIT
	JNR	R7			:JUMP IF IT IS DR2
	THI	R0,MU.ERI		:CHECK ERI BIT
	JNR	R7			:JUMP IF IT IS ER
	J	4,R7			:SKIP RETURN WHEN IT IS OK

:	R.EFRR	-THIS ROUTINE CHECKS THE EFI AND RRI INDICATORS IN
:	MUCB. AND RETURN THE COMBINATION OF EFI AND RRI IN R1.
:	-----------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	:R10 (MUCB) 
:	OUTPUT	:R1 (THE COMBINATION OF EFI AND RRI)
:	LINK	:R4
:	WORKING	:R2,R3
R.EFRR
	LB	R3,BBUFER+MUBIUF,R10,	:GET MUBIUF BYTE
	NHI	R3,MU.EFI		:MASK OFF OTHER BITS
	JN	R.EFR0			:JUMP IF EFI=EXPEDITED
	LB	R3,BBUFER+MURHF1,R10,	:GET MURHF1 BYTE
	NHI	R3,MU.RRI		:MASK OFF OTHER BITS
	JN	R.EFR1			:JUMP IF IT IS RSP
:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
	LIS	R1,NORRQ		:SET RETURN CODE TO NORMAL&RQ
	JR	R4			:RETURN
:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
R.EFR1
	LIS	R1,NORRSP		:SET RETURN CODE TO NORMAL&RSP
	JR	R4			:RETURN

R.EFR0
	LB	R3,BBUFER+MURHF1,R10,	:GET MURHF1 BYTE
	NHI	R3,MU.RRI		:MASK OFF OTHER BITS
	JN	R.EFR2			:JUMP IF IT IS RSP
:	EFI=EXPEDITED & RRI=RQ
:	-------------------------------------
	LIS	R1,EXPRQ		:SET RETURN CODE TO EXPEDITED&RQ
	JR	R4			:RETURN
R.EFR2
:	EFI=EXPEDITED & RRI=RSP
:	---------------
	LIS	R1,EXPRSP		:SET RETURN CODE TO EXPEDITED&RSP
	JR	R4			:RETURN

	SUBTTL	SCB RELATED ROUTINES (SCAN SCB_LIST FOR DESIRED SCB...)

:	*****INITIALIZE SCB CONTENTS FOR DESIRED SCB*****
:	INITIALIZE SESSION CONTROL BLOCK CONTENTS
:	-----------------------------------------
:	INPUT	-R9 (SCB_PTR)
:	LINK	-R4
V.IZSC
	STM	R0,IZSAVG,,		:SAVE ALL REGISTERS
	LIS	R1,0			:INITIAL VALUE
	LHI	R3,SCLENG-1		:LENGTH OF SCBBLK
V.IZS1
	STB	R1,SCBBLK,R3,R9		:INIT THAT BYTE
	SIS	R3,1			:GOT TO NEXT LOCATION
	CLHI	R3,SCBREL		:IS TIME TO FINISH
	JG	V.IZS1			:NO,CONTINUE
:	FOR CT_RCV_RQ_EXP
:	JAL	R8,R.CREN,,		:CALL ROUTINE
:	FOR CT_RCV_RQ_NORM
:	JAL	R8,R.CRNN,,		:CALL ROUTINE
:	FOR CT_SEND_RQ_EXP
:	JAL	R8,R.CSEN,,		:CALL ROUTINE
:	FOR CT_SEND_RQ_NORM
:	JAL	R8,R.CSNN,,		:CALL ROUTINE
:	JAL	R8,R.TDQN,,		:INIT TC_TO_DFC_QUEUE
:	FOR TCCB IN CURRENT SCB
:	--------------------------
	LHL	R15,SCBBLK+SCTCCB,R9,	:GET TCCB PTR
	LIS	R1,0			:INITIAL VALUE
	LHI	R3,TCLENG-1		:LENGTH OF TCBBLK
V.IZS2
	STB	R1,TCBBLK,R3,R15	:INIT THAT BYTE
	SIS	R3,1			:GOT TO NEXT LOCATION
	JGE	V.IZS2			:NO,CONTINUE
:	JAL	R8,R.TPQN,,		:INIT TCCB.Q_PAC
	LM	R0,IZSAVG,,		:GET BACK ALL REGISTERS
	JR	R4			:RETURN

:	*****SCAN SCB_LIST FOR DESIRED SCB*****
:	V.SCSC	-SCAN SCB_LIST ROUTINE
:	-------------------------------------------------
:	THE USAGE OF REGISTERS --
:	INPUT	-R3 (COMAPRE TO PARTNER_ID) R4 (COMAPRE TO THIS_ID)
:		-R10 (MUCB_PTR) R13, RNODE
:	OUTPUT	-R9 (SCB_PTR)
:	LINK	-R7
V.SCSC
	LB	R0,NCBBLK+NDDEVN,R13,	:GET DEVICE # FROM NCB
	SRHLS	R0,4
	STB	R0,LSTTIM,,		:FOR SCB SCANE LOOP
	LIS	R1,0
	STB	R1,LSTEND,,		:INIT FOR 1ST SCB_LST IND.
V.SCS7
	L	R1,NCBBLK+NDSCLS,R1,R13	:GET NEW SCB_LIST 
	ST	R1,LSTSAV,,		:SAVE SCB_LIST IN SAVE AREA
V.SCS1
	L	R1,LSTSAV,,		:GET SCB_LIST SAVE DATA
	JFFO	R1,V.SCS5		:JUMP,ON FINDING SCB ASSIGNED
	J	V.SCS0			:SCAN END OF SCB_LIST
V.SCS5
:	(4/21/86/CHS)
:	IF FWSCB IS 1, SCBPTR'S ARE IN FULL-WORD
	IF	FWSCB
	SLHLS	RNODE,1			:MAKE FW INDEX
	L	R9,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	SRHLS	RNODE,1
	ELSE
	LHL	R9,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	EI	(FWSCB)
	RBT	R2,LSTSAV,,		:RESET CURRENT SCB INDEX IN SAVE AREA
	LHI	R8,SCLENG		:GET LENGTH OF SCB
	LB	R0,LSTEND,,
	SLHLS	R0,5
	AR	R2,R0
	LR	R0,R2
	MHR	R0,R8
	AR	R9,R0
	CLB	R3,SCBBLK+SCOTID,R9,	:COMAPRE <> TO PARTNER_ID
	JN	V.SCS1			:JUMP,IF R3 ID<>PARTNER_ID
	CLB	R4,SCBBLK+SCMYID,R9,	:COMAPRE <> TO THIS_ID
	JN	V.SCS1			:JUMP,IF R4 ID <> THIS_ID
	JR	R7			:RETURN

V.SCS0
	LB	R1,LSTEND,,		:GET CURRENT STOP POINT
	CLB	R1,LSTTIM,,		:IS TIME FOR ENDING
	JGE	V.SCS6			:YES,SET SCB_PTR=NULL
	AIS	R1,1
	STB	R1,LSTEND,,		:SAVE NEW STOP POINT
	SLHLS	R1,2
	J	V.SCS7			:JUMP FOR SCB_LST SCANE
V.SCS6
	LCS	R9,1			:FAIL TO FIND DESIRED SCB
	JR	R7			:RETURN

:	*****DISCARD PARTICULAR SCB FROM SCB_LIST*****
:	V.SCDS	-DISCARD SCB_PTR
:	----------------------------
:	INPUT	R9 (SCB_PTR) R13 (NCB_PTR)
:	LINK	R8
V.SCDS
	ST	R8,RGSAVC,,		:SAVE RETURN ADDRESS
	ST	R15,RGSAVF,,		:SAVE REGISTER 15
	LHL	R15,SCBBLK+SCTCCB,R9,	:GET TCCB PTR
	JAL	R8,R.TPQP,,		:PURGE TCCB.Q_PAC
	LHL	R6,TCBBLK+TCQSPG,R15,	:(7/24/84/CHS)
	JEFS	V.SCDH			:IF CLEARED, SKIP (7/24/84/CHS)
	JAL	R4,RELCL,,		:CLEAR CMD (7/24/84/CHS)
	LIS	R0,0			:(7/24/84/CHS)
	STH	R0,TCBBLK+TCQSPG,R15,	:CLEAR TCQSPG (7/24/84/CHS)
	STH	R0,TCBBLK+TCQSPR,R15,	:CLEAR TCQSPR (7/24/84/CHS)
V.SCDH					:(7/24/84/CHS)
	JAL	R8,R.TDQP,,		:PURGE TC_TO_DFC_QUEUE
	LHL	R6,SCBBLK+SCQTDG,R9,	:(7/24/84/CHS)
	JEFS	V.SCDA			:IF CLEARED, SKIP (7/24/84/CHS)
	JAL	R4,RELCL,,		:CLEAR CMD (7/24/84/CHS)
	LIS	R0,0			:(7/24/84/CHS)
	STH	R0,SCBBLK+SCQTDG,R9,	:CLEAR SCQTDG (7/24/84/CHS)
	STH	R0,SCBBLK+SCQTDR,R9,	:CLEAR SCQTDR (7/24/84/CHS)
V.SCDA					:(7/24/84/CHS)
	JAL	R8,R.CREP,,		:PURGE CT_RCV_RQ_EXP
	LHL	R6,SCBBLK+SCTREG,R9,	:(7/24/84/CHS)
	JEFS	V.SCDW			:IF CLEARED, SKIP (7/24/84/CHS)
	JAL	R4,RELCL,,		:CLEAR CMD (7/24/84/CHS)
	LIS	R0,0			:(7/24/84/CHS)
	STH	R0,SCBBLK+SCTREG,R9,	:CLEAR SCTREG (7/24/84/CHS)
	STH	R0,SCBBLK+SCTRER,R9,	:CLEAR SCTRER (7/24/84/CHS)
V.SCDW					:(7/24/84/CHS)
	JAL	R8,R.CRNP,,		:PURGE CT_RCV_RQ_NORM
	LHL	R6,SCBBLK+SCTRNG,R9,	:(7/24/84/CHS)
	JEFS	V.SCDX			:IF CLEARED, SKIP (7/24/84/CHS)
	JAL	R4,RELCL,,		:CLEAR CMD (7/24/84/CHS)
	LIS	R0,0			:(7/24/84/CHS)
	STH	R0,SCBBLK+SCTRNG,R9,	:CLEAR SCTRNG (7/24/84/CHS)
	STH	R0,SCBBLK+SCTRNR,R9,	:CLEAR SCTRNR (7/24/84/CHS)
V.SCDX					:(7/24/84/CHS)
	JAL	R8,R.CSEP,,		:PURGE CT_SEND_RQ_EXP
	LHL	R6,SCBBLK+SCTSEG,R9,	:(7/24/84/CHS)
	JEFS	V.SCDY			:IF CLEARED, SKIP (7/24/84/CHS)
	JAL	R4,RELCL,,		:CLEAR CMD (7/24/84/CHS)
	LIS	R0,0			:(7/24/84/CHS)
	STH	R0,SCBBLK+SCTSEG,R9,	:CLEAR SCTSEG (7/24/84/CHS)
	STH	R0,SCBBLK+SCTSER,R9,	:CLEAR SCTSER (7/24/84/CHS)
V.SCDY					:(7/24/84/CHS)
	JAL	R8,R.CSNP,,		:PURGE CT_SEND_RQ_NORM
	LHL	R6,SCBBLK+SCTSNG,R9,	:(7/24/84/CHS)
	JEFS	V.SCDZ			:IF CLEARED, SKIP (7/24/84/CHS)
	JAL	R4,RELCL,,		:CLEAR CMD (7/24/84/CHS)
	LIS	R0,0			:(7/24/84/CHS)
	STH	R0,SCBBLK+SCTSNG,R9,	:CLEAR SCTSNG (7/24/84/CHS)
	STH	R0,SCBBLK+SCTSNR,R9,	:CLEAR SCTSNR (7/24/84/CHS)
V.SCDZ					:(7/24/84/CHS)
	LIS	R5,0
	LB	R1,SCBBLK+SCBREL,R9,	:GET REL. # OF THIS SCB
	LB	R0,NCBBLK+NDDEVN,R13,	:GET DEVICE # FROM NCB
	SLHLS	R0,2
	CR	R1,R0
	JG	R.CRAS,,		:CRASH,IF OUT OF RANGE(09/09/86/CHS) RX3
	CLHI	R1,FWRD32		:CHECK SCB RANGE
	JGE	V.SCD0			:JUMP,IF GE. 32
	RBT	R1,NCBBLK+NDSCLS,R5,R13,:RESET SCB_LST FLAG FOR FREE
	J	V.SCD1
V.SCD0
	AIS	R5,4			:ADD FOR NEXT FULLWORD
	CLHI	R1,FWRD32*2		:IS IT IN NEXT FULLWORD RANGE?
	JGE	V.SCD2			:YES,JUMP
	SHI	R1,FWRD32		:TAKE 1ST FULLWORD OFF
	RBT	R1,NCBBLK+NDSCLS,R5,R13,:RESET SCB_LST FLAG
	J	V.SCD1
V.SCD2
	AIS	R5,4			:ADD FOR NEXT FULLWORD
	CLHI	R1,FWRD32*3
	JGE	R.CRAS,,		:OUT OF RANGE,CRASH(09/09/86/CHS) RX3
	SHI	R1,FWRD32*2		:TAKE 2ND FULLWORD OFF
	RBT	R1,NCBBLK+NDSCLS,R5,R13,:RESET SCB_LST FLAG
V.SCD1
:	DO WE HAVE TO CLEANUP SCB?
:	--------------------------
	JAL	R4,V.IZSC,,		:CALL ROUTINE TO INIT SCB
	L	R15,RGSAVF,,		:GET BACK REGISTER 15
	L	R8,RGSAVC,,		:GET RETURN ADDRESSBACK
	JR	R8			:RETURN

:	*****SCAN SCB_LIST AND GET ANY ASSIGNED SCB*****
:	V.SLST	-ROUTINE TO GET ANY ONE ASSIGNED SCB_PTR
:	FOR RESET HIERARCHICAL PURPOSE
:	------------------------------------------------
:	INPUT	-RNODE,R13 (NCBBLK)
:	OUTPUT	-R9 (SCB,OR NULL)
:	DESTROY	-R2,R6,R1
:	LINK	-R7
V.SLST
	LCS	R9,1
V.SLS7
	L	R1,SCASAV,,		:GET SCB_LIST SAVE DATA
	JFFO	R1,V.SLS5		:JUMP,ON FINDING SCB ASSIGNED
	J	V.SLS0			:SCAN END OF SCB_LIST
V.SLS5
:	(4/21/86/CHS)
:	IF FWSCB IS 1, SCBPTR'S ARE IN FULL-WORD
	IF	FWSCB
	SLHLS	RNODE,1			:MAKE FW INDEX
	L	R9,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	SRHLS	RNODE,1
	ELSE
	LHL	R9,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	EI	(FWSCB)
	RBT	R2,SCASAV,,		:RESET CURRENT SCB INDEX IN SAVE AREA
	LHI	R8,SCLENG		:GET LENGTH OF SCB
	LB	R0,SCAEND,,
	SLHLS	R0,5
	AR	R2,R0
	LR	R0,R2
	MHR	R0,R8
	AR	R9,R0
	JR	R7			:RETURN
V.SLS0
	LB	R1,SCAEND,,		:GET CURRENT STOP POINT
	CLB	R1,SCATIM,,		:IS TIME FOR ENDING
	JGE	V.SLS6			:YES,SET SCB_PTR=NULL
	AIS	R1,1
	STB	R1,SCAEND,,		:SAVE NEW STOP POINT
	SLHLS	R1,2
	L	R1,NCBBLK+NDSCLS,R1,R13	:GET NEW SCB_LIST 
	ST	R1,SCASAV,,		:SAVE SCB_LIST IN SAVE AREA
	J	V.SLS7			:JUMP FOR SCB_LST SCANE
V.SLS6
	LCS	R9,1			:FAIL TO FIND DESIRED SCB
	JR	R7			:RETURN

	SUBTTL	PURGE QUEUE UTILITY ROUTINES

:	R.TDQP	-PURGE TC_TO_DFC_QUEUE IN SCB
:	---------------------------------------
:	THE USAGE OF REGISTERS --
:	INPUT	-R9(SCB_PTR) R13(NCB_PTR)
:	LINK	-R8
R.TDQP
	ST	R8,RGSAV8,,		:SAVE RETURN ADDRESS
R.TDQ1
	LHL	R6,SCBBLK+SCQTDG,R9,	:GET Q_TC_TO_DFC GET PTR
:	CLH	R6,SCBBLK+SCQTDR,R9,	:COMP GET TO RL (01/02/85 MIA)
	LHL	R4,SCBBLK+SCQTDR,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	R.TDQ0			:JUMP TO GET RETURN ADDRESS
:	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET BUFFER PTR (12/4/86 MIA)
	BBLOAD	R8,CMDBLK+CLARG,R6,	:GET MUCB PTR (12/4/86 MIA)
	BBLOAD	R3,BBUFER+MUCBTU,R8,	:GET BTU POINTER (12/4/86 MIA)
	JAL	R5,R.PBRC,,		:REL BUFFERS WITH BTU (12/4/86 MIA)
	LR	R3,R8			:COPY MUCB POINTER (12/4/86 MIA)
	JAL	R4,PBB,,		:RELEASE BUFFET
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	LHL	R6,SCBBLK+SCQTDG,R9,	:GET GET PTR
:	CLH	R6,SCBBLK+SCQTDR,R9,	:COMP TO RL PTR (01/02/85 MIA)
	LHL	R4,SCBBLK+SCQTDR,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	QUEMPT
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR
	JE	QUEMPT
	STH	R7,SCBBLK+SCQTDG,R9,	:UPDATE GET PTR
	JAL	R4,RELCL,,		:RELEASE CMDLST PTR
	J	R.TDQ1
R.TDQ0
	LB	R8,SCBBLK+SCBREL,R9,	:GET SCB REL # (03/15/85)
	RBT	R8,NCBBLK+NDQTDF,R13,	:RESET DATA PRESENT (03/15/85 MIA)
	L	R8,RGSAV8,,		:GET RETURN ADDRESS
	JR	R8			:RETURN

:	R.CREP	-PURGE CT_RCV_RQ_EXP IN SCB
:	---------------------------------------
:	THE USAGE OF REGISTERS --
:	INPUT	-R9(SCB_PTR)
:	LINK	-R8
R.CREP
	ST	R8,RGSAV8,,		:SAVE RETURN ADDRESS
R.CRE1
	LHL	R6,SCBBLK+SCTREG,R9,	:GET CT_RCV_RQ_EXP GET PTR
:	CLH	R6,SCBBLK+SCTRER,R9,	:COMP GET TO RL (01/02/85 MIA)
	LHL	R4,SCBBLK+SCTRER,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	R.CRE0			:JUMP TO GET RETURN ADDRESS
:	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET BUFFER PTR (10/17/84 MIA)
:	JAL	R4,PBB,,		:RELEASE BUFFET (10/17/84 MIA)
:	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT (10/17/84 MIA)
	LHL	R6,SCBBLK+SCTREG,R9,	:GET GET PTR
:	CLH	R6,SCBBLK+SCTRER,R9,	:COMP TO RL PTR (01/02/85 MIA)
	LHL	R4,SCBBLK+SCTRER,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	QUEMPT
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR
	JE	QUEMPT
	STH	R7,SCBBLK+SCTREG,R9,	:UPDATE GET PTR
	JAL	R4,RELCL,,		:RELEASE CMDLST PTR
	J	R.CRE1
R.CRE0
	L	R8,RGSAV8,,		:GET RETURN ADDRESS
	JR	R8			:RETURN

:	R.CRNP	-PURGE CT_RCV_RQ_NORM IN SCB
:	---------------------------------------
:	THE USAGE OF RNGISTERS --
:	INPUT	-R9(SCB_PTR)
:	LINK	-R8
R.CRNP
	ST	R8,RGSAV8,,		:SAVE RETURN ADDRESS
R.CRN1
	LHL	R6,SCBBLK+SCTRNG,R9,	:GET CT_RCV_RQ_NORM GET PTR
:	CLH	R6,SCBBLK+SCTRNR,R9,	:COMP GET TO RL (01/02/85 MIA)
	LHL	R4,SCBBLK+SCTRNR,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	R.CRN0			:JUMP TO GET RETURN ADDRESS
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET BUFFER PTR
	JAL	R4,PBB,,		:RELEASE BUFFET
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	LHL	R6,SCBBLK+SCTRNG,R9,	:GET GET PTR
:	CLH	R6,SCBBLK+SCTRNR,R9,	:COMP TO RL PTR (01/02/85 MIA)
	LHL	R4,SCBBLK+SCTRNR,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	QUEMPT
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR
	JE	QUEMPT
	STH	R7,SCBBLK+SCTRNG,R9,	:UPDATE GET PTR
	JAL	R4,RELCL,,		:RELEASE CMDLST PTR
	J	R.CRN1
R.CRN0
	L	R8,RGSAV8,,		:GET RETURN ADDRESS
	JR	R8			:RETURN


:	R.CSEP	-PURGE CT_SEND_RQ_EXP IN SCB
:	---------------------------------------
:	THE USAGE OF REGISTERS --
:	INPUT	-R9(SCB_PTR)
:	LINK	-R8
R.CSEP
	ST	R8,RGSAV8,,		:SAVE RETURN ADDRESS
R.CSE1
	LHL	R6,SCBBLK+SCTSEG,R9,	:GET CT_SEND_RQ_EXP GET PTR
:	CLH	R6,SCBBLK+SCTSER,R9,	:COMP GET TO RL (01/02/85 MIA)
	LHL	R4,SCBBLK+SCTSER,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	R.CSE0			:JUMP TO GET RETURN ADDRESS
:	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET BUFFER PTR (10/17/84 MIA)
:	JAL	R4,PBB,,		:RELEASE BUFFET (10/17/84 MIA)
:	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT (10/17/84 MIA)
	LHL	R6,SCBBLK+SCTSEG,R9,	:GET GET PTR
:	CLH	R6,SCBBLK+SCTSER,R9,	:COMP TO RL PTR (01/02/85 MIA)
	LHL	R4,SCBBLK+SCTSER,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	QUEMPT
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR
	JE	QUEMPT
	STH	R7,SCBBLK+SCTSEG,R9,	:UPDATE GET PTR
	JAL	R4,RELCL,,		:RELEASE CMDLST PTR
	J	R.CSE1
R.CSE0
	L	R8,RGSAV8,,		:GET RETURN ADDRESS
	JR	R8			:RETURN

:	R.CSNP	-PURGE CT_SEND_RQ_NORM IN SCB
:	---------------------------------------
:	THE USAGE OF RNGISTERS --
:	INPUT	-R9(SCB_PTR)
:	LINK	-R8
R.CSNP
	ST	R8,RGSAV8,,		:SAVE RETURN ADDRESS
R.CSN1
	LHL	R6,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM GET PTR
:	CLH	R6,SCBBLK+SCTSNR,R9,	:COMP GET TO RL (01/02/85 MIA)
	LHL	R4,SCBBLK+SCTSNR,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	R.CSN0			:JUMP TO GET RETURN ADDRESS
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET BUFFER PTR
	JAL	R4,PBB,,		:RELEASE BUFFET
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	LHL	R6,SCBBLK+SCTSNG,R9,	:GET GET PTR
:	CLH	R6,SCBBLK+SCTSNR,R9,	:COMP TO RL PTR (01/02/85 MIA)
	LHL	R4,SCBBLK+SCTSNR,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	QUEMPT
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR
	JE	QUEMPT
	STH	R7,SCBBLK+SCTSNG,R9,	:UPDATE GET PTR
	JAL	R4,RELCL,,		:RELEASE CMDLST PTR
	J	R.CSN1
R.CSN0
	L	R8,RGSAV8,,		:GET RETURN ADDRESS
	JR	R8			:RETURN

:	R.TPQP	-PURGE TCCB.Q_PAC IN TCCB
:	---------------------------------------
:	THE USAGE OF REGISTERS --
:	INPUT	-R9(SCB_PTR) R15 (TCCB_PTR) R13 (NCB_PTR)
:	LINK	-R8
R.TPQP
	ST	R8,RGSAV8,,		:SAVE RETURN ADDRESS
R.TPQ1
	LHL	R6,TCBBLK+TCQSPG,R15,	:GET CT_RCV_RQ_EXP GET PTR
:	CLH	R6,TCBBLK+TCQSPR,R15,	:COMP GET TO RL (01/02/85 MIA)
	LHL	R4,TCBBLK+TCQSPR,R15,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	R.TPQ0			:JUMP TO GET RETURN ADDRESS
:	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET BUFFER PTR (12/4/86 MIA)
	BBLOAD	R8,CMDBLK+CLARG,R6,	:GET MUCB PTR (12/4/86 MIA)
	BBLOAD	R3,BBUFER+MUCBTU,R8,	:GET BTU POINTER (12/4/86 MIA)
	JAL	R5,R.PBBC,		:REL BUFFERS WITH BTU (12/4/86 MIA)
	LR	R3,R8			:COPY MUCB POINTER (12/4/86 MIA)
	JAL	R4,PBB,,		:RELEASE BUFFET
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	LHL	R6,TCBBLK+TCQSPG,R15,	:GET GET PTR
:	CLH	R6,TCBBLK+TCQSPR,R15,	:COMP TO RL PTR (01/02/85 MIA)
	LHL	R4,TCBBLK+TCQSPR,R15,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R4			:COMP THEM (01/02/85 MIA)
	JE	QUEMPT
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR
	JE	QUEMPT
	STH	R7,TCBBLK+TCQSPG,R15,	:UPDATE GET PTR
	JAL	R4,RELCL,,		:RELEASE CMDLST PTR
	J	R.TPQ1
R.TPQ0
	LB	R8,SCBBLK+SCBREL,R9,	:GET REL SCB # (03/13/85 MIA)
	RBT	R8,NCBBLK+NDQTCP,R13,	:RESET DATA PRESENT (03/13/85 MIA)
	L	R8,RGSAV8,,		:GET RETURN ADDRESS
	JR	R8			:RETURN

	SUBTTL	CREATE NEWLIST (QUEUE) UTILITY ROUTINES

:	R.TDQN	-CREATE NEWLIST FOR TC_TO_DFC_QUEUE IN SCB
:	------------------------------------------------
:	INPUT	-R9 (SCB_PTR)
:	WORKING	-R0,R4,R6,R7
:	LINK	-R8
R.TDQN
	ST	R8,RGSAV8,,		:SAVE RESISTER 8
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,QUEMPT		:CRASH,IF NO CMD LIST LEFYT
	STH	R6,SCBBLK+SCQTDG,R9,	:SET GET PTR-Q_TC_TO_DFC
	STH	R6,SCBBLK+SCQTDR,R9,	:SET RELEASE PTR-Q_TC_TO_DFC
	L	R8,RGSAV8,,		:RESTORE REGISTER 8
	JR	R8			:RETURN

:	R.CREN	-CREATE NEWLIST FOR CT_RCV_RQ_EXP IN SCB
:	------------------------------------------------
:	INPUT	-R9 (SCB_PTR)
:	WORKING	-R0,R4,R6,R7
:	LINK	-R8
R.CREN
	ST	R8,RGSAV8,,		:SAVE RESISTER 8
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,QUEMPT		:CRASH,IF NO CMD LIST LEFYT
	STH	R6,SCBBLK+SCTREG,R9,	:SET GET PTR-CT_RCV_RQ_EXP
	STH	R6,SCBBLK+SCTRER,R9,	:SET RELEASE PTR-CT_RCV_RQ_EXP
	L	R8,RGSAV8,,		:RESTORE REGISTER 8
	JR	R8			:RETURN

:	R.CRNN	-CREATE NEWLIST FOR CT_RCV_RQ_NORM IN SCB
:	------------------------------------------------
:	INPUT	-R9 (SCB_PTR)
:	WORKING	-R0,R4,R6,R7
:	LINK	-R8
R.CRNN
	ST	R8,RGSAV8,,		:SAVE RESISTER 8
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,QUEMPT		:CRASH,IF NO CMD LIST LEFYT
	STH	R6,SCBBLK+SCTRNG,R9,	:SET GET PTR-CT_RCV_RQ_NORM
	STH	R6,SCBBLK+SCTRNR,R9,	:SET RELEASE PTR-CT_RCV_RQ_NORM
	L	R8,RGSAV8,,		:RESTORE REGISTER 8
	JR	R8			:RETURN

:	R.CSEN	-CREATE NEWLIST FOR CT_SEND_RQ_EXP IN SCB
:	------------------------------------------------
:	INPUT	-R9 (SCB_PTR)
:	WORKING	-R0,R8,R6,R7
:	LINK	-R8
R.CSEN
	ST	R8,RGSAV8,,		:SAVE RESISTER 8
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,QUEMPT		:CRASH,IF NO CMD LIST LEFYT
	STH	R6,SCBBLK+SCTSEG,R9,	:SET GET PTR-CT_SEND_RQ_EXP
	STH	R6,SCBBLK+SCTSER,R9,	:SET RELEASE PTR-CT_SEND_RQ_EXP
	L	R8,RGSAV8,,		:RESTORE REGISTER 8
	JR	R8			:RETURN

:	R.CSNN	-CREATE NEWLIST FOR CT_SEND_RQ_NORM IN SCB
:	------------------------------------------------
:	INPUT	-R9 (SCB_PTR)
:	WORKING	-R0,R8,R6,R7
:	LINK	-R8
R.CSNN
	ST	R8,RGSAV8,,		:SAVE RESISTER 8
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,QUEMPT		:CRASH,IF NO CMD LIST LEFYT
	STH	R6,SCBBLK+SCTSNG,R9,	:SET GET PTR-CT_SEND_RQ_NORM
	STH	R6,SCBBLK+SCTSNR,R9,	:SET RELEASE PTR-CT_SEND_RQ_NORM
	L	R8,RGSAV8,,		:RESTORE REGISTER 8
	JR	R8			:RETURN

:	R.TPQN	-NEWLIST TCCB.Q_PAC ENTRY_NAME (MU) QUEUE
:	---------------------------------------------------
:	INPUT	-R9 (SCB_PTR) R15 (TCCB_PTR)  - (5/8/85/CHS)
:	INPUT	-R9 (SCB_PTR) R12 (TCCB_PTR)  - (5/8/85/CHS)
:	WORKING	-R0,R8,R6,R7
:	LINK	-R8
R.TPQN
:	ST	R8,RGSAV8,,		:SAVE REG 8 (03/28/85 MIA)
	ST	R4,RGSAV4,,		:SAVE REG 4 (03/28/85 MIA)
	ST	R6,RGSAV6,,		:SAVE REG 6 (03/28/85 MIA)
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,QUEMPT		:CRASH,IF NO CMD LIST LEFT
:	STH	R6,TCBBLK+TCQSPG,R15,	:SET Q_PAC GET PTR(5/8/85/CHS)
:	STH	R6,TCBBLK+TCQSPR,R15,	:SET Q_PAC RELEASE PTR(5/8/85/CHS)
	STH	R6,TCBBLK+TCQSPG,R12,	:SET Q_PAC GET PTR(5/8/85/CHS)
	STH	R6,TCBBLK+TCQSPR,R12,	:SET Q_PAC RELEASE PTR(5/8/85/CHS)
:	L	R8,RGSAV8,,		:RESTORE REG 8 (03/28/85 MIA)
:	JR	R8			:RETURN (03/28/85 MIA)
	L	R6,RGSAV6,,		:RESTORE REG 6 (03/28/85 MIA)
	L	R4,RGSAV4,,		:RESTORE REG 4 (03/28/85 MIA)
	JR	R4			:RETURN (03/28/85 MIA)

:	R.LUAS	-ASSIGN LUCB BASED ON MUDADP IN MUCB
:	---------------------------------------------
:	INPUT	-R10 (MUCB_PTR) RNODE,R0 (RCV-MUDADP,SEND-MUOADP)
:	LINK	-R5
:	OUTPUT	-R15 (LUCB_PTR) & SKIP RETURN FOR SUCCESSFUL MATCH
:		 NORMAL RETURN FOR FAILURE
:	WORKING	-R0,R1,R6,R8
R.LUAS
	LHL	R8,PUCPTR,RNODE,RNODE	:GET PUCB PTR FOR NODE
	LHL	R15,PUCTAB+PUCLUC,R8,	:GET 1ST LUCB PTR
	CLB	R0,PUCTAB+PUMLID,R8,	:COMPARE TO CHECK LU IN THE RANGE?
	JGR	R5			:NORMAL RETURN,IF OUT OF RANGE
	LHL	R1,LUCTAB+LUCT.D,R15,	:GET REL. LU # TO ALL
	AR	R1,R0			:GET CURRENT DESIRED LU REL. #
	LH	R15,LUCPTR,R1,R1	:GET DESIRED LUCTAB PTR
	JG	4,R5			:SKIP RETURN,IF DEFINED
	JR	R5			:NORMAL RETURN,IF NOT DEFINED
:	LB	R1,PUCTAB+PUMLUN,R8,	:GET TOTAL LU IN THIS NODE
:R.LUA1
:	CLB	R0,LUCTAB+LUCRID,R15,	:CHECK ADDRESS
:	JER	R5			:JUMP RETURN
:	AHI	R15,LUCLEN
:	SIS	R1,1
:	JGBS	R.LUA1			:CONTINUE,IF MORE
:	J	R.CRAS			:CRASH,IF NO LUCB MATCH

	SUBTTL	FSM CALL UTILITY ROUTINES

:	R.FSMR	-ROUTINE TO SET UP FSM (IN SCB)  CALL PARAMETERS
:	-----------------------------------------------
:	INPUT	-R1 (FSM INDEX) R10 (MU_PTR) R9 (SCB_PTR) R0 (SIGNAL)
:	OUTPUT	-
:	LINK	-R3 
R.FSMR
	ST	R3,RGSAV3,,		:SAVE RETURN ADDRESS
	LB	R7,SCBBLK+SCSTAT,R1,R9	:GET STATE FOR THIS FSM
	JL	F.CRAS,,		:STATE ZERO INVALID
	LB	R2,BBUFER+MUDIRE,R10,	:SET UP MU.DIRECTION BYTE
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.RRI		:SET UP RQ/RSP
	LHL	R5,FSMSBL,R1,R1		:GET FSM ROUTINE ENTRY
	JAL	R3,F.CODE,R5,		:CALL FSM
	L	R3,RGSAV3,,		:GET RETURN ADDRESS BACK
	JR	R3			:RETURN


:	R.FSM1	-ROUTINE TO SET UP FSM (IN SCB)  CALL PARAMETERS
:		 THIS IS SECOND LEVEL CALL FSM
:	-----------------------------------------------
:	INPUT	-R1 (FSM INDEX) R10 (MU_PTR) R9 (SCB_PTR) R0 (SIGNAL)
:	OUTPUT	-
:	LINK	-R4 
R.FSM1
	ST	R4,RGSAV4,,		:SAVE RETURN ADDRESS
	LB	R7,SCBBLK+SCSTAT,R1,R9	:GET STATE FOR THIS FSM
	JL	F.CRAS,,		:STATE ZERO INVALID
	LB	R2,BBUFER+MUDIRE,R10,	:SET UP MU.DIRECTION BYTE
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.RRI		:SET UP RQ/RSP
	LHL	R5,FSMSBL,R1,R1		:GET FSM ROUTINE ENTRY
	JAL	R3,F.CODE,R5,		:CALL FSM
	L	R4,RGSAV4,,		:GET RETURN ADDRESS BACK
	JR	R4			:RETURN

:	R.FSM2	-ROUTINE TO SET UP FSM (IN SCB)  CALL PARAMETERS
:	FOR PC FSM WHICH LOCATED IN SCB
:	-----------------------------------------------
:	INPUT	-R1 (FSM INDEX) R10 (MU_PTR) R9 (PCB_PTR) R0 (SIGNAL)
:	OUTPUT	-
:	LINK	-R3 
R.FSM2
	ST	R3,RGSAV3,,		:SAVE RETURN ADDRESS
	LB	R7,SCBBLK+SCSTAT,R1,R9	:GET STATE FOR THIS FSM
	JL	F.CRAS,,		:STATE ZERO INVALID
	LB	R2,BBUFER+MUBIUF,R10,	:GET BIU BYTE
	LR	R4,R2
	NHI	R2,MU.BIU
	NHI	R4,MU.EIU
	LHL	R5,FSMSBL,R1,R1		:GET FSM ROUTINE ENTRY
	JAL	R3,F.CODE,R5,		:CALL FSM
	L	R3,RGSAV3,,		:GET RETURN ADDRESS BACK
	JR	R3			:RETURN

:	R.FTMR	-ROUTINE TO SET UP FSM (IN TCB)  CALL PARAMETERS
:	-----------------------------------------------
:	INPUT	-R1 (FSM INDEX) R10 (MU_PTR) R15 (TCB_PTR) R0 (SIGNAL)
:	OUTPUT	-
:	LINK	-R4 
R.FTMR
	ST	R4,RGSAV4,,		:SAVE RETURN ADDRESS
	LB	R7,TCBBLK+TCSTAT,R1,R15	:GET STATE FOR THIS FSM
	JL	F.CRAS,,		:STATE ZERO INVALID
	LB	R2,BBUFER+MUDIRE,R10,	:SET UP MU.DIRECTION BYTE
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.RRI		:SET UP RQ/RSP
	LHL	R5,FSMTBL,R1,R1		:GET FSM ROUTINE ENTRY
	JAL	R3,F.CODE,R5,		:CALL FSM
	L	R4,RGSAV4,,		:GET RETURN ADDRESS BACK
	JR	R4			:RETURN

:	R.FPMR	-ROUTINE TO SET UP FSM (IN PCB)  CALL PARAMETERS
:	-----------------------------------------------
:	INPUT	-R1 (FSM INDEX) R10 (MU_PTR) R15 (PCB_PTR) R0 (SIGNAL)
:	OUTPUT	-
:	LINK	-R3 
R.FPMR
	ST	R3,RGSAV3,,		:SAVE RETURN ADDRESS
	LB	R7,PCBBLK+PCSTAT,R1,R15	:GET STATE FOR THIS FSM
	JL	F.CRAS,,		:STATE ZERO INVALID
	LB	R2,BBUFER+MUBIUF,R10,	:GET BIU BYTE
	LR	R4,R2
	NHI	R2,MU.BIU
	NHI	R4,MU.EIU
	LHL	R5,FSMPBL,R1,R1		:GET FSM ROUTINE ENTRY
	JAL	R3,F.CODE,R5,		:CALL FSM
	L	R3,RGSAV3,,		:GET RETURN ADDRESS BACK
	JR	R3			:RETURN

F.CRAS
	JAL	R10,CRASH,,
	BC	0,0,0,CRQFSM

NOBUF
QUEMPT
	JAL	R10,CRASH,,
	BC	0,0,02,CRQRES

NOENT5
	JAL	R10,CRASH,,		:CRASH,IF NO ENTITY AVAILABLE
	BC	0,0,0,CRQRES

R.CRAS
	JAL	R10,CRASH,,		:CRASH,IF FORMAT ERROR
	BC	0,0,0,CRQFOM

	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER
	FO	CMDLST
	FO	MAIN

	EM
   
	SUBTTL	INITIALIZATION ROUTINES FOR SNA PACKAGE

:	THIS MODULE IS DESIGNED TO SUPPLY ALL THE INITIALIZATION ROUTINES
:	FOR SNA PACKAGE
:	-------------------------------------------------------------------

:	************REVISION HISTORY*************************
:	01/18/84 (NCS) - ORIGINAL DESIGN AND CODE
:	*****************************************************

	MO	.,SNAPKG
	RA	0

	LO	CBKDEF
	LO	MAIN
	LO	CMDLST

	SEG	A.CODE
:
:	ROUTINE TO PROCESS INITIALIZATIONS FOR ALL NODES
:	-------------------------------------------------------
:	THE USAGE OF REGISTERS --
:	R13 -- IZNODE RETURN REGISTER (FOR HIGH-LEVEL CALL RETURN)
:	R11 -- BASE REGISTER FOR NODE NUMBER
:	R9  -- BASE REGISTER FOR THE CONTROL BLOCK PTR
:	R5  -- RETURN REGISTER FOR SUBROUTINE CALL,SUCH AS IZPCB,IZNCB

IZNODE		
:	LHI	R11,MAXPUN-1		:GET TOTAL NODES # (01/20/87 YLH)
	XR	R11,R11			:INIT NODE COUNT (01/20/87 YLH)
	ST	R13,RGSAV3,,		:SAVE R13 (01/20/87 YLH)
	LIS	R13,2			:R13 WILL BE USED AS TCCB (01/20/87 YLH)
					:PTR AT SCB INIT (01/20/87 YLH)
IZNOD0
	JAL	R5,IZPCB,,		:CALL ROUTINE TO INITIALIZE PCB
	JAL	R5,IZEVB,,		:CALL ROUTINE TO INITIALIZE EVBLK
	JAL	R5,IZNCB,,		:CALL ROUTINE TO INITIALIZE NCB
	JAL	R5,IZSCB,,		:CALL ROUTINE TO INITIALIZE SCB
:	SIS	R11,1			:DECREASE NODES COUNTER (01/20/87 YLH)
	AIS	R11,1			:INCREMENT THE NODE COUNT (01/20/87 YLH)
	CLHI	R11,MAXPUN		:MAX. NODE REACHED? (01/20/87 YLH)
	JL	IZNOD0			:NO, CONTINUE (01/20/87 YLH)
:	JGE	IZNOD0			:CONTINUE,IF MORE (01/20/87 YLH)
	L	R13,RGSAV3,,		:YES, RESTORE R13 (01/20/87 YLH)
	JR	R13			:RETURN

:	IZPCB	-INITIALIZE PATH CONTROL BLOCK FOR DESIRED NODE (R11)
:	--------------------------------------------------------------
IZPCB
	LHL	R9,PCBPTR,R11,R11	:GET OFFSET OF RID FROM PCBPTR
	LIS	R1,0			:INITIAL VALUE
	LHI	R3,PCLENG-1		:LENGTH OF PCBBLK
IZPCB0
	STB	R1,PCBBLK,R3,R9		:INIT THAT BYTE
	SIS	R3,1			:GOT TO NEXT LOCATION
	CLHI	R3,PCSTAT		:IS IT TIME FOR FINISH?
	JGE	IZPCB0			:NO,CONTINUE
	JAL	R4,GETCL,,		:GET A FREE LINK
:	INIT BTU_RCV QUEUE PTR
:	----------------------
	JAL	R4,CLNULL		:CRASH,IF NO CMD LIST LEFYT
	STH	R6,PCBBLK+PCQBRG,R9,	:SET GET PTR
	STH	R6,PCBBLK+PCQBRR,R9,	:SET RELEASE PTR
	STH	R6,PCBBLK+PCQBRP,R9,	:SET PUT PTR
:	INIT SEND_LIST QUEUE PTR
:	------------------------
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,CLNULL		:CRASH,IF NO CMD LIST LEFYT
	STH	R6,PCBBLK+PCPUSG,R9,	:SET GET PTR
	STH	R6,PCBBLK+PCPUSR,R9,	:SET RELEASE PTR
	STH	R6,PCBBLK+PCPUSP,R9,	:SET PUT PTR
	JR	R5			:RETURN

:	IZNCB	-INITIALIZE NODE CONTROL BLOCK FOR DESIRED NODE (R11)
:	--------------------------------------------------------------
IZNCB
	LHL	R9,NCBPTR,R11,R11	:GET OFFSET OF RID FROM NCBPTR
	LIS	R1,0			:INITIAL VALUE
	LHI	R3,NDLENG-1		:LENGTH OF NCBBLK
IZNCB0
	STB	R1,NCBBLK,R3,R9		:INIT THAT BYTE
	SIS	R3,1			:GOT TO NEXT LOCATION
	CLHI	R3,NDSCLS		:IS TIME TO FINISH
	JGE	IZNCB0			:NO,CONTINUE
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,CLNULL		:CRASH,IF NO CMD LIST LEFYT
	STH	R6,NCBBLK+NDDQGP,R9,	:SET GET PTR (FOR DISPATCHER QUEUE)
	STH	R6,NCBBLK+NDDQRP,R9,	:SET RELEASE PTR (DISPATCHER QUEUE)
	JR	R5			:RETURN

:	IZEVB	-INITIALIZE ENVIRONMENT CONTROL BLOCK FOR DESIRED NODE(R11)
:	--------------------------------------------------------------
IZEVB
	LHL	R9,EVPTR,R11,R11	:GET OFFSET OF RID FROM EVPTR
	LIS	R1,0			:INITIAL VALUE
	LHI	R3,EVLENG-1		:LENGTH OF EVBLK
IZEVB0
	STB	R1,EVBLK,R3,R9		:INIT THAT BYTE
	SIS	R3,1			:GOT TO NEXT LOCATION
	JGE	IZEVB0			:NO,CONTINUE
	JR	R5			:RETURN

:	IZSCB	-INITIALIZE SESSION CONTROL BLOCKS IN DESIRED NODE(R11)
:	AND INITIALIZE TRANSMISSION CONTROL CONTROL BLOCK IN EACH 
:	SESSION CONTROL BLOCK.
:	--------------------------------------------------------------
IZSCB
	LHL	R15,NCBPTR,R11,R11	:GET OFFSET OF NCB FROM NCBPTR
	LB	R10,NCBBLK+NDDEVN,R15,	:GET TOTAL SCB IN THIS NODE
:	SETUP SESSION NUMBER TO INIT ALL SCB,TCB IN THAT NODE
	SLHLS	R10,1			:RESERVE FOR ALL SESSIONS
:		(4/21/86/CHS)
:	IF FWSCB IS SET, SCBPTR IS ALSO FULLWORD POINTER
	IF	FWSCB
	SLHLS	R11,1			:MAKE FW INDEX
	L	R9,SCBPTR,R11,R11	:GET OFFSET OF SCB
	SRHLS	R11,1
	ELSE
	LHL	R9,SCBPTR,R11,R11	:GET OFFSET OF RID FROM SCBPTR
	EI	(FWSCB)
	XR	R3,R3			:R3 IS USED AS REL. # OF (01/20/87 YLH)
					:SCB ON THIS PU (01/20/87 YLH)
IZSCB0
	STH	R13,SCBBLK,R9,		:INIT TCCB PTR (01/24/87 YLH)
	STB	R3,SCBBLK+2,R9,		:INIT SCB REL. # (01/24/87 YLH)
	JAL	R4,V.IZSC,,		:CALL COMMON ROUTINE TO INIT SCB
:	FOR NEXT SCB IN THIS NODE
:	-------------------------
	AHI	R13,TCLENG		:POINT TO THE NEXT TCCB (01/20/87 YLH)
	SIS	R10,1			:IS FINISHED?
	JLER	R5			:RETURN,IF FINISHED
	AIS	R3,1			:INCREMENT R3 (01/20/87 YLH)
	AHI	R9,SCLENG		:SET SCB OFFSET
	J	IZSCB0			:GOTO INIT

CLNULL
	J	CLMPTY,,
	FO	CMDLST
	FO	CBKDEF
	FO	MAIN


	EM


:	THIS PACKAGE IS DESIGNED TO SUPPORT THE UNDEFINED PROTOCOL
:	MACHINES(UPM) IN THE SNA FAPL MANUAL FOR PATH CONTROL LAYER.
:	-----------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF

	SEG	A.CODE

:	PAGE 4-45 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R0 (RCV,OR XMT AND OTHER PARAMETER)
:	OUTPUT	:
:	LINK	-R4
U.TGTR
	JR	R4

:	U.PAOC	-(UPM_ALS_OPERATIVE_CHECK) DETERMINE IF AN ADJACENT LINK
:	STATION (ALS) IS OPERATIVE.
:	PAGE 3-97 ON FAPL
:	---------------------------------------------------------------
:	INPUT	-R7 (NODE TYPE) R10 (MU PTR) R12 (CURRENT ENVIRONMENT PTR)
:		 R15 (LSCB PTR)
:	OUTPUT	-SKIP RETURN IF OK,ELSE NORMAL RETURN
:	LINK	-R4 IS LINK REGISTER
U.PAOC
	J	4,R4			:SKIP RETURN,IF OK

	FO	CMDLST
	FO	CBKDEF

	EM

   
	SUBTTL	FINITE STATE MACHINES (PATH CONTROL LAYER)
:	MODULE NAME IN COMMAND FILE -- SPCF02.F00

:	*********************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN
:	10 MARCH 1984 (DB) -- ORIGINAL CODING
:	**************************************************


:	THIS PACKAGE IS DESIGNED TO SUPPORT FSM FUNCTIONS OF SNA
:	PATH CONTROL LAYER (WHICH DESCRIBED IN FAPL CHAPTER 3)
:	-----------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF

	SEG	A.CODE

	HS	0
F.CODE	EQ	.

:	FSMPBL	-FSMPBL IS THE OFFSET TABLE FOR PCCB FSM ROUTINES
:	THE INDEX TO THIS TABLE NEEDS TO BE SETUP BEFORE THIS TABLE
:	BEING CALLED.
:	THE CONVENTION FOR THE FSM ROUTINES IS FXYYZZ, WHERE:
:	X INDICATES THE CONTROL BLOCK WHERE THE FSM ROUTINES LOCATED,
:	YY INDICATES THE INDEX (DECIMAL) FOR THAT FSM
:	ZZ IS USED AS THE LABEL (FROM 0 TO ZZ)
:	THE CONVENTION FOR THE ACTION CODE ROUTINES IS FXAYYZ, WHERE:
:	X  INDICATES THE CONTROL BLOCK USED BY THIS ACTION ROUTINE,
:	A  INDICATES LAYER (P, T, D, S OR C FOR COMMON) WHICH PRIMARILY
:	   USES THIS ACTION CODE,
:	YY INDICATES PARTICLAR ACTION CODE ROUTINE (DECIMAL), AND
:	Z  IS USED AS THE LABEL (FROM 0 TO Z)
:	------------------------------------------------------------

FSMPBL	HS	0
	HC	FPNOOP-F.CODE		:NO-OP (NO FSM ARE REQUIRED)
	HC	FP0000-F.CODE		:FSM_STATION_BIU_ASSEMBLY

:	-------------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:R15 (PCB ENTRY) R10 (MU PTR) R0 (FSM INPUT SIGNAL,OPTION)
:		 R1 (INDEX FOR FSM STATE INF. IN PCB) R2 (BBIU IN MUCB)
:		 R4 (EBIU IN MUCB)
:	OUTPUT	:R6 (TRUE -- NO-STATE-CHANGE (OC='>')
:		     FALSE -- CANN'T OCCUR (OC='/'),NO-STATE-CHANGE (OC='-')
:		 R1 (CONTAINS RECEIVE_CHECK) 
:	LINK	:R3
:	WORKING	:R4,R5,R6,R7,R2,R0 ARE DESTROYED
FP0000
	FS.MC1(FPCSBA,FS.PCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FP0002			:NO
	CLHI	R0,FS.RET		:SIGNAL=RESET?
	JN	FS.CSG,,		:NO, CRASH

:==================================================================
:	INPUT:	'RESET'
:==================================================================
	J	FP0004			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER INPUTS
:--------------------------------
FP0002
	LR	R2,R2			:BBIU?
	JE	FP0008			:NO, -BBIU
	LR	R4,R4			:EBIU?
	JE	FP0006			:NO, -EBIU

:====================================================================
:	INPUT:	BBIU, EBIU
:====================================================================
FP0004
	CLHI	R7,FS.ST1		:BETBIU STATE?
	JE	FPP000,,		:YES, ACTION = -
	J	FPP010,,		:NO, INBIU STATE, ACTION = 1
	
:====================================================================
:	INPUT:	BBIU, -EBIU
:====================================================================
FP0006
	CLHI	R7,FS.ST1		:BETBIU STATE?
	JE	FPP020,,		:YES, ACTION = 2
	J	FPP000,,		:NO, INBIU STATE, ACTION = -

:	CHECK FOR -BBIU INPUT
:------------------------------
FP0008
	LR	R4,R4			:EBIU?
	JE	FP000A			:NO, -EBIU

:======================================================================
:	INPUT:	-BBIU, EBIU
:======================================================================
	CLHI	R7,FS.ST1		:BETBIU STATE?
	JE	FS.CIN,,		:YES, ACTION = /
	J	FPP010,,		:NO, INBIU STATE, ACTION = 1

:======================================================================
:	INPUT:	-BBIU, -EBIU
:======================================================================
FP000A
	CLHI	R7,FS.ST1		:BETBIU STATE?
	JE	FS.CIN,,		:YES, ACTION = /
	J	FPP000,,		:NO, INBIU STATE, ACTION = -


FPNOOP
	JR	R3

	SUBTTL	PATH CONTROL ACTION CODE ROUTINES
:....................................................................
:	ACTION CODE:	-
:	ACTION:	NO STATE TRANSITION, SEND_OR_RCV_CHECK=FALSE
:....................................................................
FPP000
	FNC
	LHI	R6,FALSE		:SEND_OR_RCV_CHECK=FALSE
	JR	R3			:RETURN

:....................................................................
:	ACTION CODE:	1
:	ACTION:	CHANGE TO STATE 1, SEND_OR_RCV_CHECK=FALSE
:....................................................................
FPP010
	LHI	R0,FS.ST1		:GET STATE 1 VALUE
FPP012
	FNC
	STB	R0,PCBBLK+PCSTAT,R1,R15	:STORE NEW STATE VALUE INTO PCB
	JBS	FPP000			:SEND_OR_RCV_CHECK=FALSE

:....................................................................
:	ACTION CODE:	2
:	ACTION:	CHANGE TO STATE 2, SEND_OR_RCV_CHECK=FALSE
:....................................................................
FPP020
	LHI	R0,FS.ST2		:GET STATE 2 VALUE
	JBS	FPP012			:GO STORE NEW VALUE IN PCB


	FO	CMDLST
	FO	CBKDEF

	EM
  
	SUBTTL	SNA PACKAGE(UTILITY ROUTINES) - PATH CONTROL LAYER
:	MODULE NAME IN COMMAND FILE -- SPCR02.F00

:	*****************************************************
:	REVISION HISTORY --
:	DEC. 09 (NCS) -- ORIGINAL DESIGN AND CODING
:	***********************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT MISCELLANEOUS ROUTINES
:	WHICH ARE CALLED BY THE PATH CONTROL LAYER PROCESSES.
:	PLEASE REFER TO THE PSEUDO-CODES IN CHAPTER 4 ON FAPL MANUE.
:	----------------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	CMDLST

	SEG	A.CODE


:	P.THRC	-(ROUTE_EXTENSION_TH_RCV_CHK)
:		THIS PROCEDURE PERFORMS BASIC VALIDITY CHECKS ON THE PIU TH
:		CONTAINED IN A BTU RECEIVED AT OR FROM A PU_T1 OR PU_T2 NODE.
:	PAGE 3-98 ON FAPL
:	---------------------------------------------------------------
:	INPUT	-R7 (NODE TYPE) R10 (BTU PTR) R12 (CURRENT ENVIRONMENT PTR)
:	OUTPUT	-SKIP RETURN IF OK,ELSE NORMAL RETURN
:	LINK	-R8 IS LINK REGISTER
P.THRC
	LHL	R4,EVBLK+EVMULN,R12,	:GET MU LENGTH
	JE	P.THR3			:BTU_LENGTH < 1,JUMP TO CALL 800B
	LB	R6,BBUFER,R10,		:GET 1ST BYTE OF TH
:	TO THIS POINT -R6 (1ST BYTE OF PIU) R7 (NODE TYPE)
:	R4 (BTU DATA LENGTH) R10 (BTU DATA BUFFER PTR)
	CLHI	R7,PU.T2		:IS THIS NODE PU.T2? 
	JE	P.THR1			:JUMP,IF IT IS PU.T2
:	NODE IS PU TYPE 1 ,ENTER FROM THIS POINT
:	----------------------------------------
	LR	R5,R6			:SET WORKING REGISTER
	NHI	R5,0F0			:GET PIU_FID FIELD
	SRHLS	R5,AD.FID		:SET PIU_FID INTO PROPER POSITION
	CLHI	R5,FID3			:IS THIE FID3?
	JN	P.THR3			:JUMP,IF THIS FID IS NOT FID2
	CLHI	R4,2			:ELSE,IF BTUCB.BTU_LENGTH < 2
	JL	P.THR3			:THEN CALL UPM_LOG(X'800B')
	CLHI	R4,5			:ELSE IF BTUCB.BTU_LENGTH<5
	JGE	P.THR6			:(THIS IS NOT IN 'IF' CONDITION)
	LR	R5,R6			:(GET 1ST BYTE OF PIU)
	NHI	R5,08			:(MASK OFF OHER BITS)
	SRHLS	R5,AD.BIU		:(GET PROPER POSITION OF PIU_BBIUI)
	JE	P.THR6			:(NOT IN 'IF' CONDITION)
:	CALL UPM_LOG(X'4005'), INCOMPLETE RH
:	------------------------------------
	J	P.THR2
:	NODE IS PU TYPE 2 ,ENTER FROM THIS POINT
:	----------------------------------------
P.THR1
	LR	R5,R6			:SET WORKING REGISTER
	NHI	R5,0F0			:GET PIU_FID FIELD
	SRHLS	R5,AD.FID		:SET PIU_FID INTO PROPER POSITION
	CLHI	R5,FID2			:IS THIE FID2?
	JN	P.THR3			:JUMP,IF THIS FID IS NOT FID2
	CLHI	R4,6			:ELSE,IF BTUCB.BTU_LENGTH < 6
	JL	P.THR3			:THEN CALL UPM_LOG(X'800B')
	CLHI	R4,9			:ELSE IF BTUCB.BTU_LENGTH<9
	JGE	P.THR6			:(THIS IS NOT IN 'IF' CONDITION)
	LR	R5,R6			:(GET 1ST BYTE OF PIU)
	NHI	R5,08			:(MASK OFF OHER BITS)
	SRHLS	R5,AD.BIU		:(GET PROPER POSITION OF PIU_BBIUI)
	JE	P.THR6			:(NOT IN 'IF' CONDITION)
:	CALL UPM_LOG(X'4005'), INCOMPLETE RH
:	------------------------------------
P.THR2
	J	P.THR4
:	CALL UPM_LOG(X'8006'), INVALID FID
:	------------------------------------
P.THR3
:	CALL UPM_LOG(X'800B'), INCOMPLETE TH
:	------------------------------------
P.THR4
:	NORMAL RETURN FOR ALL THE ERROR CONDITIONS
:	------------------------------------------
	J	P.CRAS			:CRASH FOR TESTING
	JR	R8

:	OK,SKIP RETURN
:	--------------
P.THR6
	J	4,R8


:	P.LNPU	-(LENGTH_OF_PIU) THIS PROCEDURE IS INVOKED BY A FUNCTION
:	REFERENCE TO CALCULATE THE LENGTH OF A FID0,FID1,FID4 OR FIDF PIU.
:	THE PIU LENGTH IS THE SUM OF TH LENGTH AND DCF VALUE.
:	PAGE 3-44 ON FAPL
:	---------------------------------------------------------------
:	INPUT	-R3 (MU PTR)
:	OUTPUT	-R1 (LENGTH OF PIU)
:	LINK	-R8 IS LINK REGISTER
P.LNPU
	LHL	R1,BBUFER+MUDCF,R3,	:GET DCF FROM MUCB
:	FID=FID4 | FIDF
:	------------------
	LHI	R4,26			:LENGTH OF TH
	LB	R0,BBUFER+MUBIUF,R3,	:SET UP TH.DAF CONTAINTS
	NHI	R0,MU.FID		:MASK OFF OTHER BITS
	SRHLS	R0,AD.FID		:GET PROPER LOCATION FOR FID
	CLHI	R0,FID4			:IS FID FID4?
	JE	P.LNP0			:JUMP,IF YES
	CLHI	R0,FIDF			:IS FID FIDF?
	JE	P.LNP0			:JUMP,IF YES
	CLHI	R0,FID1			:IS FID FID1?
	JE	P.LNP1			:JUMP,IF YES
	CLHI	R0,FID0			:IS FID FID0?
	JE	P.LNP1			:JUMP,IF YES
	J	P.CRAS			:ELSE CRASH (FID ERROR)
:	FID=FID0 | FID1
:	----------------
P.LNP1
	LHI	R4,10			:LENGTH OF TH
P.LNP0
	AR	R1,R4			:PIU LENGTH=DCF+10
	JR	R8			:RETURN


:	P.EXNR	-(ROUTE_EXTENSION_NEG_RSP) IF POSSIBLE, THIS PROCEDURE
:	CHANGES A FID2|FID3 PIU OR PARTIALLY ASSEMBLED BIU TO A
:	NEGATIVE RESPONSE PIU, SETS THE SENSE CODE EQUAL TO THE VALUE
:	PASSED IN THE CALL PARAMETER (R0), AND ENQUEUES THE RESULTANT
:	NEGATIVE RESPONSE PIU ON THE BTU SEND LIST FOR THE ADJACENT
:	LINK STATION FROM WHICH THE MU WAS RECEIVED
:	PAGE 3-99 ON FAPL
:	-------------------------------------------------------------
:	INPUT	:R0 (SENSE CODE ) R10 (MU_PTR)
:	LINK	:R4
:	OUTPUT	:
:	DESTROY	:R1,R2,R5,R7
P.EXNR
	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	P.EXN0			:JUMP,IF IT IS NOT SET (NOT BBIU)
	LHL	R1,BBUFER+MUDCF,R10,	:GET DCF FROM MUCB
	CLHI	R1,3			:IS DCF< 3
	JL	P.EXN0			:JUMP,IF DCF<3
:	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH FROM MU (11/17/86 YLH)
:	NHI	R0,MU.RRI		:MASK OFF OTHER BITS (11/17/86 YLH)
	LB	R7,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH FROM MU (11/17/86 YLH)
	NHI	R7,MU.RRI		:MASK OFF OTHER BITS (11/17/86 YLH)
	JN	P.EXN0			:JUMP,IF RRI=RSP
	JAL	R7,R.RQN,,		:JUMP TO CHECK MSG HAS RESPONSE MADE
	J	P.EXN2			:JUMP,IF NOT OK
	J	P.EXN0			:JUMP,IT IS OK
:	CALL UPM_ALS_OPERATIVE_CHECK??????
:	((BBIUI<>BBIU)|(DCF<3)|RQN|RRI=RSP|UPM_ALS_OPERATIVE_CHECK)
:	----------------------------------------------------------------
:	CALL UPM_LOG(SNC_CODE)?????
:	DISCARD MU??????
P.EXN0
:	J	P.CRAS			:CRASH,IF ERROR (11/17/86 YLH)
	ST	R4,RGSAV4,,		:SAVE RETURN REG. (01/23/87 YLH)
	JAL	R8,R.DSMU,,		:DISCARD MU DATA AND MUCB (11/17/86 YLH)
	L	R4,RGSAV4,,		:RESTORE RETURN REG. (01/23/87 YLH)
	JR	R4			:RETURN
:	NOT ((BBIUI<>BBIU)|(DCF<3)|RQN|RRI=RSP|UPM_ALS_OPERATIVE_CHECK)
:	----------------------------------------------------------------
:	R0 CONTAINS SNC_CODE
P.EXN2
	JAL	R5,R.MUNR,,		:CALL CHANGE_MU_TO_NEG_RSP(SNC_CODE)
	LB	R0,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R0,MU.FID		:MASK OFF OTHER BITS
	SRHLS	R0,AD.FID		:GET PROPER LOCATION OF FID
	CLHI	R0,FID2			:IS FID FID2?
	J	P.EXN1			:JUMP,IF NOT
:	FID=FID2
:	--------
	LB	R0,BBUFER+MUDADP,R10,	:GET DAFPRIM
	LB	R1,BBUFER+MUOADP,R10,	:GET OAFPRIME
	STB	R0,BBUFER+MUOADP,R10,	:STORE DAFPRIME INTO OAFPRIME
	STB	R1,BBUFER+MUDADP,R10,	:STROE OAFPRIME INTO DAFPRIME
P.EXN1
	ST	R4,RGSAV4,,		:SAVE RETURN REGISTER
	JAL	R3,P.PISD,,		:CALL ROUTE_EXTENSION_PIU_SEND
	L	R4,RGSAV4,,		:GET RETURN ADDRESS BACK
	JR	R4			:RETURN

:	P.NBAR	-(T1_OR_T2_NO_BIU_ASSEMBLY_RCV_CK) THIS PROCEDURE
:	PERFORMS PIU RECEIVE CHECKS REQUIRED AT A PU_T1 OR PU_T2
:	NODE THAT DOES NOT SUPPORT BIU ASSEMBLY.
:	PAGE 3-91 ON FAPL
:	-------------------------------------------------------------
:	INPUT	:R10 (MU_PTR)
:	LINK	:R8
:	OUTPUT	:SKIP RETURN IF OK. ELSE ,NORMAL RETURN
:	DESTROY	:R1,R2,R5,R7
P.NBAR
:	IGNORE BIU AND EIU INDICATORS CHECKING
:	--------------------------------------
:	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
:	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
:	JE	P.NBA1			:JUMP,IF IT IS NOT SET (NOT BBIU)
:	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
:	NHI	R1,MU.EIU		:CHECK THE EBIU INDICATOR
:	JE	P.NBA1			:JUMP,IF IT IS NOT SET (NOT EBIU)
	LB	R1,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH FROM MU
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS
	CLHI	R1,MU.SC		:IS THIS SC?
	JN	P.NBA3			:JUMP IF NOT SC
	LHL	R1,BBUFER+MUDCF,R10,	:GET DCF FROM MUCB
	CLHI	R1,4			:IS DCF< 4
	JGE	P.NBA3			:JUMP IF DCF >=4
	LHI	R0,.RULER		:SETUP SENSE CODE 'RU LENGTH ERROR'
	J	P.NBA2			:JUMP TO PROCESS
P.NBA3
	LB	R1,BBUFER+MUMISC,R10,	:GET LOST DATA INDICATOR
	NHI	R1,MU.LDI		:MASK FOR LOST DATA IND.
	JE	4,R8			:SKIP RETURN,IF LOST_DATA IS NOT SET
	LHI	R0,.TOOLP		:SET SENSE CODE 'TOO LONG PIU'
	JFS	P.NBA2			:JUMP TO PROCESS
:	CALL ROUTE_EXTENSION_NEG_RSP(8007)
:	-----------------------------------
P.NBA1
	LHI	R0,.SEGER		:SETUP SENSE CODE 'SEGMENTING ERROR'
:	SAVE R8 BEFORE CALL THE NEG_RSP ROUTINE
:	---------------------------------------
P.NBA2
	ST	R8,RGSAV8,,		:SAVE RETURN REGISTER
	JAL	R4,P.EXNR,,		:CALL ROUTE_EXTENSION_NEG_RSP
	L	R8,RGSAV8,,		:GET RETURN ADDRESS BACK
	JR	R8			:NORMAL RETURN,WHEN NOT OK

:	P.PISD	-(ROUTE_EXTENSION_PIU_SEND) THIS PROCEDURE SENDS A FID2 
:	OR FID3 PIU AS FOLLOWS--
:	(1) THE PIU IS CONVERTED FROM CANONICAL FORM TO THE LINK FORMAT
:	(2) PIU_VECTOR IS CREATED
:	(3) THE PIU_VECTOR.PIU_PTR IS SET TO POINT TO THE PIU
:	(4) THE PIU_VECTOR.PIU_LENGTH IS SET TO THE LENGTH OH PIU
:	(5) A POINTER TO THE PIU_VECTOR IS ADDED TO THE LSCB.BTU_SEND_LIST
:	    FOR THE ADJACENT LINK STATION TO WHICH THE PIU IS DESTINED.
:	PAGE 3-89 ON FAPL
:	------------------------------------------------------------------
:	INPUT	:R10 (MU_PTR) R15 (PCCB_PTR)
:	LINK	:R3
:	OUTPUT	:
:	DESTROY	:R1,R2,R5,R7
P.PISD
	ST	R3,RGSAV3,,		:SAVE RETURN REGISTER
	JAL	R8,R.MFCN,,		:CALL MAP_FROM_CANONICAL(PIU_LENGTH)
:	R0 (PIU_LENGTH) R1 (MU_PTR)
:	----------------------------
:	PIU_VECTOR FORMAT IS THE SAME AS COMMAND LIST
	JAL	R4,GETCL,,		:GET COMMAND LIST
	J	P.CRAS			:CRASH,IF EMPTY
	LHL	R7,PCBBLK+PCPUSP,R15,	:GET PUT PTR
	STH	R0,CMDBLK+CLLNG,R7,	:STORE PIU_LENGTH
	BBSTOR	R1,CMDBLK+CLARG,R7,	:STORE PIU_VECTOR.PIU_PTR
	LHI	R2,DLCLNK		:GET CMD CATEGORY FOR DLC|PC
	STB	R2,CMDBLK+CLCMD,R7,	:SET DLC|PC CMD TYPE IN CMDLSIT
	LIS	R2,1
	STB	R2,CMDBLK+CLCMDS,R7,	:SET DLC|PC FLAG (FOR DLC PROTECTION)
	STH	R6,CMDBLK+CLPTR,R7,	:LINK NEW ENTRY
	STH	R6,PCBBLK+PCPUSP,R15,	:UPDATE NEW PUT PTR
	STH	R6,PCBBLK+PCPUSR,R15,	:UPDATE NEW RELEASE PTR
	LHL	R8,PUCPTR,RNODE,RNODE	:GET PUCPTR
	LB	R7,PUCTAB+PUCT.N,R8,	:GET REL. # IN ALL PU'S FOR THIS NODE
	SBT	R7,DPPCDL,,		:SET DATA PRESENT BIT ARRAY
	L	R3,RGSAV3,,		:GET RETURN ADDRESS BACK
	JR	R3			:RETURN

:	P.SSBM	-T1_OR_T2_SESSION_BIU_ASSEMBLER
:	PAGE 3-94 ON FAPL
:	---------------------------------------------
:	THE USAGE OF REGISTERS --
:	INPUT	-R9 (SCB_PTR) R10 (MU_PTR) R14 (1ST LEVEL CALL)
:	LINK	-R8
:	OUTPUT	-R0 (YES--BIU_AVAILABLE,NO)
:	WORKING	-R1 (INDEX TO FSM) R2 (BIUI IN MUCB)
P.SSBM
	LB	R2,BBUFER+MUBIUF,R10,	:GET BIU BYTE FROM MUCB
	NHI	R2,MU.BIU		:MASK FOR BIUI
	LHI	R1,FSCBUA		:GET INDEX FOR FSM
	LB	R3,SCBBLK+SCSTAT,R1,R9	:GET CURRENT STATE FOR FSM
	CLHI	R3,FS.ST1
	JE	P.SSB8			:JUMP,IF YES
	CLHI	R3,FS.ST2		:IS IT INBIU?
	JN	P.CRAS			:CRASH IF NOT
:	FSM_SESSION_BIU_ASSEMBLY=INBIU
:	--------------------------------
	LR	R2,R2			:CHECK BIUI
	JE	P.SSB1			:JUMP,IF BIUI<>BIU
:	FSM_SESSION_BIU_ASSEMBLY=INBIU,AND,BIUI=BIU
:	----------------------------------------------
	J	P.SSBA			:SET <>BIU_AVAILABLE
:	FSM_SESSION_BIU_ASSEMBLY=INBIU,AND,BIUI<>BIU
:	----------------------------------------------
P.SSB1
	J	P.SSB9			:CALL FSM,AND RETURN BIU_AVAILABLE
:	FSM_SESSION_BIU_ASSEMBLY=BETBIU
:	--------------------------------
P.SSB8
	LR	R2,R2			:CHECK BIUI
	JE	P.SSBA			:JUMP,IF BIUI<>BIU
P.SSB9
	LIS	R0,0
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSM2,,		:CALL FSM_SESSION_BIU_ASSEMBLY
	LHI	R0,YES			:SET RETURN CODE TO YES(BIU_AVAILABLE)
	JR	R8			:RETURN
:	FSM_SESSION_BIU_ASSEMBLY=BETBIU,BUT,<>BIU
:	-----------------------------------------
P.SSBA
	LHI	R0,FS.RET		:SET 'RESET' SIGNAL
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSM2,,		:CALL FSM_SESSION_BIU_ASSEMBLY
	LHI	R0,.SEGER		:SET SEGEMENTING ERROR '8007'
	ST	R0,BBUFER+MURCKS,R10,	:SETUP RECEIVE_CHECK_SENSE IN MUCB
	LHI	R0,NO			:SET RETURN CODE TO NO(<>BIU_AVAILABLE)
	JR	R8			:RETURN

P.CRAS
	JAL	R10,CRASH,,
	BC	0,0,0,CRQPCC

	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER
	FO	CMDLST

	EM

    	SUBTTL	SNA PACKAGE(MAIN PROCESSES) - PATH CONTROL LAYER
:	MODULE NAME IN COMMAND FILE -- SPCC00.F00

:	************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING 
:	************************************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT PATH CONTROL LAYERS OF
:	SNA AS DESCRIBED IN FAPL CHAPTER 3
:	------------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CBKDEF
	LO	GBLDEF
	LO	CMDLST
	LO	BBUFER
	GL	U.RCKP

	SEG	A.DATA
:	====================================================
:	-----NOTE FOR DATA STRUCTURE-----
:	(1) COMMAND LIST BETWEEN DLC AND PC --
:	    CLCMD (CONTAINS 'DLCLNK' FOR CMD CATEGORY)
:	    CLLNG (CONTAINS DATA BYTE COUNT )
:	    CLARG (CONTAINS DATA BUFFER POINTER)
:	    CLCMDS(IGNORE.....)
:	====================================================
PCCSAV	WS	1			:FOR PATH CONTROL LAYER SAVE AREA

	SEG	A.CODE

:	P.DQBR	-(PC.DEQ_Q_BTU_RCV) THIS PROCEDURE DEQUEUES A BTU FROM
:	THE PATH CONTROL BTU RECEIVE QUEUE AND ROUTES IT TO THE PATH
:	CONTROL COMPONENT APPLICABLE TO THE NODE.
:	1.FOR PU_T4 OR PU_T5 NODES,THE BTU IS ROUTED TO BF.PC.RCV
:	2.FOR PU_T1 NODES,THE BTU IS ROUTED TO PC_T1.RCV
:	3.FOR PU_T2 NODES,THE BTU IS ROUTED TO PC_T2.RCV
:	PAGE 3-88 ON FAPL
:	-------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:RNODE,R12 (EV_PTR) R14 (LINK)
:	OUTPUT	:
:	LINK	:R14(CALLED FROM DISPATCHER)
:	WORKING	:
P.DQBR
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.OPQ		:IS IT OUT OF RANGE (OPEN_QUEUE)
	JN	P.CRAS			:JUMP IF NOT OPEN_QUEUE SIGNAL

P.DQB6
	LHL	R15,PCBPTR,RNODE,RNODE	:GET PATH CONTROL BLOCK PTR
:	LOCK AND UNLOCK THE Q_BTU_RCV
:	-----------------------------
	LHL	R6,PCBBLK+PCQBRG,R15,	:GET GET PTR TO Q_BTU_RCV
:	CLH	R6,PCBBLK+PCQBRR,R15,	:COMP GET TO RL (01/02/85 MIA)
	LHL	R0,PCBBLK+PCQBRR,R15,	:GET REL PTR (01/02/85 MIA)
	CR	R6,R0			:COMP THEM (01/02/85 MIA)
	JE	P.DQB1			:NOTHING IN QUEUE,ERROR
	LB	R0,CMDBLK+CLCMD,R6,	:GET CMD CATEGORY (DLC|PC)
	CLHI	R0,DLCLNK		:IS IT RIGHT PLACE FOR THIS DATA?
	JN	P.CRAS			:CRASH,IF NOT
	BBLOAD	R10,CMDBLK+CLARG,R6,	:GET BUFFER PTR FOR BTU
	LH	R8,CMDBLK+CLLNG,R6,	:GET BYTE COUNT FOR BTU
:	REMOVE FIRST(BTU) FROM PCCB.Q_BTU_RCV SET(BTU_PTR)
:	----------------------------------------------------
	LH	R7,CMDBLK+CLPTR,R6,	:CHECK NEXT QUEUE PTR
	JE	CLERR,,			:COMMAND LIST ERROR
	STH	R7,PCBBLK+PCQBRG,R15,	:UPDATE NEW GET PTR
	JAL	R4,RELCL,,		:REMOVE THE COMMAND LIST FROM Q_BTU_RCV
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NODE CONTROL BLOCK PTR
:	SELECT ANYORDER(NCB.PU_TYPE)
:	-------------------------------
	LB	R1,NCBBLK+NDPUTY,R13,	:GET PU_TYPE FOR THIS NODE
:	WE ASSUME T/I AND H/I IS NODE TYPE 2 IN PC LEVEL
:	-------------------------------------------------
	CLHI	R1,PU.T4		:IS THIS PU.T4?
	JE	P.DQB2			:YES,JUMP
	CLHI	R1,PU.T5		:IS THIS PU.T5?
	JE	P.DQB2			:YES,JUMP
	CLHI	R1,PU.T1		:IS THIS PU.T1?
	JE	P.DQB3			:YES,JUMP
	CLHI	R1,PU.T2		:IS THIS PU.T2?
	JE	P.DQB4			:YES,JUMP
:	ERROR,1.NOTHING IN QUEUE 2.NODE TYPE IS NOT RIGHT
P.DQB1
	J	BUFCRA
:	PU_T4 OR PU_T5 HANDLER
P.DQB2
	LHI	R2,PCBFRV		:SET UP BF.PC.RCV DESTINATION
	JFS	P.DQB5			:JUMP TO COMMON AREA
:	PU_T1 HANDLER
P.DQB3
	LHI	R2,PCT1RV		:SET UP PC_T1.RCV DESTINATION
	JFS	P.DQB5			:JUMP TO COMMON AREA
:	PU_T2 HANDLER
P.DQB4
	LHI	R2,PCT2RV		:SET UP PC_T2.RCV DESTINATION
P.DQB5
	JAL	R4,GBB,,		:CREATE NEW DQE (R3 IS NEW DQE)
	J	BUFCRA			:CRASH,IF NO ENTITY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LHI	R1,PCDQBR		:THE SEND PROCEDURE IS P.DQBR
	LHI	R0,SG.BTU		:THE INPUT SIGNAL
	STH	R8,BBUFER+DQMULN,R3,	:STORE BTU LENGTH
:	PARM_PTR=BTU_PTR IN DQE
	BBSTOR	R10,BBUFER+DQPRMP,R3,	:SET UP PARAMETER ENTITY
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	ST	R7,BBUFER+DQSCB,R3,	:SET SCB PTR TO 'NULL'
	STH	R7,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO 'NULL'
	STB	R7,BBUFER+DQNWCM,R3,	:CLEAR DQNWCM
	JAL	R8,SEND,,		:JUMP TO EXECUTE 'SEND' STATEMENT
	JR	R14			:RETURN

	SUBTTL	PATH CONTROL LAYER (BOUNDARY FUNCTION SUPPORT)

:	P.BFRV	-(BF.PC.RCV) THIS PROCEDURE PROCESSES PIU'S RECEIVED
:	FROM PU_T1 OR PU_T2 NODES
:	1.INVALID PIU'S ARE DISCARDED OR RESULT IN A NEGATIVE RESPONSE
:	2.PU-PU FLOW PIU'S ARE ROUTED TO THE NETWORK SERVICES COMPONENT
:	  OR THE PU SERVICES MANAGER
:	3.BIU'S CONTAINING SESSION ACTIVATION|DEACTIVATION RU'S ARE
:	  ROUTED TO THE COMMON SESSION CONTROL MANAGER COMPONENT OF
:	  PU SERVICE MANAGER
:	4.FOR ALL OTHER PIU'S,THE BOUNDARY FUNCTION HALF-SESSION IS
:	  FOUND,IF POSSIBLE,AND THE BIU IS ROUTED TO BOUNDARY FUNCTION
:	  TRANSMISSION CONTROL
:	PAGE 3-78 ON FAPL
:	-------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:
:	OUTPUT	:
:	LINK	:
:	WORKING	:
P.BFRV
	IF	FN.BND			:IF BOUNBARY FUNCTION SUPPORT
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NODE CONTROL BLOCK PTR
	BBLOAD	R10,EVBLK+EVPRMP,R12,	:SET BTU_PTR=PARM_PTR
:	THE PU TYPE HAS TO DECIDE ?????? CHECK LSCB.XID_RCV.PU_TYPE
	LIS	R7,PU.T2		:SET UP INPUT PARAMETER
	JAL	R8,P.THRC,,		:CALL ROUTE_EXTENSION_TH_RCV_CHK
	J	P.BFR4			:JUMP,IF RETURN IS NOT OK
:	IF (ROUTE_EXTENSION_TH_RCV_CHK(PU_T2) OK,DO THE FOLLOWINGS
:	--------------------------------------------------------------
	JAL	R4,GBB,,		:GET BIG BUFFERLET FOR MUCB
	J	BUFCRA			:JUMP TO CRASH,IF NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
:	TO THIS POINT-
:	R3 (PTR TO THE MUCB) R10 (BTU PTR)
P.BFR3
	LHL	R7,EVBLK+EVMULN,R12,	:GET PIU LENGTH
	JAL	R8,R.MTCN,,		:CALL MAP_TO_CANONICAL
	LB	R4,BBUFER+MUOADP,R10,	:GET OAFPRIME FROM MUCB
	JN	P.BFR2			:JUMP,IF OADFPRME<>0
	LB	R4,BBUFER+MUDADP,R10,	:GET OAFPRIME FROM MUCB
	CLHI	R4,0FF			:IS DAFPRIME=0FF?
	JN	P.BFR2			:DAFPRIME<>'FF',JUMP
	LB	R0,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R0,MU.FID		:MASK OFF OTHER BITS
	SRHLS	R0,4			:GET PROPER LOCATION OF FID
	CLHI	R0,FID2			:IS FID FID2?
	JN	P.BFR2			:JUMP,IF NOT
	LB	R1,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	P.BFR1			:JUMP,IF IT IS NOT SET (NOT BBIU)
	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.EIU		:CHECK THE EBIU INDICATOR
	JE	P.BFR1			:JUMP,IF IT IS NOT SET (NOT EBIU)
:	NOT (BBIUI<>BBIU | EBIUI<>EBIU) SEND MU TO PU.SVC_MGR.NS.RCV
:	-------------------------------
	LHI	R2,PMNSMR		:GET 'PU.SVC_MGR.NS.RCV'
P.BFR7
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	BUFCRA			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,PCBFRV		:GET SENDING PROCEDURE #
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	JR	R14			:RETURN
:	IF BBIUI<>BBIU | EBIUI<>EBIU
:	----------------------------
P.BFR1
	LHI	R0,.SEGER		:PARAMETER FOR SEGMENTING ERROR (8007)
	J	P.T3R9			:JUMP TO CALL P.EXNR
:	NOT (FID=FID2 & DAFPRIME='FF' & OAFPRIME='00')
:	----------------------------------------------
P.BFR2
	LB	R1,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	P.BFR0			:JUMP,IF IT IS NOT SET (NOT BBIU)
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.CTG		:MASK OFF OTHER BITS
	CLHI	R4,MU.SC		:IS RU_CTGY=SC?
	JN	P.BFR0			:JUMP IF RU_CTGY<>SC
	LHL	R1,BBUFER+MUDCF,R10,	:GET DCF(R1) FROM MUCB
	CLHI	R1,4			:CHECK DCF WITH 4
	JGE	P.BFR0			:JUMP,IF DCF>=4
	LHI	R0,.RULER		:PARAMETER FOR RU LENGTH ERROR (1002)
	J	P.T3R9			:JUMP TO CALL P.EXNR
:	NOT (BBIUI=BBIU & MU_CTGY=SC & DCF<4)
:	-------------------------------------
P.BFR0
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.CTG		:MASK OFF OTHER BITS
	CLHI	R4,MU.SC		:IS RU_CTGY=SC?
	JN	P.BFR5			:JUMP IF RU_CTGY<>SC
:	RU_CTGY=SC,CHECK RQ_CODE TYPE
:	-----------------------------
	BBLOAD	R4,BBUFER+MURUPT,R10,	:GET RU BUFFER PTR
	LB	R0,BBUFER,R4,		:GET RQ_CODE FROM RU
	JAL	R4,R.SCSH,,		:SEARCH FOR RQ_CODE TYPE
	LHL	R4,P.BFRC,R2,R2
	J	P.BFRC,R4,
P.BFRC	HS
	HC	P.BFR6-P.BFRC		:RQ_CODE=ACTPU
	HC	P.BFR6-P.BFRC		:RQ_CODE=ACTLU
	HC	P.BFR6-P.BFRC		:RQ_CODE=BIND
	HC	P.BFR5-P.BFRC		:RQ_CODE=ACCDRM
	HC	P.BFR6-P.BFRC		:RQ_CODE=DACTPU
	HC	P.BFR6-P.BFRC		:RQ_CODE=DACTLU
	HC	P.BFR6-P.BFRC		:RQ_CODE=UNBIND
	HC	P.BFR5-P.BFRC		:RQ_CODE=DACDRM
	HC	P.BFR5-P.BFRC		:RQ_CODE=ERROR

:	NOT (RU_CTGY=SC & RQ_CODE=(ACTPU|DACTPU|ACTLU|DACTLU|BIND|UNBIND)
:	-----------------------------------------------------------------
P.BFR5
	LB	R0,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R0,MU.FID		:MASK OFF OTHER BITS
	SRHLS	R0,4			:GET PROPER LOCATION OF FID
	CLHI	R0,FID2			:IS FID FID2?
	JE	P.BFR8			:JUMP,IF FID=FID2
	CLHI	R0,FID3			:IS FID FID3?
	JE	P.BFR9			:JUMP,IF FID=FID3
P.BFRB
:	CHECK SCB EMPTY OR NOT?
:	-----------------------
	LHI	R0,.NOSES		:SET PARAMETER FOR NO SESSION (8005)
	J	P.T3R9			:JUMP TO CALL P.EXNR
:	FID=FID2,FIND SCB IN SCB_LIST
:	-----------------------------
P.BFR8
	J	P.BFRB
:	FID=FID3,FIND SCB IN SCB_LIST
:	-----------------------------
P.BFR9
	J	P.BFRB
:	SCB_PTR<>NULL,SEND MU TO BF.TC.RCV
:	-----------------------------------
P.BFRA
	LHI	R2,TCBFRV		:SET DESTINATION TO BF.TC.RCV
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,PCBFRV		:GET SENDING PROCEDURE #
	JAL	R13,P.RSEN,,		:CALL COMMON ROUTINE TO SEND MU
	JR	R14			:RETURN
:	(RU_CTGY=SC & RQ_CODE=(ACTPU|DACTPU|ACTLU|DACTLU|BIND|UNBIND)
:	-----------------------------------------------------------------
P.BFR6
	LB	R1,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	P.BFR1			:JUMP,IF IT IS NOT SET (NOT BBIU)
	LB	R1,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R1,MU.EIU		:CHECK THE EBIU INDICATOR
	JE	P.BFR1			:JUMP,IF IT IS NOT SET (NOT EBIU)
:	NOT (BBIUI<>BBIU | EBIUI<>EBIU) SEND MU TO PU.SVC_MGR.CSC_MGR.BF_RCV
:	-------------------------------
	LHI	R2,PMCSBR		:SET DEST. TO PU.SVC_MGR.CSC_MGR.BF_RCV
	J	P.BFR7
P.BFR4
:	DO WE NEED TO DISCARD BTU WHEN ERROR CONDITION>????????
:	OTHERS,BTU PTR'LL BE TREATED AS MU PTR
	JR	R14
	ELSE
	J	P.T2RV
	EI
P.VRSD
	IF	FN.BND			:IF BOUNBARY FUNCTION SUPPORT
	ELSE
	J	P.T2SD
	EI

	SUBTTL	PATH CONTROL LAYER (PU TYPE 1 PROCESSES)

	IF	FN.T1S			:INTERFACE SUPPORT T1 TYPE NODE
P.T1RV
P.T1SD
	J	P.CRAS			:CRASH,FOR THIS MOMENT
	ELSE
:	P.T1RV	-(PC_T1.RCV)
:	--------------------
P.T1RV
	J	P.T2RV
:	ASSUME P.VRSD,P.T1SD GOTO P.T2SD
:	---------------------------------
P.T1SD
	J	P.T2SD
	EI

	SUBTTL	PATH CONTROL LAYER (PU TYPE 2 PROCESSES)

:	P.T2RV	-(PC_T2.RCV) THIS PROCEDURE PROCESSES PIU'S RECEIVED AT
:	PU_T2 NODE AND ROUTES PUCP-PU BIU'S THAT FLOW INTERNAL TO A
:	PU_T2 NODE
:	1.INVALID PIU'S ARE DISCARDED OR RESULT IN A NEGATIVE RESPONSE
:	2.PU-PU FLOW PIU'S ARE ROUTED TO THE NETWORK SERVICES COMPONENT
:	  OR THE PU SERVICES MANAGER
:	3.BIU'S CONTAINING SESSION ACTIVATION|DEACTIVATION RU'S ARE
:	  ROUTED TO THE COMMON SESSION CONTROL MANAGER COMPONENT OF
:	  PU SERVICE MANAGER
:	4.IF SUPPORTED AND REQUIRED,BIU ASSEMBLY IS PERFORMED
:	5.FOR BIU'S DESTINED FOR A HALF-SESSION,THE HALF-SESSION IS 
:	  FOUND,IF POSSIBLE,AND THE BIU IS ROUTED TO TRANSMISSION CONTROL
:	  CONNECTION POINT MANAGER
:	PAGE 3-84 ON FAPL
:	-------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:R12 (PTR TO THE CURRENT ENVIRONMENT VECTOR)
:	OUTPUT	:
:	LINK	:R14
:	WORKING	:R15 (PCCB_PTR)
P.T2RV
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.BTU		:IS IT OUT OF RANGE (BTU IS ONLY)
	JN	P.CRAS			:JUMP,IF YES

P.T2R5
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NODE CONTROL BLOCK PTR
	LB	R4,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	CLHI	R4,PCT2SD		:IS IT PC_T2_SEND?
	JN	P.T2R0			:JUMP,IF IT IS NOT SEND BY PC_T2.SEND
:	IF DISPATCHED_BY(PC_T2.SEND)
:	-------------------------------
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU_PTR FROM EV
	THI	R10,BUFFLG		:IS BUFFER PTR VALID?
	JN	P.CRAS			:CRASH,IF NOT
	LHI	R0,RCV			:GET RECEIVE
	STB	R0,BBUFER+MUDIRE,R10,	:GET BYTE FROM MUCB
	BBLOAD	R4,BBUFER+MURUPT,R10,	:GET RU BUFFER PTR
	LB	R5,BBUFER,R4,		:GET RQ_CODE FROM RU
	CLHI	R5,ACTPU		:IS RQ_CODE=ACTPU
	JN	P.T2RF			:JUMP,IF RQ_CODE<>ACTPU
	LHI	R2,PMCSMR		:GET 'PU.SVC_MGR.CSC_MGR.RCV'
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NODE CONTROL BLOCK PTR
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB_PTR FROM NODE TABLE
	J	P.T2R8			:JUMP TO SEND MU TO PU.SVC
P.T2RF
	LHI	R4,SEC			:SET 'SEC' FOR SCB.HALF_SESSION CHK
	LB	R0,BBUFER+MUMISC,R10,	:GET MUCB.PUCP_BASED_SESSION
	NHI	R0,MU.PBS		:MASK FOR PUCP_BASED_SESSION
	CLHI	R0,MU.PUC		:IS IT PUCP_TO_PU
	JEFS	P.T2R.			:JUMP,IF PUCP_TO_PU
	LHI	R4,PRI			:SCB.HALF_SESSION NEEDS TO BE PRI
P.T2R.
	L	R1,NCBBLK+NDSCLS,R13,	:SCB_LIST (BIT#=0,FREE,BIT#=1,ASSIGNED)
	ST	R1,PCCSAV,,		:SAVE SCB_LIST IN SAVE AREA
:	COMPARE THE SCB.THIS_ID AND SCB_PARTNER_ID TO GET SCB
:	FIND SCB,SEND MU TO TC.CPMGR.RCV
:	------------------------------------------------------
P.T2RH
	L	R1,PCCSAV,,		:GET SCB_LIST SAVE DATA
	JFFO	R1,P.T2RG		:JUMP,ON FINDING SCB FREE
	J	P.CRAS			:SCAN END OF SCB_LIST
P.T2RG
:	(4/21/86/CHS)
:	IF FWSCB IS 1, SCBPTR'S ARE IN FULL-WORD
	LO	MAIN
	IF	FWSCB
	SLHLS	RNODE,1			:MAKE FW INDEX
	L	R9,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	SRHLS	RNODE,1
	ELSE
	LHL	R9,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	EI	(FWSCB)
	FO	MAIN
	RBT	R2,PCCSAV,,		:RESET CURRENT SCB INDEX IN SAVE AREA
	LHI	R8,SCLENG		:GET LENGTH OF SCB
	LR	R0,R2
	MHR	R0,R8
	AR	R9,R1
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION BIT INDICATOR
	NHI	R0,SC.SES		:MASK OFF OTHER BITS
	CR	R0,R4			:IS SCB.HALF_SESSION DESIRED?
	JN	P.T2RH			:JUMP,IF SCB.HALF_SESSION NOT DESIRED
	LB	R0,SCBBLK+SCSSTY,R9,	:GET TYPE_OF_SESSION FROM SCB
	CLHI	R0,PUCPPU		:IS IT PUCP-PU?
	JN	P.T2RH			:JUMP,IF SCB.TYPE_OF_SESSION<>PUCP_PU
	J	P.T2RE			:JUMP TO SEND MU TO TC.CPMGR.RCV
P.T2R0
	BBLOAD	R10,EVBLK+EVPRMP,R12,	:SET BTU_PTR=PARM_PTR
	LIS	R7,PU.T2		:SET UP INPUT PARAMETER
	JAL	R8,P.THRC,,		:CALL ROUTE_EXTENSION_TH_RCV_CHK
	J	P.T2R4			:JUMP,IF RETURN IS NOT OK
:	IF (ROUTE_EXTENSION_TH_RCV_CHK(PU_T2) OK,DO THE FOLLOWINGS
:	--------------------------------------------------------------
	JAL	R4,GBB,,		:GET BIG BUFFERLET FOR MUCB
	J	BUFCRA			:JUMP TO CRASH,IF NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
:	TO THIS POINT-
:	R3 (PTR TO THE MUCB) R10 (BTU PTR)
	LHL	R7,EVBLK+EVMULN,R12,	:GET PIU LENGTH
	JAL	R8,R.MTCN,,		:CALL MAP_TO_CANONICAL
	LHL	R15,PCBPTR,RNODE,RNODE	:GET PATH CONTROL BLOCK PTR
	LB	R4,PCBBLK+PCBAOP,R15,	:GET BIU_ASSEMBLY_OPTION
	JE	P.T2R1			:JUMP IF NO_ASSEMBLY
	CLHI	R4,STNASS		:IS THIS ONE STATION_ASSEMBLY?
	JE	P.T2R6			:YES,JUMP WHEN STATION_ASSEMBLY
	CLHI	R4,SESASS		:IS THIS ONE SESSION-ASSEMBLY?
	JN	P.T2R3			:JUMP,BIU_ASSEMBLY_OPTION IS ERROR
:	SESSION_ASSEMBLY OPTION
:	===============================
	LB	R4,BBUFER+MUDADP,R10,	:GET OAFPRIME FROM MUCB
	JN	P.T3RC			:JUMP IF DAFPRIME<>0
	LB	R4,BBUFER+MUOADP,R10,	:GET OAFPRIME FROM MUCB
	CLHI	R4,0FF			:IS OAFPRIME=0FF?
	JE	P.T3R6			:DAFPRIME=0 AND OAFPRIME=0FF,JUMP
P.T3RC
	LB	R1,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
:NEXT LINE USED TO BE JE P.T3RA. 8/3/84 MIA.
	JE	P.T3RD			:JUMP,IF IT IS NOT SET (NOT BBIU)
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.CTG		:MASK OFF OTHER BITS
	CLHI	R4,MU.SC		:IS RU_CTGY=SC?
	JN	P.T3RA			:JUMP IF RU_CTGY<>SC
	LHL	R1,BBUFER+MUDCF,R10,	:GET DCF(R1) FROM MUCB
	CLHI	R1,4			:CHECK DCF WITH 4
	JGE	P.T3RA			:JUMP,IF DCF>=4
	LHI	R0,.RULER		:PARAMETER FOR RU LENGTH ERROR (1002)
	J	P.T3R9			:JUMP TO CALL P.EXNR
P.T3RA
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.CTG		:MASK OFF OTHER BITS
	CLHI	R4,MU.SC		:IS RU_CTGY=SC?
	JN	P.T3RD			:JUMP IF RU_CTGY<>SC
:	RU_CTGY=SC,CHECK RQ_CODE TYPE
:	-----------------------------
	BBLOAD	R4,BBUFER+MURUPT,R10,	:GET RU BUFFER PTR
	LB	R0,BBUFER,R4,		:GET RQ_CODE FROM RU
	JAL	R4,R.SCSH,,		:SEARCH FOR RQ_CODE TYPE
	LHL	R4,P.T3R0,R2,R2
	J	P.T3R0,R4,
P.T3R0	HS
	HC	P.T3R7-P.T3R0		:RQ_CODE=ACTPU
	HC	P.T3R7-P.T3R0		:RQ_CODE=ACTLU
	HC	P.T3R7-P.T3R0		:RQ_CODE=BIND
	HC	P.T3RD-P.T3R0		:RQ_CODE=ACCDRM
	HC	P.T3R7-P.T3R0		:RQ_CODE=DACTPU
	HC	P.T3R7-P.T3R0		:RQ_CODE=DACTLU
	HC	P.T3R7-P.T3R0		:RQ_CODE=UNBIND
	HC	P.T3RD-P.T3R0		:RQ_CODE=DACDRM
	HC	P.T3RD-P.T3R0		:RQ_CODE=ERROR

:	NOT (RU_CTGY=SC & RQ_CODE=(ACTLU|DACTLU|BIND|UNBIND)
:	----------------------------------------------------
P.T3RD
:	COMPARE THE SCB.THIS_ID AND SCB_PARTNER_ID TO GET SCB
:	FIND SCB,SEND MU TO TC.CPMGR.RCV
:	------------------------------------------------------
	LB	R4,BBUFER+MUDADP,R10,	:GET DAFPRIME
	LB	R3,BBUFER+MUOADP,R10,	:GET OAFPRIME
	JAL	R7,V.SCSC,,		:CALL SCB_LIST SCANNER
:	(SCB.THIS_ID=DAFPRIME & SCB.PARTNER_ID=OAFPRIME) FOR THIS SCB(R9)
:	-------------------------------------------------------------
:	CHECK SCB EMPTY OR NOT?
	LR	R9,R9			:CHECK SCB_PTR NULL?
	JL	P.T2RB			:JUMP,SCB_PTR=NULL
	JAL	R8,P.SSBM,,		:CALL SESSION_BIU_ASSEMBLER
	LR	R0,R0			:GET RETURN CODE
	JE	P.T3R5			:IF,RETURN CODE IS NO,CRASH???
	LHI	R2,TCCMRV		:GET 'TC.CPMGR.RCV' PROC. #
	J	P.T2R8			:JUMP TO SEND MU
:	RECEIVING SEGEMENTING ERROR
:	---------------------------
P.T3R5
	J	P.CRAS			:CRASH FOR TESTING
	LHI	R1,PCT2RV		:SETUP SENDING PROCESS
	JAL	R4,U.RCKP,,		:CALL UPM_RECEIVE_CHECKS
	JR	R14			:RETURN

:	RU_CTGY=SC & RQ_CODE=(ACTPU|ACTLU|DACTPU|DACTLU|BIND|UNBIND)
:	------------------------------------------------------------
P.T3R7
	LB	R1,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	P.T3R8			:JUMP,IF IT IS NOT SET (NOT BBIU)
	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.EIU		:CHECK THE EBIU INDICATOR
	JN	P.T2R7			:JUMP,IF IT IS SET
:	IF BBIUI<>BBIU | EBIUI<>EBIU
:	----------------------------
P.T3R8
	LHI	R0,.SEGER		:PARAMETER FOR SEGMENTING ERROR (8007)
P.T3R9
	JAL	R4,P.EXNR,,		:CALL ROUTE_EXTENSION_NEG_RSP
	JR	R14			:RETURN
:	DAFPRIME=0 AND OAFPRIME=0FF, SEND MU TO PU.SVC_MGR.NS.RCV
:	-------------------------------------------------------
P.T3R6
	LB	R1,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	P.T3R8			:JUMP,IF IT IS NOT SET (NOT BBIU)
	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.EIU		:CHECK THE EBIU INDICATOR
	JE	P.T3R8			:JUMP,IF IT IS NOT SET (NOT EBIU)
:	NOT (BBIUI<>BBIU | EBIUI<>EBIU) SEND MU TO PU.SVC_MGR.NS.RCV
:	-------------------------------
	J	P.T2R9			:JUMP TO SEND MU TO PU.SVC_MGR.NS.RCV

:	WHEN (NO_ASSEMBLY)
:	==================
P.T2R1
	JAL	R8,P.NBAR,,		:CALL T1_OR_T2_NO_BIU_ASSEMBLY_RCV_OK
	J	P.T2R3			:JUMP IF RCV NOT OK
P.T2RJ
	LB	R4,BBUFER+MUDADP,R10,	:GET OAFPRIME FROM MUCB
	JN	P.T2RC			:JUMP IF DAFPRIME<>0
	LB	R4,BBUFER+MUOADP,R10,	:GET OAFPRIME FROM MUCB
	CLHI	R4,0FF			:IS OAFPRIME=0FF?
	JE	P.T2R9			:DAFPRIME=0 AND OAFPRIME=0FF,JUMP
P.T2RC
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.CTG		:MASK OFF OTHER BITS
	CLHI	R4,MU.SC		:IS RU_CTGY=SC?
	JN	P.T2RD			:JUMP IF RU_CTGY<>SC
:	RU_CTGY=SC,CHECK RQ_CODE TYPE
:	-----------------------------
	BBLOAD	R4,BBUFER+MURUPT,R10,	:GET RU BUFFER PTR
	LB	R0,BBUFER,R4,		:GET RQ_CODE FROM RU
	JAL	R4,R.SCSH,,		:SEARCH FOR RQ_CODE TYPE
	LHL	R4,P.T3R1,R2,R2
	J	P.T3R1,R4,
P.T3R1	HS
	HC	P.T2R7-P.T3R1		:RQ_CODE=ACTPU
	HC	P.T2R7-P.T3R1		:RQ_CODE=ACTLU
	HC	P.T2R7-P.T3R1		:RQ_CODE=BIND
	HC	P.T2RD-P.T3R1		:RQ_CODE=ACCDRM
	HC	P.T2R7-P.T3R1		:RQ_CODE=DACTPU
	HC	P.T2R7-P.T3R1		:RQ_CODE=DACTLU
	HC	P.T2R7-P.T3R1		:RQ_CODE=UNBIND
	HC	P.T2RD-P.T3R1		:RQ_CODE=DACDRM
	HC	P.T2RD-P.T3R1		:RQ_CODE=ERROR

:	NOT (RU_CTGY=SC & RQ_CODE=(ACTLU|DACTLU|BIND|UNBIND)
:	----------------------------------------------------
P.T2RD
:	COMPARE THE SCB.THIS_ID AND SCB_PARTNER_ID TO GET SCB
:	FIND SCB,SEND MU TO TC.CPMGR.RCV
:	------------------------------------------------------
	LB	R4,BBUFER+MUDADP,R10,	:GET DAFPRIME
	LB	R3,BBUFER+MUOADP,R10,	:GET OAFPRIME
	JAL	R7,V.SCSC,,		:CALL SCB_LIST SCANNER
:	(SCB.THIS_ID=DAFPRIME & SCB.PARTNER_ID=OAFPRIME) FOR THIS SCB(R9)
:	-------------------------------------------------------------
:	CHECK SCB EMPTY OR NOT?
	LR	R9,R9			:CHECK SCB_PTR NULL?
	JGE	P.T2RE			:JUMP,SCB_PTR<>NULL
:	SCB_PTR=NULL,CALL ROUTE_EXTENSION_NEG_RSP(X'8005')
:	--------------------------------------------------
P.T2RB
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH (11/6/84 MIA)
	THI	R0,MU.RRI		:RSP? (11/6/84 MIA)
	JN	P.DSCR			:JUMP TO DISCARD IF SO (11/6/84 MIA)
	LHI	R0,.NOSES		:SET PARAMETER FOR NO SESSION (8005)
	J	P.T3R9			:JUMP TO CALL P.EXNR
P.T2RE
	LHI	R2,TCCMRV		:GET 'TC.CPMGR.RCV' PROC. #
P.T2R8
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,PCT2RV		:GET SENDING PROCEDURE #
	JAL	R13,P.RSEN,,		:CALL COMMON ROUTINE TO SEND MU
	JR	R14			:RETURN AFTER SEND MU

:	NOT (BBIUI<>BBIU | EBIUI<>EBIU) SEND MU TO PU.SVC_MGR.CSC.RCV
:	RU_CTGY=SC & RQ_CODE=(ACTLU|DACTLU|BIND|UNBIND)
:	SEND MU TO PU.SVC_MGR.CSC_MGR.RCV
:	------------------------------------------------
P.T2R7
	LHI	R2,PMCSMR		:GET 'PU.SVC_MGR.CSC_MGR.RCV'
	LCS	R9,1			:INIT SCB_PTR (TO NULL)
	J	P.T2R8

:	DAFPRIME=0 AND OAFPRIME=0FF, SEND MU TO PU.SVC_MGR.NS.RCV
:	-------------------------------------------------------
P.T2R9
	LHI	R2,PMNSMR		:GET 'PU.SVC_MGR.NS.RCV'
	LCS	R9,1			:INIT SCB_PTR (TO NULL)
	J	P.T2R8

:	WHEN (STATION_ASSEMBLY)
:	=======================
:	CHECK BIU_ASSEMBLER_RESULT IS OK OR NOT?????
P.T2R6
	J	P.T2RJ			:JUMP,IF BIU ASSEMBLER_RESULT IS OK 

:	IF (ROUTE_EXTENSION_TH_RCV_CHK(PU_T2) NOT OK,DELETE BTU BUFFER
:	--------------------------------------------------------------
P.T2R4
:	DELETE NEXT CRASH INST. AFTER DEBUGING
	J	P.CRAS			:JUMP TO CRASH,FOR DEBUG
	LR	R3,R10			:GET BUFFER PTR (BTU_PTR)
	JAL	R4,PBB,,		:RELEASE BUFFER PTR
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	JR	R14			:RETURN TO CALLING DISPATCHER
:	AFTER GET MU_PTR,AND ERROR CONDITION (DISCARD MU)
:	---------------------------------------
P.T2R3
	JAL	R8,R.DSMU,,		:CALL DISCARD MU ROUTINE
	JR	R14			:RETURN

:	P.T2SD	-(PC_T2.SEND) THIS PROCEDURE SENDS PIU'S FROM A PU_T2
:	NODE AND ROUTES PUCP-PU BIU'S THAT FLOW INTERNAL TO A PU_T2 NODE.
:	(1) PUCP-PU BIU'S ARE ROUTED TO PC_T2.RCV
:	(2) THE INPUT MU IS DISCARDED,IF THE ADJACENT LINK STATION
:	    IS INOPERATIVE.
:	(3) THE PIU IS ENQUEUED ON THE ADJACENT LINK STATION BTU SEND LIST
:	    FOR A PU-PU FLOW PIU FROM THE NS OF THE PU.SVC_MGR
:	(4) THE PIU IS ENQUEUED ON THE ADJACENT LINK STATION BTU SEND LIST
:	    FOR A BIU CONTAINING A SESSION ACTIVATION|DEACTIVATION RU FROM
:	    THE CSC OF THE PU.SVC_MGR
:	(5) THE PIU IS ENQUEUED ON THE ADJACENT LINK STATION BTU SEND LIST
:	    FOR A BIU FROM TG.CPMGR THE BIU MAY BE SEGMENTED INTO MULTIPLE
:	    PIU'S.
:	PAGE 3-86 ON FAPL
:	----------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:SCB_PTR,MU_PTR ARE ESTABLISHED,R12 (EV PTR)
:	OUTPUT	:
:	LINK	:R14
:	WORKING	:R9 (SCB_PTR) R10 (MU_PTR) R12 (EV_PTR) R13 (NCB_PTR)
:		 R15 (PCCB_PTR)
P.T2SD
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.NOS		:IS IT OUT OF RANGE (NO_SIGNAL)
	JN	P.CRAS			:JUMP IF NOT NO_SIGNAL

P.T2S9
	LHL	R15,PCBPTR,RNODE,RNODE	:GET PATH CONTROL BLOCK PTR
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NODE CONTROL BLOCK PTR
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU_PTR FROM EV
	THI	R10,BUFFLG		:IS BUFFER PTR VALID?
	JN	P.CRAS			:CRASH,IF NOT
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB_PTR FROM NODE TABLE
	JLE	P.T2S2			:JUMP,IF SCB_PTR=NULL
	LB	R0,SCBBLK+SCSSTY,R9,	:GET TYPE_OF_SESSION FROM SCB
	CLHI	R0,PUCPPU		:IS IT PUCP-PU?
	JN	P.T2S2			:JUMP,IF IT'S NOT
:	SCB_PTR<>NULL & SCB.TYPE_OF_SESSION=PUCP_PU
:	----------------------------------------------
	LHI	R0,MU.PUC		:SET INIT VALUE TO PUCP_TO_PU
	LB	R4,SCBBLK+SCACFG,R9,	:GET HALF_SESSION BIT INDICATOR
	NHI	R4,SC.SES		:MASK OFF OTHER BITS
	JNFS	P.T2S1			:JUMP,SCB.HALF_SESSION=PRIMARY
	LHI	R0,MU.PUT		:SET TO PU_TO_PUCP
P.T2S1
	LB	R1,BBUFER+MUMISC,R10,	:GET DESIRED BYTE
	OR	R1,R0
	STB	R1,BBUFER+MUMISC,R10,	:SET PUCP_BASED_SESSION
	LHI	R2,PCT2RV		:SET UP PC_T2.RCV  DESTINATION
	LHI	R1,PCT2SD		:THE SEND PROCEDURE IS P.T2SD
	LHI	R0,SG.NOS		:CLEAR THE INPUT SIGNAL
	JAL	R13,P.RSEN,,		:CALL COMMON ROUTINE TO SEND MU
	JR	R14			:RETURN

:	NOT (SCB_PTR<>NULL & SCB.TYPE_OF_SESSION=PUCP_PU)
:	----------------------------------------------
P.T2S2
:	LIS	R2,0
:	LB	R1,NCBBLK+NDLSNM,R13,	:GET NUMBER OF LSCB IN THIS NODE
:	L	R15,NCBBLK+NDLSLS,R13,	:GET LSCB_LIST PTR FROM NCB
:P.T2S3
:	LB	R0,LSCBTY,R15,		:GET LSCB_TYPE
:	CLHI	R0,ALS			:IS THIS LSCB-TYPE=ALS?
:	JE	P.T2S4			:JUMP,IF YES
:	AIS	R2,1			:UPDATE PROCESSING LSCB NUMBER
:	CR	R2,R1			:IS ALL LSCB BEING CHECKED?
:	JGE	P.CRAS			:JUMP TO CRASH,IF NOT FIND LSCB
:	AHI	R15,LSLENG		:GET NEXT LSCB PTR
:	J	P.T2S3			:CHECK NEXT LSCB
:	FIND LSCB IN LSCB_LIST (LSCB.LSCB_TYPE=ALS) NOT IMPLEMEN AS FAPL????
:	-------------------------------------------
P.T2S4
	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	P.T2S6			:JUMP,IF IT IS NOT SET (NOT BBIU)
	JAL	R4,U.PAOC,,		:CALL UPM_ALS_OPERATIVE_CHECK
	J	P.T2S5			:JUMP,IF NOT OPERATIVE
	LB	R4,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	CLHI	R4,PMNSMR		:IS IT PU.SVC_MGR.NS.RCV?
	JE	P.T2S6			:JUMP,IF EQUAL
	CLHI	R4,PMNSMS		:IS IT PU.SVC_MGR.NS.SEND?
	JE	P.T2S6			:JUMP,IF EQUAL
:	WE ASSUME NIO/SVC_MGR HAVE DONE PRE_SEGMENTING,SKIP ....
:	--------------------------------------------------------
:	LB	R1,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
:	OHI	R1,MU.BIU		:SET BBIUI=BBIU
:	OHI	R1,MU.EIU		:SET EBIUI=EBIU
:	STB	R1,BBUFER+MUBIUF,R10,	:STORE NEW VALUE INTO MU
:	JAL	R4,GETCL,,		:GET COMMAND LIST
:	J	P.CRAS			:CRASH,IF EMPTY
:	LHL	R13,PCBPTR,RNODE,RNODE	:GET PATH CONTROL BLOCK PTR
:	LHL	R7,PCBBLK+PCPUSR,R13,	:GET PUT PTR
:	LIS	R0,0
:	STH	R0,CMDBLK,R7,		:STORE INIT VALUE
:	ST	R10,CMDBLK+CLARG,R7,	:STORE MU_PTR
:	STH	R6,CMDBLK+CLPTR,R7,	:LINK NEW ENTRY
:	STH	R6,PCBBLK+PCPUSR,R13,	:UPDATE NEW RELEASE PTR
:P.T2S8
:	LHL	R6,PCBBLK+PCPUSG,R13,	:GET GET PTR
:	CLH	R6,PCBBLK+PCPUSR,R13,	:IS EMPTY?
:	JER	R14			:EMPTY,RETURN
:	LHL	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR
:	JE	P.CRAS			:CRASH,IF NO NEXT CMDLST
:	STH	R7,PCBBLK+PCPUSG,R13,	:SET GET PTR
:	BBLOAD	R10,CMDBLK+CLARG,R6,	:GET MU_PTR
:	JAL	R4,RELCL,,		:RELEASE CMDLST
	LB	R0,BBUFER+MUBIUF,R10,	:GET FID (R0) FROM MUCB
	NHI	R0,@MU.FID		:RESET FID FIELD TO NULL
	LHI	R1,FID2			:GET FID TYPE FID2
	SLHLS	R1,4			:SET FID2 TO PROPER POSITION
	OR	R0,R1			:SET FID2 TO THE FIELD IN MU
	STB	R0,BBUFER+MUBIUF,R10,
	LB	R4,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	CLHI	R4,TCCMRV		:IS IT TC.CPMGR.RCV?
	JE	P.T2S7			:JUMP,IF EQUAL
	CLHI	R4,TCCMSD		:IS IT TC.CPMGR.SEND?
	JE	P.T2S7			:JUMP,IF EQUAL
	JAL	R3,P.PISD,,		:CALL ROUTE_EXTENSION_PIU_SEND
	JR	R14			:RETURN
:	IF DISPATCHED_BY (TC.CPMGR.*)
:	---------------------------------
P.T2S7
	LB	R4,SCBBLK+SCOTID,R9,	:GET PARTNER_ID FROM SCB
	STB	R4,BBUFER+MUDADP,R10,	:SET DAFPRIME TO SCB.PARTNER_ID
	LB	R4,SCBBLK+SCMYID,R9,	:GET SCB.THIS_ID
	STB	R4,BBUFER+MUOADP,R10,	:SET OAFPRIME TO SCB.THIS_ID
	JAL	R3,P.PISD,,		:CALL ROUTE_EXTENSION_PIU_SEND
	JR	R14			:RETURN
:	IF UPM_ALS_OPERATIVE_CHECK<>OPERATIVE, DISCARD MU
:	-----------------------------------------------------
P.T2S5
	JAL	R8,R.DSMU,,		:CALL DISCARD MU ROUTINE
	JR	R14			:RETURN
:	IF DISPATCHED_BY (PU.SVC_MGR.NS.*)
:	-----------------------------------
P.T2S6
	JAL	R3,P.PISD,,		:CALL ROUTE_EXTENSION_PIU_SEND
	JR	R14

P.RSEN
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	BUFCRA			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	ST	R9,BBUFER+DQSCB,R3,	:STORE SCB PTR INTO DQE
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	STH	R7,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO 'NULL'
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	STB	R7,BBUFER+DQNWCM,R3,	:CLEAR DQNWCM
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	JR	R13			:RETURN

	SUBTTL	PATH CONTROL LAYER (ROUTING PROTOCOL MACHINES)

:	P.VDQV	-(PC_SA.VRC.DEQ.Q_VR_PAC)
:	-----------------------------------
P.VDQV
:	P.VRPS	-(PC_SA.VRC.VRPRS_SEND)
:	-------------------------------
P.VRPS

:	P.TDQR	-(PC.TGC.DEQ_Q_BTU_RCV) THIS PROCEDURE IS DISPATCHED
:	WHEN AN OPEN SIGNAL IS SENT TO IT FROM THE HIGH-LEVEL 
:	SCHEDULER.
:	PAGE 3-39 ON FAPL
:	-------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:R12 (EV PTR)
:	OUTPUT	:
:	LINK	:
:	WORKING	:R10 (BTU) R9 (TGCB PTR) R13 (NCB PTR)
P.TDQR
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NODE CONTROL BLOCK PTR
	L	R9,NCBBLK+NDTGCB,R13,	:GET TGCB_PTR FROM NODE TABLE
:	LOCK AND UNLOCK STATEMENTS NEED TO BE IMPLEMENTED?????
	LHL	R7,TGBBLK+TGQBRG,R9,	:GET GET PTR TO Q_BTU_RCV
:	CLH	R7,TGBBLK+TGQBRR,R9,	:COMP GET TO RL (01/02/85 MIA)
	LHL	R4,TGBBLK+TGQBRR,R9,	:GET REL PTR (01/02/85 MIA)
	CR	R7,R4			:COMP THEM (01/02/85 MIA)
	JE	P.TDQ1			:NOTHING IN QUEUE,ERROR
	BBLOAD	R10,CMDBLK+CLARG,R7,	:GET BUFFER PTR FOR BTUCB+BTU
	LH	R4,CMDBLK,R7,		:GET BYTE COUNT FOR BTUCB+BTU
:	REMOVE FIRST(BTU) FROM PCCB.Q_BTU_RCV SET(BTU_PTR)
	LH	R6,CMDBLK+CLPTR,R7,	:CHECK NEXT QUEUE PTR
	JE	CLERR,,			:COMMAND LIST ERROR
	STH	R6,TGBBLK+TGQBRG,R9,	:UPDATE NEW GET PTR
	LHI	R2,PCTGCR		:SET UP PC.TGC.RCV DESTINATION
	JAL	R4,GBB,,		:CREATE NEW DQE (R3 IS NEW DQE)
	J	BUFCRA			:CRASH,IF NO ENTITY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LHI	R1,PCTGQR		:THE SEND PROCEDURE IS P.TDQR
	LHI	R0,SG.BTU		:THE INPUT SIGNAL
:	PARM_PTR=BTU_PTR IN DQE
	BBSTOR	R10,BBUFER+DQPRMP,R3,	:SET UP PARAMETER ENTITY
	ST	R9,BBUFER+DQTGCB,R3,	:SETUP TGCB PTR
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	ST	R7,BBUFER+DQSCB,R3,	:SET SCB PTR TO 'NULL'
	JAL	R8,SEND,,		:JUMP TO EXECUTE 'SEND' STATEMENT
	JR	R14			:RETURN
P.TDQ1
	J	BUFCRA

:	P.TGRV	-(PC.TGC.RCV) THIS PROCEDURE IS DISPATCHED WHEN A BTU
:	IS SENT TO IT FROM PC.TGC.DEQ_Q_BTU_RCV
:	1.IF DEBLOCKING IS SUPPORTED AND REQUIRED, THE BTU IS DEBLOCKED
:	  INTO INDIVIDUAL PIU'S
:	2.IF TG TRACE IS ACTIVE FOR THE TG,A TRACE OF EACH PIU IS
:	  PROVIDED
:	3.IF THE TG IS A SINGLE-LINK TG AND THE ADJACENT SUBAREA NODE
:	  SUPPORTS ER AND VR PROTOCOLS,THE PIU'S ARE SENT TO PC.ERC
:	4.IF THE TG IS A SINGLE-LINK TG AND THE ADJACENT SUBAREA NODE
:	  DOES NOT SUPPORT ER AND VR PROTOCOLS, THE PIU'S ARE CONVERTED
:	  FROM EITHERFID1 OR FID0 TO FID4 AND SENT TO PC.ERC
:	5.IF THE TG IS MULTIPLE-LINK TG (ADJACENT SUBAREA NODE SUPPORTS
:	  ER AND VR PROTOCOLS),THEN
:	PAGE 3-40 ON FAPL
:	-------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:
:	OUTPUT	:
:	LINK	:
:	WORKING	:
P.TGRV
	BBLOAD	R10,EVBLK+EVPRMP,R12,	:SET BTU_PTR=PARM_PTR
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NODE CONTROL BLOCK PTR
	L	R15,NCBBLK+NDTGCB,R13,	:GET TGCB_PTR FROM NODE TABLE
	LIS	R13,0			:INIT PROCESSED_BYTE_CNT
:	BTU_PTR (R10),BYTE_CNT (R13)
:	TGCB PTR (R15)
:	---------------------------------------------------------
P.TGR0
	JAL	R4,GBB,,		:GET BIG BUFFERLET FOR MUCB
	J	BUFCRA			:JUMP TO CRASH,IF NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
:	TO THIS POINT- R9 (BTU DATA BUFFER PTR)
:	R3 (PTR TO THE MUCB) R10 (BTU PTR)
:	--------------------------------
	LHL	R7,EVBLK+EVMULN,R12,	:GET PIU LENGTH
	JAL	R8,R.MTCN,,		:CALL MAP_TO_CANONICAL
	JAL	R8,P.LNPU,,		:CALL LENGTH_OF_PIU
:	R1 WHICH RETURNS FROM LENGTH_OF_PIU CONTAINS PIU_LENGTH
:	-------------------------------------------------------
	LB	R0,TGBBLK+TGTRFG,R15,	:GET TG_TRACE BYTE
	NHI	R0,TG.TRA		:MASK OFF OTHER BITS
	JEFS	P.TGR3			:JUMP,IF TGCB.TG_TRACE<>TRACE
:	IF TGCB.TG_TRACE=TRACE THEN CALL UPM_TG_TRACE('RCV')?????
:	---------------------------------------------------------
	LHI	R0,RCV
	JAL	R4,U.TGTR,,		:CALL UPM_TG_TRACE
P.TGR3
	LB	R0,TGBBLK+TGFFLG,R15,	:GET TG_FUNCTIONAL_ATTRIBUTE
	NHI	R0,TG.PEV		:MASK BITS FOR ER_VR_SUPP
	JE	P.TGR1			:JUMP,IF ER_VR_SUPP<>PRE_ER_VR
:	TGCB.ER_VR_SUPP=PRE_ER_VR
:	--------------------------
:	CALL CONVERT_FID1_OR_FID0_TO_FID4?????
:	SEND MU TO PC.ERC?????
	J	P.TGR2
:	TGCB.ER_VR_SUPP<>PRE_ER_VR
:	---------------------------
P.TGR1
:	UPDATE LINK_PIU_PTR AND PROCESSED_BYTE_CNT
:	------------------------------------------
P.TGR2
	AR	R9,R1			:LINK_PIU_PTR=LINK_PIU_PTR+PIU_LENGTH
	AR	R13,R1			:UPDATE PROCESS_BYTE_CNT+PIU_LENGTH
	CLH	R13,EVBLK+EVMULN,R12,	:PROCESSED_BYTE_CNT=BTUCB.BTU_LENGTH?
	JN	P.TGR0			:JUMP,IF NOT EQUAL
	JR	R14			:ELSE,RETURN

:: PATH CONTROL DISCARD. USED IF RSP RECEIVED FOR PU_T2 AND NO SESSION
::  IS ACTIVE (11/6/84 MIA).
P.DSCR	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO BUF CHAIN (11/6/84 MIA)
	JEFS	P.DSC1			:JUMP IF NO CHAIN (11/6/84 MIA)
	JAL	R5,R.PBRC,,		:RELASE BUFFERS (11/6/84 MIA)
P.DSC1	LR	R3,R10			:COPY MUCB POINTER (11/6/84 MIA)
	JAL	R4,PBB,,		:RELEASE IT (11/6/84)
	JAL	R4,R.PBB,,		:COPY IT (11/6/84)
	JR	R14			:AND RETURN (11/6/84 MIA)

BUFCRA
	JAL	R10,CRASH,,
	BC	0,0,0,CRQRES

	FO	CBKDEF
	FO	CMDLST
	FO	BBUFER
	FO	GBLDEF

	EM
 
	SUBTTL	SNA UNDEFINED PROTOCOL MACHINES (TRANSMISSION LAYER)
:	MODULE NAME IN COMMAND FILE -- STUP02.F00

:	*************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	*****************************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT THE UNDEFINED PROTOCOL
:	MACHINES(UPM) IN THE SNA FAPL MANUAL FOR TRANSMISSION LAYER.
:	-----------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF

	SEG	A.CODE

:	PAGE 4-34 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:NORMAL RETURN IF NOT FULL,SKIP RETURN IF FULL
:	LINK	-R4
U.PQFU
	JR	R4			:NORMAL RETURN,IF QUEUE IS NOT FULL
	J	4,R4			:SKIP RETURN,IF QUEUE IS FULL

:	PAGE 4-34 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:NORMAL RETURN IF NOT GOOD,SKIP RETURN IF GOOD
:	LINK	-R4
U.ENCI
	J	4,R4			:SKIP RETURN,IF GOOD
	JR	R4			:NORMAL RETURN,IF NOT GOOD
:	U.RESO	-(UPM__RESOURCES) DETERMINE WHETHER THERE ARE ENOUGH
:	RESOURCES TO SEND A PACING RESPONSE
:	PAGE 4-59 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:NORMAL RETURN IF NOT GOOD,SKIP RETURN IF GOOD
:	LINK	-R4
U.RESO
	J	4,R4			:SKIP RETURN,IF GOOD
	JR	R4			:NORMAL RETURN,IF NOT GOOD

:	U.IDEX	-(UPM_ID_EXP) GENERATES A UNIQUE 16-BIT ID FOR THE SESSION
:	PAGE 4-42 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:R1 CONTAINS 16-BIT ID
:	LINK	-R4
U.IDEX
	LHL	R1,SCBBLK+SCRESN,R9,	:GET SCB.RCV_EXP_SNF
	AIS	R1,1
	STH	R1,SCBBLK+SCRESN,R9,	:UPDATE SCB.RCV_EXP_SNF
	JR	R4			:NORMAL RETURN,IF NOT GOOD

:	U.ULOG	-UPM_LOG (UNEXPECTED PACING RQ RECEIVED)
:	ON PAGE B-23 ON FAPL
:	------------------------------------------------
U.ULOG
	JR	R4			:RETURN

	FO	CMDLST
	FO	CBKDEF

	EM


	SUBTTL	FINITE STATE MACHINES (TRANSMISSION LAYER)
:	MODULE NAME IN COMMAND FILE -- STCF00.F00

:	*************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN
:	10 MARCH 1984 (DB) -- ORIGINAL CODING
:	***********************************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT FSM FUNCTIONS OF SNA
:	TRANSMISSION CONTROL LAYER (WHCIH DESCRIBED IN CHAPTER 4)
:	-----------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF



	SEG	A.CODE

:	THE FOLLOWING FUNCTIONS ARE DESIGNED TO SUPPORT FSM FOR
:	SNA TC LAYERS WHICH ARE DESCRIBED ON FAPL
:	----------------------------------------------------------

:	FSMTBL	-FSMTBL IS THE OFFSET TABLE FOR TCCB FSM ROUTINES
:	THE INDEX TO THIS TABLE NEEDS TO BE SETUP BEFORE THIS TABLE
:	BEING CALLED.
:	THE CONVENTION FOR THE FSM ROUTINES IS FXYYZZ, WHERE:
:	X INDICATES THE CONTROL BLOCK WHERE THE FSM ROUTINES LOCATED,
:	YY INDICATES THE INDEX (DECIMAL) FOR THAT FSM
:	ZZ IS LABEL (FROM 0 TO ZZ) USED BY PARTICULAR FSM.
:	THE CONVENTION FOR THE FSM ACTION CODE ROUTINES IS FXAYYZ,WHERE:
:	X  INDICATES THE CONTROL BLOCK USED BY THE ACTION CODE ROUTINE,
:	A  INDICATES SNA LAYER (P, T, D, S OR C FOR COMMON) WHICH
:	   PRIMARILY USES THIS ACTION CODE ROUTINE,
:	YY INDICATES PARTICULAR ACTION CODE ROUTINE (DECIMAL), AND
:	Z  IS LABEL (FROM 0 TO Z) USED BY ACTION CODE ROUTINE.
:	------------------------------------------------------------

FSMTBL	HS	0
	HC	FTNOOP-F.CODE		:NO-OP (NO FSMS ARE REQUIRED)
	HC	FT0000-F.CODE		:FSM_PAC_RQ_SEND
	HC	FT0100-F.CODE		:FSM_PAC_RQ_RCV

FTNOOP
	JR	R3


	SUBTTL	FSM_PAC_RQ_SEND
:*******************************************************************
:	FT000	- (FSM_PAC_RQ_SEND) RECORDS THE ABILITY TO SEND A
:		SESSION LEVEL PACING REQUEST FOR SEND PACING. RESET
:		STATE INDICATES THAT A PACING REQUEST CAN BE SENT.
:		AWAITING_PAC_RSP INDICATES THAT A PACING REQUEST HAS
:		BEEN SENT BUT NO RESPONSE HAS BEEN RECEIVED.
:		PAGE 4-60 IN FAPL
:		--------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM SIGNAL INPUT, OPTION), R1 (INDEX FOR
:			FSM STATE INFO IN TCCB), R2 (MU_DIRECTION),
:			R4 (RQ OR RSP), R7 (FSM STATE VALUE), R10 (MU_PTR)
:			R15(TCCB ENTRY), R6 (FUNCTION OR CALL)
:		OUTPUT:
:		LINK:	R3
:		WORKING:

FT0000
	FS.MC1(FTCPRS,FS.TCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FT0004			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:===================================================================
:	INPUT:	'RESET'
:===================================================================	
FT0002
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FTT000,,		:YES, ACTION= -
	J	FTT010,,		:NO, ACTION = 1

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:----------------------------------------------
FT0004
	LR	R2,R2			:SEND OR RCV?
	JE	FT0006			:SEND
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.PI		:PACING INDICATOR SET?
	JE	FS.CPI,,		:NO, -PAC SO CRACH

:=====================================================================
:	INPUT:	R, RSP, PAC
:=====================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FTT050,,		:YES, ACTION = >(PACERR)
	J	FTT060,,		:NO, ACTION = 1(PACRSP)

:	CHECK FOR SEND INPUT
:---------------------------------
FT0006
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH
: CHECK IF FIRST_IN_WINDOW
:    FIRST_IN_WINDOW = TRUE IF TCCB.PACING_COUNT=TCCB.WINDOW_SIZE
	LHL	R0,TCBBLK+TCPGCT,R15,	:GET PAC_COUNT
	CLH	R0,TCBBLK+TCWDSZ,R15,	:FIRST_IN_WINDOW?
	
:=================================================================
:	INPUT:	S, RQ, -FIRT_IN_WINDOW
:=================================================================
	JN	FTT040,,		:NO, ACTION = -(NOPAC)

:=================================================================
:	INPUT:	S, RQ, FIRST_IN_WINDOW
:=================================================================
	CLHI	R7,FS.ST1		:YES, RESET STATE?
	JE	FTT030,,		:YES, ACTION = 2(PACRQ)
	J	FS.CIN,,		:NO, ACTION = /

	SUBTTL	FSM_PAC_RQ_RCV
:*****************************************************************
:	FT0100	- (FSM_PAC_RQ_RCV) THE FUNCTION OF THIS FSM IS TO 
:		RECORD THE ABILITY TO SEND A SESSION PACING RESPONSE 
:		FOR RCV PACING. IN RESET STATE, NO PACING RSP IS SENT;
:		IN PEND STATE, IT IS.
:		PAGE 4-61 IN FAPL
:--------------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR
:			FSM STATE INFO IN TCCB), R2 (MU_DIRECTION),
:			R4 (RQ OR RSP), R7 (FSM STATE VALUE), R10 (MU_PTR)
:			R15 (TCCB ENTRY)
:		OUTPUT:
:		LINK:	R3
:		WORKING:

FT0100
	FS.MC1(FTCPRR,FS.TCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FT0102			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:===============================================================
:	INPUT:	RESET
:===============================================================
	J	FT0002,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:-----------------------------------------------------
FT0102
	LR	R2,R2			:SEND OR RCV?
	JN	FT0104			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ, CRASH

:================================================================
:	INPUT:	S, RSP
:================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FTT040,,		:YES, ACTION = -(NOPAC)
	J	FTT070,,		:NO, ACTION = 1(PAC)

:	CHECK FOR RCV INPUTS
:------------------------------------------------
FT0104
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.PI		:PACING INDICATOR SET?

:===============================================================
:	INPUT:	R, RQ, -PAC
:================================================================
	JE	FTT000,,		:NO, ACTION = -

:=================================================================
:	INPUT:	R, RQ, PAC
:===================================================================
	CLHI	R7,FS.ST1		:YES, RESET STATE?
	JE	FTT020,,		:YES, ACTION = 2
	J	FTT050,,		:NO, ACTION = >(PACERR)

	SUBTTL	TRANSMISSION CONTROL ACTION CODE ROUTINES
:..................................................................
:	ACTION CODE:	-
:	ACTION:		NO STATE TRANSITION, SEND_OR_RCV_CHECK=FALSE
:..................................................................
FTT000
	FNC
	LHI	R6,FALSE		:SEND_OR_RCV_CHECK=FALSE
	JR	R3			:RETURN

:....................................................................
:	ACTION CODE:	1
:	ACTION:	STATE = STATE 1, SEND_OR_RCV_CHECK=FALSE
:....................................................................
FTT010
	LIS	R0,FS.ST1		:GET VALUE FOR STATE 1
FTT012
	FNC
	STB	R0,TCBBLK+TCSTAT,R1,R15	:STORE NEW STATE VALUE
	JBS	FTT000			:SEND_OR_RCV_CHECK=FALSE

:.....................................................................
:	ACTION CODE:	2
:	ACTION:	STATE = STATE 2, SEND_OR_RCV_CHECK=FALSE
:....................................................................
FTT020
	LIS	R0,FS.ST2		:GET VALUE FOR STATE 2
	JBS	FTT012

:..................................................................
:	ACTION CODE:	2(PACRQ)
:	ACTION:	PI = PAC, THEN STATE = STATE 2
:..................................................................
FTT030
	FNC
:	LHI	R0,MU.PI		:GET PACING INDICATOR BIT(5/13/85/CHS)
:	SBT	R0,BBUFER+MURHF2,R10,	:PI = PAC(5/13/85/CHS)
	LB	R0,BBUFER+MURHF2,R10,	:(5/13/85/CHS)
	OHI	R0,MU.PI		:SET PACING INDICATOR BIT(5/13/85/CHS)
	STB	R0,BBUFER+MURHF2,R10,	:(5/10/85/CHS)
	JBS	FTT020			:CHANGE TO STATE 2

:.....................................................................
:	ACTION CODE:	-(NOPAC)
:	ACTION:	PI = -PAC,THEN NO STATE TRANSITION
:....................................................................
FTT040
	FNC
:	LHI	R0,MU.PI		:GET PACING INDICATOR BIT(5/13/85/CHS)
:	RBT	R0,BBUFER+MURHF2,R10,	:PI = -PAC(5/13/85/CHS)
	LB	R0,BBUFER+MURHF2,R10,	:(5/13/85/CHS)
	NHI	R0,@MU.PI		:CLEAR PACING INDICATOR BIT(08/09/85/CHS)
	STB	R0,BBUFER+MURHF2,R10,	:(5/10/85/CHS)
	J	FTT000,,		:NO STATE TRANSITION

:...................................................................
:	ACTION CODE:	>(PACERR)
:	ACTION:	PI = -PAC, CALL UPM_LOG, SEND_OR_RCV_CHECK=TRUE
:...................................................................
FTT050
:	LHI	R0,MU.PI		:GET PACING INDICATOR BIT(5/13/85/CHS)
:	RBT	R0,BBUFER+MURHF2,R10,	:PI = -PAC(5/13/85/CHS)
	LB	R0,BBUFER+MURHF2,R10,	:(5/13/85/CHS)
	NHI	R0,@MU.PI		:CLEAR PACING INDICATOR BIT(08/09/85/CHS)
	STB	R0,BBUFER+MURHF2,R10,	:(5/10/85/CHS)
	J	FTT000,,		:NO STATE TRANSITION

	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	JAL	R4,U.ULOG		:CALL UPM_LOG
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTER
	LHI	R6,TRUE			:SEND_OR_RCV_CHECK=TRUE
	JR	R3			:RETURN

:...................................................................
:	ACTION CODE:	1(PACRSP)
:	ACTION:	PI = -PAC, PAC_COUNT = PAC_COUNT + WINDOW_SIZE
:		THEN CHANGE TO STATE 1
:....................................................................
FTT060
	FNC
:	LHI	R0,MU.PI		:GET PACING INDICATOR BIT(5/13/85/CHS)
:	RBT	R0,BBUFER+MURHF2,R10,	:PI = -PAC(5/13/85/CHS)
	LB	R0,BBUFER+MURHF2,R10,	:(5/13/85/CHS)
	NHI	R0,@MU.PI		:CLEAR PACING INDICATOR BIT(08/09/85/CHS)
	STB	R0,BBUFER+MURHF2,R10,	:(5/10/85/CHS)
:	J	FTT000,,		:NO STATE TRANSITION (01/09/86/CHS)

	LHL	R0,TCBBLK+TCPGCT,R15,	:GET PAC_COUNT
	AH	R0,TCBBLK+TCWDSZ,R15,	:ADD TO WINDOW_SIZE
	STH	R0,TCBBLK+TCPGCT,R15,	:STORE INTO PAC_COUNT
	J	FTT010			:CHANGE TO STATE 1

:........................................................................
:	ACTION CODE:	1(PAC)
:	ACTION:	PI = PAC, THAN CHANGE TO STATE 1
:........................................................................
FTT070
	FNC
:	LHI	R0,MU.PI		:GET PACING INDICATOR BIT(5/13/85/CHS)
:	SBT	R0,BBUFER+MURHF2,R10,	:PI = PAC(5/13/85/CHS)
	LB	R0,BBUFER+MURHF2,R10,	:(5/13/85/CHS)
	OHI	R0,MU.PI		:SET PACING INDICATOR BIT(5/13/85/CHS)
	STB	R0,BBUFER+MURHF2,R10,	:(5/10/85/CHS)
	J	FTT010			:CHANGE TO STATE 1


	FO	CMDLST
	FO	CBKDEF

	EM

  	SUBTTL	ACTION CODES FOR FSM'S USING SCB ('SSAC00')

:	*************************************************************
:	REVISION HISTORY
:	03/28/84 (DRUE BONDAD)	- ORIGINAL DESIGN AND CODING
:	*************************************************************

	RA	0
	MO	.,SNAPKG
	LO	GBLDEF
	LO	CMDLST
	LO	CBKDEF

	GL	V.SASP,V.SARQ,CLRRST,D.FSEN

	SEG	A.CODE


	SUBTTL	TRANSMISSION CONTROL ACTION CODE ROUTINES

:.........................................................................
:	ACTION CODE:	3(RESETC)
:	ACTION:	CALL CLEAR_RESET, THEN CHANGE TO STATE 3
:.........................................................................
FST000
	LIS	R0,FS.ST3		:GET STATE 3 VALUE
	JFS	FST022			

:..........................................................................
:	ACTION CODE:	4(RESETC)
:	ACTION:	CALL CLEAR_RESET, THEN CHANGE TO STATE 4
:..........................................................................
FST010
	LIS	R0,FS.ST4		:GET STATE 4 VALUE
	JFS	FST022		

:...............................................................................
:	ACTION CODE:	2(RESETC)
:	ACTION:	CALL CLEAR_RESET, THEN CHANGE TO STATE 2
:............................................................................
FST020
	LIS	R0,FS.ST2		:GET STATE 2 VALUE
FST022
	FNC
	STB	R0,SCBBLK+SCSTAT,R1,R9	:STORE NEW STATE VALUE
					:FALL THRU TO CALL CLEAR_RESET ROUTINE
:..........................................................................
:	ACTION CODE:	-(RESETC)
:	ACTION:	CALL CLEAR_RESET , THEN NO STATE TRANSITION
:..........................................................................
FST030
	FNC
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	JAL	R5,CLRRST,,		:CALL CLEAR_RESET
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTERS
	J	FSC000,,		:NO STATE CHANGE THEN RETURN

:..........................................................................
:	ACTION CODE:	2(SETCL)
:	ACTION:	SCB.LAST_CLEAR_SNF = SNF, THEN CHANGE TO STATE 2
:..........................................................................
FST040
	LIS	R0,FS.ST2		:GET STATE 2 VALUE
	JFS	FST052	

:..........................................................................
:	ACTION CODE:	4(SETCL)
:	ACTION:	SCB.LAST_CLEAR_SNF = SNF, THEN CHANGE TO STATE 4
:..........................................................................
FST050
	LIS	R0,FS.ST4		:GET STATE 4 VALUE
FST052
	FNC
	STB	R0,SCBBLK+SCSTAT,R1,R9	:STORE NEW STATE VALUE
					:FALL THRU TO SCB.LAST_CLEAR_SNF=SNF
:.........................................................................
:	ACTION CODE:	-(SETCL)
:	ACTION:	SCB.LAST_CLEAR_SNF = SNF THEN NO STATE TRANSITION
:.........................................................................
FST060
	FNC
	LHL	R2,BBUFER+MUSNF,R10,	:GET SNF	
	STH	R2,SCBBLK+SCLCSN,R9,	:STORE IN SCB.LAST_CLEAR_SNF
	J	FSC000,,		:NO STATE TRANSITION, THEN RETURN

:.............................................................................
:	ACTION CODE:	1(LASTCL)
:	ACTION:	SNF = SCB.LAST_CLEAR_SNF,
:		CALL CLEAR_RESET,
:		CHANGE TO STATE 1
:...........................................................................
FST070
	FNC
	LIS	R0,FS.ST1		:GET STATE 1 VALUE
	STB	R0,SCBBLK+SCSTAT,R1,R9	:STORE NEW STATE VALUE IN SCB
	LHL	R2,SCBBLK+SCLCSN,R9,	:GET LAST_CLEAR_SNF
	STH	R2,BBUFER+MUSNF,R10,	:STORE IN SNF
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	JAL	R5,CLRRST,,		:CALL CLEAR_RESET
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTERS
	J	FSC000,,		:NO STATE TRANSITION, THEN RETURN

:........................................................................................
:	ACTION CODE:	>(R0809)
:	ACTION:	CALL CHANGE_MU_TO_NEG_RSP(0809), THEN RECEIVE_CHECK=NEG_RSP
:...................................................................................
FST080
	LHI	R0,.MODCN		:GET SENSE CODE 
	JFS	FST092		

:............................................................................
:	ACTION CODE:	>(R2007)
:	ACTION:	CALL CHANGE_MU_TO_NEG_RSP(2007), THEN RECEIVE_CHECK=NEG_RSP
:............................................................................
FST090
	LHI	R0,.SEDTN		:GET SENSE CODE
FST092
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	JAL	R5,R.MUNR,,		:CALL CHANGE_MU_TO_NEG_RSP
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTERS
	LIS	R1,NEGRSP		:RECEIVE_CHECK=NEG_RSP
	J	FSC0A0,,		:SEND_OR_RCV_CHECK=TRUE, THEN RETURN

:...............................................................................
:	ACTION CODE:	>(R2009)
:	ACTION:	IF -RQN THEN
:			CALL CHANGE_MU_TO_NEG_RSP(2009)
:			RECEIVE_CHECK=NEG_RSP
:		ELSE RECEIVE_CHECK=DISCARD_MU
:........................................................................................
FST0A0
	LHI	R0,.SESCP		:GET SENSE CODE
	JFS	FST0B2

:............................................................................
:	ACTION CODE:	>(R2005)
:	ACTION:	IF -RQN THEN
:			CALL CHANGE_MU_TO_NEG_RSP(2005)
:			RECEIVE_CHECK=NEG_RSP
:		ELSE RECEIVE_CHECK=DISCARD_MU
:.............................................................................
FST0B0
	LHI	R0,.SEDTR		:GET SENSE CODE
FST0B2
	LB	R1,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R1,MU.DR1I+MU.DR2I+MU.ERI	:RQN?
	JEFS	FST0B4			:YES
: -RQN
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	JAL	R5,R.MUNR,,		:CALL CHANGE_MU_TO_NEG_RSP (R0=SENSE CODE)
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTERS
	LIS	R1,NEGRSP		:RECEIVE_CHECK=NEG_RSP
	JFS	FST0B6
: RQN
FST0B4	LIS	R1,DCARMU		:RECEIVE_CHECK=DISCARD_MU
: EXIT
FST0B6
	J	FSC0A0,,		:SEND_OR_RCV_CHECK=TRUE, THEN RETURN
:...........................................................................
:	ACTION CODE:	>(DISC)
:	ACTION:	RECEIVE_CHECK = DISCARD_MU, SEND_OR_RCV_CHECK=TRUE
:...........................................................................
FST0C0
	LIS	R6,TRUE			:SEND_OR_RCV_CHECK=TRUE
	JFS	FST0D2

:............................................................................
:	ACTION CODE:	-(DISC)
:	ACTION:	RECEIVE_CHECK=DISCARD_MU, SEND_OR_RCV_CHECK=FALSE
:...........................................................................
FST0D0
	FNC
	LIS	R6,FALSE		:SEND_OR_RCV_CHECK=FALSE
FST0D2
	LIS	R1,DCARMU		:RECEIVE_CHECK=DISCARD_MU
	JR	R3			:RETURN

:............................................................................
:	ACTION CODE:	>(S2009)
:	ACTION:	MUCB.SEND_CHECK_SENSE=2009 /*SESSION CONTROL PROTOCOL VIOLATION*/
:..................................................................................
FST0E0
	LHI	R0,.SESCP		:GET SENSE CODE
	JFS	FST0I2

:...............................................................................
:	ACTION CODE:	>(S0809)
:	ACTION:	MUCB.SEND_CHECK_SENSE=0809 /*MODE INCONSISTENCY*/
:............................................................................
FST0F0
	LHI	R0,.MODCN		:GET SENSE CODE
	JFS	FST0I2

:..........................................................................
:	ACTION CODE:	>(S2005)
:	ACTION:	MUCB.SEND_CHECK_SENSE=2005 /*DATA TRAFFIC RESET*/
:..........................................................................
FST0G0
	LHI	R0,.SEDTR		:GET SENSE CODE
	JFS	FST0I2		

:....................................................................................
:	ACTION CODE:	>(S2007)
:	ACTION:	MUCB.SEND_CHECK_SENSE=2007 /*DATA TRAFFIC NOT RESET*/
:.............................................................................
FST0H0
	LHI	R0,.SEDTN		:GET SENSE CODE
	JFS	FST0I2

:...........................................................................
:	ACTION CODE:	>(S200A)
:	ACTION:	MUCB.SEND_CHECK_SENSE=200A /*IMMEDIATE REQUEST MODE ERROR*/
:...........................................................................
FST0I0
	LHI	R0,.SEIRM		:GET SENSE CODE
FST0I2
	STH	R0,BBUFER+MUSCKS,R10,	:STORE INTO SCB
	J	FSC0A0,,		:SEND_OR_RCV_CHECK=TRUE, THEN RETURN

:.........................................................................
:	ACTION CODE:	>(RSPERR)
:	ACTION:	CALL UPM_LOG, THEN RECEIVE_CHECK=DISCARD_MU
:.........................................................................
FST0J0
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
:	JAL	R5,U.ULOG,,		:CALL UPM_LOG(5/2/86/CHS)
	JAL	R4,U.ULOG,,		:CALL UPM_LOG(5/2/86/CHS)
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTERS
	LIS	R1,DCARMU		:RECEIVE_CHECK=DISCARD_MU
	J	FSC0A0,,		:SEND_OR_RCV_CHECK=TRUE, THEN RETURN

:.............................................................................
:	ACTION CODE:	2(SET)
:	ACTION:	IF STSN_RQ.ACTION_CODE_SEC_TO_PRI = (SET|SET_AND_TEST) THEN
:			SCB.SQN_RCV_CNT = STSN_RQ.SEC_TO_PRI_SQN
:		IF STSN_RQ.ACTION_CODE_PRI_TO_SEC = (SET|SET_AND_TEST) THEN
:			SCB.SQN_SEND_CNT = STSN_RQ.PRI_TO_SEC_SQN
:		CHANGE TO STATE 2
:.............................................................................
FST0K0
	FNC
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R6,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	LHL	R0,BBUFER+2,R5,		:GET 3RD AND 4TH BYTES OF RU
	LR	R2,R6
: CHECK IF STSN_RQ.ACTION_CODE_SEC_TO_PRI = (SET|SET AND TEST)
	NHI	R2,ACCODE		:GET STSN_RQ.ACTION_CODE_SEC_TO_PRI
	CLHI	R2,ACSET		:ACTION_CODE = SET?
	JEFS	FST0K2			:YES
	CLHI	R2,ACSTST		:ACTION_CODE = SET AND TEST?
	JNFS	FST0K4			:NO
FST0K2
	STH	R0,SCBBLK+SCSQRC,R9,	:STORE IN SCB.SQN_RCV_CNT
	JFS	FST0K8
: CHECK FOR STSN_RQ.ACTION_CODE_PRI_TO_SEC = (SET|SET AND TEST)
FST0K4
	LHL	R0,BBUFER+3,R5,		:GET BYTES 3&4 (PRI_TO_SEC_SQN)
	SRLS	R6,2			:SHIFT ACTION CODE BITS TO THE RIGHT
	CLHI	R6,ACSET		:ACTION_CODE=SET?
	JEFS	FST0K6			:YES
	CLHI	R6,ACSTST		:ACTION_CODE=SET AND TEST?
	JNFS	FST0K8			:NO
FST0K6
	STH	R0,SCBBLK+SCSQSC,R9,	:STORE SQN INTO SCB.SQN_SEND_CNT
FST0K8
	J	FSC020,,		:CHANGE TO STATE 2


	SUBTTL	DATA FLOW CONTROL ACTION CODE ROUTINES
:...................................................................
:	ACTION CODE:	>(R)
:	ACTION:	RECEIVE_CHECK_SENSE = '2002' /*CHAINING ERROR*/
:...................................................................
FSD000
	LHI	R0,.SECHN		:GET ERROR CODE
	JFS	FSD042

:....................................................................
:	ACTION CODE:	>(R)
:	ACTION:	RECEIVE_CHECK_SENSE = '400D' /*CD NOT ALLOWED*/
:...................................................................
FSD010
	LHI	R0,.UECDI		:GET ERROR CODE
	JFS	FSD042	

:......................................................................
:	ACTION CODE:	>(R)
:	ACTION:	RECEIVE_CHECK_SENSE = '2004' 
:......................................................................
FSD020
	LHI	R0,.SEDIR		:GET ERROR CODE
	JFS	FSD042

:..........................................................................
:	ACTION CODE:	>(R)
:	ACTION:	RECEIVE_CHECK_SENSE = '200A' /*IMMEDIATE RQ MODE ERROR*/
:.........................................................................
FSD030
	LHI	R0,.SEIRM		:GET ERROR CODE
	JFS	FSD042

:.......................................................................
:	ACTION CODE:	>(R)
:	ACTION:	RECEIVE_CHECK_SENSE = '200B' /*QRI STATE ERROR*/
:.......................................................................
FSD040
	LHI	R0,.SEQRI		:GET ERROR CODE
FSD042
	ST	R0,BBUFER+MURCKS,R10,	:STORE SENSE CODE INTO SCB	
	J	FSC0A0,,		:CALL ACTION CODE >

:.......................................................................
:	ACTION CODE:	>(S)
:	ACTION:	SEND_CHECK_SENSE = '2002' /* CHAINING ERROR */
:.......................................................................
FSD050
	LHI	R0,.SECHN		:GET ERROR CODE
	JFS	FSD0A2

:......................................................................
:	ACTION CODE:	>(S)
:	ACTION:	SEND_CHECK_SENSE = '400D' /* CD NOT ALLOWED */
:......................................................................
FSD060
	LHI	R0,.UECDI		:GET ERROR CODE
	JFS	FSD0A2

:......................................................................
:	ACTION CODE:	>(S)
:	ACTION:	SEND_CHECK_SENSE = '2004'
:......................................................................
FSD070
	LHI	R0,.SEDIR		:GET ERROR CODE
	JFS	FSD0A2

:.....................................................................
:	ACTION CODE:	>(S)
:	ACTION:	SEND_CHECK_SENSE = '200A' /* IMM RQ MODE STATE ERROR */
:.....................................................................
FSD080
	LHI	R0,.SEIRM		:GET ERROR CODE
	JFS	FSD0A2

:.....................................................................
:	ACTION CODE:	>(S)
:	ACTION:	SEND_CHECK_SENSE = '200B' /* QRI STATE ERROR */
:.....................................................................
FSD090
	LHI	R0,.SEQRI		:GET ERROR CODE
	JFS	FSD0A2

:....................................................................
:	ACTION CODE:	>(S)
:	ACTION:	SEND_CHECK_SENSE = '2003' /* BRACKET ERROR */
:......................................................................
FSD0A0
	LHI	R0,.SEBER		:GET ERROR CODE
FSD0A2
	ST	R0,BBUFER+MUSCKS,R10,	:STORE SENSE CODE IN SCB
	J	FSC0A0,,		:CALL ACTION CODE >

:....................................................................
:	ACTION CODE:	-(A1)
:	ACTION:	CALL FSM_BSM WITH NO STATE TRANSITION
:....................................................................
FSD0B0
	LM	R0,FS.ASV,,		:RESTORE ORIGINAL INPUT REGISTERS
	LB	R1,SCBBLK+SCFBSM,R9,	:GET FSM_BSM TABLE OFFSET
	JFS	FSD0C2

:.....................................................................
:	ACTION CODE:	-(A1)
:	ACTION:	CALL FSM_HDX WITH NO STATE TRANSITION
:.....................................................................
FSD0C0
	LM	R0,FS.ASV,,		:RESTORE ORIGINAL INPUT REGISTERS
	LB	R1,SCBBLK+SCFHDX,R9,	:GET FSM_HDX TABLE OFFSET
FSD0C2
	FNC
	LB	R7,SCBBLK+SCSTAT,R9,R1	:GET FSM STATE VALUE
	LHI	R6,FS.CAL		:FSM CALL
	LHL	R5,FSMSBL,R1,R1		:GET ADDRESS OF FSM
	JAL	R3,F.CODE,R5,		:CALL FSM
	LM	R0,FS.ASV,,		:RESTORE ORIGINAL REGISTERS
	LHI	R6,FALSE		:RECEIVE_OR_SEND_CHECK = FALSE
	JR	R3			:RETURN

:....................................................................
:	ACTION CODE:	3(A2)
:	ACTION:	SNC_BSM_RCVD = SNC, THEN CHANGE TO STATE 3
:....................................................................
FSD0D0
	LHI	R5,SCSNBR		:GET SNC_BSM_RCVD OFFSET INTO SCB
	JFS	FSD0G2

:.....................................................................
:	ACTION CODE:	3(A2)
:	ACTION:	SNC_BSM_SENT = SNC, THEN CHANGE TO STATE 3
:.....................................................................
FSD0E0
	LHI	R5,SCSNBS		:GET SNC_BSM_SENT OFFSET INTO SCB
	JFS	FSD0G2

:.......................................................................
:	ACTION CODE:	3(A2)
:	ACTION:	SNC_HDX_RCV = SNC , THEN CHANGE TO STATE 3
:.......................................................................
FSD0F0
	LHI	R5,SCSNHR		:GET SNC_HDX_RCV OFFSET INTO SCB
	JFS	FSD0G2

:......................................................................
:	ACTION CODE:	3(A2)
:	ACTION:	SNC_HDX_SENT = SNC, THEN CHANGE TO STATE 3
:......................................................................
FSD0G0
	LHI	R5,SCSNHS		:GET SNC_HDX_SENT OFFSET INTO SCB
FSD0G2
	FNC
	L	R0,BBUFER+MURHSN,R10,	:GET SNC
	ST	R0,SCBBLK,R5,R9		:STORE SNC INTO SCB
	J	FSC030,,		:CHANGE TO STATE 3

:...................................................................
:	ACTION CODE:	1(A3)
:	ACTION:	MU_PTR_SAVE=MU_PTR
:		CREATE MU
:		MUCB.DIRECTION=RECEIVE
:		RRI=RSP
:		RU_CTGY=FMD
:		RTI=NEG
:		SDI=SD
:		SNC=SNC_BSM_RCVD
:		CALL #FSM_BSM
:		DISCARD MU
:		MU_PTR=MU_PTR_SAVE
:...................................................................
FSD0H0
	LIS	R2,RCV			:MUCB.DIRECCTION=RCV
:	L	R5,SCBBLK+SCSNBS,R9,	:GET SNC_BSM_RCVD(7/02/86/CHS)
	L	R5,SCBBLK+SCSNBR,R9,	:GET SNC_BSM_RCVD(7/02/86/CHS)
	JFS	FSD0I2

:...................................................................
:	ACTION CODE:	1(A3)
:	ACTION:	MU_PTR_SAVE=MU_PTR
:		CREATE MU
:		MUCB.DIRECTION=SEND
:		RRI=RSP
:		RU_CTGY=FMD
:		RTI=NEG
:		SDI=SD
:		SNC=SNC_BSM_SENT
:		CALL #FSM_BSM
:		DISCARD MU
:		MU_PTR=MU_PTR_SAVE
:...................................................................
FSD0I0
	LIS	R2,0			:MUCB.DIRECTION=SEND
	L	R5,SCBBLK+SCSNBS,R9,	:GET SNC_BSM_SENT
:
:ENTRY POINT FOR CALL #FSM_BSM
:	INPUT:	R2=SEND/RCV, R5=NEW SNC
:
FSD0I2
	LB	R4,SCBBLK+SCFBSM,R9,	:GET FSM_BSM TABLE OFFSET
	JFS	FSD0K4

:.................................................................
:	ACTION CODE:	1(A3)
:	ACTION:	MU_PTR_SAVE = MU_PTR
:		CREATE MU
:		MU_DIRECTION=RECEIVE
:		RRI=RSP
:		RU_CTGY=FMD
:		RTI=NEG
:		SDI=SD
:		SNC=SNC_HDX_RCVD
:		CALL #FSM_HDX
:		DISCARD MU
:		MU_PTR=MU_PTR_SAVE
:...................................................................
FSD0J0
	LIS	R2,RCV			:MU_DIRECTION=RCV
	L	R5,SCBBLK+SCSNHR,R9,	:GET SNC_HDX_RCVD
	JFS	FSD0K2

:....................................................................
:	ACTION CODE:	1(A3)
:	ACTION:	MU_PTR_SAVE=MU_PTR
:		CREATE MU
:		MU_DIRECTION = SEND
:		RRI=RSP
:		RU_CTGY=FMD
:		RTI=NEG
:		SDI=SD
:		SNC=SNC_HDX_SENT
:		CALL #FSM_HDX
:		DISCARD MU
:		MU_PTR=MU_PTR_SAVE
:.....................................................................
FSD0K0
	LIS	R2,0			:MU_DIRECTION=SEND
	L	R5,SCBBLK+SCSNHS,R9,	:GET SNC_HDX_SENT
:
:ENTRY POINT TO CALL #FSM_HDX
:	INPUT:	R0=SEND/RCV, R5=NEW SNC
:
FSD0K2
	LB	R4,SCBBLK+SCFHDX,R9,	:GET FSM_HDX TABLE OFFSET
:
:ENTRY POINT TO COMPLETE ACTION CODE A3 FUNCTION
:	INPUT:	R0=SEND/RCV, R5=NEW SNC, R4=FSM OFFSET TO CALL
:
FSD0K4
:	(9/4/85/CHS)
:	THE WHOLE ROUTINE OF FSD0K4 IS WRITTEN DUE TO TOO
:	MANY PROBLEMS OCCURRED WITHIN THE OLD CODE
:
:	DELETION START FROM HERE
:	FNC
:	STM	R0,FS.SV0,,		:SAVE REGISTERS
:	JAL	R4,GBB,,		:GET BUFFERLET TO CREATE MU
:	J	BUFCRA,,		:NONE AVAIL (03/27/85 MIA)
:	J	BUFCRA			:NONE AVAILABLE (03/27/85 MIA)
:	JAL	R4,R.GBB,,		:UPDATE BB COUNT
:	LI	R1,MU.FMD+MU.RRI+MU.SDI	:SET UP SECOND BYTE OF RH
:	STB	R1,BBUFER+MURHF2,R10,
:	LM	R0,FS.SV0,,		:RESTORE REGISTERS
:	ST	R5,BBUFER+MURHSN,R10,	:STORE SNC INTO SCB
:	LR	R1,R4			:R1 = FSM OFFSET INTO SCSTAT
:	LHL	R5,FSMSBL,R1,R1		:R5 = FSM ADDRESS
:	LB	R7,SCBBLK+SCSTAT,R1,R9	:GET CURRENT FSM STATE VALUE
:	LHL	R6,FS.CAL		:FSM CALL
:	LIS	R4,RSP			:RESPONSE MU
:	LIS	R0,0			:NO SIGNAL TO FSM
:	JAL	R3,F.CODE,R5,		:CALL FSM
:	JAL	R8,R.DSMU		:DISCARD MU
:	LM	R0,FS.ASV,,		:RESTORE ALL REGISTERS TO ORIGINAL
:	LCS	R10,1			:INDICATE MUCB DISCARD (5/20/85/CHS)
:	J	FSC010,,		:CALL CHANGE TO STATE 1
:
:	NEW CODE START FROM HERE
	FNC
	STM	R0,FS.SV0,,		:SAVE REGISTERS
	JAL	R4,GBB,,		:GET BUFFERLET TO CREATE MU
	J	BUFCRA			:NONE AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BB COUNT
	ST	R3,RGSAVA,,		:SAVE NEW MU PTR
	LM	R0,FS.SV0,,		:RESTORE REGISTERS
	LB	R1,BBUFER+MURHF2,R10,	:FETCH MURHF2 FROM OLD MU 
	BBLOAD	R6,BBUFER+MURUPT,R10,	:FETCH MURUPT FROM OLD MU (7/2/86/CHS)
	L	R10,RGSAVA,,		:R10 = NEW MU PTR
	BBSTOR	R6,BBUFER+MURUPT,R10,	:SET MURUPT FOR NEW MU (/7/2/86/CHS)
	OHI	R1,MU.RTI		:RTI = NEG
	STB	R1,BBUFER+MURHF2,R10,	:SET UP MURHF2
	LHI	R1,MU.FMD+MU.RRI+MU.SDI	:SET UP MURHF1
	STB	R1,BBUFER+MURHF1,R10,	:..
	ST	R5,BBUFER+MURHSN,R10,	:STORE SNC INTO SCB
	STB	R2,BBUFER+MUDIRE,R10,	:SET UP MU_DIRECTION
	LR	R1,R4			:R1 = FSM OFFSET INTO SCSTAT
	LHL	R5,FSMSBL,R1,R1		:R5 = FSM ADDRESS
	LB	R7,SCBBLK+SCSTAT,R1,R9	:GET CURRENT FSM STATE VALUE
	LHI	R6,FS.CAL		:FSM CALL
	LHI	R4,MU.RRI		:RESPONSE MU
	LIS	R0,0			:NO SIGNAL TO FSM
	JAL	R3,F.CODE,R5,		:CALL FSM
:		THE NEW MUCB MIGHT NOT HAVE THE BTU PTR
:		WE CAN NOT CALL R.DSMU ROUTINE TO DISCARD MU
	LR	R3,R10			:SET UP R3 = MU PTR
	JAL	R4,PBB,,
	JAL	R4,R.PBB,,
	LM	R0,FS.ASV,,		:RESTORE ALL REGISTERS TO ORIGINAL
	J	FSC010,,		:CALL CHANGE TO STATE 1
:	(9/4/85/CHS) END OF NEW CODE

:.....................................................................
:	ACTION CODE:	3,-
:	ACTION:	1. IF SCB.RECOVERY = LOSER_RESPONSIBLE
:		2. IF SCB.RECOVERY = SYMMETRIC
:......................................................................
FSD0L0
	FNC
	LB	R0,SCBBLK+SCSRMD,R9,	:GET BIND BYTE 7 FROM SCB
	NHI	R0,SC.RVR		:CHECK SCB.RECOVERY_RESP
	JN	FSC000,,		:NO STATE CHANGE IF SYMMETRIC
	J	FSC030,,		:OTHERWISE CHANGE TO STATE 3

:...................................................................
:	ACTION CODE:	>(S), -
:	ACTION:	1. SCB.PARTNER_HALF_SESSION_RSP_MODE = IMMEDIATE
:		2. SCB.PARTNER_HALF_SESSION_RSP_MODE = DELAYED
:....................................................................

FSD0M0
	FNC
	LB	R0,SCBBLK+SCMSSP,R9,	:GET PARTNER_HALF_SESS_RSP_MODE
	NHI	R0,SC.PSM		:DELAYED OR IMMEDIATE
	JN	FSC000,,		:DELAYED, ACTION = -
	J	FSD090,,		:IMMEDIATE, ACTION = >(S) '200B'


:...........................................................
:	MULTIPLE ACTION CODE:	>(R), >(R), -(C)
:	DEFINING CONDITIONS:
:		1. IF SCB.USING_BRACKETS=NO	THEN	>(R)
:		2. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=NO	THEN	>(R)
:		3. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=YES	THEN	-(C)
:...........................................................
FSD0N0
	LHI	R5,FSD0NT-F.CODE	:POINT TO TABLE OF ACTION CODES
	J	FSD0T0,,		:TEST DEFINING CONDITIONS

FSD0NT	HS	0
	HC	FSD020-F.CODE		:>(R)
	HC	FSD020-F.CODE		:>(R)
	HC	FSD0S0-F.CODE		:-(C)

:....................................................................
:	MULTIPLE ACTION CODE:	>(R), >(R), -
:	DEFINING CONDITIONS:
:		1. IF SCB.USING_BRACKETS=NO	THEN	>(R)
:		2. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=NO	THEN	>(R)
:		3. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=YES	THEN	-
:....................................................................
FSD0O0
	LI	R5,FSD0OT		:POINT TO TABLE OF ACTION CODE
	J	FSD0T0			:TEST DEFINING CONDITIONS

FSD0OT	HS	0
	HC	FSD020-F.CODE		:>(R)
	HC	FSD020-F.CODE		:>(R)
	HC	FSC000-F.CODE		:-

:...................................................................
:	MULTIPLE ACTION CODE:	>(R), 4, -
:	DEFINING CONDITIONS:	
:		1. IF SCB.USING_BRACKETS=NO	THEN	>(R)
:		2. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=NO	THEN	4
:		3. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=YES	THEN	-
:....................................................................
FSD0P0
	LI	R5,FSD0PT		:POINT TO TABLE OF ACTION CODE ROUTINES
	J	FSD0T0			:TEST DEFINING CONDITIONS

FSD0PT	HS	0
	HC	FSD020-F.CODE		:>(R)
	HC	FSC040-F.CODE		:4
	HC	FSC000-F.CODE		:-

:......................................................................
:	MULTIPLE ACTION CODE:	>(R), -, -
:	DEFINING CONDITIONS:
:		1. IF SCB.USING_BRACKETS=NO	THEN	>(R)
:		2. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=NO	THEN	-
:		3. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=YES	THEN	-
:.......................................................................
FSD0Q0
	LI	R5,FSD0QT		:POINT TO TBLE OF ACTION CODE ROUTINES
	J	FSD0T0			:TEST DEFINING CONDITIONS

FSD0QT	HS	0
	HC	FSD020-F.CODE		:>(R)
	HC	FSC000-F.CODE		:-
	HC	FSC000-F.CODE		:-

:...................................................................
:	MULTIPLE ACTION CODE:	>(R), >(R), >(R)
:	DEFINING CONDITIONS:
:		1. IF SCB.USING_BRACKETS=NO	THEN	>(R)
:		2. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=NO 	THEN	>(R)
:		3. IF SCB.USING_BRACKETS=YES &
:		      SCB.FIRST_SPEAKER=YES	THEN	>(R)
:............................................................
FSD0R0
	LI	R5,FSD0RT		:POINT TO TABLE OF ACTION CODE ROUTINES
	J	FSD0T0			:TEST DEFINING CONDITIONS

FSD0RT	HS	0
	HC	FSD020-F.CODE		:>(R)
	HC	FSD020-F.CODE		:>(R)
	HC	FSD020-F.CODE		:>(R)

:............................................................
:	ACTION CODE:	-(C)
:	ACTION:		IF SDI=-SD & FSM_CHAIN_RCV-=PURGE THEN
:			   CALL CHANGE_MU_TO_EXR	/*CONTENTION ERROR
:............................................................
FSD0S0
	LHI	R0,.RRRTM		:GET ERROR CODE
:
:ENTRY POINT FOR R0=ERROR CODE AND NEXT STATE ACTION CODE = -
:
FSD0S2
	LI	R2,FSC000		:ACTION CODE ADDRESS FOR -
:
: ENTRY POINT FOR R0=ERROR CODE AND R2=NEXT STATE ACTION CODE ADDRESS
:
FSD0S4
	FNC
	LB	R4,BBUFER+MURHF1,R10,
	NHI	R4,MU.SDI
	JN	FSD0S6			:JUMP IF SD SET
	LHI	R4,FSCCRV		:OFFSET FOR FSM_CHAIN_RCV IN SCB
	LB	R4,SCBBLK+SCSTAT,R4,R9	:GET FSM_CHAIN_RCV STATE
	CLHI	R4,FS.ST3		:STATE = PURGE STATE?
	JE	FSD0S6			:YES
	STM	R0,FS.SV0,,		:SAVE REGISTERS
	JAL	R5,R.MUEX,,		:CALL CHANGE_MU_TO_EXR
	LM	R0,FS.SV0,,		:RESTORE REGISTERS
FSD0S6
	JR	R2			:CHANGE TO NEXT STATE

:......................................................................
:	FSD0T0	- COMMON TEST ROUTINE
:	1. IF SCB.USING_BRACKETS=NO
:	2. IF SCB.USING_BRACKETS=YES & SCB.FIRST_SPEAKER=NO
:	3. IF SCB.USING_BRACKETS=YES & SCB.FIRST_SPEAKER=YES
:.......................................................................
FSD0T0
	LB	R2,SCBBLK+SCMSSP,R9,	:GET USING_BRACKETS BYTE FROM SCB
	NHI	R2,SC.UBK		:SCB.USING_BRACKETS?
	JEFS	FSD0T2			:NO
:	AIS	R5,4			:POINT TO ACTION ROUTINE FOR CASE 2
	AIS	R5,2			:POINT TO ACTION ROUTINE FOR CASE 2
	LB	R2,SCBBLK+SCMSSP,R9,	:GET FIRST_SPEAKER BYTE FROM SCB
	NHI	R2,SC.1SP		:SCB.FIRST_SPEAKER?
	JEFS	FSD0T2			:NO
:	AIS	R5,4			:POINT TO ACTION ROUTINE FOR CASE 3
	AIS	R5,2			:POINT TO ACTION ROUTINE FOR CASE 3
FSD0T2
:	L	R5,,R5			:GET ACTION CODE ROUTINE ADDR FROM TABLE
:	JR	R5			:CALL ACTION CODE ROUTINE
:	(6/20/84/CHS)
	LHL	R5,0,R5			:GET ACTION CODE ROUTINE ADDR
	J	F.CODE,R5		:CALL ACTION CODE ROUTINE

:..................................................................
:	ACTION CODE:	2, -
:	MULTIPLE ACTION: 1. SCB.RECOVERY_RESP=LOSER_RESPONSIBLE
:			 2. SCB.RECOVERY_RESP=SYMMETRIC
:..................................................................
FSD0U0
	LB	R0,SCBBLK+SCSRMD,R9,	:GET RECOVERY_RESP
	NHI	R0,SC.RVR		:SYMMETRIC?
	JN	FSC000			:YES, ACTION = -
	J	FSC020			:NO, ACTION = 2

:..................................................................
:	ACTION CODE:	>(R) OR >(R1)
:	ACTION:	RCV_CHECK_SENSE = 0809 /*MODE INCONSISTENCY */
:..................................................................
FSD0V0
	LHI	R0,.MODCN		:GET ERROR CODE
	J	FSD042			:GO STORE CODE

:...................................................................
:	ACTION CODE:	>(S1)
:	ACTION:	SEND_CHECK_SENSE = 0809 /*MODE INCONSISTENCY*/
:...................................................................
FSD0W0
	LHI	R0,.MODCN		:GET ERROR CODE
	J	FSD0A2			:GO STORE CODE

:...................................................................
:	ACTION CODE:	>(S2)
:	ACTION:	SEND_CHECK_SENSE = 2008 /*NO BEGIN BRACKET*/
:...................................................................
FSD0X0
	LHI	R0,.SENBB		:GET ERROR CODE
	J	FSD0A2			

:..................................................................
:	ACTION CODE:	>(R2)
:	ACTION:	RCV_CHECK_SENSE = 2008 /*NO BEGIN BRACKET*/
:..................................................................
FSD0Y0
	LHI	R0,.SENBB		:GET ERROR CODE
	J	FSD042	

:..................................................................
:	ACTION CODE:	>(S2)
:	ACTION:	SEND_CHECK_SENSE = 2006 /*DATA TRAFFIC QUIESCED*/
:...................................................................
FSD0Z0
	LHI	R0,.SEDTQ		:GET ERROR CODE
	J	FSD0A2

:.................................................................
:	ACTION CODE:	>(R2)
:	ACTION:	RCV_CHECK_SENSE = 2006 /*DATA TRAFFIC QUIESCED*/
:.................................................................
FSD100
	LHI	R0,.SEDTQ		:GET ERROR CODE
	J	FSD042		

:.................................................................
:	ACTION CODE:	>(S)
:	ACTION:	SEND_CHECK_SENSE = 200C  /*ERP SYNC EVENT ERROR*/
:.................................................................
FSD110
	LHI	R0,.SEESE		:GET ERROR CODE
	J	FSD0A2	

:......................................................................
:	ACTION CODE:	>(R)
:	ACTION: RECEIV_CHECK_SENSE = 200C  /*ERP SYNC EVENT ERROR*/
:......................................................................
FSD120
	LHI	R0,.SEESE		:GET ERROR CODE
	J	FSD042

:.......................................................................
:	ACTION CODE:	1(A1)
:	ACTION:	CALL FSM_HDX_FF, THEN CHANGE TO STATE 1
:		THIS ROUTINE ASSUMES FSM USING THIS ACTION CODE ROUTINE TO
:		HAVE A RECEIVE RESPONSE INPUT (R, RSP).
:.......................................................................
FSD130
	FNC
	LM	R0,FS.ASV,,		:GET ORIGINAL INPUT REGISTERS
					:NEEDED FOR NEXT FSM CALL
	LIS	R5,FS.ST1		:NEXT STATE = STATE 1
	STB	R5,SCBBLK+SCSTAT,R1,R9	:STORE NEW STATE VALUE INTO SCB
	LHI	R6,FS.CAL		:FSM CALL
	LB	R1,SCBBLK+SCFHDX,R9,	:GET FSM_HDX_FF TABLE OFFSET
	LB	R7,SCBBLK+SCSTAT,R1,R9	:R7 = FSM STATE VALUE
	LHL	R5,FSMSBL,R1,R1		:GET FSM ADDRESS FROM TABLE
	JAL	R3,F.CODE,R5,	:CALL FSM_HDX_FF
	LM	R0,FS.ASV,,		:RESTORE ORIGINAL VALUES
	LHI	R6,FALSE		:SEND_OR_RCV_CHECK = FALSE
	JR	R3			:RETURN

:...................................................................
:	ACTION CODE:	4(A2)
:	ACTION:	SNC_HDX_RCVD = SNC, THEN CHANGE TO STATE 4
:...................................................................
FSD140
	LI	R5,FSC040		:ADDRESS OF ACTION CODE ROUTINE 4
	J	FSD192

:....................................................................
:	ACTION CODE:	5(A2)
:	ACTION:	SNC_HDX_RCVD = SNC, THEN CHANGE TO STATE 5
:.....................................................................
FSD150
	LI	R5,FSC050		:ADDRESS OF ACTION CODE ROUTINE 5
	J	FSD192

:......................................................................
:	ACTION CODE:	6(A2)
:	ACTION:	SNC_HDX_RCVD = SNC, THEN CHANGE TO STATE 6
:......................................................................
FSD160
	LI	R5,FSC060		:ADDRESS OF ACTION CODE ROUTINE 6
	J	FSD192

:.......................................................................
:	ACTION CODE:	7(A2)
:	ACTION:	SNC_HDX_RCVD = SNC, THEN CHANGE TO STATE 7
:........................................................................
FSD170
	LI	R5,FSC070		:ADDRESS OF ACTION CODE ROUTINE 7
	JFS	FSD192

:........................................................................
:	ACTION CODE:	8(A2)
:	ACTION:	SNC_HDX_RCVD = SNC, THEN CHANGE TO STATE 8
:........................................................................
FSD180
	LI	R5,FSC080		:ADDRESS OF ACTION CODE ROUTINE 8
	JFS	FSD192

:.........................................................................
:	ACTION CODE:	9(A2)
:	ACTION:	SNC_HDX_RCVD = SNC, THEN CHANGE TO STATE 9
:.........................................................................
FSD190
	LI	R5,FSC090		:ADDRESS OF ACTION CODE ROUTINE 9
FSD192
	FNC
	L	R0,BBUFER+MURHSN,R10,	:GET SNC
	ST	R0,SCBBLK+SCSNHR,R9,	:STORE INTO SNC_HDX_RCVD
	JR	R5			:GO CHANGE TO NEXT STATE

:..........................................................................
:	ACTION CODE:	1(A3)
:	ACTION:	MU_PTR_SAVE = MU_PTR
:		CREATE MU:	MUCB.DIRECTION = RCV
:				RRI = RSP
:				RU_CTGY = FMD
:				RTI = NEG
:				SDI = SD
:				SNC = SNC_HDX_RCVD
:		CALL FSM_HDX_FF
:		DISCARD MU
:		MU_PTR = MU_PTR_SAVE
:........................................................................
FSD1A0
	LIS	R2,RCV			:MU_DIRECTION = RCV
	L	R5,SCBBLK+SCSNHR,R9,	:GET SNC_HDX_RCVD
	LB	R4,SCBBLK+SCFHDX,R9,	:GET TABLE OFFSET OF FSM_HDX_FF
	J	FSD0K4


:........................................................................
:	ACTION CODE:	4(A2)
:	ACTION:	SNC_HDX_SENT = SNC, THEN CHANGE TO STATE 4
:........................................................................
FSD1B0
	LI	R0,FSC040		:GET ACTION CODE ADDRESS FOR 4
	J	FSD1G2	

:.........................................................................
:	ACTION CODE:	5(A2)
:	ACTION:	SNC_HDX_SENT = SNC, THEN CHANGE TO STATE 5
:.........................................................................
FSD1C0
	LI	R0,FSC050		:GET ACTION CODE ADDRESS FOR 5
	J	FSD1G2

:........................................................................
:	ACTION CODE:	6(A2)
:	ACTION:	SNC_HDX_SENT = SNC, THEN CHANGE TO STATE 6
:.........................................................................
FSD1D0
	LI	R0,FSC060		:GET ACTION CODE ADDRESS FOR 6
	J	FSD1G2

:........................................................................
:	ACTION CODE:	7(A2)
:	ACTION:	SNC_HDX_SENT = SNC, THEN CHANGE TO STATE 7
:........................................................................
FSD1E0
	LI	R0,FSC070		:GET ACTION CODE ADDRESS FOR 7
	J	FSD1G2

:.........................................................................
:	ACTION CODE:	8(A2)
:	ACTION:	SNC_HDX_SENT = SNC, THEN CHANGE TO STATE 8
:.........................................................................
FSD1F0
	LI	R0,FSC080		:GET ACTION CODE ADDRESS FOR 8
	JFS	FSD1G2

:........................................................................
:	ACTION CODE:	9(A2)
:	ACION:	SNC_HDX_SENT = SNC, THEN CHANGE TO STATE 9
:........................................................................
FSD1G0
	LI	R0,FSC090		:GET ACTION CODE ADDRESS FOR 9
FSD1G2
	FNC				:RETURN IF FUNCTION
	L	R2,BBUFER+MURHSN,R10,	:GET SNC
	ST	R2,SCBBLK+SCSNHS,R9,	:STORE IN SNC_HDX_SENT
	JR	R0			:CHANGE TO NEW STATE
:........................................................................
:	ACTION CODE:	8(E)
:	ACTION:	IF SDI - = SD & FSM_CHAIN_RCV - = PURGE THEN
:		CALL CHANGE_MU_TO_EXR (0867)/*MUST SEND -RSP TO SYNC EVENT
:........................................................................
FSD1H0
	LHI	R0,.RRNSE		:GET ERROR CODE
	LI	R2,FSC080		:GET ACTION CODE ADDRESS FOR 8
	J	FSD0S4			:GO TO ACTION CODE C
:........................................................................
:	ACTION CODE:	-(B)
:	ACTION:	CALL #FSM_HDX ('BETB'), THEN NO STATE TRANSITION
:........................................................................
FSD1I0
	FNC				:RETURN IF FUNCTION
:
:ENTRY POINT TO SEND SIGNAL ('BETB') TO #FSM_HDX
:
FSD1I2
	LHI	R0,FS.BEB		:R0=SIGNAL 'BETB'
:
:ENTRY POINT TO SEND SIGNAL IN R0 TO #FSM_HDX
:
FSD1I4
	LB	R1,SCBBLK+SCFHDX,R9,	:GET #FSM_HDX TABLE OFFSET
	LB	R7,SCBBLK+SCSTAT,R1,R9	:R7=STATE VALUE FOR #FSM_HDX
	LHI	R6,FS.CAL		:R6=CALL ,(-FUNCTION)
	LHL	R5,FSMSBL,R1,R1		:GET #FSM_HDX ADDRESS
	ST	R3,FS.ISV,,		:SAVE LINK REGISTER
	JAL	R3,F.CODE,R5,		:CALL #FSM_HDX
	LHI	R6,FALSE		:R6=SEND_OR_RCV_CHECK=FALSE
	L	R3,FS.ISV,,		:GET LINK ADDRESS
	JR	R3			:RETURN

:........................................................................
:	ACTION CODE:	1(B)
:	ACTION:	CALL #FSM_HDX ('BETB'), THEN CHANGE TO STATE 1
:........................................................................
FSD1J0
	FNC				:RETURN IF FUNCTION
	LHI	R2,FS.ST1		:GET NEW STATE VALUE FOR STATE 1
	STB	R2,SCBBLK+SCSTAT,R1,R9	:STORE NEW STATE VALUE IN SCB
	J	FSD1I2			:GO CALL #FSM_HDX

:........................................................................
:	ACTION CODE:	-(C) OR -(C1)
:	ACTION:	IF SDI -= SD & FSM_CHAIN_RCV -= PURGE THEN,
:		CALL CHANGE_MU_TO_EXR /*BRACKET RACE ERROR (080B)
:........................................................................
FSD1K0
	LHI	R0,.RRBRE		:GET ERROR CODE
	J	FSD0S2			:GO TO ACTION CODE C

:.........................................................................
:	ACTION CODE:	-(C2)
:	ACTION:	IF SDI -= SD & FSM_CHAIN_RCV -= PURGE THEN,
:		CALL CHANGE_MU_TO_EXR /*BRACKET BID REJECT, RTR'LL NOT BE SENT
:.........................................................................
FSD1L0
	LHI	R0,.RRBJN		:GET ERROR CODE
	J	FSD0S2			:GO TO ACTION CODE C

:..........................................................................
:	ACTION CODE:	2(IR)
:	ACTION:	CALL #FSM_HDX ('INB_RCV'), THEN CHANGE TO STATE 2
:..........................................................................
FSD1M0
	FNC				:RETURN IF FUNCTION
	LHI	R0,FS.IBR		:R0=SIGNAL ('INB_RCV')
	JFS	FSD1N2			:CHANGE STATE BEFOR CALL #FSM_HDX

:.........................................................................
:	ACTION CODE:	2(IS)
:	ACTION:	CALL #FSM_HDX ('INB_SEND'), THEN CHANGE TO STATE 2
:..........................................................................
FSD1N0
	FNC				:RETURN IF FUNCTION
	LHI	R0,FS.IBS		:R0=SIGNAL ('INB_SEND')
FSD1N2
	LHI	R2,FS.ST2		:GET STATE VALUE FOR STATE 2
	STB	R2,SCBBLK+SCSTAT,R1,R9	:STORE NEW STATE VALUE
	J	FSD1I4			:GO CALL #FSM_HDX

:.........................................................................
:	ACTION CODE:	>(R)	/* 2003
:	ACTION:	RECEIVE_CHECK_SENSE = 2003, SEND_OR_RCV_CHECK=TRUE
:.........................................................................
FSD1O0
	LHI	R0,.SEBER		:GET BRACKET ERROR CODE
	J	FSD042			:GO STORE INTO RECEIVE_CHECK_SENSE

:...........................................................................
:	MULTIPLE ACTION CODE:	6,1
:	ACTIONS: 1. SCB.BRACKET_TERM_RULE=CONDITIONAL, THEN ACTION CODE=6
:		 2. SCB.BRACKET_TERM_RULE=UNCONDITIONAL,THEN ACTION CODE=1
:...........................................................................
FSD1P0
	LI	R5,FSC060		:R5 = ACTION CODE 6 ADDRESS
	LI	R2,FSC010		:R2 = ACTION CODE 1 ADDRESS
	J	FSD1S2
:............................................................................
:	MULTIPLE ACTION CODE:	6,1(B)
:	ACTIONS: 1. SCB.BRACKET_TERM_RULE=CONDITIONAL, THEN ACTION CODE=6
:		 2. SCB.BRACKET_TERM_RULE=UNCONDITIONAL,THEN ACTION CODE=1(B)
:............................................................................
FSD1Q0
	LI	R5,FSC060		:R5 = ACTION CODE 6 ADDRESS
	LI	R2,FSD1J0		:R2 = ACTION CODE 1(B) ADDRESS
	J	FSD1S2
:...........................................................................
:	MULTIPLE ACTION CODE:	5,1
:	ACTIONS: 1. SCB.BRACKET_TERM_RULE=CONDITIONAL, THEN ACTION CODE=5
:		 2. SCB.BRACKET_TERM_RULE=UNCONDITIONAL,THEN ACTION CODE=1
:...........................................................................
FSD1R0
	LI	R5,FSC050		:R5 = ACTION CODE 5 ADDRESS
	LI	R2,FSC010		:R2 = ACTION CODE 1 ADDRESS
	JFS	FSD1S2
:.........................................................................
:	MULTIPLE ACTION CODE:	5,1(B)
:	ACTIONS: 1. SCB.BRACKET_TERM_RULE=CONDITIONAL, THEN ACTION CODE=5
:		 2. SCB.BRACKET_TERM_RULE=UNCONDITIONAL,THEN ACTION CODE=1(B)
:.........................................................................
FSD1S0
	LI	R5,FSC050		:R5 = ACTION CODE 5 ADDRESS
	LI	R2,FSD1J0		:R2 = ACTION CODE 1(B) ADDRESS
:
:	ENTRY TO COMMON MULTIPLE ACTION CODE TEST ROUTINE
:	R5=CONDITIONAL ACTION CODE ADDRESS
:	R2=UNCONDITIONAL ACTION CODE ADDRESS
FSD1S2
	LB	R4,SCBBLK+SCCLUP,R9,	:GET TERMINATION RULE FROM BIND
	NHI	R4,SC.BTR		:CONDITIONAL?
	JNR	R5			:YES, CALL ACTION CODE ROUTINE
	JR	R2			:NO, CALL UNCONDITIONAL ACTION CODE


:......................................................................
:	ACTION CODE:	1(A3)
:	ACTION:	MU_PTR_SAVE = MU_PTR
:		CREATE MU
:		MUCB.DIRECTION = SEND
:		RRI = RSP
:		RU_CTG = FMD
:		RTI = NEG
:		SDI = SD
:		SNC = SNC_HDX_SENT
:		CALL FSM_HDX_FF
:		DISCARD MU
:		MU_PTR = MU_PTR_SAVE
:...................................................................
FSD1T0
	LIS	R2,0			:MU.DIRECTION = SEND
	L	R5,SCBBLK+SCSNHS,R9,	:GET SNC_HDX_SENT
	LB	R4,SCBBLK+SCFHDX,R9,	:GET FSM_HDX_FF OFFSET
	J	FSD0K4			:GO CREATE MU AND CALL FSM



	SUBTTL	SESSION CONTROL ACTION CODE ROUTINES
:...................................................................
:	ACTION CODE:	-(D)
:	ACTION:	SCB.HALF_SESSION = SEC, DISCARD MU
:...................................................................
FSS000
	FNC
	LHI	R2,SC.SES		:GET PRI BIT
	RBT	R2,SCBBLK+SCACFG,R10,	:PRI = FALSE
					:FALL THRU TO -(N) ACTION CODE ROUTINE
:..................................................................
:	ACTION CODE:	-(N)
:	ACTION:	DISCARD MU, THEN NO STATE CHANGE
:.................................................................
FSS010
	LI	R0,FSC000		:R0 = ACTION CODE ROUTINE FOR -
	JFS	FSS032			:GO TO DISCARD MU CALL

:..................................................................
:	ACTION CODE:	8(N)
:	ACTION:	DISCARD MU, THEN CHANGE TO STATE 8
:..................................................................
FSS020
	LI	R0,FSC080		:GET ADDR OF ACTION CODE ROUTINE FOR 8
	JFS	FSS032			:GO TO DISCARD MU CALL

:....................................................................
:	ACTION CODE:	9(N)
:	ACTION:	DISCARD MU, THEN CHANGE TO STATE 9
:....................................................................
FSS030
	LI	R0,FSC090		:GET ADDR OF ACTION CODE ROUTINE FOR 9
:
: ENTRY POINT FOR CALLING DISCARD MU THEN STATE CHANGE ROUTINE
:	INPUT:	R0=NEXT STATE ACTION CODE ROUTINE ADDRESS
FSS032
	FNC
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	JAL	R8,R.DSMU,,		:DISCARD MU
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTERS(5/20/85/CHS)
	LCS	R10,1			:INDICATE MUCB DISCARDED(5/20/85/CHS)
	JR	R0			:EXECUTE NEXT STATE ACTION CODE
:
: ENTRY POINT USED TO RESTORE REGISTER THEN CALL STATE CHANGE ACTION CODE
:	INPUT: ALL REGISTERS STORED INTO FS.SV0
FSS036
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTERS
	JR	R0			:EXECUTE NEXT STATE ACTION CODE

:......................................................................
:	ACTION CODE:	1(H)
:	ACTION:	CALL SCB_DISCARD, THEN CHANGE TO STATE 1
:......................................................................
FSS040
	FNC
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	JFS	FSS052			:GOTO SCB_DISCARD CALL

:.....................................................................
:	ACTION CODE:	1(HK)
:	ACTION:	CALL SCB_DISCARD, DISCARD MU, THEN CHANGE TO STATE 1
:.....................................................................
FSS050
	FNC
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	JAL	R8,R.DSMU,,		:CALL DISCARD MU
	LCS	R10,1			:INDICATE MUCB DISCARDED (5/20/85/CHS)
	ST	R10,FS.SV0+4*0A,,	:UPDATE FS.SV0 (5/2/0/85/CHS)
: ENTRY USED TO JUST CALL SCB_DISCARD ROUTINE
FSS052
	LHL	R8,SCBBLK+SCBLUC,R9,	:GET LUC FOR THIS SCB (6/29/84/CHS)
	JEFS	FSS054			:IF NO SCB , SKIP (6/29/84/CHS)
	LIS	R0,0			:ELSE CLEAR LUC.SCB (6/29/84/CHS)
	BBSSCB	R0,LUCTAB+LULSCB,R8,	:(6/29/84/CHS)
FSS054					:(6/29/84/CHS)
	JAL	R8,V.SCDS,,		:CALL SCB_DISCARD
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTERS
	J	FSC010,,		:CHANGE TO STATE 1

:..................................................................
:	ACTION CODE:	-(S)
:	ACTION:	CALL SESSACT.REQUEST, THEN NO STATE CHANGE
:..................................................................
FSS060
	LI	R0,FSC000		:GET ADDR OF ACTION CODE ROUTINE FOR -
	JFS	FSS082			:GO TO SESSACT.REQUEST CALL

:...................................................................
:	ACTION CODE:	2(S)
:	ACTION:	CALL SESSACT.REQUEST THEN CHANGE TO STATE 2
:...................................................................
FSS070
	LI	R0,FSC020		:GET ADDR OF ACTION CODE ROUTINE FOR 2
	JFS	FSS082			:GO TO SESSACT.REQUEST CALL

:....................................................................
:	ACTION CODE:	3(S)
:	ACTION:	CALL SESSACT.REQUEST, THEN CHANGE TO STATE 3
:.....................................................................
FSS080
	LI	R0,FSC030		:GET ADDR OF ACTION CODE ROUTINE FOR 3
: ENTRY POINT USED TO CALL SESSACT.REQUEST
:	INPUT:	R0=NEXT STATE ACTION CODE ROUTINE ADDRESS
FSS082
	FNC
 
	STM	R0,FS.SV0,,		:SAVE ALL REGISTERS
	JAL	R4,V.SARQ,,		:CALL SESSACT.REQUEST
	J	FSS036,,		:RESTORE REGISTERS, THEN CHANGE STATE

:......................................................................
:	ACTION CODE:	4(T)
:	ACTION:	CALL SESSACT.RESPONSE, THEN CHANGE TO STATE 4
:........................................................................
FSS090
	LI	R0,FSC040		:GET ADDR OF ACTION CODE ROUTINE FOR 4
	J	FSS124			:GO TO SESSACT.RESPONSE CALL

:........................................................................
:	ACTION CODE:	3(T)
:	ACTION:	CALL SESSACT.RESPONSE, THEN CHANGE TO STATE 3
:........................................................................
FSS100
	FNC
	LI	R0,FSC030		:GET ADDR OF ACTION CODE ROUTINE FOR 3
	J	FSS124			:GO TO SESSACT.RESPONSE CALL

:..........................................................................
:	ACTION CODE:	-(TK)
:	ACTION:	CALL SESSACT.RESPONSE, SEND HIERARCHICAL_RESET TO CSC_MGR.SON,
:		THEN NO STATE CHANGE
:...........................................................................
FSS110
	LI	R0,FSC000		:GET ADDR OF ACTION CODE ROUTINE FOR -
	JFS	FSS122			:GO TO SEND SIGNAL TO CSC_MGR.SON

:..........................................................................
:	ACTION CODE:	3(TK)
:	ACTION:	CALL SESSACT.RESPONSE, SEND HIERARCHICAL_RESET TO CSC_MGR.SON,
:		THEN CHANGE TO STATE 3
:..........................................................................
FSS120
	LI	R0,FSC030		:GET ADDR OF ACTION CODE ROUTINE FOR 3
: ENTRY USED TO SEND SIGNAL TO CSC_MGR.SON
:	INPUT:	R0=NEXT STATE ACTION CODE ROUTINE ADDRESS
FSS122
	FNC
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	LHI	R0,SG.RES		:SIGNAL=HIERARCHICAL_RESET
	LHI	R2,PMCSSO		:GET DESTINATION PROCESS
	LHI	R1,PMCSMS		:GET SENDING PROCESS
	JAL	R8,D.FSEN,,		:(04/02/84 NCS)
	JFS	FSS126
: ENTRY USED TO CALL SESSACT.RESPONSE
:	INPUT:	R0=NEXT STATE ACTION CODE ROUTINE ADDRESS
FSS124
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
: ENTRY USED TO CALL SESSACT.RESPONSE IF REGISTERS ALREADY SAVED
:	INPUT:	FS.SV0 CONTAINS ALL STORED REGISTERS, WHERE R0 STORAGE=
:		NEXT STATE ACTION CODE ADDRESS
FSS126
	JAL	R4,V.SASP,,		:CALL SESSACT.RESPONSE
	J	FSS036,,		:RESTORE REG THEN CHANGE STATE

:......................................................................
:	ACTION CODE:	1(HS)
:	ACTION:	SEND SSCP_GONE TO CSC_MGR.SON, THEN CHANGE TO STATE 1
:.....................................................................
FSS130
	LI	R0,FSC010		:GET ADDR OF ACTION CODE ROUTINE FOR 1
	JFS	FSS142			:GO TO SEND SIGNAL TO CSC_MGR.SON

:....................................................................
:	ACTION CODE:	4(HS)
:	ACTION:	SEND SSCP_GONE TO CSC_MGR.SON, THEN CHANGE TO STATE 4
:.....................................................................
FSS140
	LI	R0,FSC040		:GET ADDR OF ACTION CODE ROUTINE FOR 4
: ENTRY USED TO SEND SSCP_GONE SIGNAL TO CSC_MGR.SON
FSS142
	FNC
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	LHI	R0,SG.SGO		:SIGNAL = SSCP_GONE
	LHI	R1,PMCSMS		:GET SENDING PROCESS
	LHI	R2,PMCSSO		:GET DESTINATION PROCSS
	JAL	R8,D.FSEN,,		:(04/02/84 NCS)
	J	FSS036,,
	
:.....................................................................	
:	ACTION CODE:	1(HC)
:	ACTION:	CALL SCB_DISCARD, IF NRCB.RESOURCE_TYPE = PU_T2 THEN
:		CALL DISCARD MU, THEN CHANGE TO STATE 1
:.....................................................................
FSS150
	FNC
	STM	R0,FS.SV0,,		:STORE ALL REGISTERS
	LHL	R8,SCBBLK+SCBLUC,R9,	:GET LUC FOR THIS SCB (6/29/84/CHS)
	JEFS	FSS152			:IF NO SCB , SKIP (6/29/84/CHS)
	LIS	R0,0			:ELSE CLEAR LUC.SCB (6/29/84/CHS)
	BBSSCB	R0,LUCTAB+LULSCB,R8,	:(6/29/84/CHS)
FSS152
	JAL	R8,V.SCDS,,
: DO PU_T2 CHECK
	JAL	R8,R.DSMU,,		:CALL DISCARD MU
	LM	R0,FS.SV0,,		:RESTORE REGISTERS
	LCS	R10,1			:INDICATE MUCB DISCARDED (5/20/85/CHS)
	J	FSC010,,		:CHANGE TO STATE 1

:....................................................................
:	ACTION CODE:	1(H) FOR SEND RSP UNBIND
:	ACTION:		CLEAR LUCPTR, CALL SCB_DISCARD, CHANGE TO STATE 1
:....................................................................
FSS160
	FNC
	STM	R0,FS.SV0,,		:SAVE REGISTERS
	JFS	FSS172			:GO CLEAR LUCPTR

:....................................................................
:	ACTION CODE:	1(HK) FOR SEND RSP UNBIND
:	ACTION:		CALL DISCARD_MU, CLEAR LUCPTR, CALL SCB_DISCARD
:			CHANGE TO STATE 1
:....................................................................
FSS170
	FNC
	STM	R0,FS.SV0,,		:SAVE REGISTERS
	JAL	R8,R.DSMU,,		:DISCARD_MU
	LCS	R10,1			:INDICATE MUCB DISCARDED (5/20/85/CHS)
	ST	R10,FS.SV0+4*0A,,	:UPDATE FS.SV0 (5/2/0/85/CHS)
FSS172
:	LHL	R5,PUCPTR,RNODE,RNODE	:GET PTR TO PUCB(6/29/84/CHS)
:	LHL	R8,PUCTAB+PUCLUC,R5,	:GET PU.LUCB OFFSET(6/24/84/CHS)
:	LB	R6,SCBBLK+SCMYID,R9,	:GET SEC LU ADDR(6/29/84/CHS)
:	AH	R6,LUCTAB+LUCT.D,R8,	:REL LU# FOR THE INTERFACE(6/29/84/CHS)
:	LHL	R8,LUCPTR,R6,R6		:GET LUC PTR(6/29/84/CHS)
	LHL	R8,SCBBLK+SCBLUC,R9,	:GET LUC FOR THIS SCB (6/29/84/CHS)
	JEFS	FSS174			:IF NO SCB , SKIP (6/29/84/CHS)
	LIS	R0,0
	BBSSCB	R0,LUCTAB+LULSCB,R8,	:CLEAR PTR IN SCBJ
FSS174					:(6/29/84/CHS)
	JAL	R8,V.SCDS,,		:DISCARD SCB
	LM	R0,FS.SV0,,		:RESTORE REGISTERS
	J	FSC010,,		:CHANGE TO STATE 1

	
	SUBTTL COMMON ACTION CODE ROUTINES
:...............................................
:	ACTION CODE:	-
:	ACTION:		SAME STATE TRANSITION
:...............................................
FSC000
	FNC
	LHI	R6,FALSE		:SEND_OR_RECEIVE_CHECK = FALSE
	JR	R3			:RETURN

:..............................................
:	ACTION CODE:	1
:	ACTION:		CHANGE TO STATE 1
:..............................................
FSC010
	LIS	R0,FS.ST1			:NEW STATE = 1

:	ENTRY POINT FOR STORING NEW STATE VALUE INTO SESSION CONTROL BLOCK
:	INPUT:	R0 = NEW STATE VALUE (1 THRU 8)
:		R1 = INDEX FOR FSM STATE INFO. IN SCB
:		R9 = SCB ENTRY
:		R3 = RETURN ADDRESS
:	OUTPUT:	R6 = FALSE RETURN VALUE FOR SEND_OR_RECEIVE_CHECK

FSC012
	FNC
	STB	R0,SCBBLK+SCSTAT,R1,R9	:STORE NEW VALUE INTO SCB
	J	FSC000			:SEND_OR_RCV_CHECK=FALSE

:....................................................
:	ACTION CODE:	2
:	ACTION:		CHANGE TO STATE 2
:....................................................
FSC020
	LIS	R0,FS.ST2		:NEW STATE VALUE = 2
	J	FSC012			:GO STORE VALUE IN SCB

:.....................................................
:	ACTION CODE:	3
:	ACTION:		CHANGE TO STATE 3
:.....................................................
FSC030
	LIS	R0,FS.ST3		:NEW STATE VALUE = 3
	J	FSC012			:GO STORE VALUE IN SCB

:......................................................
:	ACTION CODE:	4
:	ACTION:		CHANGE TO STATE 4
:......................................................
FSC040
	LIS	R0,FS.ST4		:NEW STATE VALUE = 4
	J	FSC012			:GO STORE VALUE IN SCB

:.....................................................
:	ACTION CODE:	5
:	ACTION:		CHANGE TO STATE 5
:.....................................................
FSC050
	LIS	R0,FS.ST5		:NEW STATE VALUE = 5
	J	FSC012			:GO STORE VALUE IN SCB

:....................................................
:	ACTION CODE:	6
:	ACTION:		CHANGE TO STATE 6
:....................................................
FSC060
	LIS	R0,FS.ST6		:NEW STATE VALUE = 6
	J	FSC012			:GO STORE VALUE IN SCB

:....................................................
:	ACTION CODE:	7
:	ACTION:		CHANGE TO STATE 7
:....................................................
FSC070
	LIS	R0,FS.ST7		:NEW STATE VALUE=7
	J	FSC012			:GO STORE VALUE IN SCB

:....................................................
:	ACTION CODE:	8
:	ACTION:		CHANGE TO STATE 8
:....................................................
FSC080
	LIS	R0,FS.ST8		:NEW STATE VALUE = 8
	J	FSC012			:GO STORE VALUE IN SCB

:...............................................................
:	ACTION CODE:	9
:	ACTION:		CHANGE TO STATE 9
:...............................................................
FSC090
	LIS	R0,FS.ST9		:NEW STATE VALUE = 9
	J	FSC012			:GO CHANGE TO NEW STATE IN SCB

:................................................................
:	ACTION CODE:	>
:	ACTION:	SEND_OR_RCV_CHECK = TRUE, THEN NO STATE TRANSITION
:................................................................
FSC0A0
	LHI	R6,TRUE			:SEND_OR_RCV_CHECK=TRUE
	JR	R3			:RETURN


	FO	CBKDEF
	FO	GBLDEF
	FO	CMDLST	
	
	EM				:END OF MODULE 'SSAC00'

    	SUBTTL	TRANSMISSION CONTROL FSM'S USING SCB ('SSTF00')
:	***************************************************************
:	REVISION HISTORY
:	03/28/84 (DRUE BONDAD)	- ORIGINAL DESIGN AND CODING
:	***************************************************************


	RA	0
	MO	.,SNAPKG
	LO	CMDLST
	LO	CBKDEF


	SEG	A.CODE
	SUBTTL	FSM_CNTL_IMMED_EXP
:**********************************************************************
:	FSM_CNTL_IMMED_EXP
:**********************************************************************
:	FS0400	-(FSM_CNTL_IMMED_EXP) ENFORCES IMMEDIATE REQUEST MODE
:	FOR EXPEDITED REQUESTS. IMMEDIATE REQUEST MODE IS IN EFFECT FOR 
:	ALL DFC AND SC EXPEDITED REQUESTS EXCEPT RQR AND CLEAR WHICH
:	CAN BE SENT WITHOUT WAITING FOR AN OUTSTANDING RESPONSE.
:
:	ALL DFC AND SC EXPEDITED REQUESTS ARE SENT RQD.
:
:	IN RESET STATE ANY REQUEST CAN BE SENT. IN BLOCK_RQ STATE, A
:	RESPONSE NEEDS TO BE RECEIVED BEFORE A REQUEST OBEYING IMMEDIATE
:	REQUEST MODE CAN BE SENT.
:	PAGE 4-61 OF FAPL
:	------------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE 
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (FALSE OR TRUE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS0400
	FS.MC1(FSCCIE,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS0402			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:ALL OTHER SIGNALS NOT ALLOWED

:======================================================================
:	INPUT:	'RESET'
:======================================================================
FS0401
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:------------------------------
FS0402
	LB	R0,BBUFER+MUBIUF,R10,	:GET FIRST BYTE OF TH HEADER
	NHI	R0,MU.EFI		:EXPEDITED OR NORMAL FLOW?
	JE	FS.CFL,,		:NORMAL, CRASH
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS0403,,		:NO, -(CLEAR|RQR)
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,RQR			:RQR?
	JE	FS.COD,,		:YES, CRASH
	CLHI	R5,CLEAR		:CLEAR?
	JE	FS.COD,,		:YES, CRASH
FS0403
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS0404			:RECEIVE
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RESPONSE, CRASH

:========================================================================
:	INPUT:	S, RQ, EXP, -(CLEAR|RQR)
:========================================================================
	LHL	R5,TS0402,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0402	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 1
	HC	FST0I0-F.CODE 	:BLOCK_RQ STATE, ACTION = >(S200A)

:	CHECK RECEIVE INPUT
:----------------------------------------
FS0404
	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS.CRQ,,		:REQUEST, CRASH

:======================================================================
:	INPUT:	R, RSP, EXP, -(CLEAR|RQR)
:======================================================================
FS0406
	LHL	R5,TS0403,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0403	HS	0
	HC	FST0C0-F.CODE 	:RESET STATE, ACTION = >(DISC)
	HC	FSC010-F.CODE 	:BLOCK_RQ STATE , ACTION = 1


	SUBTTL	FSM_CRV_RCV
:**********************************************************************
:	FS1300	-(FSM_CRV_RCV) THIS FSM RECORDS THE ABILITY FOR ENCIPHERED
:	DATA TO FLOW IN A SESSION. THIS FSM APPEARS ONLY IN SECONDARY
:	HALF-SESSIONS THAT SUPPORT CRV.
:
:	RESET MEANS THAT CRV HAS NOT YET BEEN RECEIVED. PEND_ACTIVE
:	INDICATES THAT THE LU SERVICES MANAGER IS PROCESSING A CRV. ACTIVE
:	MEANS THAT CRYPTOGRAPHY IS FUNCTIONAL.
:	PAGE 4-71 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR 
:			RSP), R9 (SCB ENTRY), R10 (MU_PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS1300
	FS.MC1(FSCCVR,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS1302			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, ALL OTHER SIGNALS INVALID

:=================================================================
:	INPUT:	RESET
:=================================================================
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:---------------------------
FS1302
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LR	R2,R2			:SEND OR RCV?
	JN	FS130C			:RCV
	LR	R4,R4			:RQ OR RSP?
	JN	FS1304			:S, RSP INPUT 

:====================================================================
:	INPUT:	S, RQ
:=====================================================================
	J	FS1409,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RSP INPUT
:--------------------------------------------------
FS1304
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS1306			:NO, -CRV
	CLHI	R5,CRV			:CRV?
	JE	FS1308			:YES

:=================================================================================
:	INPUT:	S, RSP, -CRV
:=============================================================================
FS1306
	J	FS1409,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR SEND, RSP, CRV INPUT
:-----------------------------------------
FS1308
	LB	R0,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE?
	JN	FS130A			:NEGATIVE, -RSP

:=======================================================================
:	INPUT:	S, +RSP, CRV
:========================================================================
	CLHI	R7,FS.ST2		:PEND ACT STATE?
	JE	FSC030,,		:YES, ACTION = 3
	J	FST0J0,,		:NO, ALL OTHER STATES,ACTION=>(RSPERR)

:=======================================================================
:	INPUT:	S, -RSP, CRV
:========================================================================
FS130A
	CLHI	R7,FS.ST2		:PEND ACT STATE?
	JE	FSC010,,		:YES, ACTION = 1
	J	FST0J0,,		:NO, ALL OTHER STATES,ACTION=>(RSPERR)

:	CHECK FOR RCV
:----------------------------------
FS130C
	CLHI	R0,MU.DFC		:DFC RU?
	JE	FS130E			:YES
	CLHI	R0,MU.FMD		:FMD RU?
	JN	FS130G			:NO, -(FMD|DFC)

:==========================================================================
:	INPUT:	R, DFC|FMD
:============================================================================
FS130E
	J	FS140C,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, SC INPUT
:------------------------------------------
FS130G
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO, INVALID INPUT (NC)
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, INVALID INPUT
	CLHI	R5,CRV			:RQ, CRV?
	JN	FS130I			:NO, GO CHECK FOR SDT

:====================================================================
:	INPUT:	R, RQ, CRV
:====================================================================
	CLHI	R7,FS.ST2		:RESET STATE?
	JL	FSC020,,		:YES, ACTION = 2
	J	FST080,,		:NO, ALL OTHER STATES, ACTION = >(R0809)

:	CHECK FOR R, RQ, SDT
:-----------------------------------------------------
FS130I
	CLHI	R5,SDT			:SDT?
	JN	FS.COD,,		:NO, INVALID INPUT

:=========================================================================
:	INPUT:	R, RQ, SDT
:=========================================================================
	J	FS140C,,		:GO GET STATE ENTRY ROUTINE


	SUBTTL	FSM_CRV_SEND
:***********************************************************************
:	FS1400	-(FSM_CRV_SEND) THIS FSM RECORDS THE ABILITY OF ENCIPHERED
:	DATA TO FLOW IN A SESSION. THIS FSM APPEARS ONLY IN PRIMARY HALF-
:	SESSIONS THAT SUPPORT CRV.
:
:	RESET MEANS THAT CRV HAS NOT YET BEEN SENT. PEND_ACTIVE INDICATES
:	AN OUTSTANDING CRV. ACTIVE MEANS THAT CRYPTOGRAPHY IS FUNCTIONAL.
:	PAGE 4-70 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM 
:			STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR 
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS1400
	FS.MC1(FSCCVS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS1402			:NO
	CLHI	R0,FS.RET		:RESET SIGNAL?
	JN	FS.CSG,,		:NO, ALL OTHER SIGNALS INVALID

:========================================================================
:	INPUT:	RESET
:========================================================================
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:-------------------------------
FS1402
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS1403			:RECEIVE
	LR	R4,R4			:RQ OR RSP?
	JE	FS1403			:RQ

:====================================================================
:	INPUT:	S, RSP
:====================================================================
	J	FS1409			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S OR RCV CRV INPUT
:--------------------------------
FS1403
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS1408			:NO, GO CHECK FOR -CRV INPUT
	CLHI	R5,CRV			:CRV?
	JN	FS1408			:NO, -CRV
	LR	R2,R2			:SEND OR RCV?
	JN	FS1404			:RCV

:==================================================================
:	INPUT:	S, RQ, CRV
:==================================================================
	J	FS1905,,		:GO GET STATE ENTRY ROUTINE

:	CHECK RECEIVE CRV INPUTS
:---------------------------------
FS1404
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ, CRASH
	LB	R5,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	NHI	R5,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS1406			:NEGATIVE, -RSP

:====================================================================
:	INPUT:	R, +RSP, CRV
:====================================================================
	CLHI	R7,FS.ST2		:PEND ACT STATE?
	JE	FSC030,,		:YES, ACTION = 3
	J	FST0C0,,		:NO, ALL OTHER STATES,ACTION=>(DISC)

:===================================================================
:	INPUT:	R, -RSP, CRV
:===================================================================
FS1406
	J	FS190C,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S OR RCV -CRV INPUT
:--------------------------------------------
FS1408
	LR	R2,R2			:SEND OR RCV?
	JN	FS140A			:RCV, CHECK FOR DFC|FMD INPUT

:================================================================
:	INPUT:	S, RQ, -CRV
:================================================================
FS1409
	CLHI	R7,FS.ST3		:ACTIVE STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FST0E0,,		:NO, ALL OTHER STATES,ACTION=>(S2009)

:	CHECK FOR R, DFC|FMD INPUT
:----------------------------------------
FS140A
	CLHI	R0,MU.NC		:NC RU?
	JE	FS.CAT,,		:YES, INVALID INPUT
	CLHI	R0,MU.SC		:SC RU?
	JE	FS.CAT,,		:YES, INVALID INPUT

:=========================================================================
:	INPUT:	R, DFC|FMD
:========================================================================
FS140C
	CLHI	R7,FS.ST3		:ACTIVE STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FST0A0,,		:NO, ALL OTHER STATES,ACTION=>(R2009)


	SUBTTL	FSM_DT_RCV_CLEAR
:**********************************************************************
:	FS1500	-(FSM_DT_RCV_CLEAR) THE FUNCTION OF THIS FSM IS TO
:	RECORD THE ABILITY OF DATA TO FLOW IN A SESSION. THIS VERSION
:	OF THE DATA TRAFFIC FSM HANDLES SESSIONS USING TS PROFILE 2,
:	WHICH ALLOW ONLY CLEAR TO BE SENT. THIS FSM APPEARS ONLY IN 
:	SECONDARY HALF-SESSIONS USING TS PROFILE 2.
:
:	ACTIVE STATE MEANS THAT DATA CAN FLOW. THE PEND STATE INDICATES
:	THAT THE SERVICES MANAGER IS PROCESSING CLEAR.
:	PAGE 4-67 IN FAPL
:	--------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM SIGNAL INPUT, OPTION), R1 (INDEX FOR FSM
:			STATE INFO IN SCB), R2 (MU.DIRECTION), R4 (RQ
:			OR RSP), R9 (SCB ENTRY), R10 (MU.PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TREU OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS1500
	FS.MC1(FSCCVS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS1502			:NO
	CLHI	R0,FS.RET		:RESET?
	JN	FS.CSG,,		:NO, ALL OTHER SIGNALS INVALID INPUT

:=======================================================================
:	INPUT:	'RESET'
:=======================================================================
	J	FS1801,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:----------------------------
FS1502
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LR	R2,R2			:SEND OR RCV?
	JN	FS150C			:RCV
	LR	R4,R4			:RQ OR RSP?
	JN	FS1506			:RESPONSE
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS1504			:NO, -RQR
	CLHI	R5,RQR			:YES, RQR ACTION_CODE?
	JE	FS.COD,,		:YES, INVALID INPUT

:==================================================================
:	INPUT:	S, RQ, -RQR
:==================================================================
FS1504
	J	FS1806,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RSP INPUT
:----------------------------------
FS1506
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS1508			:NO, -CLEAR
	CLHI	R5,CLEAR		:YES, CLEAR ACTION_CODE?
	JE	FS150A			:YES, INPUT = S, RSP, CLEAR

:====================================================================
:	INPUT:	S, RSP, -CLEAR
:====================================================================
FS1508
	J	FS1806,,		:GO GET STATE ENTRY ROUTINE

:====================================================================
:	INPUT:	S, RSP, CLEAR
:====================================================================
FS150A
	CLHI	R7,FS.ST1		:ACTIVE STATE?
	JE	FST0E0,,		:YES, ACTION = >(S2009)
	J	FST070,,		:NO, PEND STATE, ACTION = 1(LASTCL)

:	CHECK FOR RCV INPUT
:----------------------------
FS150C
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS150E			:NO, CHECK FOR DFC|FMD
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, INVALID INPUT
	CLHI	R5,CLEAR		:ACTION_CODE = CLEAR?
	JN	FS.COD,,		:NO

:=====================================================================
:	INPUT:	R, RQ, CLEAR
:=====================================================================
	LHL	R5,TS1502,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1502	HS	0
	HC	FST040-F.CODE 	:ACTIVE STATE, ACTION = 2(SETCL)
	HC	FST060-F.CODE 	:PEND STATE, ACTION = -(SETCL)

:	CHECK FOR R, DFC|FMD
:-----------------------------
FS150E
	CLHI	R0,MU.DFC		:DATA FLOW CONTROL RU?
	JE	FS150G			:YES
	CLHI	R0,MU.FMD		:FUNCTION MANAGEMENT DATA RU?
	JN	FS.CAT,,		:NO, INVALID CATEGORY

:=====================================================================
:	INPUT:	R, DFC|FMD
:=====================================================================
FS150G
	J	FS180E,,		:GO GET STATE ENTRY ROUTINE



	SUBTTL	FSM_DT_RCV_SDT
:***********************************************************************
:	FS1600	-(FSM_DT_RCV_SDT) THE FUNCTION OF THIS FSM IS TO RECORD
:	THE ABILITY FOR DATA TO FLOW IN A SESSION. THIS VERSION OF THE
:	DATA TRAFFIC FSM HANDLES SESSIONS THAT ALLOW SDT TO BE SENT. THIS
:	FSM APPEARS ONLY IN SECONDARY HALF-SESSIONS USING TS PROFILES 5 
:	AND 17.
:	
:	RESET MEANS THAT NO DFC OR FMD TRAFFIC CAN FLOW. PEND_ACTIVE 
:	STATE IS ENTERED WHEN THE SERVICES MANAGER IS PROCESSING AN SDT.
:	ACTIVE MEANS THAT ALL TRAFFIC CAN FLOW.
:	PAGE 4-65 IN FAPL
:	------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR
:			FSM STATE INFO IN SCB), R2 (MU.DIRECTION),
:			R4 (RQ OR RSP), R9 (CB ENTRY), R10 (MU_PTR)
:			R7 (FSM STATE VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS1600
	FS.MC1(FSCDRS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS1602			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:=================================================================
:	INPUT:	'RESET'
:=================================================================
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:--------------------------------
FS1602
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	LR	R2,R2			:SEND OR RCV?
	JN	FS160C			:RCV
	LR	R4,R4			:RQ OR RSP?
	JN	FS1606			:RSP
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS1604			:NO, -RQR
	CLHI	R5,RQR			:YES, RQR ACTION_CODE?
	JE	FS.COD,,		:YES, INVALID ACTION_CODE

:==================================================================
:	INPUT:	S, RQ, -RQR
:==================================================================
FS1604
	J	FS1906,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RSP INPUT
:-----------------------------------
FS1606
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS1608			:NO, -SDT
	CLHI	R5,SDT			:YES, ACTION_CODE = SDT?
	JE	FS160A			:YES

:====================================================================
:	INPUT:	S, RSP, -SDT
:====================================================================
FS1608
	J	FS1906,,		:GO GET STATE ENTRY ROUTINE

:====================================================================
:	INPUT:	S, RSP, SDT
:====================================================================
FS160A
	LHL	R5,TS1601,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1601
	HS	0
	HC	FST0E0-F.CODE 	:RESET STATE, ACTION = >(S2009)
	HC	FSC030-F.CODE 	:PEND ACTIVE STATE,ACTION = 3
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -

:	CHECK FOR RCV INPUT
:-----------------------------------
FS160C
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS160E			:NO, GO CHECK FOR DFC|FMD
	CLHI	R5,SDT			:YES, ACTION_CODE=SDT?
	JN	FS.COD,,		:NO
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP

:================================================================
:	INPUT:	R, RQ, SDT
:================================================================
	LHL	R5,TS1602,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1602	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 2
	HC	FST080-F.CODE 	:PEND ACTIVE STATE, ACTION =>(R0809)
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -

:	CHECK FOR R, DFC|FMD INPUT
:---------------------------------------------------
FS160E
	CLHI	R0,MU.NC		:NETWORK CONTROL RU?
	JE	FS.CAT,,		:YES, -(DFC|FMD)
	LR	R4,R4			:RQ OR RSP?
	JN	FS160G			:RSP

:==============================================================
:	INPUT:	R, RQ, DFC|FMD
:==============================================================
	J	FS190F,,		:GO GET STATE ENTRY ROUTINE

:================================================================
:	INPUT:	R, RSP, DFC|FMD
:================================================================
FS160G
	CLHI	R7,FS.ST3		:ACTIVE STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FST0J0,,		:NO, ALL OTHER STATES,ACTION=>(RSPERR)

	
	SUBTTL	FSM_DT_RCV_SDT_AND_CLEAR
:****************************************************************
:	FS1700	-(FSM_DT_RCV_SDT_AND_CLEAR) THIS FSM RECORDS THE
:	ABILITY FOR DATA TO FLOW IN A SESSION. THIS VERSION OF THE 
:	DATA TRAFFIC FSM HANDLES SESSIONS THAT ALLOW SDT AND CLEAR
:	TO BE SENT. THIS FSM APPEARS ONLY IN SECONDARY HALF-SESSIONS
:	USING TS PROFILES 3 AND 4.
:
:	RESET MEANS THAT NO DFC OR FMD TRAFFIC CAN FLOW. PEND_ACTIVE
:	INDICATES THAT AN SDT IS BEING PROCESSED BY THE SERVICE MANAGER.
:	ACTIVE MEANS THAT ALL TRAFFIC CAN FLOW, AND PEND_RESET
:	MEANS THAT A CLEAR IS BEING PROCESSED BY THE SERVICE MANAGER.
:	PAGE 4-63 IN FAPL
:	--------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR
:			FSM STATE INFO IN SCB), R2 (MU.DIRECTION),
:			R4 (RQ OR RSP), R9 (SCB ENTRY), R10 (MU_PTR)
:			R7 (FSM STATE VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS1700
	FS.MC1(FSCDRA,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS1702			:NO
	CLHI	R0,FS.RET		:RESET?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID

:============================================================
:	INPUT:	'RESET'
:============================================================
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:----------------------------
FS1702
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL (SC) RU?
	JE	FS1703			:YES
	LR	R2,R2			:SEND OR RCV?
	JN	FS170M			:RCV, GO CHECK FOR DFC|FMD INPUT
	LR	R4,R4			:RQ OR RSP?
	JE	FS1709			:RQ, INPUT=S, RQ, -RQR
	J	FS170K			:RSP, INPUT=S, RSP,-(CLEAR|SDT|CRV)

:	CHECK FOR SESSION CONTROL INPUT
:--------------------------------------
FS1703
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE
	LR	R2,R2			:SEND OR RCV?
	JE	FS1708			:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP
	CLHI	R5,SDT			:ACTION_CODE = SDT?
	JN	FS1704			:NO, GO CHECK FOR STSN

:==================================================================
:	INPUT:	R, RQ, SDT
:==================================================================
	LHL	R5,TS1702,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1702	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 2
	HC	FST080-F.CODE 	:PEND ACTIVE STATE, ACTION = >(R0809)
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -
	HC	FST080-F.CODE 	:PEND RESET STATE, ACTION = >(R0809)

:	CHECK FOR R, RQ, STSN INPUT
:------------------------------------
FS1704
	CLHI	R5,STSN			:ACTION_CODE=STSN?
	JN	FS1706			:NO, GO CHECK FOR CLEAR

:======================================================================
:	INPUT:	R, RQ, STSN
:======================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FST090,,		:NO, ALL OTHER STATES,ACTION = >(R2007)

:	CHECK FOR R, RQ, CLEAR
:-------------------------------
FS1706
	CLHI	R5,CLEAR		:ACTION_CODE = CLEAR?
	JN	FS.COD,,		:NO

:==================================================================
:	INPUT:	R, RQ, CLEAR
:==================================================================
	CLHI	R7,FS.ST4		:PEND RESET STATE?
	JE	FST060,,		:YES, ACTION = -(SETCL)
	J	FST050,,		:ALL OTHER STATES,ACTION = 4(SETCL)

:	CHECK FOR SEND SESSION CONTROL INPUT
:-------------------------------------------------------
FS1708
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS170A			:RSP
	CLHI	R5,RQR			:ACTION_CODE = RQR?
	JE	FS.COD,,		:YES

:=================================================================
:	INPUT:	S, RQ, -RQR
:=================================================================
FS1709
	J	FS2003,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RSP, SC INPUT
:------------------------------------------
FS170A
	CLHI	R5,SDT			:ACTION_CODE=SDT?
	JN	FS170G			:NO, -SDT
	LB	R0,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS170C			:-RSP

:==================================================================
:	INPUT:	S, +RSP, SDT
:==================================================================
	LHL	R5,TS1703,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1703	HS	0
	HC	FSC0A0-F.CODE 	:RESET STATE, ACTION = >
	HC	FSC030-F.CODE 	:PEND ACTIVE STATE, ACTION = 3
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >

:	CHECK S, -RSP, SDT INPUT
:--------------------------------------------
FS170C
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE CODE
	CLHI	R0,.SEDTR		:2007?
	JN	FS170E			:-2007

:==================================================================
:	INPUT:	S, -RSP, SDT, 2007
:==================================================================
	LHL	R5,TS1704,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1704	HS	0
	HC	FSC0A0-F.CODE 	:RESET STATE, ACTION = >
	HC	FST0E0-F.CODE 	:PEND ACTIVE STATE, ACTION = >(S2009)
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >

:=================================================================
:	INPUT:	S, -RSP, SDT, -2007
:=================================================================
FS170E
	LHL	R5,TS1705,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1705	HS	0
	HC	FSC0A0-F.CODE 	:RESET STATE, ACTION = >
	HC	FSC010-F.CODE 	:PEND ACTIVE STATE, ACTION = -
	HC	FST0E0-F.CODE 	:ACTIVE STATE, ACTION = >(S2009)
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >

:	CHECK FOR S, RSP, -SDT INPUT
:-------------------------------------
FS170G
	CLHI	R5,CLEAR		:CLEAR?
	JN	FS170I			:NO, GO CHECK FOR CRV

:======================================================================
:	INPUT:	S, RSP, CLEAR
:======================================================================
	LHL	R5,TS1707,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1707	HS	0
	HC	FST0E0-F.CODE 	:RESET STATE,ACTION = >(S2009)
	HC	FST0E0-F.CODE 	:PEND ACTIVE STATE,ACTION =>(S2009)
	HC	FSC000-F.CODE 	:ACTIVE STATE,ACTION= -
	HC	FST070-F.CODE 	:PEND RESET STATE, ACTION = 1(LASTCL)

:	CHECK FOR S, RSP, -(SDT|CLEAR)
:------------------------------------------------
FS170I
	CLHI	R5,CRV			:ACTION_CODE = CRV?
	JE	FS.COD,,		:YES

:========================================================================
:	INPUT:	S, RSP, -(SDT|CLEAR|CRV)
:========================================================================
FS170K
	J	FS2003,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, DFC|FMD INPUT
:----------------------------------
FS170M
	CLHI	R0,MU.NC		:NETWORK CONTROL RU?
	JE	FS.CAT,,		:YES, -(DFC|FMD)
	LR	R4,R4			:RQ OR RSP?
	JN	FS170O			:RSP

:================================================================
:	INPUT:	R, RQ, DFC|FMD
:================================================================
	J	FS200N,,		:GO GET STATE ENTRY ROUTINE

:================================================================
:	INPUT:	R, RSP, DFC|FMD
:================================================================
FS170O
	LHL	R5,TS170C,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS170C	HS	0
	HC	FST0J0-F.CODE 	:RESET STATE, ACTION = >(RSPERR)
	HC	FST0J0-F.CODE 	:PEND ACTIVE STATE, ACTION = >(RSPERR)
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -
	HC	FST0D0-F.CODE 	:PEND RESET STATE, ACTION = -(DISC)




	SUBTTL	FSM_DT_SEND_CLEAR
:******************************************************************
:	FS1800	-(FSM_DT_SEND_CLEAR) THE FUNCTION OF THIS FSM IS TO
:	RECORD THE ABILITY OF DATA TO FLOW IN A SESSION. THIS VERSION
:	OF THE DATA TRAFFIC FSM HANDLES SESSIONS THAT ALLOW ONLY CLEAR
:	TO BE SENT. THIS FSM APPEARS ONLY IN PRIMARY HALF-SESSIONS
:	USING TS PROFILE 2.
:
:	ACTIVE STATE MEANS THAT ALL TRAFIC CAN FLOW. THE PEND STATE
:	INDICATES AN OUTSTANDING CLEAR.
:	PAGE 4-66 IN FAPL
:	------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR 
:			FSM STATE INFO IN SCB), R2 (MU.DIRECTION), 
:			R4 (RQ OR RSP), R7 (FSM STATE VALUE),
:			R9 (SCB ENTRY), R10 (MU_PTR), R6 (FUNCTION OR
:			CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R17 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS1800
	FS.MC1(FSCDSC,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS1802			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID INPUT

:====================================================================
:	INPUT:	'RESET'
:====================================================================
FS1801
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:--------------------------------
FS1802	
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LR	R2,R2			:SEND OR RCV?
	JN	FS1808			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS1804			:RQ

:=================================================================
:	INPUT:	S, RSP
:=================================================================
	J	FS1806			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ INPUT
:------------------------------
FS1804
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS1806			:NO, CRASH
	CLHI	R5,CLEAR		:CLEAR?
	JN	FS1806			:S, RQ, -CLEAR

:================================================================
:	INPUT:	S, RQ, CLEAR
:================================================================
	LHL	R5,TS1803,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1803	HS	0
	HC	FST020-F.CODE 	:ACTIVE STATE, ACTION = 2(RESETC)
	HC	FST030-F.CODE 	:PEND STATE, ACTION = -(RESETC)

:==================================================================
:	INPUT:	S, RQ, -CLEAR
:==================================================================
FS1806
	LHL	R5,TS1804,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1804	HS	0
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -
	HC	FST0G0-F.CODE 	:PEND STATE, ACTION =>(S2005)

:	CHECK FOR RCV INPUT
:-----------------------------------------
FS1808
	CLHI	R5,MU.SC		:SESSION CONTROL RU?
	JN	FS180C			:NO, GO CHECK FOR DFC|FMD
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:R, RQ, SC  - CRASH
	CLHI	R5,CLEAR		:CLEAR?
	JN	FS.COD,,		:NO, CRASH

:	CHECK FOR LAST_CLEAR INPUT

	LHL	R0,SCBBLK+SCLCSN,R9,	:GET LAST_CLEAR_SNF
:	CLH	R0,BBUFER+MUSNF,R10,	:COMPARE WITH SNF? (12/6/84 MIA)
	LHL	R5,BBUFER+MUSNF,R10,	:GET SNF (12/6/84 MIA)
	CR	R0,R5			:THE SAME? (12/6/84 MIA)
	JN	FS180A			:NO, -LAST_CLEAR

:=================================================================
:	INPUT:	R, RSP, CLEAR, LAST_CLEAR
:=================================================================
FS1809
	LHL	R5,TS1805,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1805	HS	0
	HC	FST0J0-F.CODE 	:ACTIVE STATE, ACTION =>(RSPERR)
	HC	FSC010-F.CODE 	:PEND STATE, ACTION = 1

:=====================================================================
:	INPUT:	R, RSP, CLEAR, -LAST_CLEAR
:=====================================================================
FS180A
	LHL	R5,TS1806,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1806	HS	0
	HC	FST0J0-F.CODE 	:ACTIVE STATE, ACTION = >(RSPERR)
	HC	FSC000-F.CODE 	:PEND STATE, ACTION = -

:	CHECK FOR DFC|FMD INPUT
:------------------------------------
FS180C
	CLHI	R5,MU.NC		:DFC|FMD?
	JE	FS.CAT,,		:NO, NC

:==================================================================
:	INPUT:	R, DFC|FMD
:==================================================================	
FS180E
	LHL	R5,TS1807,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1807	HS	0
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -
	HC	FST0D0-F.CODE 	:PEND STATE, ACTION = -(DISC)


	SUBTTL	FSM_DT_SEND_SDT
:******************************************************************
:	FS1900	-(FSM_DT_SEND_SDT) THIS FSM RECORDS THE ABILITY FOR
:	DATA TO FLOW IN A SESSION. THIS VERSION OF THE DATA TRAFFIC
:	FSM HANDLES SESSIONS THAT ALLOW SDT TO BE SENT. THIS FSM
:	APPEARS ONLY IN PRIMARY HALF-SESSIONS USING TS PROFILES 5&17.
:
:	RESET MEANS THAT NO DFC OR FMD TRAFFIC CAN FLOW. PEND_ACTIVE
:	STATE IS ENTERED WHEN AN SDT REQUEST IS OUTSTANDING. ACTIVE
:	MEANS THAT ALL TRAFFIC CAN FLOW.
:	PAGE 4-64 IN FAPL
:	------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 ( INDEX FOR
:			FSM STATE INFO. IN SCB), R2 (MU.DIRECTION),
:			R4 (RQ OR RSP), R7 (FSM STATE VALUE)
:			R9 (SCB ENTRY), R10 (MU_PTR), R6 (FUNCTION
:			OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS1900
	FS.MC1(FSCDSS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS1902			:NO
	CLHI	R0,FS.RET		:SIGNAL=RESET?
	JN	FS.CSG,,		:NO, OTHER SIGNALS NOT ALLOWED

:=====================================================================
:	INPUT:	'RESET'
:=====================================================================
FS1901
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC010,,		:NO, ALL OTHER STATES, ACTION = 1

:	CHECK OTHER INPUTS
:------------------------------
FS1902
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS1908			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS1904			:S, RQ

:===================================================================
:	INPUT:	S, RSP
:===================================================================
	J	FS1906			:GO GET STATE ENTRY ROUTINE

:	CHECK S, RQ INPUT
:--------------------------
FS1904
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS1906			:NO, -SDT
	CLHI	R5,SDT			:SDT?
	JN	FS1906			:S, RQ, -SDT

:==============================================================
:	INPUT:	S, RQ, SDT
:==============================================================
FS1905
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FST0F0,,		:NO, ALL OTHER STATES,ACTION=>(S0809)

:==============================================================
:	INPUT:	S, RQ, -SDT
:==============================================================
FS1906
	CLHI	R7,FS.ST3		:ACTIVE STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FST0G0,,		:NO, ALL OTHER STATES,ACTION=>(S2005)

:	CHECK RECEIVE INPUT
:----------------------------------
FS1908
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS190E			:NO, -SC
	CLHI	R5,SDT			:SDI?
	JN	FS.COD,,		:NO, R,-SDT (CRASH)
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:R, RQ, SDT - CRASH
	LB	R2,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS190A			:-RSP

:================================================================
:	INPUT:	R, +RSP, SDT
:================================================================
:	INPUT:	R, -RSP, SDT, 2007
:================================================================
FS1909
	CLHI	R7,FS.ST2		:PEND ACTIVE STATE?
	JE	FST000,,		:YES, ACTION = 3(RESETC)
	J	FST0C0,,		:NO, ALL OTHER STATES, ACTION=>(DISC)

:	CHECK R, -RSP, SDT INPUT
:----------------------------------
FS190A
	LHL	R0,BBUFER+MURHSN,R10,	:GET SNC
	CLHI	R0,.SEDTR		:2007?
	JE	FS1909			:YES


:==============================================================
:	INPUT:	R, -RSP, SDT, -2007
:==============================================================

FS190C
	CLHI	R7,FS.ST2		:PEND ACTIVE STATE?
	JE	FSC010,,		:YES, ACTION = 1
	J	FST0C0,,		:NO, ALL OTHER STATES,ACTION=>(DISC)

:	CHECK R, DFC|FMD INPUT
:------------------------------
FS190E
	CLHI	R0,MU.NC		:DFC|FMD?
	JE	FS.CAT,,		:NO, NC
	LR	R4,R4			:RQ OR RSP?
	JN	FS190G			:RSP

:================================================================
:	INPUT:	R, RQ, DFC|FMD
:================================================================
FS190F
	CLHI	R7,FS.ST3		:ACTIVE STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FST0B0,,		:NO, ALL OTHER STATES, ACTION=>(R2005)

:=================================================================
:	INPUT:	R, RSP, DFC|FMD
:=================================================================
FS190G
	CLHI	R7,FS.ST3		:ACTIVE STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FST0C0,,		:NO, ALL OTHER STATES, ACTION=>(DISC)


	SUBTTL	FSM_EBCD_RCV
:**************************************************************
:***************************************************************
:	FSM_DT_SEND_SDT_AND_CLEAR
:***************************************************************
:	FS2000	-(FSM_DT_SEND_SDT_AND_CLEAR) RECORDS THE ABILITY
:	FOR DATA TO FLOW IN A SESSION. THIS VERSION OF THE DATA 
:	TRAFFIC FSM HANDLES SESSIONS THAT ALLOW SDT AND CLEAR TO
:	BE SENT.  THIS FSM APPEARS ONLY IN PRIMARY HALF-SESSIONS
:	USING TS PROFILES 3 AND 4.
:	THE MEANING OF STATES ARE AS FOLLOWS:
:	1. RESET -NO DFC OR FMD TRAFFIC CAN FLOW
:	2. PEND_ACTIVE -INDICATES THAT AN SDT IS OUTSTANDING
:	3. ACTIVE -MEANS THAT ALL TRAFFIC CAN FLOW
:	4. PEND_RESET -MEANS THAT A CLEAR IS OUTSTANDING
:	PAGE 4-62 ON FAPL
:	-----------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:R9 (SCB ENTRY) R10 (MU PTR) R0 (FSM INPUT SIGNAL,OPTION)
:		 R1 (INDEX FOR FSM STATE INF. IN SCB) R2 (MU.DIRECTION)
:		 R4 (RQ OR RSP), R7 (FSM STATE VALUE), R6 (FUNCTION OR CALL) 
:	OUTPUT	:R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:		R8 THRU R15 ARE UNCHANGED
:	LINK	:R3
:	WORKING	:R0,R1,R2,R4,R5,R6,R7 ARE DESTROYED
FS2000
	FS.MC1(FSCDSA,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS2002			:NO
	CLHI	R0,FS.RET		:SIGNAL=RESET?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID

:==================================================================
:	INPUT:	'RESET'
:==================================================================
FS2001
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:----------------------------------
FS2002
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS2004			:RECEIVE
	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS2004			:REQUEST

:=================================================================
:	INPUT:	S, RSP
:================================================================
FS2003
	CLHI	R7,FS.ST3		:ACTIVE STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FST0G0,,		:NO, ALL OTHER STATES, ACTION=>(S2005)

:	CHECK FOR SESSION CONTROL (SC) INPUT
:--------------------------------------------
FS2004
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JE	FS2005			:YES
	LR	R2,R2			:SEND OR RCV?
	JN	FS200M			:RCV, GO CHECK FOR DFC|FMD
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP
	J	FS200L			:RQ, INPUT=S, RQ, -(CLEAR|SDT|STSN|CRV)
FS2005
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,SDT			:SDT?
	JN	FS200C			:NO, -SDT
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS2006			:RECEIVE
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:S, RSP, SDT - CRASH

:======================================================================
:	INPUT:	S, RQ, SDT
:=======================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FST0F0,,		:NO, ALL OTHER STATES, ACTION=>(S0809)

:	CHECK FOR R, SDT INPUT
:----------------------------------
FS2006
	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS.CRQ,,		:R, RQ, SDT - CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS2008			:-RSP

:===================================================================
:	INPUT:	R, +RSP, SDT
:===================================================================
FS2007
	CLHI	R7,FS.ST2		:PEND ACT STATE?
	JE	FSC030,,		:YES, ACTION = 3
	J	FST0C0,,		:NO, ALL OTHER STATES,ACION=>(DISC)

:	CHECK R, -RSP, SDT INPUT
:-------------------------------------
FS2008
	LHL	R0,BBUFER+MURHSN,R10,	:GET SNC
	CLHI	R0,.SEDTR		:SNC = 2007?
	JN	FS200A			:NO, -2007

:=================================================================
:	INPUT:	R, -RSP, SDT, 2007
:=================================================================
	J	FS2007,,		:GO GET STATE ENTRY ROUTINE

:================================================================
:	INPUT:	R, -RSP, SDT, -2007
:================================================================
FS200A
	CLHI	R7,FS.ST2		:PEND ACT STATE?
	JE	FSC010,,		:YES, ACTION = 1
	J	FST0C0,,		:NO, ALL OTHER STATES, ACTION =>(DISC)

:	CHECK FOR CLEAR INPUT
:----------------------------------
FS200C
	CLHI	R5,CLEAR		:CLEAR?
	JN	FS200I			:NO, -CLEAR
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS200E			:RECEIVE
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, INVALID INPUT

:=================================================================
:	INPUT:	S, RQ, CLEAR
:=================================================================
	CLHI	R7,FS.ST4		:PEND RESET STATE?
	JE	FST030,,		:YES, ACTION = -(RESETC)
	J	FST010,,		:NO, ALL OTHER STATES,ACTION=4(RESETC)

:	CHECK R, CLEAR INPUT
:---------------------------------------
FS200E
	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS.CRQ,,		:REQUEST, CRASH
	LHL	R0,BBUFER+MUSNF,R10,	:GET SNF
:	CLH	R0,SCBBLK+SCLCSN,R9,	:SNF=LAST_CLEAR_SNF? (12/6/84 MIA)
	LHL	R5,SCBBLK+SCLCSN,R9,	:GET LAST_CLEAR_SNF (12/6/84 MIA)
	CR	R0,R5			:EQUAL? (12/6/84 MIA)
	JN	FS200G			:NO, -LAST_CLEAR

:================================================================
:	INPUT:	R, RSP, CLEAR, LAST_CLEAR
:=================================================================
	CLHI	R7,FS.ST4		:PEND RESET STATE?
	JE	FSC010,,		:YES, ACTION = 1
	J	FST0C0,,		:NO, ALL OTHER STATES, ACTION=>(DISC)

:=========================================================================
:	INPUT:	R, RSP, CLEAR, -LAST_CLEAR
:=========================================================================
FS200G
	CLHI	R7,FS.ST4		:PEND RESET STATE, ?
	JE	FSC000,,		:YES, ACTION = -
	J	FST0C0,,		:NO, ALL OTHER STATES, ACTION = >(DISC)

:	CHECK S, RQ, -(CLEAR|SDT) INPUT
:--------------------------------------------------------------
FS200I
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS.CRV,,		:RECEIVE, CRASH
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP
	CLHI	R5,STSN			:STSN?
	JN	FS200K			:S, RQ, -(CLEAR|SDT|STSN)

:======================================================================
:	INPUT:	S, RQ, STSN
:======================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FST0H0,,		:NO, ALL OTHER STATES,ACTION=>(S2007)

:	CHECK FOR S, RQ, -(CLEAR|SDT|STSN) INPUT
:--------------------------------------------------------------
FS200K
	CLHI	R5,CRV			:CRV?
	JE	FS.COD,,		:YES, CRASH

:===================================================================
:	INPUT:	S, RQ, -(CLEAR|SDT|STSN|CRV)
:===================================================================
FS200L
	J	FS2003			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR RCV DFC|FMD INPUT
:-------------------------------------------
FS200M
	CLHI	R0,MU.NC		:FMD|DFC?
	JE	FS.CAT,,		:NO, NETWORK CONTROL
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS200O			:RESPONSE

:===========================================================
:	INPUT:	R, RQ, DFC|FMD
:===========================================================
FS200N
	LHL	R5,TS200C,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS200C	HS	0
	HC	FST0B0-F.CODE 	:RESET STATE, ACTION = >(R2005)
	HC	FST0B0-F.CODE 	:PEND ACTIVE STATE, ACTION = >(R2005)
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -
	HC	FST0D0-F.CODE 	:PEND RESET STATE, ACTION = -(DISC)

:=============================================================
:	INPUT:	R, RSP, DFC|FMD
:=============================================================
FS200O
	LHL	R5,TS200D,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS200D	HS	0
	HC	FST0C0-F.CODE 	:RESET STATE, ACTION = >(DISC)
	HC	FST0C0-F.CODE 	:PEND ACTIVE STATE, ACTION = >(DISC)
	HC	FSC000-F.CODE 	:ACTIVE STATE, ACTION = -
	HC	FST0D0-F.CODE 	:PEND RESET STATE, ACTION = -(DISC)

	SUBTTL	FSM_RQR_RCV
:*********************************************************************
:	FS3400	-(FSM_RQR_RCV) THIS FSM RECORDS THE RECEIPT OF A
:	REQUEST RECOVERY (RQR). THIS FSM APPEARS ONLY IN PRIMARY
:	HALF-SESSIONS THAT SUPPORT RQR.
:
:	RESET STATE MEANS THAT THERE IS NO OUTSTANDING RQR. PEND
:	STATE INDICATES THAT THE SERVICES MANAGER IS PROCESSING AN RQR.
:	PAGE 4-68 IN FAPL
:	------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR 
:			FSM STATE INFO IN SCB), R2 (MU.DIRECTION),
:			R4 (RQ OR RSP), R9 (SCB ENTRY), R10 (MU_PTR)
:			R7 (FSM STATE VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS3400
	FS.MC1(FSCRQR,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS3402			:NO
	CLHI	R0,FS.RET		:RESET?
	JN	FS.CSG,,		:NO, CRASH

:=====================================================================
:	INPUT:	'RESET'
:=====================================================================
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:--------------------------------------
FS3402
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, CRASH
	CLHI	R5,RQR			:RQR?
	JN	FS.COD,,	:NO, -RQR SO CRASH
	LR	R2,R2			:SEND OR RCV?
	JE	FS3404			:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH

:====================================================================
:	INPUT:	R, RQ, RQR
:====================================================================
	LHL	R5,TS3402,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3402	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 2
	HC	FST080-F.CODE 	:PEND STATE, ACTION = >(R0809)

:	CHECK FOR SEND, RQR INPUT
:---------------------------------
FS3404
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ, CRASH

:==================================================================
:	INPUT:	S, RSP, RQR
:==================================================================
FS3406
	LHL	R5,TS3403,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3403	HS	0
	HC	FST0F0-F.CODE 	:RESET STATE, ACTION = >(S0809)
	HC	FSC010-F.CODE 	:PEND STATE, ACTION = 1

	SUBTTL	FSM_RQR_SEND
:***********************************************************************
:	FS3500	-(FSM_RQR_SEND) THIS FSM RECORDS THE SENDING OF A
:	REQUEST RECOVERY (RQR). THIS FSM APPEARS ONLY IN SECONDARY
:	HALF-SESSIONS THAT SUPPORT RQR.
:
:	RESET STATE MEANS THAT THERE IS NO OUTSTANDING RQR. PEND STATE
:	INDICATES AN OUTSTANDING RQR.
:	PAGE 4-67
:	--------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR 
:			FSM STATE INFO IN SCB), R2 (MU.DIRECTION),
:			R4 (RQ OR RSP), R9 (SCB ENTRY), R10 (MU_PTR)
:			R7 (FSM STATE VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS3500
	FS.MC1(FSCRQS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS3502			:NO
	CLHI	R0,FS.RET		:RESET?
	JN	FS.CSG,,		:NO, ALL OTHER SIGNALS INVALID

:===================================================================
:	INPUT:	'RESET'
:===================================================================
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:------------------------------
FS3502
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL?
	JN	FS.CAT,,		:NO
	CLHI	R5,RQR			:RQR?
	JN	FS.COD,,		:NO, CRASH
	LR	R4,R4			:RSP OR RQ?
	JN	FS3504			:RSP
	LR	R2,R2			:SEND OR RCV?
	JN	FS.CRV,,		:RCV, CRASH

:=======================================================================
:	INPUT:	S, RQ, RQR
:=======================================================================
	LHL	R5,TS3502,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3502	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 2
	HC	FST0F0-F.CODE 	:PEND STATE, ACTION = >(S0809)

:	CHECK FOR RECEIVE INPUT
:----------------------------------
FS3504
	LR	R2,R2			:SEND OR RCV?
	JE	FS.CSD,,		:SEND, CRASH

:========================================================================
:	INPUT:	R, RSP, RQR
:========================================================================
	J	FS1809,,		:GO GET STATE ENTRY ROUTINE

	SUBTTL	FSM_SESSION_BIU_ASSEMBLY
:*********************************************************************
:	FS5100	-(FSM_SESSION_BIU_ASSEMBLY) THIS FINITE STATE MACHINE IS
:	USED TO MAINTAIN THE STATE OF A HALF-SESSION RELATIVE TO BIU
:	ASSEMBLY. IT IS APPLICABLE WHEN BIU ASSEMBLY IS PERFORMED ON A
:	SESSION BASIS.
:
:	THE BETBIU STATE INDICATES "BETWEEN BIU'S"--A BIU IS NOT BEING
:	ASSEMBLED FROM PIU'S CONTINING BIU SEGMENTS.
:
:	THE INBIU STATE INDICATES "IN BIU ASSEMBLY"--A BIU IS BEING 
:	ASSEMBLED FROM PIU'S CONTAINING BIU SEGMENTS.
:	PAGE 3-102 IN FAPL
:	---------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (BBIU FROM MUCB), R4 (BBIU
:			FROM MUCB), R9 (SCB ENTRY), R10 (MU_PTR),
:			R6 (FUNCTION OR CALL), R7 (FSM STATE VALUE)
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
FS5100
	LR	R0,R0			:SIGNAL=PRESENT?
	JEFS	FS5104			:NO
	CLHI	R0,FS.RET		:SIGNAL=RESET?
	JN	FS.CSG,,		:NO, CRASH

:===========================================================================
:	INPUT:	'RESET'
:===========================================================================
FS5102
	CLHI	R0,FS.ST1		:BETBIU STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC010,,		:NO, INBIU STATE,ACTION= 1

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:--------------------------------------------
FS5104
	LR	R2,R2			:BBIU?
	JE	FS5106			:NO, -BBIU
	LR	R4,R4			:EBIU?

:====================================================================
:	INPUT:	BBIU, EBIU
:====================================================================
	JN	FS5102			:YES, GO GET STATE ACTION ROUTINE

:=====================================================================
:	INPUT:	BBIU, -EBIU
:=====================================================================
	CLHI	R7,FS.ST1		:BETBIU STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FSC000,,		:NO, INBIU STATE, ACTION = -

:	CHECK FOR -BBIU INPUT
:---------------------------------
FS5106
	LR	R4,R4			:EBIU?
	JE	FS5108			:NO, -EBIU

:======================================================================
:	INPUT:	-BBIU, EBIU
:======================================================================
	CLHI	R7,FS.ST1		:BETBIU STATE?
	JE	FS.CIN,,		:YES, ACTION = /
	J	FSC010,,		:NO, INBIU STATE, ACTION = -

:=======================================================================
:	INPUT:	-BBIU, -EBIU
:=======================================================================
FS5108
	CLHI	R7,FS.ST1		:BETBIU STATE?
	JE	FS.CIN,,		:YES, ACTION = /
	J	FSC000,,		:NO, ACTION = -
	



	SUBTTL	FSM_STSN_RCV
:**********************************************************************
:	FS5400	-(FSM_STSN_RCV) THIS FSM RECORDS THE RECEIPT OF A SET AND
:	TEST SEQUENCE NUMBER (STSN). THIS FSM APPEARS ONLY IN SECONDARY
:	HALF SESSIONS THAT SUPPORT STSN.
:
:	RESET STATE MEANS THAT THERE IS NO OUTSTANDING STSN. PEND STATE
:	INDICATES THAT THE SERVICES MANAGER IS PROCESSING A STSN.
:	PAGE 4-69 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM 
:			STATE INFO IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU.PTR), R6 (FUNCTION
:			CALL), R7 (FSM STATE VALUE)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS5400
	FS.MC1(FSCSNR,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS5402			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, ALL OTHER SIGNALS INVALID

:======================================================================
:	INPUT:	RESET
:======================================================================
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER INPUT
:----------------------------------
FS5402
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, INVALID INPUT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,STSN			:STSN RU?
	JN	FS.COD,,		:NO, CRASH
	LR	R2,R2			:SEND OR RCV?
	JE	FS5404			:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:R, RSP INPUT - CRASH

:==============================================================
:	INPUT:	R, RQ, STSN
:==============================================================
	LHL	R5,TS5402,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5402	HS	0
	HC	FST0K0-F.CODE 	:RESET STATE, ACTION = 2(SET)
	HC	FST080-F.CODE 	:PEND STATE, ACTION = >(R0809)

:	CHECK FOR SEND INPUT
:--------------------------------
FS5404	
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:S, RQ INPUT - CRASH

:======================================================================
:	INPUT:	S, RSP, STSN
:======================================================================
	J	FS3406,,		:GO GET STATE ENTRY ROUTINE

	SUBTTL	FSM_STSN_SEND
:**********************************************************************
:	FS5500	-(FSM_STSN_SEND) THIS FSM RECORDS THE SENDING OF A
:	SET AND TEST SEQUENCE NUMBER (STSN). THIS FSM APPEARS ONLY IN 
:	PRIMARY HALF-SESSIONS THAT SUPPORT STSN.
:
:	RESET STATE MEANS THAT THERE IS NO OUTSTANDING STSN. PEND
:	STATE INDICATES THAT THERE IS AN OUTSTANDING STSN.
:	PAGE 4-68 IN FAPL
:	-------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM SIGNAL INPUT, OPTION), R1 (INDEX FOR FSM
:			STATE INFO IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU_PTR), R6 (FUNCTION
:			OR CALL), R7 (FSM STATE VALUE)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS5500
	FS.MC1(FSCSNS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS5502			:NO
	CLHI	R0,FS.RET		:RESET?
	JN	FS.CSG,,		:NO, ALL OTHER SIGNALS NOT VALID

:=====================================================================
:	INPUT:	'RESET'
:=====================================================================
	J	FS1901,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:-------------------------------
FS5502
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, CRASH
	CLHI	R5,STSN			:STSN?
	JN	FS.COD,,		:NO, CRASH
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS5504			:RECEIVE
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:S,RSP, STSN INPUT - CRASH
	
:=====================================================================
:	INPUT:	S, RQ, STSN
:=====================================================================
FS5503
	LHL	R5,TS5502,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5502	HS	0
	HC	FST0K0-F.CODE 	:RESET STATE, ACTION = 2(SET)
	HC	FST0F0-F.CODE 	:PEND STATE, ACTION = >(S0809)

:	CHECK RECEIVE INPUT
:--------------------------------
FS5504
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:R, RQ, STSN INPUT - CRASH

:==================================================================
:	INPUT:	R, RSP, STSN
:==================================================================
	LHL	R5,TS5503,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5503	HS	0
	HC	FST0C0-F.CODE 	:RESET STATE, ACTION = >(DISC)
	HC	FSC010-F.CODE 	:PEND STATE, ACTION = 1

	FO	CBKDEF
	FO	CMDLST	
	
	EM				:END OF MODULE SSTF00

  	SUBTTL	MSCELLANEOUS DFC FSM'S USING SCB ('SSDF00')
:	********************************************************************
:	REVISION HISTORY
:	03/28/84 (DRUE BONDAD)	- ORIGINAL DESIGN AND CODING
:	********************************************************************


	RA	0
	
	MO	.,SNAPKG
	LO	CMDLST
	LO	CBKDEF
	GL	FS05D0

	SEG	A.CODE

FSNOOP
	IF	FN.FSM			:(3/22/84 NCS) FOR TESTING
	LIS	R1,0
	ELSE
	LIS	R1,0
	EI				:(3/22/84)
	J	FSC000,,		:(3/25/84 NCS) FOR TESTING
	JR	R3			:RETURN

	SUBTTL	FSM_CHAIN_RCV
:******************************************************************
:	FSM_CHAIN_RCV
:******************************************************************
:	FS0200	-(FSM_CHAIN_RCV) ENFORCES THE CHAINING PROTOCOL
:		 FOR RECEIVED CHAINS. SEE "CHAINING PROTOCOL" ON
:		 PAGE 5-8 OF FAPL FOR PROSE DESCRIPTION. THERE ARE
:		 3 STATE IN THIS FSM AND THEIR MEANINGS ARE AS 
:		 FOLLOWS:
:		 1. BETC (BETWEEN-CHAINS STATE): NOT CURRENTLY IN THE
:		    PROCESS OF RECEIVING A CHAIN. THE NEXT REQUEST
:		    RU MUST HAVE THE BEGIN CHAIN INDICATOR (BCI) SET.
:		 2. INC (IN-CHAIN STATE): CURRENTLY IN THE PROCESS OF
:		    RECEIVING A CHAIN. THE CHAIN IS ENDED WHEN A 
:		    REQUEST RU WITH THE END CHAIN INDICATOR (ECI) SET
:		    IS RECEIVED.
:		 3. PURGE (PURGING-CHAIN STATE): MEANS HAVE SENT A
:		    NEGATIVE RESPONSE WHILE IN THE PROCESS OF RECEIVING 
:		    A CHAIN. THIS STATE IS USED TO PURGE PURGE (DISCARD)
:		    THE REMAINING REQUESTS IN THE CHAIN.
:		 PAGE 5-72 IN FAPL
:		--------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE 
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK),
:			R8 THRU R15 RE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R2, R4, R5, R7, R1 ARE DESTROYED
:
FS0200
	FS.MC1(FSCCRV,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS0202			:NO, GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:YES. IS IT RESET?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID.
:=====================================================================
:	INPUT:	'RESET'
:=====================================================================
FS0201
	CLHI	R7,FS.ST1		:BETC STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC010,,		:NO, ALL OTHER STATES, ACTION = 1

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:--------------------------------------------
FS0202
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS0204			:RECEIVE
	LR	R4,R4			:SEND. REQUEST OR RESPONSE?
	JE	FS.CRQ,,		:REQUEST, INVALID INPUT.
	LB	R2,BBUFER+MURHF2,R10,	:RESPONSE. GET RTI BIT
	NHI	R2,MU.RTI		:NEGATIVE RESPONSE?
	JE	FS.CPS,,		:NO, INVALID INPUT.
	JAL	R4,FS05D0,,		:YES. CHECK IF TO_CURRENT_CHAIN?
	J	FS.CUR,,		:NO, INVALID INPUT.

:=======================================================================
:	INPUT:	S, -RSP, TO_CURRENT_CHAIN
:=======================================================================
	CLHI	R7,FS.ST2		:INC STATE?
	JE	FSC030,,		:YES, ACTION = 3
	J	FSC000,,		:NO, ALL OTHER STATE, ACTION = -

:	CHECK FOR RECEIVE INPUT
:-----------------------------------
FS0204
	LR	R4,R4			:REQUEST?
	JN	FS.CRS,,		:NO, INVALID INPUT.
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS0206			:NO, DON'T CHECK ACTION_CODE
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET REQUEST CODE
	CLHI	R0,CANCEL		:CANCEL?
	JN	FS0206			:NO. -CANCEL INPUT

:======================================================================
:	INPUT:	R, RQ, CANCEL
:======================================================================
	CLHI	R7,FS.ST1		:BETC STATE?
	JE	FSD000,,		:YES, ACTION = >(R)
	J	FSC010,,		:NO, ALL OTHER STATES, ACTION = 1

:	CHECK FOR -CANCEL INPUT
:-----------------------------------
FS0206
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.BCI+MU.ECI	:MASK FOR BBI AND EBI 
	JE	FS020C			:-BC AND -EC
	CLHI	R2,MU.BCI		:BC AND-EC?
	JEFS	FS0208			:YES
	CLHI	R2,MU.ECI		:-BC AND EC?
	JE	FS020A			:YES

:=============================================================
:	INPUT:	R, RQ, -CANCEL, BC, EC
:=============================================================
	CLHI	R7,FS.ST1		:NO,(MUST BE BB,EC). BETC STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD000,,		:NO, ALL OTHER STATE, ACTION = >(R)

:===============================================================
:	INPUT:	R, RQ, -CANCEL, BC, -EC
:===============================================================
FS0208
	CLHI	R7,FS.ST1		:BETC STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FSD000,,		:NO, ALL OTHER STATES, ACTION=>(R)

:=====================================================================
:	INPUT:	R, RQ, -CANCEL, -BC, EC
:=====================================================================
FS020A
	CLHI	R7,FS.ST1		:BETC STATE?
	JE	FSD000,,		:YES, ACTION = >(R)
	J	FSC010,,		:NO, ALL OTHER STATES, ACTION = 1

:======================================================================
:	INPUT:	R, RQ, -CANCEL, -BC, -EC
:======================================================================
FS020C
	CLHI	R7,FS.ST1		:BETC STATE?
	JE	FSD000,,		:YES, ACTION = >(R)
	J	FSC000,,		:NO, ALL OTHER STATE, ACTION = -



	SUBTTL	FSM_CHAIN_SEND
:***********************************************************************
:	FSM_CHAIN_SEND
:***********************************************************************
:	FS0300	-(FSM_CHAIN_SEND) ENFORCES THE CHAINING PROTOCOL FOR
:	SENDING CHAINS. SEE "CHAINING PROTOCOL" ON PAGE 5-8 IN FAPL
:	FOR PROSE DESCRIPTION. THERE ARE 2 STATES IN THIS FSM, AND THEY
:	ARE AS FOLLOWS:
:	1. BETC (BETWEEN-CHAINS STATE): MEANS NOT CURRENTLY IN THE
:	PROCESS OF SENDING A CHAIN.
:	2. INC (IN-CHAIN STATE): MEANS CURRENTLY IN THE PROCESS OF
:	SENDING A CHAIN.
:	PAGE 5-72 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R2, R4, R5, R6, R7, R1 ARE DESTROYED
FS0300
	FS.MC1(FSCCSD,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS0302			:NO, GO CHECK FOR OTHER INPUTS
	CLHI	R0,FS.RET		:IS IT RESET SIGNAL?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID

:==================================================================
:	INPUT:	'RESET'
:==================================================================
FS0301
	J	FS0201,,		:GO CALL STATE ENTRY ROUTINE

:	CHECK FOR INPUTS OTHER THAN SIGNAL INPUT
:-----------------------------------------------------
FS0302
	LR	R2,R2			:SEND?
	JN	FS.CRV,,		:NO, INVALID INPUT
	LR	R4,R4			:REQUEST?
	JN	FS.CRS,,		:NO, INVALID INPUT
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS0304			:NO, DON'T CHECK ACTION_CODE
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU PTR FROM MUCB
	LB	R0,BBUFER,R1,		
	CLHI	R0,CANCEL		:CANCEL?
	JN	FS0304			:-CANCEL

:===============================================================
:	INPUT:	S, RQ, CANCEL
:===============================================================
	J	FS0308			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR -CANCEL INPUT
:-----------------------------------
FS0304
	LB	R2,BBUFER+MURHF1,R10,	:GET BCI AND ECI BITS
	NHI	R2,MU.BCI+MU.ECI	:BC AND EC?
	JE	FS030A			:-(BC & EC)
	CLHI	R2,MU.ECI		:-BC & EC?
	JE	FS0308			:YES
	CLHI	R2,MU.BCI		:BC & -EC?
	JE	FS0306			:YES

:==================================================================
:	INPUT:	S, RQ, -CANCEL, BC, EC
:===================================================================
	CLHI	R7,FS.ST1		:BETC STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD050,,		:NO, INC STATE, ACTION = >(S)


:=====================================================================
:	INPUT:	S, RQ, -CANCEL, BC, -EC
:=====================================================================
FS0306
	CLHI	R7,FS.ST1		:BETC STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FSD050,,		:NO, INC STATE,ACTION = >(S)


:=============================================================
:	INPUT:	S, RQ, -CANCEL, -BC, EC
:=============================================================
FS0308
	CLHI	R7,FS.ST1		:BETC STATE?
	JE	FSD050,,		:YES, ACTION = >(S)
	J	FSC010,,		:NO, INC STATE, ACTION = 1

:==============================================================
:	INPUT:	S, RQ, -CANCEL, -BC, -EC
:==================================================================
FS030A
	CLHI	R7,FS.ST1		:BETC STATE?
	JE	FSD050,,		:YES, ACTION = >(S)
	J	FSC000,,		:NO, INC STATE, ACTION = -



	SUBTTL	FSM_EBCD_RCV
:**************************************************************
:	FS2100	-(FSM_EBCD_RCV) THE FUNCTION OF THIS FSM IS TO
:	ENFORCE THAT EB CHAINS DO NOT HAVE CD SET ON END OF 
:	CHAIN.
:	PAGE 5-81 IN FAPL
:	-------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY),
:			R10 (MU PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7, ARE DESTROYED
FS2100
	FS.MC1(FSCERV,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS2102			:NO, GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID INPUTS

:=======================================================================
:	INPUT:	'RESET'
:=======================================================================
	J	FS0201,,		:YES, GO GET STATE ENTRY ROUTINE

:
:	CHECK OTHER INPUTS
:--------------------------
FS2102
	LR	R2,R2			:RECEIVE OR SEND?
	JE	FS.CSD,,		:SEND, CRASH
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RSP, CRASH
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS2106			:NO, DO'T CHECK ACTION_CODE
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU_PTR
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,CANCEL		:CANCEL?
	JN	FS2106			:NOT CANCEL, CHECK OTHER INPUTS
	LB	R2,BBUFER+MURHF3,R10,	:GET LAST BYTE OF RH
	NHI	R2,MU.CDI		:CHANGE DIRECTION INDICATOR SET?
	JE	FS2104			:-CD INPUT

:======================================================================
:	INPUT:	R, RQ, CANCEL,CD
:======================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD010,,		:NO, INC STATE, ACTION = >(R)

:========================================================================
:	INPUT:	R, RQ, CANCEL, -CD
:========================================================================
FS2104
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, RQ, NOT CANCEL INPUTS
:---------------------------------------------
FS2106
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.BCI+MU.ECI	:GET JUST BC AND EC INDICATORS
	CLHI	R0,MU.BCI		:BC,-EC?
	JN	FS2108			:NO
	LB	R0,BBUFER+MURHF3,R10,	:GET THIRD BYTE OF RH
	NHI	R0,MU.EBI		:END BRACKET INDICATOR SET?
	JE	FS.CEB,,		:NO, (-EB) 
:=======================================================================
:	INPUT:	R, RQ, BC, -EC, EB
:=======================================================================
FS2107
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FS.CIN,,		:NO, INC STATE, ACTION = /

:	CHECK -BC INPUTS
:---------------------------------
FS2108
	CLHI	R0,MU.ECI		:-BC,EC?
	JN	FS.CEC,,		:NO, CRASH
	LB	R0,BBUFER+MURHF3,R10,	:GET LAST BYTE OF RH
	NHI	R0,MU.CDI		:CHANGE DIRECTION INDICATOR SET?
	JE	FS210A			:NO, -BC & EC & -CD INPUT

:==================================================================
:	INPUT:	R, RQ, -BC, EC, CD
:==================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD010,,		:NO, INC STATE, ACTION = >(R)

:===================================================================
:	INPUT:	R, RQ, -BC, EC, -CD
:===================================================================
FS210A
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE



	SUBTTL	FSM_EBCD_SEND
:************************************************************************
:	FSM_EBCD_SEND
:************************************************************************
:	FS2200	-(FSM_EBCD_SEND) THE FUNCTION OF THIS FSM IS TO ENFORCE
:	THAT EB CHAINS DO NOT HAVE CD SET ON END OF CHAIN.
:	PAGE 5-81 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP),  R9 (SCB ENTRY), R10 (MU PTR), R7 ( FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS2200
	FS.MC1(FSCESD,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS2202			:NO, GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:SIGNAL = 'RESET'?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID INPUT

:==========================================================================
:	INPUT:	'RESET'
:==========================================================================
	J	FS0201,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK INPUTS OTHER THAN SINAL INPUT
:---------------------------------------------
FS2202
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS.CRV,,		:RECEIVE, CRASH
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RESPONSE, CRASH
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS2206			:NO, DON'T CHECK ACTION_CODE
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,CANCEL		:CANCEL?
	JN	FS2206			:NO, GO CHECK NOT CANCEL INPUTS
	LB	R2,BBUFER+MURHF3,R10,	:GET LAST BYTE OF RH
	NHI	R2,MU.CDI		:CHANGE DIRECTION INDICATOR SET?
	JE	FS2204			:NO, -CD INPUT

:================================================================
:	INPUT:	S, RQ, CANCEL, CD
:================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD060,,		:NO, ACTION = >(S)

:================================================================
:	INPUT:	S, RQ, CANCEL, -CD
:================================================================
FS2204
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK NOT CANCEL INPUTS
:------------------------------------
FS2206
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	LR	R2,R0
	NHI	R0,MU.BCI		:BEGIN CHAIN INDICATOR SET?
	JE	FS2208			:NO, GO CHECK -BC INPUT
	NHI	R2,MU.ECI		:END CHAIN INDICATOR SET?
	JN	FS.CEC,,		:YES, BC & EC INPUT INVALID
	LB	R0,BBUFER+MURHF3,R10,	:GET LAST BYTE OF RH
	NHI	R0,MU.EBI		:END BRACKET INDICATOR SET?
	JE	FS.CEB,,		:NO, BC & -EC & -EB INPUT INVALID

:=======================================================================
:	INPUT:	S, RQ, BC, -EC, EB
:========================================================================
	J	FS2107,,		:GO GET STATE ENTRY ROUTINE

:	CHECK -BC INPUTS
:-------------------------------------------
FS2208
	NHI	R2,MU.ECI		:END CHAIN INDICATOR SET?
	JE	FS.CEC,,		:NO, -EC INVALID
	LB	R0,BBUFER+MURHF3,R10,	:GET LAST BYTE OF RH
	NHI	R0,MU.CDI		:CHANGE DIRECTION INDICATOR SET?
	JE	FS220A			:NO, -CD INPUT

:===============================================================
:	INPUT:	S, RQ, -BC, EC, CD
:===============================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD060,,		:NO, INC STATE, ACTION = >(S)

:==============================================================
:	INPUT:	S, RQ, -BC, EC, -CD
:==============================================================
FS220A
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE


	SUBTTL	FSM_IMM_RQ_MODE_RCV
:*********************************************************************************
:	FS2600	-(FSM_IMM_RQ_MODE_RCV)THE FUNCTION OF THIS FSM IS TO
:	ENFORCE THE IMMEDIATE REQUEST MODE PROTOCOL FOR NORMAL FLOW.
:	SEE CHAPTER 4 FOR PROSE DESCRIPTION.
:	PAGE 5-86 IN FAPL
:	--------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R6 (FUNCTION
:			OR CALL), R7 (FSM STATE VALUE)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS2600
	FS.MC1(FSCIRR,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS2602			:NO, GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID

:================================================================
:	INPUT:	'RESET'
:===============================================================
FS2601
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:------------------------------
FS2602
	LR	R2,R2			:SEND OR RECEIVE?
	JE	FS260C	 		:SEND, GO CHECK SEND INPUT
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RESPONSE, CRASH
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS2606			:NO, DON'T CHECK ACTION_CODE
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU_PTR
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,CANCEL		:CANCEL?
	JN	FS2606			:NO, GO CHECK -CANCEL INPUTS

:=====================================================================
:	INPUT:	R, RQ, CANCEL
:=====================================================================
	LHL	R5,TS2602,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2602	HS	0
	HC	FSC050-F.CODE 	:RESET STATE, ACTION = 5
	HC	FSD030-F.CODE 	:RCVD RQD -CANCEL STATE, ACTION=>(R)
	HC	FSC050-F.CODE 	:INC STATE, ACTION = 5
	HC	FSC050-F.CODE 	:INC RSP SENT STATE, ACTION=5
	HC	FSD030-F.CODE 	:RCVD RQD CANCEL, ACTION = >(R)

:	CHECK R, RQ, -CANCEL INPUTS
:-----------------------------------------
FS2606
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.ECI		:END CHAIN INDICATOR SET?
	JN	FS2608			:YES, EC INPUT

:===================================================================
:	INPUT:	R, RQ, -CANCEL, -EC
:==================================================================
	LHL	R5,TS2603,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2603	HS	0
	HC	FSC030-F.CODE 	:RESET STATE, ACTION = 3
	HC	FSD030-F.CODE 	:RCVD RQD -CANCEL, ACTION = >(R)
	HC	FSC000-F.CODE 	:INC STATE, ACTION = -
	HC	FSC000-F.CODE 	:INC RSP SENT STATE, ACTION = -
	HC	FSD030-F.CODE 	:RCVD RQD CANCEL STATE, ACTION=>(R)

:	CHECK R, RQ, -CANCEL, EC INPUTS
:------------------------------------------------

FS2608
	LB	R2,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	LR	R0,R2
	NHI	R2,MU.ERI		:EXCEPTION RESPONSE INDICATOR SET?
	JN	FS260A			:YES, -RQD INPUT
	NHI	R0,MU.DR1I+MU.DR2I	:DEFINITE RESPONSE INDICATOR 1/2 SET?
	JE	FS260A			:NO, -RQD INPUT

:====================================================================
:	INPUT:	R, RQ, -CANCEL, EC, RQD
:====================================================================
	LHL	R5,TS2604,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2604	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 2
	HC	FSD030-F.CODE 	:RCVD RQD -CANCEL, ACTION = >(R)
	HC	FSC020-F.CODE 	:INC STATE, ACTION = 2
	HC	FSC010-F.CODE 	:INC RSP SENT STATE, ACTION = 1
	HC	FSD030-F.CODE 	:RCVD RQD CANCEL STATE, ACTION=>(R)

:====================================================================
:	INPUT:	R, RQ, -CANCEL, EC, -RQD
:====================================================================
FS260A
	LHL	R5,TS2605,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2605	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSD030-F.CODE 	:RCVD RQD -CANCEL STATE, ACTION = >(R)
	HC	FSC010-F.CODE 	:INC STATE, ACTION = 1
	HC	FSC010-F.CODE 	:INC RSP SENT STATE, ACTION = 1
	HC	FSD030-F.CODE 	:RCVD RQD CANCEL STATE, ACTION = >(R)

:	CHECK SEND INPUT
:----------------------------------
FS260C
	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS.CRQ,,		:REQUEST, CRASH
	JAL	R4,FS05D0,,		:TO_CURRENT_CHAIN?
	J	FS.CUR,,		:NO, CRASH
	CLHI	R5,CANCEL		:CANCEL?
	JE	FS260E			:YES

:=================================================================
:	INPUT:	S, RSP, -CANCEL, TO_CURRENT_CHAIN
:================================================================
FS260D
	LHL	R5,TS2606,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2606	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSC010-F.CODE 	:RCVD RQD -CANCEL STATE, ACTION = 1
	HC	FSC040-F.CODE 	:INC STATE, ACTION = 4
	HC	FSC000-F.CODE 	:INC RSP SENT STATE, ACTION = -
	HC	FSC000-F.CODE 	:RCVD RQD CANCEL STATE, ACTION = -

:===============================================================
:	INPUT:	S, RSP, CANCEL, TO_CURRENT_CHAIN
:==============================================================
FS260E
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE




	SUBTTL	FSM_IMM_RQ_MODE_SEND
:***************************************************************
:	FSM_IMM_RQ_MODE_SEND
:***************************************************************
:	FS2700	-(FSM_IMM_RQ_MODE_SEND) THE FUNCTION OF THIS FSM
:	IS TO ENFORCE THE IMMEDIATE REQUEST MODE PROTOCOL FOR THE 
:	NORMAL FLOW. SEE CHAPTER 4 IN FAPL FOR PROSE DESCRIPTION.
:	PAGE 5-86 IN FAPL
:	----------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR
:			FSM STATE INFO. IN SCB), R2 (MU.DIRECTION),
:			R4 (RQ OR RSP), R9 (SCB ENTRY), R10 (MU PTR)
:			R6 (FUNCTION OR CALL), R7 (FSM STATE VALUE)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS2700
	FS.MC1(FSCIRS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS2702			:NO, GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:SIGNAL = 'RESET'?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID INPUTS
	
:=====================================================================
:	INPUT:	'RESET'
:=====================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:-------------------------------
FS2702
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU PTR
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS270C			:RECEIVE, GO CHECK RCV INPUTS
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RESPONSE, CRASH
	CLHI	R0,MU.DFC		:RU = DFC?
	JN	FS2706			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,CANCEL		:CANCEL?
	JN	FS2706			:NO, GO CHECK -CANCEL INPUTS

:==================================================================
:	INPUT:	S, RQ, CANCEL
:==================================================================
	LHL	R5,TS2702,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2702	HS	0
	HC	FSC050-F.CODE 	:RESET STATE, ACTION = 5
	HC	FSD080-F.CODE 	:SENT RQD -CANCEL STATE,ACTION = >(S)
	HC	FSC050-F.CODE 	:INC STATE, ACTION = 5
	HC	FSC050-F.CODE 	:INC RSP RCVD STATE, ACTION = 5
	HC	FSD080-F.CODE 	:SENT RQD CANCEL STATE, ACTION = >(S)

:	CHECK -CANCEL INPUTS
:-------------------------------------------
FS2706	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.ECI		:END CHAIN INDICATOR SET?
	JN	FS2708			:YES, CHECK EC INPUTS

:==================================================================
:	INPUT:	S, RQ, -CANCEL, -EC
:===================================================================
	LHL	R5,TS2703,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2703	HS	0
	HC	FSC030-F.CODE 	:RESET STATE, ACTION = 3
	HC	FSD080-F.CODE 	:SENT RQD -CANCEL STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:INC STATE, ACTION = -
	HC	FSC000-F.CODE 	:INC RSP RCVD STATE, ACTION = -
	HC	FSD080-F.CODE 	:SENT RQD CANCEL STATE, ACTION = >(S)

:	CHECK S, RQ, -CANCEL, EC INPUTS
:------------------------------------------------------
FS2708	LB	R2,BBUFER+MURHF2,R10,	:GET FIRST BYTE OF RH
	LR	R0,R2
	NHI	R2,MU.ERI		:EXCEPTION RESPONSE INDICATOR SET?
	JN	FS270A			:YES, -RQD
	NHI	R0,MU.DR1I+MU.DR2I	:DIRECT RESPONSE 1 OR 2 INDICATORS SET???
	JE	FS270A			:NO, -RQD 

:==============================================================================
:	INPUT:	S, RQ, -CANCEL, EC, RQD
:==================================================================================
	LHL	R5,TS2704,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2704	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 2
	HC	FSD080-F.CODE 	:SENT RQD -CANCEL STATE, ACTION=>(S)
	HC	FSC020-F.CODE 	:INC STATE, ACTION = 2
	HC	FSC010-F.CODE 	:INC RSP RCVD STATE, ACTION = 1
	HC	FSD080-F.CODE 	:SENT RQD CANCEL STATE, ACTION=>(S)

:=====================================================================
:	INPUT:	S, RQ, -CANCEL, EC, -RQD
:=====================================================================
FS270A	LHL	R5,TS2705,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2705	HS	0	
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSD080-F.CODE 	:SENT RQD -CANCEL STATE, ACTION=>(S)
	HC	FSC010-F.CODE 	:INC STATE, ACTION = 1
	HC	FSC010-F.CODE 	:INC RSP RCVD STATE, ACTION=1
	HC	FSD080-F.CODE 	:SENT RQD CANCEL STATE,ACTION=>(S)

:	CHECK RECEIVE INPUTS
:-------------------------------------------
FS270C
	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS.CRQ,,		:REQUEST, CRASH
	JAL	R4,FS05D0,,		:TO_CURRENT_CHAIN?
	J	FS.CUR,,		:NO, CRASH
	CLHI	R0,MU.DFC		:DFC RU?
	JNFS	FS270D			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,CANCEL		:CANCEL?

:====================================================================
:	INPUT:	R, RSP, -CANCEL, TO_CURRENT_CHAIN
:====================================================================
FS270D
	JN	FS260D,,		:NO, GO GET STATE ENTRY ROUTINE

:=========================================================================
:	INPUT:	R, RSP, CANCEL, TO_CURRENT_CHAIN
:=========================================================================
FS270E
	LHL	R5,TS2707,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2707	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSC010-F.CODE 	:SENT RQD -CANCEL STATE, ACTION = 1
	HC	FSC000-F.CODE 	:INC STATE, ACTION = -
	HC	FSC000-F.CODE 	:INC RSP RCVD STATE, ACTION = -
	HC	FSC010-F.CODE 	:SENT RQD CANCEL STATE, ACTION = 1



	SUBTTL	FSM_QEC_RCV
:*********************************************************************
:	FSM_QEC_RCV
:*********************************************************************
:	FS2800	-(FSM_QEC_RCV) THE FUNCTION OF THIS FSM IS TO ENFORCE
:	THE QUIESCE PROTOCOL FOR THE HALF-SESSION THAT IS BEING QUIESCED
:	(RECEIVED QEC). SEE QUIESCE PROTOCOL ON PAGE 5-20 IN FAPL FOR
:	PROSE DESCRIPTION.
:	PAGE 5-87 IN FAPL
:	-------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR
:			FSM STATE INFO. IN SCB), R2 (MU.DIRECTION), 
:			R4 (RQ OR RSP), R9 (SCB ENTRY), R10 (MU PTR)
:			R6 (FUNCTION OR CALL), R7 (SM STATE VALUE)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS2800
	FS.MC1(FSCQRV,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS2802			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:=======================================================================	:
:	INPUT:	RESET
:=======================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER INPUTS
:-------------------------------
FS2802
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LR	R2,R2			:SEND OR RCV?
	JE	FS2806			:SEND
	LR	R4,R4			:RQ OR RSP?
	JE	FS2804			:RQ
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,QC			:ACTION_CODE = QC?
	JN	FS.COD,,		:NO, CRASH
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH

:====================================================================
:	INPUT:	R, +RSP, QC
:====================================================================
	J	FSC000,,		:ALL STATE ACTION = -

:	CHECK FOR R, RQ INPUT
:-------------------------------
FS2804
	LB	R2,BBUFER+MUBIUF,R10,	:GET TH
	NHI	R2,MU.EFI		:NORMAL OR EXPEDITED?
	JE	FS.CFL,,		:NORM, CRASH
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,RELQ			:ACTION_CODE=RELQ?

:======================================================================
:	INPUT:	R, RQ, EXP, RELQ
:======================================================================
	JE	FSC000,,		:YES, ACTION = -

:	CHECK FOR R, RQ, EXP, QEC INPUT
:---------------------------------------
	CLHI	R5,QEC			:ACTION_CODE=QEC
	JN	FS.COD,,		:NO, CRASH

:=======================================================================
:	INPUT:	R, RQ, EXP, QEC
:=======================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0V0,,		:NO, ACTION = >(R)

:	CHECK FOR SEND INPUT
:-----------------------------------
FS2806
	LR	R4,R4			:RQ OR RSP?
	JE	FS280E			:RQ
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:-RSP, CRASH
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,QEC			:ACTION_CODE=QEC?
	JNFS	FS280A			:-QEC

:====================================================================
:	INPUT:	S, +RSP, QEC
:====================================================================
FS2808
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR S,+RSP, RELQ INPUT
:------------------------------------------
FS280A
	CLHI	R5,RELQ			:ACTION_CODE=RELQ?
	JN	FS.COD,,		:NO, CRASH

:===================================================================
:	INPUT:	S, +RSP, RELQ
:===================================================================
FS280C
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ INPUT
:-------------------------------
FS280E
	LB	R2,BBUFER+MUBIUF,R10,	:GET TH
	NHI	R2,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JN	FS.CFL,,		:EXP, CRASH
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS280H			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,QC			:ACTION_CODE = QC?
	JN	FS280G			:-QC

:==================================================================
:	INPUT:	S, RQ, NORM, QC
:==================================================================
	CLHI	R7,FS.ST2		:PEND QC STATE?
	JE	FSC030,,		:YES, ACTION = 3
	J	FSD0W0,,		:NO, ACTION = >(S1)

:	CHECK FOR OTHER S, RQ, NORM INPUT
:------------------------------------------
FS280G
	CLHI	R5,CANCEL		:ACTION_CODE = CANCEL?

:======================================================================
:	INPUT:	S, RQ, NORM, CANCEL
:======================================================================
	JE	FS280I			:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, NORM,-CANCEL INPUT
:---------------------------------------------
FS280H
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.BCI		:BEGIN CHAIN INDICATOR SET?
	JEFS	FS280I			:NO, -BC

:=========================================================================
:	INPUT:	S, RQ, NORM, -CANCEL, BC
:=========================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0Z0,,		:NO, ACTION = >(S2)

:=======================================================================
:	INPUT:	S, RQ, NORM, -CANCEL, -BC
:=======================================================================
FS280I
	CLHI	R7,FS.ST3		:QUIESCED STATE?
	JE	FSD0Z0,,		:YES, ACTION = >(S2)
	J	FSC000,,		:NO, ACTION = -

	SUBTTL	FSM_QEC_SEND
:************************************************************************
:	FSM_QEC_SEND
:************************************************************************
:	FS2900	-(FSM_QEC_SEND) THE FUNCTION OF THIS FSM IS TO ENFORCE
:	THE QUIESCE PROTOCOL FOR THE HALF-SESSION THAT SENT QEC. SEE
:	"QUIECSE PROTOCOL" ON PAG 5-20 FOR PROSE DESCRIPTION.
:	PAGE 5-87 IN FAPL
:	--------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR 
:			FSM STATE INFO. IN SCB), R2 (MU.DIRECTION),
:			R4 (RQ OR RSP), R7 (FSM STATE VALUE),
:			R9 (SCB ENTRY), R10 (MU PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS2900
	FS.MC1(FSCQSD,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL = PRESENT?
	JEFS	FS2902			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:====================================================================
:	INPUT:	RESET
:====================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:-----------------------------------------
FS2902
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LR	R2,R2			:SEND OR RCV?
	JN	FS2906			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS2904			:RQ
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,QC			:ACTION_CODE = QC?
	JN	FS.COD,,		:NO, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH

:===================================================================
:	INPUT:	S, +RSP, QC
:====================================================================
	J	FSC000,,		:ACTION = -

:	CHECK FOR S, RQ INPUT
:-------------------------------------
FS2904
	LB	R2,BBUFER+MUBIUF,R10,	:GET TH
	NHI	R2,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JE	FS.CFL,,		:NORMAL, CRASH
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,RELQ			:ACTION_CODE = RELQ?

:=====================================================================
:	INPUT:	S, RQ, EXP, RELQ
:=====================================================================
	JE	FSC000,,		:YES, ACTION = -

:	CHECK FOR S, RQ, EXP, QEC INPUT
:---------------------------------------
	CLHI	R5,QEC			:NO, ACTION_CODE = QEC?
	JN	FS.COD,,		:NO, CRASH

:====================================================================
:	INPUT:	S, RQ, EXP, QEC
:====================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0W0,,		:NO, ACTION = >(S)

:	CHECK FOR RCV INPUT
:-----------------------------------------
FS2906
	LR	R4,R4			:RQ OR RSP?
	JE	FS2908			:RQ
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R2,MU.RTI		:POSITIVE OR NEG RSP?
	JN	FS.CNG,,		:-RSP, CRASH
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,QEC			:ACTION_CODE = QEC?

:======================================================================
:	INPUT:	R, +RSP, QEC
:======================================================================
	JE	FS2808,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, +RSP, RELQ INPUT
:-------------------------------------
	CLHI	R5,RELQ			:NO, ACTION_CODE = RELQ?
	JN	FS.COD,,		:NO, CRASH

:=====================================================================
:	INPUT:	R, +RSP, RELQ
:=====================================================================
	J	FS0201,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK R, RQ INPUT
:-------------------------
FS2908
	LB	R2,BBUFER+MUBIUF,R10,	:GET TH
	NHI	R2,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JN	FS.CFL,,		:EXPEDITED, CRASH
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS290A			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,QC			:ACTION_CODE = QC?
	JN	FS290A			:NO, -QC

:=======================================================================
:	INPUT:	R, RQ, NORM, QC
:=======================================================================
	LHL	R5,TS2901,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2901	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSC030-F.CODE 	:PEND QC STATE, ACTION = 3
	HC	FSD0V0-F.CODE 	:QUIESCED STATE, ACTION = >(R1)

:=======================================================================
:	INPUT:	R, RQ, NORM, CANCEL	OR
:		R, RQ, NORM,-CANCEL, BC	OR
:		R, RQ, NORM,-CANCEL,-BC	
:=======================================================================
FS290A
	CLHI	R7,FS.ST3		:QUIESCED STATE?
	JE	FSD100,,		:YES, ACTION = >(R2)
	J	FSC000,,		:NO, ACTION = -


	SUBTTL	FSM_QRI_CHECK_SEND
:***********************************************************************
:	FSM_QRI_CHECK_SEND
:***********************************************************************
:	FS3000	-(FSM_QRI_CHECK_SEND) THE FUNCTION OF THIS FSM IS TO
:	ENFORCE THE PROTOCOL FOR SENDING REQUESTS USING THE QRI INDICATOR.
:	WHEN RUNNING DELAYED RESPONSE MODE AND THIS FSM IS IN QR_SENT STATE
:	REQUESTS OTHER THAN CHASE MAY BE SENT WITH -QR. THIS IS 
:	BECAUSE RESPONSES MAY COME BACK IN ANY ORDER WHEN USING DELAYED 
:	RESPONSE MODE.
:	PAGE 5-88 IN FAPL
:	---------------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R6 (FUNCTION
:			OR CALL), R7 (FSM STATE VALUE)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DETROYED
FS3000
	FS.MC1(FSCQCS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS3004			:NO, GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:RESET SIGNAL?
	JE	FS3002			:YES, GO PROCESS INPUT
	CLHI	R0,FS.NOR		:NO_OUTSTANDING_RQS'?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID INPUTS

:====================================================================
:	INPUT:	'RESET' OR 'NO_OUTSTANDING_RQS'
:====================================================================
FS3002
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK INPUTS OTHER THAN SIGNAL INPUTS
:-------------------------------------------------
FS3004
	LR	R2,R2			:RECEIVE OR SEND?
	JN	FS.CRV,,		:RECEIVE, CRASH
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RESPONSE, CRASH
	LB	R2,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RU
	LR	R0,R2
	NHI	R2,MU.DR1I+MU.DR2I+MU.ERI	:RQN?
	JE	FS.CRM,,		:YES, CRASH
	NHI	R0,MU.QRI		:QUEUED RESPONSE INDICATOR SET?
	JE	FS3006			:NO, GO CHECK -QR INPUTS

:=============================================================
:	INPUT:	S, RQ, -RQN, QR
:=============================================================
FS3005
	LHL	R5,TS3003,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3003	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 2
	HC	FSC000-F.CODE 	:QR SENT STATE, ACTION = -

:	CHECK -QR INPUTS
:-------------------------
FS3006
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS3008			:NO, -CHASE INPUT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R2,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R2,CHASE		:CHASE?
	JN	FS3008			:NO, -CHASE INPUT

:===========================================================
:	INPUT:	S, RQ, -RQN, -QR, CHASE
:===========================================================
	LHL	R5,TS3004,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3004	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSD090-F.CODE 	:QR SENT STATE, ACTION = >(S)

:==============================================================
:	INPUT:	S, RQ, -RQN, -QR, -CHASE
:=============================================================
FS3008
	LHL	R5,TS3005,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3005	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSD0M0-F.CODE 	:QR SENT STATE, ACTION = >(S), -


:*********************************************************************
:	FS3100	-(FSM_QRI_CHAIN_RCV) THIS FSM ENFORCES THE QRI INDICATOR
:	IN THE RH. THIS INDICATOR IS SET THE SAME FOR ALL RU'S IN A
:	CHAIN, I.E. ALL RU'S IN A CHAIN HAVE QRI=QR OR ALL RU'S IN A CHAIN
:	HAVE QRI=-QR.
:	PAGE 5-88 IN FAPL
:---------------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R6 (FUNCTION OR
:			CALL), R7 (FSM STATE VALUE)
:		LINK:	R3
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS3100
	FS.MC1(FSCQNR,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS3102			:NO, GO CHECK FOR OTHER INPUT
	CLHI	R0,FS.RET		:RESET SIGNAL?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID

:=============================================================
:	INPUT:	'RESET'
:==============================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUT OTHER THAN SIGNAL INPUT
:-----------------------------------------------------
FS3102	
	LR	R2,R2			:RECEIVE OR SEND?
	JE	FS.CSD,,		:SEND, CRASH
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH 
	LB	R2,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	NHI	R2,MU.QRI		:QUEUED RESPONSE INDICATOR SET?
:	JN	FS3106			:NO, CHECK -QR INPUT (7/10/85 MIA)
	JE	FS3106			:NO, CHECK -QR INPUT (7/10/85 MIA)
	NHI	R0,MU.ECI		:END CHAIN INDICATOR SET?
	JE	FS3104			:NO, GO CHECK -EC INPUT

:==============================================================
:	INPUT:	R, RQ, QR, EC
:==============================================================
	LHL	R5,TS3102,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3102	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSC010-F.CODE 	:INC QR STATE, ACTION = 1
	HC	FSD040-F.CODE 	:INC -QRI STATE, ACTION = >(R)

:===================================================================
:	INPUT:	R, RQ, QR, -EC
:===================================================================
FS3104
	LHL	R5,TS3103,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3103	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 2	
	HC	FSC000-F.CODE 	:INC QR STATE, ACTION = -
	HC	FSD040-F.CODE 	:INC -QRI STATE, ACTION = >(R)

:	CHECK FOR -QR INPUT
:--------------------------
FS3106
	NHI	R0,MU.ECI		:END CHAIN INDICATOR SET?
	JE	FS3108			:NO, -EC INPUT

:=============================================================
:	INPUT:	R, RQ, -QR, EC
:==============================================================
	LHL	R5,TS3104,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3104	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSD040-F.CODE 	:INC QR STATE, ACTION = >(R)
	HC	FSC010-F.CODE 	:INC -QRI STATE, ACTION = 1

:=============================================================
:	INPUT:	R, RQ, -QR, -EC
:=============================================================
FS3108
	LHL	R5,TS3105,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3105	HS	0
	HC	FSC030-F.CODE 	:RESET STATE, ACTION = 3
	HC	FSD040-F.CODE 	:INC QR STATE, ACTION = >(R)
	HC	FSC000-F.CODE 	:INC -QRI STATE, ACTION = -



	SUBTTL	FSM_QRI_CHAIN_SEND
:******************************************************************
:	FS3200	-(FSM_QRI_CHAIN_SEND) THIS FSM ENFORCES THE QRI
:	INDICATOR IN THE RH. THIS INDICATOR MUST BE SET THE SAME
:	FOR ALL RU'S IN A CHAIN, I.E., ALL RU'S IN A CHAIN HAVE
:	QRI=QR OR ALL RU'S IN A CHAIN HAVE QRI=-QR.
:	PAGE 5-89 IN FAPL
:	-----------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR
:			FSM STATE INFO. IN SCB), R2 (MU.DIRECTION),
:			R4 (RQ OR RSP), R9 (SCB ENTRY), R10 (MU_PTR)
:			R6 (FUNCTION OR CALL), R7 (FSM STATE VALUE)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS3200
	FS.MC1(FSCQNS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS3202			:NO, GO CHECK FOR OTHER INPUT
	CLHI	R0,FS.RET		:RESET SIGNAL?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID

:====================================================================
:	INPUT:	'RESET'
:====================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUT OTHER THAN SIGNAL INPUT
:------------------------------------------------
FS3202	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS.CRV,,		:RECEIVE, CRASH
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RESPONSE, CRASH
	LB	R2,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.QRI		:QUEUED RESPONSE INDICATOR SET?
	JE	FS3206			:NO, -QR INPUT CHECK
	NHI	R0,MU.ECI		:END CHAIN INDICATOR SET?
	JE	FS3204			:NO, -EC INPUT

:===================================================================
:	INPUT:	S, RQ, QR, EC
:===================================================================
	LHL	R5,TS3202,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3202	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSC010-F.CODE 	:INC QR STATE, ACTION = 1
	HC	FSD090-F.CODE 	:INC -QRI STATE, ACTION = >(S)

:=================================================================
:	INPUT:	S, RQ, QR, -EC
:=================================================================
FS3204
	LHL	R5,TS3203,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3203	HS	0
	HC	FSC020-F.CODE 	:RESET STATE, ACTION = 2
	HC	FSC000-F.CODE 	:INC QR STATE, ACTION = -
	HC	FSD090-F.CODE 	:INC -QRI STATE, ACTION = >(S)

:	CHECK -QR INPUT
:---------------------------
FS3206
	NHI	R0,MU.ECI		:END CHAIN INDICATOR SET?
	JE	FS3208			:NO, -EC INPUT

:============================================================
:	INPUT:	S, RQ, -QR, EC
:=============================================================
	LHL	R5,TS3204,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3204	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSD090-F.CODE 	:INC QR STATE, ACTION = >(S)
	HC	FSC010-F.CODE 	:INC -QRI STATE, ACTION = 1

:=============================================================
:	INPUT:	S, RQ, -QR, -EC
:=============================================================
FS3208
	LHL	R5,TS3205,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3205	HS	0
	HC	FSC030-F.CODE 	:RESET STATE, ACTION = 3
	HC	FSD090-F.CODE 	:INC QR STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:INC -QRI STATE, ACTION = -

	SUBTTL	FSM_RES
:*************************************************************
:	FS3300	-(FSM_RES) THIS FSM ENFORCES THAT NORMAL-FLOW
:	REQUESTS NOT BE SENT WHEN RESOURCES ARE UNAVAILABLE.
:	PAGE 5-89 IN FAPL
:	------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX
:			FOR FSM STATE INFO. IN SCB), R2 (MU_DIRECTION),
:			R4 (RQ OR RSP), R9 ( SCB ENTRY), R10 (MU_PTR)
:			R6 (FUNCTION OR CALL), R7 (FSM STATE VALUE)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS3300
	FS.MC1(FSCRES,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS3306			:NO, GO CHECK OTHER INPUT
	CLHI	R0,FS.UAV		:'UNAV' SIGNAL?

:===================================================================
:	INPUT:	'UNAVL'
:===================================================================
	JE	FS3005,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR 'AVL'
:--------------------------
FS3302
	CLHI	R0,FS.AVL		:'AVL' SIGNAL?

:==================================================================
:	INPUT:	'AVL'
:==================================================================
	JEFS	FS3304			:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR RESET
:-----------------------------
	CLHI	R0,FS.RET		:'RESET' SIGNAL?
	JN	FS.CSG,,		:NO, ALL OTHER SIGNALS ARE INVALID

:================================================================
:	INPUT:	'RESET'
:================================================================
FS3304
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK INPUTS OTHER THAN SIGNAL INPUTS
:-------------------------------------------------
FS3306
	LR	R2,R2			:SEND OR RECEIVE?
	JE	FS.CSD,,		:SEND, CRASH
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RESPONSE, CRASH
	LB	R0,BBUFER+MUBIUF,R10,	:GET TH
	NHI	R0,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JN	FS.CFL,,		:EXPEDITED

:================================================================
:	INPUT:	R, RQ, NORM
:================================================================
	LHL	R5,TS3304,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS3304	HS	0	
	HC	FSC000-F.CODE 	:AVL STATE, ACTION = -
	HC	FSD0S0-F.CODE 	:UNAVL STATE, ACTION = -(C)

	SUBTTL	FSM_RTR_BIDDER
:*************************************************************************
:	FS3600	-(FSM_RTR_BIDDER) TO ENFORCE RTR PORTION OF THE BRACKET
:	PROTOCOL FOR THE BIDDER. SEE "BRACKETS PROTOCOL" ON PAGE 5-14
:	FOR PROSE DESCRIPTION.
:	PAGE 5-90 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL , OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU_PTR), R7 (FSM STATE 
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS3600
	FS.MC1(FSCRTB,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS3602			:NO, GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:'RESET' SIGNAL?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID INPUTS

:==========================================================================
:	INPUT:	'RESET'
:==========================================================================
	J	FS360A			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUT OTHER THAN SIGNAL INPUT
:------------------------------------------------
FS3602
	LR	R2,R2			:SEND OR RECEIVE INPUT?
	JN	FS3604			:RECEIVE
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RESPONSE, CRASH
	LB	R2,BBUFER+MURHF3,R10,	:GET THIRD BYTE OF RH
	NHI	R2,MU.BBI		:BEGIN BRACKET INDICATOR SET?
	JE	FS.CBB,,		:NO, -BB INVALID INPUT

:===========================================================================
:	INPUT:	S, RQ, BB
:===========================================================================
	LHL	R5,TS3602,R7,R7  	:GET STATE ENTRY ROUTINE	
	J	F.CODE,R5,,     
TS3602	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSD0A0-F.CODE 	:PEND STATE, ACTION = >(S)

:	CHECK RECEIVE INPUT
:---------------------------------
FS3604
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.CTG		:MASK FOR JUST RU_CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU 
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS3606			:RESPONSE, GO CHECK RSP INPUT
	CLHI	R2,MU.DFC		:RU CATEGORY = DFC?
	JN	FS.CAT,,		:NO, CRASH
	CLHI	R5,RTR			:RTR?
	JN	FS.COD,,		:NO, CRASH

:==================================================================
:	INPUT:	R, RQ, RTR
:==================================================================
	J	FS360A			:GO GET STATE ENTRY ROUTINE

:	CHECK RECEIVE RESPONSE INPUTS
:-------------------------------------
FS3606	LB	R0,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE?
	JN	FS3608			:NEGATIVE
	CLHI	R2,MU.DFC		:RU DATA FLOW CONTROL?
	JN	FS.CAT,,		:NO, CRASH
	CLHI	R5,BID			:BID?	
	JN	FS.COD,,		:NO, CRASH

:======================================================================
:	INPUT:	R, +RSP, BID
:======================================================================
	J	FS360A			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR -RSP INPUT
:-------------------------------------
FS3608
	CLHI	R2,MU.DFC		:DFS RU?
	JN	FS360C			:NO
	CLHI	R5,BID			:BID?
	JN	FS360C			:NO, GO CHECK CT(BB) INPUT
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE CODE
	CLHI	R0,.RRBJF		:0814?

:==============================================================
:	INPUT:	R, -RSP, BID, 0814
:==============================================================
	JE	FS360E			:YES, GO GET STATE ENTRY ROUTINE

:=============================================================
:	INPUT:	R, -RSP, BID, -0814
:=============================================================
FS360A
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, -RSP, CT(BB), 0814 INPUT
:----------------------------------------------
FS360C
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR (6/22/84/CHS)
:	CLH	R5,SCBBLK+SCTPTR,R9,	:PTR EMPTY? (6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JE	FS.CPT,,		:YES, INVALID INPUT
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO CORRELATION TAB (9/7/84 MIA)
	LB	R2,BBUFER+CLARG5,R5,	:GET CT(BB)
	NHI	R2,MU.BBI		:BEGIN BRACKET INDICATOR SET?
	JE	FS.CBB,,		:NO, -CT(BB)
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE CODE	
	CLHI	R0,.RRBJF		:0814?
	JN	FS.CSC,,		:NO, CRASH


:====================================================================
:	INPUT:	R, -RSP, CT(BB), 0814
:====================================================================
FS360E
	J	FS3005,,		:GO GET STATE ENTRY ROUTINE


	SUBTTL	FSM_RTR_FSP
:******************************************************************
:	FS3700	-(FSM_RTR_FSP) THIS FSM ENFORCES RTR PORTION OF THE
:	BRACKET PROTOCOL FOR THE FIRST SPEAKER.
:	PAGE 5-90 IN FAPL
:	----------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR
:			FSM STATE INFO. IN SCB), R2 (MU.DIRECTION),
:			R4 (RQ OR RSP), R9 (SCB ENTRY), R10 (MU_PTR)
:			R6 (FUNCTION OR CALL), R7 (FSM STATE VALSUE)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R6, R7 ARE DESTROYED
FS3700
	FS.MC1(FSCRTF,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS3702			:NO, GO CHECK FOR OTHER INPUT
	CLHI	R0,FS.RET		:'RESET' SIGNAL?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID

:===============================================================
:	INPUT:	'RESET'
:===============================================================
	J	FS3708			:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUT OTHER THAN SIGNAL
:------------------------------------------
FS3702
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST RU BYTE FOR FUTURE CHECKS
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS.CRV,,		:RECEIVE, CRASH
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS3704			:RESPONSE
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,RTR			:RTR?
	JN	FS.COD,,		:NO, CRASH

:==============================================================
:	INPUT:	S, RQ, RTR
:===============================================================
	J	FS3708			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR RESPONSE INPUT
:--------------------------------------------
FS3704
	LB	R2,BBUFER+MURHF2,R10,	:GET SECOND BYTE OF RH
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS3706			:NEGATIVE
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,BID			:BID?
	JN	FS.COD,,		:NO, CRASH

:================================================================
:	INPUT:	S, +RSP, BID
:================================================================
	J	FS3708			:GO GET STATE ENTRY ROUTINE

:	CHECK -RSP INPUT
:-------------------------------------------
FS3706
	LHL	R2,BBUFER+MURHSN,R10,	:GET SENSE CODE
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS370A			:NO
	CLHI	R5,BID			:BID?
	JN	FS370A			:NO, CRASH
	CLHI	R2,.RRBJF		:0814?

:=============================================================
:	INPUT:	S, -RSP, BID, 0814
:=============================================================
	JE	FS370C			:YES, GO GET STATE ENTRY ROUTINE

:============================================================
:	INPUT:	S, -RSP, BID, -0814
:============================================================
FS3708
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, -RSP, CT(BB), 0814 INPUT
:--------------------------------------------------------
FS370A
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR (6/22/84/CHS)
:	CLH	R5,SCBBLK+SCTPTR,R9,	:GET PTR EQ RELEASE PTR?(6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JE	FS.CPT,,		:RETURN IF EMPTY PTR
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO CORRELATION TAB (9/7/84 MIA)
	LB	R5,BBUFER+CLARG5,R5,	:GET CT(BB)
	NHI	R5,MU.BBI		:BEGIN BRACKET INDICATOR SET?
	JE	FS.CCT,,		:NO, -CT(BB)
	CLHI	R2,.RRBJF		:0814?
	JN	FS.CSC,,		:NO, -0814

:=================================================================
:	INPUT:	S, -RSP, CT(BB), 0814
:=================================================================
FS370C
	J	FS3005,,		:GO GET STATE ENTRY ROUTINE


	SUBTTL	FSM_SBI_RCV
:**********************************************************************
:	FS3800	- (FSM_SBI_RCV) THE FUNCTION OF THIS FSM IS TO ENFORCE
:		THE STOP-BRACKET-INITIATION PROTOCOL FOR THE SBI RECEIVER.
:		PAGE 5-91 IN FAPL
:	----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR
:			RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY),
:			R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7, ARE DESTROYED
FS3800
	FS.MC1(FSCSIR,FS.SCB)		:CHECK INPUTS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS3802			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:========================================================================
:	INPUT:	RESET
:========================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER INPUTS
:------------------------------
FS3802
	LB	R0,BBUFER+MUBIUF,R10,	:GET TH
	LR	R2,R2			:SEND OR RCV?
	JE	FS380A			:SEND
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	LR	R4,R4			:RQ OR RSP?
	JN	FS3806			:RSP
	NHI	R0,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JE	FS.CFL,,		:NORMAL, CRASH
	CLHI	R5,SBI			:ACTION_CODE = SBI?
	JN	FS.COD,,		:NO, -SBI SO CRASH

:=====================================================================
:	INPUT:	R, RQ, EXP, SBI
:=====================================================================
FS3804
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0V0,,		:NO, ACTION = >(R)

:	CHECK FOR R, RSP INPUT
:------------------------------
FS3806
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS.CNG,,		:NEGATIVE, CRASH
	CLHI	R5,BIS			:ACTION_CODE = BIS?
	JN	FS.COD,,		:NO, CRASH

:=======================================================================
:	INPUT:	R, +RSP, BIS
:=======================================================================
FS3808
	CLHI	R7,FS.ST3		:NOBB STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC030,,		:NO, ACTION = 3

:	CHECK FOR SEND INPUT
:-----------------------------
FS380A
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	LR	R4,R4			:RQ OR RSP?
	JE	FS380E			:RQ
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,SBI			:ACTION_CODE = SBI?
	JN	FS.COD,,		:NO, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH

:=======================================================================
:	INPUT:	S, +RSP, SBI
:=======================================================================
FS380C
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR SEND, RQ INPUT
:---------------------------------
FS380E
	NHI	R0,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JN	FS.CFL,,		:EXPEDITED, CRASH
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS380H			:NO
	CLHI	R5,BIS			:ACTION_CODE = BIS?
	JNFS	FS380G			:NO

:========================================================================
:	INPUT:	S, RQ, NORM, BIS
:========================================================================
	CLHI	R7,FS.ST3		:YES, NOBB STATE?
	JE	FSD0W0,,		:YES, ACTION = >(S1)
	J	FSC000,,		:NO, ACTION = -
	
:	CHECK FOR BB OR BID INPUT
:-------------------------------------
FS380G
	CLHI	R5,BID			:ACTION_CODE = BID?
	JEFS	FS380I			:YES
FS380H
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R5,MU.BBI		:BEGIN BRACKET INDICATOR SET?
	JE	FS.CBB,,		:NO, CRASH

:=======================================================================
:	INPUT:	S, RQ, NORM, BID
:=======================================================================
:	INPUT:	S, RQ, NORM, BID
:=======================================================================
FS380I
	CLHI	R7,FS.ST3		:NOBB STATE?
	JE	FSD0X0,,		:YES, ACTION = >(S2)
	J	FSC000,,		:NO, ACTION = -

	SUBTTL	FSM_SBI_SEND
:*********************************************************************
:	FS3900	- (FSM_SBI_SEND) THE FUNCTION OF THIS FSM IS TO ENFORCE
:		THE STOP-BRACKET-INITIATION PROTOCOL FOR THE SBI SENDER.
:		PAGE 5-91 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR 
:			RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY), 
:			R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS3900
	FS.MC1(FSCSIS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS3902			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:======================================================================
:	INPUT:	RESET
:======================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER INPUT
:---------------------------------
FS3902
	LB	R0,BBUFER+MUBIUF,R10,	:GET TH
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE
	LR	R2,R2			:SEND OR RCV?
	JN	FS3908			:RCV
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.CTG		:MASK FOR RU CATEGORY BITS
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	LR	R4,R4			:RQ OR RSP?
	JN	FS3906			:RSP
	NHI	R0,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JE	FS.CFL,,		:NORMAL, CRASH
	CLHI	R5,SBI			:ACTION_CODE = SBI?
	JN	FS.COD,,		:NO, CRASH

:======================================================================
:	INPUT:	S, RQ, EXP, SBI
:======================================================================
FS3904
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0W0,,		:NO, ACTION = >(S)

:	CHECK S, RSP INPUT
:------------------------------
FS3906
	CLHI	R5,BIS			:ACTION_CODE = BIS?
	JN	FS.COD,,		:NO, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH

:=====================================================================
:	INPUT:	S, +RSP, BIS
:=====================================================================
	J	FS3808,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR RCV INPUT
:--------------------------------
FS3908
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	LR	R4,R4			:RQ OR RSP?
	JE	FS390A			:RQ
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,SBI			:ACTION_CODE = SBI?
	JN	FS.COD,,		:NO, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH

:======================================================================
:	INPUT:	R, +RSP, SBI
:======================================================================
	J	FS380C,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, RQ, INPUT
:------------------------------
FS390A
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS390D			:NO, -BIS OR BID
	NHI	R0,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JN	FS.CFL,,		:EXP, CRASH
	CLHI	R5,BIS			:ACTION_CODE = BIS?
	JNFS	FS390C			:NO

:======================================================================
:	INPUT:	R, RQ, NORM, BIS
:======================================================================
	CLHI	R7,FS.ST3		:NOBB STATE?
	JE	FSD0V0,,		:YES, ACTION = >(R1)
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR R, RQ, NORM, BID|BB INPUT
:--------------------------------------------
FS390C
	CLHI	R5,BID			:ACTION_CODE = BID?
	JEFS	FS390E			:YES
FS390D
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R5,MU.BBI		:BEGIN BRACKET INDICATOR SET?
	JE	FS.CBB,,		:NO, CRASH
:======================================================================
:	INPUT: R, RQ, NORM, BB
:======================================================================
:	INPUT: R, RQ, NORM, BID
:======================================================================
FS390E
	CLHI	R7,FS.ST3		:NOBB STATE?
	JE	FSD0Y0,,		:YES, ACTION = >(R2)
	J	FSC000,,		:NO, ACTION = -
	JR	R3

	SUBTTL	FSM_SHUTD_RCV
:***********************************************************************
:	FS5200	- (FSM_SHUTD_RCV) THE FUNCTION OF THIS FSM IS TO ENFORCE
:		THE SHUTDOWN PROTOCOL FOR THE HALF SESSION THAT IS BEING
:		SHUT DOWN.
:		PAGE 5-92 IN FAPL
:	----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR
:			RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY),
:			R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		LINK:	R3
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS5200
	FS.MC1(FSCSHR,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS5202			:NO
	CLHI	R0,FS.RET		:YES, SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:========================================================================
:	INPUT:	RESET
:========================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER INPUT
:--------------------------------
FS5202
	LB	R0,BBUFER+MUBIUF,R10,	:GET TH
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE FROM RU
	LR	R2,R2			:SEND OR RCV?
	JE	FS520A			:SEND
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	LR	R4,R4			:RQ OR RSP?
	JE	FS5206			:RQ
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH
	CLHI	R5,SHUTC		:ACTION_CODE = SHUTC?
	JN	FS.COD,,		:NO, CRASH

:==================================================================
:	INPUT:	R, +RSP, SHUTC
:==================================================================
FS5204
	CLHI	R7,FS.ST2		:PEND SHUTC STATE?
	JE	FSC030,,		:YES, ACTION = 3
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR R, RQ INPUT
:-------------------------------
FS5206
	NHI	R0,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JE	FS.CFL,,		:NORMAL, CRASH
	CLHI	R5,SHUTD		:ACTION_CODE = SHUTD?

:======================================================================
:	INPUT:	R, RQ, EXP, SHUTD
:======================================================================
	JE	FS3804,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, RQ, EXP, RELQ
:----------------------------------
	CLHI	R5,RELQ			:NO, ACTION_CODE = RELQ?
	JN	FS.COD,,		:NO, CRASH

:========================================================================
:	INPUT:	R, RQ, EXP, RELQ
:========================================================================
FS5208
	J	FSC000,,		:YES, ACTION = -

:	CHECK FOR SEND INPUT
:---------------------------------
FS520A
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	LR	R4,R4			:RQ OR RSP?
	JE	FS520E			:RQ
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH
	CLHI	R5,SHUTD		:ACTION_CODE = SHUTD?
	JN	FS520C			:NO, CRASH

:======================================================================
:	INPUT:	S, +RSP, SHUTD
:======================================================================
	J	FS380C,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, +RSP, RELQ INPUT
:----------------------------------------
FS520C
	CLHI	R5,RELQ			:ACTION_CODE = RELQ?
	JN	FS.COD,,		:NO, CRASH

:======================================================================
:	INPUT:	S, +RSP, RELQ
:======================================================================
	J	FS0201,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ INPUT
:------------------------------
FS520E
	NHI	R0,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JNFS	FS520G			:EXPEDITED

:=======================================================================
:	INPUT:	S, RQ, NORM
:=======================================================================
	CLHI	R7,FS.ST3		:QUIESCED STATE?
	JE	FSD0Z0,,		:YES, ACTION = >(S2)
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR S, RQ, EXP INPUT
:--------------------------------------
FS520G
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO
	CLHI	R5,SHUTC		:ACTION_CODE = SHUTC?
	JN	FS.COD,,		:NO, CRASH

:=====================================================================
:	INPUT:	S, RQ, EXP, SHUTC
:=====================================================================
	CLHI	R7,FS.ST2		:PEND SHUTC STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0W0,,		:NO, ACTION = >(S1)

	SUBTTL	FSM_SHUTD_SEND
:*********************************************************************
:	FS5300	-(FSM_SHUTD_SEND) THE FUNCTION OF THIS FSM IS TO ENFORCE
:		THE SHUTDOWN PROTOCOL FOR THE HALF-SESSION THAT SENDS 
:		SHUTD.
:		PAGE 5-92 IN FAPL
:	---------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR RSP),
:			R7 (FSM STATE VALUE), R9 (SCB ENTRY), R10(MU_PTR)
:			R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS5300
	FS.MC1(FSCSHS,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS5302			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:====================================================================
:	INPUT:	RESET
:====================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER INPUT
:-----------------------------
FS5302
	LB	R0,BBUFER+MUBIUF,R10,	:GET TH
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE FROM RU
	LR	R2,R2			:SEND OR RCV?
	JE	FS5304			:SEND
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH
	CLHI	R5,SHUTC		:ACTION_CODE = SHUTC?
	JN	FS.COD,,		:NO, CRASH

:=====================================================================
:	INPUT:	S, +RSP, SHUTC
:=====================================================================
	J	FS5204,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ INPUT
:----------------------------------------
FS5304
	NHI	R0,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	JE	FS.CFL,,		:NORMAL, CRASH
	CLHI	R5,SHUTD		:ACTION_CODE = SHUTD?
	
:=====================================================================
:	INPUT:	S, RQ, EXP, SHUTD
:=====================================================================
	JE	FS3904,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, EXP, RELQ INPUT
:---------------------------------------------------
	CLHI	R5,RELQ			:NO, ACTION_CODE = RELQ?
	JN	FS.COD,,		:NO, CRASH

:=======================================================================
:	INPUT:	S, RQ, EXP, RELQ
:=======================================================================
	J	FSC000,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR RCV INPUT
:---------------------------
FS5306
	LR	R4,R4			:RQ OR RSP?
	JE	FS5308			:RQ
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH
	CLHI	R5,SHUTD		:ACTION_CODE = SHUTD?

:======================================================================
:	INPUT:	R, +RSP, SHUTD
:======================================================================
	JE	FS380C,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, +RSP, RELQ INPUT
:----------------------------------------------
	CLHI	R5,RELQ			:NO, ACTION_CODE = RELQ?
	JN	FS.COD,,		:NO, CRASH

:====================================================================
:	INPUT:	R, +RSP, RELQ
:====================================================================
	J	FS0201,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, RQ INPUT
:----------------------------
FS5308
	NHI	R0,MU.EFI		:NORMAL OR EXPEDITED FLOW?
	
:====================================================================
:	INPUT:	R, RQ, NORM
:====================================================================
	JE	FSC000,,		:NORM, GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, RQ, EXP INPUT
:------------------------------------------
	CLHI	R5,SHUTC		:ACTION_CODE = SHUTC?
	JN	FS.COD,,		:NO, CRASH

:=========================================================================
:	INPUT:	R, RQ, EXP, SHUTC
:=========================================================================
	CLHI	R7,FS.ST2		:PEND SHUTC STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0V0,,		:NO, ACTION = >(R)

	FO	CBKDEF
	FO	CMDLST
	
	EM				:END OF SSDF00 MODULE
    :	************************************************************
:	REVISION HISTORY
:	03/28/84 (DRUE BONDAD)	- ORIGINAL DESIGN AND CODING
:	************************************************************

	SUBTTL	BRACKET FSMs USING SCB - DFC LAYER ('SSBF00')

	RA	0
	
	MO	.,SNAPKG
	LO	CMDLST
	LO	CBKDEF

	SEG	A.CODE


	SUBTTL	FSM_BSM_BIDDER
:*****************************************************************
:	FSM_BSM_BIDDER
:*****************************************************************
:	FS0000	-(FSM_BSM_BIDDER) THIS FSM ENFORCES THE BRACKET 
:	PROTOCOL FOR THE BIDDER. SEE "BRACKETS PROTOCOL" ON PAGE
:	5-14 FOR THE PROSE DESCRIPTION. THERE ARE 6 STATES IN THIS
:	FSM AND THEY ARE AS FOLLOWS:
:	1. BETB (BETWEEN BRACKETS): THIS STATE INDICATES NO BRACKETS
:	ARE BEING PROCESSED.
:	2. INB (IN BRACKET): THIS STATE INDICATES A BRACKET IS CUR-
:	RENTLY BEING PROCESSED.A REQUEST WITH BBI SET HAS PREVIOUSLY
:	BEEN SENT OR RECEIVED TO BEGIN THE BRACKET.
:	3. PEND_BB (PENDING SENDING BEGIN BRACKET) THIS STATE IS
:	ENTERED WHEN A POSITIVE RESPONSE TO BID IS RECEIVED OR A
:	POSITIVE RESPONSE TO RTR IS SENT. THE BIDDER HAS BEEN GRANTED
:	THE RIGHT TO START A BRACKET (BY SENDING BB).
:	4. PEND_INB (PENDING ENTERING IN BACKET STATE): THIS STATE IS
:	ENTERED WHEN THE BIDDER SENDS A BB REQUEST WHILE IN BETB.THE
:	BIDDER IS REQUESTING PERMISION TO BEGIN A BRACKET. 
:	5. & 6. PEND_TERM_S AND PEND_TERM_R (PENDING TERMINATION OF
:	THE BRACKET): THESE STATES ARE ENTERED FROM THE IN-BRACKET
:	STATE (INB) WHEN A REQUEST CARRYING EB (END BRACKET) IS SENT OR
:	RECEIVED.
:	PAGE 5-68 IN FAPL
:	------------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM SIGNAL INPUT, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP)), R9 (SCB ENTRY), R10 (MU PTR), R6 (FUNCTION
:			OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK),
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS0000
	FS.MC1(FSCBBI,FS.SCB)
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS0007			:NO
	CLHI	R0,FS.REB		:SIGNAL = 'RESET_BETB'?
	JNFS	FS0004			:NO
	
:=================================================================
:	INPUT:	'RESET_BETB'
:=================================================================
FS0002
	CLHI	R7,FS.ST1		:BETB STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC010,,		:NO, ACTION = 1

:	CHECK FOR OTHER SIGNALS
:--------------------------------
FS0004
	CLHI	R0,FS.REI		:SIGNAL = 'RESET_INB'?
	JN	FS.CSG,,		:NO, CRASH

:==================================================================
:	INPUT:	'RESET_INB'
:==================================================================
FS0006
	CLHI	R7,FS.ST2		:INB STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC020,,		:NO, ACTION = 2

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:------------------------------------------
FS0007
	LHI	R0,FS.ERR		:ASSUME CT_PTR EMPTY
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT TABLE GET PTR (6/22/84/CHS)
:	CLH	R5,SCBBLK+SCTPTR,R9,	:GET PTR = RELEASE PTR? (6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JEFS	FS0001			:YES, EMPTY (FS.CTS = ERROR)
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO CORRELATION TAB (9/7/84 MIA)
	LB	R0,BBUFER+CLARG5,R5,	:GET CT_BBI, CT_EBI AND CT_CDI VALUES
	NHI	R0,MU.BBI+MU.EBI+MU.CDI	:MASK FOR THESE 3 INDICATORS ONLY
FS0001
	STB	R0,FS.CTS,,		:SAVE FOR LATER USE
	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
:RQD = TRUE IF -ERI (DR1I|DR2I)
	LR	R0,R5
	NHI	R0,MU.ERI		:ERI?
	JNFS	FS0008			:NO, FS.RQD = NON ZERO
	LIS	R0,0
	NHI	R5,MU.DR1I+MU.DR2I	:DR1|DR2?
	JNFS	FS0009			:YES, FS.RQD = ZERO
FS0008
	LIS	R0,1			:NO, FS.RQD = NON ZERO
FS0009
	STB	R0,FS.RQD,,		:SAVE FOR LATER USE
	LB	R5,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R5,MU.CTG		:FIND RU_CATEGORY
	LIS	R0,0			:R0 = 0 FOR FMD CATEGORY 
	CLHI	R5,MU.FMD		:FMD CATEGORY?
	JEFS	FS000A			:YES, LEAVE R0=0
	LIS	R0,1			:R0=1 FOR DFC
	CLHI	R5,MU.DFC		:DFC CATEGORY?
	JN	FS.CAT,,		:NO, CRASH
FS000A
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE
	LR	R2,R2			:SEND OR RCV?
	JN	FS0020			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS000I			:RQ
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	LR	R0,R0			:FMD RU?
	JE	FS000C			:YES, DON'T CHECK ACTION_CODE
	CLHI	R5,RTR			:ACTION_CODE = RTR?
	JN	FS000C			:NO, -RTR
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:-RSP, CRASH

:====================================================================
:	INPUT:	S, +RSP, RTR
:====================================================================
FS000B
	CLHI	R7,FS.ST1		:BETB STATE?
	JE	FSC030,,		:YES, ACTION = 3
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR S, RSP, -RTR INPUT
:------------------------------------
FS000C
	LB	R5,FS.CTS,,		:GET CT_BBI AND CT_EBI VALUES
	CLHI	R5,FS.ERR		:CT_PTR EMPTY?
	JE	FS.CPT,,		:YES, INVALID INPUT
	NHI	R5,MU.EBI+MU.BBI	:MASK FOR CT_EBI AND CT_BBI
	CLHI	R5,MU.EBI		:CT(-BB&EB)?
	JN	FS.CCT,,		:NO, CRASH
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JNFS	FS000G			:-RSP

:===================================================================
:	INPUT:	S, +RSP, -RTR, CT(-BB,EB)
:===================================================================
FS000E
	CLHI	R7,FS.ST5		:PEND TERM_R STATE?
	JE	FSD1J0,,		:YES, ACTION = 1(B)
	J	FSC000,,		:NO, ACTION = -

:==================================================================
:	INPUT:	S, -RSP, -RTR, CT(-BB,EB)
:==================================================================
FS000G
	CLHI	R7,FS.ST5		:PEND TERM_R STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR S, RQ, INPUT
:-----------------------------------
FS000I
	LR	R0,R0			:FMD?
	JEFS	FS000M			:YES
	CLHI	R5,BID			:ACTION_CODE = BID?
	JNFS	FS000M			:NO, -BID

:=================================================================
:	INPUT:	S, RQ, BID
:=================================================================
FS000K
	CLHI	R7,FS.ST1		:BETB STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0A0,,		:NO, ACTION = >(S)
	
:	CHECK FOR S, RQ, BB INPUT
:---------------------------------
FS000M
	LB	R4,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R4,MU.BBI+MU.EBI	:MASK FOR BBI AND EBI BITS
	CLHI	R4,MU.BBI+MU.EBI	:BB AND EB?
	JN	FS000O			:NO
	LR	R0,R0			:FMD?
	JEFS	FS000N			:YES
	CLHI	R5,LUSTAT		:ACTION_CODE = LUSTAT?
	JN	FS.COD,,		:NO, CRASH

:===================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, BB, EB
:===================================================================
FS000N
	LHL	R5,TS0001,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0001	HS	0
	HC	FSC000-F.CODE 	:BETB STATE, ACTION = -
	HC	FSD0A0-F.CODE 	:INB STATE, ACTION = >(S)
	HC	FSC010-F.CODE 	:PEND BB STATE, ACTION = 1
	HC	FSD0A0-F.CODE 	:PEND INB STATE, ACTION = >(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE, ACTION=>(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_S STATE,ACTION = >(S)

:	CHECK FOR S, RQ, BB, -EB
:---------------------------------
FS000O
	CLHI	R4,MU.BBI		:BB AND -EB?
	JN	FS0010			:NO
	LR	R0,R0			:FMD?
	JEFS	FS000Q			:YES
	CLHI	R5,LUSTAT		:ACTION_CODE=LUSTAT?
	JN	FS.COD,,		:NO, CRASH
FS000Q
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JNFS	FS000S			:YES, EC

:==================================================================
:	INPUT:	S, RQ, BB, -EB, FMD|LUSTAT, -EC
:==================================================================
	LHL	R5,TS0002,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0002	HS	0
	HC	FSC040-F.CODE 	:BETB STATE, ACTION = 4
	HC	FSD0A0-F.CODE 	:INB STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:PEND BB STATE,ACTION = -
	HC	FSD0A0-F.CODE 	:PEND INB STATE, ACTION = >(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION = >(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_S STATE,ACTION = >(S)

:	CHECK FOR S, RQ, BB, -EB, FMD|LUSTAT, EC INPUT
:------------------------------------------------------------
FS000S
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	LB	R5,FS.RQD,,		:RQD?
	JN	FS000W			:NO, -RQD
	NHI	R2,MU.CDI		:YES, CD?
	JEFS	FS000U			:NO, -CD

:=================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, BB, -EB, RQD, CD
:=================================================================
	LHL	R5,TS0003,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0003	HS	0
	HC	FSC040-F.CODE 	:BETB STATE, ACTION = 4
	HC	FSD0A0-F.CODE 	:INB STATE, ACTION = >(S)
	HC	FSD1M0-F.CODE 	:PEND BB STATE, ACTION = 2(IR)
	HC	FSD0A0-F.CODE 	:PEND INB STATE, ACTION=>(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION=>(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_S STATE,ACTION=>(S)

:=======================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, BB, -EB, RQD, -CD
:=======================================================================
FS000U
	LHL	R5,TS0004,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0004	HS	0
	HC	FSC040-F.CODE 	:BETB STATE, ACTION = 4
	HC	FSD0A0-F.CODE 	:INB STATE, ACTION = >(S)
	HC	FSD1N0-F.CODE 	:PEND BB STATE,ACTION=2(IS)
	HC	FSD0A0-F.CODE 	:PEND INB STATE, ACTION=>(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION=>(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_S STATE,ACTION=>(S)

:	CHECK FOR S, RQ, BB, -EB, FMD|LUSTAT, EC, RQD INPUT
:-----------------------------------------------------------------
FS000W
	NHI	R2,MU.CDI		:CD?
	JEFS	FS000Y			:NO, -CD

:===================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, BB, -EB, EC, -RQD, CD
:===================================================================
	CLHI	R7,FS.ST3		:PEND BB STATE?
	JE	FSD1M0,,		:YES, ACTION = 2(IR)
	J	FSD0A0,,		:NO, ACTION = >(S)

:===================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, BB, -EB, EC, -RQD, -CD
:===================================================================
FS000Y
	CLHI	R7,FS.ST3		:PEND BB STATE?
	JE	FSD1N0,,		:YES, ACTION = 2(IS)
	J	FSD0A0,,		:NO, ACTION = >(S)

:	CHECK FOR S, RQ, -BB, EB INPUT
:-----------------------------------------------
FS0010
	CLHI	R4,MU.EBI		:-BB AND EB?
	JN	FS001G			:NO, MUST BE -BB AND -EB
	LR	R0,R0			:FMD?
	JE	FS0016			:YES
	CLHI	R5,CANCEL		:ACTION_CODE=CANCEL?
	JN	FS0014			:NO, -CANCEL

:=====================================================================
:	INPUT:	S, RQ, CANCEL, EB
:=====================================================================
FS0012
	LHL	R5,TS0005,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0005	HS	0
	HC	FSD0A0-F.CODE 	:BETB STATE, ACTION = >(S)
	HC	FSD1J0-F.CODE 	:INB STATE, ACTION = 1(B)
	HC	FSD0A0-F.CODE 	:PEND BB STATE,ACTION=>(S)
	HC	FSD0A0-F.CODE 	:PEND INB STATE,ACTION=>(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION = >(S)
	HC	FSD1J0-F.CODE 	:PEND TERM_S STATE,ACTION=1(B)

:	CHECK FOR S, RQ, -BB, EB, EBDFC INPUT
:------------------------------------------------------
FS0014
	CLHI	R5,CHASE		:ACTION_CODE=CHASE?
	JE	FS001A			:YES
	CLHI	R5,QC			:ACTION_CODE=QC?
	JE	FS001A			:YES
	CLHI	R5,LUSTAT		:ACTION_CODE=LUSTAT?
	JN	FS.COD,,		:NO, -EBDFC SO CRASH

:	CHECK FOR S, RQ, FMD, -BB, EB, -EC
:-----------------------------------------------
FS0016
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JNFS	FS001A			:YES, EC

:=================================================================
:	INPUT:	S, RQ, FMD, -BB, EB, -EC
:=================================================================
FS0018
	CLHI	R7,FS.ST2		:INB STATE?
	JE	FSD1P0,,		:YES, MULT. ACTION CODE=6,1
	J	FSD0A0,,		:NO, ACTION = >(S)

:	CHECK FOR S, RQ, FMD|LUSTAT, -BB, EB, EC INPUT
:-----------------------------------------------------------
FS001A
	LB	R5,FS.RQD,,		:RQD?
	JNFS	FS001E			:-RQD

:===================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, -BB, EB, RQD, EC
:====================================================================
FS001C
	CLHI	R7,FS.ST2		:INB STATE?
	JE	FSD1Q0,,		:YES, MULT. ACTION CODE = 6, 1(B)
	J	FSD0A0,,		:NO, ACTION = >(S)

:=====================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, -BB, EB, -RQD, EC
:=====================================================================
FS001E
	CLHI	R7,FS.ST2		:INB STATE?
	JE	FSD1J0,,		:YES, ACTION = 1(B)
	J	FSD0A0,,		:NO, ACTION = >(S)

:	CHECK FOR S, RQ, -BB, -EB
:---------------------------------------
FS001G
	LR	R0,R0			:FMD?
	JN	FS001Q			:NO, DFC
	LB	R2,BBUFER+MURHF1,R10,	:YES, GET 1ST BYTE OF RH
	NHI	R2,MU.BCI		:BC?
	JEFS	FS001I			:NO, -BC

:=====================================================================
:	INPUT:	S, RQ, FMD, -BB, -EB, BC
:=====================================================================
	CLHI	R7,FS.ST2		:INB STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0A0,,		:NO, ACTION = >(S)

:	CHECK FOR S, RQ, -BB, -EB, FMD, -BC INPUT
:-------------------------------------------------
FS001I
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R2,MU.CDI		:CD?
	JN	FS001M			:YES, CD
	LB	R4,FS.RQD,,		:RQD?
	JN	FS001K			:-RQD

:====================================================================
:	INPUT:	S, RQ, FMD, -BB, -EB, -BC, RQD, -CD
:====================================================================
	LHL	R5,TS0006,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0006	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1N0-F.CODE 	:PEND BB STATE, ACTION = 2(IS)
	HC	FSC000-F.CODE 	:PEND INB STATE, ACTION= -
	HC	FSD0A0-F.CODE 	:PEND TERM_R	STATE,ACTION=>(S)
	HC	FSC000-F.CODE 	:PEND TERM_S STATE, ACTION=-

:	CHECK FOR S, RQ, FMD, -BB, -EB, -BC, -RQD, -CD INPUT
:----------------------------------------------------------
FS001K
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JE	FS.CEC,,		:NO, -EC SO CRASH

:======================================================================
:	INPUT:	S, RQ, FMD, -BB, -EB, -BC, -RQD, EC, -CD
:======================================================================
	LHL	R5,TS0007,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0007	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1N0-F.CODE 	:PEND BB STATE, ACTION = 2(IS)
:	HC	FSD0A0-SEG|a.CODE| :PN INB ST, ACT >(S) (03/27/86 MIA)
	HC	FSD0A0-F.CODE	:PND INB ST, ACT = >(S) (03/27/86 MIA)
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE, ACTION=>(S)
	HC	FSD1J0-F.CODE 	:PEND TERM_S STATE, ACTION = 1(B)

:	CHECK FOR S, RQ, FMD,-BB, -EB, -BC, CD INPUT
:----------------------------------------------------
FS001M
	LB	R4,FS.RQD,,		:RQD?
	JN	FS001O			:NO, -RQD

:=====================================================================
:	INPUT:	S, RQ, FMD, -BB, -EB, -BC, EC, RQD, CD
:=====================================================================
	LHL	R5,TS0008,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0008	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1M0-F.CODE 	:PEND BB STATE, ACTION = 2(IR)
	HC	FSC000-F.CODE 	:PEND INB STATE, ACTION = -
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION=>(S)
	HC	FSC000-F.CODE 	:PEND TERM_S STATE,ACTION = -

:======================================================================
:	INPUT:	S, RQ, FMD, -BB, -EB, -BC, EC, -RQD, CD
:======================================================================
FS001O
	LHL	R5,TS0009,R7,R7		:GET STATE ENTRY ROUTINE	
	J	F.CODE,R5,,     
TS0009	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1M0-F.CODE 	:PEND BB STATE, ACTION = 2(IR)
	HC	FSD0A0-F.CODE 	:PEND INB STATE, ACTION =>(S)
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION = >(S)
	HC	FSD1J0-F.CODE 	:PEND TERM_S STATE,ACTION=1(B)

:	CHECK FOR S, RQ, DFC, -BB, -EB INPUT
:------------------------------------------------
FS001Q
	CLHI	R5,CANCEL		:ACTION_CODE = CANCEL?
	JEFS	FS001U			:YES

:===================================================================
:	INPUT:	S, RQ, OTHERDFC, -BB, -EB
:===================================================================
FS001S
	CLHI	R7,FS.ST4		:LESS THAN PEND INB STATE?
	JL	FSC000,,		:YES, ACTION = -
	J	FSD0A0,,		:NO, ACTION = >(S)

:	CHECK FOR S, RQ, CANCEL,-BB, -EB INPUT
:-------------------------------------------------
FS001U
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R2,MU.CDI		:CD?
	JE	FS001W			:NO, -CD

:=====================================================================
:	INPUT:	S, RQ, CANCEL, -BB, -EB, CD
:=====================================================================
	LHL	R5,TS000A,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000A	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1M0-F.CODE 	:PEND BB STATE, ACTION = 2(IR)
	HC	FSC010-F.CODE 	:PEND INB STATE, ACTION = 1
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE, ACTION = >(S)
	HC	FSC020-F.CODE 	:PEND TERM_S STATE,ACTION = 2

:=====================================================================
:	INPUT:	S, RQ, CANCEL, -BB, -EB, -CD
:=====================================================================
FS001W
	LHL	R5,TS000B,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000B	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE,ACTION = -
	HC	FSD1N0-F.CODE 	:PEND BB STATE, ACTION = 2(IS)
	HC	FSC010-F.CODE 	:PEND INB STATE, ACTION = 1
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION=>(S)
	HC	FSC020-F.CODE 	:PEND TERM_S STATE,ACTION=2

:	CHECK FOR RECEIVE INPUT
:--------------------------------
FS0020
	LR	R4,R4			:RQ OR RSP?
	JE	FS002M			:RQ
	LB	R4,FS.CTS,,		:GET CORRELATION TABLE INDICATORS
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	LR	R0,R0			:FMD?
	JEFS	FS0022			:YES
	CLHI	R5,LUSTAT		:ACTION_CODE=LUSTAT?
	JN	FS002C			:NO, -LUSTAT
FS0022
	CLHI	R4,FS.ERR		:GET_PTR EMPTY/
	JE	FS.CPT,,		:YES, INVALID INPUT
	NHI	R4,MU.BBI+MU.EBI	:GET CT_BBI AND CT_EBI
	CLHI	R4,MU.BBI		:CT(BB,-EB)?
	JN	FS002G			:NO, GO CHECK FOR -BID INPUT
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JEFS	FS0026			:POSITIVE, +RSP

:====================================================================
:	INPUT:	R, -RSP, FMD|LUSTAT, CT(BB,-EB)
:====================================================================
FS0024
	CLHI	R7,FS.ST4		:PEND INB STATE?
	JE	FSC010,,		:YES, ACTION = 1
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR R, +RSP, CT(BB,-EB) INPUT
:-------------------------------------------------
FS0026
	LB	R2,FS.CTS,,		:GET CORRELATION TABLE INDICATORS
	NHI	R2,MU.CDI		:MASK FOR JUST CT_CDI
	JNFS	FS002A			:YES, CD

:==========================================================================
:	INPUT:	R, +RSP, FMD|LUSTAT, CT(BB,-EB,-CD)
:==========================================================================
FS0028
	CLHI	R7,FS.ST4		:PEND INB STATE?
	JE	FSD1N0,,		:YES, ACTION = 2(IS)
	J	FSC000,,		:NO, ACTION = -

:==========================================================================
:	INPUT:	R, +RSP, FMD|LUSTAT, CT(BB,-EB,CD)
:==========================================================================
FS002A
	CLHI	R7,FS.ST4		:PEND INB STATE?
	JE	FSD1M0,,		:YES, ACTION = 2(IR)
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR R, RSP, -LUSTAT INPUT
:-------------------------------------------
FS002C
	CLHI	R5,BID			:ACTION_CODE = BID?
	JNFS	FS002G			:NO
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS.CNG,,		:NEGATIVE, CRASH
:=================================================================
:	INPUT:	R, +RSP, BID
:=================================================================
FS002E
	CLHI	R7,FS.ST1		:BETB STATE?
	JE	FSC030,,		:YES, ACTION = 3
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR R, RSP, -BID
:------------------------------
	
FS002G
	LB	R4,FS.CTS,,		:GET CT_BBI AND CT_EBI BITS
	CLHI	R4,FS.ERR		:GET_PTR = EMPTY?
	JE	FS.CPT,,		:YES, INVALID INPUT
	NHI	R4,MU.BBI+MU.EBI	:GET JUST CT_BBI AND CT_EBI
	CLHI	R4,MU.EBI		:CT(-BB,EB)?
	JN	FS.CEB,,		:NO, CRASH
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JNFS	FS002K			:NEGATIVE, -RSP

:=======================================================================
:	INPUT:	R, +RSP, -BID, CT(-BB,EB)
:=======================================================================
FS002I
	CLHI	R7,FS.ST6		:PEND TERM_R STATE?
	JE	FSD1J0,,		:YES, ACTION = 1(B)
	J	FSC000,,		:NO, ACTION = -

:=====================================================================
:	INPUT:	R, -RSP, -BID, CT(-BB,EB)
:=====================================================================
FS002K
	CLHI	R7,FS.ST6		:PEND TERM_S STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR R, RQ INPUT
:------------------------------------
FS002M
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R2,MU.BBI+MU.EBI	:GET BBI AND EBI BITS
	CLHI	R2,MU.BBI+MU.EBI	:BB AND EB?
	JN	FS002Q			:NO
	LR	R0,R0			:FMD?
	JEFS	FS002O			:YES
	CLHI	R5,LUSTAT		:NO, ACTION_CODE = LUSTAT?
	JN	FS.COD,,		:NO, CRASH

:===============================================================
:	INPUT:	R, RQ, FMD|LUSTAT, BB, EB
:===============================================================
FS002O
	CLHI	R7,FS.ST5		:PEND TERM_R STATE?
	JE	FSD1O0,,		:YES, ACTION = >(R)
	JL	FSC000,,		:LOWER STATES, ACTION = -
	J	FSD1K0,,		:PEND TERM_S STATE,ACTION =-(C)

:	CHECK FOR R, RQ, BB, -EB INPUT
:-----------------------------------------
FS002Q
	CLHI	R2,MU.BBI		:BB AND-EB?
	JN	FS002W			:NO
	LR	R0,R0			:FMD?
	JEFS	FS002S			:YES
	CLHI	R5,LUSTAT		:NO, ACTION_CODE = LUSTAT?
	JN	FS.COD,,		:NO, CRASH
FS002S
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R2,MU.CDI		:CD?
	JE	FS002U			:NO, -CD

:==================================================================
:	INPUT:	R, RQ, FMD|LUSTAT, BB, -EB, CD
:==================================================================
	LHL	R5,TS000C,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000C	HS	0
	HC	FSD1N0-F.CODE 	:BETB STATE, ACTION = 2(IS)
	HC	FSD1O0-F.CODE 	:INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND BB STATE, ACTION=>(R)
	HC	FSD1N0-F.CODE 	:PEND INB STATE, ACTION=2(IS)
	HC	FSD1O0-F.CODE 	:PEND TERM_R  STATE,ACTION=>(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_S STATE, ACTION =>(R)

:==================================================================
:	INPUT:	R, RQ, FMD|LUSTAT, BB, -EB, EC, -CD
:	INPUT:	R, RQ, FMD|LUSTAT, BB, -EB, -EC,
:==================================================================
FS002U
	LHL	R5,TS000D,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000D	HS	0
	HC	FSD1M0-F.CODE 	:BETB STATE,ACTION = 2(IR)
	HC	FSD1O0-F.CODE 	:INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND BB STATE, ACTION = >(R)
	HC	FSD1M0-F.CODE 	:PEND INB STATE,ACTION =2(IR)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE,ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_S STATE,ACTION = >(R)

:	CHECK FOR R, RQ, -BB, EB INPUT
:-------------------------------------
FS002W
	CLHI	R2,MU.EBI		:EB?
	JN	FS0034			:MUST BE -BB AND -EB
	LR	R0,R0			:FMD?
	JN	FS002Y			:NO
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JN	FS0030			:YES, EC

:=========================================================================
:	INPUT:	R, RQ, FMD, -BB, EB, -EC
:=========================================================================
	LHL	R5,TS000E,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000E	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE,ACTION = -(C)
	HC	FSD1R0-F.CODE 	:INB STATE,ACTION = 5,1
	HC	FSD1O0-F.CODE 	:PEND BB STATE,ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND INB STATE, ACTION = -(C)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE,ACTION=>(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE,ACTION=-(C)

:	CHECK FOR R, RQ, -BB, EB, DFC INPUT
:---------------------------------------------
FS002Y
	CLHI	R5,CHASE		:ACTION_CODE=CHASE?
	JE	FS0030			:YES
	CLHI	R5,QC			:ACTION_CODE=QC?
	JE	FS0030			:YES
	CLHI	R5,LUSTAT		:ACTION_CODE = LUSTAT?
	JE	FS0030			:YES
	CLHI	R5,CANCEL		:ACTION_CODE = CANCEL?
	JN	FS.COD,,		:NO, CRASH

:================================================================
:	INPUT:	R, RQ, CANCEL, EB
:================================================================
	LHL	R5,TS000F,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000F	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE,ACTION = -(C)
	HC	FSD1J0-F.CODE 	:INB STATE,ACTION = 1(B)
	HC	FSD1O0-F.CODE 	:PEND BB STATE,ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND INB STATE,ACTION = -(C)
	HC	FSD1J0-F.CODE 	:PEND TERM_R STATE,ACTION = 1(B)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE,ACTION = -(C)

:	CHECK FOR R, RQ, -BB, EB, FMD|EBDFC INPUT
:----------------------------------------------------
FS0030
	LB	R5,FS.RQD,,		:RQD?
	JN	FS0032			:-RQD

:=====================================================================
:	INPUT:	R, RQ, FMD|EBDFC, -BB, EB, RQD
:======================================================================
	LHL	R5,TS000G,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000G	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE, ACTION = -(C)
	HC	FSD1S0-F.CODE 	:INB STATE, ACTION = 5, 1(B)
	HC	FSD1O0-F.CODE 	:PEND BB STATE, ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND INB STATE, ACTION = -(C)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE, ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE,ACTION = -(C)

:===========================================================================
:	INPUT:	R, RQ, FMD|EBDFC, -BB, EB, -RQD, EC
:===========================================================================
FS0032
	LHL	R5,TS000H,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000H	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE, ACTION = -(C)
	HC	FSD1J0-F.CODE 	:INB STATE, ACTION = 1(B)
	HC	FSD1O0-F.CODE 	:PEND BB STATE, ACTION=>(R)
	HC	FSD1K0-F.CODE 	:PEND INB STATE, ACTION=-(C)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE,ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE,ACTION = -(C)

:	CHECK FOR R, RQ, -BB, -EB INPUT
:-----------------------------------------
FS0034
	LR	R0,R0			:FMD?
	JN	FS003A			:NO, DFC
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.BCI		:BC?
	JE	FS0036			:NO, -BC

:====================================================================
:	INPUT:	R, RQ, FMD, -BB, -EB, BC
:====================================================================
	LHL	R5,TS000I,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000I	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE, ACTION = -(C)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1O0-F.CODE 	:PEND BB STATE, ACTION=>(R)
	HC	FSD1K0-F.CODE 	:PEND INB STATE,ACTION=-(C)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE,ACTION=>(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE,ACTION=-(C)

:	CHECK FOR R, RQ, -BB, -EB, -BC INPUT
:------------------------------------------------------------
FS0036
	LB	R4,FS.RQD,,		:RQD?
	JN	FS0038			:NO, -RQD

:==========================================================
:	INPUT:	R, RQ, FMD, -BC, RQD
:==========================================================
	LHL	R5,TS000J,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000J	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND BB STATE, ACTION = -
	HC	FSD1K0-F.CODE 	:PEND INB STATE,ACTION = -(C)
	HC	FSC000-F.CODE 	:PEND TERM_R STATE,ACTION= _
	HC	FSC000-F.CODE 	:PEND TERM_S STATE,ACTION = -

:	CHECK FOR R, RQ, -BB, -EB, -BC, -RQD INPUT
:----------------------------------------------------------------
FS0038
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JE	FS.CEC,,		:NO, -EC

:==================================================================
:	INPUT:	R, RQ, FMD, -BC, EC, -RQD
:===================================================================
	LHL	R5,TS000K,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000K	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND BB STATE,ACTION = -
	HC	FSD1K0-F.CODE 	:PEND INB STATE, ACTION = -(C)
	HC	FSD1J0-F.CODE 	:PEND TERM_R STATE,ACTION = 1(B)
	HC	FSC000-F.CODE 	:PEND TERM_S STATE,ACTION = -

:	CHECK FOR R, RQ, -BB, -EB, DFC INPUT
:---------------------------------------------
FS003A
	CLHI	R5,CANCEL		:ACTION_CODE=CANCEL?
	JN	FS003C			:NO, -CANCEL

:====================================================================
:	INPUT:	R, RQ, CANCEL, -EB
:====================================================================
	LHL	R5,TS000L,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000L	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE,ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND BB STATE, ACTION = -
	HC	FSD1K0-F.CODE 	:PEND INB STATE,ACTION = -(C)
	HC	FSC020-F.CODE 	:PEND TERM_R STATE,ACTION = 2
	HC	FSC000-F.CODE 	:PEND TERM_S STATE,ACTION = -


:	CHECK FOR R, RQ, -BB, -EB, -CANCEL INPUT
:---------------------------------------------------------
FS003C
	CLHI	R5,RTR			:ACTION_CODE=RTR?
	JN	FS003E			:NO

:==========================================================================
:	INPUT:	R, RQ, RTR
:==========================================================================
	LHL	R5,TS000M,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS000M	HS	0
	HC	FSC000-F.CODE 	:BETB STATE,ACTION=-
	HC	FSD1K0-F.CODE 	:INB STATE, ACTION = -(C)
	HC	FSD1K0-F.CODE 	:PEND BB STATE, ACTION = -(C)
	HC	FSD1K0-F.CODE 	:PEND INB STATE, ACTION = -(C)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE, ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE, ACTION = -(C)

:=========================================================================
:	INPUT:	R, RQ, OTHERDFC, -BB, -EB
:=========================================================================
FS003E
	CLHI	R7,FS.ST5		:PEND TERM_R STATE?
	JE	FSD1O0,,		:YES, ACTION = >(R)
	J	FSC000,,		:NO, ACTION = -
	


	SUBTTL	FSM_BSM_FSP
:*****************************************************************
:	FSM_BSM_FSP
:*****************************************************************
:	FS0100	-(FSM_BSM_FSP) THIS FSM ENFORCES THE BRACKETS 
:	PROTOCOL FOR THE FIRST SPEAKER. SEE "BRACKETS PROTOCOL" ON 
:	PAGE 5-14 IN FAPL FOR PROSE DESCRIPTION. THERE ARE 6 STATES
:	IN THIS FSM AND THEY ARE AS FOLLOWS:
:	1. BETB (BETWEEN BRACKETS): THIS STATE INDICATES NO BRACKET
:	IS BEING PROCESSED.
:	2. INB (IN BRACKET): THIS STATE INDICATES A BRACKET IS BEING
:	PROCESSED. A REQUEST WITH BBI SET HAS PREVIOUSLY BEEN SENT OR 
:	RECEIVED TO BEGIN THE BRACKET.
:	3. PEND_BB (PENDING SENDING BEGIN BRACKET): THIS STATE IS
:	ENTERED WHEN A POSITIVE RESPONSE TO BID IS SENT OR A POSITIVE
:	RESPONSE TO RTR IS RECEIVED.
:	4. PEND_INB (PENDING ENTERING IN-BRACKET STATE): THIS STATE
:	IS ENTERED WHEN THE FIRST SPEAKER RECEIVES A BB REQUEST WHILE
:	IN BETB.
:	5. & 6. PEND_TERM_S AND PEND_TERM_R (PENDING TERMINATION OF THE
:	BRACKET): THESE STATES ARE ENTERED FROM THE IN BRACKETS STATE (INB)
:	WHEN A REQUEST CARRYING EB (END BRACKET) IS SENT OR RECEIVED.
:	PAGE 5-70 IN FAPL
:	------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION, R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R6 (FUNCTION
:			OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK),
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
:
FS0100
	FS.MC1(FSCBFP,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS0101			:NO
	CLHI	R0,FS.REB		:YES, SIGNAL=RESET_BETB?
	
:================================================================
:	INPUT:	RESET_BETB
:================================================================
	JE	FS0002,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER SIGNAL
:-----------------------------------
	CLHI	R0,FS.REI		:SIGNAL = RESET_INB?

:======================================================================
:	INPUT:	RESET_INB
:======================================================================
	JE	FS0006,,		:YES, GO GET STATE ENTRY ROUTINE

:	BAD SIGNAL
:--------------------------
	J	FS.CSG,,		:NO, CRASH

:	CHECK FOR OTHER INPUTS
:------------------------------------------
FS0101
	LHI	R0,FS.ERR		:ASSUME CT_PTR EMPTY
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT TABLE POINTER (6/22/84/CHS)
:	CLH	R5,SCBBLK+SCTPTR,R9,	:GET_PTR = RELEASE_PTR? (6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JE	FS0107			:YES, PTR EMPTY (FS.CTS=ERROR)
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO TABLE (9/7/84 MIA)
	LB	R0,BBUFER+CLARG5,R5,	:GET CT_BBI AND CT_EBI AND CT_CDI
	NHI	R0,MU.EBI+MU.BBI+MU.CDI	:MASK FOR JUST 3 INDICATORS
FS0107
	STB	R0,FS.CTS,,		:STORE INTO CT SAVE ADDRESS
:RQD = TRUE IF-ERI (DR1I | DR2I)
	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	LR	R0,R5
	NHI	R0,MU.ERI		:EXCEPTION RESPONSE INDICATOR SET?
	JNFS	FS0102			:YES, -RQD
	LIS	R0,0			:ASSUME RQD = TRUE
	NHI	R5,MU.DR1I+MU.DR2I	:DR1I|DR2I?
	JNFS	FS0103			:YES, RQD
FS0102	LIS	R0,1			:NO, -RQD
FS0103	STB	R0,FS.RQD,,		:STORE RQD INDICATOR (0=TRUE,1=FALSE)
	LB	R5,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R5,MU.CTG		:MASK FOR RU CATEGORY BITS
	LIS	R0,0			:ASSUME FMD RU
	CLHI	R5,MU.FMD		:FMD RU?
	JEFS	FS0104			:YES, R0=0
	LIS	R0,1			:ASSUME DFC RU
	CLHI	R5,MU.DFC		:DFC RU?
	JN	FS.CAT,,		:NO, CRASH
FS0104
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE
	LR	R2,R2			:SEND OR RCV?
	JN	FS0116			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS010C			:RQ
	LB	R4,FS.CTS,,		:GET CORRELATION TABLE INDICATORS
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	LR	R0,R0			:FMD?
	JEFS	FS0106			:YES
	CLHI	R5,LUSTAT		:NO, ACTION_CODE=LUSTAT?
	JN	FS0108			:NO, -LUSTAT
FS0106
	CLHI	R4,FS.ERR		:POINTER EMPTY?
	JE	FS.CPT,,		:YES, INVALID INPUT
	NHI	R4,MU.BBI+MU.EBI	:GET JUST CT_BBI AND CT_EBI
	CLHI	R4,MU.BBI		:CT(BB,-EB)?
	JN	FS010A			:NO, GO CHECK FOR -BID INPUT
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?

:======================================================================
:	INPUT:	S, -RSP, FMD|LUSTAT,CT(BB,-EB)
:======================================================================
	JN	FS0024,,		:NEGATIVE, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, +RSP, FMD|LUSTAT, CT(BB,-EB) INPUT
:------------------------------------------------------
	LB	R2,FS.CTS,,		:GET CT_CDI
	NHI	R2,MU.CDI		:CHANGE DIRECTION INDICATOR SET?

:=================================================================
:	INPUT:	S, +RSP, FMD|LUSTAT, CT(BB,-EB,CD)
:=================================================================
	JN	FS0028,,		:YES, GO GET STATE ENTRY ROUTINE

:=================================================================
:	INPUT:	S, +RSP, FMD|LUSTAT, CT(BB,-EB,-CD)
:=================================================================
	J	FS002A,,		:NO, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RSP, -LUSTAT INPUT
:----------------------------------------------
FS0108
	CLHI	R5,BID			:ACTION_CODE = BID?
	JNFS	FS010A			:NO, -BID
	NHI	R2,MU.RTI		:YES, POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:NEGATIVE, CRASH

:==================================================================
:	INPUT:	S, +RSP, BID
:==================================================================
	J	FS000B,,		:POSITIVE, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RSP, -BID INPUT
:--------------------------------------
FS010A
	LB	R5,FS.CTS,,		:GET CT_BBI AND CT_EBI
	CLHI	R5,FS.ERR		:POINTER = EMPTY?
	JE	FS.CPT,,		:INVALID INPUT
	NHI	R5,MU.EBI+MU.BBI	:MASK FOR JUST CT_EBI AND CT_BBI
	CLHI	R5,MU.EBI		:CT(-BB,EB)?
	JN	FS.CEB,,		:NO, CRASH
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?

:==================================================================
:	INPUT:	S, +RSP, -BID, CT(-BB, EB)
:==================================================================
	JE	FS000E,,		:+RSP, GO GET STATE ENTRY ROUTINE

:========================================================================
:	INPUT:	S, -RSP, -BID, CT(-BB, EB)
:========================================================================
	J	FS000G,,		:-RSP, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, RTR INPUT
:----------------------------------
FS010C
	LR	R0,R0			:FMD?
	JEFS	FS010E			:YES
	CLHI	R5,RTR			:NO, ACTION_CODE=RTR?
	
:=====================================================================
:	INPUT:	S, RQ, RTR
:=====================================================================
	JE	FS000K,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER S, RQ INPUTS
:-------------------------------------
FS010E
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R2,MU.BBI+MU.EBI	:MASK FOR BBI AND EBI BITS
	CLHI	R2,MU.BBI+MU.EBI	:BB AND EB?
	JN	FS010I			:NO
	LR	R0,R0			:YES, FMD?
	JEFS	FS010G			:YES
	CLHI	R5,LUSTAT		:NO, ACTION_CODE=LUSTAT?
	JN	FS.COD,,		:NO, CRASH

:=====================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, BB, EB
:=====================================================================
FS010G
	J	FS000K,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, BB, -EB INPUT
:---------------------------------------------
FS010I
	CLHI	R2,MU.BBI		:BB AND -EB?
	JN	FS010Q			:NO
	LR	R0,R0			:YES, FMD?
	JEFS	FS010K			:YES
	CLHI	R5,LUSTAT		:NO, ACTION_CODE=LUSTAT?
	JN	FS.COD,,		:NO, CRASH
FS010K
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JEFS	FS010M			:NO, -EC
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R2,MU.CDI		:CD?
	JNFS	FS010O			:YES, CD

:================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, BB, -EB, -EC
:	INPUT:	S, RQ, FMD|LUSTAT, BB, -EB, EC, -CD
:================================================================
FS010M
	CLHI	R7,FS.ST1		:BETB STATE?
	JE	FSD1N0,,		:YES, ACTION = 2(IS)
	J	FSD0A0,,		:NO, ACTION = >(S)

:==================================================================
:	INPUT:	S, RQ, FMD|LUSTAT, BB, -EB, CD
:==================================================================
FS010O
	CLHI	R7,FS.ST1		:BETB STATE?
	JE	FSD1M0,,		:YES, ACTION = 2(IR)
	J	FSD0A0,,		:NO, ACTION = >(S)

:	CHECK FOR S, RQ, -BB, EB INPUT
:------------------------------------------
FS010Q
	CLHI	R2,MU.EBI		:-BB AND EB?
	JN	FS010Y			:NO
	LR	R0,R0			:YES, FMD?
	JN	FS010S			:NO, DFC
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JN	FS010U			:YES, EC

:=================================================================
:	INPUT:	S, RQ, FMD, -BB, EB, -EC
:==================================================================
	J	FS0018,,		:NO,GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, -BB, EB, DFC INPUT
:--------------------------------------------
FS010S
	CLHI	R5,CANCEL		:ACTION_CODE=CANCEL?

:================================================================
:	INPUT:	S, RQ, CANCEL, EB
:================================================================
	JE	FS0012,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, -BB, EB, DFC INPUT
:-----------------------------------------------
	CLHI	R5,LUSTAT		:ACTION_CODE=LUSTAT?
	JEFS	FS010U			:YES
	CLHI	R5,CHASE		:ACTION_CODE=CHASE?
	JEFS	FS010U			:YES
	CLHI	R5,QC			:ACTION_CODE=QC?
	JN	FS.COD,,		:NO, CRASH
FS010U
	LB	R5,FS.RQD,,		:RQD?
	JNFS	FS010W			:NO, -RQD

:==================================================================
:	INPUT:	S, RQ, FMD|EBDFC, -BB, EB, RQD
:===================================================================
	J	FS001C,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, -BB, EB, FMD|EBDFC, -RQD INPUT
:------------------------------------------------------
FS010W
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JE	FS.CEC,,		:NO, -EC SO CRASH

:=================================================================	
:	INPUT:	S, RQ, FMD|EBDFC, -BB, EB, EC, -RQD
:=================================================================
	J	FS001E,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, -BB, -EB INPUT
:-----------------------------------------------
FS010Y
	LR	R0,R0			:FMD?
	JN	FS0114			:NO, DFC
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.BCI		:BC?
	JEFS	FS0110			:NO, -BC

:=======================================================================
:	INPUT:	S, RQ, FMD, -BB, -EB, BC
:=======================================================================
	CLHI	R7,FS.ST2		:INB STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSD0A0,,		:NO, ACTION = >(S)

:	CHECK FOR S, RQ, -BB, -EB, FMD, -BC INPUT
:-------------------------------------------------------
FS0110
	LB	R5,FS.RQD,,		:RQD?
	JN	FS0112			:NO, -RQD

:=====================================================================
:	INPUT:	S, RQ, -BB, -EB, FMD, -BC, RQD
:=====================================================================
	LHL	R5,TS0100,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0100	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD0A0-F.CODE 	:PEND BB STATE,ACTION = >(S)
	HC	FSC000-F.CODE 	:PEND INB STATE, ACTION = -
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION = >(S)
	HC	FSC000-F.CODE 	:PEND TERM_S STATE,ACTION = -

:	CHECK FOR S, RQ, -BB, -EB, FMD, -BC, -RQD INPUT
:----------------------------------------------------------
FS0112
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JE	FS.CEC,,		:NO, -EC SO CRASH

:=================================================================
:	INPUT:	S, RQ, FMD, -BC, EC, -RQD
:=================================================================
	LHL	R5,TS0101,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0101	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE,ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE,ACTION = -
	HC	FSD0A0-F.CODE 	:PEND BB STATE,ACTION = >(S)
	HC	FSC000-F.CODE 	:PEND INB STATE,ACTION= -
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION = >(S)
	HC	FSD1J0-F.CODE 	:PEND TERM_S STATE,ACTION = 1(B)

:	CHECK FOR S, RQ, -BB, -EB, DFC INPUT
:-----------------------------------------------
FS0114
	CLHI	R5,CANCEL		:ACTION_CODE=CANCEL?

:==================================================================
:	INPUT:	S, RQ, OTHERDFC, -BB, -EB
:==================================================================
	JN	FS001S,,		:NO, GO GET STATE ENTRY ROUTINE

:==================================================================
:	INPUT:	S, RQ, CANCEL, -EB
:==================================================================
	LHL	R5,TS0102,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0102	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD0A0-F.CODE 	:PEND BB STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:PEND INB STATE, ACTION = -
	HC	FSD0A0-F.CODE 	:PEND TERM_R STATE,ACTION = >(S)
	HC	FSC020-F.CODE 	:PEND TERM_S STATE, ACTION=2

:	CHECK FOR RECEIVE INPUT
:-------------------------------------
FS0116
	LR	R4,R4			:RQ OR RSP?
	JE	FS011A			:RQ
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	LR	R0,R0			:FMD?
	JE	FS0118			:YES, GO CHECK FOR -RTR INPUT
	CLHI	R5,RTR			:ACTION_CODE=RTR?
	JNFS	FS0118			:NO
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:-RSP, CRASH

:================================================================
:	INPUT:	R, +RSP, RTR
:================================================================
	J	FS000B,,		:+RSP, GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, RSP, -RTR INPUT
:-------------------------------------------
FS0118
	LB	R4,FS.CTS,,		:GET CT_BB AND CT_EB
	CLHI	R4,FS.ERR		:POINTER = EMPTY?
	JE	FS.CPT,,		:YES, INVALID INPUT
	NHI	R4,MU.EBI+MU.BBI	:GET JUST CT_BBI AND CT_EBI
	CLHI	R4,MU.EBI		:CT(-BB,EB)?
	JN	FS.CCT,,		:NO, CRASH
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?

:==================================================================
:	INPUT:	R, -RSP, -RTR, CT(-BB, EB)
:==================================================================
	JN	FS002K,,		:-RSP, GO GET STATE ENTRY ROUTINE

:===================================================================
:	INPUT:	R, +RSP, -RTR, CT(-BB,EB)
:==================================================================
	J	FS002I,,		:+RSP, GO GET STATE ENTRY ROUTINE

:	CHECK FOR R, RQ INPUT
:--------------------------------------
FS011A
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R2,MU.BBI+MU.EBI	:GET JUST BB AND EB INDICATORS
	CLHI	R2,MU.BBI+MU.EBI	:BB AND EB?
	JN	FS011E			:NO
	LR	R0,R0			:YES, FMD?
	JEFS	FS011C			:YES
	CLHI	R5,LUSTAT		:NO, ACTION_CODE=LUSTAT?
	JN	FS.COD,,		:NO, CRASH

:==================================================================
:	INPUT:	R, RQ, FMD|LUSTAT, BB, EB
:==================================================================
FS011C
	LHL	R5,TS0103,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0103	HS	0
	HC	FSC000-F.CODE 	:BETB STATE, ACTION = -
	HC	FSD1L0-F.CODE 	:INB STATE, ACTION = -(C2)
	HC	FSC010-F.CODE 	:PEND BB STATE, ACTION = 1
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE, ACTION=>(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE, ACTION=-(C1)

:	CHECK FOR R, RQ, BB, -EB INPUT
:---------------------------------------------------------
FS011E
	CLHI	R2,MU.BBI		:BB AND -EB?
	JN	FS011O			:NO
	LR	R0,R0			:YES, FMD?
	JN	FS011G			:NO, DFC
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JN	FS011G			:YES, EC

:===============================================================
:	INPUT:	R, RQ, FMD, BB, -EB, -EC
:===============================================================
	LHL	R5,TS0104,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0104	HS	0
	HC	FSC040-F.CODE 	:BETB STATE, ACTION = 4
	HC	FSD1L0-F.CODE 	:INB STATE, ACTION = -(C2)
	HC	FSC000-F.CODE 	:PEND BB STATE, ACTION= -
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE,ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE,ACTION=-(C1)

:	CHECK FOR R, RQ, BB, -EB, FMD|LUSTAT INPUT
:-------------------------------------------------------
FS011G
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R2,MU.CDI		:CD?
	JE	FS011K			:NO, -CD
	LB	R4,FS.RQD,,		:RQD?
	JN	FS011I			:NO, -RQD

:=====================================================================
:	INPUT:	R, RQ, FMD|LUSTAT, BB, -EB, RQD, CD
:=====================================================================
	LHL	R5,TS0105,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0105	HS	0
	HC	FSC040-F.CODE 	:BETB STATE, ACTION = 4
	HC	FSD1L0-F.CODE 	:INB STATE, ACTION = -(C2)
	HC	FSD1N0-F.CODE 	:PEND BB STATE,ACTION = 2(IS)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE, ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE, ACTION = -(C1)

:====================================================================
:	INPUT:	R, RQ, BB, -EB, FMD|LUSTAT, -RQD, CD
:====================================================================
FS011I
	LHL	R5,TS0106,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0106	HS	0
	HC	FSD1O0-F.CODE 	:BETB STATE, ACTION = >(R)
	HC	FSD1L0-F.CODE 	:INB STATE, ACTION = -(C2)
	HC	FSD1N0-F.CODE 	:PEND BB STATE, ACTION = 2(IS)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE, ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE, ACTION = -(C1)

:	CHECK FOR R, RQ, BB, -EB, FMD|LUSTAT, -CD INPUT
:----------------------------------------------------------
FS011K
	LB	R4,FS.RQD,,		:RQD?
	JN	FS011M			:-RQD

:==================================================================
:	INPUT:	R, RQ, BB, -EB, FMD|LUSTAT, RQD, -CD
:==================================================================
	LHL	R5,TS0107,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0107	HS	0
	HC	FSC040-F.CODE 	:BETB STATE, ACTION = 4
	HC	FSD1L0-F.CODE 	:INB STATE, ACTION = -(C2)
	HC	FSD1M0-F.CODE 	:PEND BB STATE, ACTION = 2(IR)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE, ACTION=>(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE, ACTION = -(C1)

:=================================================================
:	INPUT:	R, RQ, FMD|LUSTAT, BB, -EB, EC, -RQD, -CD
:=================================================================
FS011M
	LHL	R5,TS0108,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0108	HS	0
	HC	FSD1O0-F.CODE 	:BETB STATE, ACTION = >(R)
	HC	FSD1L0-F.CODE 	:INB STATE, ACTION = -(C2)
	HC	FSD1M0-F.CODE 	:PEND BB STATE,ACTION = 2(IR)
	HC	FSD1O0-F.CODE 	:PEND INB STATE,ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE,ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE, ACTION=-(C1)

:	CHECK FOR R, RQ, -BB, EB INPUT
:----------------------------------------------
FS011O
	CLHI	R2,MU.EBI		:-BB AND EB?
	JN	FS011W			:NO
	LR	R0,R0			:FMD?
	JN	FS011Q			:NO, DFC
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JN	FS011S			:YES, EC

:==================================================================
:	INPUT:	R, RQ, FMD, -BB, EB, -EC
:==================================================================
	LHL	R5,TS0109,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0109	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE,ACTION = -(C1)
	HC	FSD1R0-F.CODE 	:INB STATE,ACTION = 5,1
	HC	FSD1O0-F.CODE 	:PEND BB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE,ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE, ACTION = -(C1)

:	CHECK FOR R, RQ, -BB, EB, DFC INPUT
:---------------------------------------------------
FS011Q
	CLHI	R5,LUSTAT		:ACTION_CODE=LUSTAT?
	JE	FS011S			:YES
	CLHI	R5,CHASE		:ACTION_CODE=CHASE?
	JE	FS011S			:YES
	CLHI	R5,QC			:ACTION_CODE=QC?
	JE	FS011S			:YES
	CLHI	R5,CANCEL		:ACTION_CODE=CANCEL?
	JN	FS.COD,,		:NO, CRASH

:==================================================================
:	INPUT:	R, RQ, CANCEL, EB
:==================================================================
	LHL	R5,TS010A,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010A	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE, ACTION = -(C1)
	HC	FSD1J0-F.CODE 	:INB STATE, ACTION = 1(B)
	HC	FSD1O0-F.CODE 	:PEND BB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION= >(R)
	HC	FSD1J0-F.CODE 	:PEND TERM_R STATE, ACTION= 1(B)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE, ACTION=-(C1)

:	CHECK FOR R, RQ, -BB, EB, FMD|EBDFC INPUT
:-------------------------------------------------
FS011S
	LB	R4,FS.RQD,,		:RQD?
	JN	FS011U			:-RQD

:================================================================
:	INPUT:	R, RQ, FMD|EBDFC, -BB, EB, RQD
:================================================================
	LHL	R5,TS010B,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010B	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE, ACTION = -(C1)
	HC	FSD1S0-F.CODE 	:INB STATE, ACTION = 5,1(B)
	HC	FSD1O0-F.CODE 	:PEND BB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE,ACTION=>(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE,ACTION=-(C1)

:	CHECK FOR R, RQ, -BB, EB, FMD|EBDFC, -RQD INPUT
:--------------------------------------------------------
FS011U
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JE	FS.CEC,,		:NO, CRASH

:==================================================================
:	INPUT:	R, RQ, FMD|EBDFC, -BB, EB, EC, -RQD
:==================================================================
	LHL	R5,TS010C,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010C	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE, ACTION = -(C1)
	HC	FSD1J0-F.CODE 	:INB STATE, ACTION = 1(B)
	HC	FSD1O0-F.CODE 	:PEND BB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE, ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE,ACTION = -(C1)

:	CHECK FOR R, RQ, -BB, -EB INPUT
:--------------------------------------
FS011W
	LR	R0,R0			:FMD?
	JN	FS0124			:NO, DFC
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.BCI		:BC?
	JE	FS011Y			:NO, -BC

:================================================================
:	INPUT:	R, RQ, FMD, -BB, -EB, BC
:================================================================
	LHL	R5,TS010D,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010D	HS	0
	HC	FSD1K0-F.CODE 	:BETB STATE,ACTION = -(C1)
	HC	FSC000-F.CODE 	:INB STATE,ACTION = -
	HC	FSD1O0-F.CODE 	:PEND BB STATE,ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE,ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE,ACTION = -(C1)

:	CHECK FOR R, RQ, -BB, -EB, FMD, -BC INPUT
:------------------------------------------------------
FS011Y
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	LB	R4,FS.RQD,,		:RQD?
	JN	FS0120			:-RQD
	NHI	R2,MU.CDI		:CD?
	JE	FS011Z			:-CD

:===================================================================
:	INPUT:	R, RQ, FMD, -BC, RQD, CD
:===================================================================
	LHL	R5,TS010E,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010E	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1N0-F.CODE 	:PEND BB STATE, ACTION = 2(IS)
	HC	FSC000-F.CODE 	:PEND INB STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND TERM_R STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND TERM_S STATE, ACTION = -

:=========================================================================
:	INPUT:	R, RQ, FMD, -BB, -EB, -BC, RQD, -CD
:=========================================================================
FS011Z
	LHL	R5,TS010K,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010K	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1M0-F.CODE 	:PEND BB STATE, ACTION = 2(IR)
	HC	FSC000-F.CODE 	:PEND INB STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND TERM_R STATE,ACTION = -
	HC	FSC000-F.CODE 	:PEND TERM_S STATE, ACTION = -
	

:	CHECK FOR R, RQ, -BB, -EB, FMD, -BC, -RQD INPUT
:-----------------------------------------------------------
FS0120
	NHI	R2,MU.CDI		:CD?
	JE	FS0122			:NO, -CD

:================================================================
:	INPUT:	R, RQ, FMD, -BC, -RQD, CD
:================================================================
	LHL	R5,TS010F,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010F	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE ,ACTION = -
	HC	FSD1N0-F.CODE 	:PEND BB STATE, ACTION = 2(IS)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1J0-F.CODE 	:PEND TERM_R STATE,ACTION = 1(B)
	HC	FSC000-F.CODE 	:PEND TERM_S STATE, ACTION = -

:	CHECK FOR R, RQ, -BB, -EB, FMD, -BC, -RQD, -CD INPUT
:--------------------------------------------------------------------
FS0122
	LB	R2,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R2,MU.ECI		:EC?
	JE	FS.CEC,,		:NO, -EC

:======================================================================
:	INPUT:	R, RQ, FMD, -BC, EC, -RQD, -CD
:======================================================================
	LHL	R5,TS010G,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010G	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1M0-F.CODE 	:PEND BB STATE, ACTION = 2(IR)
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >R)
	HC	FSD1J0-F.CODE 	:PEND TERM_R STATE, ACTION = 1(B)
	HC	FSC000-F.CODE 	:PEND TERM_S STATE, ACTION = -

:	CHECK FOR R, RQ, -BB, -EB, DFC
:------------------------------------------------
FS0124
	CLHI	R5,BID			:ACTION_CODE=BID?
	JN	FS0126			:NO

:================================================================
:	INPUT:	R, RQ, BID
:================================================================
	LHL	R5,TS010H,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010H	HS	0
	HC	FSC000-F.CODE 	:BETB STATE, ACTION = -
	HC	FSD1L0-F.CODE 	:INB STATE, ACTION = -(C2)
	HC	FSC000-F.CODE 	:PEND BB STATE,ACTION = -
	HC	FSD1O0-F.CODE 	:PEND INB STATE, ACTION = >(R)
	HC	FSD1O0-F.CODE 	:PEND TERM_R STATE, ACTION = >(R)
	HC	FSD1K0-F.CODE 	:PEND TERM_S STATE, ACTION = -(C1)

:	CHECK FOR R, RQ, -BB, -EB, OTHERDFC
:---------------------------------------------
FS0126
	CLHI	R5,CANCEL		:OTHERDFC?
	JEFS	FS0128			:NO, CANCEL

:=================================================================
:	INPUT:	R, RQ, OTHERDFC, -BB, -EB
:==================================================================
	CLHI	R7,FS.ST4		:PEND INB STATE?
	JEFS	FS0128			:YES, ACTION = >(R)
	CLHI	R7,FS.ST5		:PEND TERM_R STATE?
FS0128
	JE	FSD1O0,,		:YES, ACTION = >(R)
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR R, RQ, -BB, -EB, CANCEL
:----------------------------------------------
FS012A
	LB	R2,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	NHI	R2,MU.CDI		:CD?
	JE	FS012C			:NO, -CD

:================================================================
:	INPUT:	R, RQ, CANCEL, -EB, CD
:================================================================
	LHL	R5,TS010I,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010I	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1N0-F.CODE 	:PEND BB STATE, ACTION = 2(IS)
	HC	FSC010-F.CODE 	:PEND INB STATE, ACTION = 1
	HC	FSC020-F.CODE 	:PEND TERM_R STATE, ACTION = 2
	HC	FSC000-F.CODE 	:PEND TERM_S STATE, ACTION = -

:=======================================================================
:	INPUT:	R, RQ, CANCEL, -EB, -CD
:=======================================================================
FS012C
	LHL	R5,TS010J,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS010J	HS	0
	HC	FSD1I0-F.CODE 	:BETB STATE, ACTION = -(B)
	HC	FSC000-F.CODE 	:INB STATE, ACTION = -
	HC	FSD1M0-F.CODE 	:PEND BB STATE, ACTION = 2(IR)
	HC	FSC010-F.CODE 	:PEND INB STATE, ACTION = 1
	HC	FSC020-F.CODE 	:PEND TERM_R STATE, ACTION = 2
	HC	FSC010-F.CODE 	:PEND TERM_S STATE, ACTION = -





	SUBTTL	FSM_CONTROL_BSM_RSP_RCV
:***********************************************************************
:	FSM_CONTROL_BSM_RSP_RCV
:***********************************************************************
:	FS0500	-(FSM_CONTROL_BSM_RSP_RCV) PASSES RESPONSES TO THE BRACKET
:	STATE MANAGER (BSM) FSM. THE RESPONSES ARE PASSED TO BSM ONLY
:	WHEN 2 CONDITIONS ARE SATISFIED: 1) THE END CHAIN REQUEST HAS BEEN
:	SENT AND 2) THE RESPONSE IS TO THE CURRENT CHAIN (NOT A PREVIOUS
:	CHAIN). ALL POSITIVE AND NEGATIVE RESPONSES TO THE CURRENT CHAIN
:	ARE PASSED TO FSM_BSM, BUT STATE CHANGES ARE NOT MADE ON ALL OF 
:	THEM. THIS FSM MAY FOLLOW A DIRECT CALL TO FSM_BSM AND MAY RE-
:	INVOKE FSM_BSM.
:	PAGE 5-73 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE 
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK),
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS0500
	FS.MC1(FSCCBR,FS.SCB)		:CHECK INPUTS
	STM	R0,FS.ASV,,		:SAVE ALL ORIGINAL INPUT REGISTERS
					:FOR A1 OR A3 ACTION CODES.
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS0502			:NO. GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:SIGNAL = 'RESET'?
	JN	FS.CSG,,		:NO, INVALID INPUT.

:=================================================================
:	INPUT:	'RESET'
:=================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUTS OTHER THAN SIGNAL INPUT
:------------------------------------------------
FS0502
	LR	R2,R2			:SEND?
	JN	FS0506			:NO, GO CHECK RCV INPUTS
	LR	R4,R4			:REQUEST ?
	JN	FS.CRS,,		:NO, INVALID INPUT.
	LB	R5,BBUFER+MURHF1,R10,	:GET ECI BIT
	NHI	R5,MU.ECI		:END CHAIN INDICATOR SET?

:======================================================================
:	INPUT:	S, RQ, -EC
:======================================================================
	JE	FS0603,,		:NO, GO GET STATE ENTRY ROUTINE

:====================================================================
:	INPUT:	S, RQ, EC
:====================================================================
FS0504
	LHL	R5,TS0503,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0503	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSC010-F.CODE 	:INC STATE, ACTION = 1
	HC	FSD0H0-F.CODE 	:RSP RCVD STATE, ACTION = 1(A3)

:	CHECK RECEIVE INPUTS
:------------------------------
FS0506
	LR	R4,R4			:RESPONSE?
	JE	FS.CRQ,,		:NO, INVALID INPUT
	JAL	R4,FS05D0,,		:CHECK IF TO_CURRENT_CHAIN
	J	FS.CUR,,		:NO, INVALID INPUT
	LB	R5,BBUFER+MURHF2,R10,	:GET ERI BIT
	NHI	R5,MU.RTI		:POSITIVE RESPONSE?
	JN	FS0508			:NEGATIVE, -RSP INPUT

:=====================================================================
:	INPUT:	R, +RSP, TO_CURRENT_CHAIN
:=====================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSD0B0,,		:YES, ACTION = -(A1)
	J	FSC000,,		:NO, ALL OTHER STATES, ACTION = -

:================================================================
:	INPUT:	R, -RSP, TO_CURRENT_CHAIN
:================================================================
FS0508
	LHL	R5,TS0506,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0506	HS	0
	HC	FSD0B0-F.CODE 	:RESET STATE, ACTION = -(A1)
	HC	FSD0D0-F.CODE 	:INC STATE, ACTION = 3(A2)
	HC	FSC000-F.CODE 	:RSP RCVD STATE, ACTION = -


:	FS05D0	-THIS ROUTINE CHECKS IF TO_CURRENT_CHAIN IS TRUE.
:		 A NORMAL RETURN IS EXECUTED IF FALSE. A SKIP 
:		 RETURN IS EXECUTED IF TRUE.
:		
:		TO_CURRENT_CHAIN IS TRUE IF ONE OF THE TWO FOLLOWING 
:		CONDITIONS IS TRUE:
:		1.   [LAST ENTRY(CT_PTR)->CT_END_SNF -
:		      LAST ENTRY(CT_PTR)->CT_BEG_SNF>=0]     
:				AND
:		     [SNF>=LAST ENTRY(CT_PTR)->CT_BEG_SNF AND
:		      SNF<=LAST ENTRY(CT_PTR)->CT_END_SNF]
:		2.   [LAST ENTRY(CT_PTR)->CT_END_SNF -
:		      LAST ENTRY(CT_PTR)->CT_BEG_SNF<0]
:				AND
:		     [SNF>=LAST_ENTRY(CT_PTR)->CT_BEG_SNF OR
:		      SNF<=LAST_ENTRY(CT_PTR)->CT_END_SNF]
:	LET BEG_SNF=A, SNF=B AND END_SNF=C (9/19/84, MIA)
:	THEN THIS CONDITIONS ARE EQUIVALENT TO THE FOLLOWING (9/19/84 MIA)
:	COMPUTE A-B, C-A AND C-B (9/19/84 MIA)
:	ODD NUMBER OF THEM SHOULD BE NEGATIVE (9/19/84 MIA)
:	INPUT:	R9 (SCB ENTRY), R10 (MU_PTR)
:	LINK:	R4
:	OUTPUT:	NORMAL RETURN FOR FALSE, SKIP RETURN FOR TRUE
:	WORKING:DOESN'T DISTURB ANY REGISTERS
:-------------------------------------------------------------------
FS05D0
	STM	R0,FS.SV0,,		:SAVE ALL REGISTERS
	LHL	R1,SCBBLK+SCTPTG,R9,	:GET 1ST_ENTRY(CT_PTR)
:	CLH	R1,SCBBLK+SCTPTR,R9,	:GET PTR = REL PTR? (01/03/85 MIA)
	LHL	R0,SCBBLK+SCTPTR,R9,	:GET REL PTR (01/03/84 MIA)
	CR	R1,R0			:COMP THEM (01/03 85 MIA)
	JE	FS05D4			:YES, ERROR
FS05D1					:(6/21/84/CHS) TO SEARCH FOR LAST ENTRY
	LHL	R2,CMDBLK+CLPTR,R1,	:GET LINK PTR
:	CLH	R2,SCBBLK+SCTPTR,R9,	:THE LAST ONE ? (01/03/84 MIA)
	CR	R2,R0			:THE LAST ONE? (01/03/84 MIA)
	JE	FS05D5			:YES, SKIP
	LR	R1,R2			:R1 POINT TO NEXT ONE
	J	FS05D1			:REPEAT
FS05D5
					:(6/21/84/CHS) END OF SEARCH
	BBLOAD	R1,CMDBLK+CLARG,R1,	:POINT TO CORRELATION TAB (9/7/84 MIA)
	LHL	R0,BBUFER+MUSNF,R10,	:GET SNF
	LHL	R2,BBUFER+CLARG3,R1,	:GET CT_END_SNF
:	SH	R2,BBUFER+CLARG0,R1,	:SUBTRACT CT_BEG_SNF
:	JG	FS05D4			:NORMAL RETURN, FALSE
:	JL	FS05D2			:GO CHECK FOR SECOND CONDITION
:	CH	R0,BBUFER+CLARG0,R1,	:SNF>=LAST_ENTRY(CT_PTR)->CT_BEG_SNF?
:	JL	FS05D4			:NO, FALSE CONDITION
:	CH	R0,BBUFER+CLARG3,R1,	:SNF<=LAST_ENTRY(CT_PTR)->CT_END_SNF?
:	JG	FS05D4			:NO, FALSE CONDITION
:	J	FS05D3			:TRUE. TO_CURRENT_CHAIN
:FS05D2	CH	R0,BBUFER+CLARG0,R1,	:SNF>=LAST_ENTRY(CT_PTR)->CT_BEG_SNF?
:	JGE	FS05D3			:YES, TO_CURRENT_CHAIN IS TRUE.
:	CH	R0,BBUFER+CLARG3,R1,	:SNF<=LAST_ENTRY(CT_PTR)->CT_END_SNF?
:	JG	FS05D4			:NO, FALSE CONDITION
	LHL	R1,BBUFER+CLARG0,R1,	:GET SNF = B (9/19/84 MIA)
	SR	R2,R0			:COMPUTE (C-B) (9/19/84 MIA)
	JEFS	FS05D3			:OK IF C = B (9/19/84 MIA)
	SR	R1,R0			:COMPUTE (A-B) (9/19/84 MIA)
	JEFS	FS05D3			:OK IF A = B (9/19/84 MIA)
	LR	R0,R2			:COPY (C - B) (9/20/84 MIA)
	SR	R0,R1			:C - A = (C-B) - (A-B) (9/20/84 MIA)
	XR	R2,R1			:SIGNS (C-A) AND (A-B) (9/19/84 MIA)
	XR	R2,R0			:ALSO SIGN OF (C-B) (9/19/84 MIA)
	JGEFS	FS05D4			:FALSE IF NOT NEGATIVE (9/19/84 MIA)

: TO_CURRENT_CHAIN = TRUE, EXECUTE A SKIP RETURN
FS05D3
	LM	R0,FS.SV0,,		:RESTORE REGISTERS
	AIS	R4,6			:YES, TO_CURRENT_CHAIN IS TRUE.
	JR	R4			:SKIP RETURN IF TRUE
: TO_CURRENT_CHAIN = FALSE, EXECUTE NORMAL RETURN
FS05D4
	LM	R0,FS.SV0,,		:RESTORE ALL REGISTERS
	JR	R4



	SUBTTL	FSM_CONTROL_BSM_RSP_SEND
:**********************************************************************
:	FSM_CONTROL_BSM_RSP_SEND
:**********************************************************************
:	FS0600	-(FSM_CONTROL_BSM_RSP_SEND) THIS FSM PASSES RESPONSES TO
:	THE BRACKET STATE MANAGER (BSM) FSM. THE RESPONSES ARE PASSED
:	TO BSM ONLY WHEN TWO CONDITIONS ARE SATISFIED: 1) THE END CHAIN
:	REQUEST HAS BEEN RECEIVED AND 2) THE RESPONSE IS TO THE CURRENT
:	CHAIN (NOT A PREVIOUS CHAIN). ALL POSITIVE AND NEGATIVE RESPONSES
:	TO THE CURRENT CHAIN ARE PASSED TO #FSM_BSM, BUT STATE CHANGES
:	ARE NOT MADE ON ALL OF THEM. THIS FSM MAY FOLLOW A DIRECT CALL
:	TO #FSM_BSM AND MAY INVOKE #FSM_BSM.
:	PAGE 5-74 IN FAPL
:	----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK),
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS0600
	FS.MC1(FSCCBS,FS.SCB)		:CHECK INPUTS
	STM	R0,FS.ASV,,		:SAVE ORIGINAL INPUT REGISTERS FOR
					:POSSIBLE A1 OR A2 ACTION CODE
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS0602			:NO, GO CHECK FOR OTHER INPUTS
	CLHI	R0,FS.RET		:SIGNAL=RESET?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID INPUTS
:===================================================================
:	INPUT:	'RESET'
:===================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUTS OTHER THAN SIGNAL INPUTS
:------------------------------------------------
FS0602
	LR	R2,R2			:RECEIVE?
	JE	FS0606			:NO, SEND.
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:CRASH, RSP NOT VALID INPUT
	LB	R5,BBUFER+MURHF1,R10,	:GET ECI BIT
	NHI	R5,MU.ECI		:ECI BIT SET?
	JN	FS0604			:YES, EC INPUT.
:=====================================================================
:	INPUT:	R, RQ, -EC
:=====================================================================
FS0603
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC020,,		:YES, ACTION = 2
	J	FSC000,,		:NO, ALL OTHER STATES, ACTION = -

:=======================================================================
:	INPUT:	R, RQ, EC
:=======================================================================
FS0604
	LHL	R5,TS0603,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0603	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSC010-F.CODE 	:INC STATE, ACTION = 1
	HC	FSD0I0-F.CODE 	:RSP SENT STATE, ACTION = 1(A3)

:	CHECK FOR SEND INPUT
:----------------------------------
FS0606
	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS.CRQ,,		:REQUEST, CRASH.
	JAL	R4,FS05D0,,		:CHECK IF TO_CURRENT_CHAIN
	J	FS.CUR,,		:FALSE, CRASH.
	LB	R5,BBUFER+MURHF2,R10,	:GET RTI BIT
	NHI	R5,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS0608,,		:NEGATIVE (-RSP)

:======================================================================
:	INPUT:	S, +RSP, TO_CURRENT_CHAIN
:======================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSD0B0,,		:YES, ACTION = -(A1)
	J	FSC000,,		:NO, ALL OTHER STATES, ACTION = -

:=====================================================================
:	INPUT:	S, -RSP, TO_CURRENT_CHAIN
:======================================================================
FS0608
	LHL	R5,TS0605,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0605	HS	0
	HC	FSD0B0-F.CODE 	:RESET STATE, ACTION = -(A1)
	HC	FSD0E0-F.CODE 	:INC STATE, ACTION = 3(A2)
	HC	FSC000-F.CODE 	:RSPSENT STATE, ACTION = -


	FO	CBKDEF
	FO	CMDLST
	
	EM				:END OF MODULE 'SSBF00'
 :	*******************************************************************
:	REVISION HISTORY
:	03/28/84 (DRUE BONDAD)	-ORIGINAL DESIGN AND CODING
:	********************************************************************

	SUBTTL	HDX FSM'S USING SCB - DFC LAYER ('SSHF00')

	RA	0
	
	MO	.,SNAPKG
	LO	CMDLST
	LO	CBKDEF

	SEG	A.CODE

:(F05/12/18/87/DB/START)
: THIS JUMP WAS ADDED SO THAT FSCIN COULD ACCESS FS.CIN WHICH IS
: NOT DEFINED AFTER FCODE.
: ALL REFERENCES TO FS.CIN WERE CHANGED TO FSCIN!!!!
FSCIN	
	J	FS.CIN,,
:(F05/12/18/87/DB/END)

	SUBTTL	FSM_CONTROL_HDX_RSP_RCV
:***********************************************************************
:	FSM_CONTROL_HDX_RSP_RCV
:***********************************************************************
:	FS0700	-(FSM_CONTROL_HDX_RSP_RCV) THIS FSM PASSES RESPONSES TO
:	THE HALF-DUPLEX MANAGER FSM (#FSM_HDX). THE RESPONSES ARE PASSED
:	ONLY WHEN BETWEEN CHAINS. ONLY NEGATIVE RESPONSES ARE PASSED TO
:	#FSM_HDX. STATE CHANGES ARE NOT NECESSARILY MADE BY #FSM_HDX ON
:	EVERY RECEIVED NEGATIVE RESPONSE. POSITIVE RESPONSES ARE NOT 
:	PASSED BECAUSE NO STATE CHANGES ARE EVER MADE ON THEM. THIS FSM
:	MAY FOLLOW A DIRECT CALL TO FSM_HDX AND MAY REINVOKE FSM_HDX.
:	PAGE 5-75 FAPL
:	----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENDTRY), R10 (MU PTR ), R7 (FSM STATE 
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS0700
	FS.MC1(FSCHRV,FS.SCB)		:CHECK INPUTS
	STM	R0,FS.ASV,,		:SAVE ORIGINAL INPUT REGISTERS FOR 
					:POSSIBLE A1 OR A2 ACTION CODES
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS0702			:NO, GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:SIGNAL = 'RESET'?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID

:===========================================================================
:	INPUT:	'RESET'
:==========================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:--------------------------------
FS0702
	LR	R2,R2			:SEND OR RECEIVE?
	JN	FS0706			:RECEIVE
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:CRASH IF RESPONSE
	LB	R5,BBUFER+MURHF1,R10,	:GET ECI BIT
	NHI	R5,MU.ECI		:END CHAIN INDICATOR SET?
	JN	FS0704			:YES, EC INPUT

:=========================================================================
:	INPUT:	S, RQ, -EC
:==========================================================================
	J	FS0603,,		:GO GET STATE ENTRY ROUTINE

:=========================================================================
:	INPUT:	S, RQ, EC
:=========================================================================
FS0704	
	LHL	R5,TS0703,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0703	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSC010-F.CODE 	:INC STATE, ACTION = 1
	HC	FSD0J0-F.CODE 	:RSP RCVD STATE, ACTION = 1(A3)

:	CHECK FOR RECEIVE INPUT
:---------------------------------------------
FS0706
	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS.CRQ,,		:CRASH IF REQUEST
	LB	R0,BBUFER+MURHF2,R10,	:GET RTI BIT
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JE	FS.CPS,,		:POSITVE RSP, CRASH
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR (6/22/84/CHS)
:	CLH	R5,SCBBLK+SCTPTR,R9,	:GET_PTR = REL_PTR? (6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JE	FS.CPT,,		:RETURN IF PTR EMPTY
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO CORRELATION TAB (9/7/84 MIA)
	LB	R2,BBUFER+CLARG5,R5,	:GET CT(BB) AND CT(EB) BITS
	NHI	R2,MU.BBI+MU.EBI	:GET CT_BBI & CT_EBI BITS ONLY
	CLHI	R2,MU.BBI+MU.EBI	:CT(BB&EB)?
	JE	FS.CCT,,		:YES, INVALID INPUT

:=======================================================================
:	INPUT:	R, -RSP, -(CT(BB) AND CT(EB))
:=======================================================================
FS0708
	LHL	R5,TS0704,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0704	HS	0
	HC	FSD0C0-F.CODE 	:RESET STATE, ACTION = -(A1)
	HC	FSD0F0-F.CODE 	:INC STATE, ACTION = 3(A2)
	HC	FSC000-F.CODE 	:RSP RCVD STATE, ACTION = -

	

	SUBTTL	FSM_CONTROL_HDX_RSP_RCV_ERP_DL
:****************************************************************************
:	FSM_CONTROL_HDX_RSP_RCV_ERP_DL
:****************************************************************************
:	FS0800	-(FSM_CONTROL_HDX_RSP_RCV_ERP_DL) TO IDENTIFY THE ERP
:	SYNCHRONIZATION EVENT (THE RESPONSE TO CHASE) THAT MARKS THE POINT
:	AT WHICH THE HDX FSM IS TO MAKES IT'S ERP TRANSITION. WHEN THE 
:	EVENT OCCURS, THIS FSM CALLS FSM_HDX_FF TO CAUSE THE ERP TRAN-
:	SITION. THE BASIC IDEA IS TO PRESENT ALL RESPONSES TO FSM_HDX_FF 
:	AT THE END OF A PERIOD OF ACTIVITY SO THAT FSM_HDX_FF WILL NOT HAVE
:	TO NUMEROUS PENDING STATES OR COMPLICATED CHECKING OF PENDING 
:	STATES IN OTHER FSMS.
:
:	THERE ARE THREE MAJOR STATES IN THIS FSM:
:	1. & 2. RESET
:	3. & 6. THE SYNC EVENT HAS BEEN SENT BUT IT'S RESPONSE HAS NOT 
:	BEEN RECEIVED.
:	4. & 5. A NEGATIVE RESPONSE HAS BEEN RECEIVED, BUT THE SYNC EVENT
:	HAS NOT YET BEEN SENT.
:
:	THIS FSM IS USED ONLY WHEN SYMMETRIC ERROR RECOVERY IS BEING USED 
:	AND THIS HALF-SESSION IS USING DELAYED REQUEST MODE.
:	PAGE 5-76 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR 
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE 
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK),
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS0800
	FS.MC1(FSCHRD,FS.SCB)		:CHECK INPUTS
	STM	R0,FS.ASV,,		:SAVE ORIGINAL INPUT REGISTERS FOR
					:POSSIBLE A1 OR A2 ACTION CODES.
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS0804			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:=======================================================================
:	INPUT:	RESET
:=======================================================================
FS0802
	CLHI	R7,FS.ST1		:RESET BETC STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC010,,		:NO, ACTION = 1

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:--------------------------------------------
FS0804
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE
	LR	R2,R2			:SEND OR RCV?
	JN	FS080A			:RCV
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.CTG		:MASK FOR JUST RU_CATEGORY BITS
	CLHI	R2,MU.DFC		:RU = DFC?
	JN	FS0806			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,CHASE		:ACTION_CODE = CHASE?
	JN	FS0806			:NO, -CHASE

:========================================================================
:	INPUT:	S, RQ, CHASE
:========================================================================
	LHL	R5,TS0801,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0801	HS	0
	HC	FSC030-F.CODE 	:RESET BETC STATE, ACTION = 3
	HC	FSCIN-F.CODE 	:RESET INC STATE, ACTION = /
	HC	FSD110-F.CODE 	:SENTSE BETC CHASE, ACTION = >(S)
	HC	FSC060-F.CODE 	:WAITSE BETC STATE, ACTION = 6
	HC	FSCIN-F.CODE 	:WAITSE INC STATE, ACTION = /
	HC	FSD110-F.CODE 	:CMSSE BETC CHASE STATE,ACTION=>(S)

:	CHECK FOR , RQ, -CHASE INPUT
:--------------------------------------
FS0806
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.ECI		:END CHAIN INDICATOR SET?
	JN	FS0808			:YES, EC

:========================================================================
:	INPUT:	S, RQ, -EC
:========================================================================
	CLHI	R7,FS.ST2		:RESET INC STATE?
	JE	FSC000,,		:YES, ACTION = -
	JL	FSC020,,		:NO, RESET BETC STATE, ACTION = 2
	J	FSD110,,		:OTHER STATES, ACTION = >(S)

:=========================================================================
:	INPUT:	S, RQ, EC, -CHASE
:=========================================================================
FS0808
	LHL	R5,TS0802,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0802	HS	0
	HC	FSC000-F.CODE 	:RESET BETC STATE, ACTION = -
	HC	FSC010-F.CODE 	:RESET INC STATE, ACTION = 1
	HC	FSD110-F.CODE 	:SENTSE BETC CHASE STATE, ACTION=>(S)
	HC	FSD110-F.CODE 	:WAITSE BETC STATE, ACTION = >(S)
	HC	FSC040-F.CODE 	:WAITSE INC STATE, ACTION = 4
	HC	FSD110-F.CODE 	:CMSSE BETC CHASE, ACTION = >(S)

:	CHECK FOR RCV INPUT
:--------------------------------------
FS080A
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ
	LB	R4,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R4,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS080C			:-RSP
	CLHI	R4,MU.DFC		:DFC RU?
	JN	FS080B			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,CHASE		:ACTION_CODE = CHASE?

:===================================================================
:	INPUT:	R, +RSP, -CHASE
:===================================================================
FS080B
	JN	FSC000,,		:NO, ACTION = -

:===================================================================
:	INPUT:	R, +RSP, CHASE
:===================================================================
	LHL	R5,TS0803,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0803	HS	0
	HC	FSC000-F.CODE 	:RESET BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:RESET INC STATE, ACTION = -
	HC	FSC010-F.CODE 	:SENTSE BETC CHASE, ACTION= 1
	HC	FSC000-F.CODE 	:WAITSE BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC STATE, ACTION = -
	HC	FSD1A0-F.CODE 	:CMSSE BETC CHASE STATE, ACTION = 1(A3)


:	CHECK FOR R, -RSP, INPUT
:------------------------------------------
FS080C
	CLHI	R4,MU.DFC		:DFC RU?
	JN	FS080E			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,CHASE		:ACTION_CODE = CHASE?
	JN	FS080E			:NO
:========================================================================
:	INPUT:	R, -RSP, CHASE
:========================================================================
	LHL	R5,TS0804,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0804	HS	0
	HC	FSC000-F.CODE 	:RESET BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:RESET INC STATE, ACTION = -
	HC	FSD130-F.CODE 	:SENTSE BETC CHASE, ACTION = 1(A1)
	HC	FSC000-F.CODE 	:WAITSE BETS STATE, ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC STATE, ACTION = -
	HC	FSD1A0-F.CODE 	:CMSEE BETC CHASE STATE,ACTION=1(A3)

:	CHECK FOR R, -RSP, -CHASE INPUT
:------------------------------------------------------
FS080E
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR (6/22/84/CHS)
:	CLH	R5,SCBBLK+SCTPTR,R9,	:GET CT_PTR = REL CT_PTR? (6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM=ENTRY_PTR (6/22/84/CHS)
	JE	FS.CPT,,		:RETURN IF PTR EMPTY
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO CORRELATION TAB (9/7/84 MIA)
	LB	R2,BBUFER+CLARG5,R5,	:GET BB AND EB BITS FROM CT
	NHI	R2,MU.BBI+MU.EBI	
	CLHI	R2,MU.BBI+MU.EBI	:BB AND EB?
	JE	FS.CCT,,		:YES, CRASH

:=========================================================================
:	INPUT:	R, -RSP, -CHASE, -(CT(BB)&CT(EB))
:=========================================================================
FS080G
	LHL	R5,TS0805,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0805	HS	0
	HC	FSD140-F.CODE 	:RESET BETC STATE, ACTION = 4(A2)
	HC	FSD150-F.CODE 	:RESET INC STATE, ACTION = 5(A2)
	HC	FSD160-F.CODE 	:SENTSE BETC CHASE, ACTION = 6(A2)
	HC	FSC000-F.CODE 	:WAITSE BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC STATE, ACTION = -
	HC	FSC000-F.CODE 	:CMSSE BETC CHASE STATE, ACTION = -



	SUBTTL	FSM_CONTROL_HDX_RSP_RCV_ERP_IM
:************************************************************************
:	FSM_CONTROL_HDX_RSP_RCV_ERP_IM
:************************************************************************
:	FS0900	-(FSM_CONTROL_HDX_RSP_RCV_ERP_IM) THE FUNCTION OF THIS
:	FSM IS TO IDENTIFY THE SYNCHRONIZATION EVENT (SYNC EVENT RESPONSE
:	TO RQD OR RQE WITH CD. THAT MARKS THE POINT AT WHICH THE HDX FSM
:	IS TO MAKE IT'S ERP TRANSITION. WHEN THAT EVENT OCCURS, THIS FSM
:	FSM_HDX_FF TO CAUSE THE ERP TRANSITION. THE BASIC IDEA IS TO 
:	PRESENT ALL RESPONSES TO FSM_HDX_FF AT THE END OF A PERIOD OF
:	ACTIVITY  SO THAT FSM_HDX_FF WILL NOT HAVE TO CONTAIN NUMEROUS
:	PENDING STATES OF COMPLICATED CHECKING OF PENDING STATES IN OTHER
:	FSMS.
:
:	THERE ARE THREE MAJOR STATES IN THIS FSM:
:	1. & 2. RESET
:	3., 4., 8., & 9. THE SYNC EVENT HAS BEEN SENT BUT IT'S RESPONSE
:	HAS NOT BEEN RECEIVED. THIS RESPONSE MAY BE POSITIVE OR NEGATIVE. 
:	IF THE SYNC EVENT WAS RQE WITH CD THEN THE POSITIVE RESPONSE MAY
:	BE IMPLIED BY THE RECEIPT OF A REQUEST. THIS MAY OCCUR IN STATE 3.
:	5., 6. & 7. A NEGATIVE RESPONSE HAS BEEN RECEIVED, BUT THE SYNC
:	EVENT HAS NOT YET BEEN SENT.
:
:	THIS FSM IS USED ONLY WHEN SYMMETRIC ERROR RECOVERY IS USED AND
:	THIS HALF-SESSION IS USING IMMEDIATE REQUEST MODE.
:	PAGE 5-77 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM 
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS0900
	FS.MC1(FSCHRI,FS.SCB)		:CHECK INPUTS
	STM	R0,FS.ASV,,		:SAVE ORIGINAL INPUT REGISTERS FOR
					:POSSIBLE A1 OR A2 ACTION CODES.
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS0904			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:=====================================================================
:	INPUT:	RESET
:=====================================================================
FS0902
	CLHI	R7,FS.ST1		:RESET BETC STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC010,,		:NO, ACTION = 1

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:------------------------------------------
FS0904
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE FROM RU
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR RU CATEGORY BITS
	LR	R2,R2			:SEND OR RCV?
	JE	FS090I			:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS0906			:RSP

:===================================================================
:	INPUT:	R, RQ
:===================================================================
	LHL	R5,TS0901,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0901	HS	0
	HC	FSC000-F.CODE 	:RESET BETC STATE, ACTION = -
	HC	FSCIN-F.CODE 	:RESET INC STATE, ACTION = /
	HC	FSC010-F.CODE 	:SENTSE BETC NOTCAN STATE,ACTION=1
	HC	FSD120-F.CODE 	:SENTSE BETC CANCEL STATE,ACTION =>(R)
	HC	FSCIN-F.CODE 	:WAITSE BETC STATE, ACTION = /
	HC	FSCIN-F.CODE 	:WAITSE INC STATE, ACTION = /
	HC	FSCIN-F.CODE 	:WAITSE INC PRECHN, ACTION = /
	HC	FSD120-F.CODE 	:SENTSE BETC NOTCAN STATE, ACTION=>(R)
	HC	FSD120-F.CODE 	:SENTSE BETC CANCEL STATE,ACTION=>(R)

:	CHECK FOR R, RSP INPUT
:-------------------------------------
FS0906
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS090A			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,CANCEL		:ACTION_CODE = CANCEL?
	JN	FS090A			:NO, -CANCEL
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS0908			:NEGATIVE, -RSP

:======================================================================
:	INPUT:	R, +RSP, CANCEL
:======================================================================
	CLHI	R7,FS.ST4		:SENTSE BETC CANCEL STATE?
	JE	FSC010,,		:YES, ACTION = 1
	CLHI	R7,FS.ST9		:SENTSE BETC CANCEL STATE?
	JE	FSD1A0,,		:YES, ACTION = 1(A3)
	J	FSC000,,		:NO, ACTION = -

:=====================================================================
:	INPUT:	R, -RSP, CANCEL
:=====================================================================
FS0908
	CLHI	R7,FS.ST4		:SENTSE BETC CANCEL STATE?
	JE	FSD130,,		:YES, ACTION = 1(A1)
	CLHI	R7,FS.ST9		:SENTSE BETC CANCEL STATE?
	JE	FSD1A0,,		:YES, ACTION = 1(A3)
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR R, RSP, -CANCEL INPUT
:----------------------------------------
FS090A
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS090C			:NEGATIVE,
	JAL	R4,FS05D0,,		:TO_CURRENT_CHAIN?
	J	FS.CUR,,		:NO, CRASH

:=====================================================================
:	INPUT:	R, +RSP, -CANCEL, TO_CURRENT_CHAIN
:=====================================================================
	CLHI	R7,FS.ST3		:SENTSE BETC NOTCAN STATE?
	JE	FSC010,,		:YES, ACTION = 1
	CLHI	R7,FS.ST8		:SENTSE BETC NOTCAN -RSP RCVD STATE?
	JE	FSD1A0,,		:YES, ACTION = 1(A3)
	J	FSC000,,		:NO, ACTION = -

:	CHECK FOR R, -RSP, -CANCEL INPUT
:---------------------------------------------------------
FS090C
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR (6/22/84/CHS)
:	CLH	R5,SCBBLK+SCTPTR,R9,	:GET CT_PTR = REL CT_PTR? (6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JE	FS.CPT,,		:RETURN IF PTR EMPTY
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO CORRELATION TAB (9/7/84 MIA)
	LB	R2,BBUFER+CLARG5,R5,	:GET CT(BB) & CT(EB) BITS
	NHI	R2,MU.BBI+MU.EBI	
	CLHI	R2,MU.BBI+MU.EBI	:CT(BB)&CT(EB)?
	JE	FS.CCT,,		:YES, CRASH
	JAL	R4,FS05D0,,		:TO_CURRENT_CHAIN?
	J	FS090G,,		:NO, - TO_CURRENT_CHAIN

:==================================================================
:	INPUT:	R, -RSP, -CANCEL, TO_CURRENT_CHAIN,-(CT(BB)&CT(EB))
:==================================================================
	LHL	R5,TS0902,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0902	HS	0
	HC	FSD150-F.CODE 	:RESET BETC STATE, ACTION =5(A2)
	HC	FSD160-F.CODE 	:RESET INC STATE, ACTION = 6(A2)
	HC	FSD130-F.CODE 	:SENTSE BETC NOTCAN STATE,ACTION=1(A1)
	HC	FSD190-F.CODE 	:SENTSE BETC CANCEL STATE,ACTION=9(A2)
	HC	FSC000-F.CODE 	:WAITSE BETC STATE,ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC STATE, ACTION = -
	HC	FSC060-F.CODE 	:WAITSE INC PRECHN STATE,ACTION = 6
	HC	FSD1A0-F.CODE 	:SENTSE BETC NOTCAN,ACTION = 1(A3)
	HC	FSC000-F.CODE 	:SENTSE BETC CANCEL, ACTION = -

:================================================================================
:	INPUT:	R, -RSP, -CANCEL, -TO_CURRENT_CHAIN,-(CT(BB)&CT(EB))
:=============================================================================
FS090G
	LHL	R5,TS0903,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0903	HS	0
	HC	FSD150-F.CODE 	:RESET BETC STATE, ACTION = 5(A2)
	HC	FSD170-F.CODE 	:RESET INC STATE, ACTION = 7(A2)
	HC	FSD180-F.CODE 	:SENTSE BETC NOTCAN, ACTION = 8(A2)
	HC	FSD190-F.CODE 	:SENTSE BETC CANCEL, ACTION = 9(A2)
	HC	FSC000-F.CODE 	:WAITSE BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC STATE, ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC PRECHN, ACTION = -
	HC	FSC000-F.CODE 	:SENTSE BETC NOTCAN, ACTION = -
	HC	FSC000-F.CODE 	:SENTSE BETC CANCEL, ACTION = -

:	CHECK FOR SEND INPUT
:-----------------------------
FS090I
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS090K			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,CANCEL		:ACTION_CODE = CANCEL?
	JN	FS090K			:NO, -CANCEL

:=========================================================================
:	INPUT:	S, RQ, CANCEL
:=========================================================================
	LHL	R5,TS0904,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0904	HS	0
	HC	FSCIN-F.CODE 	:RESET BETC STATE, ACTION = /
	HC	FSC040-F.CODE 	:RESET INC STATE, ACTION = 4
	HC	FSCIN-F.CODE 	:SENTSE BETC NOTCAN, ACTION = /
	HC	FSCIN-F.CODE 	:SENTSE BETC CANCEL, ACTION = /
	HC	FSCIN-F.CODE 	:WAITSE BETC, ACTION = /
	HC	FSC090-F.CODE 	:WAITSE INC CURCHN, ACTION = 9
	HC	FSC090-F.CODE 	:WAITSE INC PRECHN, ACTION = 9
	HC	FSCIN-F.CODE 	:SENTSE BETC NOTCAN,ACTION = /
	HC	FSCIN-F.CODE 	:SENTSE BETC CANCEL, ACTION = /

:	CHECK FOR S, RQ, -CANCEL INPUT
:----------------------------------------
FS090K
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.ECI		:END CHAIN INDICATOR SET?
	JN	FS090M			:YES

:=================================================================
:	INPUT:	S, RQ, -CANCEL, -EC
:=================================================================
	CLHI	R7,FS.ST2		:RESET INC STATE?
	JL	FSC020,,		:NO, RESET BETC STATE, ACTION = 2
	JE	FSC000,,		:YES, ACTION = -
	J	FSD110,,		:ALL OTHER STATE, ACTION = >(S)

:	CHECK FOR S, RQ, -CANCEL, EC INPUT
:-----------------------------------------------------
: CHECK FOR INPUT A OR INPUT B:
:      (RQD|(RQE&CD)) = INPUT A
:     -(RQD|(RQE&CD)) = -RQD & - (RQE & CD) = INPUT B
:	RQD = TRUE IF -ERI(DR1|DR2)
:	RQE = TRUE IF  ERI
: IF ERI THEN 		/* RQE
:    IF CD THEN ERI & CD = INPUT A
:    ELSE -CD THEN -RQD&-(ERI&CD) = INPUT B
: ELSE -ERI THEN	/* -RQE
:    IF -(DR1|DR2) THEN -RQE&-RQD = INPUT B
:    ELSE DR1|DR2 THEN RQD = INPUT A
: 
FS090M
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH	
	LR	R2,R0
	LR	R4,R0
	NHI	R2,MU.ERI		:ERI?
	JEFS	FS090O			:-ERI, WHICH MEANS -RQE
	NHI	R0,MU.CDI		:CDI?
	JN	FS090Q			:YES, RQD&CD
	J	FS090S			:-CD
FS090O
	NHI	R4,MU.DR1I+MU.DR2I	:DR1|DR2?
	JE	FS090S			:NO, WHICH MEANS -RQD	

:==========================================================================
:	INPUT:	S, RQ, -CANCEL, EC, (RQD|RQE&CD)
:==========================================================================
FS090Q
	LHL	R5,TS0905,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS0905	HS	0
	HC	FSC030-F.CODE 	:RESET BETC STATE, ACTION = 3
	HC	FSC030-F.CODE 	:RESET INC STATE, ACTION = 3
	HC	FSD110-F.CODE 	:SENTSE BETC NOTCAN ,ACTION=>(S)
	HC	FSD110-F.CODE 	:SENTSE BETC CANCEL,ACTION = >(S)
	HC	FSC080-F.CODE 	:WAITSE BETC STATE, ACTION = 8
	HC	FSD1A0-F.CODE 	:WAITSE INC STATE,ACTION = 1(A3)
	HC	FSC080-F.CODE 	:WAITSE INC PRECHN, ACTION = 8
	HC	FSD110-F.CODE 	:SENTSE BETC NOTCAN,ACTION = >(S)
	HC	FSD110-F.CODE 	:SENTSE BETC CANCEL,ACTION = >(S)

:===================================================================
:	INPUT:	S, RQ, -CANCEL, EC, -(RQD|RQE&CD)
:===================================================================
FS090S
	CLHI	R7,FS.ST2		:RESET INC STATE?
	JL	FSC000,,		:NO, RESET BETC STATE, ACTION = -
	JE	FSC010,,		:YES, ACTION = 1
	J	FSD110,,		:OTHER STATES, ACTION = >(S)
	

	


	SUBTTL	FSM_CONTROL_HDX_RSP_SEND
:******************************************************************
:	FSM_CONTROL_HDX_RSP_SEND
:******************************************************************
:	FS1000	-(FSM_CONTROL_HDX_RSP_SEND) THE FUNCTION OF THIS FSM
:	IS TO PASS RESPONSES TO THE HALF DUPLEX MANAGER FSM (#FSM_HDX).
:	THE THE RESPONSES ARE PASSED TO FSM_HDX ONLY WHEN BETWEEN
:	CHAINS. I.E., #FSM_HDX NEVER GETS A RESPONSE WHEN IN THE
:	MIDDLE OF A CHAIN. ONLY NEGATIVE RESPONSES ARE PASSED. STATE
:	CHANGES ARE NOT NECESSARILY MADE BY #FSM_HDX ON ALL THE
:	NEGATIVE RESPONSES. POSITIVE RESPONSES ARE NOT PASSED TO 
:	#FSM_HDX BECAUSE STATE CHANGES ARE NEVER MADE ON THEM.NOTE
:	THAT THIS FSM MAY FOLLOW A DIRECT CALL TO #FSM_HDX AND THAT
:	THIS FSM MAY REINVOKE #FSM_HDX.
:	PAGE 5-78 IN FAPL
:	---------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED

FS1000
	FS.MC1(FSCHSN,FS.SCB)		:CHECK INPUTS
	STM	R0,FS.ASV,,		:SAVE ORIGINAL INPUT REGISTERS FOR
					:POSSIBLE A1 OR A2 ACTION CODES.
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS1002			:NO, GO CHECK OTHER INPUTS
	CLHI	R0,FS.RET		:SIGNAL = 'RESET'?
	JN	FS.CSG,,		:NO, OTHER SIGNALS INVALID

:=======================================================================
:	INPUT:	'RESET'
:=======================================================================
	J	FS0201,,		:GO GET STATE ENTRY ROUTINE

:	CHECK OTHER INPUTS
:--------------------------------------------
FS1002
	LR	R2,R2			:RECEIVE?
	JE	FS1006			:NO, SEND
	LR	R4,R4			:REQUEST OR RESPONSE?
	JN	FS.CRS,,		:RESPONSE
	LB	R5,BBUFER+MURHF1,R10,	:GET ECI BIT
	NHI	R5,MU.ECI		:END CHAIN INDICATOR SET?
	JN	FS1004			:EC INPUT

:====================================================================
:	INPUT:	R, RQ, -EC
:====================================================================
	J	FS0603,,		:GO GET STATE ENTRY ROUTINE

:====================================================================
:	INPUT:	R, RQ, EC
:====================================================================
FS1004
	LHL	R5,TS1003,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1003	HS	0
	HC	FSC000-F.CODE 	:RESET STATE, ACTION = -
	HC	FSC010-F.CODE 	:INC STATE, ACTION = 1
	HC	FSD0K0-F.CODE 	:RSP SENT STATE, ACTION = 1(A3)

:	CHECK SEND INPUT
:-----------------------------------
FS1006
	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS.CRQ,,		:REQUEST, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET RTI BIT
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JE	FS.CPS,,		:POSITIVE RESPONSE, CRASH
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR (6/22/84/CHS)
:	CLH	R5,SCBBLK+SCTPTR,R9,	:GET CT_PTR = REL CT_PTR? (6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JE	FS.CPT,,		:RETURN IF PTR EMPTY
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO CORRELATION TAB (9/7/84 MIA)
	LB	R2,BBUFER+CLARG5,R5,	:GET CT(BB) AND CT(EB) BITS
	NHI	R2,MU.BBI+MU.EBI	:MASK FOR JUST CT_BB & CT_EB
	CLHI	R2,MU.BBI+MU.EBI	:CT(BB&EB)?
	JE	FS.CCT,,		:YES, INVALID INPUT

:=====================================================================
:	INPUT:	S, -RSP,-(CT(BB) AND CT(EB))
:=====================================================================
FS1008
	LHL	R5,TS1004,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1004	HS	0
	HC	FSD0C0-F.CODE 	:RESET STATE, ACTION = -(A1)
	HC	FSD0G0-F.CODE 	:INC STATE, ACTION = 3(A2)
	HC	FSC000-F.CODE 	:RSP SENT STATE, ACTION = -



	SUBTTL	FSM_CONTROL_HDX_RSP_SEND_ERP_DL
:*********************************************************************
:	FSM_CONTROL_HDX_RSP_SEND_ERP_DL
:*********************************************************************
:	FS1100	-(FSM_CONTROL_HDX_RSP_SEND_ERP_DL) THE FUNCTION OF THIS
:	FSM IS TO IDENTIFY THE ERP SYNCHRONIZATION EVENT (THE RESPONSE
:	TO #FSM_HDX_FF AT THE END OF A PERIOD OF ACTIVITY SO THAT 
:	#FSM_HDX_FF WILL NOT HAVE TO CONTAIN NUMEROUS PENDING STATES
:	OR COMPLICATED CHECKING OF PENDING STATES IN OTHER FSMS.
:
:	THERE ARE THREE MAJOR STATES IN THIS FSM:
:	1. & 2. RESET
:	3. & 6. THE SYNC EVENT HAS BEEN RECEIVED BUT IT'S RESPONSE
:	HAS NOT BEEN SENT.
:	4. & 5. A NEGATIVE RESPONSE HAS BEEN SENT BUT THE SYNC EVENT
:	HAS NOT YET BEEN RECEIVED.
:
:	THIS FSM IS USED ONLY WHEN SYMMETRIC ERROR RECOVERY IS BEING
:	USED AND THE OTHER HALF-SESSION IS USING DELAYED REQUEST MODE.
:	PAGE 5-79 IN FAPL
:	-------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK),
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS1100
	FS.MC1(FSCHSD,FS.SCB)		:CHECK INPUTS
	STM	R0,FS.ASV,,		:SAVE ORIGINAL INPUT REGISTERS FOR
					:POSSIBLE A1 OR A2 ACTION CODES.
	LR	R0,R0			:SIGNAL PRESENT?
	JNFS	FS1102			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:===========================================================================
:	INPUT:	RESET
:===========================================================================
	J	FS0802,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:----------------------------------------------
FS1102
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE
	LR	R2,R2			:SEND OR RCV?
	JE	FS1108			:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH
	CLHI	R0,MU.DFC		:DFC RU?
	JN	FS1104			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,CHASE		:ACTION_CODE = CHASE?
	JN	FS1104			:NO, -CHASE

:============================================================================
:	INPUT:	R, RQ, CHASE
:============================================================================
	LHL	R5,TS1101,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1101	HS	0
	HC	FSC030-F.CODE 	:RESET BETC STATE, ACTION = 3
	HC	FSCIN-F.CODE 	:RESET INC STATE, ACTION = /
	HC	FSD120-F.CODE 	:RCVDSE BETC CHASE, ACTION = >(R)
	HC	FSC060-F.CODE 	:WAITSE BETC STATE, ACTION = 6
	HC	FSCIN-F.CODE 	:WAITSE INC STATE, ACTION = /
	HC	FSD120-F.CODE 	:RCVDS BETC CHASE STATE,ACTION=>(R)

:	CHECK FOR R, RQ, -CHASE INPUT
:-------------------------------------
FS1104
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.ECI		:END CHAIN INDICATOR SET?
	JN	FS1106			:YES, EC

:===========================================================================
:	INPUT:	R, RQ, -EC
:===========================================================================
	LHL	R5,TS1102,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1102	HS	0
	HC	FSC020-F.CODE 	:RESET BETC STATE,ACTION = 2
	HC	FSC000-F.CODE 	:RESET INC STATE, ACTION = -
	HC	FSD120-F.CODE 	:RCVDSE BETC CHASE, ACTION = >(R)
	HC	FSC050-F.CODE 	:WAITSE BETC STATE, ACTION = 5
	HC	FSC000-F.CODE 	:WAITSE INC STATE, ACTION = -
	HC	FSD120-F.CODE 	:RCVDSE BETC CHASE, ACTION = >(R)

:=====================================================================================
:	INPUT:	R, RQ, EC, -CHASE
:=============================================================================
FS1106
	LHL	R5,TS1103,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1103	HS	0
	HC	FSC000-F.CODE 	:RESET BETC STATE, ACTION = -
	HC	FSC010-F.CODE 	:RESET INC STATE, ACTION = 1
	HC	FSD120-F.CODE 	:RCVDSE BETC CHASE, ACTION = >(R)
	HC	FSC000-F.CODE 	:WAITSE BETC STATE, ACTION = -
	HC	FSC040-F.CODE 	:WAITSE INC STATE, ACTION = 4
	HC	FSD120-F.CODE 	:RCVDSE BETC CHASE STATE,ACTION=>(R)

:	CHECK FOR SEND INPUT
:----------------------------
FS1108
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	CLHI	R0,MU.DFC		:DFC RU?
	JNFS	FS110A			:NO, DON'T CHECK ACTION_CODE
	CLHI	R5,CHASE		:ACTION_CODE = CHASE?
	JE	FS110C			:YES
FS110A
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?

:==========================================================================
:	INPUT:	S, +RSP, -CHASE
:==========================================================================
	JE	FSC000,,		:POSITIVE, ACTION = -

:	CHECK FOR S, -RSP, -CHASE INPUT
:---------------------------------------------
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_TABLE POINTER
:	CLH	R5,SCBBLK+SCTPTR,R9,	:GET CT_PTR = REL CT_PTR? (6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JE	FS.CPT,,		:RETURN IF PTR EMPTY
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO TABLE (9/7/84 MIA)
:	LHL	R2,BBUFER+CLARG5,R5,	:GET CT_BB AND CT_EB BITS(08/09/85/CHS)
	LB	R2,BBUFER+CLARG5,R5,	:GET CT_BB AND CT_EB BITS(08/09/85/CHS)
	NHI	R2,MU.BBI+MU.EBI	:MASK FOR JUST CT_BB & CT_EB BITS
	CLHI	R2,MU.EBI+MU.BBI	:CT(BB&EB)?
	JE	FS.CCT,,		:YES, INVALID INPUT

:========================================================================
:	INPUT:	S, -RSP, -CHASE, -(CT(BB)&CT(EB))
:========================================================================
	LHL	R5,TS1104,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1104	HS	0
	HC	FSD1B0-F.CODE 	:RESET BETC STATE, ACTION = 4(A2)
	HC	FSD1C0-F.CODE 	:RESET INC STATE, ACTION = 5(A2)
	HC	FSD1D0-F.CODE 	:RCVDSE BETC CHASE STATE, ACTION= 6(A2)
	HC	FSC000-F.CODE 	:WAITSE BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC STATE, ACTION = -
	HC	FSC000-F.CODE 	:RCVDSE BETC CHASE STATE, ACTION = -

:	CHECK FOR S, RSP, CHASE INPUT
:-------------------------------------

FS110C
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS110E			:NEGATIVE, -RSP

:==========================================================================
:	INPUT:	S, +RSP, CHASE
:==========================================================================
	LHL	R5,TS1105,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1105	HS	0
	HC	FSC000-F.CODE 	:RESET BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:RESET INC STATE, ACTION = -
	HC	FSC010-F.CODE 	:RCVDSE BETC CHASE STATE, ACTION = 1
	HC	FSC000-F.CODE 	:WAITSE BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC STATE, ACTION = -
	HC	FSD1T0-F.CODE 	:RCVDSE BETC CHASE STATE, ACTION= 1(A3)

:=========================================================================
:	INPUT:	S, -RSP, CHASE
:=========================================================================
FS110E
	LHL	R5,TS1106,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1106	HS	0
	HC	FSC000-F.CODE 	:RESET BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:RESET INC STATE, ACTION = -
	HC	FSD130-F.CODE 	:RCVDSE BETC CHASE STATE, ACTION=1(A1)
	HC	FSC000-F.CODE 	:WAITSE BETC STATE, ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC STATE, ACTION = -
	HC	FSD1T0-F.CODE 	:RCVDSE BETC CHASE, ACTION = 1(A3)


	SUBTTL	FSM_CONTROL_HDX_RSP_SEND_ERP_IM
:******************************************************************************
:	FSM_CONTROL_HDX_RSP_SEND_ERP_IM
:*****************************************************************************
:	FS1200	-(FSM_CONTROL_HDX_RSP_SEND_ERP_IM) THE FUNCTION OF THIS FSM
:	IS TO IDENTIFY THE SYNCHRONIZATION EVENT (SYNC EVENT RESPONSES TO
:	RQD OR RQE WITH CD) THAT MARKS THE POINT AT WHICH THE HDX FSM IS TO
:	MAKE IT'S ERP TRANSITION. WHEN THAT EVENT OCCURS THIS FSM CALLS
:	FSM_HDX_FF TO CAUSE THE ERP TRANSITION. THE BASIC IDEA IS TO SEND
:	ALL RESPONSES TO FSM_HDX_FF AT THE END OF A PERIOD OF ACTIVITY SO
:	THAT FSM_HDX_FF WILL NOT HAVE TO CONTAIN NUMEROUS PENDING STATES
:	OR COMPLICATED CHECKING OF PENDING STATES IN OTHER FSMS.
:
:	THERE ARE THREE MAJOR STATES IN THIS FSM:
:	1. & 2. RESET
:	3., 4., 8. & 9. THE SYNC EVENT REQUEST HAS BEEN RECEIVED BUT THE
:	RESPONSE TO IT HAS NOT YET BEEN SENT. THIS RESPONSE MAY BE
:	POSITIVE OR NEGATIVE. IF THE SYNC EVENT REQUEST WAS RQE WITH CD 
:	THEN IT WILL BE A NEGATIVE RESPONSE.
:	5., 6. & 7. A NEGATIVE RESPONSE HAS BEEN SENT BUT THE SYNC EVENT
:	REQUEST HAS NOT YET BEEN RECEIVED.
:
:	THIS FSM IS USED ONLY WHEN SYMMETRIC ERROR RECOVERY IS BEING
:	USED AND THE OTHER HALF-SESSION IS USING IMMEDIATE REQUEST MODE.
:	PAGE 5-80 IN FAPL
:	----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUTS:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR
:			RSP), R9 (SCB ENTRY), R10 (MU PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS1200
	FS.MC1(FSCHSI,FS.SCB)		:CHECK INPUTS
	STM	R0,FS.ASV,,		:SAVE ORIGINAL REGISTERS FOR
					:POSSIBLE A1 OR A2 ACTION CODES.
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS1202			:NO
	CLHI	R0,FS.RET		:SIGNAL=RESET?
	JN	FS.CSG,,		:NO, CRASH

:=======================================================================
:	INPUT:	'RESET'
:=======================================================================
	J	FS0902,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:-------------------------------------------
FS1202
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER,R5,		:GET ACTION_CODE
	LR	R2,R2			:SEND OR RCV?
	JE	FS120A			:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP
	LB	R2,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R2,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R2,MU.DFC		:DFC RU?
	JN	FS1204			:NO, DON'T CHECK ACTION_CODE
	CLHI	R0,CANCEL		:ACTION_CODE=CANCEL?
	JN	FS1204			:NO, -CANCEL

:===================================================================
:	INPUT:	R, RQ, CANCEL
:===================================================================
	LHL	R5,TS1201,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1201	HS	
	HC	FSCIN-F.CODE 	:RESET BETC STATE,ACTION = /
	HC	FSC040-F.CODE 	:RESET INC STATE, ACTION = 4
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN,ACTION=>(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION=>(R)
	HC	FSCIN-F.CODE 	:WAITSE BETC,ACTION=/
	HC	FSC090-F.CODE 	:WAITSE INC CURCHN,ACTION= 9
	HC	FSC090-F.CODE 	:WAITSE INC PRECHN,ACTION= 9
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN, ACTION=>(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION=>(R)

:	CHECK FOR R, RQ, -CANCEL INPUT
:------------------------------------------
FS1204
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.ECI		:END CHAIN INDICATOR SET?
	JN	FS1204			:YES, EC

:==================================================================
:	INPUT:	R, RQ, -CANCEL, -EC
:==================================================================
	LHL	R5,TS1202,R7,R7		:GO GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1202	HS	0
	HC	FSC020-F.CODE 	:RESET BETC STATE,ACTION = 2
	HC	FSC000-F.CODE 	:RESET INC STATE,ACTION = -
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN,ACTION=>(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION = >(R)
	HC	FSC070-F.CODE 	:WAITSE BETC, ACTION = 7
	HC	FSC000-F.CODE 	:WAITSE INC , ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC PRECHN,ACTION = -
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN,ACTION=>(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION=>(R)

:	CHECK FOR R, RQ, -CANCEL, EC INPUT
:-------------------------------------------
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.ERI+MU.DR1I+MU.DR2I	:MASK FOR RQD BITS
:RQD= -ERI(DR1I|DR2I)  /*DEFINITE RESPONSE REQUEST MODE
:RQN= -(ERI|DR1I|DR2I) /*NO RESPONSE REQUEST MODE
:RQE=  ERI	       /*EXCEPTION RESPONSE REQUEST MODE
	JE	FS1208			:RQN, -(RQD|(RQE&CD))
	NHI	R0,MU.ERI		:RQE?
	JN	FS1206			:YES, DO RQE&CD CHECK

:==================================================================
:	INPUT:	R, RQ, -CANCEL, EC, RQD
:==================================================================
	LHL	R5,TS1203,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1203	HS	0
	HC	FSC030-F.CODE 	:RESET BETC STATE,ACTION = 3
	HC	FSC030-F.CODE 	:RESET INC STATE,ACTION = 3
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN,ACTION=>(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION=>(R)
	HC	FSC080-F.CODE 	:WAITSE BETC STATE, ACTION = 8
	HC	FSD1T0-F.CODE 	:WAITSE INC CURCHN,ACTION= 1(A3)
	HC	FSC080-F.CODE 	:WAITSE INC PRECHN,ACTION= 8
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN,ACTION=>(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION = >(R)

:	CHECK FOR R, RQ, -CANCEL, EC, RQE INPUT
:-----------------------------------------------
FS1206
	LB	R0,BBUFER+MURHF3,R10,	:GET THIRD BYTE OF RH
	NHI	R0,MU.CDI		:CHANGE DIRECTION INDICATOR SET?
	JE	FS1208			:NO, -CD

:=================================================================
:	INPUT:	R, RQ, -CANCEL, EC, RQE, CD
:=================================================================
	LHL	R5,TS1204,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1204	HS	0
	HC	FSC030-F.CODE 	:RESET BETC STATE, ACTION = 3
	HC	FSC030-F.CODE 	:RESET INC STATE, ACTION = 3
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN,ACTION=>(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION =>(R)
	HC	FSD1H0-F.CODE 	:WAITSE BETC STATE,ACTION = 8(E)
	HC	FSD1T0-F.CODE 	:WAITSE INC CURCHN,ACTION=1(A3)
	HC	FSD1H0-F.CODE 	:WAITSE INC PRECHN,ACTION = 8(E)
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN,ACTION=>(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION=>(R)

:=======================================================================
:	INPUT:	R, RQ, -CANCEL, EC, -(RQD|(RQE&CD))
:=======================================================================
FS1208
	LHL	R5,TS1205,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1205	HS	0
	HC	FSC000-F.CODE 	:RESET BETC STATE,ACTION = -
	HC	FSC010-F.CODE 	:RESET INC STATE,ACTION = 1
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN,ACTION = >(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION=>(R)
	HC	FSC000-F.CODE 	:WAITSE BETC STATE,ACTION= -
	HC	FSC050-F.CODE 	:WAITSE INC CURCHN,ACTION = 5
	HC	FSC050-F.CODE 	:WAITSE INC PRECHN,ACTION = 5
	HC	FSD120-F.CODE 	:RCVDSE BETC NOTCAN,ACTION =>(R)
	HC	FSD120-F.CODE 	:RCVDSE BETC CANCEL,ACTION = >(R)

:	CHECK FOR SEND INPUT
:-----------------------------
FS120A
	LR	R4,R4			:RQ OR RSP?
	JN	FS120C			:RSP

:==============================================================
:	INPUT:	S, RQ
:==============================================================
	LHL	R5,TS1206,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1206	HS	0
	HC	FSC000-F.CODE 	:RESET BETC STATE,ACTION = -
	HC	FSCIN-F.CODE 	:RESET INC STATE,ACTION = /
	HC	FSC010-F.CODE 	:RCVDSE BETC NOTCAN,ACTION = 1
	HC	FSD110-F.CODE 	:RCVDSE BETC CANCEL,ACTION = >(S)
	HC	FSCIN-F.CODE 	:WAITSE BETC STATE,ACTION = /
	HC	FSCIN-F.CODE 	:WAITSE INC CURCHN,ACTION = /
	HC	FSCIN-F.CODE 	:WAITSE INC PRECHN,ACTION = /
	HC	FSD110-F.CODE 	:RCVDSE BETC NOTCAN,ACTION = >(S)
	HC	FSD110-F.CODE 	:RCVDSE BETC CANCEL,ACTION = >(S)

:	CHECK FOR S, RSP INPUT
:--------------------------------
FS120C
	LB	R4,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R4,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS120G			:-RSP
	CLHI	R4,MU.DFC		:DFC RU?
	JN	FS120E			:NO, DON'T CHECK ACTION_CODE
	CLHI	R0,CANCEL		:ACTION_CODE = CANCEL?
	JN	FS120E			:NO, -CANCEL

:========================================================================
:	INPUT:	S, +RSP, CANCEL
:========================================================================
	CLHI	R7,FS.ST4		:YES, RCVDSE BETC CANCEL STATE?
	JE	FSC010,,		:YES, ACTION = 1
	CLHI	R7,FS.ST9		:NO, RCVDSE BETC CANCEL -RSP SENT?
	JE	FSD1T0,,		:YES, ACTION = 1(A3)
	J	FSC000,,		:ALL OTHER STATES, ACTION = -

:	CHECK FOR S, +RSP, -CANCEL INPUT
:---------------------------------------
FS120E
	JAL	R4,FS05D0,,		:TO_CURRENT_CHAIN?
	J	FS.CUR,,		:NO, CRASH

:=================================================================
:	INPUT:	S, +RSP, -CANCEL, TO_CURRENT_CHAIN
:=================================================================
	CLHI	R7,FS.ST3		:RCVDSE BETC NOTCAN STATE?
	JE	FSC010,,		:YES, ACTION= 1
	CLHI	R7,FS.ST8		:RCVDSE BETC NOTCAN -RSP SENT?
	JE	FSD1T0,,		:YES, ACTION = 1(A3)
	J	FSC000,,		:ALL OTHER STATES,ACTION = -

:	CHECK FOR S, -RSP INPUT
:-------------------------------------
FS120G
	CLHI	R4,MU.DFC		:DFC RU?
	JNFS	FS120H			:NO, DON'T CHECK ACTION_CODE
	CLHI	R0,CANCEL		:CANCEL?
	JE	FS120J			:YES
FS120H
:	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR (6/22/84/CHS)
:	CLH	R5,SCBBLK+SCTPTR,R9,	:GET CT_PTR = REL CT_PTR? (6/22/84/CHS)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JE	FS.CPT,,		:YES, EMPTY PTR. INVALID INPUT
	BBLOAD	R5,CMDBLK+CLARG,R5,	:POINT TO CORRELATION TAB (9/7/84 MIA)
	LB	R0,BBUFER+CLARG5,R5,	:GET CT(BB&EB) INDICATORS
	NHI	R0,MU.BBI+MU.EBI	:GET JUST BBI AND EBI
	CLHI	R0,MU.BBI+MU.EBI	:CT(BB&EB)?
	JE	FS.CCT,,		:YES, CRASH
	JAL	R4,FS05D0,,		:NO, TO_CURRENT_CHAIN?
	J	FS120I,,		:-TO_CURRENT_CHAIN

:===============================================================
:	INPUT:	S, -RSP, -CANCEL, TO_CURRENT_CHAIN, -CT(BB&EB)
:===============================================================
	LHL	R5,TS1207,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1207	HS	0
	HC	FSD1C0-F.CODE 	:RESET BETC STATE,ACTION=5(A2)
	HC	FSD1D0-F.CODE 	:RESET INC STATE,ACTION = 6(A2)
	HC	FSD130-F.CODE 	:RCVDSE BETC NOTCAN,ACTION = 1(A1)
	HC	FSD1G0-F.CODE 	:RCVDSE BETC CANCEL,ACTION = 9(A2)
	HC	FSC000-F.CODE 	:WAITSE BETC STATE,ACTION= -
	HC	FSC000-F.CODE 	:WAITSE INC CURCHN,ACTION = -
	HC	FSC060-F.CODE 	:WAITSE INC PRECHN,ACTION = 6
	HC	FSD1T0-F.CODE 	:RCVDSE BETC NOTCAN,ACTION = 1(A3)
	HC	FSC000-F.CODE 	:RCVDSE BETC CANCEL,ACTION = -

:=====================================================================
:	INPUT:	S, -RSP, -CANCEL, -TO_CURRENT_CHAIN, -CT(BB&EB)
:=====================================================================
FS120I
	LHL	R5,TS1208,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS1208	HS	0
	HC	FSD1C0-F.CODE 	:RESET BETC STATE,ACTION = 5(A2)
	HC	FSD1E0-F.CODE 	:RESET INC STATE,ACTION= 7(A2)
	HC	FSD1F0-F.CODE 	:RCVDSE BETC NOTCAN,ACTION = 8(A2)
	HC	FSD1G0-F.CODE 	:RCVDSE BETC CANCEL, ACTION = 9(A2)
	HC	FSC000-F.CODE 	:WAITSE BETC,ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC CURCHN,ACTION = -
	HC	FSC000-F.CODE 	:WAITSE INC PRECHN,ACTION = -
	HC	FSC000-F.CODE 	:RCVDSE BETC NOTCAN,ACTION = -
	HC	FSC000-F.CODE 	:RCVDSE BETC CANCEL,ACTION = -

:======================================================================
:	INPUT:	S, -RSP, CANCEL
:======================================================================
FS120J
	CLHI	R7,FS.ST4		:RCVDSE BETC BETC CANCEL STATE?
	JE	FSD130,,		:YES, ACTION = 1(A1)
	CLHI	R7,FS.ST9		:RCVDSE BETC CANCEL -RSP SEND?
	JE	FSD1T0,,		:YES, ACTION = 1(A3)
	J	FSC000,,		:ALL OTHER STATES, ACTION = -
	
	

	SUBTTL	FSM_DT_SEND_SDT_AND_CLEAR

:***************************************************************
:	FSM_HDX_CONT_LOSER
:***************************************************************
:	FS2300	-(FSM_HDX_CONT_LOSER) TO ENFORCE THE HALF_DUPLEX CPNTENTION
:	SEND/RECEIVE MODE PROTOCOL FOR THE CONTENTION LOSER.
:	THE STATES ARE:
:	0.RESET
:	1.CONT (CONTENTION STATE) - A CHAIN IS NOT IN THE PROCESS OF BEING
:	  SENT OR RECEIVED.
:	2.SEND (SEND STATE) - A CHAIN IS CURRENTLY IN THE PROCESS OF BEING
:	  SENT BY THE CONTENTION LOSER.
:	3.RCV (RECEIVE STATE) - A CHAIN IS CURRENTLY IN THE PROCESS OF
:	  BEING RECEIVED FROM THE CONTENTION WINNER.
:	PAGE 5-82 ON FAPL
:	-------------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:R9 (SCB ENTRY) R10 (MU PTR) R0 (FSM INPUT SIGNAL,OPTION)
:		 R1 (INDEX FOR FSM STATE INF. IN SCB) R2 (MU.DIRECTION)
:		 R4 (RQ OR RSP) , R7 (FSM STATE VALUE), R6 (FUNCTION OR 
:		 CALL)
:	OUTPUT	:R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK),
:		:R8 THRU R15 ARE UNCHANGED
:	LINK	:R3
:	WORKING	:R4,R5,R6,R7,R2,R0,R1 ARE DESTROYED
FS2300
	FS.MC1(FSCHCL,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS2304			:NO
	CLHI	R0,FS.REC		:SIGNAL = RESET_CONT?
	JEFS	FS2302			:YES
	CLHI	R0,FS.BEB		:SIGNAL = BETB?
	JN	FS.CSG,,		:NO, CRASH

:==========================================================================
:	INPUT:	'BETB' OR 'RESET_CONT'
:==========================================================================
FS2302
	J	FS0201			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR OTHER INPUTS
:------------------------------
FS2304
	LR	R4,R4			:RQ OR RSP?
	JN	FS2306			:RSP
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	LR	R2,R2			:SEND OR RCV?
	JN	FS230A			:RCV
	NHI	R0,MU.ECI		:POSITIVE OR NEGATIVE RESPONSE?

:=============================================================================
:	INPUT:	S, RQ, -EC
:========================================================================================
	JE	FS2408,,		:POSITIVE, GO GET STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, EC INPUT
:-------------------------------------
	LB	R0,BBUFER+MURHF3,R10,	:GET BYTE 3 OF RH
	NHI	R0,MU.CDI		:CHANGE DIRECTION INDICATORE SET?
	
:=======================================================================
:	INPUT:	S, RQ, EC, CD
:=======================================================================
	JN	FS2405,,		:YES, GO GET STATE ENTRY ROUTINE

:========================================================================
:	INPUT:	S, RQ, EC, -CD
:=========================================================================
	J	FS2406,,		:NO, GO GET STATE ENTRY ROUTINE

:	CHECK FOR RSP INPUT
:------------------------------
FS2306
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JE	FS.CPS,,		:POSITIVE, CRASH
	LHL	R0,BBUFER+MURHSN,R10,	:GET SNC
	CLHI	R0,.RRBRE		:080B?
	JE	FS.CSC,,		:YES, CRASH
	CLHI	R0,.RRBJN		:0813?
	JE	FS.CSC,,		:YES, CRASH
	CLHI	R0,.RRBJF		:0814?
	JE	FS.CSC,,		:YES, CRASH
	CLHI	R0,.RRRTM		:081B?
	JE	FS.CSC,,		:YES, CRASH
	LR	R2,R2			:SEND OR RCV?
	JNFS	FS2308			:RCV

:=========================================================================
:	INPUT:	S, -RSP, -(080B,0813,0814,081B)
:=========================================================================
	CLHI	R7,FS.ST1		:S,R CONT STATE?
	JE	FSD0U0,,		:YES, ACTION = 2, -
	J	FSC000,,		:NO, ACTION = -

:=========================================================================
:	INPUT:	R, -RSP, -(080B,0813,0814,081B)
:=========================================================================
FS2308
	CLHI	R7,FS.ST3		:-S,R RCV STATE?
	JE	FSC010,,		:YES, ACTION = 1
	J	FSC000,,		:NO, ACTION = -

:	CHECK R, RQ INPUT
:-------------------------
FS230A
	NHI	R0,MU.ECI		:END OF CHAIN INDICATOR SET?
	JE	FS230C			:NO, -EC

:============================================================================
:	INPUT:	R, RQ, EC
:============================================================================
	LHL	R5,TS2301,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2301	HS	0
	HC	FSC000-F.CODE 	:S, R CONT STATE, ACTION = -
	HC	FSCIN-F.CODE 	:S, -R SEND STATE, ACTION = /
	HC	FSC010-F.CODE 	:-2, R RCV STATE, ACTION = 1

:===========================================================================
:	INPUT:	R, RQ, -EC
:===========================================================================
FS230C
	LHL	R5,TS2302,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2302	HS	0
	HC	FSC030-F.CODE 	:S, R CONT STATE, ACTION = 3
	HC	FSCIN-F.CODE 	:S, -R SEND STATE, ACTION = /
	HC	FSC000-F.CODE 	:-S, R RCV STATE, ACTION = -


	SUBTTL	FSM_HDX_CONT_WINNER
:*********************************************************************************
:	FSM_HDX_CONT_WINNER
:*****************************************************************************
:	STATE DEFINITION FOR THIS FSM
:===============================================================================
:	FS2400	-(FSM_HDX_CONT_WINNER) TO ENFORCE THE HALF-DUPLEX CONTENTION
:	SEND/RECEIVE MODE PROTOCOL FOR THE CONTENTION WINNER.
:	THE STATES ARE:
:	0.RESET
:	1.CONT (CONTENTION STATE) -  CHAIN IS NOT IN THE PROCESS OF BEING
:	  SENT OR RECEIVED. 
:	2.SEND (SEND STATE) - A CHAIN IS CURRENTLY IN THE PROCESS OF BEING 
:	  SENT BY THE CONTENTION WINNER. 
:	3.RCV (RECEIVE STATE) - A CHAIN IS CURRENTLY IN THE PROCESS OF BEING
:	  RECEIVED FROM THE CONTENTION LOSER.
:	PAGE 5-83 IN FAPL
:---------------------------------------------------------------------------
:	REGISTER USAGE:
:	INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM STATE INFO.
:		IN SCB), R2 (MU.DIRECTION), R4 (RQ OR RSP), R9 (SCB ENTRY),
:		R10 (MU PTR), R7 (FSM STATE VALUE), R6 (FUNCTION OR CALL)
:	OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:		R8 THRU R15 ARE UNCHANGED
:	LINK:	R3
:	WORKING:R4, R5, R6, R7, R2, R0, R1 ARE DISTROYED
FS2400
	FS.MC1(FSCHCW,FS.SCB)		:CHECK INPUTS

:	CHECK FSM INPUT SIGNAL FIRST
:	----------------------
	LR	R0,R0			:IS INPUT SIGNAL PRESENT?
	JE	FS2404			:NO
	CLHI	R0,FS.BEB		:IS IT 'BETB'?
	JE	FS2402			:YES	
	CLHI	R0,FS.REC		:IS IT 'RESET_CONT'?
	JN	FS.CSG,,		:NO, CRASH

:========================================================================
:	INPUT SIGNAL ---- BETB, OR RESET_CONT
:========================================================================
FS2402
	J	FS0201,,		:YES, GO GET STATE ENTRY ROUTINE

:	CHECK FOR INPUTS OTHER THAN INPUT SIGNAL
:	----------------------------------------
FS2404
	LR	R2,R2			:CHECK MUCB.DIRECTION
	JN	FS240A			:JUMP IF IT'S RECEIVE
	LR	R4,R4			:CHECK MU RRI
	JN	FS.CRS,,		:RSP, CRASH
	LB	R2,BBUFER+MURHF1,R10,	:GET MURHF1 FOR ECI
	NHI	R2,MU.ECI		:MASK FOR ECI BIT
	JE	FS2408			:JUMP IF -EC
	LB	R2,BBUFER+MURHF3,R10,	:GET MURHF3 FOR CDI
	NHI	R2,MU.CDI		:MASK FOR CDI
	JE	FS2406			:JUMP IF -CD

:====================================================================
:	INPUT: S, RQ, EC, CD
:====================================================================
FS2405
	CLHI	R7,FS.ST3		:RECEIVE STATE?
	JE	FSD070,,		:YES, ACTION = >(S)
	J	FSC030,,		:NO, ALL OTHER STATES, ACTION = 3

:==================================================================
:	INPUT: S, RQ, EC, -CD
:==================================================================
FS2406
	LHL	R5,TS2402,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS2402	HS	0
	HC	FSC000-F.CODE 	:CONT STATE,	ACTION = -
	HC	FSC010-F.CODE 	:SEND STATE,	ACTION = 1
	HC	FSD070-F.CODE 	:RECEIVE STATE,	ACTION = >(S)

:===================================================================
:	INPUT:	S,RQ,-EC	
:===================================================================
FS2408
	LHL	R5,TS2403,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS2403	HS	0
	HC	FSC020-F.CODE 	:CONT STATE, 	ACTION = 2
	HC	FSC000-F.CODE 	:SEND STATE,	ACTION = -
	HC	FSD070-F.CODE 	:RECEIVE STATE,	ACTION = >(S)

:	CHECKING FOR RECEIVE INPUT
:---------------------------------------------------
FS240A
	LR	R4,R4			:CHECK IF RSP OR RQST?
	JE	FS240C			:JUMP IF REQUEST
	LB	R2,BBUFER+MURHF2,R10,	:GET MURHF2 FOR RTI
	NHI	R2,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JE	FS.CPS,,		:+RSP, CRASH
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE DATA (SNC)
	CLHI	R0,.RRBRE		:IS IT BRACKET RACE CONDITION?
	JE	FS.CSC,,		:RACE, CRASH
	CLHI	R0,.RRBJN		:IS IT BRACKET BID REJECT,NO RTR?
	JE	FS.CSC,,		:YES, CRASH
	CLHI	R0,.RRBJF		:IS IT BRACKET REJECT,RTR, ERROR?
	JE	FS.CSC,,		:YES, CRASH
	CLHI	R0,.RRRTM		:IS IT RECEIVER IN XMT MODE?
	JE	FS.CSC,,		:YES, CRASH
	CLHI	R0,.RREMF		:IS IT ERP MSG FORTHCOMING?
	JE	FS.CSC,,		:YES, CRASH

:====================================================================
:	INPUT:	R, -RSP, -(080B|0813|0814|081B|0846)
:====================================================================
	CLHI	R7,FS.ST1		:CONT STATE?
	JE	FSD0L0,,		:YES, ACTION = 3,-
	J	FSC000,,		:NO, ALL OTHER STATES, ACTION = -

:	CHECK IF THIS REQUEST WAS EC OR -EC
:-------------------------------------------------------------------------
FS240C	
	LB	R2,BBUFER+MURHF1,R10,	:GET MURHF1 FOR ECI
	NHI	R2,MU.ECI		:MASK ECI BIT
	JE	FS240E			:JUMP IF -EC

:========================================================================
:	INPUT:	R, RQ, EC
:========================================================================
	LHL	R5,TS2405,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS2405	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSD0S0-F.CODE 	:SEND STATE, ACTION = -(C)
	HC	FSC010-F.CODE 	:RECEIVE STATE, ACTION = 1

:=======================================================================
:	INPUT:	R,RQ,-EC	
:=======================================================================
FS240E
	LHL	R5,TS2406,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS2406	HS	0
	HC	FSC030-F.CODE 	:CONT STATE,	ACTION = 3
	HC	FSD0S0-F.CODE 	:SEND STATE,	ACTION = -(C)
	HC	FSC000-F.CODE 	:RECEIVE STATE,	ACTION = -


	SUBTTL	FSM_HDX_FF
:***********************************************************************
:	FSM_HDX_FF
:***********************************************************************
:	STATE DEFINITION FOR THIS FSM
:=======================================================================
:	FS2500	-(FSM_HDX_FF) TO ENFORCE THE HALF-DUPLEX FLIP-FLOP
:	PROTOCOL (WITH AND WITHOUT BRACKETS).
:	THE STATES ARE:
:
:	0.RESET
:
:	STATES 1 THRU 3 APPLY ONLY TO HDX-FF WITH BRACKETS WHEN THE BRACKET
:	FSM IS IN BETWEEN BRACKETS STATE.
:	1.CONT (CONTENTION STATE) - THIS STATE IS USED WHEN CHAIN IS NOT
:	  IN PROCESS OF BEING SENT OR RECEIVED.
:	2.CONT SEND (CONTENTION SEND STATE) - THIS STATE IS USED WHEN A
:	  CHAIN IS IN PROCESS OF BEING SENT.
:	3.CONT RCV (CONTENTION RECEIVE STATE) - THIS STATE IS USED WHEN
:	  A CHAIN IS IN PROCESS OF BEING RECEIVED.
:	
:	STATES 4 THRU 8 MAY BE USED BY HDX-FF WITH/WITHOUT BRACKETS. FOR
:	WITH BRACKETS, THESE STATES ARE ONLY USED WHEN THE BRACKET FSM
:	IS IN IN-BRACKET STATE.
:	4.SEND (SEND STATE) - IN THIS STATE NORMAL FLOW REQUESTS MAY BE
:	  SENT.
:	5.RCV (RECEIVE STATE) - IN THIS STATE NORMAL FLOW REQUESTS MAY BE
:	  RECEIVED.
:	6.RCV 081B (RECEIVE 081B SENSE CODE STATE) - THIS STATE IS ENTERED
:	  AFTER A NEGATIVE RESPONSE IS RECEIVED WITH SENSE CODE 081B. IN
:	  THIS STATE ONLY REQUESTS ARE ALLOWED TO BE RECEIVED.
:	7.ERPS (ERROR RECOVERY STATE) - THIS STATE IS USED WHEN AN ERROR
:	  OCCURS AND DEPENDS ON TYPE OF ERROR RECOVERY IN USE. ALLOWS 
:	  RECEIVING OF LUSTAT AND SENDING OF NORMAL-FLOW REQUESTS.
:	8.ERPR (ERROR RECOVERY STATE) - THIS IS ALSO USED WHEN AN ERROR
:	  OCCURS AND DEPENDS ON TYPE OF ERROR RECOVERY IN USE. ALLOWS
:	  SENDING OF LUSTAT AND RECEIVING OF NORMAL-FLOW REQUESTS.
:	PAGE 5-84 IN FAPL
:-------------------------------------------------------------------------
:	REGISTER USAGE:
:	INPUT:	R0 (FSM INPUT SIGAL, OPTION), R1 (INDEX FOR FSM STATE INFO.
:		IN SCB), R2 (MU.DIRECTION), R4 (RQ OR RSP), R9 (SCB ENTRY),
:		R10 (MUPTR), R7 (FSM STATE VALUE), R6 (FUNCTION OR CALL)
:	OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:		R8 THRU R15 ARE UNCHANGED
:	LINK:	R3
:	WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED

FS2500
	FS.MC1(FSCHFF,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:IS INPUT SIGNAL PRESENT?
	JE	FS2507			:NO 
	CLHI	R0,FS.IBS		:IS IT INB_SEND?
	JE	FS2502			:YES
	CLHI	R0,FS.IBR		:IS IT INB_RCV?
	JE	FS2503			:YES
	CLHI	R0,FS.REC		:IS IT RESET_CONT?
	JE	FS2504			:YES
	CLHI	R0,FS.RES		:IS IT RESET_SEND?
	JE	FS2505			:YES
	CLHI	R0,FS.RER		:IS IT RESET_RCV?
	JE	FS2505			:YES
	CLHI	R0,FS.BEB		:IS IT 'BETB'?
	JN	FS.CSG,,		:NO, ALL OTHER SIGNALS ARE INVALID

:=======================================================================
:	INPUT SIGNAL:	BETB
:=======================================================================
	CLHI	R7,FS.ST4		:SEND STATE?
	JL	FSC000,,		:NO, PREVIOUS STATES, ACTION = -
	J	FSC010,,		:ALL OTHER STATES, ACTION = 1

:=======================================================================
:	INPUT SIGNAL:	INB_SEND
:===========================================================================
FS2502
	CLHI	R7,FS.ST4		:SEND STATE?
	JL	FSC040,,		:NO, PREVIOUS STATES, ACTION = 4
	J	FSC000,,		:ALL OTHER STATES, ACTION = -

:============================================================================
:	INPUT SIGNAL:	INB_RCV
:============================================================================
FS2503
	CLHI	R7,FS.ST4		:SEND STATE?
	JL	FSC050,,		:NO, PREVIOUS STATE, ACTION = 5
	J	FSC000,,		:ALL OTHER STATES, ACTION = -

:==========================================================================
:	INPUT SIGNAL:	RESET_CONT
:==========================================================================
FS2504
	CLHI	R7,FS.ST1		:CONT STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC010,,		:ALL OTHER STATES, ACTION = 1

:======================================================================
:	INPUT SIGNAL: RESET_SEND
:=======================================================================
FS2505
	CLHI	R7,FS.ST4		:SEND STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC040,,		:NO, ALL OTHER STATES, ACTION = 4

:===========================================================================
:	INPUT SIGNAL:	RESET_RCV
:========================================================================
FS2506
	CLHI	R7,FS.ST5		:RECEIVE STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSC050,,		:NO, ALL OTHER STATES, ACTION = 5

:	CHECK INPUTS OTHER THAN SIGNAL INPUTS
:------------------------------------------------------------------------
FS2507
	LB	R0,SCBBLK+SCACFG,R9,	:GET PRI/SEC HALF SESSION INDICATORS
	LB	R5,SCBBLK+SCSRMD,R9,	:GET CONTENTION WINNER INDICATOR
	NHI	R5,SC.CWN		:PRIMARY = CONTENTION WINNER?
	JE	FS2530			:NO, SECONDARY IS CONTENTION WINNER
:SECONDARY= CONTENTION LOSER, PRIMARY = CONTENTION WINNER
	LIS	R5,0			:ASSUME NOT_RECOVERER
	NHI	R0,SC.SES		:PRIMARY HALF SESSION?
	JN	FS2532			:YES, NOT_RECOVERER (FS.RCV=0)
	J	FS2531			:NO, RECOVERER (FS.RCV=1)
:SECONDARY= CONTENTION WINNER, PRIMARY = CONTENTION LOSER
FS2530
	NHI	R0,SC.SES		:PRIMARY HALF SESSION?
	JE	FS2532			:NO, NOT_RECOVERER (FS.RCV=0)
:CONTENTION LOSER IS RECOVERER
FS2531
	LIS	R5,1			:RECOVERER (FS.RCV=1)
:CONTENTION WINNER - NOT RESPONSIBLE FOR RECOVERY (NOT_RECOVERER)
FS2532
	STB	R5,FS.RCV,,		:STORE RECOVERER INDICATOR

	LIS	R0,0			:R0=0 FOR FMD RU'S OR R0=1
					:FOR DFC RU'S
	LB	R5,BBUFER+MURHF1,R10,	:GET MURHF1 FOR RU CATEGORY
	NHI	R5,MU.CTG		:MASK RU CATEGORY BITS
	CLHI	R5,MU.FMD		:IS THIS FMD OR DFC?
	JE	FS2509			:FMD, LEAVE R0=0
	LIS	R0,1			:DFC, R0 = 1
	BBLOAD	R5,BBUFER+MURUPT,R10,	:DFC, POINT TO RU
	LB	R5,BBUFER,R5,		:GET ACTION_CODE
FS2509	LR	R2,R2			:CHECK MUCB.DIRECTION
	JN	FS251C			:JUMP IF RECEIVE
	LR	R4,R4			:CHECK MU RRI
	JN	FS250R			:JUMP IF IT'S A RESPONSE
	LB	R2,BBUFER+MURHF1,R10,
	NHI	R2,MU.ECI		:IS ECI BIT SET?
	JE	FS250P			:NO, -EC
	LB	R2,BBUFER+MURHF3,R10,
	NHI	R2,MU.CDI		:IS CDI BIT SET?
	JE	FS250H			:NO, -CD
	LR	R0,R0			:IS THIS FMD RU?
	JE	FS250B			:YES
	CLHI	R5,CANCEL		:NO, IS IT DFC CANCEL?
	JN	FS250D			:NO, GO CHECK FOR OTHER DFC VALUES

:========================================================================
:	INPUT:	S, RQ, FMD|CANCEL|, CD
:========================================================================
FS250B
	LHL	R5,TS2507,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS2507	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSC010-F.CODE 	:CONT SEND STATE, ACTION = 1
	HC	FSD070-F.CODE 	:CONT RCV STATE, ACTION = >(S)
	HC	FSC050-F.CODE 	:SEND STATE, ACTION = 5
	HC	FSD070-F.CODE 	:RCV STATE, ACTION = >(S)
	HC	FSD070-F.CODE 	:RCV 081B STATE, ACTION = >(S)
	HC	FSC050-F.CODE 	:ERPS STATE, ACTION = 5
	HC	FSD070-F.CODE 	:ERPR STATE, ACTION = >(S)

:	CHECK FOR CHASE|LUSTAT|QC
:-------------------------------------------
FS250D	CLHI	R5,CHASE		:IS IT CHASE?
	JE	FS250F			:YES
	CLHI	R5,LUSTAT		:IS IT LUSTAT?
:	JE	FS250F			:YES (7/18/84/CHS)
	JE	FS250M			:YES
	CLHI	R5,QC			:IS IT QC?
	JN	FS.COD,,		:NO, CRASH

:==========================================================
:	INPUT:	S, RQ, CHASE|LUSTAT|QC, CD (7/18/84/CHS)
:	INPUT:	S, RQ, CHASE|QC, CD (7/18/84/CHS)
:==========================================================
FS250F
	CLHI	R7,FS.ST4		:SEND STATE?
	JEFS	FS250G			:YES, ACTION = 5
	CLHI	R7,FS.ST7		:ERPS STATE?
	JN	FSD070,,		:NO, ALL OTHER STATES, ACTION=>(S)
FS250G
	J	FSC050,,		:YES, ACTION = 5

:	(7/18/84/CHS) TO HANDLE LUSTAT SPEICALLY
:==========================================================
:	INPUT:	S, RQ, LUSTAT, CD
:==========================================================
FS250M
	CLHI	R7,FS.ST1		:CONTENTION STATE?
	JE	FSC000,,		:YES, ACTION = -
	CLHI	R7,FS.ST4		:SEND STATE?
	JEFS	FS250N			:YES, ACTION = 5
	CLHI	R7,FS.ST7		:ERPS STATE?
	JN	FSD070,,		:NO, ALL OTHER STATES, ACTION=>(S)
FS250N
	J	FSC050,,		:YES, ACTION = 5
:	(7/18/84/CHS) END

:	CHECK FOR -CD, EC INPUTS
:------------------------------------------------------------------
FS250H	LR	R0,R0			:CHECK RU OP CODE
	JE	FS250J			:FMD RU
	CLHI	R5,CANCEL		:IS THIS DFC CANCEL?
	JE	FS250J			:YES
	CLHI	R5,LUSTAT		:IS THIS DFC LUSTAT?
	JN	FS250I			:NO, GO TO REST_OF_DFC INPUT
	LB	R2,BBUFER+MURHF3,R10,	:YES, MORE CHECKING
	NHI	R2,MU.EBI		:IS THIS END BRACKET?
	JE	FS250L			:NO (-EB)

:=====================================================================
:	INPUT:	S, RQ, REST_OF_DFC, -CD
:=====================================================================
:	INPUT:	S, RQ, LUSTAT, EB, -CD
:=====================================================================
FS250I
	LHL	R5,TS2509,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS2509	HS	0
	HC	FSC000-F.CODE 	:CONT STATE,	ACTION = -
	HC	FSD070-F.CODE 	:CONT SEND STATE, ACTION = >(S)
	HC	FSD070-F.CODE 	:CONT RCV STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:SEND STATE, ACTION = -
	HC	FSD070-F.CODE 	:RCV STATE, ACTION = >(S)
	HC	FSD070-F.CODE 	:RCV 081B STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:ERPS STATE, ACTION = -
	HC	FSD070-F.CODE 	:ERPR STATE, ACTION = >(S)

:======================================================================
:	INPUT:	S, RQ, FMD|CANCEL|, -CD, EC
:======================================================================
FS250J	
	LHL	R5,TS250A,R7,R7  	:GET STATE ENTRY ROUTINE 
	J	F.CODE,R5,,     

TS250A	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSC010-F.CODE 	:CONT SEND STATE, ACTION = 1
	HC	FSD070-F.CODE 	:CONT RCV STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:SEND STATE, ACTION = -
	HC	FSD070-F.CODE 	:RCV STATE, ACTION = >(S)
	HC	FSD070-F.CODE 	:RCV 081B STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:ERPS STATE, ACTION = -
	HC	FSD070-F.CODE 	:ERPR STATE, ACTION = >(S)

:==========================================================================
:	INPUT:	S, RQ, LUSTAT, -EB, -CD, EC
:==========================================================================
FS250L
	LHL	R5,TS250B,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250B	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSD070-F.CODE 	:CONT SEND STATE, ACTION = >(S)
	HC	FSD070-F.CODE 	:CONT RCV STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:SEND STATE, ACTION = -
	HC	FSD070-F.CODE 	:RCV STATE, ACTION = >(S)
	HC	FSD070-F.CODE 	:RCV 081B STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:ERPS STATE, ACTION = -
	HC	FSC000-F.CODE 	:ERPR STATE, ACTION = -


:============================================================================
:	INPUT:	S, RQ, -EC
:============================================================================
FS250P
	LHL	R5,TS250D,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250D	HS	0
	HC	FSC020-F.CODE 	:CONT STATE, ACTION = 2
	HC	FSC000-F.CODE 	:CONT SEND STATE, ACTION = -
	HC	FSD070-F.CODE 	:CONT RCV STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:SEND STATE, ACTION = -
	HC	FSD070-F.CODE 	:RCV STATE, ACTION = >(S)
	HC	FSD070-F.CODE 	:RCV 081B STATE, ACTION = >(S)
	HC	FSC000-F.CODE 	:ERPS STATE, ACTION = -
	HC	FSD070-F.CODE 	:ERPR STATE, ACTION = >(S)

:	CHECK SEND (S), RESPONSE (RSP) INPUTS
:-----------------------------------------------------------------------------
FS250R
	LB	R2,BBUFER+MURHF2,R10,
	NHI	R2,MU.RTI		:IS THIS POSITIVE RESPONSE?
	JE	FS.CPS,,		:YES, CRASH
	LB	R2,SCBBLK+SCSRMD,R9,	:GET BIND BYTE FOR SYMETRIC BIT
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE DATA
	CLHI	R0,.RREMF		:IS IT 0846 ?
	JN	FS2512			:NO, GO CHECK FOR -RACE INPUT
	NHI	R2,SC.RVR		:YES, BIND SPECIFY SYMETRIC?
	JN	FS2510			:YES
	LB	R0,FS.RCV,,		:NO, RECOVERER?
	JN	FS250Z			:YES

:=======================================================================
:	INPUT:	S, -RSP, 0846, -SYMETRIC, NOT_RECOVERER
:=======================================================================
FS250V	
	CLHI	R7,FS.ST4		:SEND STATE?
	JEFS	FS250W			:YES, ACTION = 8
	CLHI	R7,FS.ST5		:RCV STATE?
	JN	FSC000,,		:NO, ALL OTHER STATES, ACTION = -
FS250W
	J	FSC080,,		:YES, ACTION = 8

:===========================================================================
:	INPUT:	S,-RSP, 0846, -SYMETRIC, RECOVERER
:=========================================================================
FS250Z
	CLHI	R7,FS.ST5		:RCV STATE?
	JE	FSC040,,		:YES, ACTION = 4
	J	FSC000,,		:NO, ALL OTHER STATES, ACTION = -

:====================================================================
:	INPUT:	S, -RSP, 0846, SYMETRIC
:===================================================================
FS2510	
	CLHI	R7,FS.ST4		:SEND STATE?
	JEFS	FS2511			:YES, ACTION = 7
	CLHI	R7,FS.ST5		:RCV STATE?
	JN	FSC000,,		:NO, ALL OTHER STATES, ACTION = -
FS2511	
	J	FSC070,,		:YES, ACTION = 7

:	CHECK -RACE INPUTS
:---------------------------------------------------------------------
FS2512
	CLHI	R0,.RRBRE		:IS THIS A BRACKET RACE ERROR?
	JE	FS.CSC,,		:YES, RACE ERROR
	CLHI	R0,.RRBJN		:BRACKET BID REJECT, RTR NOT BE SENT?
	JE	FS.CSC,,		:YES, RACE ERROR
	CLHI	R0,.RRBJF		:BRACKET BID REJECT, RTR'LL BE SENT?
	JE	FS.CSC,,		:YES, RACE ERROR
	CLHI	R0,.RRRTM		:RECEIVER IN TRANSMIT MODE?
	JE	FS.CSC,,		:YES, RACE ERROR
	NHI	R2,SC.RVR		:NO, BIND SPECIFY SYMETRIC?
	JN	FS251A			:YES
	LB	R0,FS.RCV,,		:RECOVERER?
	JNFS	FS2518			:YES

:====================================================================
:	INPUT:	S, -RSP, -RACE, -SYMETRIC, NOT_RECOVERER
:===================================================================
FS2516
	J	FS250V			:NO, GO GET STATE ENTRY ROUTINE

:===================================================================
:	INPUT:	S, -RSP, -RACE, -SYMETRIC, RECOVERER
:===================================================================
FS2518
	J	FS250Z			:GO GET STATE ENTRY ROUTINE

:===============================================================
:	INPUT:	S, -RSP, -RACE, SYMETRIC
:===============================================================
FS251A
	J	FS250V			:GO GET STATE ENTRY ROUTINE	

:	CHECK FOR RECEIVE (R) INPUTS
:-------------------------------------------------------------------
FS251C	LR	R4,R4			:REQUEST OR RESPONSE?
	JE	FS251Y			:REQUEST
	LB	R2,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R2,MU.RTI		:WHAT KIND OF RESPONSE?
	JE	FS.CPS,,		:POSITIVE, CRASH
	LHL	R4,BBUFER+MURHSN,R10,
	CLHI	R4,.RRRTM		:RCVR IN XMIT MODE ERROR (O81B)?
	JN	FS251E			:NO, GO CHECK FOR 0846 ERROR

:=======================================================================
:	INPUT:	R, -RSP, 081B
:====================================================================
	CLHI	R7,FS.ST4		:SEND STATE?
	JEFS	FS251D			:YES, ACTION = 6
	CLHI	R7,FS.ST5		:RCV STATE?
	JN	FSC000,,		:NO, ALL OTHER STATES, ACTION = -
FS251D
	J	FSC060,,		:YES, ACTION = 6

:	CHECK FOR 0846 INPUTS
:--------------------------------------------------------------
FS251E	LB	R2,SCBBLK+SCSRMD,R9,
	CLHI	R4,.RREMF		:IS THIS AN 0846 ERROR?
	JN	FS251O			:NO, GO CHECK IF -RACE INPUT
	NHI	R2,SC.RVR
	JN	FS251M			:THIS IS SYMMETRIC INPUT
	LB	R4,FS.RCV,,		:RECOVERER?
	JNFS	FS251K			:YES

:=================================================================
:	INPUT:	R, -RSP, 0846, -SYMMETRIC, NOT_RECOVERER
:===================================================================
FS251I
	CLHI	R7,FS.ST4		:SEND STATE?
	JE	FSC050,,		:YES, ACTION = 5
	J	FSC000,,		:NO, ALL OTHER STATES, ACTION = -

:============================================================================
:	INPUT:	R, -RSP, 0846, -SYMMETRIC, RECOVERER
:==========================================================================
FS251K
	J	FS2510			:GO GET STATE ENTRY ROUTINE

:=======================================================================
:	INPUT:	R, -RSP, 0846, SYMMETRIC
:======================================================================
FS251M
	J	FS250V			:GO GET STATE ENTRY ROUTINE

:	CHECK FOR -RACE INPUTS
:----------------------------------------------------------------------
FS251O
	CLHI	R4,.RRBRE		:IS THIS BRACKET RACE ERROR?
	JE	FS.CSC,,		:YES, CRASH
	CLHI	R0,.RRBJN		:BRACKET BID REJECT,RTR NOT SENT?
	JE	FS.CSC,,		:YES, RACE ERROR CRASH
	CLHI	R0,.RRBJF		:BRACKET BID REJECT, RTR SEND?
	JE	FS.CSC,,		:YES, RACE ERROR CRASH
	CLHI	R0,.RRRTM		:RECEIVER IN TRANSMIT MODE?
	JE	FS.CSC,,		:YES, RACE CONDITION CRASH
	NHI	R2,SC.RVR		:BIND SPECIFY SYMMETRIC RECOVERY?
	JN	FS251W			:YES
	LB	R4,FS.RCV,,		:RECOVERER?
	JNFS	FS251U			:YES

:=====================================================================
:	INPUT:	R, -RSP, -RACE, -SYM, NOT_RECOVERER
:=====================================================================
FS251S
	J	FS251I			:GO GET STATE ENTRY ROUTINE

:====================================================================
:	INPUT:	R,-RSP,-RACE,-SYM,REC
:====================================================================
FS251U
	J	FS2510			:GO GET STATE ENTRY ROUTINE

:====================================================================
:	INPUT:	R, -RSP, -RACE, SYM
:=====================================================================
FS251W	
	J	FS2510			:GO GET STATE ENTRY ROUTINE

:	CHECK RECEIVE (R) REQUEST (RQ) INPUTS
:---------------------------------------------
FS251Y
:	LHL	R2,SCBBLK+SCTPTG,R9,	:GET CT_PTR (6/22/84/CHS)
:	CLH	R2,SCBBLK+SCTPTR,R9,	:POINTER EMPTY? (6/22/84/CHS)
	LHL	R2,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR (6/22/84/CHS)
	JE	FS.CPT,,		:YES
	BBLOAD	R2,CMDBLK+CLARG,R2,	:POINT TO CORRELATION TAB (9/10/84MIA)
	LB	R2,BBUFER+CLARG5,R2,	:GET CT_BBI
	NHI	R2,MU.BBI		:CT(BB)?
	JE	FS2526			:NO, GO CHECK FOR -BB INPUT
	LR	R0,R0			:CHECK OP CODE
	JN	FS2520			:NOT FMD, GO CHECK DFC INPUT
	LB	R2,BBUFER+MURHF1,R10,
	NHI	R2,MU.ECI		:END CHAIN?
	JN	FS2522			:YES, (EC) DO MORE CHECKING

:=============================================================
:	INPUT:	R, RQ, FMD, CT(BB), -EC
:=============================================================
:FS250R					:(10/11/84 MIA)
	LHL	R5,TS250R,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250R	HS	0
	HC	FSC030-F.CODE 	:CONT STATE, ACTION = 3
	HC	FSD0N0-F.CODE 	:CONT SEND,ACTION=>(R),>(R),-(C)
	HC	FSC000-F.CODE 	:CONT RCV, ACTION = -
	HC	FSD0O0-F.CODE 	:SEND STATE, ACTION = >(R),>(R),-
	HC	FSD0Q0-F.CODE 	:RCV STATE, ACTION= >(R),-,-
	HC	FSC000-F.CODE 	:RCV 081B STATE, ACTION = -
	HC	FSC000-F.CODE 	:ERPS STATE, ACTION = -
	HC	FSC000-F.CODE 	:ERPR STATE, ACTION = -

:	CHECK FOR DFC CT(BB) INPUT
:--------------------------------------------------------------------- 
FS2520
	CLHI	R5,LUSTAT
	JE	FS2522			:LUSTAT
	CLHI	R5,CANCEL	
	JN	FS.COD,,		:NO, INVALID ACTION_CODE
FS2522	LB	R2,BBUFER+MURHF3,R10,
	NHI	R2,MU.CDI		:CHANGE DIRECTION INDICATOR SET?
	JE	FS2524			:NO, -CD.

:======================================================================
:	INPUT:	R, RQ, FMD|LUSTAT|CANCEL, CT(BB), CD
:======================================================================
	LHL	R5,TS250S,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250S	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSD0N0-F.CODE 	:CONT SEND, ACTION=>(R),>(R),-(C)
	HC	FSC010-F.CODE 	:CONT RCV STATE, ACTION = 1
	HC	FSD0O0-F.CODE 	:SEND STATE, ACTION=>(R),>(R),-
	HC	FSD0P0-F.CODE 	:RCV STATE, ACTION=>(R),4,-
	HC	FSC000-F.CODE 	:RCV 081B STATE, ACTION = -
	HC	FSC000-F.CODE 	:ERPS STATE, ACTION = -
	HC	FSC000-F.CODE 	:ERPR STATE, ACTION = -

:=======================================================================
:	INPUT:	R, RQ, FMD|LUSTAT|CANCEL, CT(BB), -CD, EC
:=======================================================================
FS2524
	LHL	R5,TS250T,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     	

TS250T	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSD0N0-F.CODE 	:CONT SEND, ACTION=>(R),>(R),-(C)
	HC	FSC010-F.CODE 	:CONT RCV STATE, ACTION = 1
	HC	FSD0O0-F.CODE 	:SEND STATE, ACTION=>(R),>(R),-
	HC	FSD0Q0-F.CODE 	:RCV STATE, ACTION=>(R),-,-
	HC	FSC000-F.CODE 	:RCV 081B STATE, ACTION = -
	HC	FSC000-F.CODE 	:ERPS STATE, ACTION = -
	HC	FSC000-F.CODE 	:ERPR STATE, ACTION = -

:	CHECK FOR CT(-BB) INPUT
:---------------------------------
FS2526
	LB	R2,BBUFER+MURHF3,R10,
	NHI	R2,MU.CDI		:CHANGE DIRECTION INDICATOR SET?
	JE	FS252E			:NO, -CD. CHECK EC
	LR	R0,R0			:CHECK OP CODE	
	JE	FS2528			:FMD
	CLHI	R5,CANCEL		:CANCEL DFC RU?
	JN	FS252A			:NO

:==============================================================
:	INPUT:	R, RQ, FMD|CANCEL, CT(-BB), CD
:==============================================================
FS2528
	LHL	R5,TS250U,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250U	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSD0N0-F.CODE 	:CONT SEND, ACTION=>(R),>(R),-(C)
	HC	FSC010-F.CODE 	:CONT RCV STATE, ACTION = 1
	HC	FSD0R0-F.CODE 	:SEND STATE, ACTION=>(R),>(R),>(R)
	HC	FSC040-F.CODE 	:RCV STATE, ACTION = 4
	HC	FSC040-F.CODE 	:RCV 081B STATE, ACTION = 4
	HC	FSD020-F.CODE 	:ERPS STATE, ACTION = >(R)
	HC	FSC040-F.CODE 	:ERPR STATE, ACTION = 4

:	CHECK FOR LUSTAT|CHASE|QC INPUT
:---------------------------------------
FS252A
	CLHI	R5,CHASE		:CHASE DFC RU?
	JE	FS252C			:YES
	CLHI	R5,LUSTAT		:LUSTAT DFC RU?
:	JE	FS252C			:YES (7/6/84/CHS)
	JE	FS252D			:YES (7/6/84/CHS)
	CLHI	R5,QC			:QC DFC RU?
	JN	FS.COD,,		:NO, CRASH

:===================================================
:	INPUT:	R, RQ, CHASE|LUSTAT|QC, CT(-BB), CD (7/6/84/CHS)
:	INPUT:	R, RQ, CHASE|QC, CT(-BB), CD (7/6/84/CHS)
:===================================================
FS252C
	LHL	R5,TS250V,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250V	HS	0
	HC	FSD020-F.CODE 	:CONT STATE, ACTION = >(R)
	HC	FSD0R0-F.CODE 	:CONT SEND, ACTION=>(R),>(R),>(R)
	HC	FSD020-F.CODE 	:CONT RCV STATE, ACTION = >(R)
	HC	FSD0R0-F.CODE 	:SEND STATE, ACTION=>(R),>(R),>(R)
	HC	FSC040-F.CODE 	:RCV STATE, ACTION = 4
	HC	FSC040-F.CODE 	:RCV 081B STATE, ACTION = 4
	HC	FSD020-F.CODE 	:ERPS STATE, ACTION = >(R)
	HC	FSC040-F.CODE 	:ERPR STATE, ACTION = 4

:	(7/6/84/CHS) FOR LUSTAT IN BETB
:===================================================
:	INPUT:	R, RQ, LUSTAT, CT(-BB), CD
:===================================================
FS252D
	LHL	R5,TS250Q,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250Q	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSD0R0-F.CODE 	:CONT SEND, ACTION=>(R),>(R),>(R)
	HC	FSD020-F.CODE 	:CONT RCV STATE, ACTION = >(R)
	HC	FSD0R0-F.CODE 	:SEND STATE, ACTION=>(R),>(R),>(R)
	HC	FSC040-F.CODE 	:RCV STATE, ACTION = 4
	HC	FSC040-F.CODE 	:RCV 081B STATE, ACTION = 4
	HC	FSD020-F.CODE 	:ERPS STATE, ACTION = >(R)
	HC	FSC040-F.CODE 	:ERPR STATE, ACTION = 4
:	(7/6/84/CHS) END OF LUSTAT IN BETB

:	CHECK FOR CT(-BB), AND -CD INPUT
:----------------------------------------
FS252E
	LR	R0,R0			:CHECK OP CODE
	JN	FS252K			:NOT FMD, MUST BE DFC RU
	LB	R2,BBUFER+MURHF1,R10,
	NHI	R2,MU.ECI		:END CHAIN INDICATOR SET?
	JE	FS252I			:NO, -EC INPUT

:===================================================
:	INPUT:	R, RQ, FMD|CANCEL|, CT(-BB), -CD, EC
:===================================================
FS252G
	LHL	R5,TS250W,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250W	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSD0N0-F.CODE 	:CONT SEND, ACTION=>(R),>(R),-(C)
	HC	FSC010-F.CODE 	:CONT RCV STATE, ACTION = 1
	HC	FSD0R0-F.CODE 	:SEND STATE, ACTION=>(R),>(R),>(R)
	HC	FSC000-F.CODE 	:RCV STATE, ACTION = -
	HC	FSC040-F.CODE 	:RCV 081B STATE, ACTION = 4
	HC	FSD020-F.CODE 	:ERPS STATE, ACTION = >(R)
	HC	FSC000-F.CODE 	:ERPR STATE, ACTION = -

:=====================================================
:	INPUT:	R, RQ, FMD, CT(-BB), -EC
:=====================================================
FS252I
	LHL	R5,TS250X,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250X	HS	0
	HC	FSC030-F.CODE 	:CONT STATE, ACTION = 3
	HC	FSD0N0-F.CODE 	:CONT SEND, ACTION=>(R),>(R),-(C)
	HC	FSC000-F.CODE 	:CONT RCV STATE, ACTION = -
	HC	FSD0R0-F.CODE 	:SEND STATE, ACTION=>(R),>(R),>(R)
	HC	FSC000-F.CODE 	:RCV STATE, ACTION = -
	HC	FSC000-F.CODE 	:RCV 081B STATE, ACTION = -
	HC	FSD020-F.CODE 	:ERPS STATE, ACTION = >(R)
	HC	FSC000-F.CODE 	:ERPR STATE, ACTION = -

:	CHECK FOR DFC INPUT
:-----------------------------
FS252K	
	CLHI	R5,CANCEL		:CANCEL DFC RU?
	JN	FS252M			:NO
	LB	R2,BBUFER+MURHF1,R10,
	NHI	R2,MU.ECI		:END CHAIN INDICATOR SET?
	JE	FS.CEC,,		:NO, CRASH
	J	FS252G			:YES
FS252M	CLHI	R5,LUSTAT		:LUSTAT DFC RU?
	JN	FS252Q			:NO, REST_OF_DFC INPUT

:=======================================================
:	INPUT:	R, RQ, LUSTAT, CT(-BB), -CD
:=======================================================
FS252O
	LHL	R5,TS250Y,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250Y	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSD0N0-F.CODE 	:CONT SEND, ACTION=>(R),>(R),-(C)
	HC	FSD020-F.CODE 	:CONT RCV STATE, ACTION=>(R)
	HC	FSD0O0-F.CODE 	:SEND STATE, ACTION=>(R),>(R),-
	HC	FSC000-F.CODE 	:RCV STATE, ACTION = -
	HC	FSC040-F.CODE 	:RCV 081B STATE, ACTION = 4
	HC	FSC000-F.CODE 	:ERPS STATE, ACTION = -
	HC	FSC000-F.CODE 	:ERPR STATE, ACTION = -

:======================================================
:	INPUT:	R, RQ, REST_OF_DFC, CT(-BB), -CD
:======================================================
FS252Q
	LHL	R5,TS250Z,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     

TS250Z	HS	0
	HC	FSC000-F.CODE 	:CONT STATE, ACTION = -
	HC	FSD0N0-F.CODE 	:CONT SEND, ACTION=>(R),>(R),-(C)
	HC	FSD020-F.CODE 	:CONT RCV STATE, ACTION = >(R)
	HC	FSD0O0-F.CODE 	:SEND STATE, ACTION=>(R),>(R),-
	HC	FSC000-F.CODE 	:RCV STATE, ACTION = -
	HC	FSC040-F.CODE 	:RCV 081B STATE, ACTION = 4
	HC	FSD020-F.CODE 	:ERPS STATE, ACTION = >(R)
	HC	FSC000-F.CODE 	:ERPR STATE, ACTION = -



	FO	CBKDEF
	FO	CMDLST
	
	EM				:END OF 'SSHF00' MODULE
	SUBTTL	SESSION CONTROL FSM'S USING SCB ('SSMF00')
:	******************************************************************
:	REVISION HISTORY
:	03/28/84 (DRUE BONDAD)	-ORIGINAL DESIGN AND CODING
:	******************************************************************

	
	RA	0

	MO	.,SNAPKG

	LO	CBKDEF
	LO	CMDLST

	SEG	A.CODE	

:(F06/12/18/87/DB) ALL REFERENCES TO FSCIN WERE CHANGED TO FSCIN!!

	SUBTTL	FSM_SESS_BF_CP_LU
:***********************************************************************
:	FS4000	-(FSM_SESS_BF_CP_LU) THE FUNCTION OF THIS FSM IS TO 
:	REMEMBER THE STATE OF THE SSCP-LU HALF-SESSION THAT IS SUPPORTED
:	BY BOUNDARY FUNCTION.
:	PAGE 13-97 IN FAPL
:	----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR
:			RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY),
:			R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS4000
	FS.MC1(FSCCIE,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS4001			:NO, CHECK FOR OTHER INPUTS
	CLHI	R0,FS.RET		:SIGNAL=RESET?
	JN	FS.CSG,,		:NO, CRASH

:=======================================================================
:	INPUT:	'RESET'
:=======================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSC000,,		:YES, ACTION = -
	J	FSS040,,		:NO, ACTION = 1(H)

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:------------------------------------------
FS4001
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, INVALID INPUT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LB	R0,SCBBLK+SCMYEA,R9,	:GET ELEMENT_ADDRESS
	CLHI	R5,ACTLU		:ACTION_CODE=ACTLU?
	JN	FS400C			:NO, GO CHECK FOR DACTLU
	LR	R4,R4			:RQ OR RSP?
	JN	FS4004			:RSP
	LR	R2,R2			:SEND OR RCV?
	JEFS	FS4002			:SEND
	CLH	R0,BBUFER+MUDEAF,R10,	:PRI OR SEC?
	JN	FS.CHS,,		:SEC, CRASH

:===================================================================
:	INPUT:	R, RQ, ACTLU, PRI
:===================================================================
	J	FS4108,,		:CALL STATE ENTRY ROUTINE

:	CHECK FOR S, RQ, ACTLU INPUT
:----------------------------------------------
FS4002
	CLH	R0,BBUFER+MUDEAF,R10,	:PRI OR SEC?
	JN	FS.CHS,,		:PRI, CRASH

:=====================================================================
:	INPUT:	S, RQ, ACTLU, SEC
:======================================================================
	J	FS420A,,		:CALL STATE ENTRY ROUTINE

:	CHECK FOR RSP, ACTLU INPUT
:----------------------------------
FS4004
	CLH	R0,BBUFER+MUOEAF,R10,	:PRI OR SEC?
	JN	FS.CHS,,		:SEND & SEC, OR RCV & PRI - CRASH
	LR	R2,R2			:SEND OR RCV?
:=======================================================================
:	INPUT:	R, RSP, ACTLU, SEC
:=======================================================================
	JN	FS4206,,		:RCV, CALL STATE ENTRY ROUTINE
	
:	CHECK FOR S, RSP, ACTLU INPUT
:------------------------------------------
FS4006
	LB	R0,BBUFER+MURHF2,R10,	:SEND, GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JEFS	FS4008			:+RSP

:======================================================================
:	INPUT:	S, -RSP, ACTLU, PRI
:======================================================================
	LHL	R5,TS4004,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4004	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSS040-F.CODE 	:PEND ACT STATE, ACTION = 1(H)
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RSET STATE, ACTION = >
	HC	FSS050-F.CODE 	:PEND SON STATE, ACTION = 1(HK)

:	CHECK FOR S, +RSP, ACTLU, PRI INPUT
:--------------------------------------------
FS4008
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	CLHI	R0,COLD			:TYP_ACTIVATION = COLD

:====================================================================
:	INPUT:	S, +RSP, ACTLU, PRI, COLD
:====================================================================
	JE	FS410C,,		:CALL STATE ENTRY ROUTINE

:	CHECK FOR ERP INPUT
:---------------------------
FS400A
	CLHI	R0,ERP			:TYPE_ACTIVATION = ERP?
	JN	FS.CAC,,		:NO, CRASH

:========================================================================
:	INPUT:	S, +RSP, ACTLU, PRI, ERP
:========================================================================
	J	FS410G,,		:CALL STATE ENTRY ROUTINE

:	CHECK FOR DACTLU INPUT
:----------------------------------
FS400C
	CLHI	R5,DACTLU		:ACTION_CODE=DACTLU?
	JN	FS.COD,,		:NO, CRASH
	LR	R4,R4			:RQ OR RSP?
	JN	FS400I			:RSP
	CLH	R0,BBUFER+MUDEAF,R10,	:PRI OR SEC?
	JN	FS.CHS,,		:SEND & PRI, OR RCV & SEC - CRASH
	LR	R2,R2			:SEND OR RCV?
	JNFS	FS400E			:RCV

:======================================================================
:	INPUT:	S, RQ, DACTLU, SEC
:======================================================================
	LHL	R5,TS4007,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4007	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
:	HC	FSC0A0-SEG|a.CODE| :ACTIVE ST, ACT = > (03/27/86 MIA)
	HC	FSC0A0-F.CODE	:ACTIVE STATE, ACT = > (03/27/86 MIA)
	HC	FSS110-F.CODE 	:PEND RSET STATE, ACTION = -(TK)
	HC	FSS150-F.CODE 	:PEND SON STATE, ACTION = 1(HC)

:	CHECK FOR R, RQ, DACTLU, PRI INPUT
:-------------------------------------------
FS400E
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	CLHI	R0,SON			:SESSION OUTAGE NOTIFICATION?

:======================================================================
:	INPUT:	R, RQ, DACTLU, PRI, SON
:======================================================================
	JE	FS410O,,		:YES (SON), CALL STATE ENTRY ROUTINE

:======================================================================
:	INPUT:	R, RQ, DACTLU, PRI, -SON
:======================================================================
	LHL	R5,TS4008,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4008	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC040-F.CODE 	:PEND ACT STATE, ACTION = 4
	HC	FSC040-F.CODE 	:ACTIVE STATE, ACTION = 4	
	HC	FSC000-F.CODE 	:PEND RSET STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR RSP, DACTLU INPUT
:------------------------------------
FS400I
	CLH	R0,BBUFER+MUOEAF,R10,	:PRI OR SEC?
	JN	FS.CHS,,		:SEND & SEC, OR RCV & PRI - CRASH
	LR	R2,R2			:SEND OR RCV?

:========================================================================
:	INPUT:	R, RSP, DACTLU, SEC
:========================================================================
	JN	FS420O,,		:RCV, CALL STATE ENTRY ROUTINE

:========================================================================
:	INPUT:	S, RSP, DACTLU, PRI
:========================================================================
	J	FS420K,,		:SEND, CALL STATE ENTRY ROUTINE


	SUBTTL	FSM_SESS_BF_CP_PU_T1
:***********************************************************************
:	FS4100	-(FSM_SESS_BF_CP_PU_T1) THE FUNCTION OF THIS FSM IS TO
:	REMEMBER THE STATE OF THE SSCP-PU_T1 HALF-SESSION THAT IS SUPPORTED
:	BY THE BOUNDARY FUNCTION IN THE NODE.
:	PAGE 13-95 IN FAPL
:	-----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM 
:			STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR
:			RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY),
:			R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS4100
	FS.MC1(FSCBS1,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JE	FS4104			:NO
	CLHI	R0,FS.RET		:SIGNAL = RESET?
	JN	FS.CSG,,		:NO, CRASH

:=================================================================
:	INPUT:	RESET
:=================================================================
FS4102
	CLHI	R7,FS.ST1		:STATE 1?
	JE	FSCIN,,		:YES, RESET STATE, ACTION = /
	J	FSS040,,		:NO, ACTION CODE = 1(H)

:	CHECK FOR INPUTS OTHER THAN SIGNAL
:--------------------------------------------
FS4104
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, INVALID INPUT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,ACTPU		:ACTION_CODE=ACTPU?
	JN	FS410I			:NO
	LR	R2,R2			:SEND OR RCV?
	JN	FS4108			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JE	FS410A			:+RSP

:================================================================
:	INPUT:	S, -RSP, ACTPU
:=================================================================
FS4106
	CLHI	R7,FS.ST2		:STATE 2?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSS040,,		:YES, PEND ACT STATE, ACTION=1(H)
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:=====================================================================
:	INPUT:	R, RQ, ACTPU
:=====================================================================
FS4108
	LHL	R5,TS4102,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     	
TS4102	HS	0
	HC	FSS070-F.CODE 	:RESET STATE, ACTION = 2(S)
	HC	FSC0A0-F.CODE 	:PEND ACTIVE STATE, ACTION = >
	HC	FSS070-F.CODE 	:ACTIVE STATE, ACTION = 2(S)
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR S, +RSP, ACTPU INPUT
:----------------------------------------
FS410A
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	NHI	R0,AP.ACT		:(3/27/84 NCS)
	CLHI	R0,COLD			:COLD?
	JN	FS410E			:NO, -COLD

:====================================================================
:	INPUT:	S, +RSP, ACTPU, COLD
:====================================================================
FS410C
	CLHI	R7,FS.ST2		:STATE 2?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSS120,,		:YES, PEND ACT STATE, ACTION=3(T)
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR ERP INPUT
:---------------------------
FS410E
	CLHI	R0,ERP			:ERP?
	JN	FS.CRM,,		:NO, CRASH

:================================================================
:	INPUT:	S, +RSP, ACTPU, ERP
:================================================================
FS410G
	CLHI	R7,FS.ST2		:STATE 2?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSS100,,		:YES, PEND ACT STATE, ACTION=3(TK)
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR DACTPU INPUT
:--------------------------------
FS410I
	CLHI	R5,DACTPU		:ACTION_CODE=DACTPU?
	JN	FS.COD,,		:NO, CRASH
	LR	R2,R2			:SEND OR RCV?
	JN	FS410K			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ, CRASH

:==================================================================
:	INPUT:	S, RSP, DACTPU
:==================================================================
	LHL	R5,TS4105,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4105	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
:	HC	FSC0A0-SEG|a.CODE| :PN ACT ST, ACT = > (03/27/86 MIA)
	HC	FSC0A0-F.CODE	:PND ACTIVE ST, ACT = > (03/27/86 MIA)
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSS040-F.CODE 	:PEND RESET STATE, ACTION = 1(H)
	HC	FSS050-F.CODE 	:PEND SON STATE, ACTION = 1(HK)

:	CHECK FOR R, DACTPU INPUT
:--------------------------------------
FS410K
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	CLHI	R0,SON			:SESSION OUTAGE NOTIFICATION?
	JE	FS410O			:YES

:===========================================================================
:	INPUT:	R, RQ, DACTPU, -SON
:===========================================================================
FS410M
	LHL	R5,TS4106,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4106	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC040-F.CODE 	:PEND ACTIVE STATE, ACTION = 4
	HC	FSS140-F.CODE 	:ACTIVE STATE, ACTION = 4(HS)
	HC	FSC000-F.CODE 	:PEND RESET STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:========================================================================
:	INPUT:	R, RQ, DACTPU, SON
:=========================================================================
FS410O
	CLHI	R7,FS.ST1		:STATE 1?
	JE	FSCIN,,		:YES, RESET STATE, ACTION = /
	CLHI	R7,FS.ST5		:STATE 5?
	JE	FSC0A0,,		:YES, ACTION = >
	J	FSC050,,		:ALL OTHER STATES, ACTION = 5


	SUBTTL	FSM_SESS_BF_CP_PU_T2
:**************************************************************
:	FS4200	-(FSM_SESS_BF_CP_PU_T2) THE FUNCTION OF THIS FSM IS
:	TO REMEMBER THE STATE OF THE SSCP-PU_T2 HALF-SESSION THAT IS
:	SUPPORTED BY BOUDARY FUNCTION.
:	PAGE 13-96 IN FAPL
:	------------------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR
:			RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY),
:			R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS4200
	FS.MC1(FSCBS2,FS.SCB)		:CHECK INPUTS
	LR	R0,R0			:SIGNAL PRESENT?
	JEFS	FS4202			:NO
	CLHI	R0,FS.RET		:RESET SIGNAL?
	JN	FS.CSG,,		:NO, CRASH

:====================================================================
:	INPUT:	RESET
:====================================================================
	J	FS4102,,		:CALL STATE ENTRY ROUTINE

:	CHECK FOR INPUT OTHER THAN SIGNAL
:--------------------------------------------
FS4202
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, INVALID INPUT
	LB	R0,SCBBLK+SCMYEA,R9,	:GET ELEMENT_ADDRESS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,ACTPU		:ACTION_CODE=ACTPU?
	JN	FS420G			:NO, GO CHECK FOR DACTPU
	LR	R2,R2			:SEND OR RCV?
	JE	FS4208			:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS4204			:RSP
	CLH	R0,BBUFER+MUDEAF,R10,	:ELEMENT_ADDRESS=DEF?
	JN	FS.CHS,,		:NO, CRASH

:===============================================================
:	INPUT:	R, RQ, ACTPU, PRI
:===============================================================
	J	FS4108,,		:CALL STATE ENTRY ROUTINE

:	CHECK FOR R, RSP, ACTPU INPUT
:----------------------------------------
FS4204
	CLH	R0,BBUFER+MUOEAF,R10,	:ELEMENT_ADDRESS=OEF?
	JN	FS.CHS,,		:NO, -SEC SO CRASH

:=========================================================================
:	INPUT:	R, RSP, ACTPU, SEC
:=========================================================================
FS4206
	LHL	R5,TS4203,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4203	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC000-F.CODE 	:PEND ACT STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSS010-F.CODE 	:PEND RESET STATE, ACTION = -(N)
	HC	FSS010-F.CODE 	:PEND SON STATE, ACTION = -(N)

:	CHECK FOR S, ACTPU INPUT
:----------------------------------
FS4208
	LR	R4,R4			:RQ OR RSP?
	JN	FS4208			:RSP
	CLH	R0,BBUFER+MUDEAF,R10,	:ELEMENT_ADDRESS=DAF?
	JN	FS.CHS,,		:NO, -SEC SO CRASH

:=============================================================================
:	INPUT:	S, RQ, ACTPU, SEC
:===============================================================================
FS420A
	CLHI	R7,FS.ST2		:STATE 2?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSC000,,		:YES, PEND ACT STATE, ACTION = -
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR S, RSP, ACTPU INPUT
:----------------------------------------------
FS420C
	CLH	R0,BBUFER+MUOEAF,R10,	:ELEMENT_ADDRESS=OEF?
	JN	FS.CHS,,		:NO, -PRI SO CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?

:===============================================================
:	INPUT:	S, -RSP, ACTPU, PRI
:===============================================================
	JN	FS4106,,		:NEGATIVE, CALL STATE ENTRY ROUTINE

:	CHECK FOR S, +RSP, ACTPU, PRI INPUT
:---------------------------------------------------
FS420E
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET FIRST BYTE OF RU
	NHI	R0,AP.ACT		:(3/27/84 NCS)
	CLHI	R0,COLD			:COLD?

:=========================================================================
:	INPUT:	S, +RSP, ACTPU, PRI, COLD
:=========================================================================
	JE	FS410C,,		:YES, CALL STATE ENTRY ROUTINE

:==========================================================================
:	INPUT:	S, +RSP, ACTPU, PRI, ERP
:==========================================================================
	J	FS410G,,		:CALL STATE ENTRY ROUTINE

:	CHECK FOR DACTPU INPUT
:-------------------------------------------------------
FS420G
	CLHI	R5,DACTPU		:ACTION_CODE=DACTPU?
	JN	FS.COD,,		:NO, CRASH
	LR	R2,R2			:SEND OR RCV?
	JN	FS420M			:RCV
	LR	R4,R4			:RQ OR RSP?
	JN	FS420I			:RSP
	CLH	R0,BBUFER+MUDEAF,R10,	:ELEMENT_ADDRESS=DEF?
	JN	FS.CHS,,		:NO, -SEC

:========================================================================
:	INPUT:	S, RQ, DACTPU,SEC
:========================================================================
	LHL	R5,TS4208,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4208	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND RESET STATE, ACTION = -
	HC	FSS050-F.CODE 	:PEND SON STATE, ACTION = 1(HK)

:	CHECK FOR S, RSP, DACTPU
:-----------------------------------------
FS420I
	CLH	R0,BBUFER+MUOEAF,R10,	:ELEMENT_ADDRESS=OEF?
	JN	FS.CHS,,		:NO, -PRI SO CRASH

:======================================================================
:	INPUT:	S, RSP, DACTPU, PRI
:======================================================================
FS420K
	LHL	R5,TS4209,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4209	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSS040-F.CODE 	:PEND RESET STATE, ACTION = 1(H)
	HC	FSS050-F.CODE 	:PEND SON STATE, ACTION = 1(HK)

:	CHECK FOR R, DACTPU
:------------------------------------------
FS420M
	LR	R4,R4			:RQ OR RSP?
	JE	FS420Q,,		:RQ
	CLH	R0,BBUFER+MUDEAF,R10,	:ELEMENT ADDRESS = DEF?
	JN	FS.CHS,,		:NO, -SEC SO CRASH

:=======================================================================
:	INPUT:	R, RSP, DACTPU, SEC
:=======================================================================
FS420O
	LHL	R5,TS420A,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS420A	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND RESET STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND SON STATE, ACTION = -

:	CHECK FOR R, RQ, DACTPU INPUT
:-------------------------------------------------
FS420Q
	CLH	R0,BBUFER+MUOEAF,R10,	:ELEMENT_ADDR=OEF?
	JN	FS.CHS,,		:NO, -PRI SO CRASH
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	CLHI	R0,SON			:SESSION OUTAGE NOTIFICATION?

:===============================================================
:	INPUT:	R, RQ, DACTPU, -SON, PRI
:===============================================================
	JN	FS410M,,		:NO (-SON), CALL STATE ENTRY ROUTINE

:=======================================================================
:	INPUT:	R, RQ, DACTPU, SON, PRI
:=======================================================================
	J	FS410O,,		:YES (SON), CALL STATE ENTRY ROUTINE

		
	SUBTTL	FSM_SESS_BF_LU_LU
:***********************************************************************
:	FS4300	-(FSM_SESS_BF_LU_LU) THE FUNCTION OF THIS FSM IS TO
:	REMEMBER THE STATE OF THE LU-LU HALF-SESSION THAT IS SUPPORTED
:	BY BOUNDARY FUNCTION.
:	PAGE 13-98 IN FAPL
:	---------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR
:			FSM  STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ
:			OR RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY),
:			R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1, R2, R4, R5, R7 ARE DESTROYED
FS4300
	FS.MC1(FSCBLL,FS.SCB)		:CHECK INPUTS
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, INVALID INPUT
	LB	R0,SCBBLK+SCMYEA,R9,	:GET ELEMENT ADDRESS
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,BIND			:ACTION_CODE=BIND
	JN	FS430C			:NO, GO CHECK FOR UNBIND
	LR	R2,R2			:SEND OR RCV?
	JE	FS4304			:SEND
	LR	R4,R4			:RQ OR RSP?
	JNFS	FS4302			:RSP
	CLH	R0,BBUFER+MUDEAF,R10,	:PRI?
	JN	FS.CHS,,		:-PRI, CRASH

:================================================================
:	INPUT:	R, RQ, BIND, PRI
:================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSS070,,		:YES, ACTION = 2(S)
	J	FSC0A0,,		:NO, ALL OTHER STATES, ACTION = >

:	CHECK FOR R, RSP, BIND INPUT
:------------------------------------------------
FS4302
	CLH	R0,BBUFER+MUOEAF,R10,	:SEC?
	JN	FS.CHS,,		:-SEC, CRASH

:=================================================================
:	INPUT:	R, RSP, BIND, SEC
:=================================================================
	LHL	R5,TS4302,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4302	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC000-F.CODE 	:PEND ACT STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSS010-F.CODE 	:PEND UNBIND PRI STATE, ACTION = -(N)
	HC	FSC0A0-F.CODE 	:PEND UNBIND SEC STATE, ACTION=>
	HC	FSC0A0-F.CODE 	:PEND UNBIND RSP STATE, ACTION=>
	HC	FSC0A0-F.CODE 	:PEND RSET O84D STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND REX OUT STATE, ACTION = >

:	CHECK FOR S, BIND, INPUT
:-----------------------------------
FS4304
	LR	R4,R4			:RQ OR RSP?
	JN	FS4306			:RSP
	CLH	R0,BBUFER+MUDEAF,R10,	:SEC?
	JN	FS.CHS,,		:-SEC, CRASH

:==================================================================
:	INPUT:	S, RQ, BIND, SEC
:==================================================================
	CLHI	R7,FS.ST2		:PEND ACTIVE STATE?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSC000,,		:YES, ACTION = -
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR S, RSP, BIND INPUT
:--------------------------------------------
FS4306
	CLH	R0,BBUFER+MUOEAF,R10,	:PRI?
	JN	FS.CHS,,		:-PRI, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS4308			:-RSP

:=================================================================
:	INPUT:	S, +RSP, BIND, PRI
:=================================================================
	CLHI	R7,FS.ST2		:PEND ACT STATE?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSS100,,		:YES, ACTION = 3(T)
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR S, -RSP, BIND INPUT
:---------------------------------------
FS4308
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE CODE
	CLHI	R0,.RRISB		:SENSE CODE = 084D?
	JEFS	FS430A			:YES

:==================================================================
:	INPUT:	S, -RSP, BIND, PRI, -084D
:==================================================================
	CLHI	R7,FS.ST2		:PEND ACT STATE?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSS040,,		:YES, ACTION = 1(H)
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:=================================================================
:	INPUT:	S, -RSP, BIND, 084D
:=================================================================
FS430A
	CLHI	R7,FS.ST2		:PEND ACT STATE?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSC070,,		:YES, ACTION = 7
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR UNBIND INPUT
:---------------------------------------------
FS430C
	CLHI	R5,UNBIND		:ACTION_CODE=UNBIND?
	JN	FS.COD,,		:NO, CRASH
	LR	R2,R2			:SEND OR RCV?
	JN	FS430K			:RCV
	CLH	R0,BBUFER+MUOEAF,R10,	:PRI?
	JN	FS430G			:-PRI, CRASH
	LR	R4,R4			:RQ OR RSP?
	JN	FS430E			:RSP

:===================================================================
:	INPUT:	S, RQ, UNBIND, PRI
:====================================================================
	LHL	R5,TS4307,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4307	HS	0		
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC060-F.CODE 	:ACTIVE STATE, ACTION = 6
	HC	FSC0A0-F.CODE 	:PEND UNBIND PRI STATE, ACTION=>
	HC	FSC000-F.CODE 	:PEND UNBIND SEC STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND UNBIND RSP STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND RSET 084D STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTON = >
	HC	FSC000-F.CODE 	:PEND REX OUT STATE ACTION = -

:==========================================================================
:	INPUT:	S, RSP, UNBIND, PRI
:==========================================================================
FS430E
	LHL	R5,TS4308,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4308	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSS160-F.CODE 	:PEND UNBIND PRI STATE, ACTION = 1(H)
	HC	FSC0A0-F.CODE 	:PEND UNBIND SEC STATE, ACTION = >
	HC	FSS160-F.CODE 	:PEND UNBIND RSP STATE, ACTION = 1(H)
	HC	FSS170-F.CODE 	:PEND RSET STATE, ACTION = 1(HK)
	HC	FSS170-F.CODE 	:PEND VR OUT STATE, ACTION = 1(HK)
	HC	FSS160-F.CODE 	:PEND REX OUT STATE, ACTION = 1(H)

:	CHECK FOR S, UNBIND, SEC INPUT
:------------------------------------------------
FS430G
	CLH	R0,BBUFER+MUDEAF,R10,	:SEC?
	JN	FS.CHS,,		:NO, CRASH
	LR	R4,R4			:RQ OR RSP?
	JN	FS430I			:RSP

:===================================================================
:	INPUT:	S, RQ, UNBIND, SEC
:===================================================================
	LHL	R5,TS4309,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4309	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC060-F.CODE 	:ACTIVE STATE, ACTION = 6
	HC	FSC000-F.CODE 	:PEND UNBIND PRI STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND UNBIND SEC STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND RSP STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND RESET 084D STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND VR OUT STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND REX OUT STATE, ACTION = >

:==================================================================
:	INPUT:	S, RSP, UNBIND, SEC
:==================================================================
FS430I	
	LHL	R5,TS430A,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS430A	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND UNBIND PRI STATE, ACTION = >
	HC	FSS160-F.CODE 	:PEND UNBIND SEC STATE, ACTION = 1(H)
	HC	FSS160-F.CODE 	:PEND UNBIND RSP STATE, ACTION = 1(H)
	HC	FSC0A0-F.CODE 	:PEND RSET 084D STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >
	HC	FSS170-F.CODE 	:PEND REX OUT STATE, ACTION = 1(HK)

:	CHECK FOR R, UNBIND INPUT
:----------------------------------
FS430K
	LIS	R2,1			:ASSUME PRIMARY
	CLH	R0,BBUFER+MUDEAF,R10,	:PRI?
	JEFS	FS430M			:YES
	LIS	R2,0			:ASSUME SEC
	CLH	R0,BBUFER+MUOEAF,R10,	:SEC?
	JN	FS.CHS,,		:NO, CRASH
FS430M
	LR	R4,R4			:RQ OR RSP?
	JE	FS430Q			:RQ
	LR	R2,R2			:PRI OR SEC?
	JN	FS430O			:PRI
	
:==================================================================
:	INPUT:	R, RSP, UNBIND, SEC
:==================================================================
	LHL	R5,TS430B,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS430B	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACT STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND UNBIND PRI STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND UNBIND SEC STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND UNBIND RSP STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND RESET 984D STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND VR OUT STATE , ACTION = -
	HC	FSC0A0-F.CODE 	:PEND REX OUT STATE, ACTION = >

:=======================================================================
:	INPUT:	R, RSP, UNBIND, PRI
:=======================================================================
FS430O
	LHL	R5,TS430C,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS430C	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND UNBIND PRI STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND UNBIND SEC STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND UNBIND RSP STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND RESET 084D STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND REX OUT STATE, ACTION = -

:	CHECK FOR R, RQ, UNBIND INPUT
:----------------------------------------------------
FS430Q
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	LR	R2,R2			:PRI OR SEC?
	JE	FS430W			:SEC
	CLHI	R0,SO.VIO		:VR_INOP?
	JEFS	FS430S			:YES
	CLHI	R0,SO.VRF		:DACTVR_FORCED?
	JN	FS430U			:NO

:======================================================================
:	INPUT:	R, RQ, UNBIND, PRI, VR_OUT
:======================================================================
FS430S
	LHL	R5,TS430D,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS430D	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC080-F.CODE 	:PEND ACT STATE, ACTION = 8
	HC	FSC080-F.CODE 	:ACT STATE, ACTION = 8
	HC	FSS020-F.CODE 	:PEND UNBIND PRI STATE, ACTION = 8(N)
	HC	FSC080-F.CODE 	:PEND UNBIND SEC STATE, ACTION = 8
	HC	FSS020-F.CODE 	:PEND UNBIND RSP STATE, ACTION = 8(N)
	HC	FSC080-F.CODE 	:PEND RSET 084D STATE, ACTION = 8
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >
	HC	FSS050-F.CODE 	:PEND REX OUT STATE ACTION = 1(HK)

:=======================================================================
:	INPUT:	R, RQ, UNBIND, PRI, -VR_OUT
:========================================================================
FS430U
	LHL	R5,TS430E,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS430E	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC040-F.CODE 	:PEND ACT STATE, ACTION = 4
	HC	FSC040-F.CODE 	:ACT STATE, ACTION = 4
	HC	FSC000-F.CODE 	:PEND UNBIND PRI STATE, ACTION = -
	HC	FSC060-F.CODE 	:PEND UNBIND SEC STATE, ACTION = 6
	HC	FSC000-F.CODE 	:PEND UNBIND RSP STATE, ACTION = -
	HC	FSC040-F.CODE 	:PEND RESET 084D STATE, ACTION = 4
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >
	HC	FSS010-F.CODE 	:PEND REX OUT STATE, ACTION = -(N)

:	CHECK FOR R, RQ, UNBIND, SEC INPUT
:------------------------------------------------------
FS430W
	CLHI	R0,SO.RIO		:REX_INOP?
	JE	FS430Y			:YES

:====================================================================
:	INPUT:	R, RQ, UNBIND, SEC, -REX_OUT
:====================================================================
	LHL	R5,TS430F,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS430F	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC050-F.CODE 	:PEND ACT STATE, ACTION = 5
	HC	FSC050-F.CODE 	:ACTIVE STATE, ACTION = 5
	HC	FSC060-F.CODE 	:PEND UNBIND PRI STATE, ACTION = 6
	HC	FSC000-F.CODE 	:PEND UNBIND SEC STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND UNBIND RSP STATE, ACTION = -
	HC	FSS010-F.CODE 	:PEND RSET 084D STATE, ACTION = -(N)
	HC	FSS010-F.CODE 	:PEND VR OUT STATE, ACTION = -(N)
	HC	FSC0A0-F.CODE 	:PEND REX OUT STATE, ACTION = >

:=======================================================================
:	INPUT:	R, RQ, UNBIND, SEC, REX_OUT 
:=======================================================================
FS430Y
	LHL	R5,TS430G,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS430G	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC090-F.CODE 	:PEND ACT STATE, ACTION = 9
	HC	FSC090-F.CODE 	:ACTIVE STATE, ACTION = 9
	HC	FSC090-F.CODE 	:PEND UNBIND PRI STATE, ACTION = 9
	HC	FSS030-F.CODE 	:PEND UNBIND SEC STATE, ACTION = 9(N)
:	HC	FSS030-SEG|a.CODE| :PN UNB RSP, = 9(N) (03/27/86 MIA)
	HC	FSS030-F.CODE	:PND UNBIND RSP, =9(N) (03/27/86 MIA)
	HC	FSS050-F.CODE 	:PEND RESET 084D STATE, ACTION = 1(HK)
	HC	FSS050-F.CODE 	:PEND VR OUT STATE, ACTION = 1(HK)
	HC	FSC0A0-F.CODE 	:PEND REX OUT STATE, ACTION = >



	SUBTTL	FSM_SESS_LU_LU_PRI
:*****************************************************************
:	FS4400-(FSM_SESS_LU_LU_PRI) THE FUNCTION OF THIS FSM IS TO
:	REMEMBER THE STATE OF THE PRIMARY LU-LU HALF-SESSION.
:	PAGE 13-94 IN FAPL
:	----------------------------------------------------------	
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR 
:			FSM STATE INFOIN SCB), R2 (MU_DIRECTION),
:			R4 (RQ OR RSP), R7 (FSM STATE VALUE), R9 (SCB
:			ENTRY), R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS4400
	FS.MC1(FSCLLP,FS.SCB)		:CHECK INPUTS
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSIN CONTROL RU?
	JN	FS.CAT,,		:NO, INVALID INPUT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,BIND			:ACTION_CODE=BIND?
	JN	FS4408			:NO, GO CHECK FOR UNBIND
	LR	R2,R2			:SEND OR RCV?
	JN	FS4402			:RECEIVE
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH

:================================================================
:	INPUT:	S, RQ, BIND
:================================================================
FS4401
	CLHI	R7,FS.ST1		:STATE 1?
	JE	FSS070,,		:YES, RESET STATE, ACTION = 2(S)
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR R, BIND INPUT
:-----------------------------------------------------
FS4402
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:REQUEST, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS4404			:-RSP

:======================================================================
:	INPUT:	R, +RSP, BIND
:======================================================================
FS4403
	CLHI	R7,FS.ST2		:STATE 2?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSS100,,		:YES, PEND ACT STATE, ACTION=3(T)
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR R, -RSP, BIND INPUT
:----------------------------------------
FS4404
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE CODE
	CLHI	R0,.RRISB		:SENSE CODE = 084D?
	JE	FS4406			:YES
	CLHI	R0,.RRISP		:SENSE CODE = 084E?
	JE	FS4406			:YES

:===============================================================
:	INPUT:	R, -RSP, BIND, -(084D|084E)
:===============================================================
	CLHI	R7,FS.ST2		:STATE 2?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
 	JE	FSC010,,		:YES, PEND ACT STATE, ACTION=1
	J	FSC0A0,,		:ALL OTHER STATES ACTION = >

:===================================================================
:	INPUT:	R, -RSP, BIND, (084D|084E)
:===================================================================
FS4406
	CLHI	R7,FS.ST2		:STATE 2?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSC040,,		:YES, PEND ACT STATE, ACTION = 4
	J	FSC0A0,,		:ALL OTHER STATE, ACTION = >

:	CHECK FOR UNBIND INPUT
:-------------------------------
FS4408
	LR	R2,R2			:SEND OR RCV?
	JN	FS440C			:RCV
	LR	R4,R4			:RQ OR RSP?
	JN	FS440A			:RSP

:======================================================================
:	INPUT:	S, RQ, UNBIND
:======================================================================
	LHL	R5,TS4405,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4405	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC050-F.CODE 	:PEND ACT STATE, ACTION = 5
	HC	FSC050-F.CODE 	:ACTIVE STATE, ACTION = 5
	HC	FSC050-F.CODE 	:PEND RSET NRSP, ACTION = 5
	HC	FSC000-F.CODE 	:PEND RSET PRI STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND RSET SEC STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND RSET BOTH STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:========================================================================
:	INPUT:	S, RSP, UNBIND
:========================================================================
FS440A
	LHL	R5,TS4406,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4406	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RSET NRSP STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RSET PRI STATE, ACTION = >
	HC	FSS160-F.CODE 	:PEND RSET SEC STATE, ACTION = 1(H)
	HC	FSS160-F.CODE 	:PEND RSET BOTH, ACTION = 1(H)
	HC	FSS170-F.CODE 	:PEND SON STATE, ACTION = 1(HK)

:	CHECK FOR R, UNBIND INPUT
:----------------------------------
FS440C
	LR	R4,R4			:RQ OR RSP?
	JE	FS440E			:RQ

:=====================================================================
:	INPUT: R, RSP, UNBIND
:======================================================================
	LHL	R5,TS4407,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4407	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RSET NRSP STATE, ACTION = >
	HC	FSC010-F.CODE 	:PEND RSET PRI STATE, ACTION = 1
	HC	FSC0A0-F.CODE 	:PEND RSET SEC STATE, ACTION = >
	HC	FSC010-F.CODE 	:PEND RSET BOTH STATE, ACTION = 1
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR R, RQ, UNBIND INPUT
:-------------------------------------
FS440E
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU 
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	JAL	R4,FS44A0,,		:DEACT_TYPE = SON?
	JE	FS440G			:YES

:===================================================================
:	INPUT:	R, RQ, UNBIND, -SON
:====================================================================
	LHL	R5,TS4408,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4408	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE STATE, ACTION = >
	HC	FSC060-F.CODE 	:ACTIVE STATE, ACTION = 6
	HC	FSC060-F.CODE 	:PEND RSET NRPS STATE, ACTION = 6
	HC	FSC070-F.CODE 	:PEND RSET PRI STATE, ACTION = 7
	HC	FSC000-F.CODE 	:PEND RSET SEC STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND RSET BOTH STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:=====================================================================
:	INPUT:	R, RQ, UNBIND, SON
:======================================================================
FS440G
	CLHI	R7,FS.ST1		:STATE 1?
	JE	FSCIN,,		:YES, RESET STATE, ACTION = /
	CLHI	R7,FS.ST8		:STATE 8?
	JE	FSC0A0,,		:YES, PEND SON STATE, ACTION=>
	J	FSC080,,		:ALL OTHER STATES, ACTION = 8
:----------------------------------------------------------------------
:	FS44A0	- THIS ROUTINE IS USED BY FSM'S THAT WANT TO KNOW IF
:		  A UNBIND.DEACTIVATION_TYPE IS SESSION OUTAGE NOTIFICATION
:		  (SON).
:	INPUT:	R0 (UNBIND.DEACTIVATION_TYPE)
:	LINK:	R4
:	OUTPUT:	CONDITION CODES = 0 FOR SON, CONDITION CODES = NON ZERO 
:		FOR -SON
:	WORKING:R2 & R5 DESTROYED, ALL OTHER REGISTERS ARE UNCHANGED
:-------------------------------------------------------------------------
FS44A0
	LI	R5,FS44AT		:R5 POINTS TO TABLE OF SON VALUES
	LHL	R2,0,R5,		:FIRST VALUE IN TABLE IS # OF SON VALUES
FS44A2
	AIS	R5,2			:POINT TO NEXT SON VALUE TO CHECK FOR
	CLH	R0,0,R5,		:DEACTIVATION_TYPE = SON?
	JER	R4			:YES, RETURN WITH CC = ZERO (SON TRUE)
	SIS	R2,1			:NO, ONE LESS SON VALUE TO CHECK
	JN	FS44A2			:ONLY LOOP IF NOT ALL VALUES CHECKED
	LIS	R2,1			:SET CC = NON ZERO (SON FALSE)
	JR	R4			:RETURN
:
:	TABLE OF SESSION OUTAGE VALUES FOR UNBIND.DEACTIVATION_TYPE BYTE
:
	BND	2
FS44AT	HC	08			:NUMBER OF SON VALUES IN TABLE
	HC	07			:VIRTUAL ROUTE INOPERATIVE
	HC	08			:ROUTE EXTENSION INOPERATIVE
	HC	09			:HIERARCHICHAL RESET
	HC	0B			:VIRTUAL ROUTE DEACTIVATED
	HC	0C			:LU FAILURE - UNRECOVERABLE
	HC	0E			:LU FAILURE - RECOVERABLE
	HC	0F			:CLEANUP
	HC	0FE			:INVALID SESSION PROTOCOL


:**********************************************************************
:	FS4500	-(FSM_SESS_LU_LU_SEC) THE FUNCTION OF THIS FSM IS TO
:	REMEMBER THE STATE OF THE SECONDARY LU-LU HALF-SESSION.
:	PAGE 13-94 IN FAPL
:	-------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO IN SCB), R2 (MU_DIRECTION), R4 (RQ OR
:			RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY), 
:			R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TREU OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		WORKING:R0, R1, R2, R4, R5, R6, R7 ARE DESTROYED
:		LINK:	R3
FS4500
	FS.MC1(FSCLLS,FS.SCB)		:CHECK INPUTS
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, INVALID INPUT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLHI	R5,BIND			:BIND?
	JN	FS4506			:NO
	LR	R2,R2			:SEND OR RCV?
	JE	FS4502			:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH

:==================================================================
:	INPUT:	R, RQ, BIND
:==================================================================
	J	FS4401,,		:CALL STATE ENTRY ROUTINE

:	CHECK FOR S, BIND INPUT
:---------------------------------
FS4502
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYT OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE?

:===============================================================
:	INPUT:	S, +RSP, BIND
:================================================================
	JE	FS4403,,		:POSITIVE, CALL STATE ENTRY ROUTINE

:===============================================================
:	INPUT:	S, -RSP, BIND
:===============================================================
FS4504
	CLHI	R7,FS.ST2		:STATE 2?
	JL	FSCIN,,		:NO, RESET STATE, ACTION = /
	JE	FSS040,,		:YES, PEND ACT STATE, ACTION=1(H)
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR UNBIND INPUT
:--------------------------------
FS4506
	CLHI	R5,UNBIND		:ACTION_CODE=UNBIND?
	JN	FS.COD,,		:NO, CRASH
	LR	R2,R2			:SEND OR RCV?
	JN	FS450A			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS4508			:REQUEST

:=========================================================================
:	INPUT:	S, RSP, UNBIND
:=========================================================================
	LHL	R5,TS4504,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4504	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSS160-F.CODE 	:PEND RSET PRI STATE, ACTION = 1(H)
	HC	FSC0A0-F.CODE 	:PEND RSET SEC STATE, ACTION = >
	HC	FSS160-F.CODE 	:PEND RSET BOTH STATE, ACTION = 1(H)
	HC	FSS170-F.CODE 	:PEND SON STATE, ACTION = 1(HK)

:=================================================================
:	INPUT:	S, RQ, UNBIND
:=================================================================
FS4508
	LHL	R5,TS4505,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4505	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE STATE, ACTION = >
	HC	FSC050-F.CODE 	:ACTIVE STATE, ACTION = 5
	HC	FSC0A0-F.CODE 	:PEND RSET PRI STATE, ACTION = >
	HC	FSC000-F.CODE 	:PEND RSET SEC STATE, ACTION = -
	HC	FSC000-F.CODE 	:PEND RSET BOTH STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND SON STATE,ACTION = >

:	CHECK FOR R, UNBIND INPUT
:-----------------------------------
FS450A
	LR	R4,R4			:RQ OR RSP?
	JE	FS450C			:RQ

:==================================================================
:	INPUT:	R, RSP, UNBIND
:==================================================================
	LHL	R5,TS4506,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4506	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RSET PRI STATE, ACTION = >
	HC	FSC010-F.CODE 	:PEND RSET SEC STATE, ACTION = 1
	HC	FSC010-F.CODE 	:PEND RSET BOTH STATE, ACTION = 1
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR R, RQ, UNBIND INPUT
:--------------------------------------
FS450C
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	JAL	R4,FS44A0,,		:DEACT_TYPE = SON?
	JE	FS450E			:YES

:=======================================================================
:	INPUT:	R, RQ, UNBIND, -SON
:=======================================================================
	LHL	R5,TS4507,R7,R7  	:GET STATE ENTRY RTINE
	J	F.CODE,R5,,     
TS4507	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC040-F.CODE 	:PEND ACTIVE STATE, ACTION = 4
	HC	FSC040-F.CODE 	:ACTIVE STATE, ACTION = 4
	HC	FSC000-F.CODE 	:PEND RSET PRI STATE, ACTION = -
	HC	FSC060-F.CODE 	:PEND RSET SEC STATE, ACTION = 6
	HC	FSC000-F.CODE 	:PEND RSET BOTH STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:========================================================================
:	INPUT:	R, RQ, UNBIND, SON
:========================================================================
FS450E
	CLHI	R7,FS.ST1		:STATE 1?
	JE	FSCIN,,		:YES, RESET STATE, ACTION = /
	CLHI	R7,FS.ST7		:STATE 7?
	JE	FSC0A0,,		:YES, PEND SON STATE,ACTION=>
	J	FSC070,,		:ALL OTHER STATES, ACTION = 7

	SUBTTL	FSM_SESS_CP_LU_PRI
:*****************************************************************
:	FS4600	-(FSM_SESS_CP_LU_PRI) THE FUNCTION OF THIS FSM IS
:	TO REMEMBER THE STATE OF THE PRIMARY SSCP-LU HALF-SESSION.
:	PAGE 13-93 IN FAPL
:	---------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX 
:			FOR FSM STATE INFO IN SCB), R2 (MU.DIRECTION)
:			R4 (RQ OR RSP), R7 (FSM STATE VALUE),
:			R9 (SCB ENTRY), R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS4600
	FS.MC1(FSCSLP,FS.SCB)		:CHECK INPUTS
	LI	R0,ACTLU*10000+DACTLU	:THIS FSM CHECKS FOR ACTLU & DACTLU
: ENTRY POINT FOR FSM_SESS_CP_LU_SEC (FS4800)
:	INPUT:	R0= BITS 0-15 ACTIVATION ACTION_CODE
:		    BITS 16-32 DEACTIVATION ACTION_CODE
FS46A0
	ST	R0,FS.ACT,,		:STORE FOR FUTURE COMPARISONS
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, INVALID INPUT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLH	R5,FS.ACT,,		:ACTION_CODE=ACTLU/PU?
	JN	FS4606			:NO, GO CHECK FOR DACTLU/PU
	LR	R2,R2			:SEND OR RCV?
	JN	FS4602			:RCV
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP,CRASH

:=================================================================
:	INPUT:	S, RQ, ACTLU/PU
:=================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSS070,,		:YES, ACTION = 2(S)
	J	FSC0A0,,		:NO, ALL OTHER STATES, ACTION=>

:	CHECK FOR R, ACTLU/PU INPUT
:--------------------------------
FS4602
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:REQUEST, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS4604			:-RSP

:================================================================
:	INPUT:	R, +RSP, ACTLU/PU
:=================================================================
	LHL	R5,TS4602,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4602	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSS100-F.CODE 	:PEND ACTIVE STATE, ACTION = 3(T)
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >

:===================================================================
:	INPUT:	R, -RSP, ACTLU/PU
:=====================================================================
FS4604
	LHL	R5,TS4603,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4603	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC010-F.CODE 	:PEND ACTIVE STATE, ACTION = 1
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >

:	CHECK FOR DACTLU/PU INPUT
:---------------------------------------
FS4606
	CLH	R5,FS.ACT+2,,		:ACTION_CODE=DACTLU/PU?
	JN	FS.COD,,		:NO, CRASH
	LR	R2,R2			:SEND OR RCV?
	JN	FS460A			:RCV
	LR	R4,R4			:RQ OR RSP?
	JN	FS4608			:RSP

:=================================================================
:	INPUT:	S, RQ, DACTLU/PU
:=================================================================
	LHL	R5,TS4604,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4604	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC040-F.CODE 	:PEND ACTIVE STATE, ACTION = 4
	HC	FSC040-F.CODE 	:ACTIVE STATE, ACTION = 4
	HC	FSC000-F.CODE 	:PEND RESET STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >

:	CHECK FOR S, RSP, DACTLU/PU
:----------------------------------
FS4608
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS.CNG,,		:-RSP

:=================================================================
:	INPUT:	S, +RSP, DACTLU/PU
:=================================================================
	LHL	R5,TS4605,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4605	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >
	HC	FSS050-F.CODE 	:PEND VR OUT STATE, ACTION = 1(HK)

:	CHECK FOR R, DACTLU/PU INPUT
:--------------------------------------
FS460A
	LR	R4,R4			:RQ OR RSP?
	JN	FS460C			:RSP
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET DEACTIVATION_TYPE
	CLHI	R0,SON			:SESSION OUTAGE NOTIFICATION?
	JN	FS.CDC,,		:NO, INVALID INPUT
	LB	R0,BBUFER+2,R5,		:GET 3RD BYTE OF RU
	CLHI	R0,SO.VIO		:VR_INOP?
	JEFS	FS460B			:YES, VR_OUT
	CLHI	R0,SO.VRF		:VR_FORCED?
	JN	FS.CDC,,		:NO, -VR_OUT, INVALID INPUT

:===================================================================
:	INPUT:	R, RQ, DACTLU/PU, VR_OUT
:===================================================================
FS460B
	LHL	R5,TS4606,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4606	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC050-F.CODE 	:PEND ACTIVE STATE, ACTION =5
	HC	FSC050-F.CODE 	:ACTIVE STATE, ACTION = 5
	HC	FSC050-F.CODE 	:PEND RESET STATE, ACTION = 5
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >

:===================================================================
:	INPUT:	R, RSP, DACTLU/PU
:===================================================================
FS460C
	LHL	R5,TS4607,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     	
TS4607	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC010-F.CODE 	:PEND RESET STATE, ACTION = 1
	HC	FSC0A0-F.CODE 	:PEND VR OUT STATE, ACTION = >

	SUBTTL	FSM_SESS_CP_LU_SEC
:*******************************************************************
:	FS4700	-(FSM_SESS_CP_LU_SEC) THE FUNCTION OF THIS FSM IS TO
:	REMEMBER THE STATE OF THE SECONDARY SSCP-LU HALF-SESSION.
:	PAGE 13-93 IN FAPL
:	------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR
:			FSM STATE INFO IN SCB), R2 (MU_DIRECTION),
:			R4 (RQ OR RSP), R7 (FSM STATE VALUE), R9 (SCB
:			ENTRY), R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0, R1, R2, R4, R5, R7 ARE DESTROYED
FS4700
	FS.MC1(FSCSLS,FS.SCB)		:CHECK INPUTS
	LI	R5,ACTLU*10000+DACTLU	:THIS FSM CHECKS FOR ACTLU & DACTLU
: ENTRY POINT FOR FSM_SESS_CP_PU_SEC (FS4900), 
:	INPUT:	R5= BITS 0-15 ACTIVATION ACTION_CODE
:		    BITS 16-32 DEACTIVATION ACTION_CODE
FS47A0
	ST	R5,FS.ACT,,		:SAVE FOR FUTURE COMPARISONS
	LR	R0,R0			:SIGNAL PRESENT?
	JN	FS470E			:YES, GO FIND WHICH SIGNAL
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:MASK FOR JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, INVALID INPUT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	CLH	R5,FS.ACT,,		:ACTION_CODE=ACTLU/PU?
	JN	FS4708			:NO, GO CHECK FOR DACTLU/PU
	LR	R2,R2			:SEND OR RCV?
	JE	FS4702			:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH

:===============================================================
:	INPUT:	R, RQ, ACTLU/PU
:===============================================================
	LHL	R5,TS4701,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4701	HS	0
	HC	FSS070-F.CODE 	:RESET STATE, ACTION = 2(S)
	HC	FSC0A0-F.CODE 	:PEND ACTIVE STATE, ACTION = >
	HC	FSS070-F.CODE 	:ACTIVE STATE, ACTION = 2(S)
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR S, ACTLU/PU INPUT
:-------------------------------------
FS4702
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JE	FS4704			:+RSP

:=====================================================================
:	INPUT:	S, -RSP, ACTLU/PU
:=====================================================================
	LHL	R5,TS4702,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4702	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSS040-F.CODE 	:PEND ACTIVE STATE, ACTION = 1(H)
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR S, +RSP, ACTLU/PU
:----------------------------------------
FS4704
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	NHI	R0,AP.ACT		:(3/27/84 NCS)
	CLHI	R0,COLD			:COLD?
	JN	FS4706			:NO, GO CHECK FOR ERP

:=================================================================
:	INPUT:	S, +RSP, ACTLU/PU, COLD
:==================================================================
	LHL	R5,TS4703,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4703	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSS120-F.CODE 	:PEND ACTIVE STATE, ACTION = 3(TK)
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR ERP INPUT
:-------------------------------------------
FS4706
	CLHI	R0,ERP			:ERP?
	JN	FS.CAC,,		:NO, CRASH
	
:===================================================================
:	INPUT:	S, +RSP, ACTLU/PU, ERP
:===================================================================
	LHL	R5,TS4704,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4704	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSS100-F.CODE 	:PEND ACTIVE STATE, ACTION = 3(T)
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR DACTLU/PU INPUT
:-------------------------------------
FS4708
	CLH	R5,FS.ACT+2,,		:ACTION_CODE=DACTLU/PU?
	JN	FS.COD,,		:NO, CRASH
	LR	R2,R2			:SEND OR RCV?
	JN	FS470A			:RCV
	LR	R4,R4			:RQ OR RSP?
	JE	FS.CRQ,,		:RQ, CRASH
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS.CNG,,		:-RSP

:=====================================================================
:	INPUT:	S, +RSP, DACTLU/PU
:=====================================================================
	LHL	R5,TS4705,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4705	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSS130-F.CODE 	:PEND RESET STATE, ACTION = 1(HS)
	HC	FSS050-F.CODE 	:PEND SON STATE, ACTION = 1(HK)

:	CHECK FOR R, DACTLU/PU INPUT
:----------------------------------------
FS470A
	LR	R4,R4			:RQ OR RSP?
	JN	FS.CRS,,		:RSP, CRASH
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LHL	R0,BBUFER+MUDCF,R10,	:GET RU LENGTH (9/26/84/CHS)
	CLHI	R0,4			:SHORT FORM OF DACTLU?(9/26/84/CHS)
	JLEFS	FS470X			:YES, SKIP (9/26/84/CHS)
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	CLHI	R0,SON			:SESSION OUTAGE NOTIFICATION?
	JE	FS470C			:YES

:=================================================================
:	INPUT:	R, RQ, DACTLU/PU, -SON
:=================================================================
FS470X					:(9/26/84/CHS)
	LHL	R5,TS4706,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4706	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC040-F.CODE 	:PEND ACTIVE STATE, ACTION = 4
	HC	FSC040-F.CODE 	:ACTIVE STATE, ACTION = 4
	HC	FSC000-F.CODE 	:PEND RESET STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:====================================================================
:	INPUT:	R, RQ, DACTLU/PU, SON
:====================================================================
FS470C
	LHL	R5,TS4707,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4707	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC050-F.CODE 	:PEND ACTIVE STATE, ACTION = 5
	HC	FSC050-F.CODE 	:ACTIVE STATE, ACTION = 5
	HC	FSC050-F.CODE 	:PEND RESET STATE, ACTION = 5
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR SIGNAL INPUT
:-------------------------------
FS470E
	CLHI	R0,FS.HRT		:HIERARCHICAL_RESET_RQ?
	JN	FS470G			:NO

:============================================================================
:	INPUT:	'HIERARCHICAL_RESET_REQUEST'
:============================================================================
	LHL	R5,TS4708,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4708	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC050-F.CODE 	:PEND ACT STATE, ACTION = 5
	HC	FSC050-F.CODE 	:ACTIVE STATE, ACTION = 5
	HC	FSC050-F.CODE 	:PEND RESET STATE, ACTION = 5
	HC	FSC0A0-F.CODE 	:PEND SON STATE, ACTION = >

:	CHECK FOR 'HIERARCHICAL_RESET_RESPONSE'
:-------------------------------------------------
FS470G
	CLHI	R0,FS.HRP		:HIERARCHICAL_RESET_RSP?
	JN	FS.CSG,,		:NO, CRASH

:======================================================================
:	INPUT:	'HIERARCHICAL_RESET_RESPONSE'
:======================================================================
	LHL	R5,TS4709,R7,R7		:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS4709	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACT STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSS040-F.CODE 	:PEND RESET STATE, ACTION = 1(H)
	HC	FSS040-F.CODE 	:PEND SON STATE, ACTION = 1(H)
	

	SUBTTL	FSM_SESS_CP_PU_PRI
:******************************************************************
:	FS4800	-(FSM_SESS_CP_PU_PRI) THE FUNCTION OF THIS FSM IS
:	TO REMEMBER THE STATE OF THE PRIMARY SSCP-PU HALF-SESSION.
:	PAGE 13-92 IN FAPL
:	------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR 
:			FSM STATE INFO IN SCB), R2 (MU.DIRECTION), R4 (RQ
:			OR RSP), R9 (SCB ENTRY), R10 (MU_PTR)
:			R7 (FSM STATE VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS4800
	FS.MC1(FSCSPP,FS.SCB)		:CHECK INPUTS
	LI	R0,ACTPU*10000+DACTPU	:THIS FSM CHECKS FOR ACTPU & DACTPU
	J	FS46A0,,		:THIS FSM USES SAME INPUT CHECKING
					:LOGIC AS FSM_SESS_CP_LU_PRI (FS4600)
	

	SUBTTL	FSM_SESS_CP_PU_SEC
:***********************************************************************
:	FS4900	-(FSM_SESS_CP_PU_SEC) THE FUNCTION OF THIS FSM IS TO
:	REMEMBER THE STATE OF THE SECONDARY SSCP-PU HALF-SESSION.
:	PAGE 13-92 IN FAPL
:	----------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM
:			STATE INFO. IN SCB), R2 (MU_DIRECTION), R4 (RQ OR
:			RSP), R7 (FSM STATE VALUE), R9 (SCB ENTRY),
:			R10 (MU_PTR), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS4900
	FS.MC1(FSCSPS,FS.SCB)		:CHECK INPUTS
	LI	R5,ACTPU*10000+DACTPU	:THIS FSM CHECKS ACTPU & DACTPU
	J	FS47A0,,		:USES SAME INPUT CHECKING LOGIC
					:AS FSM_SESS_CP_LU_SEC (FS4700)

	SUBTTL	FSM_SESS_SSCP_SSCP_PRI_OR_SEC
:********************************************************************
:	FS5000	-(FSM_SESS_SSCP_SSCP_PRI_OR_SEC) THE FUNCTION OF THIS
:	FSM IS TO REMEMBER THE STATE OF THE SSCP-SSCP HALF SESSION.
:	PAGE 13-91 IN FAPL
:	-------------------------------------------------------------
:	REGISTER USAGE:
:		INPUT:	R0 (FSM INPUT SIGNAL, OPTION), R1 (INDEX FOR FSM 
:			STATE INFO. IN SCB), R2 (MU.DIRECTION), R4 (RQ OR 
:			RSP), R9 (SCB ENTRY), R10 (MU_PTR), R7 (FSM STATE
:			VALUE), R6 (FUNCTION OR CALL)
:		OUTPUT:	R6 (TRUE OR FALSE FOR SEND_OR_RCV_CHECK)
:			R8 THRU R15 ARE UNCHANGED
:		LINK:	R3
:		WORKING:R0,R1,R2,R4,R5,R7 ARE DESTROYED
FS5000
	FS.MC1(FSCSSP,FS.SCB)		:CHECK INPUTS
	LB	R0,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	NHI	R0,MU.CTG		:GET JUST RU CATEGORY BITS
	CLHI	R0,MU.SC		:SESSION CONTROL RU?
	JN	FS.CAT,,		:NO, CRASH
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R5,BBUFER,R5,		:GET FIRST BYTE OF RU
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE FOR FUTURE CHECKS
	CLHI	R5,ACCDRM		:ACTCDRM RU?
	JN	FS500E,,		:NO, GO CHECK FOR DACTCDRM
	LR	R2,R2			:SEND OR RCV?
	JE	FS5008,,		:SEND
	LR	R4,R4			:RQ OR RSP?
	JN	FS5002,,		:RSP

:============================================================
:	INPUT:	R, RQ, ACTCDRM
:============================================================
	LHL	R5,TS5001,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5001	HS	0
	HC	FSS080-F.CODE 	:RESET STATE, ACTION = 3(S)
	HC	FSS080-F.CODE 	:PEND ACTIVE SEND, ACTION = 3(S)
	HC	FSS060-F.CODE 	:PEND ACTIVE RCV, ACTION = -(S)
	HC	FSS080-F.CODE 	:ACTIVE STATE, ACTION = 3(S)
	HC	FSS080-F.CODE 	:PEND RESET SEND, ACTION = 3(S)
	HC	FSC0A0-F.CODE 	:PEND RESET RCV, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET SON, ACTION = >

:	CHECK FOR R, RSP, ACTCDRM INPUT
:----------------------------------------
FS5002
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RSP?
	JN	FS5004			:NEGATIVE, -RSP

:===================================================================
:	INPUT:	R, +RSP, ACTCDRM
:===================================================================
	LHL	R5,TS5002,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5002	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSS090-F.CODE 	:PEND ACTIVE SEND STATE, ACTION = 4(T)
	HC	FSC0A0-F.CODE 	:PEND ACTIVE RCV STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET SEND STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET RCV STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET SON STATE, ACTION = >

:	CHECK FOR R, -RSP, ACTCDRM INPUT
:-----------------------------------------------
FS5004
	LHL	R2,BBUFER+MURHSN,R10,	:GET SENSE CODE (SNC)
	CLHI	R2,.RRNAU		:NAU CONTENTION ERROR (080D)?
	JN	FS5006			:NO, -080D INPUT

:=======================================================================
:	INPUT:	R, -RSP, ACTCDRM, 080D
:=======================================================================
	LHL	R5,TS5003,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5003	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSS000-F.CODE 	:PEND ACTIVE SEND STATE, ACTION = -(D)
	HC	FSS000-F.CODE 	:PEND ACTIVE RCV STATE, ACTION = -(D)
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET SEND, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET RCV STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RSET SON STATE, ACTION = >

:======================================================================
:	INPUT:	R, -RSP, ACTCDRM, -080D
:======================================================================
FS5006
	CLHI	R7,FS.ST2		:PEND ACTIVE SEND STATE?
	JL	FSCIN,,		:NO, RESET STATE,ACTION = /
	JE	FSC010,,		:YES, ACTION = 1
	J	FSC0A0,,		:ALL OTHER STATES, ACTION = >

:	CHECK FOR S, ACTCDRM INPUT
:--------------------------------------
FS5008
	LR	R4,R4			:RQ OR RSP?
	JN	FS500A			:RSP
	
:================================================================
:	INPUT:	S, RQ, ACTCDRM
:================================================================
	CLHI	R7,FS.ST1		:RESET STATE?
	JE	FSS070,,		:YES, ACTION = 2(S)
	J	FSC0A0,,		:NO, ALL OTHER STATES, ACTION = >

:	CHECK FOR S, RSP, ACTCDRM INPUT
:--------------------------------------------
FS500A
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE RESPONSE?
	JN	FS500C			:NEGATIVE, -RSP INPUT

:===================================================================
:	INPUT:	S, +RSP, ACTCDRM
:===================================================================
	LHL	R5,TS5006,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5006	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE SEND STATE, ACTION = >
	HC	FSS090-F.CODE 	:PEND ACTIVE RCV STATE, ACTION = 4(T)
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET SEND STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET RCV STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET SON STATE, ACTION = >

:=======================================================================
:	INPUT:	S, -RSP, ACTCDRM
:=======================================================================
FS500C
	LHL	R5,TS5007,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5007	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE SEND STATE, ACTION =>
	HC	FSS040-F.CODE 	:PEND ACTIVE RCV STATE, ACTION =1(H)
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION =>
	HC	FSC0A0-F.CODE 	:PEND RESET SEND STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET RCV STATE, ACTION =>
	HC	FSC0A0-F.CODE 	:PEND RESET SON STATE, ACTION = >

:	CHECK FOR DACTCDRM INPUT
:-----------------------------------
FS500E
	LR	R2,R2			:SEND OR RCV?
	JN	FS500I			:RCV
	LR	R4,R4			:RQ OR RSP?
	JN	FS500G			:RSP

:==============================================================
:	INPUT:	S, RQ, DACTCDRM
:==============================================================
	LHL	R5,TS5008,R7,R7  	:GET FSM STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5008	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC050-F.CODE 	:PEND ACTIVE SEND STATE, ACTION = 5
	HC	FSC050-F.CODE 	:PEND ACTIVE RCV STATE, ACTION = 5
	HC	FSC050-F.CODE 	:ACTIVE STATE, ACTION = 5
	HC	FSC000-F.CODE 	:PEND RESET SEND STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND RESET RCV STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET SON STATE, ACTION = >

:	CHECK FOR S, RSP, DACTCDRM INPUT
:------------------------------------------
FS500G
	NHI	R0,MU.RTI		:POSITIVE OR NEGATIVE?
	JN	FS.CNG,,		:NEGATIVE, CRASH
	
:====================================================================
:	INPUT:	S, +RSP, DACTCDRM
:====================================================================
	LHL	R5,TS5009,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS5009	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE SEND STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND ACTIVE RCV STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND RESET SEND STATE, ACTION = >
	HC	FSS040-F.CODE 	:PEND RESET RCV STATE, ACTION = 1(H)
	HC	FSS050-F.CODE 	:PEND RESET SON STATE, ACTION = 1(HK)

:	CHECK R, DACTCDRM INPUTS
:-----------------------------------
FS500I
	LR	R4,R4			:RQ OR RSP?
	JE	FS500K			:RQ

:======================================================================
:	INPUT:	R, RSP, DACTCDRM
:======================================================================
	LHL	R5,TS500A,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS500A	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC0A0-F.CODE 	:PEND ACTIVE SEND STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:PEND ACTIVE RCV STATE, ACTION = >
	HC	FSC0A0-F.CODE 	:ACTIVE STATE, ACTION = >
	HC	FSC010-F.CODE 	:PEND RESET SEND STATE, ACTION = 1
	HC	FSC010-F.CODE 	:PEND RESET RCV STATE, ACTION = 1
	HC	FSC0A0-F.CODE 	:PEND RESET SON STATE, ACTION = >

:	CHECK R, RQ, DACTCDRM INPUT
:------------------------------------------
FS500K
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R0,BBUFER+1,R5,		:GET 2ND BYTE OF RU
	NHI	R0,DC.DCT		:MASK FOR DEACTIVATION_TYPE (BITS4-7)
	CLHI	R0,SON			:SESSION OUTAGE NOTIFICATION?
	JE	FS500M			:YES

:================================================================
:	INPUT:	R, RQ, DACTCDRM, -SON
:=================================================================
	LHL	R5,TS500B,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS500B	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC060-F.CODE 	:PEND ACTIVE SEND STATE, ACTION = 6
:	HC	FSC060-SEG|a.CODE| :PN ACT RCV, ACT = 6 (03/27/86 MIA)
	HC	FSC060-F.CODE	:PEND ACT RCV, ACT = 6 (03/27/86 MIA)
	HC	FSC060-F.CODE 	:ACTIVE STATE, ACTION = 6
	HC	FSC060-F.CODE 	:PEND RESET SEND STATE, ACTION = 6
	HC	FSC000-F.CODE 	:PEND RESET RCV STATE, ACTION = -
	HC	FSC0A0-F.CODE 	:PEND RESET SON STATE, ACTION = >

:=====================================================================
:	INPUT:	R, RQ, DACTCDRM, SON
:=====================================================================
FS500M
	LHL	R5,TS500C,R7,R7  	:GET STATE ENTRY ROUTINE
	J	F.CODE,R5,,     
TS500C	HS	0
	HC	FSCIN-F.CODE 	:RESET STATE, ACTION = /
	HC	FSC070-F.CODE 	:PEND ACTIVE SEND STATE, ACTION = 7
	HC	FSC070-F.CODE 	:PEND ACTIVE RCV STATE, ACTION = 7
	HC	FSC070-F.CODE 	:ACTIVE STATE, ACTION = 7
	HC	FSC070-F.CODE 	:PEND RESET SEND STATE, ACTION = 7
	HC	FSC070-F.CODE 	:PEND RESET RCV STATE, ACTION = 7
	HC	FSC0A0-F.CODE 	:PEND RESET SON STATE, ACTION = >



	SUBTTL	INDEX FOR EACH FSM (IN SCB)

:	FSMSBL	-FSMSBL IS THE OFFSET TABLE FOR SCCB FSM ROUTINES
:	THE INDEX TO THIS TABLE NEEDS TO BE SETUP BEFORE THIS TABLE
:	BEING CALLED.
:	THE CONVENTION USED IN THIS MODULE IS AS FOLLOWS:
:	FXYYZZ	-- THIS CONVENTION IS FOR THE PROCESSES,LABELS
:		-- X INDICATES THE CONTROL BLOCK WHERE THE FSMS ARE LOCATED
:		-- YY IS THE INDEX OF THAT FSM IN SCB
:		-- ZZ IS FOR LABELS  (FROM 0 TO ZZ) USED BY PARTICULAR FSM
:	FXAYYZ	-- THIS IS THE CONVENTION USED BY ACTION CODE ROUTINES,
:		-- X INDICATES THE CONTROL BLOCK WHERE THE FSMS ARE LOCATED
:		-- A INDICATES THE SNA LAYER WHICH PRIMARILY USES THIS ACTION
:		   CODE, A = P (PATH CONTROL), T (TRANSMISSION CONTROL),
:		   D (DATA FLOW CONTROL), OR C (COMMON TO MORE THAN ONE LAYER).
:		-- YY INDICATES PARTICULAR ACTION CODE ROUTINE (FROM 0 TO ZZ)
:		-- Z IS FOR LABELS (FROM 0 TO Z) USED BY PARTICULAR ROUTINE.
:	------------------------------------------------------------

FSMSBL	HS	0
	HC	FSNOOP-F.CODE 	:NO-OP (NO FSMS ARE REQUIRED)
	HC	FS0000-F.CODE 	:FSM_BSM_BIDDER
	HC	FS0100-F.CODE 	:FSM_BSM_FSP
	HC	FS0200-F.CODE 	:FSM_CHAIN_RCV
	HC	FS0300-F.CODE 	:FSM_CHAIN_SEND
	HC	FS0400-F.CODE 	:FSM_CNTL_IMMED_EXP
	HC	FS0500-F.CODE 	:FSM_CONTROL_BSM_RSP_RCV
	HC	FS0600-F.CODE 	:FSM_CONTROL_BSM_RSP_SEND
	HC	FS0700-F.CODE 	:FSM_CONTROL_HDX_RSP_RCV
	HC	FS0800-F.CODE 	:FSM_CONTROL_HDX_RSP_RCV_ERP_DL
	HC	FS0900-F.CODE 	:FSM_CONTROL_HDX_RSP_RCV_ERP_IM
	HC	FS1000-F.CODE 	:FSM_CONTROL_HDX_RSP_SEND
	HC	FS1100-F.CODE 	:FSM_CONTROL_HDX_RSP_SEND_ERP_DL
	HC	FS1200-F.CODE 	:FSM_CONTROL_HDX_RSP_SEND_ERP_IM
	HC	FS1300-F.CODE 	:FSM_CRV_RCV
	HC	FS1400-F.CODE 	:FSM_CRV_SEND
	HC	FS1500-F.CODE 	:FSM_DT_RCV_CLEAR
	HC	FS1600-F.CODE 	:FSM_DT_RCV_SDT
	HC	FS1700-F.CODE 	:FSM_DT_RCV_SDT_AND_CLEAR
	HC	FS1800-F.CODE 	:FSM_DT_SEND_CLEAR
	HC	FS1900-F.CODE 	:FSM_DT_SEND_SDT
	HC	FS2000-F.CODE 	:FSM_DT_SEND_SDT_AND_CLEAR
	HC	FS2100-F.CODE 	:FSM_EBCD_RCV
	HC	FS2200-F.CODE 	:FSM_EBCD_SEND
	HC	FS2300-F.CODE 	:FSM_HDX_CONT_LOSER
	HC	FS2400-F.CODE 	:FSM_HDX_CONT_WINNER
	HC	FS2500-F.CODE 	:FSM_HDX_FF
	HC	FS2600-F.CODE 	:FSM_IMM_RQ_MODE_RCV
	HC	FS2700-F.CODE 	:FSM_IMM_RQ_MODE_SEND
	HC	FS2800-F.CODE 	:FSM_QEC_RCV
	HC	FS2900-F.CODE 	:FSM_QEC_SEND
	HC	FS3000-F.CODE 	:FSM_QRI_CHECK_SEND
	HC	FS3100-F.CODE 	:FSM_QRI_CHAIN_RCV
	HC	FS3200-F.CODE 	:FSM_QRI_CHAIN_SEND
	HC	FS3300-F.CODE 	:FSM_RES
	HC	FS3400-F.CODE 	:FSM_RQR_RCV
	HC	FS3500-F.CODE 	:FSM_RQR_SEND
	HC	FS3600-F.CODE 	:FSM_RTR_BIDDER
	HC	FS3700-F.CODE 	:FSM_RTR_FSP
	HC	FS3800-F.CODE 	:FSM_SBI_RCV
	HC	FS3900-F.CODE 	:FSM_SBI_SEND
	HC	FS4000-F.CODE 	:FSM_SESS_BF_SSCP_LU
	HC	FS4100-F.CODE 	:FSM_SESS_BF_SSCP_PU_T1
	HC	FS4200-F.CODE 	:FSM_SESS_BF_SSCP_PU_T2
	HC	FS4300-F.CODE 	:FSM_SESS_BF_LU_LU
	HC	FS4400-F.CODE 	:FSM_SESS_LU_LU_PRI
	HC	FS4500-F.CODE 	:FSM_SESS_LU_LU_SEC
	HC	FS4600-F.CODE 	:FSM_SESS_SSCP_LU_PRI
	HC	FS4700-F.CODE 	:FSM_SESS_SSCP_LU_SEC
	HC	FS4800-F.CODE 	:FSM_SESS_SSCP_PU_PRI
	HC	FS4900-F.CODE 	:FSM_SESS_SSCP_PU_SEC
	HC	FS5000-F.CODE 	:FSM_SESS_SSCP_SSCP_PRI_OR_SEC
	HC	FS5100-F.CODE 	:FSM_SESSION_BIU_ASSEMBLY
	HC	FS5200-F.CODE 	:FSM_SHUTD_RCV
	HC	FS5300-F.CODE 	:FSM_SHUTD_SEND
	HC	FS5400-F.CODE 	:FSM_STSN_RCV
	HC	FS5500-F.CODE 	:FSM_STSN_SEND




	FO	CBKDEF
	FO	CMDLST	
	
	EM				:END OF MODULE SSMF00.FNN


	SUBTTL	SNA PACKAGE(UTILITY ROUTINES) - TRANSMISSION CONTROL LAYER
:	MODULE NAME IN COMMAND FILE -- STCR00.F00

:	********************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	****************************************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT MISCELLANEOUS ROUTINES
:	WHICH ARE CALLED BY THE TRANSMISSION CONTROL LAYER PROCESSES.
:	PLEASE REFER TO THE PSEUDO-CODES IN CHAPTER 4 ON FAPL MANUE.
:	----------------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CBKDEF
	LO	BBUFER

	GL	T.CRAS


	SEG	A.DATA
	BND	10
T.RQTB	
	BC	RQR,CLEAR,SDT,CRV,STSN
T.RQLN	EQ	.-T.RQTB

	SEG	A.CODE

:	T.CRCK	-(TC.CPMGR.RCV_CHECKS) USAGE CHECKS ARE MADE FOR VALID
:	RU LENGTH AND VALID SEQUENCE NUMBER ON A NORMAL FLOW REQUEST.
:	IF CRYPTOGRAPHY IS TO BE USED, AN OPTIONAL CHECK IS MADE THAT
:	EDI IS SET WHEN ENCIPHERING IS MANDATORY AND THE LENGTH OF THE
:	RU IS CHECKED FOR BEING A MULTIPLE OF 8. THE SEESION ACTIVATION
:	STATE IS CHECKED AND AN OPTIONAL CHECK IS MADE FOR A NAU SERVICE
:	MANAGER FAILURE. THE PROCEDURE VERIFIES THAT ALL FSM'S ARE IN
:	THE PROPER STATE.
:	PAGE 4-38 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	-R1 (FOR RETURN CODE)
:	LINK	-R8
T.CRCK
	ST	R8,RGSAV8,,
:	CHECK THE SESSION ACTIVE OR NOT
:	==============================
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS
	LB	R2,SCBBLK+SCSTAT,R1,R9	:GET CURRENT STATE
	CLHI	R2,FS.ST3		:IS IT ACTIVE?(STATE 3)
	JN	T.CRC0			:JUMP TO DISCARD_MU,IF NOT ACTIVE
:	CHECK THE SEQUENCE NUMBER
:	===========================
	LB	R0,BBUFER+MUBIUF,R10,	:GET BIU FLAG FROM MUCB
	NHI	R0,MU.EFI		:MASK OFF OTHER BITS
	JN	T.CRCD			:JUMP,IF EFI<>NORMAL
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK OFF OTHER BITS
	JN	T.CRC6			:JUMP IF RRI=RSP
:	EFI=NORMAL AND RRI=RQ
:	---------------------
T.CRC2
	LB	R0,SCBBLK+SCSQUS,R9,	:GET SQN_USAGE
	CLHI	R0,SEQNUM		:IS SQN_USAGE=SEQUENCE_NUMBERS?
	JN	T.CRC6			:JUMP IF NOT EQU
	LB	R0,NCBBLK+NDPUTY,R13,	:GET NCB.PU_TYPE
	CLHI	R0,PU.T2		:IS PU_TYPE=PU_T2?
	JE	T.CRC5			:JUMP IF YES
	CLHI	R0,PU.T4		:IS PU_TYPE=PU_T4?
	JE	T.CRC5			:JUMP IF YES
	CLHI	R0,PU.T5		:IS PU_TYPE=PU_T5?
	JN	T.CRC6			:JUMP IF NOT
:	EFI=NORMAL & RRI=RQ & SCB.SQN_USAGE=SEQUENCE_NUMBERS &
:	NCB.PU_TYPE=PU_T2|PU_T4|PU_T5
:	SEQUENCE NUMBERS CHECK
:	------------------------------------------------------
T.CRC5
	LHI	R0,.SEQER		:SET SEQUENCE NUMBER ERROR (2001)
	LHL	R1,SCBBLK+SCSQRC,R9,	:GET SQN_RCV_CNT FROM SCB
	AIS	R1,1
:	CLH	R1,BBUFER+MUSNF,R10,	:MU.SNF TO SQN_RCV_CNT+1 (12/6/84 MIA)
	LHL	R5,BBUFER+MUSNF,R10,	:GET MU.SNF (12/6/84 MIA)
	CR	R1,R5			:COMP WITH SQN_RCV_CNT+1 (12/6/84 MIA)
	JN	T.CRC1			:JUMP IF NOT EQU
	STH	R1,SCBBLK+SCSQRC,R9,	:STORE SCB.SQN_RCV_CNT
:	USAGE CHECKS -- VALID RU LENGTH
:	=================================
T.CRC6
	L	R0,TCBBLK+TCMRRU,R15,	:GET TCCB.MAX_RCV_RU_SIZE
	JE	T.CRCC			:JUM IF TCCB.MAX_RCV_RU_SIZE=0
	LHL	R5,BBUFER+MUDCF,R10,	:GET DCF FROM MUCB
	SIS	R5,RHLENG		:DCF-RH_LENGTH
	CR	R5,R0			:(DCF-RH_LENGTH)>TCCB.MAX_RCV_RU_SIZE ?
	JLE	T.CRCC			:JUMP IF NOT
:	EFI=NORMAL & TCCB.MAX_RCV_RU_SIZE<>NOT_SPECIFIED &
:	(DCF-RH_LENGTH)>TCCB.MAX_RCV_RU_SIZE
:	VALID RU LENGTH
:	----------------------------------------------------
T.CRC9
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK OFF OTHER BITS
	JN	T.CRC0			:JUMP IF RRI=RSP
	LHI	R0,.RULER		:SET RU LENGTH ERROR (1002)
T.CRC1
	JAL	R5,R.MUEX,,		:CALL CHANGE_MU_TO_EXR
	LHI	R1,CVTEXR		:SET RETURN CODE CONVERT_TO_EXR
	J	T.CRCF			:RETURN
:	USAGE CHECKS -- PACING CHECK
:	================================
T.CRCC
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK OFF OTHER BITS
	JN	T.CRCD			:JUMP IF RRI=RSP
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.PI		:CHECK THE PACING INDICATOR
	JE	T.CRC4			:JUMP,IF PI<>PAC
	LB	R0,TCBBLK+TCCBFG,R15,	:GET RCV_PACING BIT FROM TCCB
	NHI	R0,TC.RPA		:MASK OTHER BITS FOR RCV_PACING
	JN	T.CRC4			:JUMP,RCV_PACING<>NO
	LB	R0,SCBBLK+SCTSPF,R9,	:GET SCB.TS_PROFILE
	CLHI	R0,PROF02		:IS THIS PROFILE 2?
	JE	T.CRC3			:JUMP,IF YES
	CLHI	R0,PROF03		:IS THIS PROFILE 3?
	JE	T.CRC3			:JUMP,IF YES
	CLHI	R0,PROF04		:IS THIS PROFILE 4?
	JE	T.CRC3			:JUMP,IF YES
	CLHI	R0,PROF07		:IS THIS PROFILE 7?
	JE	T.CRC3			:JUMP,IF YES
	CLHI	R0,PROF17		:IS THIS PROFILE 17?
	JN	T.CRC4			:JUMP,IF NOT
:	RRI=RQ & EFI=NORMAL & PI=PAC & TCCB.RCV_PACING=NO &
:	SCB.TS_PROFILE=PROFILE2|PROFILE3|PROFILE_4|PROFILE_7|PROFILE_17
:	PACING CHECK
:	--------------------------------------------------------------------
T.CRC3
	JAL	R7,R.RQN,,		:JUMP TO CHECK MSG HAS RESPONSE MADE
	J	T.CRCE			:JUMP,IF NOT OK
T.CRC0
	LHI	R1,DCARMU		:SET RETURN CODE DISCARD_MU
	J	T.CRCF			:RETURN
T.CRCE
	LHI	R0,.PGNSU		:SETUP PACING NOT SUPPORTED (4008)
	JAL	R5,R.MUNR,,		:JUMP TO CALL CHANGE_MU_TO_NEG_RSP
	LHI	R1,NEGRSP		:SET RETURN CODE NEG_RSP
	J	T.CRCF			:RETURN

:	USAGE CHECKS -- DECIPHERING FUNCTION CHECKS
:	============================================
T.CRC4
	LB	R0,SCBBLK+SCCYSL,R9,	:GET CRYPTOGRAPHY_SESSION_LEVEL
	CLHI	R0,MANDAT		:IS ITS MANDATORY?
	JE	T.CRCB			:JUMP,IF IT IS MANDATORY
	CLHI	R0,SELECT		:IS IT SELECTIVE?
	JN	T.CRCD			:JUMP,IF NOT SELECTIVE
	LB	R0,BBUFER+MURHF3,R10,	:GET 3ND BYTE OF RH
	NHI	R0,MU.EDI		:MASK OFF OTHER BITS
	JE	T.CRCD			:JUMP IF EDI<>ED
T.CRCB
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF FROM MUCB
	CLHI	R0,RHLENG		:IS DCF=RH_LENGTH (3)?
	JE	T.CRCD			:YES,JUMP TO NEXT IF STATEMENT
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.SDI		:MASK OFF OTHER BITS
	JN	T.CRCD			:JUMP,WHEN SDI<>SD
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTGY
	JN	T.CRCD			:JUMP IF IT IS NOT FMD

:	RRI=RQ & EFI=NORMAL & RU_CTGY=FMD & SDI<>SD & DCF<>RH_LENGTH
:	(SCB.CRYPTOGRAPHY_SESSION_LEVEL=MANDATORY | 
:	(SCB.CRYPTOGRAPHY_SESSION_LEVEL=SELECTIVE & EDI=ED))
:	DECIPHERING FUNCTION CHECKS
:	------------------------------------------------------------
T.CRC7
	LHI	R0,.MODCN		:SET MODE INCONSISTENCY (0809)
	LB	R1,BBUFER+MURHF3,R10,	:GET 3ND BYTE OF RH
	NHI	R1,MU.EDI		:MASK OFF OTHER BITS
	JE	T.CRC1			:JUMP IF EDI<>ED
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF FROM MUCB
	SIS	R0,RHLENG		:GET DCF-RHLENG
	LR	R1,R0			:SAVE DCF-RHLENG
	NHI	R0,@MODUL8		:MASK OFF BIT 7,6,5
	SR	R1,R0			:GET THE DIFFERENCE
	JE	T.CRCD			:JUMP,IF MODULE OF 8 IS 0
	LHI	R0,.RUDER		:SET RU DATA ERROR (1001)
	J	T.CRC1

:	USAGE CHECKS -- STATE CHECKS
:	==============================
:	EFI=NORMAL AND RRI=RSP
:	EFI<>NORMAL
:	CHECK NAU SERVICE MANAGER FAILURE OR NOT
:	CHECK DATA TRAFFIC FLOW  FSM
:	------------
T.CRCD
:	CHECK FOR NAU SERVICE MANAGER FAILURE ??????
:	-------------------------------------------------
	LHI	R1,FSCCIE		:GET INDEX OF FSM_CNTL_IMMED_EXP
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.CRCF			:JUMP,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFMDT,R9,	:SET UP #FSM_DT INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.CRCF			:JUMP,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFMCR,R9,	:SET UP #FSM_CRV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JNFS	T.CRCF			:JUMP RETURN,IF 'TRUE' FROM FSM
T.CRC8
	LHI	R1,GOOD			:SET RETURN CODE GOOD
T.CRCF
	L	R8,RGSAV8,,
	JR	R8			:RETURN

:	T.CRNR	-(TC.CPMGR.RCV.NORM_RQ) DECIPHER A NORMAL-FLOW REQUEST
:	IF NECESSARY AND UPDATE PACING FSM
:	PAGE 4-40 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	-
:	LINK	-R8
T.CRNR
	LB	R0,SCBBLK+SCCYSL,R9,	:GET CRYPTOGRAPHY_SESSION_LEVEL
	CLHI	R0,MANDAT		:IS ITS MANDATORY?
	JE	T.CRN2			:JUMP,IF IT IS MANDATORY
	CLHI	R0,SELECT		:IS IT SELECTIVE?
	JN	T.CRN0			:JUMP,IF NOT SELECTIVE
	LB	R0,BBUFER+MURHF3,R10,	:GET 3ND BYTE OF RH
	NHI	R0,MU.EDI		:MASK OFF OTHER BITS
	JE	T.CRN0			:JUMP IF EDI<>ED
T.CRN2
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF FROM MUCB
	CLHI	R0,RHLENG		:IS DCF=RH_LENGTH (3)?
	JE	T.CRN0			:YES,JUMP TO NEXT IF STATEMENT
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.SDI		:MASK OFF OTHER BITS
	JN	T.CRN0			:JUMP,WHEN SDI<>SD
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTGY
	JN	T.CRN0			:JUMP IF IT IS NOT FMD
	JAL	R5,DECIPH,,		:CALL DECIPHER
T.CRN0
:	IF TCCB.RCV_PACING=YES THEN CALL FSM_PAC_RQ_RCV
	LB	R0,TCBBLK+TCCBFG,R15,	:GET RCV_PACING BIT FROM TCCB
	NHI	R0,TC.RPA		:MASK OTHER BITS FOR RCV_PACING
	JER	R8			:RETURN,IF RCV_PACING=NO
	LHI	R1,FTCPRR		:GET INDEX OF FSM_PAC_RQ_RCV
	LIS	R0,0			:CLEAR FSMINPUT
	ST	R8,RGSAV8,,
:	JAL	R3,R.FTMR,,		:CALL FSM (TCCB) ROUTINE (6/17/85 MIA)
	LIS	R6,FS.CAL		:SETUP FSM CALL (06/18/85 MIA)
	JAL	R4,R.FTMR,,		:CALL FSM (TCCB) ROUTINE (6/17/85 MIA)
	L	R8,RGSAV8,,
	JR	R8			:RETURN

:	T.CSCK	-(TC.CPMGR.SEND_CHECKS) THIS PROCEDURE PERFORMS THE
:	CONNECTION POINT MANAGER USAGE AND STATE SEND ERROR CHECKS
:	PAGE 4-32 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:NORMAL RETURN IF NOT OK,SKIP RETURN IF OK
:	LINK	-R8
T.CSCK
	ST	R8,RGSAV8,,
	LIS	R0,0			:CLEAR VALUE X'0000'
	ST	R0,BBUFER+MUSCKS,R10,	:SET MUCB.SEND_CHECK_SENSE
:	CHECK THE SESSION ACTIVE OR NOT
:	==============================
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS
	LB	R2,SCBBLK+SCSTAT,R1,R9	:GET CURRENT STATE
	CLHI	R2,FS.ST3		:IS IT ACTIVE?(STATE 3)
	JE	T.CSC0			:JUMP,IF IT IS ACTIVE
	LHI	R0,.NOSES		:GET SENSE CODE '8005' FOR NO SESSION
	J	T.CSC7			:JUMP TO CHECK RETURN VALUE
:	USAGE CHECKS
:	===========
T.CSC0
	LB	R0,BBUFER+MUBIUF,R10,	:GET BIU FLAG FROM MUCB
	NHI	R0,MU.EFI		:MASK OFF OTHER BITS
	JN	T.CSC5			:JUMP,IF EFI<>NORMAL
	LHI	R2,MURHF1
	LHL	R1,SCBBLK+SCTCCB,R9,	:GET TCCB PTR
	L	R0,TCBBLK+TCMRRU,R1,	:GET TCCB.MAX_SEND_RU_SIZE
:	JE	T.CSC5			:TCCB.MAX_SEND_RU_SIZE=0 (7/10/85 MIA)
	JE	T.CSC8			:TCCB.MAX_SEND_RU_SIZE=0 (7/10/85 MIA)
	LHL	R5,BBUFER+MUDCF,R10,	:GET DCF FROM MUCB
	SIS	R5,RHLENG		:DCF-RH_LENGTH
	CR	R5,R0			:(DCF-RH_LENGTH)>TCCB.MAX_SEND_RU_SIZE?
:	JLE	T.CSC5			:JUMP IF NOT (07/10/85 MIA)
	JLE	T.CSC8			:JUMP IF NOT (07/10/85 MIA)
	LHI	R0,.RULER		:GET SENSE CODE '1002' FOR INVALID RU
	J	T.CSC7			:JUMP TO CHECK RETURN VALUE
T.CSC5
:	STATE CHECKS 
:	============
	LHI	R1,FSCCIE		:GET INDEX OF FSM_CNTL_IMMED_EXP
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.CSC1			:JUMP,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFMDT,R9,	:SET UP #FSM_DT INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.CSC1			:JUMP,IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFMCR,R9,	:SET UP #FSM_CRV INDEX
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JE	T.CSC2			:JUMP,IF 'FALSE' FROM FSM
T.CSC1
T.CSC2
	LB	R0,BBUFER+MUBIUF,R10,	:GET BIU FLAG FROM MUCB
	NHI	R0,MU.EFI		:MASK OFF OTHER BITS
	JN	T.CSC8			:JUMP,IF EFI<>NORMAL
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK OFF OTHER BITS
	JE	T.CSC6			:JUMP IF RRI=RQ
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.QRI		:CHECK THE QRI BIT
	JE	T.CSC8			:JUMP,IF QRI<>QR
:	PACING QUEUE FULL OR NOT 
T.CSC6
	JAL	R4,U.PQFU,,		:CHECK PACING QUEUE FULL OR NOT?
	J	T.CSC8			:JUMP,IF PACING QUEUE IS NOT FULL
	LHI	R0,.RRISR		:ELSE,SET TO INSUFFICIENT RESOURCE
T.CSC7
	ST	R0,BBUFER+MUSCKS,R10,	:SET MUCB.SEND_CHECK_SENSE
T.CSC8
	L	R0,BBUFER+MUSCKS,R10,	:GET MUCB.SEND_CHECK_SENSE
	JE	T.CSCA			:SKIP RETURN,IF OK (SENSE CODE IS 0)
T.CSC9
	L	R8,RGSAV8,,
	JR	R8			:RETURN
T.CSCA
	L	R8,RGSAV8,,
	J	4,R8

:	T.CSNQ	-(TC.CPMGR.SEND_NORM_RQ) ENCIPHER A NORMAL-FLOW REQUEST
:	IF NECESSARY AND DETERMINE IF IT IS TO BE PACED.
:	PAGE 4-33 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	-
:	LINK	-R8
T.CSNQ
	LB	R0,SCBBLK+SCCYSL,R9,	:GET CRYPTOGRAPHY_SESSION_LEVEL
	CLHI	R0,MANDAT		:IS ITS MANDATORY?
	JE	T.CSN1			:JUMP,IF IT IS MANDATORY
	CLHI	R0,SELECT		:IS IT SELECTIVE?
	JN	T.CSN6			:JUMP,IF IT IS NOT SELECTIVE
	LB	R0,BBUFER+MURHF3,R10,	:GET 3ND BYTE OF RH
	NHI	R0,MU.EDI		:MASK OFF OTHER BITS
	JE	T.CSN6			:JUMP IF EDI<>ED
T.CSN1
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF FROM MUCB
	CLHI	R0,RHLENG		:IS DCF=RH_LENGTH (3)?
	JE	T.CSN6			:YES,JUMP TO NEXT IF STATEMENT
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.SDI		:MASK OFF OTHER BITS
	JN	T.CSN6			:JUMP,WHEN SDI=SD
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTGY
	JN	T.CSN6			:JUMP IF IT IS NOT FMD
:	RRI=RQ & EFI=NORMAL & RU_CTGY=FMD & SDI<>SD & DCF<>RH_LENGTH
:	(SCB.CRYPTOGRAPHY_SESSION_LEVEL=MANDATORY | 
:	(SCB.CRYPTOGRAPHY_SESSION_LEVEL=SELECTIVE & EDI=ED))
:	------------------------------------------------------------
:	CALL RU_PAD
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF FROM MUCB
	LR	R4,R0			:SAVE DCF
	SIS	R0,RHLENG		:GET DCF-RHLENG
	LR	R1,R0			:SAVE DCF-RHLENG
	LR	R3,R0			:SAVE DCF-RHLENG
	NHI	R0,@MODUL8		:MASK OFF BIT 7,6,5
	SR	R1,R0			:GET THE DIFFERENCE
:	R1 CONTAINS MODULO(DCF-RH_LENGTH,8) R3 CONTAINS (DCF-RHLENG)
:	R4 CONTAINS DCF
	LIS	R0,8			:SET R0 TO 8
	SR	R0,R1			:PAD=8-MODULO(DCF-RHLENG,8)
	CLHI	R0,8			:CHECK PAD=8 OR NOT
	JE	T.CSN9			JUMP,IF PAD=8
:	R0 CONTAINS PAD
:	RU=RU(0:DCF-RH_LENGTH-1)||UPM_PAD(PAD-1)||PAD_ALIAS(1:1)
:	DCF=DCF+PAD
:	PDI=PD
	AR	R4,R0			:DCF=DCF+PAD
	STH	R4,BBUFER+MUDCF,R10,	:STORE DCF=DCF+PAD INTO MUCB
	LB	R0,BBUFER+MURHF3,R10,	:GET 3ND BYTE OF RH
	OHI	R0,MU.PDI		:SET PDI BIT
	STB	R0,BBUFER+MURHF3,R10,	:STORE PDI=PD INTO MUCB
	J	T.CSN5
:	PDI<>PD
T.CSN9
	LB	R0,BBUFER+MURHF3,R10,	:GET 3ND BYTE OF RH
	NHI	R0,@MU.PDI		:MASK OFF PDI BIT
	STB	R0,BBUFER+MURHF3,R10,	:STORE PDI=PD INTO MUCB
:	IF UPM_ENCIPHER=NG THEN MUCB.SEND_CHECK_SENSE=X'0848'
T.CSN5
	JAL	R4,U.ENCI,,		:CALL UPM_ENCIPHERING=NG OR NOT?
	J	T.CSN2			:UPM_ENCIPHERING=NG,JUMP
	J	T.CSN6			:UPM_ENCIPHERING<>NG,JUMP
T.CSN2
	LHI	R0,.RRCFI		:SET CRYPTOGRAPHY FUNCTION INOPERATIVE
	ST	R0,BBUFER+MUSCKS,R10,	:SET MUCB.SEND_CHECK_SENSE
:	CHECK TCCB.SEND_PACING AND RETURN VALUE
:	---------------------------------------
T.CSN6
	LB	R0,TCBBLK+TCCBFG,R15,	:GET SEND_PACING BIT FROM TCCB
	NHI	R0,TC.SPA		:MASK OTHER BITS FOR SEND_PACING
	JN	4,R8			:SKIP RETURN,SEND_PACING<>NO
	JR	R8			:RETURN

:	T.CSNP	-(TC.CPMGR.SEND_NORM_RSP) PROCESS A NORMAL-FLOW RESPONSE
:	BY DETERMINING IF A SESSION-LEVEL PACING PACING RESPONSE SHOULD
:	BE INCLUDED AND IF THIS RESPONSE SHOULD BE PLACED ON THE PACING
:	QUEUE.
:	PAGE 4-33 ON FAPL
: ATTENTION: THIS PROCEDURE IN FAPL HAS A BUG. IT SHOULD HAVE CHECKED
: TCCB.RCV_PACING = YES RATHER THAN TCCB.SEND_PACING = YES.
: THE CODE WAS CHANGED CORRESPONDINGLY (09/05/85 MIA).
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	-
:	LINK	-R8
T.CSNP
	LB	R0,TCBBLK+TCCBFG,R15,	:GET SEND_PACING BIT FROM TCCB
:	NHI	R0,TC.SPA		:SEND_PACING? (09/05/85 MIA)
	NHI	R0,TC.RPA		:RCV_PACING? (09/05/85 MIA)
	JER	R8			:NORMAL RETURN,IF SEND_PACING=NO
T.CSN7
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.QRI		:CHECK THE QRI BIT
	JE	T.CSN8			:JUMP,IF QRI<>QR
:	CHECK EMPTY(TCCB.Q_PAC)
:	----------------------
	LHL	R6,TCBBLK+TCQSPG,R15,	:GET GET POINTER FOR Q_PAC
:	CLH	R6,TCBBLK+TCQSPR,R15,	:COMP GET TO RL PTR (03/13/85 MIA)
	LHL	R0,TCBBLK+TCQSPR,R15,	:GET REL POINTER (03/13/85 MIA)
	CR	R6,R0			:COMP GET TO RL PTR (03/13/85 MIA)
	JN	4,R8			:SKIP,RETURN (YES),Q_PAC IS NOT EMPTY
:	CHECK FSM_PAC_RQ_RCV=PEND& UPM_RESOURCES=OK, CALL FSM_PAC_RQ_RCV
T.CSN8
	LHI	R1,FTCPRR		:GET INDEX OF FSM_PAC_RQ_RCV
	LB	R2,TCBBLK+TCSTAT,R1,R15	:GET CURRENT FSM STATE
	CLHI	R2,FS.ST2		:IS IT PENDING STATE?
	JNR	R8			:RETURN (NO),IF NOT IN STATE 'PEND'
	JAL	R4,U.RESO,,		:CALL UPM_RESOURCES
	J	0,R8			:RETURN (NO) IF NOT OK
	LIS	R0,0			:CLEAR FSMINPUT
	ST	R8,RGSAV8,,
:	JAL	R3,R.FTMR,,		:CLL FSM (TCCB) ROUTINE (06/17/85 MIA)
	LIS	R6,FS.CAL		:SETUP FSM CALL (06/18/85 MIA)
	JAL	R4,R.FTMR,,		:CLL FSM (TCCB) ROUTINE (06/17/85 MIA)
	L	R8,RGSAV8,,
	JR	R8			:NORMAL RETURN,FOR (NO)

:					:(12/18/85/TTW)
:	T.PRRV  -(PAC_RSP_RCV) IF MESSAGE UNIT IS AN IPR OR RESPONSE
:	WITH PI=PAC, THE RECEIPT OF A PAC_RSP IS NOTED.  IF THE MESSAGE
:	UNIT IS AN IPR, IT IS DISCARDED AND THE RETURN CODE IS SET TO
:	INDICATE THIS ACTION.  IF IT IS A RESPONSE WITH A PI = PAC, PI
:	IS SET TO -PAC AND THE PIU IS RETURNNED TO FURTHER PROCESSING.
:	PAGE 4-41 ON FAPAL
:	------------------------------------------------------------------
:
:	INPUT   :
:	OUTPUT  :R1 (YES = IPR_DISCARDED)
:	LINK    :R8
T.PRRV
	ST	R8,RGSAV8,,
:	IF TCCB.SEND_PACING = YES
	LHL	R15,SCBBLK+SCTCCB,R9,	:GET TCCB PTR(12/24/85/CHS)
	JLE	T.CRAS			:CRASH IF TCCB_PTR IS NULL
	LB	R5,TCBBLK+TCCBFG,R15,	:GET CONTROL FLAG
:	NHI	R5,TC.RPA		:MASK OF OTHER BITS (01/09/86/CHS)
	NHI	R5,TC.SPA		:MASK OF OTHER BITS (01/09/86/CHS)
	JE	T.PRR5			:SKIP IF TCCB.SEND_PACING=NO
:	CHECK IF RRI = RSP & PI = PAC
	LB	R5,BBUFER+MURHF1,R10,	:GET FLAG BYTE TO CHECK RRI
	NHI	R5,MU.RRI		:MASK FOR RRI
	JE	T.PRR8			:SKIP IF RRI=RQ
	LB	R5,BBUFER+MURHF2,R10,	:GET FLAG TO CHECK PI
	NHI	R5,MU.PI		:MASK FOR PI
	JE	T.PRR8			:SKIP IF PI <> PAC
:	CALL FSM_PAC_RQ_SEND
	LHI	R1,FTCPRS		:SET INDEX OF FSM_PAC_RQ_SEND
	LIS	R0,0			:CLEAR FSM INPUT
	LIS	R6,FS.CAL		:SET FSM CALL
	JAL	R4,R.FTMR,,		:CALL FSM (TCCB) ROUTINE
:	CHECK IF IPR_CHECK = YES
T.PRR5
	JAL	R8,T.IRCK		:GO IPR_CHECK
	CLHI	R1,YES			:CHECK RETURN CODE
	JNFS	T.PRR8			:SKIP IF IPR_CHECK=NO
	JAL	R8,R.DSMU,,		:DISCARD MU
	LHI	R1,YES			:RETURN CODE = YES
	J	T.PRR9
T.PRR8	LHI	R1,NO		:SET RETURN CODE=NO
T.PRR9	L	R8,RGSAV8,,
	JR	R8



:	T.SRCK	-(TC.SC.RCV_CHECKS) VERIFIES THAT THE FUNCTION REQUESTED 
:	IS SUPPORTED BY THIS HALF-SESSION AND THAT ALL FSM'S ARE IN THE
:	PROPER STATE FOR THE MESSAGE UNIT TO BE PROCESSED.
:	PAGE 4-45 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:R1 CONTAINS THE RETURN CODE (GOOD,DISCARD_MU,NEG_RSP)
:	LINK	-R8
T.SRCK
	ST	R8,RGSAV8,,
	JAL	R6,T.SFNS,,		:CALL TC.SC_FUNCTION_SUPPORTED
	J	T.SRC2			:JUMP IF THE RETURN IS NG
	J	T.SRC1			:JUMP,IF THE RETURN IS GOOD
T.SRC2
	LB	R3,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R3,MU.RRI		:MASK OFF OTHER BITS
	JN	T.SRC0			:JUMP IF RRI=RSP
	LHI	R0,.RQEFN		:SETUP FUNCTION NOT SUPPORTED (1003)
	JAL	R5,R.MUNR,,		:JUMP TO CALL CHANGE_MU_TO_NEG_RSP
	LHI	R1,NEGRSP		:SET RETURN CODE NEG_RSP
	J	T.SRC3			:RETURN
T.SRC0
	LHI	R1,DCARMU		:SET RETURN CODE TO DISCARD_MU
	J	T.SRC3			:RETURN
T.SRC1
	JAL	R6,T.SFCK,,		:CALL TC.SC_FORMAT_CHECK
	CLHI	R1,GOOD			:CHECK RETURN CODE IS GOOD OR NOT?
	JN	T.SRC3			:RETURN,IF TC.SC_FORMAT_CHECK=NG
:	WHEN TC.SC_FORMAT_CHECK<>NG,CHECK ALL THE FSM'S 
:	-----------------------------------------------------
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFMST,R9,	:SET UP #FSM_STSN INDEX
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.SRC3			:(RECEIVE_CHECK IN R1) WHEN FSM IS TRUE
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFMDT,R9,	:SET UP #FSM_DT INDEX
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.SRC3			:(RECEIVE_CHECK IN R1) WHEN FSM IS TRUE
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFMCR,R9,	:SET UP #FSM_CRV INDEX
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.SRC3			:(RECEIVE_CHECK IN R1) WHEN FSM IS TRUE
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFMRQ,R9,	:SET UP #FSM_RQR INDEX
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.SRC3			:(RECEIVE_CHECK IN R1) WHEN FSM IS TRUE
	LHI	R1,GOOD			:SET RETURN CODE GOOD
T.SRC3
	L	R8,RGSAV8,,
	JR	R8			:RETURN

:	T.SFCK	-(TC.SC_FORMAT_CHECK) CHECKS THE RH BITS OF THE REQUEST OR
:	RESPONSE.
:	PAGE 4-46 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:R1 CONTAINS THE RETURN CODE (GOOD,DISCARD_MU,NEG_RSP)
:	LINK	-R6
T.SFCK
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.RRI		:MASK OFF OTHER BITS
	JN	T.SFC1			:JUMP,IF RRI=RSP
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	LR	R4,R0			:SETUP R4 FOR WORKING REGISTER
	NHI	R4,MU.SC		:MASK OFF OTHER BITS
	CLHI	R4,MU.SC
	JN	T.SFC0			:JUMP,IF RU_CTGY<>SC
	LR	R4,R0			:GET BACK 1ST BYE OF RH
	THI	R4,MU.FI		:TEST BITS
	JE	T.SFC0			:JUMP,IF FI<>1
	THI	R4,MU.SDI		:TEST BITS
	JN	T.SFC0			:JUMP,IF SDI=SD
	THI	R4,MU.BCI		:TEST BITS
	JE	T.SFC0			:JUMP,IF BCI<>BC
	THI	R4,MU.ECI		:TEST BITS
	JE	T.SFC0			:JUMP,IF ECI<>EC
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R0,MU.DR1		:TEST BITS
	JE	T.SFC0			:JUMP,IF DR1I<>DR1
	THI	R0,MU.DR2		:TEST BITS
	JN	T.SFC0			:JUMP,IF DR2I=DR2
	THI	R0,MU.ERI		:TEST BITS
	JN	T.SFC0			:JUMP,IF ERI=ER
	THI	R0,MU.QRI		:TEST BITS
	JN	T.SFC0			:JUMP,IF QRI=QR
	THI	R0,MU.PI		:TEST BITS
	JN	T.SFC0			:JUMP,IF PI=PI
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	THI	R0,MU.CSI		:TEST BITS FOR CSI
	JN	T.SFC0			:JUMP,IF EDI<>ED
	THI	R0,MU.EDI		:TEST BITS FOR EDI
	JN	T.SFC0			:JUMP,IF EDI<>ED
	THI	R0,MU.PDI		:TEST BITS FOR PDI
	JN	T.SFC0			:JUMP,IF EDI<>ED
	THI	R0,MU.EBI		:TEST BITS FOR EBI
	JN	T.SFC0			:JUMP,IF EBI=EB
	THI	R0,MU.BBI		:TEST BITS FOR BBI
	JN	T.SFC0			:JUMP,IF EBI=EB
	THI	R0,MU.CDI		:TEST BITS FOR CDI
	JNFS	T.SFC0			:JUMP,IF EBI=EB
	LHI	R1,GOOD			:SET RETURN CODE TO GOOD
	JR	R6			:RETURN THE RECEIVE_CHECK
T.SFC0
	JAL	R7,R.RQN,,		:JUMP TO CHECK MSG HAS RESPONSE MADE
	J	T.SFC3			:JUMP,IF NOT OK
	J	T.SFC2			:JUMP,IT IS OK
T.SFC3
	LHI	R0,.RHESC		:SETUP INVALID SC RH (4001)
	JAL	R5,R.MUNR,,		:JUMP TO CALL CHANGE_MU_TO_NEG_RSP
	LHI	R1,NEGRSP		:SET RETURN CODE NEG_RSP
	JR	R6			:RETURN
:	RRI=RSP,DO THE CHECKING FOR RSP
:	-------------------------------
T.SFC1
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	LR	R4,R0			:SETUP R4 FOR WORKING REGISTER
	NHI	R4,MU.SC		:MASK OFF OTHER BITS
	CLHI	R4,MU.SC
	JN	T.SFC2			:JUMP,IF RU_CTGY<>SC
	LR	R4,R0			:SETUP R4 FOR WORKING REGISTER
	THI	R4,MU.FI		:TEST BITS
	JE	T.SFC2			:JUMP,IF FI<>1
	THI	R4,MU.BCI		:TEST BITS
	JE	T.SFC2			:JUMP,IF BCI<>BC
	THI	R4,MU.ECI		:TEST BITS
	JE	T.SFC2			:JUMP,IF ECI<>EC
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R0,MU.DR1		:TEST BITS
	JE	T.SFC2			:JUMP,IF DR1I<>DR1
	THI	R0,MU.DR2		:TEST BITS
	JN	T.SFC2			:JUMP,IF DR2I=DR2
	THI	R0,MU.QRI		:TEST BITS
	JN	T.SFC2			:JUMP,IF QRI=QR
	THI	R0,MU.PI		:TEST BITS
	JNFS	T.SFC2			:JUMP,IF PI=PI
	LHI	R1,GOOD			:SET RETURN CODE TO GOOD
	JR	R6			:RETURN THE RECEIVE_CHECK
T.SFC2
	LHI	R1,DCARMU		:SET RETURN CODE TO DISCARD_MU
	JR	R6			:RETURN

:	T.SSCK	-(TC.SC.SEND_CHECKS) VERIFIES THAT THE FUNCTION REQUESTED 
:	IS SUPPORTED BY THIS HALF-SESSION AND THAT ALL FSM'S ARE IN THE
:	PROPER STATE FOR THE MESSAGE UNIT TO BE PROCESSED.
:	PAGE 4-48 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:NORMAL RETURN IF NOT OK,SKIP RETURN IF OK
:	LINK	-R8
T.SSCK
	ST	R8,RGSAV8,,
	JAL	R6,T.SFNS,,		:CALL TC.SC_FUNCTION_SUPPORTED
	J	T.SSC0			:JUMP IF THE RETURN IS NG
T.SSC1
:	WHEN TC.SC_FUNCTION_SUPPORTED<>NG,CHECK ALL THE FSM'S
:	-----------------------------------------------------
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS
	LB	R2,SCBBLK+SCSTAT,R1,R9	:GET CURRENT STATE
	CLHI	R2,FS.ST3		:IS IT ACTIVE?(STATE 3)
	JE	T.SSC2			:JUMP,IF IT IS ACTIVE
	LHI	R0,.NOSES		:GET SENSE CODE '8005' FOR NO SESSION
	J	T.SSC5

T.SSC2
	LIS	R0,0			:CLEAR FSMINPUT
	LHI	R1,FSCCIE		:GET INDEX OF FSM_CNTL_IMMED_EXP
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.SSC3			:RETURN (NG) IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFMDT,R9,	:SET UP #FSM_DT INDEX
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.SSC3			:RETURN (NG) IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFMCR,R9,	:SET UP #FSM_CRV INDEX
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.SSC3			:RETURN (NG),IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFMST,R9,	:SET UP #FSM_STSN INDEX
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	T.SSC3			:RETURN (NG) IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFMRQ,R9,	:SET UP #FSM_RQR INDEX
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JEFS	T.SSC4			:SKIP RETURN,IF NOT TRUE FROM FSM
T.SSC3
	L	R8,RGSAV8,,
	JR	R8			:RETURN
T.SSC4
	L	R8,RGSAV8,,
	J	4,R8
T.SSC0
	LHI	R0,.RQEFN		:SETUP FUNCTION NOT SUPPORTED (1003)
T.SSC5
	ST	R0,BBUFER+MUSCKS,R10,	:SET MUCB.SEND_CHECK_SENSE
	J	T.SSC3			:NORMAL RETURN FOR NG

:	T.SFST	-(TC.SC_FORMAT_SET) SET THE RH BITS OF THE REQUEST OR
:	RESPONSE.
:	PAGE 4-49 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	-
:	LINK	-R8
T.SFST
	LB	R0,BBUFER+MUBIUF,R10,	:GET BIU FLAG FROM MUCB
	OHI	R0,MU.EFI		:SET EFI TO EXPEDITED
	STB	R0,BBUFER+MUBIUF,R10,	:STORE NEW VALUE INTO MUCB
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	OHI	R0,MU.BCI+MU.ECI+MU.FI+MU.SC	
	LB	R3,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	OHI	R3,MU.DR1		:SET D1I TO DR1
:	SET DR2I=<>DR2,QRI=<>QR,PI=<>PAC
	NHI	R3,@(MU.DR2+MU.QRI+MU.PI)
:	R0 CONTAINS NEW VALUE FOR MURHF1 (THIS VALUE IS FOR BOTH RQ AND RSP)
:	R3 CONTAINS NEW VALUE FOR MURHF2 (THIS VALUE IS FOR BOTH RQ AND RSP)
:	--------------------------------------------------------------------
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.RRI		:MASK OFF OTHER BITS
	JN	T.SFS1			:JUMP,IF RRI=RSP
:	RRI=RQ,SOME MORE BITS NEED TO BE UPDATED
:	----------------------------------------
	NHI	R0,@MU.SDI		:SET SDI TO <>SD
	NHI	R3,@MU.ERI		:SET ERI TO <>ER
	LB	R4,BBUFER+MURHF3,R10,	:GET 3ND BYTE OF RH
:	SET BBI =<>BB,EBI =<>EB,EDI =<>ED,PDI =<>PD,CDI=<>CD,CSI=CODE0
	NHI	R4,@(MU.BBI+MU.EBI+MU.EDI+MU.PDI+MU.CDI+MU.CSI)
	STB	R4,BBUFER+MURHF3,R10,	:STORE NEW MURHF3 INTO MUCB
T.SFS1
	STB	R3,BBUFER+MURHF2,R10,	:STORE NEW MURHF2 INTO MUCB
	STB	R0,BBUFER+MURHF1,R10,	:STORE NEW MURHF1 INTO MUCB
	JR	R8			:RETURN

:	T.SFNS	-(TC.SC_FUNCTION_SUPPORTED) VERIFIES THE FUNCTIONS REQUESTED 
:	IS SUPPORTED BY THIS HALF-SESSION.
:	PAGE 4-50 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:NORMAL RETURN IF NOT OK,SKIP RETURN IF OK
:	LINK	-R6
T.SFNS
:	RETURN NO GOOD WHEN
:	RQ_CODE=CLEAR&SCB.SC_CLEAR<>ALLOWED | RQ_CODE=SDT&SCB.SC_SDT<>ALLOWED
:	RQ_CODE=STSN&SCB.SC_STSN<>ALLOWED | RQ_CODE=RQR&SCB.SC_RQR<>ALLOWED
:	RQ_CODE=CRV&(SCB.SC_CRV<>ALLOWED|SCB.CRYPTOGRAPHY_SESSION_LEVEL=NONE)
:	--------------------------------------------------------------------
	BBLOAD	R1,BBUFER+MURUPT,R10,	:R1 CONTAINS RU PTR
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	LB	R5,SCBBLK+SCTFFG,R9,	:GET RQ_CODE SUPPORTED INDICATOR
	CLHI	R0,CLEAR		:IS RQ_CODE=CLEAR?
	JNFS	T.SFN0			:JUMP,IF RQ_CODE<>CLEAR
	THI	R5,SC.CLR		:TEST BITS FOR CLEAR
	JER	R6			:JUMP WHEN SCB.SC_CLEAR<>ALLOWED
T.SFN0
	CLHI	R0,SDT			:IS RQ_CODE=SDT?
	JNFS	T.SFN3			:JUMP,IF RQ_CODE<>SDT
	THI	R5,SC.SDT		:TEST BITS FOR SDT
	JER	R6			:JUMP WHEN SCB.SC_SDT<>ALLOWED
T.SFN3
	CLHI	R0,STSN			:IS RQ_CODE=STSN?
	JNFS	T.SFN9			:JUMP,IF RQ_CODE<>STSN
	THI	R5,SC.STN		:TEST BITS FOR STSN
	JER	R6			:JUMP WHEN SCB.SC_STSN<>ALLOWED
T.SFN9
	CLHI	R0,RQR			:IS RQ_CODE=RQR?
	JNFS	T.SFNA			:JUMP,IF RQ_CODE<>RQR
	THI	R5,SC.RQR		:TEST BITS FOR RQR
	JER	R6			:JUMP WHEN SCB.SC_RQR<>ALLOWED
T.SFNA
	CLHI	R0,CRV			:IS RQ_CODE=CRV?
	JN	T.SFN1			:JUMP,IF RQ_CODE<>CRV
	THI	R5,SC.CRV		:TEST BITS FOR CRV
	JER	R6			:JUMP WHEN SCB.SC_CRV<>ALLOWED
	LB	R3,SCBBLK+SCCYSL,R9,	:GET CRYPTOGRAPHY_SESSION_LEVEL
	JER	R6			:JUMP,CRYPTOGRAPHY_SESSION_LEVEL=NONE
:	TO THIS POINT,R0 CONTAINS RQ_CODE
:	---------------------------------
T.SFN1
	LB	R3,BBUFER+MUDIRE,R10,	:GET BYTE FROM MUCB
	LB	R4,SCBBLK+SCACFG,R9,	:GET HALF_SESSION BIT INDICATOR
	NHI	R4,SC.SES		:MASK OFF OTHER BITS
	JE	T.SFN2			:JUMP,SCB.HALF_SESSION=SECONDARY
:	SCB.HALF_SESSION=PRIMARY
:	---------------------------------
	LR	R3,R3			:GET DIRECTION BYTE
	JN	T.SFN4			:JUMP,MUCB.DIRECTION=RECEIVE
	J	T.SFN6			:JUMP,MUCB.DIRECTION=SEND & PRIMARY
:	SCB.HALF_SESSION=SECONDARY
:	---------------------------------
T.SFN2
	LR	R3,R3			:GET DIRECTION BYTE
	JN	T.SFN6			:JUMP,MUCB.DIRECTION=RECEIVE
:	((SCB.HALF_SESSION=PRIMARY & MUCB.DIRECTION=RECEIVE) |
:	(SCB.HALF_SESSION=SECONDARY & MUCB.DIRECTION=SEND))
:	------------------------------------------------------
T.SFN4
	JAL	R4,T.RQSH		:SEARCH FOR DESIRED RQ_CODE INDEX
	LB	R3,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R3,MU.RRI		:MASK OFF OTHER BITS
	JE	T.SFN5			:JUMP IF RRI=RQ
T.SFND
	LHL	R5,T.SFNB,R2,R2		:FOR THE PROCESSING ROUTINE
	J	T.SFNB,R5		:JUMP TO ROUTINE

T.SFNB	HS
	HC	T.SFN8-T.SFNB		:RETURN (RQR)
	HC	T.SFNF-T.SFNB		:SKIP RETURN (CLEAR)
	HC	T.SFNF-T.SFNB		:SKIP RETURN (SDT)
	HC	T.SFNF-T.SFNB		:SKIP RETURN (CRV)
	HC	T.SFNF-T.SFNB		:SKIP RETURN (STSN)
	HC	T.SFN8-T.SFNB		:RETURN (RQ_CODE ERROR)

T.SFN5
	LHL	R5,T.SFNC,R2,R2		:FOR THE PROCESSING ROUTINE
	J	T.SFNC,R5		:JUMP TO ROUTINE

T.SFNC	HS
	HC	T.SFNF-T.SFNC		:SKIP RETURN (RQR)
	HC	T.SFN8-T.SFNC		:RETURN (CLEAR)
	HC	T.SFN8-T.SFNC		:RETURN (SDT)
	HC	T.SFN8-T.SFNC		:RETURN (CRV)
	HC	T.SFN8-T.SFNC		:RETURN (STSN)
	HC	T.SFN8-T.SFNC		:RETURN (RQ_CODE ERROR)

:	((SCB.HALF_SESSION=PRIMARY & MUCB.DIRECTION=SEND) |
:	(SCB.HALF_SESSION=SECONDARY & MUCB.DIRECTION=RECEIVE))
:	------------------------------------------------------
T.SFN6
	JAL	R4,T.RQSH		:SEARCH FOR DESIRED RQ_CODE INDEX
	LB	R3,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R3,MU.RRI		:MASK OFF OTHER BITS
	JN	T.SFN5			:JUMP IF RRI=RSP
	J	T.SFND			:JUMP FOR RRI=RQ
T.SFNF
	AIS	R6,4
T.SFN8
	JR	R6			:NG,WHEN RQ_CODE NOT SUPPORTED


:	THIS ROUTINE IS USED TO SUPPORT SC RU CATEGORY SEARCH
:	-----------------------------------------------------------
:	INPUT	-R0 (RQ CODE)
:	LINK	-R4
:	OUTPUT	-R2 (INDEX TO T.RQTB)
T.RQSH
	LHI	R2,T.RQLN-1
T.RQS1
	CLB	R0,T.RQTB,R2,		:CHECK CURRENT RQ_CODE TO TABLE
	JER	R4			:YES,RETURN
	SIS	R2,1
	JGEBS	T.RQS1
	LHI	R2,T.RQLN
	JR	R4			:RETURN

:	DECIPH	-(DECIPHER) TO DECIPHER AN ENCRYPTED MESSAGE
:	PAGE 4-42 ON FAPL
:	-----------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	-
:	LINK	-R5
DECIPH
	JR	R5			:RETURN


					:(12/19/85/TTW)
:	T.IRCK  -(IPR_CHECK) DETERMINES IF A MESSAGE UNIT IS AN ISOLATED
:	PACING RESPONSE
:	PAGE 4-58 ON FAPL
:	-----------------------------------------------------------------
:	INPUT    :
:	OUTPUT   :R1 CONTAINS THE RETURN CODE (YES, IPR MESSAGE UNIT)
:	LINK     :R8
T.IRCK
:	IF RRI=RSP & PI=PAC & DR1I= -DR1 & DR2I= -DR2
	LB	R5,BBUFER+MURHF1,R10,	:GET FLAG TO CHECK RRI
	NHI	R5,MU.RRI		:MASK FOR RRI
	JE	T.IRC5			:SKIP IF RRI=RQ
	LB	R5,BBUFER+MURHF2,R10,	:GET FLAG TO CHECK PI
	LR	R0,R5			:SAVE FLAG
:	IT IS TOO LATE TO CHECK 'PI' INDICATOR BECAUSE THIS BIT
:	MIGHT HAVE BEEN TURNED OFF BY FSM_PAC_RQ_SEND.
:	SEE T.PRRV SUBROUTINE.
:	THEREFORE, WE TAKE THE FACT THAT CURRENTLY ONLY IPR
:	COMES WITH [DR1I,DR2I]=[0,0]	(01/14/86/CHS)
:	NHI	R5,MU.PI		:MASK FOR PI(01/14/86/CHS)
:	JEFS	T.IRC5			:SKIP IF PI<>PAC(01/14/86/CHS)
	NHI	R0,MU.DR1+MU.DR2	:MASK FOR DR1 & DR2
	JNFS	T.IRC5			:SKIP IF DR1I=DR1 OR DR2I=DR2
	LHI	R1,YES			:RETURN CODE=YES
	JR	R8
T.IRC5	LHI	R1,NO			:RETURN CODE=NO
	JR	R8

	FO	CBKDEF
	FO	BBUFER

	EM

  
	SUBTTL	SNA PACKAGE(INITIALIZATION) - TRANSMISSION LAYER
:	MODULE NAME IN COMMAND FILE -- STCI02.F00

:	***************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	*****************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT INITIALIZATION OF TCCB
:	AND SOME OTHER INITIALIZATION FUNCTIONS FOR SNA TRANSMISSION
:	CONTROL LAYER (WHCIH DESCRIBED IN CHAPTER 4)
:	-----------------------------------------------------------

	RA	0
	MO	.,SNAPKG


	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	GL	D.RDFC

	SEG	A.CODE

:	T.ITC	-(SESSACT.TC_INITIALIZE) SETS UP SESSION PARAMETERS NEEDED
:	BY TC. THIS PROCEDURE IS EXECUTED WHEN THE SESSION IS BEING
:	ACTIVATED. 
:	PAGE 4-24 ON FAPL
:	-----------------------------------------------------------------
:	USAGE OF REGISTERS -
:	INPUT	-R9 (SCB_PTR) R10 (MU_PTR) R14 (LINK FOR DISPATCHER)
:		 R13 (NCB)
:	OUTPUT	-
:	LINK	-R5
:	WORKING	-R12 (TCCB) R3,R4,R6,R7 (PROTECTED FOR CALLING ROUTINES)
T.ITC
	LHL	R12,SCBBLK+SCTCCB,R9,	:TCCB_PTR=SCB.TC_CB_PTR
	LB	R0,SCBBLK+SCACFG,R9,	:CHECK SESSION TYPE
	NHI	R0,SC.SES		:MASK OFF OTHER BITS FOR SESSION
	JE	T.ITC0			:SCB.HALF_SESSION=SECONDARY,JUMP
	JAL	R6,T.IPRI,,		:CALL SESSACT.PRIMARY_INITIALIZE
	JFS	T.ITC1			:JUMP TO PROCESS NEXT ENTRY
T.ITC0
	JAL	R6,T.ISEC,,		:CALL SESSACT.SECONDARY_INITIALIZE
T.ITC1
	LB	R1,NCBBLK+NDPUTY,R13,	:GET PU_TYPE
	CLHI	R1,PU.T5		:IS TYPE ERROR?
	JG	T.ITC7			:JUMP,IF PU_TYPE ERROR
	LHL	R2,T.ITC2,R1,R1		:GET ROUTINE ENTRY
	J	T.ITC2,R2,		:JUMP TO ROUTINE

T.ITC2	HS
	HC	T.ITC7-T.ITC2		:PU.TYPE ERROR
	HC	T.ITC3-T.ITC2		:PU.TYPE=T1
	HC	T.ITC4-T.ITC2		:PU.TYPE=T2
	HC	T.ITC7-T.ITC2		:PU.TYPE ERROR (T3?)
	HC	T.ITC5-T.ITC2		:PU.TYPE=T4
	HC	T.ITC5-T.ITC2		:PU.TYPE=T5

:	PU_TYPE=T1
:	-----------
T.ITC3
	LHI	R0,PCT1SD		:GET INDEX FOR PC_T1.SEND
	JFS	T.ITC6			:JUMP TO UPDATE #PC
:	PU_TYPE=T2
:	-----------
T.ITC4
	LHI	R0,PCT2SD		:GET INDEX FOR PC_T2.SEND
	JFS	T.ITC6			:JUMP TO UPDATE #PC
:	PU_TYPE=T4|T5
:	-----------
T.ITC5
	LHI	R0,PCVRSD		:GET INDEX FOR PC.VRC.SEND
T.ITC6
	STB	R0,TCBBLK+TCCMPC,R12,	:SET #PC DEPENDS PU_TYPE
	JR	R5			:RETURN
:	PU_TYPE ERROR
:	-------------
T.ITC7
	JAL	R10,CRASH,,
	BC	0,0,0,0FF

:	T.IPRI	(SESSACT.PRIMARY_INITIALIZE) SETS UP SESSION PARAMETERS
:	NEEDED BY A PRIMARY HALF-SESSION TC.
:	PAGE 4-25 ON FAPL
:	-----------------------------------------------------------------
:	USAGE OF REGISTERS -
:	INPUT	-R9 (SCB_PTR) R10 (MU_PTR) R14 (LINK FOR DISPATCHER)
:		 R13 (NCB) R12 (TCCB)
:	OUTPUT	-
:	LINK	-R6
:	WORKING	-R3,R4,R5,R7 (PROTECTED FOR CALLING ROUTINES)
T.IPRI
:	RU SIZE AND PACING COUNTS INITIAL VALUE
:	---------------------------------------
	LIS	R2,0			:INITIAL VAL. FOR TCCB.MAX_SEND_RU_SIZE
	LB	R1,SCBBLK+SCPMRU,R9,	:GET SCB.PRI_SEND_MAX_RU_SIZE
	JEFS	T.IPR6			:JUMP,IF IT IS 0
	JAL	R7,R.DECO,,		:CALL DECODED (R1)
T.IPR6
	ST	R2,TCBBLK+TCMSRU,R12,	:SET TCCB.MAX_SEND_RU_SIEZ
	LIS	R2,0			:INITIAL VAL. FOR TCCB.MAX_RCV_RU_SIZE
	LB	R1,SCBBLK+SCSMRU,R9,	:GET SCB.SEC_SEND_MAX_RU_SIZE
	JEFS	T.IPR7			:JUMP,IF IT IS 0
	JAL	R7,R.DECO,,		:CALL DECODED (R1)
T.IPR7
	ST	R2,TCBBLK+TCMRRU,R12,	:SET TCCB.MAX_RCV_RU_SIZE
	LHI	R2,@TC.SPA		:GET BIT OFF VALUE

:	FOR NATIVE MODE, NO MATTER ONE OR TWO-STAGE PACING FOR
:	PRIMARY TO SECONDARY, WE MUST USE SEC_RCV_PACING_CNT.
:	THE TIF OF NATIVE MODE MUST ACTIVE AS 'BF' IN HANDING
:	OF PACING. (01/14/86/CHS)
	LB	R1,SCBBLK+SCTPUG,R9,	:SCB.PRI_SEND_PACING_CNT,STAGING_IND
	LHL	R7,SCBBLK+SCBLUC,R9,	:SEE IF HAS LUC
	JEFS	T.IPRW			:NO, MUST SSCP-LU
	LB	R0,LUCTAB+LULUST,R7,	:GET LU-LU STATE
	NHI	R0,0E0			:CHECK TO SEE IF TRANSPRENT STATE
	JNFS	T.IPRW			:NO, SKIP
	LB	R1,SCBBLK+SCSRPC,R9,	:USE SCB.SEC_RCV_PACING_CNT
T.IPRW
	LB	R0,TCBBLK+TCCBFG,R12,	:GET BYTE CONTAINS TCCB.RCV_PACING
:	LB	R1,SCBBLK+SCTPUG,R9,	:SCB.PRI_SEND_PACING_CNT,STAGING_IND
:					: (01/14/86/CHS)

	NHI	R1,@SC.STG		:MASK OFF STAGING.IND
	JNFS	T.IPR8			:JUMP,IF CNT<>0
	NR	R0,R2
	STB	R0,TCBBLK+TCCBFG,R12,	:SET TCCB.SEND_PACING=NO
	J	T.IPR1			:JUMP TO NEXT FUNCTIONS
T.IPR8
	LHI	R2,TC.SPA		:GET VALUE FOR THAT BIT POSITION
	OR	R0,R2			:SET TCCB.SEND_PACING
	STB	R0,TCBBLK+TCCBFG,R12,	:STORE NEW VALUE
	STH	R1,TCBBLK+TCWDSZ,R12,	:TCCB.WINDOW_SIZE=SCB.PRI_SEND_PAC-CNT
:	NEWLIST TCCB.Q_PAC ENTRY_NAME (MU) QUEUE,NEEDS SAVE R3,R4,R6,R7
:	-------------------------------------------------------------
	JAL	R4,R.TPQN,,		:CALL CREATE NEWLIST ROUTINE
T.IPR1
	LB	R0,TCBBLK+TCCBFG,R12,	:GET BYTE CONTAINS TCCB.RCV_PACING
	LHI	R2,@TC.RPA		:INITIAL VALUE FOR TCCB.RCV_PACING
	LB	R1,SCBBLK+SCPRPC,R9,	:SCB.PRI_RCV_PACING_CNT
	JEFS	T.IPR9			:JUMP,IF CNT=0
:	OHI	R2,TC.RPA		:SET VALUE (06/12/85 MIA)
	OHI	R0,TC.RPA		:SET BIT (06/12/85 MIA)
:FAKE DATA PRESENT TO SCHEDULE IPR (12/17/85 MIA).
	LB	R1,SCBBLK+SCBREL,R9,	:GET REL # OF SCB (12/17/85 MIA)
	SBT	R1,NCBBLK+NDQTCP,R13,	:SET DATA PRESENT (12/17/85 MIA)
	JFS	T.IPRR			:JUMP TO CONTINUE (06/12/85 MIA)
T.IPR9
	NR	R0,R2			:SET TCCB.RCV_PACING
T.IPRR					:(06/12/85 MIA)
	STB	R0,TCBBLK+TCCBFG,R12,	:STORE NEW VALUE
:	FSM'S INITIAL VALUE
:	---------------------
	LB	R0,SCBBLK+SCTFFG,R9,	:GET ALLOWED BIT ARRY
	LR	R1,R0			:SAVE BIT ARRAY IN R1
	LHI	R2,FSMNOP		:SET NO_OP FOR INITIAL VALUE
	NHI	R1,SC.RQR		:MASK OFF OTHER BITS FOR SC_RQR
	JEFS	T.IPRA			:JUMP,IF NOT ALLOWED SC_RQR
	LHI	R2,FSCRQR		:GET INDEX TO FSM_RQR_RCV
T.IPRA
	STB	R2,SCBBLK+SCFMRQ,R9,	:SET #FSM_RQR TO DESIRED
	LR	R1,R0			:SAVE BIT ARRAY IN R1
	LHI	R2,FSMNOP		:SET NO_OP FOR INITIAL VALUE
	NHI	R1,SC.STN		:MASK OFF OTHER BITS FOR SC_STSN
	JEFS	T.IPRB			:JUMP,IF NOT ALLOWED SC_STSN
	LHI	R2,FSCSNS		:GET INDEX TO FSM_STSN_SEND
T.IPRB
	STB	R2,SCBBLK+SCFMRQ,R9,	:SET #FSM_STSN TO DESIRED
	LR	R1,R0			:SAVE BIT ARRAY IN R1
	NHI	R1,SC.SDT		:MASK OFF OTHER BITS FOR SC_SDT
	JE	T.IPR2			:JUMP,IF SC_SDT NOT ALLOWED
	LR	R1,R0
	LHI	R2,FSCDSS		:SET FSM_DT_SEND_SDT
	NHI	R1,SC.CLR		:MASK OFF OTHER BITS FOR SC_CLEAR
	JE	T.IPR3			:JUMP,IF SC_CLEAR NOT ALLOWED
	LHI	R2,FSCDSA		:SET FSM_DT_SEND_SDT_AND_CLEAR
	J	T.IPR3
:	SC_SDT NOT ALLOWED
T.IPR2
	LHI	R2,FSMNOP		:SET NO_OP FOR INITIAL VALUE
	LR	R1,R0
	NHI	R1,SC.CLR		:MASK OFF OTHER BITS FOR SC_CLEAR
	JEFS	T.IPR3			:JUMP,IF SC_CLEAR NOT ALLOWED
	LHI	R2,FSCDSC		:SET FSM_DT_SEND_CLEAR
T.IPR3
	STB	R2,SCBBLK+SCFMDT,R9,	:SET #FSM_DT TO DESIRED
	LHI	R2,FSMNOP		:SET NO_OP FOR INITIAL VALUE
	LR	R1,R0
	NHI	R1,SC.CRV		:MASK OFF OTHER BITS FOR SC_CRV
	JE	T.IPR4			:JUMP,SC_CRV NOT ALLOWED
	LB	R1,SCBBLK+SCCYSL,R9,	:GET SCB.CRYPTOGRAPY_SESSION_LEVEL
	CLHI	R1,SELECT		:IS IT SELECTIVE
	JEFS	T.IPR5			:JUMP,IF IT IS SELECTIVE
	CLHI	R1,MANDAT		:IS IT MANDATORY?
	JNFS	T.IPR4			:JUMP IF NOT (SELECTIVE |MANDATORY)
T.IPR5
	LHI	R2,FSCCVS		:SET FSM_CRV_SEND
T.IPR4
	STB	R2,SCBBLK+SCFMCR,R9,	:SET #FSM_CRV TO DESIRED
	JR	R6			:RETURN

:	T.ISEC	(SESSACT.SECONDARY_INITIALIZE) SETS UP SESSION PARAMETERS
:	NEEDED BY A SECONDARY HALF-SESSION TC.
:	PAGE 4-26 ON FAPL
:	-----------------------------------------------------------------
:	USAGE OF REGISTERS -
:	INPUT	-R9 (SCB_PTR) R10 (MU_PTR) R14 (LINK FOR DISPATCHER)
:		 R13 (NCB) R12 (TCCB)
:	OUTPUT	-
:	LINK	-R6
:	WORKING	-R3,R4,R5,R7 (PROTECTED FOR CALLING ROUTINES)
T.ISEC
:	RU SIZE AND PACING COUNTS INITIAL VALUE
:	---------------------------------------
	LIS	R2,0			:INITIAL VAL. FOR TCCB.MAX_SEND_RU_SIZE
	LB	R1,SCBBLK+SCSMRU,R9,	:GET SCB.SEC_SEND_MAX_RU_SIZE
	JEFS	T.ISE0			:JUMP,IF IT IS 0
	JAL	R7,R.DECO,,		:CALL DECODED (R1)
T.ISE0
	ST	R2,TCBBLK+TCMSRU,R12,	:SET TCCB.MAX_SEND_RU_SIEZ
	LIS	R2,0			:INITIAL VAL. FOR TCCB.MAX_RCV_RU_SIZE
	LB	R1,SCBBLK+SCPMRU,R9,	:GET SCB.PRI_SEND_MAX_RU_SIZE
	JEFS	T.ISE9			:JUMP,IF IT IS 0
	JAL	R7,R.DECO,,		:CALL DECODED (R1)
T.ISE9
	ST	R2,TCBBLK+TCMRRU,R12,	:SET TCCB.MAX_RCV_RU_SIZE
	LHI	R2,@TC.SPA		:GET BIT OFF VALUE
	LB	R0,TCBBLK+TCCBFG,R12,	:GET BYTE CONTAINS TCCB.RCV_PACING
	LB	R1,SCBBLK+SCTSUG,R9,	:SCB.SEC_SEND_PACING_CNT,STAGING_IND
	NHI	R1,@SC.STG		:MASK OFF STAGING.IND
	JNFS	T.ISEA			:JUMP,IF CNT<>0
	NR	R0,R2
	STB	R0,TCBBLK+TCCBFG,R12,	:SET TCCB.SEND_PACING=NO
	J	T.ISE1			:JUMP TO NEXT FUNCTIONS
T.ISEA
	LHI	R2,TC.SPA		:GET VALUE FOR THAT BIT POSITION
	OR	R0,R2			:SET TCCB.SEND_PACING
	STB	R0,TCBBLK+TCCBFG,R12,	:STORE NEW VALUE
	STH	R1,TCBBLK+TCWDSZ,R12,	:TCCB.WINDOW_SIZE=SCB.SEC_SEND_PAC-CNT
:	NEWLIST TCCB.Q_PAC ENTRY_NAME (MU) QUEUE,NEEDS SAVE R3,R4,R6,R7
:	-------------------------------------------------------------
	JAL	R4,R.TPQN,,		:CALL CREATE NEWLIST ROUTINE
T.ISE1
	LB	R0,TCBBLK+TCCBFG,R12,	:GET BYTE CONTAINS TCCB.RCV_PACING
	LHI	R2,@TC.RPA		:INITIAL VALUE FOR TCCB.RCV_PACING
	LB	R1,SCBBLK+SCSRPC,R9,	:SCB.SEC_RCV_PACING_CNT
	JEFS	T.ISE6			:JUMP,IF CNT=0
:	OHI	R2,TC.RPA		:SET VALUE (06/12/85 MIA)
:FAKE DATA PRESENT TO SCHEDULE IPR (12/17/85 MIA).
	LB	R1,SCBBLK+SCBREL,R9,	:GET REL # OF SCB (12/17/85 MIA)
	SBT	R1,NCBBLK+NDQTCP,R13,	:SET DATA PRESENT (12/17/85 MIA)
	OHI	R0,TC.RPA		:SET BIT (06/12/85 MIA)
	JFS	T.ISEB			:JUMP TO CONTINUE (06/12/85 MIA)
T.ISE6
	NR	R0,R2			:SET TCCB.RCV_PACING
T.ISEB					:(06/12/85 MIA)
	STB	R0,TCBBLK+TCCBFG,R12,	:STORE NEW VALUE
:	FSM'S INITIAL VALUE
:	---------------------
	LB	R0,SCBBLK+SCTFFG,R9,	:GET ALLOWED BIT ARRY
	LR	R1,R0			:SAVE BIT ARRAY IN R1
	LHI	R2,FSMNOP		:SET NO_OP FOR INITIAL VALUE
	NHI	R1,SC.RQR		:MASK OFF OTHER BITS FOR SC_RQR
	JEFS	T.ISE7			:JUMP,IF NOT ALLOWED SC_RQR
	LHI	R2,FSCRQS		:GET INDEX TO FSM_RQR_SEND
T.ISE7
	STB	R2,SCBBLK+SCFMRQ,R9,	:SET #FSM_RQR TO DESIRED
	LR	R1,R0			:SAVE BIT ARRAY IN R1
	LHI	R2,FSMNOP		:SET NO_OP FOR INITIAL VALUE
	NHI	R1,SC.STN		:MASK OFF OTHER BITS FOR SC_STSN
	JEFS	T.ISE8			:JUMP,IF NOT ALLOWED SC_STSN
	LHI	R2,FSCSNR		:GET INDEX TO FSM_STSN_RCV
T.ISE8
	STB	R2,SCBBLK+SCFMRQ,R9,	:SET #FSM_STSN TO DESIRED
	LR	R1,R0			:SAVE BIT ARRAY IN R1
	NHI	R1,SC.SDT		:MASK OFF OTHER BITS FOR SC_SDT
	JE	T.ISE2			:JUMP,IF SC_SDT NOT ALLOWED
	LR	R1,R0
	LHI	R2,FSCDRS		:SET FSM_DT_RCV_SDT
	NHI	R1,SC.CLR		:MASK OFF OTHER BITS FOR SC_CLEAR
	JE	T.ISE3			:JUMP,IF SC_CLEAR NOT ALLOWED
	LHI	R2,FSCDRA		:SET FSM_DT_RCV_SDT_AND_CLEAR
	J	T.ISE3
:	SC_SDT NOT ALLOWED
T.ISE2
	LHI	R2,FSMNOP		:SET NO_OP FOR INITIAL VALUE
	LR	R1,R0
	NHI	R1,SC.CLR		:MASK OFF OTHER BITS FOR SC_CLEAR
	JEFS	T.ISE3			:JUMP,IF SC_CLEAR NOT ALLOWED
	LHI	R2,FSCDRC		:SET FSM_DT_RCV_CLEAR
T.ISE3
	STB	R2,SCBBLK+SCFMDT,R9,	:SET #FSM_DT TO DESIRED
	LHI	R2,FSMNOP		:SET NO_OP FOR INITIAL VALUE
	LR	R1,R0
	NHI	R1,SC.CRV		:MASK OFF OTHER BITS FOR SC_CRV
	JE	T.ISE4			:JUMP,SC_CRV NOT ALLOWED
	LB	R1,SCBBLK+SCCYSL,R9,	:GET SCB.CRYPTOGRAPY_SESSION_LEVEL
	CLHI	R1,SELECT		:IS IT SELECTIVE
	JEFS	T.ISE5			:JUMP,IF IT IS SELECTIVE
	CLHI	R1,MANDAT		:IS IT MANDATORY?
	JNFS	T.ISE4			:JUMP IF NOT (SELECTIVE |MANDATORY)
T.ISE5
	LHI	R2,FSCCVR		:SET FSM_CRV_RCV
T.ISE4
	STB	R2,SCBBLK+SCFMCR,R9,	:SET #FSM_CRV TO DESIRED
	JR	R6			:RETURN

:	T.RTC	-(SESSACT.TC_RESET) RESETS ALL TC FSM'S . THIS ROUTINE
:	IS CALLED AS A RESULT OF RESETTING A SUBTREE THAT INCLUDES
:	CRV,DT AND ALL PACING OBJECTS.
:	PAGE 4-27 ON FAPL
:	-----------------------------------------------------------------
:	USAGE OF REGISTERS -
:	INPUT	-R9 (SCB_PTR) R10 (MU_PTR) R14 (LINK FOR DISPATCHER)
:		 R13 (NCB)
:	OUTPUT	-
:	LINK	-R5
:	WORKING	-R12 (TCCB) R3,R4,R6,R7 (PROTECTED FOR CALLING ROUTINES)
T.RTC
	ST	R5,RGSAV5,,		:SAVE REG 5
	ST	R7,RGSAV7,,		:SAVE REG 7
:	CALL #FSM_CRV
:	------------
	LB	R1,SCBBLK+SCFMCR,R9,	:SET UP #FSM_CRV INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SETUP FSM CALL
	JAL	R4,R.FSM1,,		:CALL ROUTINE
:	CALL #FSM_DT
:	------------
	LB	R1,SCBBLK+SCFMDT,R9,	:SET UP #FSM_DT INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SETUP FSM CALL
	JAL	R4,R.FSM1,,		:CALL ROUTINE
:	CALL CPMGR_RESET
:	-----------------
	JAL	R6,T.RCPM,,		:CALL CPMGR_RESET
	L	R5,RGSAV5,,		:RESTORE REG 5
	L	R7,RGSAV7,,		:RESTORE REG 7
	JR	R5			:RETURN

:	CLRRST	-RESETS A HALF-SESSION WHEN A CLEAR IS BEING PROCESSED
:	--------------------------------------------------------------
:	PAGE 4-27 ON FAPL
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	-
:	LINK	-R5
CLRRST
:	ST	R3,RGSAV3,,		:SAVE REG 3 (02/28/85 MIA)
	ST	R4,RGSAV4,,		:SAVE REG 4
	ST	R5,RGSAV5,,		:SAVE REG 5
	ST	R6,RGSAV6,,		:SAVE REG 6
	ST	R7,RGSAV7,,		:SAVE REG 7
:	CALL CPMGR_RESET
:	-----------------
	JAL	R6,T.RCPM,,		:CALL CPMGR_RESET
	LB	R6,TCBBLK+TCCBFG,R15,	:GET CONTROL FLAG(12/18/85/MIA)
	NHI	R6,TC.RPA		:MASK OFF OTHER BITS(12/18/85/MIA)
	JEFS	CLRRS1			:SKIP IF TCCB.RCV_PACING=NO(12/18/85/MIA)
	LB	R6,SCBBLK+SCBREL,R9,	:GET REL. # OF SCB(12/18/85/MIA)
	SBT	R6,NCBBLK+NDQTCP,R13,	:SET DATA PRESENT(12/18/85/MIA)
CLRRS1
	L	R3,RGSAV3,,		:RESTORE REG 3
	L	R4,RGSAV4,,		:RESTORE REG 4
	L	R5,RGSAV5,,		:RESTORE REG 5
	L	R6,RGSAV6,,		:RESTORE REG 6
	L	R7,RGSAV7,,		:RESTORE REG 7
:	CALL SESSACT.DFC_RESET
:	-----------------------
	LR	R7,R5			:SAVE RETURN ADDRESS
	JAL	R5,D.RDFC,,		:CALL SESSACT.DFC_RESET
	LR	R5,R7			:GET BACK RETURN ADDRESS
	JR	R5			:RETURN

:	T.RCPM	-(CPMGR_RESET) PAGE 4-28 ON FAPL
:	------------------------------------------
:	INPUT	-R9 (SCB_PTR) 
:	LINK	-R6
T.RCPM
	ST	R6,RGSAV6,,		:SAVE REG 6
	LR	R12,R15
	LHL	R15,SCBBLK+SCTCCB,R9,	:TCCB_PTR=SCB.TC_CB_PTR
:	CALL #FSM_RQR
:	------------
	LB	R1,SCBBLK+SCFMRQ,R9,	:SET UP #FSM_RQR INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SETUP FSM CALL
	JAL	R4,R.FSM1,,		:CALL ROUTINE
:	CALL #FSM_STSN
:	------------
	LB	R1,SCBBLK+SCFMST,R9,	:SET UP #FSM_STSN INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SETUP FSM CALL
	JAL	R4,R.FSM1,,		:CALL ROUTINE
:	CALL FSM_PAC_RQ_SEND
:	------------
	LHI	R1,FTCPRS		:SET INDEX FOR FSM_PAC_RQ_SEND
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SETUP FSM CALL
	JAL	R4,R.FTMR,,		:CALL ROUTINE
:	CALL FSM_PAC_RQ_RCV
:	------------
	LHI	R1,FTCPRR		:SET INDEX FOR FSM_PAC_RQ_RCV
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SETUP FSM CALL
	JAL	R4,R.FTMR,,		:CALL ROUTINE
:	CALL #FSM_CNTL_IMMED_EXP
:	------------
	LHI	R1,FSCCIE		:GET FSM_CNTL_IMMED_EXP INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SETUP FSM CALL
	JAL	R4,R.FSM1,,		:CALL ROUTINE
:	PURGE SCB.Q_TC_TO_DFC
:	--------------------------
	JAL	R8,R.TDQP,,		:PURGE TC_TO_DFC_QUEUE
:	CHECK TCCB.SEND_PACING
:	-------------------------------
	LB	R0,TCBBLK+TCCBFG,R15,	:SET TCCB.SEND_PACING=NO
	NHI	R0,TC.SPA		:MASK OFF FOR TCCB.SEND_PACING
	JE	T.RCP1			:JUMP,IF SEND_PACING=NO
	JAL	R8,R.TPQP,,		:CALL PURGE TCCB.Q_PAC
	LHL	R1,TCBBLK+TCWDSZ,R15,	:TCCB.WINDOW_SIZE=SCB.PRI_SEND_PAC-CNT
	STH	R1,TCBBLK+TCPGCT,R15,	:SET TCCB.WINDOW_SIZE=PACING_COUNT
T.RCP1
	LIS	R0,0			:SET INIT VALUE
	STH	R0,SCBBLK+SCSQSC,R9,	:SET SQN_SEND_CNT TO 0
	STH	R0,SCBBLK+SCSQRC,R9,	:SET SQN_RCV_CNT TO 0
	L	R6,RGSAV6,,		:RESTORE REG 6
	LR	R15,R12
	JR	R6			:RETURN

:	R.DECO	-(DECODED) CONVERTS MAX_RU_SIZE FROM ITS ENCODED FORM
:	TO AN HEX INTEGER VALUE
:	PAGE 4-57 ON FAPL
:	-----------------------------------------------------------------
:	USAGE OF REGISTERS -
:	INPUT	-R9 (SCB_PTR) R10 (MU_PTR) R14 (LINK FOR DISPATCHER)
:		 R13 (NCB) R12 (TCCB) R1 (ENCODED VALUE X'AB')
:	OUTPUT	-R2 (A*(2**B))
:	LINK	-R7
:	WORKING	-R3,R4,R5,R6 (PROTECTED FOR CALLING ROUTINES)
R.DECO
	LR	R0,R1			:SAVE R1 CONTENTS IN R0
	NHI	R0,0F0			:GET (0:3) FOR INPUT
	SRHLS	R0,4			:R0 CONTAINS INPUT (0:3) 'A'
	NHI	R1,0F			:GET (4:7) FOR INPUT 'B'
	LIS	R2,2
R.DEC1
	SIS	R1,1			:FOR NEXT CYCLE
	JLEFS	R.DEC2			:JUMP,IF FINISH
	SLHLS	R2,1
	JBS	R.DEC1			:CONTINUE
R.DEC2
	MHR	R2,R0			:A*(2**B)
	JR	R7			:RETURN

					:(12/04/85/TTW/BEG.)
:	T.CIPR  -(CREATE_IPR) CREATES AN ISOLATED PACING RESPONSE (IPR)
:	WITH RH=X'830100'
:	PAGE 4-58 ON FAPL
:	---------------------------------------------------------------
:	USAGE OF REGISTERS -
:	INPUT   -R10 (SCB PTR)
:	OUTPUT  -R9 (SCB_PTR), R10 (MU_PTR)
:	LINK    -R8
:	WORKING -R0,R1,R3,R4,R9
T.CIPR
:	CREATE MU
	JAL	R4,GBB,,		:GET BIG BUFFLET FOR MUCB
	J	T.CICR			:CRASH IF NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BUFFER COUNT
	LR	R10,R3			:R10=MU_PTR
	LB	R0,SCBBLK+SCOTID,R9,	:GET LU# FOR DAF
	LB	R1,SCBBLK+SCMYID,R9,	:GET PRIMARY LOCAL ADDRESS
	JAL	R4,GBB,,		:GET A BUFFLET
	J	T.CICR			:CRASH IF NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BUFFER COUNT
	BBSTOR	R3,BBUFER+MUCBTU,R10,	:STORE BTU BTR IN MUCB
	STB	R0,BBUFER+MUDADP,R10,	:STORE DAF INTO MUCB
	STB	R0,BBUFER+2,R3,		:STORE INTO BUFFER AREA
	STB	R1,BBUFER+MUOADP,R10,	:STORE OAF INTO MUCB
	STB	R1,BBUFER+3,R3,		:STORE INTO BUFFER AREA
	LIS	R0,FID2			:GET FID TYPE
	SLHLS	R0,AD.FID		:GET PROPER POSITION FOR FID
	OHI	R0,MU.BIU+MU.EIU
	STB	R0,BBUFER+MUBIUF,R10,	:STORE INTO MUCB
	STB	R0,BBUFER+0,R3,		:STORE INTO BUFFER AREA
	LIS	R0,0			:SET INIT VALUE
	STB	R0,BBUFER+1,R3,		:STORE INTO BUFFER AREA
	STH	R0,BBUFER+MUSNF,R10,	:STORE INTO MUCB
	STH	R0,BBUFER+4,R3,		:STORE INTO BUFFER AREA
	AIS	R3,6			:SET UP POINTER TO BEG. OF RH
:	RRI = RSP
:	BCI = BC
:	ECI = EC
	LHI	R0,MU.RRI+MU.BCI+MU.ECI	:R0=83
	STB	R0,BBUFER+MURHF1,R10,	:STORE INTO MUCB
	STB	R0,BBUFER+0,R3,		:STORE INTO BUFFER AREA
:	SET RH VALUES FOR IPR
	LIS	R0,0			:SET INIT. VALUE
	OHI	R0,MU.PI		:PI = PAC
	STB	R0,BBUFER+MURHF2,R10,	:STORE INTO MUCB
	STB	R0,BBUFER+1,R3,		:STORE INTO BUFFER AREA
	LIS	R0,0			:SET UP MURHF3 (12/26/85/CHS)
	STB	R0,BBUFER+MURHF3,R10,	:..(12/26/85/CHS)
	STB	R0,BBUFER+2,R3,		:...(12/26/85/CHS)
	LIS	R0,3			:SET UP MUDCF=3 (12/26/85/CHS)
	STH	R0,BBUFER+MUDCF,R10,	:....(01/06/86/CHS)
	AIS	R3,3			:SET POINTER TO BEG. OF RU
	BBSTOR	R3,BBUFER+MURUPT,R10,	:STORE RU PTR INTO MUCB
	LHI	R0,SENT			:SET DIRECTION TO SENT
	STB	R0,BBUFER+MUDIRE,R10,	:SET UP MUCB.DIRECTION.CONTANTS
	JR	R8			:RETURN

T.CICR	J	NOENT5,,
					:(12/04/85/TTW/END)


	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF

	EM

    
	SUBTTL	SNA PACKAGE(MAIN PROCESSES) - TRANSMISSION CONTROL LAYER
:	MODULE NAME IN COMMAND FILE -- STCC00.F00

:	***********************************************
:	REVISION HISTORY ---
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	***********************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT TRANSMISSION CONTROL 
:	FUNCTIONS OF SNA AS DESCRIBED ON FAPL
:	-----------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF

	SEG	A.CODE

:	T.DQPG	-(TC_OR_BF_TC.DEQUEUE.Q_PAC) THIS PROCEDURE 
:	DETERMINES IF IT IS VALID TO REMOVE A MESSAGE UNIT FROM
:	Q_PAC. IF VALID,REMOVES PIU FROM Q_PAC AND SENS IT TO PATH
:	CONTROL. THIS PROCEDURE MAY TURN PACING INDICATOR ON IN
:	A RESPONSE. THIS PROCEDURE IS DISPATCHED WHEN AN OPEN QUEUE
:	SIGNAL IS SENT TO IT FROM THE HIGHER-LEVEL SCHEDULER.
:	PAGE 4-29 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:
:	OUTPUT	:
:	LINK	:
:	WORKING	:
T.DQPG
:	L	R15,NCBBLK+NDTCCB,R13,	:GET TC CONTROL BLOCK PTR(12/24/85/CHS)
	L	R9,NCBBLK++NDSSCB,R13,	:GET SCB PTR (12/24/85/CHS)
	JLE	T.CRAS			:CRASH, IF SCB_PTR NULL(12/24/85/CHS)
	LHL	R15,SCBBLK+SCTCCB,R9,	:GET TCCB_PTR=SCB.TC_CB_PTR(12/24/85/CHS)
	JLE	T.CRAS			:CRASH,IF SCB_PTR NULL
	LB	R5,TCBBLK+TCCBFG,R15,	:GET CONTROL FLAG
	NHI	R5,TC.SPA		:MASK OFF OTHER BITS
	JER	R14			:TCCB.SEND_PACING= NO,RETURN
	LHL	R5,TCBBLK+TCPGCT,R15,	:GET TCCB.PACING_COUNT
	JN	T.DQP1			:JUMP, IF PACING_COUNT>0
	LHL	R6,TCBBLK+TCQSPG,R15,	:GET GET POINTER FOR Q_PAC
:	CLH	R6,TCBBLK+TCQSPR,R15,	:COMPARE GET TO RL (01/03/85 MIA)
	LHL	R4,TCBBLK+TCQSPR,R15,	:GET REL PTR (01/03/85 MIA)
	CR	R6,R4			::COMP THEM (01/03 85 MIA)
	JE	T.DQP2			:JUMP TO ERROR,IF NOTHING IN QUEUE
	BBLOAD	R10,CMDBLK+CLARG,R6,	:GET MU STARTING PTR (9/7/84 MIA)
	LB	R5,BBUFER+MUBIUF,R10,	:GET BIU FLAG(01/06/86/TTW)
	THI	R5,MU.BIU		:CHECK BBIU INDICATOR(01/06/86/TTW)
	JEFS	T.DQP1			:JUMP IF NOT BBIU(01/06/86/TTW)
	LB	R5,BBUFER+MURHF1,R10,	:GET FLAG BYTE TO CHAECK RRI
	NHI	R5,MU.RRI		:MASK OFF OTHER BITS
	JER	R14			:RETURN,IF RRI<>RSP
:	REMOVE FIRST(MU) FROM TCCB.Q_PAC??????
T.DQP1
	LHL	R6,TCBBLK+TCQSPG,R15,	:GET GET POINTER FOR Q_PAC
:	CLH	R6,TCBBLK+TCQSPR,R15,	:COMPARE GET TO RL (01/03/85 MIA)
	LHL	R4,TCBBLK+TCQSPR,R15,	:GET REL PTR (01/03/85 MIA)
	CR	R6,R4			:COMP THEM (01/03/85 MIA)
	JE	T.DQP2			:JUMP TO ERROR,IF NOTHING IN QUEUE
:	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR (03/13/85 MIA)
	LHL	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR (03/15/85 MIA)
	JE	T.DQP2			:JUMP TO ERROR WHEN NEXT PTR=0
	BBLOAD	R10,CMDBLK+CLARG,R6,	:GET MU STARTING PTR (9/7/84 MIA)
	STH	R7,TCBBLK+TCQSPG,R15,	:UPDATE GET PTR FOR TCCB.Q_PAC
	CR	R7,R4			:LAST IN QUEUE?
:	JNFS	T.DQP0			:JUMP IF NOT(12/18/85/TTW)
	JN	T.DQP0			:JUMP IF NOT(12/18/85/TTW)
:DO NOT RESET DATA PRESENT IF RCV_PACING TO SCHEDULE IPR (12/17/85 MIA)
	LB	R4,TCBBLK+TCCBFG,R15,	:GET TCCB FLAG BYTE (12/17/85 MIA)
	NHI	R4,TC.RPA		:RECEIVE PACING? (12/17/85 MIA)
	JNFS	T.DQP0			:JUMP IF SO (12/17/85 MIA)
:	L	R4,NCBBLK+NDSSCB,R13,	:GET SCB POINTER (01/13/85 MIA)(4/28/85/CHS)
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB POINTER (4/28/85/CHS)
:	LB	R4,SCBBLK+SCBREL,R4,	:GET SCB REL # (01/13/85 MIA)(4/28/85/CHS)
	LB	R4,SCBBLK+SCBREL,R9,	:GET SCB REL # (4/28/85/CHS)
	RBT	R4,NCBBLK+NDQTCP,R13,	:RESET DATA PRESENT (01/13/85 MIA)
T.DQP0	JAL	R4,RELCL,,		:RELEASE CMDLST
	LB	R5,BBUFER+MUBIUF,R10,	:GET BIU FLAG(01/06/86/TTW)
	THI	R5,MU.BIU		:CHECK BBIU FLAG(01/06/86/TTW)
	JE	T.DQP4			:JUMP IF NOT BBIU(01/06/86/TTW)
:	SELECT ANYORDER ACCORDING TO THE VALUE OF RRI
	LB	R5,BBUFER+MURHF1,R10,	:GET FLAG BYTE TO CHAECK RRI
	NHI	R5,MU.RRI		:MASK OFF OTHER BITS
	JE	T.DQP3			:RETURN,IF RRI<>RSP
:	RRI=RSP, CHECK TCCB.RCV_PACING=YES& UPM_RESOURCES=OK
:	---------------------------------------------------
	LB	R5,TCBBLK+TCCBFG,R15,	:GET CONTROL FLAG
	NHI	R5,TC.RPA		:MASK OFF OTHER BITS
	JE	T.DQP4			:TCCB.RCV_PACING=NO,JUMP
:	CALL UPM_RESOURCES??????
:	CALL FSM_PAC_RQ_RCV?????
	LHI	R1,FTCPRR		:GET INDEX OF FSM_PAC_RQ_RCV(01/06/86/TTW)
	LIS	R0,0			:CLEAR FSM INPUT(01/06/86/TTW)
	LIS	R6,FS.CAL		:SET UP FSM CALL(01/06/86/TTW)
	JAL	R4,R.FTMR,,		:CALL FSM_PAC_RQ_RCV(01/06/86/TTW)
	JFS	T.DQP4			:..(01/06/86/TTW)
:	RRI=RQ,CALL FSM_PAC_RQ_SEND,DEC. PACING_COUNT
:	-------------------------------------------
T.DQP3
:	CALL FSM_PAC_RQ_SEND???????
	LHI	R1,FTCPRS		:GET INDEX OF FSM_PAC_RQ_SEND(01/06/86/TTW)
	LIS	R0,0			:CLEAR FSM INPUT(01/06/86/TTW)
	LIS	R6,FS.CAL		:SET UP FSM CALL(01/06/86/TTW)
	JAL	R4,R.FTMR,,		:CALL FSM_PAC_RQ_SEND(01/06/86/TTW)
	LHL	R5,TCBBLK+TCPGCT,R15,	:GET TCCB.PACING_COUNT
	SIS	R5,1			:DECREASE PACING_COUNT BY ONE
	STH	R5,TCBBLK+TCPGCT,R15,	:STORE NEW PACING_COUNT
:	ACCORDING TO THE SESSION TYPE TO DO 'SEND' FUNCTION
:	----------------------------------------------------
T.DQP4
	LB	R0,SCBBLK+SCACFG,R9,	:GET SESSION TYPE (HALF,BF SESSION)
	NHI	R0,SC.BFS		:MASK FOR SESSION TYPE
	JE	T.DQP5			:JUMP,IF IT IS HALF-SESSION
	LHI	R1,TCBFSD		:ELSE,BF_SESSION GET SENDING PROC. #
	JFS	T.DQP6			:JUMP TO PROCESS SEND STATEMNET
T.DQP5
	LHI	R1,TCCMSD		:GET SENDING PROCEDURE #
T.DQP6
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	T.CRA1			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BUFFER CNT
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R2,PCT2SD		:GET DESTINATION PROCEDURE #
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
:	THE DESTINATION IS VARIED DEPENDS ON SESSION TYPE?????
:	IF THIS IS PLU,THE DESTINATION IS PC.VRC.SEND,ELSE PC_T2.SEND
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
:	ST	R7,BBUFER+DQSCB,R3,	:SET SCB PTR TO 'NULL'(4/28/85/CHS)
	ST	R9,BBUFER+DQSCB,R3,	:SET SCB PTR(4/28/85/CHS)
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	JR	R14			:RETURN

T.DQP2
	JR	R14			:RETURN

:	T.IPRS	-(TC_OR_BF_TC.IPR_SEND) DETERMINES IF AN IPR MAY BE
:	SENT BASED ON THE STATE OF FSM_PAC_RQ_RCV. IF IT CAN BE SENT
:	GENERATES AN IPR AND SENDS IT TO PATH CONTROL. THIS PROCEDURE
:	IS DISPATCHED WHEN AN OPEN QUEUE IS SENT TO IT FROM THE 
:	HIGH-LEVEL SCHEDULER.
:	PAGE 4-29 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:
:	OUTPUT	:
:	LINK	:
:	WORKING	:
T.IPRS
					:(12/04/85/TTW)
:	IF TCCB.RCV_PACING = YES
:	------------------------
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGINAL
	CLHI	R1,SG.IPR		:'SEND IPR SIGINAL'?
	JN	T.CRASH			:CRASH IF NOT SEND IPR SIGINAL
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB_PTR FOR THIS SESSION
	LHL	R15,SCBBLK+SCTCCB,R9,	:GET TC CONTROL BLOCK PTR
	JLE	T.CRAS			:CRASH IF SCB_PTR NULL
	LB	R5,TCBBLK+TCCBFG,R15,	:GET CONTROL FLAG
	NHI	R5,TC.RPA		:MASK OF OTHER BITS
	JER	R14			:TCCB.RCV_PACING=NO, RETURN
:	CHECK FSM_PAC_RQ_RCV = PEND
:	---------------------------
	LHI	R1,FTCPRR		:GET INDEX OF FSM_PAC_RQ_RCV
	LB	R2,TCBBLK+TCSTAT,R1,R15,:GET CURRENT FSM STATE
	CLHI	R2,FS.ST2		:IS IT PENDING STATE?
	JNR	R14			:RETURN IF NOT PENDING STATE
:	CHECK UPM_RESOURCES = OK
:	------------------------
	JAL	R4,U.RESO,,		:CALL UPM RESOURCES
	J	0,R14			:RETURN IF NOT OK
	JAL	R8,T.CIPR		:CALL CREATE_IPR
	IF	\IPREFI			:(12/26/85/CHS)
	IF	IPREFI			:(12/26/85/CHS)
:	EFI = EXPEDITED (OPTIONAL)
:	---------------
	LB	R0,BBUFER+MUBIUF,R10,	:GET BIU FLAG FROM MUCB
	OHI	R0,MU.EFI		:SET EFI TO EXPEDITED
	STB	R0,BBUFER+MUBIUF,R10,	:STORE NEW VALUE INTO MUCB
	EI	(IPREFI)		:(12/26/85/CHS)
	EI	\(IPREFI)		:(12/26/85/CHS)
:	CALL FSM_PAC_RQ_RCV
:	-------------------
	LHI	R1,FTCPRR		:GET INDEX OF FSM_PAC_RQ_RCV
	LIS	R0,0			:CLEAR FSM INPUT
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FTMR,,		:CALL FSM_PAC_RQ_RCV
:	CHECK IF SCB.SCB_TYP = HALF_SESS
:	--------------------------------
	LB	R0,SCBBLK+SCACFG,R9,	:GET SESSION TYPE
	NHI	R0,SC.BFS		::MASK FOR SESSION TYPE
	JN	T.IPRX			:JUMP IF IT IS NOT HALF-SESSION
	LHI	R1,TCCMSD		:ORIGIN=TC.CPMGR
	JFS	T.IPRY			:JUMP TO PROCESS SENDING PROCEDURE
T.IPRX	LHI	R1,TCBFSD		:ORIGIN=BF.TC
T.IPRY	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	T.CRA1			:CRASH IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BUFFER COUNT
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R2,PCT2SD		:GET DESTINATION PROCEDURE
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE UP MU PTR INTO DQE
	ST	R9,BBUFER+DQSCB,R3,	:FILL IN DQE_SCB PTR
	ST	R15,BBUFER+DQTCCB,R3,	:FILL IN DQE_TCCB PTR
:	THE DESTINATION IS VARIED DEPENDS ON SESSION TYPE?????
:	IF THIS IS PLU, THE DESTINATION IS PC.VRC.SEND, ELSE PC_T2.SEND
	LCS	R7,1			:LOAD -1 INTO OTHER FIELD
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINS LENGTH TO 'NULL'
	JAL	R8,SEND,,		:JUMP TO EXEC 'SEND' STATEMENT
	LR	R10,R9			:R10=SCB_PTR
	JR	R14			:RETURN

	SUBTTL	TRANSMISSION CONTROL - CONNECTION POINT MANAGER

:***********************************************************
:	TC ELEMENT - CONNECTION POINT MANAGER (TC.CPMGR)
:***********************************************************

:	T.CMRV	-(TC.CPMGR.RCV) IF THE MESSAGE UNIT CONTAINS A PACING
:	RESPONSE, IT IS PROCESSED. TYPE 1 NODES HAVE SNF ADDED. REQUESTS
:	AND RESPONSES ARE ROUTED AND PACING REQUESTS ARE PROCESSED.
:	PAGE 4-36 ON FAPL
:	------------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:R12 (PTR TO CURRENT EV) R13 (NCB) RNODE (NODE #)
:	OUTPUT	:
:	LINK	:R14 
:	WORKING	:
T.CMRV
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	T.CRAS			:CRASH,IF NOT NO_SIGNAL

T.CMRC
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS THE BUFFER PTR VALID?
	JN	T.CRAS			:CRASH,IF NOT
	LB	R0,BBUFER+MUSCHK,R10,	:GET SEND_CHECK_SENSE BIT
	JN	T.CRAS			:CRASH,IF SEND_CHECK_SENSE SET
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR FROM NCB
	JLE	T.CRAS			:CRASH,IF SCB_PTR NULL
	LHL	R15,SCBBLK+SCTCCB,R9,	:GET TCCB_PTR=SCB.TC_CB_PTR
	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	T.CMR8			:JUMP,IF IT IS NOT SET (NOT BBIU)
	JAL	R8,T.CRCK,,		:JUMP TO TC.CPMGR.RCV_CHECKS
	LHL	R5,TCCKTB,R1,R1		:GET PROCESSING ENTRY ACCORDING TO RC
	J	TCCKTB,R5,

TCCKTB	HS
	HC	T.CMR0-TCCKTB		:RETURN CODE IS GOOD
	HC	T.CMR1-TCCKTB		:RETURN CODE IS DISCARD_MU
	HC	T.CMR2-TCCKTB		:RETURN CODE IS NEG_RSP
	HC	T.CMR0-TCCKTB		:RETURN CODE IS OTHERS

:	RETURN CODE FROM TC.CPMGR.RCV_CHECKS IS DISCARD_MU
:	------------------------------------------------
T.CMR1
	JAL	R8,R.DSMU,,		:DISCARD MUCB
	JR	R14			:RETURN

:	RETURN CODE FROM TC.CPMGR.RCV_CHECKS IS NEG_RSP
:	------------------------------------------------
T.CMR2
	LHI	R2,TCCMSD		:GET DESTINATION PROCEDURE #
T.CMR6
	LHI	R1,TCCMRV		:GET SENDING PROCEDURE #
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R13,T.RSEN,,		:CALL SEND MU COMMON ROUTINE
	JR	R14			:RETURN

:	RETURN CODE FROM TC.CPMGR.RCV_CHECKS IS OTHERS 
:	------------------------------------------------
:	CALL FSM_CNTL_IMMED_EXP
T.CMR0
	LHI	R1,FSCCIE		:GET INDEX OF FSM_CNTL_IMMED_EXP
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
	LB	R3,BBUFER+MURHF1,R10,	:GET FLAG BYTE TO CHAECK RRI
	NHI	R3,MU.CTG		:MASK OFF OTHER BITS
	JEFS	T.CMR9			:JUMP,IF RU_CTGY=FMD
	CLHI	R3,MU.DFC		:CHECK RU_CTGY IS DFC OR NOT?
	JN	T.CMR3			:JUMP,IF RU_CTGY<>DFC
:	RU_CTGY=(DFC |FMD) 
:	---------------------------------
T.CMR9
	LB	R1,SCBBLK+SCFMDT,R9,	:SET UP #FSM_DT INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
:	R1 IS RETURN VALUE FROM FSM (RECEIVE_CHECK)
:	-------------------------------------------
	CLHI	R1,DCARMU		:IS RECEIVE_CHECK=DISCARD_MU?
	JE	T.CMR1			:JUMP,IF RECEIVE_CHECK=DISCARD_MU
:	NEED TO CALL PAC_RSP_RCV,
					:(12/19/85/TTW)
	JAL	R8,T.PRRV		:CHECK IF IPR_DISCARDED
:	R1 IS THE RETURN CODE FROM PAC_RSP_RCV
:	YES = IPR_DISCARDED
	CLHI	R1,YES			:YES = IPR_DISCARDED
	JER	R14			:RETURN IF IPR_DISCARDED

:	NCB.PU_TYPE=PU_T1 CALL ADD_SNF_FOR_T1??????
:	----------------------------------------
T.CMR3
	LB	R3,BBUFER+MURHF1,R10,	:GET FLAG BYTE TO CHAECK RRI
	NHI	R3,MU.CTG		:MASK OFF OTHER BITS
	JE	T.CMR4			:JUMP IF RU_CTGY=FMD
	CLHI	R3,MU.DFC		:CHECK RU_CTGY IS DFC OR NOT?
	JE	T.CMR4			:JUMP,IF RU_CTGY=DFC
	CLHI	R3,MU.NC		:IS RU_CTGY NC?
	JE	T.CMR5			:JUMP,IF RU_CTGY=NC
:	RU_CTGY=SC
:	------------
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,TCCMRV		:GET SENDING PROCEDURE #
	LHI	R2,TCSCRV		:GET DESTINATION PROCEDURE #
	JAL	R13,T.RSEN,,		:CALL SEND MU COMMON ROUTINE
	JR	R14			:RETURN
:	RU_CTGY=DFC,FMD
:	----------------
T.CMR4
	LHI	R2,DFCRCV		:SETUP DESTINATION PROCEDURE #
	LB	R3,BBUFER+MUBIUF,R10,	:GET MUBIUF BYTE
	NHI	R3,MU.EFI		:MASK OFF OTHER BITS
	JN	T.CMR6			:JUMP IF EFI=EXPEDITED
	LB	R3,BBUFER+MURHF1,R10,	:GET FLAG BYTE TO CHAECK RRI
	NHI	R3,MU.RRI		:MASK OFF OTHER BITS
	JN	T.CMR7			:JUMP IF IT IS RSP
:	RU_CTGY=DFC,FMD & EFI=NORMAL & RRI=RQ
:	-------------------------------------
	JAL	R8,T.CRNR,,		:CALL TC.CPMGR.RCV.NORMAL_RQ
:	INSERT MU LAST IN SCB.Q_TC_TO_DFC
:	---------------------------------
T.CMR8
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,CLEMP5		:CRASH,IF NO MORE FREE LINK
	LHL	R7,SCBBLK+SCQTDR,R9,	:GET SCB.Q_TC_TO_DFC RELEASE PTR
	BBSTOR	R10,CMDBLK+CLARG,R7,	:STORE MU PTR
	STH	R6,CMDBLK+CLPTR,R7,	:LINK NEW ENTRY
	STH	R6,SCBBLK+SCQTDR,R9,	:UPDATE RELEASE PTR IN Q
	LB	R4,SCBBLK+SCBREL,R9,	:GET SCB REL # (01/15/85 MIA)
	SBT	R4,NCBBLK+NDQTDF,R13,	:SET DATA PRESENT (01/15/85 MIA)
	JR	R14			:RETURN

:	RU_CTGY=DFC,FMD & EFI=NORMAL & RRI=RSP
:	-------------------------------------
T.CMR7
	LB	R3,BBUFER+MURHF2,R10,	:GET MURHF2 BYTE
	NHI	R3,MU.QRI		:MASK OFF OTHER BITS
	JN	T.CMR8			:JUMP,IF IT'S QR
	LHI	R2,DFCRCV		:SETUP DESTINATION PROCEDURE #
	J	T.CMR6			:JUMP TO SEND MU TO DFC.RCV
:	RU_CTGY=NC
:	----------
T.CMR5
	JAL	R7,R.RQN,,		:JUMP TO CHECK MSG'S RESPONSE MADE
	J	T.CMRA			:JUMP IF NOT OK
	J	T.CMR1			:JUMP TO DISCARD MU
T.CMRA
	LB	R3,BBUFER+MURHF1,R10,	:GET FLAG BYTE TO CHAECK RRI
	NHI	R3,MU.RRI		:MASK OFF OTHER BITS
	JN	T.CMR1			:JUMP IF IT IS RSP
	LHI	R0,.CGNSU		:SETUP CATEGORY NOT SUPPORTED
	JAL	R5,R.MUNR,,		:JUMP TO CALL CHANGE_MU_TO_NEG_RSP
	J	T.CMR2


:	T.CMSD	-(TC.CPMGR.SEND) USAGE AND STATE CHECKS ARE PERFORMED.
:	IF REQUIRED, THE MESSAGE UNIT IS ENCIPHERED. IF PACING IS
:	SUPPORTED, THE MESSAGE UNIT MAY BE PLACED ON Q_PAC.
:	PAGE 4-31 ON FAPL
:	------------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:R14 (RETURN ADDRESS) R12 (EV_PTR) RNODE R13 (NCB_PTR)
:	OUTPUT	:
:	LINK	:R14
:	WORKING	:
T.CMSD
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	T.CRAS			:CRASH,IF NOT NO_SIGNAL

T.CMSA
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS THE BUFFER PTR VALID?
	JN	T.CRAS			:CRASH,IF NOT
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR FROM NCB
	JLE	T.CRAS			:CRASH,IF SCB_PTR NULL
	LHL	R15,SCBBLK+SCTCCB,R9,	:GET TCCB_PTR=SCB.TC_CB_PTR
:	IS THIS DISPATCHED BY TC.SC*?
:	-----------------------------
	LB	R4,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	CLHI	R4,TCSCSD		:IS IT SEND FROM TC.SC.SEND?
	JE	T.CMS9			:JUMP,IF YES
	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
:	JE	T.CMS8			:JUMP,IF IT IS NOT SET (NOT BBIU)(01/06/86/TTW/BEG)
	JNFS	T.CMSB			:JUMP,IF IT IS FIRST SEGMENT
	LB	R0,TCBBLK+TCCBFG,R15,	:GET TCCB FLAG
	THI	R0,TC.SPA		:CHECK TCCB.SEND_PACING
	JN	T.CMSX			:JUMP IF YES
	J	T.CMS8			:SEND MU IF PAC=NO
T.CMSB					:(01/06/86/TTW/END)
:	SKIP,TC.CPMGR.SEND_CHECKS HAS DONE IN DFC LAYERS
:	--------------------------------------------------
:	JAL	R8,T.CSCK,,		:JUMP TO TC.CPMGR.SEND_CHECKS
:	J	T.CMS1			:JUMP,IF CHECKS IS NG
:	ELSE DO THE OTHER CHECKING
:	-------------------------------
T.CMS9
	LIS	R0,0			:CLEAR VALUE X'0000'
	ST	R0,BBUFER+MUSCKS,R10,	:CLEAR MUCB.SEND_CHECK_SENSE
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,T.CMS0,R1,R1		:GET ENTRY PTR FOR EACH COMBINATION
	J	T.CMS0,R5,

T.CMS0	HS
	HC	T.CMS2-T.CMS0		:ENTRY PTR FOR NORMAL & RQ
	HC	T.CMS3-T.CMS0		:ENTRY PTR FOR NORMAL & RSP
	HC	T.CMS4-T.CMS0		:ENTRY PTR FOR EXPEDITED & RQ
	HC	T.CMS5-T.CMS0		:ENTRY PTR FOR EXPEDITED & RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------
T.CMS2
	JAL	R8,T.CSNQ,,		:CALL TC.CPMGR.SEND_NORMAL_RQ
	J	T.CMS5			:JUMP,IF PACE=NO
	J	T.CMS7			:YES (NEEDS TO BE DEFINED AS CONSTANT)

:	EFI=NORMAL & RRI=RSP
:	-------------------
T.CMS3
	JAL	R8,T.CSNP,,		:CALL TC.CPMGR.SEND_NORMAL_RSP
	J	T.CMS5			:JUMP,IF PACE=NO
T.CMS7
	LHI	R0,YES			:YES (NEEDS TO BE DEFINED AS CONSTANT)
	J	T.CMS6

:	EFI=EXPEDITED & RRI=RQ
:	-------------------
T.CMS4
:	CALL FSM_CNTL_IMMED_EXP
	LHI	R1,FSCCIE		:GET INDEX OF FSM_CNTL_IMMED_EXP
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM

:	EFI=EXPEDITED & RRI=RSP
:	-------------------
T.CMS5
	LHI	R0,NO			:SET PACE TO NO

:	CHECK PACE BIT AND MUCB.SEND_CHECK_SENSE
:	----------------------------------------
T.CMS6
	L	R1,BBUFER+MUSCKS,R10,	:GET MUCB.SEND_CHECK_SENSE
	JN	T.CMS1			:JUMP,IF MUCB.SEND_CHECK_SENSE<>0
:	DO WE HAVE TO CHECK PACE BIT AFTER CHECKING MUCB.SEND_CHECK_SENSE???
:	-----------------------
	LR	R0,R0			:GET PACE BIT
	JE	T.CMS8			:JUMP,WHEN PACE=NO
:	PACE=YES, INSERT MU LAST IN TCCB.Q_PAC
:	---------------------------------
T.CMSX					:(01/06/86/TTW)
	JAL	R4,GETCL,,		:GET A FREE LINK
	JAL	R4,CLEMP5		:CRASH,IF NO MORE FREE LINK
	L	R4,NCBBLK+NDSSCB,R13,	:GET SCB POINTER (01/15/85 MIA)
	LB	R4,SCBBLK+SCBREL,R4,	:GET SCB REL # (01/15/85 MIA)
	SBT	R4,NCBBLK+NDQTCP,R13,	:SET DATA PRESENT (01/15/85 MIA)
	LHL	R7,TCBBLK+TCQSPR,R15,	:GET TCCB.Q_PAC RELEASE PTR
	BBSTOR	R10,CMDBLK+CLARG,R7,	:STORE MU PTR
	STH	R6,CMDBLK+CLPTR,R7,	:LINK NEW ENTRY
	STH	R6,TCBBLK+TCQSPR,R15,	:UPDATE RELEASE PTR IN QUEUE
	JR	R14			:RETURN
:	PACE=NO, SEND MU TO #PC
:	-----------------------------
T.CMS8
	LB	R2,TCBBLK+TCCMPC,R15,	:GET #PC FOR DESTINATION PROC.
	LHI	R1,TCCMSD		:GET SENDING PROCEDURE #
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R13,T.RSEN,,		:CALL SEND MU COMMON ROUTINE
	JR	R14			:RETURN

:	IF NOT (TC.CPMGR.SEND_CHECKS=NG & (<>DISPATCHED BY(TC.SC*))
:	--------------------------------------------------------------
T.CMS1
	J	T.CRAS			:CRASH FOR TESTING(SHOULD NOT HAPPEN)
	LIS	R0,1
	STB	R0,BBUFER+MUSCHK,R10,	:SET SEND_CHECK_SENSE BIT
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,TCCMSD		:GET SENDING PROCEDURE #
	LB	R2,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	JAL	R13,T.RSEN,,		:CALL SEND MU COMMON ROUTINE
	JR	R14			:RETURN

	SUBTTL	TRANSMISSION CONTROL - SESSION CONTROL

:***********************************************************
:	TC ELEMENT - SESSION CONTROL (TS.SC)
:***********************************************************

:	INPUT FROM -- TC.CPMGR.RCV
:	==============================
:	T.SCRV	-(TC.SC.RCV) CHECKS THAT THE FUNCTION IS SUPPORTED.
:	AND MAKES STATE RECEIVE CHECKS. IF THE CHECKS FAIL,THE 
:	MESSAGE UNIT IS DISCARDED OR RETURNED AS A -RSP.
:	OTHERWISE,MESSAGE UNIT IS ROUTED TO THE FSM'S.
:	PAGE 4-44 ON FAPL
:	------------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:R14 (LINK) R13 (NCB_PTR) R12 (EV_PTR)
:	OUTPUT	:
:	LINK	:
:	WORKING	:
T.SCRV
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	T.CRAS			:CRASH,IF NOT NO_SIGNAL

T.SCR6
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS THE BUFFER PTR VALID?
	JN	T.CRAS			:CRASH,IF NOT
	LB	R0,BBUFER+MUSCHK,R10,	:GET SEND_CHECK_SENSE BIT
	JN	T.CRAS			:CRASH,IF SEND_CHECK_SENSE SET
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR FROM NCB
	JLE	T.CRAS			:CRASH,IF SCB_PTR NULL
:	L	R15,NCBBLK+NDTCCB,R13,	:GET TC CONTROL BLOCK PTR(12/24/85/CHS)
	LHL	R15,SCBBLK+SCTCCB,R9,	:GET TCCB_PTR FROM SCB (12/24/85/CHS)
	JLE	T.CRAS			:CRASH,IF SCB_PTR NULL
	JAL	R8,T.SRCK,,		:CALL TC.SC.RCV_CHECKS
:	THE RETURN CODE IS IN R1
:	-----------------------
	LHL	R5,T.SCR0,R1,R1		:GET ENTRY PTR FROM TABLE
	J	T.SCR0,R5,

T.SCR0	HS
	HC	T.SCR1-T.SCR0		:THE RETURN CODE IS GOOD
	HC	T.SCR2-T.SCR0		:THE RETURN CODE IS DISCARD_MU
	HC	T.SCR3-T.SCR0		:THE RETURN CODE IS NEG_RSP

:	THE RETURN CODE FROM TC.SC.RCV_CHECKS IS GOOD
:	----------------------------------------------
:	CALL #FSM_DT,#FSM_STN,#FSM_RQR,#FSM_CRV,SEND MU TO #SVC_MGR
T.SCR1
	LB	R1,SCBBLK+SCFMDT,R9,	:SET UP #FSM_DT INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
	LB	R1,SCBBLK+SCFMST,R9,	:SET UP #FSM_STSN INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
	LB	R1,SCBBLK+SCFMRQ,R9,	:SET UP #FSM_RQR INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
	LB	R1,SCBBLK+SCFMCR,R9,	:SET UP #FSM_CRV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
:	SEND MU TO #SVC_MGR
:	-------------------
	LB	R2,SCBBLK+SCSVMV,R9,	:GET #SVC_MGR FOR DESTINATION PROC.
	LHI	R1,TCSCRV		:GET SENDING PROCEDURE #
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R13,T.RSEN,,		:CALL SEND MU COMMON ROUTINE
	JR	R14			:RETURN

:	THE RETURN CODE FROM TC.SC.RCV_CHECKS IS DISCARD_MU
:	----------------------------------------------
T.SCR2
	JAL	R8,R.DSMU,,		:DISCARD MUCB
	JR	R14			:RETURN

:	THE RETURN CODE FROM TC.SC.RCV_CHECKS IS NEG_RSP
:	----------------------------------------------
T.SCR3
	LHI	R2,TCCMSD		:GET DESTINATION PROCEDURE #
	LHI	R1,TCSCRV		:GET SENDING PROCEDURE #
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R13,T.RSEN,,		:CALL SEND MU COMMON ROUTINE
	JR	R14			:RETURN

T.RSEN
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	T.CRA1			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BUFFER CNT
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	ST	R9,BBUFER+DQSCB,R3,	:STORE SCB PTR INTO DQE
	ST	R15,BBUFER+DQTCCB,R3,	:STORE TCCB PTR INTO DQE
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
	STH	R7,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO 'NULL'
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	STB	R7,BBUFER+DQNWCM,R3,	:CLEAR DQNWCM
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	JR	R13			:RETURN

:	INPUT FROM -- PU.SVC_MGR.NS,LU.SVC_MGR.SS,SSCP.SVC_MGR.CS
:	==========================================================
:	T.SCSD	-(TC.SC.SEND) CHECKS THAT THE FUNCTION IS SUPPORTED
:	AND MAKES STATE SEND CHECKS. IF THE CHECKS FAIL, A SEND-
:	CHECK SENSE DATA IS SENT TO THE SENDING PROCEDURE,A 
:	NAU.SVC_MGR. OTHERWISE, THE MESSAGE UNIT IS SENT TO THE PROPER
:	FSM. AFTER AN SNF IS FILLED IN FOR EXPEDITED REQUESTS, THE MU
:	IS SENT ON.
:	PAGE 4-47 ON FAPL
:	------------------------------------------------------------------
:	THE USAGES OF REGISTERS ---
:	INPUT	:R14 (LINK) R12 (EV_PTR) R13 (NCB_PTR)
:	OUTPUT	:
:	LINK	:R14
:	WORKING	:
T.SCSD
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.NOS		:IS IT NOT NO_SIGNAL?
	JN	T.CRAS			:CRASH,IF NOT NO_SIGNAL

T.SCS3
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS THE BUFFER PTR VALID?
	JN	T.CRAS			:CRASH,IF NOT
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR FROM NCB
	JLE	T.CRAS			:CRASH,IF SCB_PTR NULL
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR
	LB	R0,BBUFER+MUSCHK,R10,	:GET SEND_CHECK_SENSE BIT
	JN	T.CRAS			:CRASH,IF SEND_CHECK_SENSE SET
	LIS	R0,0			:CLEAR VALUE X'0000'
	ST	R0,BBUFER+MUSCKS,R10,	:CLEAR MUCB.SEND_CHECK_SENSE
	JAL	R8,T.SSCK,,		:CALL TC.SC.SEND_CHECKS
	J	T.SCS0			:JUMP,IF RETURN IS NG
	JAL	R8,T.CSCK,,		:CALL TC.CPMGR.SEND_CHECKS
	J	T.SCS0			:JUMP,IF RETURN IS NG
:	TC.SC.SEND_CHECKS<>NG & TC.CPMGR.SEND_CHECKS<>NG
:	-------------------------------------------------
:	UPDATE FSM'S
:	==================
	LB	R1,SCBBLK+SCFMDT,R9,	:SET UP #FSM_DT INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
	LB	R1,SCBBLK+SCFMST,R9,	:SET UP #FSM_STSN INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
	LB	R1,SCBBLK+SCFMRQ,R9,	:SET UP #FSM_RQR INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
	LB	R1,SCBBLK+SCFMCR,R9,	:SET UP #FSM_CRV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL ROUTINE FOR FSM
	LB	R3,BBUFER+MURHF1,R10,	:GET FLAG BYTE TO CHAECK RRI
	NHI	R3,MU.RRI		:MASK OFF OTHER BITS
	JN	T.SCS2			:JUMP IF IT IS RSP
:	RRI=RQ, DO THE FOLLOWINGS: SNF=UPM_ID_EXP,IF RQ_CODE=CLEAR
:	SCB.LAST_CLEAR_SNF=SNF
:	ASSIGN VALUE TO SNF FOR REQUEST AND SAVE THE SNF VALUE IF IT IS A
:	CLEAR REQUEST
:	----------------------------------------------------------------
	GL	U.IAEX
	JAL	R4,U.IAEX,,		:CALL UPM_ID_EXP,R1 IS RETURN VALUE
	STH	R1,BBUFER+MUSNF,R10,	:SET MUSNF TO SCB.RCV_EXP_SNF
	BBLOAD	R1,BBUFER+MURUPT,R10,	:R1 CONTAINS RU PTR
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CLEAR		:IS RQ_CODE=CLEAR?
	JN	T.SCS2			:JUMP IF RQ_CODE<>CLEAR
	LHL	R1,BBUFER+MUSNF,R10,	:GET SNF FROM MUCB
	STH	R1,SCBBLK+SCLCSN,R9,	:SET SCB.LAST_CLEAR_SNF TO MUSNF
:	CALL SC_FORMAT_SET AND SEND MU TO TC.CPMGR.SEND
:	-----------------------------------------------
T.SCS2
	JAL	R8,T.SFST,,		:CALL SC_FORMAT_SET
	LHI	R2,TCCMSD		:GET DESTINATION PROCEDURE #
	LHI	R1,TCSCSD		:GET SENDING PROCEDURE #
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R13,T.FSEN,,		:CALL COMMON ROUTINE TO SEND
	LB	R2,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	CLHI	R2,LUSEND		:IS IT SEND BY LU.SVC_MGR?
	JNR	R14			:RETURN,IF NOT
:	(9/18/84/CHS)	GENERATE MUCB - LUSEND NEEDS IT
	JAL	R4,GBB,,		:CREATE NEW MUCB IN R3
	J	T.CRA1			:CRASH, IF NO BUFFER AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LB	R4,BBUFER+MUDADP,R10,	:COPY MUDADP FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MUDADP,R3,	:
	LB	R4,BBUFER+MUOADP,R10,	:COPY MUOADP FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MUOADP,R3,	:
	LB	R4,BBUFER+MURHF1,R10,	:COPY MURHF1 FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MURHF1,R3,	:
	LB	R4,BBUFER+MURHF2,R10,	:COPY MURHF2 FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MURHF2,R3,	:
	LB	R4,BBUFER+MURHF3,R10,	:COPY MURHF3 FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MURHF3,R3,	:
	LB	R4,BBUFER+MUBIUF,R10,	:COPY MUBIUF FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MUBIUF,R3,	:
	LHI	R2,LUSEND		:SET UP R2 AGAIN
	LR	R10,R3			:R10 = NEW MUCB
:	(9/18/84/CHS)	END OF GENERATION MUCB INSERTION
	LIS	R0,0			:SET SEND_SENSE_CHECK TO O.K.
	J	T.SCS4			:JUMP TO SEND NOTIFICATION FOR LU.SVC
:	TC.SC.SEND_CHECKS=NG | TC.CPMGR.SEND_CHECKS=NG
:	----------------------------------------------
T.SCS0
	L	R0,BBUFER+MUSCKS,R10,	:GET MUCB.SEND_CHECK_SENSE
	JE	T.SCS1			:JUMP,IF MUCB.SEND_CHECK_SENSE=0
:	SEND SEND_CHECK TO SENDING_PROCEDURE
:	-------------------------------------
	LB	R2,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	LIS	R0,1
T.SCS4
	STB	R0,BBUFER+MUSCHK,R10,	:SET SEND_CHECK_SENSE BIT
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,TCSCSD		:GET SENDING PROCEDURE #
	JAL	R13,T.FSEN,,		:CALL COMMON ROUTINE TO SEND MU
	JR	R14			:RETURN
:	DISCARD MU
:	-----------
T.SCS1
	JAL	R8,R.DSMU,,		:DISCARD MUCB
	JR	R14			:RETURN
:	COMMON ROUTINE FOR TC LAYER TO PROCESS SEND STATEMENT
:	------------------------------------------------------
T.FSEN
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	T.CRA1			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BUFFER CNT
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	ST	R9,BBUFER+DQSCB,R3,	:STORE SCB PTR INTO DQE
	STH	R15,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO 'NULL'
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	STB	R7,BBUFER+DQNWCM,R3,	:CLEAR DQNWCM
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	JR	R13			:RETURN


	SUBTTL	TRANSMISSION CONTROL - BOUNDARY FUNCTION SUPPORT

:***********************************************************
:	BF.TC PROTOCOL MACHINE IN THE NODE PROVIDING THE BF SUPPORT
:***********************************************************

:	T.BFSD	-(BF.TC.SEND) ENFORCES PACING PROTOCOLS IF APPLICABLE
:	PAGE 4-54 ON FAPL
:	-------------------------------------------------------------
T.BFSD
T.BFRV
	JR	R14

T.CRAS
	JAL	R10,CRASH,,
	BC	0,0,0,CRQTCC

T.CRA1
	J	NOENT5,,

CLEMP5
	J	CLMPTY,,

	FO	CBKDEF
	FO	CMDLST

	EM
  
	SUBTTL	SNA UNDEFINED PROTOCOL MACHINES (DFC)
:	MODULE NAME IN COMMAND FILE -- SDUP02.F00

:	*****************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	*****************************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT THE UNDEFINED PROTOCOL
:	MACHINES(UPM) IN THE SNA FAPL MANUAL FOR DATA FLOW CONTROL LAYER
:	-----------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF

	GL	D.CRAS

	SEG	A.CODE

:	U.RCKP	(UPM_RECEIVE_CHECKS_PROCESS) TO PROCESS RECEIVE ERROR
:	CONDITIONS. THESE ERRORS OCCUR ONLY WHEN THE OTHER HALF-SESSION
:	VIOLATES THE ARCHITECTURE. THE PROCEDURE TAKES THE FOLLOWING
:	ACTIONS:
:	(1)END THE SESSION BY SENDING UNBIND,THE SENSE IS AVAILABLE IN
:	   THE RECEIVE_CHECK_SENSE FIELD
:	(2)NOTIFY APPROPRIATE OPERATOR ASSOCIATED WITH THE NAU.
:	(3)LOG THE ERROR
:	PAGE 5-57 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R1 (SENDING PROCESS) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:
:	LINK	-R4
U.RCKP
	ST	R4,RGSAV4,,
	JAL	R8,R.DSMU,,		:RELEASE MUCB,RU PTR
	LIS	R10,0			:CLEAR MUCB PTR
	LB	R2,SCBBLK+SCSVMV,R9,	:GET SVC.MGR FOR DESTINATION
	LHI	R0,SG.UNB		:SIGNAL FOR UNBIND REQUEST
	JAL	R13,P.RSEN,,		:CALL SEND COMMON ROUTINE
	L	R4,RGSAV4,,		:GET BACK RETURN ADDRESS
	JR	R4			:RETURN

:	U.IANM	(UPM_ID_ASSIGN_NORMAL) THIS UPM ASSIGNS ID'S FOR
:	NORMAL-FLOW REQUESTS.
:	PAGE 5-45 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:
:	LINK	-R4
U.IANM
	JR	R4			:RETURN

:	U.IAEX	(UPM_ID_ASSIGN_EXPEDITED) THIS UPM ASSIGNS ID'S FOR
:	EXPEDITED-FLOW REQUESTS.
:	PAGE 5-46 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R9 (SCB) R13 (NCB) R10 (MUCB) R15 (LUCB_PTR)
:	OUTPUT	:
:	LINK	-R4
U.IAEX
	LHL	R1,SCBBLK+SCESQN,R9,	:GET EXPEDITED SEQUENCE #
	AIS	R1,1			:UPDATE BY 1
	LHL	R1,BBUFER+MUSNF,R10,	:GET THE NEW SEQ#
	STH	R1,SCBBLK+SCESQN,R9,	:STORE  THE NEW SEQ. #
	JR	R4			:RETURN

:	U.SANM	(UPM_SQN_ASSIGN_NORMAL) THIS UPM HANDLES CORRELATION
:	TABLE SEQUENCE FOR PU TYPE 1 NODES (FID3 TH)
:	PAGE 5-45 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS:
:	INPUT	-R15 (TCCB) R9 (SCB) R13 (NCB) R10 (MUCB)
:	OUTPUT	:
:	LINK	-R4
U.SANM
	JR	R4			:RETURN

	FO	CMDLST
	FO	CBKDEF

	EM

   
	SUBTTL	SNA PACKAGE(INITIALIZATION) - DATA FLOW CONTROL LAYER
:	MODULE NAME IN COMMAND FILE -- SDCI02.F00

:	********************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	********************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT INITIALIZATION OF FSM,DFC
:	AND SOME OTHER INITIALIZATION FUNCTIONS FOR SNA DATA FLOW
:	CONTROL LAYER (WHCIH DESCRIBED IN CHAPTER 5)
:	-----------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF

	SEG	A.CODE
A.COD2	EQ	.

:	D.IDFC	-(SESSACT.DFC_INITIALIZE) THE PURPOSE OF THIS PROCEDURE
:	IS TO SET UP,IN THE SCB, VARIOUS SESSION PARAMETERS, DFC COMMAND
:	USAGE AND DFC FSM USAGE FOR THE SESSION.
:	PAGE 5-31 ON FAPL
:	----------------------------------------------------------------
:	USAGE OF REGISTERS --
:	INPUT	-
:	OUTPUT	-
:	LINK	-R5
:	WORKING	-R3,R4,R6,R7 (PROTECTED FOR OTHER CALLING FSM ROUTINES)
D.IDFC
	JAL	R6,D.IMSP,,		:CALL DFC_INIT_MISC_SESSIONS_PARMS
	JAL	R6,D.IDUG,,		:CALL DFC_INIT_DFC_USAGE
	JAL	R6,D.IFSM,,		:CALL DFC_INIT_FSM_USAGE
	JR	R5

:	D.IDUG	-(DFC_INIT_DFC_USAGE) THIS PROCEDURE SETS UP SCB INDICATORS
:	FOR EACH DFC COMMAND. THESE INDICATORS SPECIFY WHETHER OR NOT THE
:	DFC COMMAND MAY BE SENT AND/OR RECEIVED. THE SETTING OF THESE
:	INDICATORS IS BASED ON THE FM PROFILE.
:	PAGE 5-32 ON FAPL
:	----------------------------------------------------------------
:	USAGE OF REGISTERS --
:	INPUT	-R5 (1ST-LEVEL CALL LINK) R9 (SCB_PTR)
:	OUTPUT	-
:	LINK	-R6
:	WORKING	-R3,R4,R6,R7 (PROTECTED FOR OTHER CALLING FSM ROUTINES)
D.IDUG
	LHL	R1,SCBBLK+SCDFNR,R9,	:GET DFC NORMAL REQUEST ALLOWED
	LB	R2,SCBBLK+SCACFG,R9,	:GET HALF_SESSION TYPE
	NHI	R2,SC.SES		:CHECK PRI OR SEC
	JE	D.IDU0			:JUMP,IF HALF_SESSION=SEC
	LB	R0,SCBBLK+SCPLUP,R9,	:GET PRI LU PROTOCOL
	NHI	R0,SC.PCU		:MASK FOR PRI_CHAIN_USE
	JEFS	D.IDUA			:JUMP,IF PRI_CHAIN_USE<>MULTIPLE
	OHI	R1,SC.CNS		:SET SCB.DFC_CANCEL_SEND TO ALLOWED
D.IDUA
	LB	R0,SCBBLK+SCSLUP,R9,	:GET SEC LU PROTOCOL
	NHI	R0,SC.SCU		:MASK FOR SEC_CHAIN_USE
	JEFS	D.IDUB			:JUMP,IF SEC_CHAIN_USE<>MULTIPLE
	OHI	R1,SC.CNR		:SET SCB.DFC_CANCEL_RCV ALLOWED
D.IDUB
	STH	R1,SCBBLK+SCDFNR,R9,	:STORE NEW VALUE IN SCB
	J	D.IDU1
D.IDU0
	LB	R0,SCBBLK+SCSLUP,R9,	:GET SEC LU PROTOCOL
	NHI	R0,SC.SCU		:MASK FOR SEC_CHAIN_USE
	JEFS	D.IDUC			:JUMP,IF SEC_CHAIN_USE<>MULTIPLE
	OHI	R1,SC.CNS		:SET SCB.DFC_CANCEL_SEND TO ALLOWED
D.IDUC
	LB	R0,SCBBLK+SCPLUP,R9,	:GET PRI LU PROTOCOL
	NHI	R0,SC.PCU		:MASK FOR PRI_CHAIN_USE
	JEFS	D.IDUD			:JUMP,IF PRI_CHAIN_USE<>MULTIPLE
	OHI	R1,SC.CNR		:SET SCB.DFC_CANCEL_RCV ALLOWED
D.IDUD
	STH	R1,SCBBLK+SCDFNR,R9,	:STORE NEW VALUE IN SCB
D.IDU1
	LB	R0,SCBBLK+SCFMPF,R9,	:GET SCB.FM_PROFILE
	CLHI	R0,PROF00		:IS IT PROFILE_0?
	JE	D.IDU2			:JUMP,IT IS PROFILE_0
	CLHI	R0,PROF03		:IS IT PROFILE_3?
	JE	D.IDU3			:JUMP,IT IS PROFILE_3
	CLHI	R0,PROF04		:IS IT PROFILE_4?
	JE	D.IDU4			:JUMP,IT IS PROFILE_4
	CLHI	R0,PROF06		:IS IT PROFILE_6?
	JE	D.IDU5			:JUMP,IT IS PROFILE_6
	CLHI	R0,PROF07		:IS IT PROFILE_7?
	JE	D.IDU6			:JUMP,IT IS PROFILE_7
	CLHI	R0,PROF18		:IS IT PROFILE_18?
	JE	D.IDU7			:JUMP IT IS PROFILE_18
	JR	R6			:ELSE,RETURN
:	PROFILE_0 (R2 CONTAINS HAL_SESSION TYPE)
:	---------
D.IDU2
	LHL	R1,SCBBLK+SCDFNR,R9,	:GET DFC NORMAL REQUEST ALLOWED
	LR	R2,R2
	JEFS	D.IDUE			:JUMP,IF HALF_SESSION=SEC
	OHI	R1,SC.LSR		:SET SCB.DFC_LUSTAT_RCV
	NHI	R1,@SC.LSS		:CLEAR DFC_LUSTAT_SEND
	JFS	D.IDUF
D.IDUE
	OHI	R1,SC.LSS		:SET SCB.DFC_LUSTAT_SEND
	NHI	R1,@SC.LSR		:CLEAR DFC_LUSTAT_RCV
D.IDUF
	STH	R1,SCBBLK+SCDFNR,R9,	:SET DFC NORMAL REQ ALLOWED
	JR	R6

:	PROFILE_3 (R2 FOR HALF_SESSION TYPE)
:	---------
D.IDU3
	LHL	R0,SCBBLK+SCDFER,R9,	:GET DFC EXPEDITED FLOW ALLOWED
	LHL	R1,SCBBLK+SCDFNR,R9,	:GET DFC NORMAL REQUEST ALLOWED
	OHI	R0,SC.SGR+SC.SGS
	OHI	R1,SC.CHR+SC.CHS
	LR	R2,R2			:CHECK PRI OR SEC
	JE	D.IDU8			:JUMP,IF HALF_SESSION=SEC
	OHI	R0,SC.SDS+SC.SCR+SC.RSR
	OHI	R1,SC.LSR		:SET SCB.DFC_LUSTAT_RCV
	J	D.IDU9			:JUMP
D.IDU8
	OHI	R0,SC.SDR+SC.SCS+SC.RSS
	OHI	R1,SC.LSS		:SET SCB.DFC_LUSTAT_SEND
D.IDU9
	STH	R0,SCBBLK+SCDFER,R9,	:SET DFC EXPEDITED FLOW ALLOWED
	STH	R1,SCBBLK+SCDFNR,R9,	:SET DFC NORMAL REQ ALLOWED
	JAL	R7,D.IBRT,,		:CALL DFC_INIT_DFC_USAGE_BID_RTR
	JR	R6			:RETURN

:	PROFILE_4
:	---------
D.IDU4
:	PROFILE_6
:	---------
D.IDU5
:	PROFILE_7
:	------------
D.IDU6
:	PROFILE_18
:	----------
D.IDU7
	JR	R6


:	D.IFSM	-(DFC_INIT_FSM_USAGE) THIS PROCEDURE SETS UP FSM USAGE FOR
:	THIS HALF-SESSION'S DFC.
:	PAGE 5-34 ON FAPL
:	----------------------------------------------------------------
:	USAGE OF REGISTERS --
:	INPUT	-R5 (1ST-LEVEL CALL LINK) R9 (SCB_PTR)
:	OUTPUT	-
:	LINK	-R6
:	WORKING	-R3,R4,R6,R7 (PROTECTED FOR OTHER CALLING FSM ROUTINES)
D.IFSM
	LHI	R0,FSMNOP		:INIT VALUE 'NO-OP'
	STB	R0,SCBBLK+SCFBSM,R9,	:INIT FSM_BSM
	STB	R0,SCBBLK+SCFCHR,R9,	:INIT FSM_CHAIN_RCV
	STB	R0,SCBBLK+SCFCHS,R9,	:INIT FSM_CHAIN_SEND
	STB	R0,SCBBLK+SCFCBR,R9,	:INIT FSM_CONTROL_BSM_RSP_RCV
	STB	R0,SCBBLK+SCFCBS,R9,	:INIT FSM_CONTROL_BSM_RSP_SEND
	STB	R0,SCBBLK+SCHDRR,R9,	:INIT FSM_CONTROL_HDX_RSP_RCV
	STB	R0,SCBBLK+SCHDRS,R9,	:INIT FSM_CONTROL_HDX_RSP_SEND
	STB	R0,SCBBLK+SCFEBR,R9,	:INIT FSM_EBCD_RCV
	STB	R0,SCBBLK+SCFEBS,R9,	:INIT FSM_EBCD_SEND
	STB	R0,SCBBLK+SCFHDX,R9,	:INIT FSM_HDX
	STB	R0,SCBBLK+SCFIRR,R9,	:INIT FSM_IMM_RQ_MODE_RCV
	STB	R0,SCBBLK+SCFIRS,R9,	:INIT FSM_IMM_RQ_MODE_SEND
	STB	R0,SCBBLK+SCFQER,R9,	:INIT FSM_QEC_RCV
	STB	R0,SCBBLK+SCFQES,R9,	:INIT FSM_QEC_SEND
	STB	R0,SCBBLK+SCFQCR,R9,	:INIT FSM_QRI_CHAIN_RCV
	STB	R0,SCBBLK+SCFQCS,R9,	:INIT FSM_QRI_CHAIN_SEND
	STB	R0,SCBBLK+SCFQKS,R9,	:INIT FSM_QRI_CHECK_SEND
	STB	R0,SCBBLK+SCFRES,R9,	:INIT FSM_RES
	STB	R0,SCBBLK+SCFRTR,R9,	:INIT FSM_RTR
	STB	R0,SCBBLK+SCFSBR,R9,	:INIT FSM_SBI_RCV
	STB	R0,SCBBLK+SCFSBS,R9,	:INIT FSM_SBI_SEND
	STB	R0,SCBBLK+SCFSHT,R9,	:INIT FSM_SHUTD
	LHI	R0,FSCQCS		:SET FSM_QRI_CHECK_SEND
	STB	R0,SCBBLK+SCFQKS,R9,	:STORE FSM_QRI_CHECK_SEND
	LB	R2,SCBBLK+SCACFG,R9,	:GET HALF_SESSION TYPE
	NHI	R2,SC.SES		:CHECK PRI OR SEC
	JE	D.IFS2			:JUMP,IF HALF_SESSION=SEC
	LB	R0,SCBBLK+SCPLUP,R9,	:GET PRI LU PROTOCOL
	NHI	R0,SC.PCU		:MASK FOR PRI_CHAIN_USE
	JE	D.IFS1			:JUMP,IF PRI_CHAIN_USE<>MULTIPLE
	LHI	R0,FSCCSD		:FSM_CHAIN_SEND
	STB	R0,SCBBLK+SCFCHS,R9,	:SET NEW FSM VALUE
	LHI	R0,FSCQNS		:FSM_QRI_CHAIN_SEND
	STB	R0,SCBBLK+SCFQCS,R9,	:SET NEW FSM VALUE
D.IFS1
	LB	R0,SCBBLK+SCSLUP,R9,	:GET SEC LU PROTOCOL
	NHI	R0,SC.SCU		:MASK FOR SEC_CHAIN_USE
	JE	D.IFS3			:JUMP,IF SEC_CHAIN_USE<>MULTIPLE
	LHI	R0,FSCCRV		:FSM_CHAIN_RCV
	STB	R0,SCBBLK+SCFCHR,R9,	:SET NEW FSM VALUE
	LHI	R0,FSCQNR		:FSM_QRI_CHAIN_RCV
	STB	R0,SCBBLK+SCFQCR,R9,	:SET NEW FSM VALUE
	J	D.IFS3
D.IFS2
	LB	R0,SCBBLK+SCSLUP,R9,	:GET SEC LU PROTOCOL
	NHI	R0,SC.SCU		:MASK FOR SEC_CHAIN_USE
	JE	D.IFS0			:JUMP,IF SEC_CHAIN_USE<>MULTIPLE
	LHI	R0,FSCCSD		:FSM_CHAIN_SEND
	STB	R0,SCBBLK+SCFCHS,R9,	:SET NEW FSM VALUE
	LHI	R0,FSCQNS		:FSM_QRI_CHAIN_SEND
	STB	R0,SCBBLK+SCFQCS,R9,	:SET NEW FSM VALUE
D.IFS0
	LB	R0,SCBBLK+SCPLUP,R9,	:GET PRI LU PROTOCOL
	NHI	R0,SC.PCU		:MASK FOR PRI_CHAIN_USE
	JE	D.IFS3			:JUMP,IF PRI_CHAIN_USE<>MULTIPLE
	LHI	R0,FSCCRV		:FSM_CHAIN_RCV
	STB	R0,SCBBLK+SCFCHR,R9,	:SET NEW FSM VALUE
	LHI	R0,FSCQNR		:FSM_QRI_CHAIN_RCV
	STB	R0,SCBBLK+SCFQCR,R9,	:SET NEW FSM VALUE
D.IFS3
	LHL	R0,SCBBLK+SCDFER,R9,	:GET DFC EXPEDITED FLOW ALLOWED
	LR	R1,R0
	NHI	R1,SC.QER		:MASK FOR DFC_QEC_RCV
	JEFS	D.IFS6			:JUMP,IF NOT ALLOWED
	LHI	R2,FSCQRV		:SET FSM_QEC_RCV
	STB	R2,SCBBLK+SCFQER,R9,	:SET NEW FSM VALUE
D.IFS6
	LR	R1,R0
	NHI	R1,SC.QES		:MASK FOR DFC_QEC_SEND
	JEFS	D.IFS7			:JUMP,IF NOT ALLOWED
	LHI	R2,FSCQSD		:SET FSM_QEC_SEND
	STB	R2,SCBBLK+SCFQES,R9,	:SET NEW FSM VALUE
D.IFS7
	LR	R1,R0
	NHI	R1,SC.SDR		:MASK FOR DFC_SHUTD_RCV
	JEFS	D.IFSA			:JUMP,IF NOT ALLOWED
	LHI	R2,FSCSHR		:FSM_SHUTD_RCV
	JFS	D.IFS8
D.IFSA
	NHI	R0,SC.SDS		:MASK FOR DFC_SHUTD_SEND
	JEFS	D.IFS9			:JUMP,IF NOT ALLOWED
	LHI	R2,FSCSHS		:FSM_SHUTD_SEND
D.IFS8
	STB	R2,SCBBLK+SCFSHT,R9,	:SET NEW FSM VALUE
D.IFS9
	LB	R1,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAMETER
	LR	R2,R1
	NHI	R1,SC.MQM		:FOR THIS_HALF_SESS_RQ_MODE
	JNFS	D.IFS4			:JUMP,IF IT IS NOT IMMEDIATE
	LHI	R0,FSCIRS		:SET FSM_IMM_RQ_MODE_SEND
	STB	R0,SCBBLK+SCFIRS,R9,	:SET NEW FSM VALUE
D.IFS4
	NHI	R2,SC.PQM		:FOR PARTNER_HALF_SESSION_RQ_MODE
	JNFS	D.IFS5			:JUMP,IF IT IS NOT IMMEDIATE
	LHI	R0,FSCIRR		:SET FSM_IMM_RQ_MODE_RCV
	STB	R0,SCBBLK+SCFIRR,R9,	:SET NEW FSM VALUE
D.IFS5
	JAL	R7,D.IBSR,,		:CALL DFC_INIT_FSM_USAGE_BSM_SBI_RTR
	JAL	R7,D.IHDX,,		:CALL DFC_INIT_FSM_USAGE_HDX_RES
	JR	R6			:RETURN

:	D.IMSP	-(DFC_INIT_MISC_SESSION_PARMS) THE PURPOSE OF THIS PROCEDURE
:	IS TO SET UP SESSION PARAMETERS THAT NEED TO BE KNOWN BY DFC
:	PAGE 5-37 ON FAPL
:	----------------------------------------------------------------
:	USAGE OF REGISTERS --
:	INPUT	-R5 (1ST-LEVEL CALL LINK) R9 (SCB_PTR)
:	OUTPUT	-
:	LINK	-R6
:	WORKING	-R3,R4,R6,R7 (PROTECTED FOR OTHER CALLING FSM ROUTINES)
:	WORKING	-R2 (CONTAINS SCM.DFC_MISC_SESSION_PARAMETERS)
D.IMSP
:	SET UP BRACKETS OPTIONS
:	=======================
	LB	R2,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAMETERS
	LB	R0,SCBBLK+SCFMPF,R9,	:GET SCB.FM_PROFILE
	CLHI	R0,PROF02		:IS IT PROFILE_2?
	JE	D.IMS0			:JUMP,IT IS PROFILE_2
	CLHI	R0,PROF03		:IS IT PROFILE_3?
	JE	D.IMS0			:JUMP,IT IS PROFILE_3
	CLHI	R0,PROF04		:IS IT PROFILE_4?
	JE	D.IMS0			:JUMP,IT IS PROFILE_4
	CLHI	R0,PROF07		:IS IT PROFILE_7?
	JE	D.IMS0			:JUMP,IT IS PROFILE_7
	CLHI	R0,PROF18		:IS IT PROFILE_18?
	JN	D.IMS4			:JUMP IT IS NOT PROFILE_18
D.IMS0
	LB	R1,SCBBLK+SCCLUP,R9,	:GET BIND BYTE-6
	NHI	R1,SC.BRS		:CHECK BRACKETS_RESET_STATE
	JN	D.IMS1			:JUMP,IF  BRACKETS_RESET_STATE=BETB
	LB	R1,SCBBLK+SCPLUP,R9,	:GET BIND BYTE-4
	NHI	R1,SC.PEB		:CHECK PRI_EB_IND
	JN	D.IMS1			:JUMP,IF PRI_EB_IND=MAY_SEND
	LB	R1,SCBBLK+SCSLUP,R9,	:GET BIND BYTE-5
	NHI	R1,SC.SEB		:CHECK SEC_EB_IND
	JE	D.IMS4			:JUMP,IF SEC_EB_IND<>MAY_SEND
:	SCB.FM_PROFILE=(2|3|4|7|18) & (SCB.BRACKETS_RESET_STATE=BETB |
:	SCB.PRI_EB_IND=MAY_SEND | SCB.SEC_EB_IND=MAY_SEND)
:	----------------------------------------------------------------
D.IMS1
	OHI	R2,SC.UBK		:SET USING_BRACKETS TO 'YES'
	NHI	R2,@SC.1SP		:SET FIRST_SPEAKER TO 'NO'
	LB	R1,SCBBLK+SCACFG,R9,	:GET HALF_SESSION TYPE
	NHI	R1,SC.SES		:CHECK PRI OR SEC
	JE	D.IMS2			:JUMP,IF HALF_SESSION=SEC
	LB	R1,SCBBLK+SCSRMD,R9,	:GET BIND BYTE-7
	NHI	R1,SC.CWN		:MASK FOR SCB.CONT_WIN
	JN	D.IMS3			:JUMP,( CONT_WIN=PRI & SESSION=PRI)
	J	D.IMS5			:ELSE ,JUMP TO D.IMS5
D.IMS2
	LB	R1,SCBBLK+SCSRMD,R9,	:GET BIND BYTE-7
	NHI	R1,SC.CWN		:MASK FOR SCB.CONT_WIN
	JN	D.IMS5			:JUMP,NOT CONT_WIN=SEC & SESSION=SEC
:	IF (HALF_SESSION=PRI&CONT_WIN=PRI)|(HALF_SESSION=SEC&CONT_WIN=SEC)
:	----------------------------------------------------------------
D.IMS3
	OHI	R2,SC.1SP		:SET FIRST_SPEAKER TO 'YES'
	JFS	D.IMS5
D.IMS4
	NHI	R2,@SC.UBK		:SET USING_BRACKETS TO 'NO'
:	SET UP RESPONSE MODE
:	====================
:	R0 (CONTAINS PROFILE TYPE) R2 (CONTAINS SCMSSP)
:	-----------------------------------------------
D.IMS5
	CLHI	R0,PROF05		:IS IT PROFILE_5?
	JE	D.IMS6			:JUMP,IT IS PROFILE_5
	CLHI	R0,PROF06		:IS IT PROFILE_6?
	JE	D.IMS6			:JUMP,IT IS PROFILE_6
	CLHI	R0,PROF17		:IS IT PROFILE_6?
	JE	D.IMS6			:JUMP,IT IS PROFILE_17
	NHI	R2,@SC.MSM		:SET THIS_HALF_SESSION_RSP_MODE TO IMM
	NHI	R2,@SC.OSM		:SET PARTNER_HALF_SESS_RSP_MODE TO IMM
	JFS	D.IMS7
D.IMS6
	OHI	R2,SC.MSM+SC.OSM
D.IMS7
:	SET UP REQUEST MODE
:	=====================
	LB	R1,SCBBLK+SCPLUP,R9,	:GET PRI LU PROTOCOL
	LB	R12,SCBBLK+SCSLUP,R9,	:GET SEC LU PROTOCOL
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION TYPE
	NHI	R0,SC.SES		:CHECK PRI OR SEC
	JE	D.IMS8			:JUMP,IF HALF_SESSION=SEC
:	SCB.HALF_SESSION=PRI
:	-------------------------
	NHI	R1,SC.PID		:CHECK PRI_RQ_MODE=IMMEDIATELY?
	JE	D.IMSA			:JUMP,IF PRI_RQ_MODE=IMMEDIATELY
D.IMS9
	OHI	R2,SC.MQM		:SET THIS_HALF_SESSION_RQ_MODE TO DEL
	J	D.IMSC			:JUMP TO STORE IN SCB
:	SCB.HALF_SESSION=SEC
:	-------------------------
D.IMS8
	NHI	R12,SC.PID		:CHECK SEC_RQ_MODE=IMMEDIATELY?
	JN	D.IMS9			:JUMP,IF SEC_RQ_MODE<>IMMEDIATELY
:	(HLF_SESSION=PRI & PRI_RQ_MODE=IMMEDIATELY) |
:	(HLF_SESSION=SEC & SEC_RQ_MODE=IMMEDIATELY)
:	---------------------------------------------
D.IMSA
	NHI	R2,@SC.MQM		:SET THIS_HALF_SESSION_RQ_MODE=IMM
D.IMSC
	LR	R0,R0
	JE	D.IMSE			:JUMP,IF HALF_SESSION=SEC
	NHI	R12,SC.SID		:CHECK SEC_RQ_MODE=IMMEDIATELY?
	JE	D.IMSB			:JUMP,IF SEC_RQ_MODE=IMMEDIATELY
D.IMSD
	OHI	R2,SC.PQM		:SET PARTNER_HALF_SESS_RQ_MODE TO DEL
	J	D.IMSF			:JUMP TO STORE IN SCB
D.IMSE
	NHI	R1,SC.PID		:CHECK PRI_RQ_MODE=IMMEDIATELY?
	JN	D.IMSD			:JUMP,IF PRI_RQ_MODE<>IMMEDIATELY
:	(HLF_SESSION=PRI & SEC_RQ_MODE=IMMEDIATELY) |
:	(HLF_SESSION=SEC & PRI_RQ_MODE=IMMEDIATELY)
:	---------------------------------------------
D.IMSB
	NHI	R2,@SC.PQM		:SET PARTNER_HALF_SESS_RQ_MODE TO IMM
D.IMSF
	STB	R2,SCBBLK+SCMSSP,R9,	:SET NEW DFC_MISC_SESSION_PAR
:	CREATE CORRELATION TABLES
:	=========================
	ST	R6,RGSAV6,,		:SAVE REG 6
:	NEWLIST CT_SEND_RQ_EXP ENTRY_NAME QUEUE,NEEDS SAVE R3,R4,R6,R7
:	--------------------------------------------------------
	JAL	R8,R.CSEN,,		:CALL NEWLIST ROUTINE
:	NEWLIST CT_RCV_RQ_EXP ENTRY_NAME QUEUE,NEEDS SAVE R3,R4,R6,R7
:	--------------------------------------------------------
	JAL	R8,R.CREN,,		:CALL NEWLIST ROUTINE
:	NEWLIST CT_SEND_RQ_NORM ENTRY_NAME QUEUE,NEEDS SAVE R3,R4,R6,R7
:	--------------------------------------------------------
	JAL	R8,R.CSNN,,		:CALL NEWLIST ROUTINE
:	NEWLIST CT_RCV_RQ_NORM ENTRY_NAME QUEUE,NEEDS SAVE R3,R4,R6,R7
:	--------------------------------------------------------
	JAL	R8,R.CRNN,,		:CALL NEWLIST ROUTINE
	JAL	R8,R.TDQN,,		:CALL NEWLIST ROUTINE (Q_TC_TO_DFC)
	L	R6,RGSAV6,,		:RESTORE REG 6
	JR	R6			:RETURN

:	D.IBRT	-(DFC_INIT_DFC_USAGE_BID_RTR) SETS THE SCB INDICATORS FOR
:	BID AND RTR USAGE
:	PAGE 5-33 ON FAPL
:	----------------------------------------------------------------
:	USAGE OF REGISTERS --
:	INPUT	-R5 (1ST-LEVEL CALL LINK) R9 (SCB_PTR) R6 (2ND-LEVEL CALL)
:	OUTPUT	-
:	LINK	-R7
:	WORKING	-R3,R4,R6,R7 (PROTECTED FOR OTHER CALLING FSM ROUTINES)
D.IBRT
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAMETER
	LR	R2,R0			:SAVE R0
	NHI	R0,SC.UBK		:MASK FOR USING_BRACKETS
	JER	R7			:RETURN,IF NO USING_BRACKETS
	LHL	R1,SCBBLK+SCDFNR,R9,	:GET DFC NORMAL REQUEST ALLOWED
	NHI	R2,SC.1SP		:IS IT FIRST_SPEAKER?
	JE	D.IBR0			:JUMP,IF NOT FIRST_SPEAKER
	OHI	R1,SC.BDR+SC.RTS
	JFS	D.IBR1
D.IBR0
	OHI	R1,SC.BDS+SC.RTR
D.IBR1
	STH	R1,SCBBLK+SCDFNR,R9,	:STORE NEW DFC ALLOWED
	JR	R7

:	D.IBSR	-(DFC_INIT_FSM_USAGE_BSM_SBI_RTR) SETS UP THE FSM
:	USAGE FOR THE BSM,SBI AND RTR FSM'S.
:	PAGE 5-35 ON FAPL
:	----------------------------------------------------------------
:	USAGE OF REGISTERS --
:	INPUT	-R5 (1ST-LEVEL CALL LINK) R9 (SCB_PTR) R6 (2ND-LEVEL CALL)
:	OUTPUT	-
:	LINK	-R7
:	WORKING	-R3,R4,R6,R7 (PROTECTED FOR OTHER CALLING FSM ROUTINES)
D.IBSR
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAMETER
	LR	R2,R0			:SAVE R0
	NHI	R2,SC.UBK		:MASK FOR USING_BRACKETS
	JER	R7			:RETURN,IF USING_BRACKETS<>YES
	LB	R2,SCBBLK+SCSRMD,R9,	:GET BIND BYTE-7
	NHI	R2,SC.SRM		:MASK FOR SEND_RCV_MODE
	JE	D.IBS3			:JUMP,IF SEND_RCV_MODE=FULL_DUPLEX
	LHL	R1,SCBBLK+SCDFER,R9,	:GET DFC EXPEDITED FLOW ALLOWED
	LR	R2,R1
	NHI	R2,SC.SBR		:MASK FOR DFC_SBI_RCV
	JEFS	D.IBS2			:JUMP,IF DFC_SBI_RCV<>ALLOWED
	LHI	R2,FSCSIR		:SET FSM_SBI_RCV
	STB	R2,SCBBLK+SCFSBR,R9,	:TO #FSM_SBI_RCV
D.IBS2
	LR	R2,R1
	NHI	R2,SC.SBS		:MASK FOR DFC_SBI_SEND
	JEFS	D.IBS4			:JUMP,IF DFC_SBI_SEND<>ALLOWED
	LHI	R2,FSCSIS		:SET FSM_SBI_SEND
	STB	R2,SCBBLK+SCFSBS,R9,	:TO #FSM_SBI_SEND
D.IBS4
	LHI	R2,FSCERV		:SET FSM_EBCD_RCV
	STB	R2,SCBBLK+SCFEBR,R9,	:TO #FSM_EBCD_RCV
	LHI	R2,FSCESD		:SET FSM_EBCD_SEND
	STB	R2,SCBBLK+SCFEBS,R9,	:TO #FSM_EBCD_SEND
	LHI	R2,FSCCBR		:SET FSM_CONTROL_BSM_RSP_RCV
	STB	R2,SCBBLK+SCFCBR,R9,	:TO #FSM_CONTROL_BSM_RSP_RCV
	LHI	R2,FSCCBS		:SET FSM_CONTROL_BSM_RSP_SEND
	STB	R2,SCBBLK+SCFCBS,R9,	:TO #FSM_CONTROL_BSM_RSP_SEND
	NHI	R0,SC.1SP		:IS IT FIRST_SPEAKER?
	JE	D.IBS0			:JUMP,IF NOT FIRST_SPEAKER
	LHI	R0,FSCBFP		:SET FSM_BSM_FSP
	LHI	R1,FSCRTF		:SET FSM_RTR_FSP
	JFS	D.IBS1
D.IBS0
	LHI	R0,FSCBBI		:SET FSM_BSM_BIDDER
	LHI	R1,FSCRTB		:SET FSM_RTR_BIDDER
D.IBS1
	STB	R0,SCBBLK+SCFBSM,R9,	:UPDATE #FSM_BSM
	STB	R1,SCBBLK+SCFRTR,R9,	:UPDATE #FSM_RTR
:	FULL-DUPLEX,CALL UPM_FDX_BRACKETS?????
:	--------------------------------------
D.IBS3
	JR	R7			:RETURN

:	D.IHDX	-(DFC_INIT_FSM_USAGE_HDX_RES) SETS UP THE FSM FOR 
:	NORMAL-FLOW SEND AND RECEIVE MODE (#FSM_HDX) AND RESOURCE (#FSM_RES)
:	PAGE 5-36 ON FAPL
:	----------------------------------------------------------------
:	USAGE OF REGISTERS --
:	INPUT	-R5 (1ST-LEVEL CALL LINK) R9 (SCB_PTR) R6 (2ND-LEVEL CALL)
:	OUTPUT	-
:	LINK	-R7
:	WORKING	-R3,R4,R6,R7 (PROTECTED FOR OTHER CALLING FSM ROUTINES)
D.IHDX
	LB	R2,SCBBLK+SCACFG,R9,	:GET HALF_SESSION TYPE
	NHI	R2,SC.SES		:CHECK PRI OR SEC
	JE	D.IHD0			:JUMP,IF HALF_SESSION=SEC
	LB	R2,SCBBLK+SCSRMD,R9,	:GET BIND BYTE-7
	NHI	R2,SC.RVR		:MASK FOR SCB.RECOVERY_RESP
	JNFS	D.IHD1			:JUMP,IF SCB.RECOVERY_RESP =SYMMETRIC
D.IHD0
	LHI	R2,FSCRES		:GET FSM_RES
	STB	R2,SCBBLK+SCFRES,R9,	:SET #FSM_RES
D.IHD1
	LB	R2,SCBBLK+SCSRMD,R9,	:GET BIND BYTE-7
	NHI	R2,SC.SRM		:MASK FOR SEND_RCV_MODE
	SRHLS	R2,AD.SRM		:GET PROPER SEND_RCV_MODE (HW INDEX)
	LHL	R1,D.IHD2,R2,		:GET ENTRY FOR DIFFERENT SEND_RCV_MODE
	J	A.COD2,R1,
D.IHD2	HS	
	HC	D.IHD6-A.COD2		:FULL-DUPLEX
	HC	D.IHD4-A.COD2		:HDX CONTENTION
	HC	D.IHD5-A.COD2		:HDX FLIP_FLOP
	HC	D.IHD6-A.COD2		:RESERVED

:	SEND_RCV_MODE = HDX_CONTENTION
:	------------------------------
D.IHD4
	LHI	R0,FSCHRV		:SET FSM_CONTROL_HDX_RSP_RCV
	STB	R0,SCBBLK+SCHDRR,R9,	:TO #FSM_CONTROL_HDX_RSP_RCV
	LHI	R0,FSCHSN		:SET FSM_CONTROL_HDX_RSP_SEND
	STB	R0,SCBBLK+SCHDRS,R9,	:TO #FSM_CONTROL_HDX_RSP_SEND
	LB	R2,SCBBLK+SCACFG,R9,	:GET HALF_SESSION TYPE
	NHI	R2,SC.SES		:CHECK PRI OR SEC
	JE	D.IHD3			:JUMP,IF HALF_SESSION=SEC
	LB	R2,SCBBLK+SCSRMD,R9,	:GET BIND BYTE-7
	NHI	R2,SC.CWN		:MASK FOR SCB.CONT_WIN
	JN	D.IHD7			:JUMP,IF CONT_WIN=PRI & SESSION=PRI
	J	D.IHD8			:ELSE ,JUMP TO D.IHD8
D.IHD3
	LB	R2,SCBBLK+SCSRMD,R9,	:GET BIND BYTE-7
	NHI	R2,SC.CWN		:MASK FOR SCB.CONT_WIN
	JE	D.IHD7			:JUMP,IF CONT_WIN=SEC & SESSION=SEC
D.IHD8
	LHI	R2,FSMNOP		:SET 'NO_OP'
	STB	R2,SCBBLK+SCFRES,R9,	:TO #FSM_RES
	LHI	R2,FSCHCL		:SET FSM_HDX_CONT_LOSER
	STB	R2,SCBBLK+SCFHDX,R9,	:TO #FSM_HDX
	JR	R7			:RETURN
:	IF (HALF_SESSION=PRI&CONT_WIN=PRI)|(HALF_SESSION=SEC&CONT_WIN=SEC)
:	----------------------------------------------------------------
D.IHD7
	LHI	R2,FSCHCW		:SET FSM_HDX_CONT_WINNER
	STB	R2,SCBBLK+SCFHDX,R9,	:TO #FSM_HDX
	JR	R7			:RETURN

:	SEND_RCV_MODE = HDX_FLIP_FLOP
:	-----------------------------
D.IHD5
	LHI	R2,FSCHFF		:SET FSM_HDX_FF
	STB	R2,SCBBLK+SCFHDX,R9,	:TO #FSM_HDX
	LHI	R2,FSCHRV		:SET FSM_CONTROL_HDX_RSP_RCV
	LHI	R1,FSCHSN		:SET FSM_CONTROL_HDX_RSP_SEND
	LB	R0,SCBBLK+SCSRMD,R9,	:GET BIND BYTE-7
	NHI	R0,SC.RVR		:MASK FOR SCB.RECOVERY_RESP
	JE	D.IHD9			:JUMP,IF SCB.RECOVERY_RESP<>SYMMETRIC
	LHI	R2,FSCHRI		:SET FSM_CONTROL_HDX_RSP_RCV_ERP_IM
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAM
	NHI	R0,SC.MQM		:FOR THIS_HALF_SESSION_RQ_MODE
	JEFS	D.IHDA			:JUMP,IF IMMEDIATELY
	LHI	R2,FSCHRD		:SET FSM_CONTROL_HDX_RSP_RCV_ERP_DL
D.IHDA
	LHI	R1,FSCHSI		:SET FSM_CONTROL_HDX_RSP_SEND_ERP_IM
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARA
	NHI	R0,SC.PQM		:FOR PARTNER_HALF_SESSION_RQ_MODE
	JEFS	D.IHD9			:JUMP,IF IMMEDIATELY
	LHI	R1,FSCHSD		:SET FSM_CONTROL_HDX_RSP_SEND_ERP_DL
D.IHD9
	STB	R2,SCBBLK+SCHDRR,R9,	:STORE #FSM_CONTROL_HDX_RSP_RCV
	STB	R1,SCBBLK+SCHDRS,R9,	:STORE #FSM_CONTROL_HDX_RSP_SEND
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARA
	LR	R1,R0
	NHI	R1,SC.UBK		:FOR SCB.USING_BRACKETS
	JER	R7			:RETURN,IF USING_BRACKETS<>YES
	NHI	R0,SC.1SP		:FOR SCB.FIRST_SPEAKER
	JNR	R7			:RETURN,IF FIRST_SPEAKER<>NO
	LHI	R2,FSMNOP
	STB	R2,SCBBLK+SCFRES,R9,	:SET #FSM_RES TO NO_OP
	JR	R7			:RETURN

:	SEND_RCV_MODE =( FULL_DUPLEX | RESERVED )
:	-----------------------------------------
D.IHD6
	JR	R7			:RETURN

:	D.RDFC	-(SESSACT.DFC_RESET) RESETS ALL DFC FSM'S.  THIS ROUTINE
:	IS CALLED AS A RESULT OF RESETTING A SUBTREE THAT INCLUDES
:	DFC. TO RESET CORRELATION TABLES.
:	PAGE 5-38 ON FAPL
:	-----------------------------------------------------------------
:	USAGE OF REGISTERS -
:	INPUT	-R9 (SCB_PTR) R10 (MU_PTR) R14 (LINK FOR DISPATCHER)
:		 R13 (NCB)
:	OUTPUT	-
:	LINK	-R5
:	WORKING	-R15 (TCCB) R3,R4,R6,R7 (PROTECTED FOR CALLING ROUTINES)
D.RDFC
	ST	R5,RGSAV5,,		:SAVE REG 5
	ST	R7,RGSAV7,,		:SAVE REG 7
:	CALL #FSM_CHAIN_RCV
:	------------
	LB	R1,SCBBLK+SCFCHR,R9,	:SET UP #FSM_CHAIN_RCV INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_CHAIN_SEND
:	------------
	LB	R1,SCBBLK+SCFCHS,R9,	:SET UP #FSM_CHAIN_SEND INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_CONTROL_BSM_RSP_RCV
:	------------
	LB	R1,SCBBLK+SCFCBR,R9,	:SET UP #FSM_CONTROL_BSM_RSP_RCV INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_CONTROL_BSM_RSP_SEND
:	------------
	LB	R1,SCBBLK+SCFCBS,R9,	:SET UP #FSM_CONTROL_BSM_RSP_SEND INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_CONTROL_HDX_RSP_RCV
:	------------
	LB	R1,SCBBLK+SCHDRR,R9,	:SET UP #FSM_CONTROL_HDX_RSP_RCV INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
:	CALL #FSM_SHUTD
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_CONTROL_HDX_RSP_SEND
:	------------
	LB	R1,SCBBLK+SCHDRS,R9,	:SET UP #FSM_CONTROL_HDX_RSP_SEND INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_EBCD_RCV
:	------------
	LB	R1,SCBBLK+SCFEBR,R9,	:SET UP #FSM_EBCD_RCV INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_EBCD_SEND
:	------------
	LB	R1,SCBBLK+SCFEBS,R9,	:SET UP #FSM_EBCD_SEND INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_IMM_RQ_MODE_RCV
:	------------
	LB	R1,SCBBLK+SCFIRR,R9,	:SET UP #FSM_IMM_RQ_MODE_RCV INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_IMM_RQ_MODE_SEND
:	------------
	LB	R1,SCBBLK+SCFIRS,R9,	:SET UP #FSM_IMM_RQ_MODE_SEND INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_QEC_RCV
:	------------
	LB	R1,SCBBLK+SCFQER,R9,	:SET UP #FSM_QEC_RCV INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_QEC_SEND
:	------------
	LB	R1,SCBBLK+SCFQES,R9,	:SET UP #FSM_QEC_SEND INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_QRI_CHECK_SEND
:	------------
	LB	R1,SCBBLK+SCFQKS,R9,	:SET UP #FSM_QRI_CHECK_SEND INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_QRI_CHAIN_RCV
:	------------
	LB	R1,SCBBLK+SCFQCR,R9,	:SET UP #FSM_QRI_CHAIN_RCV INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_QRI_CHAIN_SEND
:	------------
	LB	R1,SCBBLK+SCFQCS,R9,	:SET UP #FSM_QRI_CHAIN_SEND INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_RES
:	------------
	LB	R1,SCBBLK+SCFRES,R9,	:SET UP #FSM_RES INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_RTR
:	------------
	LB	R1,SCBBLK+SCFRTR,R9,	:SET UP #FSM_RTR INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_SBI_RCV
:	------------
	LB	R1,SCBBLK+SCFSBR,R9,	:SET UP #FSM_SBI_RCV INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_SBI_SEND
:	------------
	LB	R1,SCBBLK+SCFSBS,R9,	:SET UP #FSM_SBI_SEND INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_SHUTD
:	------------
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LHI	R0,FS.RET		:SET SIGNAL 'RESET'
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
:	CALL #FSM_BSM
:	----------------
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAM
	NHI	R0,SC.UBK		:MASK BITS FOR USING_BRACKETS
	JE	D.RDF0			:JUMP,IF USING_BRACKETS<>YES
	LB	R1,SCBBLK+SCFBSM,R9,	:SET UP #FSM_BSM INDEX
	LHI	R0,FS.REB		:SET SIGNAL 'RESET_BETB'
	LB	R3,SCBBLK+SCCLUP,R9,	:GET BIND BYTE 6
	NHI	R3,SC.BRS		:CHECK BRACKETS RESET STATE
	JNFS	D.RDF1			:JUMP,IF BRACKETS_RESET_STATE=BETB
	LHI	R0,FS.REI		:INPUT 'RESET_INB'
D.RDF1
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
D.RDF0
:	CALL DFC_RESET_HDX
:	------------------
	JAL	R6,D.RHDX,,		:DFC_RESET_HDX
:	PURGE CT_RCV_RQ_EXP,CT_RCV_RQ_NORM,CT_SEND_RQ_EXP,CT_SEND_RQ_NORM
:	-----------------------------------------------------------------
	JAL	R8,R.CREP,,		:CALL CT_RCV_RQ_EXP
	JAL	R8,R.CRNP,,		:CALL CT_RCV_RQ_NORM
	JAL	R8,R.CSEP,,		:CALL CT_SEND_RQ_EXP
	JAL	R8,R.CSNP,,		:CALL CT_SEND_RQ_NORM
:	INIT SEND SEQUENCE COUNTER
:	--------------------------
	LIS	R0,0
	STH	R0,SCBBLK+SCSQSC,R9,	:CLEAR SCB.SQN_SEND_CNT
	L	R5,RGSAV5,,		:RESTORE REG 5
	L	R7,RGSAV7,,		:RESTORE REG 7
	JR	R5			:RETURN

:	D.RHDX	-(DFC_RESET_HDX) RESETS THE HDX FSM'S
:	PAGE 5-39 ON FAPL
:	--------------------------------------------------
:	THE USAGE OF REGISTERS --
:	LINK	-R6
D.RHDX
	ST	R6,RGSAV6,,		:SAVE REG 6
	LB	R0,SCBBLK+SCSRMD,R9,	:GTE BYTE 7 OF BIND
	NHI	R0,SC.SRM		:MASK FOR SEND_RCV_MODE
	JER	R6			:RETURN,IF IT IS FULL_DUPLEX
	CLHI	R0,HDXCON		:IS IT HDX_CONTENTION?
	JE	D.RHD0			:JUMP,IF IT IS HDX_CONTENTION
	CLHI	R0,HDXFF		:IS IT HDX_FLIP_FLOP?
	JEFS	D.RHD1			:JUMP,IF IT IS HDX_FF
	JR	R6			:RETURN,FOR OTHERS
:	SEND_RCV_MODE=HDX_FLIP_FLOP
:	----------------------------
D.RHD1
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAM
	NHI	R0,SC.UBK		:MASK BITS FOR USING_BRACKETS
	JE	D.RHD5			:JUMP,IF USING_BRACKETS<>YES
	LB	R1,SCBBLK+SCFBSM,R9,	:GET #FSM_BSM INDEX
	LB	R0,SCBBLK+SCSTAT,R1,R9	:GET CURRENT STATE
	CLHI	R0,FS.ST1		:IS IT 'BETB' STATE?
	JE	D.RHD0			:JUMP,IF IT IS 'BETB'
:	SCB.USING_BRACKETS<>YES
:	-------------------------
:	OR SCB.USING_BRACKETS=YES,BUT,#FSM_BSM<>BETB
D.RHD5
	LHI	R0,FS.RER		:SET SIGNAL TO 'RESET_RCV'
	LB	R1,SCBBLK+SCACFG,R9,	:SCB.HALF_SESSION
	NHI	R1,SC.SES		:MASK FOR HALF_SESSION
	JE	D.RHD6			:JUMP,IF IT IS SECONDARY
	LB	R1,SCBBLK+SCSRMD,R9,	:GTE BYTE 7 OF BIND
	NHI	R1,SC.HFS		:MASK FOR HDX_FF_RESET_STATE
	JE	D.RHD7			:JUMP, HDX_FF_RESET_STATE=SEND_FOR_SEC
	J	D.RHD8			:JUMP TO CALL #FSM_HDX
D.RHD6
	LB	R1,SCBBLK+SCSRMD,R9,	:GTE BYTE 7 OF BIND
	NHI	R1,SC.HFS		:MASK FOR HDX_FF_RESET_STATE
	JN	D.RHD7			:JUMP, HDX_FF_RESET_STATE=SEND_FOR_PRI
:	HALF_SESSION=SEC & HDX_FF_RESET_STATE=SEND_FOR_SEC
:	HALF_SESSION=PRI & HDX_FF_RESET_STATE=SEND_FOR_PRI
:	--------------------------------------------------
D.RHD8
	LHI	R0,FS.RES		:INPUT SIGNAL 'RESET_SEND'
	J	D.RHD7			:JUMP TO CALL #FSM_HDX
:	SEND_RCV_MODE=HDX_CONTENTION
:	----------------------------
D.RHD0
	LHI	R0,FS.REC		:INPUT SIGNAL 'RESET_CONT'
:	CALL #FSM_HDX
:	----------------
D.RHD7
	LB	R1,SCBBLK+SCFHDX,R9,	:SET UP #FSM_HDX INDEX
	LIS	R6,FS.CAL		:SET UP FSM CALL
	JAL	R4,R.FSM1,,		:CALL FSM ROUTINE
	L	R6,RGSAV6,,		:RESTORE REG 6
	JR	R6			:RETURN

	FO	CMDLST
	FO	CBKDEF

	EM

  
	SUBTTL	SNA PACKAGE(UTILITY ROUTINES) - DATA FLOW CONTROL LAYER
:	MODULE NAME IN COMMAND FILE -- SDCR00.F00

:	*******************************
:	REVISION HISTORY --
:	DEC. 08,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	*******************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT MISCELLANEOUS ROUTINES
:	WHICH ARE CALLED BY THE DATA FLOW CONTROL LAYER PROCESSES.
:	PLEASE REFER TO THE PSEUDO-CODES IN CHAPTER 5 ON FAPL MANUE.
:	----------------------------------------------------------------

	RA	0
	MO	.,SNAPKG

:	COMMAND LIST STRUCTURE FOR CT_RCV_RQ_EXP IS
:	CLCMD CONTAINS CT_RCV_RQ_EXP_DFC_RQ_CODE (1 BYTE)
:	CLLNG CONTAINS CT_RCV_RQ_EXP_ID (2 BYTES)
:	CLARG CONTAINS CT_RCV_RQ_EXP_EXR_SENSE (2 BYTES)

:	COMMAND LIST STRUCTURE FOR CT_SEND_RQ_EXP IS
:	CLCMD CONTAINS CT_SEND_RQ_EXP_DFC_RQ_CODE (1 BYTE)
:	CLLNG CONTAINS CT_SEND_RQ_EXP_ID (2 BYTES)

	LO	CBKDEF
	LO	BBUFER
	LO	CMDLST
	LO	MAIN

	SEG	A.CODE

:	D.RFMT	-(RCV_FORMAT) TO ALLOW REQUESTS AND RESPONSES TO BE
:	RECEIVED FROM HALF-SESSIONS NOT SUPPORTING NEWLY REQUIRED SEND
:	FORMAT CHECKS. THIS PROCEDURE MAKES THE FORMAT CORRECT WITH
:	RESPECT TO THE SEND CHECK
:	PAGE 5-51 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MU PTR)
:	OUTPUT	:
:	LINK	:R8
:	WORKING	:R5
D.RFMT
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R6,D.RFM0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R6,

D.RFM0	HS
	HC	D.RFM1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.RFM2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.RFM2-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.RFM2-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	WHEN (EFI=NORMAL) & (RRI=RQ)
:	----------------------------
D.RFM1
	LB	R5,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R5,MU.EBI		:MASK OUT OTHER BITS FOR EBI
	JE	D.RFM2			:JUMP,IF IT IS 0 (NOT EB)
:	IF EBI=EB
:	---------
	LB	R5,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R5,@MU.CDI		:MASK OFF CDI BIT
	STB	R5,BBUFER+MURHF3,R10,	:STORE BYTE BACK TO MUCB
D.RFM2
	JR	R8

:	D.RTIN	-(RCV_CT_INITIALIZE) TO INITIALIZE THE CORRELATION TABLE
:	PAGE 5-52 ON FAPL
:	-----------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:
:	OUTPUT	:
:	LINK	:R8
:	WORKING	:
D.RTIN
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R6,D.RTI0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R6,

D.RTI0	HS
	HC	D.RTI1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.RTI2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.RTI3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.RTI4-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.RTI1
	LHL	R2,SCBBLK+SCTRNG,R9,	:GET CT_RCV_RQ_NORM GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTPTG,R9,	:SET CT_PTR GET PTR
	LHL	R2,SCBBLK+SCTRNR,R9,	:GET CT_RCV_RQ_NORM RELEASE PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTPTR,R9,	:SET CT_PTR RELEASE PTR
	JAL	R5,D.CEAU,,		:JUMP CALL CT_ENTRY_ADD_OR_UPDATE
	LHL	R2,SCBBLK+SCTPTG,R9,	:GET WORKING GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTRNG,R9,	:SET CT_RCV_RQ_NORM TO NEW
	LHL	R2,SCBBLK+SCTPTR,R9,	:GET CT_PTR RELEASE PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTRNR,R9,	:SET CT_RCV_RQ_NORM RELEASE PTR
	JR	R8			:RETURN

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.RTI2
	LHL	R2,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTPTG,R9,	:SET CT_PTR GET PTR
	LHL	R2,SCBBLK+SCTSNR,R9,	:GET CT_SEND_RQ_NORM RELEASE PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTPTR,R9,	:SET CT_PTR RELEASE PTR
	LHL	R3,BBUFER+MUSNF,R10,	:GET SNF FROM MUCB
	STH	R3,SCBBLK+SCKEYY,R9,	:SCB.KEY=SNF
	LHI	R1,NOFIND		:DEFAULT 'NOT FIND'
	JAL	R5,D.CKSR,,		:CALL CT_KEY_SEARCH
	J	D.RTI9			:JUMP,IF NOT FOUND
	LHI	R1,FIND			:SETUP VALUE 'FIND'
D.RTI9
	STB	R1,SCBBLK+SCCTET,R9,	:SET CT_ENTRY IN SCB
	JR	R8			:RETURN

:	EFI=EXPEDITED & RRI=RQ
:	-------------------------------------
D.RTI3
	JAL	R4,GETCL,,
	JAL	R4,CLEMP5
	LHL	R7,SCBBLK+SCTRER,R9,	:GET RELEASE PTR FOR CT_RCV_RQ_EXP
	LHL	R0,BBUFER+MUSNF,R10,	:GET SNF FROM MUCB
	STH	R0,CMDBLK+CLLNG,R7,	:STORE INTO CT_RCV_RQ_EXP_ID
	LIS	R0,0
	STH	R0,CMDBLK+CLARG,R7,	:CLEAR CT_RCV_RQ_EXP_EXR_SENSE
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R3,		:GET RQ_CODE FROM RU
	STH	R0,CMDBLK,R7,		:SET CT_RCV_RQ_EXP_DFC_RQ_CODE
	STH	R6,CMDBLK+CLPTR,R7,	:UPDATE NEXT CMDLST PTR
	STH	R6,SCBBLK+SCTRER,R9,	:LINK NEW ENTRY
	STH	R7,SCBBLK+SCRREE,R9,	:SET CT_RCV_RQ_EXP_ENTRY_PTR
	JR	R8			:RETURN

:	EFI=EXPEDITED & RRI=RSP
:	---------------
D.RTI4
	LHI	R1,NOFIND		:DEFAULT 'NOT FIND'
	STB	R1,SCBBLK+SCCTET,R9,	:SET CT_ENTRY IN SCB
	LHL	R0,BBUFER+MUSNF,R10,	:GET SNF FROM MUCB
	LHL	R3,SCBBLK+SCTSEG,R9,	:GET CT_SEND_RQ_EXP GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
D.RTI6
:	CLH	R3,SCBBLK+SCTSER,R9,	:GET AND RL THE SAME? (01/03/85 MIA)
	LHL	R6,SCBBLK+SCTSER,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R3,R6			:COMP GET AND REL PTR (01/03/85 MIA)
	JE	D.RTI7			:JUMP,IF CT_PTR IS EMPTY
:	CLH	R0,CMDBLK+CLLNG,R3,	:CT_SEND_RQ_EXP_ID=SNF? (01/03/85 MIA)
	LHL	R6,CMDBLK+CLLNG,R3,	:GET CT_SEND_RQ__EXP_ID (01/03/85 MIA)
	CR	R0,R6			:COMP IT WITH SNF (01/03/85 MIA)
	JE	D.RTI8			:YES,JUMP
:	UPDATE GET AND RELEASE PTR
:	--------------------------
	LH	R3,CMDBLK+CLPTR,R3,	:GET NEXT CT PTR
	J	D.RTI6
D.RTI8
	STH	R3,SCBBLK+SCSREE,R9,	:SET CT_SEND_RQ_EXP_ENTRY_PTR
	LHI	R1,FIND			:SETUP VALUE 'FIND'
	STB	R1,SCBBLK+SCCTET,R9,	:SET CT_ENTRY IN SCB
	JR	R8			:RETURN

:SCAN CT_SEND_RQ_EXP FAIL,WHAT VALUE'LL BE IN CT_SEND_RQ_EXP_ENTRY_PTR????
:------------------------------------------------------------------------
D.RTI7
	JR	R8			:RETURN

:	D.CKSR	-(CT_KEY_SEARCH) TO SCAN A CORRELATION TABLE LOOKING 
:	FOR A SPECIFIC ENTRY
:	PAGE 5-60 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R1 (DEFAULT RETURN VALUE)
:	OUTPUT	:NORMAL RETURN IF NOT OK,SKIP RETURN IF OK
:	LINK	:R5,R8 (PREVIOUS CALL)
:	WORKING	:
D.CKSR
	LHL	R4,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR
D.CKS0
:	CLH	R4,SCBBLK+SCTPTR,R9,	:GET AND REL THE SAME? (01/03/85 MIA)
	LHL	R3,SCBBLK+SCTPTR,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R4,R3			:COMP GET AND REL PTR (01/03/85 MIA)
	JE	D.CKS5			:JUMP,IF CT_PTR IS EMPTY
	BBLOAD	R3,CMDBLK+CLARG,R4,	:GET CT PTR
	LHL	R6,BBUFER+CLARG0,R3,	:GET CT_BEG_SNF
	LHL	R0,BBUFER+CLARG3,R3,	:GET CT_END_SNF
	LHL	R3,SCBBLK+SCKEYY,R9,	:GET SCB.KEY (12/6/84 MIA)
	CR	R0,R6			:COMPARE CT_END_SNF AND CT_BEG_SNF
	JL	D.CKS1			:JUMP,IF CT_END_SNF<CT_BEG_SNF
:	CLH	R6,SCBBLK+SCKEYY,R9,	:GET SCB.KEY (12/6/84 MIA)
	CR	R6,R3			:CMP SCB.KEY TO BEG_SNF (12/6/84 MIA)
	JG	D.CKS3			:JUMP SCB.KEY<CT_BEG_SNF
:	CLH	R0,SCBBLK+SCKEYY,R9,	:COMP SCB.KEY TO END_SNF (12/6/84 MIA)
	CR	R0,R3			:COMP SCB.KEY TO END_SNF (12/6/84 MIA)
	JGE	D.CKS4			:JUMP,IF FIND
:	UPDATE GET AND RELEASE PTR
:	--------------------------
D.CKS3
:	LH	R4,CMDBLK+CLPTR,R4,	:GET NEXT CT PTR (01/03/85 MIA)
	LHL	R4,CMDBLK+CLPTR,R4,	:GET NEXT CT PTR (01/03/85 MIA)
	J	D.CKS0
D.CKS1
:	CLH	R6,SCBBLK+SCKEYY,R9,	:GET SCB.KEY (12/6/84 MIA)
	CR	R6,R3			:COMP SCB.KEY TO BEG_SNF (12/6/84 MIA)
:	JL	D.CKS4			:JMP SCB.KEY>=CT_BEG_SNF (12/6/84 MIA)
	JLE	D.CKS4			:JMP SCB.KEY>=CT_BEG_SNF (12/6/84 MIA)
:	CLH	R0,SCBBLK+SCKEYY,R9,	:COMP SCB.KEY TO END_SNF (12/6/84 MIA)
	CR	R0,R3			:COMP SCB.KEY TO END_SNF (12/6/84 MIA)
	JL	D.CKS3			:JUMP,IF NOT FIND
D.CKS4
	AIS	R5,4			:SKIP RETURN FOR 'FIND'=
	STH	R4,SCBBLK+SCTNPT,R9,	:SET CT_NORM_ENTRY_PTR
	JR	R5
D.CKS5
	LIS	R4,0
	STH	R4,SCBBLK+SCTNPT,R9,	:CLEAR CT_NORM_ENTRY_PTR
	JR	R5			:RETURN

:	D.CEAU	-(CT_ENTRY_ADD_OR_UPDATE) TO ADD A NEW ENTRY OR TO 
:	UPDATE AN ENTRY IN A NORMAL-FLOW CORRELATION TABLE.
:	PAGE 5-59 ON FAPL
:	-------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:CT_PTR IS SIGNIFICANT
:	OUTPUT	:
:	LINK	:R5,R8 (PREVIOUS CALL)
:	WORKING	:
D.CEAU
:	NEED TO SAVE R5 BEFORE CALL RQN 
	ST	R5,RGSAV5,,
	JAL	R7,R.RQN,,		:CALL RQN
	J	D.CEA9			:JUMP,IF NOT OK
	J	D.CEA2			:JUMP TO GET LINK REGISTER AND RETURN
:	CHECK CT_PTR EMPTY OR NOT,AND CHECK ENTRY_TYPE
:	----------------------------------------------
D.CEA9
	LHL	R7,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR
:	CLH	R7,SCBBLK+SCTPTR,R9,	:COMPARE TO RELEASE PTR (01/03/85 MIA)
	LHL	R3,SCBBLK+SCTPTR,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R7,R3			:COMP GET AND REL PTR (01/03/85 MIA)
	JE	D.CEA1			:JUMP,IF CT_PTR EMPTY
D.CEAB
:	LH	R6,CMDBLK+CLPTR,R7,	:NXT PTR (FIND LST_ENT) (01/03/85 MIA)
:	CLH	R6,SCBBLK+SCTPTR,R9,	:IS THE LAST ONE ENTRY? (01/03/85 MIA)
	LHL	R6,CMDBLK+CLPTR,R7,	:GET NEXT PTR (01/03/85 MIA)
	CR	R6,R3			:LAST ENTRY? (01/03/85 MIA)
	JE	D.CEAA			:YES,JUMP TO GET LAST_ENTRY
	LR	R7,R6			:CONTINUE
	J	D.CEAB
D.CEAA
	BBLOAD	R3,CMDBLK+CLARG,R7,	:GET CT PTR
	LB	R0,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY 
	NHI	R0,CT.ENT		:MASK OFF OTHER BITS
	JN	D.CEA1			:JUMP IF NOT PARTIAL_CHAIN
:	UPDATE CT_NORM_ENTRY_PTR
:	------------------------
	STH	R7,SCBBLK+SCTNPT,R9,	:SET CT_NORM_ENTRY_PTR TO CT_PTR
	LHL	R0,BBUFER+MUSNF,R10,	:GET SNF FROM MUCB
	STH	R0,BBUFER+CLARG3,R3,	:SET CT_END_SNF TO SNF
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.ECI		:MASK OUT OTHER BITS FOR ECI
	JE	D.CEA2			:JUMP,ECI<>EC (RETURN)
:	UPDATE ENTRY IN THE CT_PTR
:	--------------------------
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	STB	R0,BBUFER+CLARG5+1,R3,	:STORE DR1I,DR2I AND ERI IN CT
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.CDI		:MASK OTHER BITS FOR CDI
	LB	R1,BBUFER+CLARG5,R3,	:GET CDI BYTE
	OR	R1,R0			:UPDATE CDI IN CT_PTR
	STB	R1,BBUFER+CLARG5,R3,	:UPDATE CDI IN CT_PTR
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R0,MU.DFC		:IS RU_CTG=DFC?
	JN	D.CEA3			:JUMP,IF RU_CTG<>DFC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CANCEL		:IS RQ_CODE=CANCEL?
	JN	D.CEA3			:JUMP IF NOT
	STB	R0,BBUFER+CLARG4,R3,	:UPDATE CT_DFC_RQ_CODE
	LB	R5,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R5,MU.EBI		:MASK OUT OTHER BITS FOR EBI
	LB	R0,BBUFER+CLARG5,R3,	:GET EBI BYTE FROM CT_PTR
	OR	R0,R5
	STB	R0,BBUFER+CLARG5,R3,	:STORE EBI INTO CT
	LB	R0,BBUFER+CLARG6,R3,	:GET CT_ENTRY_TYPE BYTE
	NHI	R0,@ONLCAN		:CLEAR CT_ENTRY_TYPE
	OHI	R0,WCWCAN		:SET TYPE TO WHOLE_CHAIN_WITH_CANCEL
	JFS	D.CEA4
D.CEA3
	LB	R0,BBUFER+CLARG6,R3,	:GET CT_ENTRY_TYPE BYTE
	NHI	R0,@ONLCAN		:CLEAR CT_ENTRY_TYPE
	OHI	R0,WCNCAN		:SET TYPE TO WHOLE_CHAIN_NO_CANCEL
D.CEA4
	STB	R0,BBUFER+CLARG6,R3,	:UPDATE CT_ENTRY_TYPE
	J	D.CEA2			:RETURN
:	ADD NEW CT_NORM_ENTRY
:	---------------------
D.CEA1
	JAL	R4,GBB,,		:CREATE NEW CT TABLE
	J	D.CEA0			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	JAL	R4,GETCL,,		:GET FREE COMMAND LIST
	JAL	R4,CLEMP5		:CRASH,IF NO MORE FREE LIST
	LHL	R7,SCBBLK+SCTPTR,R9,	:GET CT_PTR RELEASE PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R6,CMDBLK+CLPTR,R7,	:UPDATE NEXT CMD LIST PTR
	STH	R6,SCBBLK+SCTPTR,R9,	:UPDATE CT_PTR RELEASE PTR
	BBSTOR	R3,CMDBLK+CLARG,R7,	:SET CT PTR
	LHL	R0,BBUFER+MUSNF,R10,	:GET SNF FROM MUCB
	STH	R0,BBUFER+CLARG3,R3,	:SET CT_END_SNF TO SNF
	STH	R0,BBUFER+CLARG0,R3,	:SET CT_BEG_SNF TO SNF
	LIS	R0,0
	STB	R0,BBUFER+CLARG6,R3,	:CLEAR CT_RSP_TO_NOT_CANCEL
	ST	R0,BBUFER+CLARG1,R3,	:CLEAR CT_EXR_SENSE_FOR_NOT_CANCEL
	ST	R0,BBUFER+CLARG2,R3,	:CLEAR CT_EXR_SENSE_FOR_CANCEL
	L	R0,SLOWC,,		:GET SLOW CLOCK(6/21/84/CHS)
	AHI	R0,$A120		:120 SECS(6/21/84/CHS)
	ST	R0,BBUFER+CLARG7,R3,	:SET UP DELETE TIMER
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	STB	R0,BBUFER+CLARG5+1,R3,	:STORE DR1I,DR2I,QRI,ERI IN CT
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,@MU.CDI		:MASK OFF CDI BIT
	STB	R0,BBUFER+CLARG5,R3,	:STORE BBI,EBI AND CDI
	BBLOAD	R2,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R4,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R4,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	LIS	R0,0
	CLHI	R4,MU.DFC		:IS RU_CTGY=DFC?
	JNFS	D.CEA5			:JUMP,IF RU_CTGY<>DFC
	LB	R0,BBUFER,R2,		:GET RQ_CODE
D.CEA5
	STB	R0,BBUFER+CLARG4,R3,	:UPDATE CT_DFC_RQ_CODE
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.ECI		:MASK OUT OTHER BITS FOR ECI
	JE	D.CEA6			:JUMP,ECI<>EC 
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.CDI		:MASK OTHER BITS FOR CDI
	LB	R1,BBUFER+CLARG5,R3,	:GET CDI BYTE
	OR	R1,R0			:UPDATE CDI IN CT_PTR
	STB	R1,BBUFER+CLARG5,R3,	:UPDATE CDI IN CT_PTR
	CLHI	R4,MU.DFC		:IS RU_CTG=DFC?
	JN	D.CEA7			:JUMP,IF RU_CTG<>DFC
	LB	R0,BBUFER,R2,		:GET RQ_CODE
	CLHI	R0,CANCEL		:IS RQ_CODE=CANCEL?
	JN	D.CEA7			:JUMP IF NOT
	LB	R0,BBUFER+CLARG6,R3,	:GET CT_ENTRY_TYPE BYTE
	OHI	R0,ONLCAN		:SET TYPE TO CANCEL ONLY
	J	D.CEA8
D.CEA6
	LB	R0,BBUFER+CLARG6,R3,	:GET CT_ENTRY_TYPE BYTE
	OHI	R0,PARCHA		:SET TYPE TO PARTIAL_CHAIN
	JFS	D.CEA8			:SET TYPE TO PARTAIL_CHAIN
D.CEA7
	LB	R0,BBUFER+CLARG6,R3,	:GET CT_ENTRY_TYPE BYTE
	OHI	R0,WCNCAN		:SET TYPE TO WHOLE_CHAIN_NO_CANCEL
D.CEA8
	OR	R0,R4			:OR WITH RU_CTGY
	STB	R0,BBUFER+CLARG6,R3,	:UPDATE CT_ENTRY_TYPE
	STH	R7,SCBBLK+SCTNPT,R9,	:SET CT_NORM_ENTRY_PTR TO CT_PTR
:	DO WE NEED TO UPDATE CT_NORM_ENTRY_PTR????? WE UPDATE CT_PTR ALREADY
:	--------------------------------------------------------------------

D.CEA2
:	NEED TO GET LINK REGISTER R5 BACK 
	L	R5,RGSAV5,,
	JR	R5			:RETURN

D.CEA0
	J	NOENT5,,

:	D.SRSC	-(SEND_RSP_SENSE_CKS) TO MAKE SURE RESPONSES TO EXR'S
:	ARE NEGATIVE RESPONSES WITH THE CORRECT SENSE. IF THE RECEIVED
:	REQUEST WAS SENT TO THE LAYER ABOVE DFC AS AN EXR,THEN
:	(1)THE RESPONSE TO THE EXR IS A NEGATIVE RESPONSE AND
:	(2)THE SENSE BYTES ON THE NEGATIVE RESPONSE ARE THE SAME AS THE 
:		SENSE BYTES THAT WERE SPECIFIED ON THE EXR.
:	PAGE 5-44 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R7 (CT_PTR GET PTR)
:	OUTPUT	:NORMAL RETURN IF NOT OK,SKIP RETURN IF OK
:	LINK	:R5
:	WORKING	:
D.SRSC
:	CHECK (RU_CTGY=DFC &RQ_CODE=CANCEL)
:	------------------------------------
	BBLOAD	R3,CMDBLK+CLARG,R7,	:GET CT PTR
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JN	D.SRS1			:JUMP,IF RU_CTGY<>DFC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CANCEL		:IS RQ_CODE=CANCEL?
	JN	D.SRS1			:JUMP,IF RQ_CODE<>CANCEL
	L	R0,BBUFER+CLARG2,R3,	:GET CT_EXR_SENSE_FOR_CANCEL
	JE	4,R5			:RETURN OK,IF =0
	LB	R3,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R3,MU.SDI		:MASK OFF OTHER BITS
	JER	R5			:RETURN NG,IF SDI<>SD
	LHL	R3,BBUFER+MURHSN,R10,	:GET SNC FROM MUCB
	CR	R3,R0			:CT_EXR_SENSE_FOR_CANCEL<>SNC?
	JNR	R5			:RETURN NG,IF NOT EQU
	J	4,R5			:ELSE,RETURN OK
:	NOT (RU_CTGY=DFC & RQ_CODE=CANCEL)
:	----------------------------------
D.SRS1
	L	R0,BBUFER+CLARG1,R3,	:GET CT_EXR_SENSE_FOR_NOT_CANCEL
	JE	4,R5			:RETURN OK,IF =0
	LB	R3,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R3,MU.SDI		:MASK OFF OTHER BITS
	JER	R5			:RETURN NG,IF SDI<>SD
	CLHI	R0,.RRBJN		:IS CT_EXR_SENSE_FOR_NOT_CANCEL=0813?
	JN	4,R5			:RETURN OK,IF NOT
	LHL	R3,BBUFER+MURHSN,R10,	:GET SNC FROM MUCB
	CLHI	R3,.RRBJN		:IS SNC(0:15)<>0813
	JE	D.SRS2			:JUMP,IF YES
	CLHI	R3,.RRBJF		:IS SNC(0:15)<>0814
	JNR	R5			:RETURN NG,IF SNC<>0813 & SNC<>0814
D.SRS2
	CR	R3,R0			:CT_EXR_SENSE_FOR_NOT_CANCEL<>SNC?
	JNR	R5			:RETURN NG,IF NOT EQU
	J	4,R5			:ELSE,RETURN OK

:	D.UGCK	-(USAGE_CHECKS) THIS PROCEDURE PERFORMS USAGE CHECKS
:	ON ALL REQUESTS AND RESPONSES. USAGE CHECKS INVOLVING THE RH
:	AND VARIOUS SESSION ACTIVATION PARAMETERS. USAGE CHECKS ARE BY
:	DEFINITION STATE INDEPENDENT, AND THUS INVOLVE NO FSM STATES.
:	PAGE 5-61 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:
:	OUTPUT	:NORMAL RETURN IF NOT OK,SKIP RETURN IF OK
:	LINK	:R5
:	WORKING	:
D.UGCK
	LHL	R7,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR
	CLH	R7,SCBBLK+SCTPTR,R9,	:COMPARE TO RELEASE PTR
:	JE	D.SDC5			:JUMP,IF CT_PTR EMPTY
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R6,D.UGC0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R6,

D.UGC0	HS
	HC	D.UGC1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.UGC2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.UGC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.UGC4-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.UGC1
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R0,MU.DFC		:IS RU_CTG=DFC?
	JN	D.UGC5			:JUMP,IF RU_CTG<>DFC
:	RU_CTG=DFC,USAGE_SENSE=USAGE_CHECKS_NORMAL_RQ_DFC
:	-------------------------------------------------
	JAL	R4,D.NQFW,,		:CALL USAGE_CHECKS_NORMAL_RQ_DFC
	J	D.UGC6			:JUMP TO CHECK USGAE_SENSE
D.UGC5
:	RU_CTG<>DFC,USAGE_SENSE=USAGE_CHECKS_NORMAL_RQ_FMD
:	-------------------------------------------------
	JAL	R4,D.NQMH,,		:CALL USAGE_CHECKS_NORMAL_RQ_FMD
	J	D.UGC6			:JUMP TO CHECK USAGE_SENSE

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.UGC2
	JAL	R4,D.NRSP,,		:CALL USAGE_CHECKS_NORMAL_RSP
	J	D.UGC6			:JUMP TO CHECK USAGE_SENSE

:	EFI=EXPEDITED & RRI=RQ
:	-------------------------------------
D.UGC3
	JAL	R4,D.EQCK,,		:CALL USAGE_CHECKS_EXP_RQ
	J	D.UGC6			:JUMP TO CHECK USAGE_SENSE

:	EFI=EXPEDITED & RRI=RSP
:	---------------
D.UGC4
	JAL	R4,D.ERSP,,		:CALL USAGE_CHECKS_EXP_RSP
	J	D.UGC6			:JUMP TO CHECK USAGE_SENSE
:	CHECK USAGE_SENSE
D.UGC6
	LR	R1,R1
	JE	4,R5			:SKIP RETURN,WHEN IT IS OK
	LHI	R3,MUSCKS		:GET OFFSET OF SEND_CHECK_SENSE
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JEFS	D.UGC7			:JUMP,IF IT IS SEND
	LHI	R3,MURCKS		:GET OFFSET OF RECEIVE_CHECK_SENSE
D.UGC7
	ST	R1,BBUFER,R3,R10	:STORE USAGE_SENSE INTO MUCB
	JR	R5			:NORMAL RETURN,IF NOT OK

:	D.RVCK	-(RCV_CHECKS) TO DETECT RECEIVE ERROR CONDITIONS. A 
:	RECEIVE ERROR IS ONE THAT CANNOT OCCUR IF THE OTHER HALF-SESSION
:	HAS IMPLEMENTED THE ARCHITECTURE CORRECTLY. THESE CHECKS ARE
:	OPTIONAL.
:	PAGE 5-53 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:
:	OUTPUT	:NORMAL RETURN IF NOT OK,SKIP RETURN IF OK
:	LINK	:R8
:	WORKING	:
D.RVCK
	ST	R8,RGSAV8,,
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.RVC0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.RVC0	HS
	HC	D.RVC1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.RVC2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.RVC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.RVC4-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.RVC1
	JAL	R5,D.UGCK,,		:CALL USAGE_CHECKS
	J	D.RVC6			:RETURN NG
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFHDX,R9,	:SET UP #FSM_HDX INDEX
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	LB	R1,SCBBLK+SCFQES,R9,	:SET UP #FSM_QEC_SEND INDEX
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	JAL	R6,D.RPEP,,		:CALL RESPONSE EXPECTED(6/22/84/CHS)
	LR	R0,R0			:CHECK OUTPUT(6/22/84/CHS)
	JN	D.RVC6			:RETURN NG, IF IT IS 'YES'(6/22/84/CHS)
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFIRR,R9,	:SET UP #FSM_IMM_RQ_MODE_RCV INDEX
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFCHR,R9,	:SET UP #FSM_CHAIN_RCV INDEX
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFBSM,R9,	:SET UP #FSM_BSM INDEX
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCHDRS,R9,	:SET UP #FSM_CONTROL_HDX_RSP_SEND
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	LB	R1,SCBBLK+SCHDRR,R9,	:SET UP #FSM_CONTROL_HDX_RSP_RCV
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LIS	R0,0			:CLEAR FSMINPUT
	LB	R1,SCBBLK+SCFSBS,R9,	:SET UP #FSM_SBI_SEND INDEX
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFEBR,R9,	:SET UP #FSM_EBCD_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFRTR,R9,	:SET UP #FSM_RTR INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFQCR,R9,	:SET UP #FSM_QRI_CHAIN_RCV
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	J	D.RVC7			:SKIP RETURN,IF OK

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.RVC2
	LB	R1,SCBBLK+SCCTET,R9,	:SET CT_ENTRY IN SCB
	JE	D.RVC6			:RETURN NG,IF CT_ENTRY<>FOUND
	LHL	R7,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
:	CLH	R7,SCBBLK+SCTPTR,R9,	:COMPARE TO REL PTR (01/03/85 MIA)
	LHL	R3,SCBBLK+SCTPTR,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R7,R3			:COMP GET AND REL PTR (01/03/85 MIA)
	JE	D.SDC5			:JUMP,IF CT_PTR EMPTY
	BBLOAD	R3,CMDBLK+CLARG,R7,	:GET CT PTR
	JAL	R5,D.UGCK,,		:CALL USAGE_CHECKS
	J	D.RVC6			:RETURN NG
	LB	R2,BBUFER+CLARG4,R3,	:GETCT_DFC_RQ_CODE
	CLHI	R2,CANCEL		:IS CT_DFC_RQ_CODE=CANCEL?
	JE	D.RVC5			:JUMP,IF CT_DFC_RQ_CODE=CANCEL
	LB	R1,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY_TYPE&CONTROL
	NHI	R1,CT.RNC		:MASK OFF OTHER BITS
	JN	D.RVC6			:RETURN NG,CT_RSP_TO_NOT_CANCEL=RCVD
D.RVC5
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.ERI		:CHECK MU.RTI BIT
	JN	D.RVC7			:ERI<>POS,RETURN OK
	CLHI	R2,LUSTAT		:IS CT_DFC_RQ_CODE=LUSTAT?
	JE	D.RVC7			:RETURN OK,IF EQU
	LB	R0,BBUFER+CLARG5+1,R3,	:GET CT_RH_RU_INFO
	THI	R0,MU.ERI		:CHECK CT_ERI BIT
	JE	D.RVC7			:CT_ERI<>ER,RETURN OK
	THI	R0,MU.DR1		:CHECK CT_DR1I
	JN	D.RVC6			:CT_DR1I=DR1,RETURN NG
	THI	R0,MU.DR2		:CHECK CT_DR2I
	JN	D.RVC6			:CT_DR2I=DR2,RETURN NG
	J	D.RVC7			:ELSE RETURN OK

:	EFI=EXPEDITED & RRI=RSP
:	-------------------------------------
D.RVC4
	LB	R1,SCBBLK+SCCTET,R9,	:SET CT_ENTRY IN SCB
	JE	D.RVC6			:RETURN NG,IF CT_ENTRY<>FOUND
	JAL	R5,D.UGCK,,		:CALL USAGE_CHECKS
	J	D.RVC6			:RETURN NG
	J	D.RVC7			:SKIP RETURN,IF OK

:	EFI=EXPEDITED & RRI=RQ
:	---------------
D.RVC3
	JAL	R5,D.UGCK,,		:CALL USAGE_CHECKS
	J	D.RVC6			:RETURN NG
	LB	R1,SCBBLK+SCFQER,R9,	:SET UP #FSM_QEC_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.RVC6			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFSBR,R9,	:SET UP #FSM_SBI_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JE	D.RVC7			:SKIP RETURN,IF TRUE FROM FSM
D.RVC6
	L	R8,RGSAV8,,
	JR	R8
D.RVC7
	L	R8,RGSAV8,,
	J	4,R8


:	D.RFSM	-(RCV_FSMS) TO UPDATE THE RECEIVE FINITE-STATE MACHINES.
:	ALSO,CONTENTION ERRORS ARE DETECTED AT THIS TIME. WHEN THEY
:	ARE DETECTED THE REQUEST IS CONVERTED TO AN EXCEPTION REQUEST.
:	PAGE 5-55 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:
:	OUTPUT	:
:	LINK	:
:	WORKING	:
D.RFSM
	ST	R8,RGSAV8,,
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.RFS0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.RFS0	HS
	HC	D.RFS1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.RFS2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.RFS3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.RFS4-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.RFS1
	LB	R1,SCBBLK+SCFRES,R9,	:SET UP #FSM_RES INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFHDX,R9,	:SET UP #FSM_HDX INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFQES,R9,	:SET UP #FSM_QEC_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFIRR,R9,	:SET UP #FSM_IMM_RQ_MODE_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFCHR,R9,	:SET UP #FSM_CHAIN_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFBSM,R9,	:SET UP #FSM_BSM INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFCBS,R9,	:SET UP #FSM_CONTROL_BSM_RSP_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCHDRS,R9,	:SET UP #FSM_CONTROL_HDX_RSP_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCHDRR,R9,	:SET UP #FSM_CONTROL_HDX_RSP_RCV
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSBS,R9,	:SET UP #FSM_SBI_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFEBR,R9,	:SET UP #FSM_EBCD_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFRTR,R9,	:SET UP #FSM_RTR INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFQCR,R9,	:SET UP #FSM_QRI_CHAIN_RCV
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	J	D.RFS5			:RETURN

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.RFS2
	LB	R1,SCBBLK+SCFQER,R9,	:SET UP #FSM_QEC_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFIRS,R9,	:SET UP #FSM_IMM_RQ_MODE_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFCBR,R9,	:SET UP #FSM_CONTROL_BSM_RSP_RCV
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCHDRR,R9,	:SET UP #FSM_CONTROL_HDX_RSP_RCV
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSBR,R9,	:SET UP #FSM_SBI_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFRTR,R9,	:SET UP #FSM_RTR INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	J	D.RFS5			:RETURN

:	EFI=EXPEDITED & RRI=RQ
:	-------------------------------------
D.RFS3
	LB	R1,SCBBLK+SCFQER,R9,	:SET UP #FSM_QEC_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSBR,R9,	:SET UP #FSM_SBI_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	J	D.RFS5			:RETURN

:	EFI=EXPEDITED & RRI=RSP
:	---------------
D.RFS4
	LB	R1,SCBBLK+SCFQES,R9,	:SET UP #FSM_QEC_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSBS,R9,	:SET UP #FSM_SBI_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
D.RFS5
	L	R8,RGSAV8,,
	JR	R8			:RETURN

:	D.RTCL	-(RCV_CT_CLEANUP) TO CLEAN UP CORRELATION TABLES.
:	PAGE 5-56 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR)
:	OUTPUT	:
:	LINK	:R8
:	WORKING	:
D.RTCL
	ST	R8,RGSAV8,,
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.RTC0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.RTC0	HS
	HC	D.RTC1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.RTC2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.RTC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.RTC4-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.RTC1
	JAL	R7,R.RQN,,		:CALL RQN
	J	D.RTCF			:JUMP,IF NOT OK
	J	D.RTCH			:RETURN
D.RTCF
	LHL	R6,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	LB	R0,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY 
	LR	R1,R0			:SAVE CONTAINTS FOR NEXT CHECK
	NHI	R0,CT.ENT		:MASK OFF OTHER BITS
	CLHI	R0,WCNCAN		:CT_ENTRY_TYPE=WHOLE_CHAIN_NO_CANCEL?
	JN	D.RTC7			:JUMP,IF NOT
	NHI	R1,CT.RNC		:MASK OFF OTHER BITS
	JE	D.RTC7			:JUMP,IF CT_RSP_TO_NOT_CANCEL<>SENT
:	REMOVE CT_NORM_ENTRY FROM CT_RCV_RQ_NORM DISCRAD 
:	-------------------------------------------------
:	CLH	R6,SCBBLK+SCTPTG,R9,	:IS R6 = CT_PTR GT (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR (01/03/85 MIA)
	CR	R6,R5			:EQUAL TO R6? (01/03/85 MIA)
	JN	D.SDC5			:CT_NORM_ENTRY SHOULD EQU CT_PTR
:	CLH	R6,SCBBLK+SCTRNG,R9,	:IS R6 = CT_RCV_RQ_NRM? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTRNG,R9,	:GET CT_RCV_RQ_NORM (01/03/85 MIA)
	CR	R6,R5			:EQUAL TO R6? (01/03/85 MIA)
	JN	D.SDC5			:THIS 2 PTRS SHOULD BE EQU
:	CLH	R6,SCBBLK+SCTRNR,R9,	:IS LIST EMPTY? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTRNR,R9,	:GET REL POINTER (01/03/85 MIA)
	CR	R6,R5			:IS LIST EMPTY? (01/03/85 MIA)
	JE	D.SDC5			:CRASH,IF LIST EMPTY
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT LIST PTR
	JE	D.SDC5			:CRASH,IF EMPTY
	STH	R7,SCBBLK+SCTRNG,R9,	:UPDATE GET PTR
	STH	R7,SCBBLK+SCTPTG,R9,	:UPDATE GET PTR
	LIS	R4,0
	STH	R4,SCBBLK+SCTNPT,R9,	:CLEAR CT_NORM_ENTRY_PTR
:	R3 CONTAINS BUFFER PTR
	JAL	R4,RELCL,,		:DISCARD CMD LIST
	JAL	R4,PBB,,		:RELEASE CT PTR (BUFFER)
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	J	D.RTCH			:RETURN
D.RTC7
	LB	R4,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R4,MU.SDI		:MASK OFF OTHER BITS
	JE	D.RTCH			:RETURN,IF SDI<>SD
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R0,MU.DFC		:IS RU_CTG=DFC?
	JN	D.RTC8			:JUMP,IF RU_CTG<>DFC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CANCEL		:IS RQ_CODE=CANCEL?
	JN	D.RTC8			:JUMP IF NOT
	LHL	R4,BBUFER+MURHSN,R10,	:GET SNC FROM MUCB
	STH	R4,BBUFER+CLARG2,R3,	:PUT SNC(0:15) CT_EXR_SENSE_FOR_CANCEL
	J	D.RTCH			:RETURN
D.RTC8
	L	R4,BBUFER+CLARG1,R3,	:GET CT_EXR_SENSE_FOR_NOT_CANCEL
	JN	D.RTCH			:RETURN, IF NOT 0
	LHL	R4,BBUFER+MURHSN,R10,	:GET SNC FROM MUCB
	STH	R4,BBUFER+CLARG1,R3,	:SNC(0:15) CT_EXR_SENSE_FOR_NOT_CANCEL
	J	D.RTCH			:RETURN

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.RTC2
	LHL	R6,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
:	CLH	R6,SCBBLK+SCTPTR,R9,	:COMPARE TO REL PTR (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTPTR,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R6,R5			:COMP GET AND REL PTR (01/03/85 MIA)
:	JE	D.SDC5			:JUMP,IF CT_PTR EMPTY(08/05/86/CHS)
	JE	D.RTCD			:EXIT,IF CT_PTR EMPTY(08/05/86/CHS)
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	LB	R0,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY 
	NHI	R0,CT.ENT		:MASK OFF OTHER BITS
	CLHI	R0,WCNCAN		:CT_ENTRY_TYPE=WHOLE_CHAIN_NO_CANCEL?
	JE	D.RTC5			:JUMP,IF YES
	CLHI	R0,ONLCAN		:CT_ENTRY_TYPE=CANCEL_ONLY?
	JE	D.RTC5			:JUMP,IF YES
	CLHI	R0,PARCHA		:CT_ENTRY_TYPE=PARTIAL_CHAIN?
	JE	D.RTC9			:JUMP,IF YES
:	CT_ENTRY_TYPE=WHOLE_CHAIN_WITH_CANCEL
:	----------------------------------
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JN	D.RTC9			:JUMP,IF RU_CTGY<>DFC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CANCEL		:IS RQ_CODE=CANCEL?
	JN	D.RTC9			:JUMP IF NOT
:	RU_CTGY=DFC&RQ_CODE=CANCEL THEN CHECK 
:	SCB.PARTNER_HALF_SESSION_RSP_MODE=IMMEDIATE? ELSE GO TO D.RTCA
:	--------------------------------------------------------------
	LB	R0,SCBBLK+SCMSSP,R9,	:GET PARTNER_HALF_SESSION_RSP_MODE
	NHI	R0,SC.OSM		:MASK OFF OTHER BITS
	JN	D.RTCA			:JUMP,IF IT IS NOT IMMEDIATE
	J	D.RTCB			:ELSE,GOTO PROCESS FUNCTIONS IN D.RTCB
:	CT_ENTRY_TYPE=WHOLE_CHAIN_NO_CANCEL OR CANCEL_ONLY
:	---------------------------------------------------
D.RTC5
	LB	R0,SCBBLK+SCMSSP,R9,	:GET PARTNER_HALF_SESSION_RSP_MODE
	NHI	R0,SC.OSM		:MASK OFF OTHER BITS
	JE	D.RTCB			:JUMP,IT IS IMMEDIATE
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JN	D.RTCA			:JUMP,IF RU_CTGY<>DFC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CHASE		:IS RQ_CODE=CHASE?
	JN	D.RTCA			:JUMP IF NOT
:	SCB.PARTNER_HALF_SESSION_RSP_MODE=IMMEDIATE |
:	(RU_CTGY=DFC&RQ_CODE=CHASE),ELSE GOTO D.RTCA
:	---------------------------------------------------
D.RTCB
:	SCAN CT_SEND_RQ_NORM PTR(SCB.SCAN_PTR)??????
	LHL	R6,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
D.RTCE
:	CLH	R6,SCBBLK+SCTSNR,R9,	:COMPARE TO REL PTR (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTSNR,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R6,R5			:COMP GET AND REL PTR (01/03/85 MIA)
	JE	D.RTCD			:JUMP,IF EMPTY
:	CLH	R6,SCBBLK+SCTNPT,R9,	:IS = CT_NRM_ENTRY_PTR? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTNPT,R9,	:GET CT_NRM_ENTRY_PTR (01/03/85 MIA)
	CR	R6,R5			:COMPARE WITH GET PTR (01/03/85 MIA)
	JN	D.RTC.			:JUMP,IF NOT EQU
	STH	R6,SCBBLK+SCSCNP,R9,	:SET SCB.SCAN_PTR TO CT_NORM_ENTRY_PTR
	J	D.RTCA
D.RTC.
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT LIST PTR
	JE	D.SDC5			:CRASH,IF EMPTY
	STH	R7,SCBBLK+SCTSNG,R9,	:UPDATE GET PTR
	STH	R7,SCBBLK+SCTPTG,R9,	:UPDATE GET PTR
	LIS	R3,0
	STH	R3,SCBBLK+SCTNPT,R9,	:CLEAR CT_NORM_ENTRY_PTR
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	JAL	R4,RELCL,,		:DISCARD CMD LIST
	JAL	R4,PBB,,		:RELEASE CT PTR (BUFFER)
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	J	D.RTCB			:REPEAT UNTILL SCB.SCAN_PTR =
					: CT_NORM_ENTRY_PTR

:	REMOVE CT_NORM_ENTRY FROM CT_SEND_RQ_NORM DISCRAD 
:	----------------------------------------------
D.RTCA
	LHL	R6,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
:	CLH	R6,SCBBLK+SCTPTG,R9,	:IS R6 = CT_PTR GET PTR (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR (01/03/85 MIA)
	CR	R6,R5			:COMP GET AND REL PTR (01/03/85 MIA)
	JN	D.SDC5			:CT_NORM_ENTRY SHOULD EQU CT_PTR
:	CLH	R6,SCBBLK+SCTSNG,R9,	:IS R6 = CT_SND_RQ_NRM? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM (01/03/85 MIA)
	CR	R6,R5			:COMPARE THEM (01/03/85 MIA)
	JN	D.SDC5			:THIS 2 PTRS SHOULD BE EQU
:	CLH	R6,SCBBLK+SCTSNR,R9,	:IS LIST EMPTY? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTSNR,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R6,R5			:IS LIST EMPTY? (01/03/85 MIA)
	JE	D.RTCD			:CALL #FSM_QRI_CHECK_SEND,IF EMPTY
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT LIST PTR
	JE	D.SDC5			:CRASH,IF EMPTY
	STH	R7,SCBBLK+SCTSNG,R9,	:UPDATE GET PTR
	STH	R7,SCBBLK+SCTPTG,R9,	:UPDATE GET PTR
	LIS	R3,0
	STH	R3,SCBBLK+SCTNPT,R9,	:CLEAR CT_NORM_ENTRY_PTR
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	JAL	R4,RELCL,,		:DISCARD CMD LIST
	JAL	R4,PBB,,		:RELEASE CT PTR (BUFFER)
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	J	D.RTCC			:JUMP TO CHECK EMPTY(CT_SEND_RQ_NORM)
:	CT_ENTRY_TYPE=PARTIAL_CHAIN
:	------------------------
D.RTC9
	LB	R0,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY 
	OHI	R0,CT.RNC		:SET CT_RSP_TO_NOT_CANCEL TO RCVD
	STB	R0,BBUFER+CLARG6,R3,	:UPDATE NEW VALUE IN CMDLST
:	IF EMPTY(CT_SEND_RQ_NORM) THEN CALL #FSM_QRI_CHECK_SEND
:	---------------------------------------------------------------
D.RTCC
	LHL	R6,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	CLH	R6,SCBBLK+SCTSNR,R9,	:COMPARE TO RELEASE PTR
	JN	D.RTCH			:RETURN,IF NOT EMPTY(CT_SEND_RQ_NORM)
D.RTCD
:	CALL #FSM_QRI_CHECK_SEND('NO_OUTSTANDING_RQS')
	LB	R1,SCBBLK+SCFQKS,R9,	:SET UP #FSM_QRI_CHECK_SEND
	LHI	R0,FS.NOR		:'NO_OUTSTANDING_RQS'
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	J	D.RTCH			:RETURN

:	EFI=EXPEDITED & RRI=RQ
:	-------------------------------------
D.RTC3
	LB	R3,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R3,MU.SDI		:MASK OFF OTHER BITS
	JE	D.RTCH			:JUMP,IF SDI BIT IS NOT SET
	LHL	R7,SCBBLK+SCRREE,R9,	:GET CT_RCV_RQ_EXP_ENTRY_PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
	LHL	R3,BBUFER+MURHSN,R10,	:GET SNC FROM MUCB
	STH	R3,CMDBLK+CLARG,R7,	:PUT SNC(0:15) CT_RCV_RQ_EXP_EXR_SENSE
	J	D.RTCH			:RETURN

:	EFI=EXPEDITED & RRI=RSP
:	---------------
:	REMOVE CT_SEND_RQ_EXP_ENTRY FROM CT_SEND_RQ_EXP AND DISCARD
D.RTC4
	LHL	R6,SCBBLK+SCSREE,R9,	:GET CT_SEND_RQ_EXP_ENTRY_PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
	LHL	R4,SCBBLK+SCTSEG,R9,	:GET CT_SEND_RQ_EXP GET PTR?
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	CR	R6,R4			:IS IT CT_SEND_RQ_EXP GET PTR?
	JN	D.RTC6			:JUMP IF NOT EQUAL
	LH	R3,CMDBLK+CLPTR,R4,	:GET NEXT CMD LST PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R3,SCBBLK+SCTSEG,R9,	:UPDATE GET PTR
	LIS	R3,0
	STH	R3,SCBBLK+SCSREE,R9,	:CLEAR CT_SEND_RQ_EXP_ENTRY_PTR
	JAL	R4,RELCL,,		:RELEASE COMMAND LST (R6)
	J	D.RTCH			:RETURN
D.RTC6
:	LH	R3,CMDBLK+CLPTR,R4,	:GET NEXT CMD LST PTR (01/03/85 MIA)
:	CLH	R3,SCBBLK+SCTSER,R9,	:= CT_SD_RQ_EXP RL PTR? (01/03/85 MIA)
	LHL	R3,CMDBLK+CLPTR,R4,	:GET NEXT CMD LST PTR (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTSER,R9,	:GET CT_SEND_RQ_EXP PTR (01/03/85 MIA)
	CR	R3,R5			:COMPARE POINTERS (01/03/85 MIA)
	JE	D.SDC5			:JUMP,IT IS ERROR
	CR	R6,R3			:IS IT THE PTR LOOKING FOR?
	JE	D.RTCG			:JUMP,IF YES
:	LH	R4,CMDBLK+CLPTR,R3,	:GET NEXT PTR (01/03/85 MIA)
	LHL	R4,CMDBLK+CLPTR,R3,	:GET NEXT PTR (01/03/85 MIA)
	J	D.RTC6			:CONTINUE FOR NEXT
D.RTCG
	LH	R5,CMDBLK+CLPTR,R3,	:GET NEXT PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R5,CMDBLK+CLPTR,R4,	:UPDATE PREVIOUS CMDLST NEXT PTR
	LIS	R3,0
	STH	R3,SCBBLK+SCSREE,R9,	:CLEAR CT_SEND_RQ_EXP_ENTRY_PTR
	JAL	R4,RELCL,,		:RELEASE CMDLST (R6)
D.RTCH
	L	R8,RGSAV8,,
	JR	R8			:RETURN

:	D.RDCK	-(RCV_DISCARD_CHECKS) TO DETERMINE IF INPUT RQ|RSP
:	IS TO BE DISCARDED.
:	PAGE 5-54 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR)
:	OUTPUT	:NORMAL RETURN IF NOT OK,SKIP RETURN IF OK TO DISCARD
:	LINK	:R8
:	WORKING	:
D.RDCK
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.RDC0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.RDC0	HS
	HC	D.RDC1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.RDC2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.RDC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.RDC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
:	CHECK TO SEE IN PURGING CHAIN STATE OR NOT 
D.RDC1
	LB	R1,SCBBLK+SCFCHR,R9,	:SET UP #FSM_CHAIN_RCV INDEX
	JER	R8			:FSM ENTRY IS NOOP,IGNORE
	LB	R2,SCBBLK+SCSTAT,R1,R9	:GET FSM CURRENT STATE
	CLHI	R2,FS.ST3		:IS IT 'PURGE' STATE?
	JE	4,R8			:SKIP RETURN,IF IT IS 'PURGE'
	JR	R8			:NORMAL RETURN,IF NOT OK TO DISCARD

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
:	DISCRD +RSP TO LUSTAT(RQE) RCV FROM HALF-SESSIONS NOT
:	SUPPORTING NEWLY REQUIRED SEND CHECKS??????
D.RDC2
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.ERI		:CHECK MU.RTI BIT
	JNR	R8			:ERI<>POS,RETURN DO_NOT_DISCARD
	LHL	R7,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
:	CLH	R7,SCBBLK+SCTPTR,R9,	:COMPARE TO REL PTR (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTPTR,R9,	:GET RELEASE PTR (01/03/85 MIA)
	CR	R7,R5			:COMP GET AND REL PTR (01/03/85 MIA)
	JER	R8			:JUMP,IF CT_PTR EMPTY
	BBLOAD	R3,CMDBLK+CLARG,R7,	:GET CT PTR
	LB	R0,BBUFER+CLARG4,R3,	:GETCT_DFC_RQ_CODE
	CLHI	R0,LUSTAT		:IS CT_DFC_RQ_CODE=LUSTAT?
	JNR	R8			:RETURN DO_NOT_DISCARD,IF NOT
	LB	R1,BBUFER+CLARG5+1,R3,	:GET CT_RH_RU_INFO
	THI	R1,MU.ERI		:CHECK CT_ERI BIT
	JER	R8			:CT_ERI<>ER ,RETURN DO_NOT_DISCARD
	THI	R1,MU.DR1		:CHECK CT_DR1I
	JN	4,R8			:CT_DR1I=DR1,RETURN DO_DISCARD
	THI	R1,MU.DR2		:CHECK CT_DR2I
	JN	4,R8			:CT_DR2I=DR2,RETURN DO_DISCARD
	JR	R8			:ELSE,RETURN DO_NOT_DISCARD

:	EFI=EXPEDITED & RRI=RQ
:	EFI=EXPEDITED & RRI=RSP
:	-------------------------------------
D.RDC3
	JR	R8			:NORMAL RETURN,IF NOT OK TO DISCARD

:	D.SDCK	-(SEND_DISCARD_CHECKS) TO DETERMINE WHEN RQ|RSP IS
:	TO BE DISCARDED.
:	PAGE 5-47 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:
:	OUTPUT	:
:	LINK	:
:	WORKING	:
D.SDCK
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.SDC0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.SDC0	HS
	HC	D.SDC1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.SDC2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.SDC1-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.SDC1-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	EFI=EXPEDITED & RRI=RQ
:	EFI=EXPEDITED & RRI=RSP
:	-------------------------------------
D.SDC1
	JR	R8			:NORMAL RETURN,IF NOT OK TO DISCARD

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
:	POSITIVE RESPONSE AND RQE REQUEST
D.SDC2
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.ERI		:CHECK MU.RTI BIT
	JNR	R8			:ERI<>POS,RETURN DO_NOT_DISCARD
	LHL	R7,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
:	CLH	R7,SCBBLK+SCTPTR,R9,	:COMPARE TO REL PTR (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTPTR,R9,	:GET RELEASE PTR (01/03/85 MIA)
	CR	R7,R5			:COMP GET AND REL PTR (01/03/85 MIA)
	JE	D.SDC5			:JUMP,IF CT_PTR EMPTY
	BBLOAD	R3,CMDBLK+CLARG,R7,	:GET CT PTR
	LB	R0,BBUFER+CLARG5+1,R3,	:GET CT_RH_RU_INFO
	THI	R0,MU.ERI		:CHECK CT_ERI BIT
	JER	R8			:CT_ERI<>ER ,RETURN DO_NOT_DISCARD
	THI	R0,MU.DR1		:CHECK CT_DR1I
	JN	4,R8			:CT_DR1I=DR1,RETURN DO_DISCARD
	THI	R0,MU.DR2		:CHECK CT_DR2I
	JN	4,R8			:CT_DR2I=DR2,RETURN DO_DISCARD
	JR	R8			:ELSE,RETURN DO_NOT_DISCARD

D.SDC5
	JAL	R10,CRASH,,
	BC	0,0,0,CRQDFC

:	D.SNCK	-(DFC.SEND_CHECKS) TO PERFORM ALL DFC SEND ERROR
:	CHECKS.
:	PAGE 5-42 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:
:	OUTPUT	:NORMAL RETURN IF NOT GOOD,SKIP RETURN IF GOOD
:	LINK	:R8
:	WORKING	:
D.SNCK
	ST	R8,RGSAV8,,
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.SNC0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.SNC0	HS
	HC	D.SNC1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.SNC2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.SNC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.SNC4-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.SNC1
	JAL	R5,D.UGCK,,		:CALL USAGE_CHECKS
	J	D.SNCA			:RETURN NG
	LB	R1,SCBBLK+SCFHDX,R9,	:SET UP #FSM_HDX INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFQER,R9,	:SET UP #FSM_QEC_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	JAL	R6,D.RSPO,,		:CALL RESPONSE_OWED
	LR	R0,R0			:CHECK OUT-PUT
	JN	D.SNCA			:RETURN 'NG',IF IT IS 'YES'
	LB	R1,SCBBLK+SCFIRS,R9,	:SET UP #FSM_IMM_RQ_MODE_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFCHS,R9,	:SET UP #FSM_CHAIN_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFBSM,R9,	:SET UP #FSM_BSM INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCHDRR,R9,	:SET UP #FSM_CONTROL_HDX_RSP_RCV
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCHDRS,R9,	:SET UP #FSM_CONTROL_HDX_RSP_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFSBR,R9,	:SET UP #FSM_SBI_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFEBS,R9,	:SET UP #FSM_EBCD_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFRTR,R9,	:SET UP #FSM_RTR INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFQKS,R9,	:SET UP #FSM_QRI_CHECK_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFQCS,R9,	:SET UP #FSM_QRI_CHAIN_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R0,SCBBLK+SCSRMD,R9,	:GET BYTE 7 OF BIND
	NHI	R0,SC.SRM		:MASK OFF OTHER BITS FOR SEND_RCV_MODE
	CLHI	R0,HDXCON		:IS IT HDX_CONTENTION?
:	JN	D.SNC8			:RETURN OK,IF S/R MODE<>HDX_CONTENTION
					: (7/20/84/CHS)
	JN	D.SNCB			:RETURN OK,IF S/R MODE<>HDX_CONTENTION
					: (7/20/84/CHS)
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.QRI		:MASK OUT OTHER BITS FOR QRI
:	JN	D.SNC8			:RETURN GOOD,IF QRI=QR (7/20/84/CHS)
	JN	D.SNCB			:RETURN GOOD,IF QRI=QR (7/20/84/CHS)
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	LR	R1,R0
	NHI	R0,MU.EBI		:MASK OUT OTHER BITS FOR EBI
	JEFS	D.SNC8			:JUMP,IF EBI<>EB
	NHI	R1,MU.BBI		:MASK OUT OTHER BITS FOR BBI
	JE	D.SNCA			:RETURN NG,IF (BBI<>BB & EBI=EB)
D.SNC8
	LB	R1,SCBBLK+SCFBSM,R9,	:SET UP #FSM_BSM INDEX
	JE	D.SNCB			:FSM ENTRY IS NOOP,IGNORE
	LB	R0,SCBBLK+SCSTAT,R1,R9	:GET FSM CURRENT STATE
	CLHI	R0,FS.ST6		:IS IT 'PEND_TERM_S' STATE?
	JE	D.SNCA			:RETURN,IF 'PEND_TERM_S'
	J	D.SNCB			:SKIP RETURN,IF GOOD

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.SNC2
	LHL	R2,SCBBLK+SCTRNG,R9,	:GET CT_RCV_RQ_NORM GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTPTG,R9,	:SET CT_PTR GET PTR
	LHL	R2,SCBBLK+SCTRNR,R9,	:GET CT_RCV_RQ_NORM RELEASE PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTPTR,R9,	:SET CT_PTR RELEASE PTR
	LHL	R3,BBUFER+MUSNF,R10,	:GET SNF FROM MUCB
	STH	R3,SCBBLK+SCKEYY,R9,	:SCB.KEY=SNF
	LHI	R1,NOFIND		:DEFAULT 'NOT FIND'
	JAL	R5,D.CKSR,,		:CALL CT_KEY_SEARCH
	IF	IG2RSP
	J	D.SNCC
	ELSE
	J	D.SNCA			:JUMP,IF NOT FIND
	EI
:	CT_KEY_SEARCH=FOUND
:	--------------------
:	CHECK USAGE_CHECKS
:	------------------
	JAL	R5,D.UGCK,,		:CALL USAGE_CHECKS
	J	D.SNCA			:RETURN NG
	LHL	R7,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
	BBLOAD	R3,CMDBLK+CLARG,R7,	:GET CT PTR
	LB	R0,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY 
	NHI	R0,CT.RNC		:MASK OFF OTHER BITS
	JE	D.SNC7			:JUMP,IF CT_RSP_TO_NOT_CANCEL<>SENT
:	CHECK (RU_CTGY=DFC &RQ_CODE=CANCEL)
:	------------------------------------
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JN	D.SNCA			:RETURN NG,IF RU_CTGY<>DFC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CANCEL		:IS RQ_CODE=CANCEL?
	JN	D.SNCA			:RETURN NG,IF RQ_CODE<>CANCEL
:	CHECK SEND_RSP_SENSE_CKS
:	-------------------------
D.SNC7
	JAL	R5,D.SRSC,,		:CALL SEND_RSP_SENSE_CHECK
	J	D.SNCA			:RETURN NG
:	CHECK SCB.THIS_HALF_SESSION_RSP_MODE=IMMEDIATE &
:	CT_NORM_ENTRY_PTR<>FIRST(CT_RCV_RQ_NORM)
:	-------------------------------------------------------------
	LB	R2,SCBBLK+SCMSSP,R9,	:GET THIS_HALF_SESSION_RSP_MODE
	NHI	R2,SC.MSM		:MASK OFF OTHER BITS
	JN	D.SNC9			:JUMP,IF IT IS NOT IMMEDIATE
	LHL	R6,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
	STH	R6,SCBBLK+SCTPTG,R9,	:UPDATE WORKING PTR
:	CLH	R6,SCBBLK+SCTRNG,R9,	:CT_NRM_ENT=1ST(CT_RCV) (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTRNG,R9,	:GET 1ST(CT_RCV_RQ_NRM) (01/03/85 MIA)
	CR	R6,R5			:COMP WITH CT_NRM_ENTRY (01/03/85 MIA)
:	(8/28/84/CHS)	THE CORRELATION TABLE MAY CONTAIN ENTRIES THAT
:	HAVE THE ERI INDICATOR SET ON. THUS, EVENTHOUGH THE FOUND CT_ENTRY
:	IS NOT THE 1ST ONE, IT IS NECESSARY REMOVED THOSE ENTRIES THAT HAVE
:	THE ERI ON AND INFRONT OF THE CT_ENTRY_FOUND
:
:	JN	D.SNCA			:RETURN NG,IF YES(8/28/84/CHS)
	JE	D.SNCB			:RETURN OK, IF YES
D.SNCX
	LHL	R6,SCBBLK+SCTRNG,R9,	:GET CT_RCV_RQ_NORM GET PTR
:	CLH	R6,SCBBLK+SCTNPT,R9,	:COMP TO CT_NRM_ENT (01/03/85 MIA)
	LHL	R2,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY (01/03/85 MIA)
	CR	R6,R2			:COMPARE POINTERS (01/03/85 MIA)
	JE	D.SNCB			:RETURN OK, IF DONE
	LHL	R2,CMDBLK+CLPTR,R6,	:GET NEXT PTR
	JE	D.CRA2			:CRASH,IF EMPTY IN NEXT PTR
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	LB	R0,BBUFER+CLARG5+1,R3,	:GET CT_RH INF.
	NHI	R0,CT.ERI		:IS IT ERI ON?
	JE	D.SNCA			:RETURN NG, IF NOT ERI
	STH	R2,SCBBLK+SCTRNG,R9,	:UPDAT CT PTR
	JAL	R4,RELCL,,		:RELEASE CT_PTR
	JAL	R4,PBB,,		:RELEASE CT_PTR
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	J	D.SNCX			:REPEAT
:	(8/28/84/CHS)	END OF MODIFICATION
:
:	CHECK SCB.THIS_HALF_SESSION_RSP_MODE=DELAYED
:	CT_NORM_ENTRY_PTR<>FIRST(CT_RCV_RQ_NORM) &
:	RU_CTGY=DFC&RQ_CODE=CHASE
:	-------------------------------------------------------------
D.SNC9
	LR	R2,R2			:GET THIS_HALF_SESSION_RSP_MODE
	JE	D.SNCB			:RETURN OK,IF IT IS NOT DELAYED
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JN	D.SNCB			:RETURN OK,IF RU_CTGY<>DFC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CHASE		:IS RQ_CODE=CHASE?
	JN	D.SNCB			:RETURN OK,IF RQ_CODE<>CHASE
	LHL	R6,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
	CLH	R6,SCBBLK+SCTRNG,R9,	:CT_NORM_ENTRY_PTR=1ST(CT_RCV_RQ_NORM)?
	JE	D.SNCB			:RETURN OK,IF YES
	J	D.SNCA			:RETURN NG

:	EFI=EXPEDITED & RRI=RQ
:	-------------------------------------
D.SNC3
	JAL	R5,D.UGCK,,		:CALL USAGE_CHECKS
	J	D.SNCA			:RETURN NG
	LB	R1,SCBBLK+SCFQES,R9,	:SET UP #FSM_QEC_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	LB	R1,SCBBLK+SCFSBS,R9,	:SET UP #FSM_SBI_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SET UP ROUTINE CALL TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	D.SNCA			:RETURN NG,IF 'TRUE' FROM FSM
	J	D.SNCB			:SKIP RETURN,IF GOOD

:	EFI=EXPEDITED & RRI=RSP
:	---------------
D.SNC4
	LHL	R0,BBUFER+MUSNF,R10,	:GET SNF FROM MUCB
	LHL	R3,SCBBLK+SCTREG,R9,	:GET CT_RCV_RQ_EXP GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
D.SNC5
:	CLH	R3,SCBBLK+SCTRER,R9,	:GET AND REL PTR SAME? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTRER,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R3,R5			:COMP GET AND REL PTR (01/03/85 MIA)
	JE	D.SNCA			:RETURN (NG) WHEN CT_PTR IS EMPTY
:	CLH	R0,CMDBLK+CLLNG,R3,	:CT_RCV_RQ_EXP_ID=SNF? (01/03/85 MIA)
	LHL	R5,CMDBLK+CLLNG,R3,	:GET CT_RCV_RQ_EXP_ID (01/03/85 MIA)
	CR	R0,R5			:COMP WITH SNF (01/03/85 MIA)
	JE	D.SNC6			:JUMP,IF CT_RCV_RQ_EXP_ID=SNF
:	UPDATE GET AND RELEASE PTR
:	--------------------------
:	LH	R3,CMDBLK+CLPTR,R3,	:GET NEXT CT PTR (01/03/85 MIA)
	LHL	R3,CMDBLK+CLPTR,R3,	:GET NEXT CT PTR (01/03/85 MIA)
	J	D.SNC5
D.SNC6
	STH	R3,SCBBLK+SCRREE,R9,	:SET CT_RCV_RQ_EXP_ENTRY_PTR
:	CALL USAGE_CHECKS
:	-----------------
	JAL	R5,D.UGCK,,		:CALL USAGE_CHECKS
	J	D.SNCA			:RETURN NG
	J	D.SNCB			:RETURN OK
D.SNCA
	LIS	R0,0
	L	R8,RGSAV8,,
	JR	R8
D.SNCB
	L	R8,RGSAV8,,
	J	4,R8
D.SNCC
	LIS	R0,1
	L	R8,RGSAV8,,
	JR	R8

:	D.SSNA	-(SEND_SNF_ASSIGN) TO ASSIGN THE SEQUENCE NUMBER OR
:	ID TO THE REQUEST.
:	PAGE 5-45 ON FAPL
:	-----------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:
:	OUTPUT	:
:	LINK	:R8
:	WORKING	:
D.SSNA
	LB	R5,BBUFER+MUBIUF,R10,	:GET BIU FLAG FROM MU
	NHI	R5,MU.EFI		:MASK OUT THE OTHER BITS
	JN	D.SSN0			:JUMP,IF IT IS 1 (EXPEDITED)
	LB	R1,SCBBLK+SCSQUS,R9,	:GET SCB.SQN_USAGE
	JE	D.SSN1			:JUMP,IT IS IDENTIFIERS
	CLHI	R1,SEQNUM		:TO CHECK IS IT SEQUENCE_NUMBERS?
	JE	D.SSN2			:JUMP IT IS SEQUENCE_NUMBERS
	CLHI	R1,NOSEQU		:IS IT NO_SNF?
	JN	D.SSN3			:JUMP,IT IS ERROR
	JAL	R4,U.SANM,,		:CALL UPM_SQN_ASSIGN_NORM
	JR	R8			:RETURN
:	SCB.SQN_USAGE=IDENTIFIERS
:	-------------------------
D.SSN1
	JAL	R4,U.IANM,,		:CALL UPM_ID_ASSIGN_NORM
	JR	R8			:RETURN
:	SCB.SQN_USAGE=SEQUENCE_NUMBERS
:	-------------------------
D.SSN2
	LHL	R1,SCBBLK+SCSQSC,R9,	:GET SCB.SQN_SEND_CNT
	AIS	R1,1			:UPDATE SCB.SQN_SEND_CNT
	STH	R1,SCBBLK+SCSQSC,R9,	:STORE IT INTO SCB
	STH	R1,BBUFER+MUSNF,R10,	:SET MUSNF TO SCB.SQN_SEND_CNT
	JR	R8			:RETURN
:	ERROR SCB.SQN_USAGE
:	-------------------
D.SSN3
	JR	R8			:RETURN
D.SSN0
	JAL	R4,U.IAEX,,		:CALL UPM_ID_ASSIGN_EXP
	JR	R8			:RETURN

:	D.STIN	-(SEND_CT_INITIALIZE) TO INITIALIZE THE CORRELATION TABLE
:	PAGE 5-46 ON FAPL
:	-----------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:
:	OUTPUT	:
:	LINK	:R8
:	WORKING	:
D.STIN
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.STI0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.STI0	HS
	HC	D.STI1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.STI2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.STI3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.STI4-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.STI1
	LHL	R2,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTPTG,R9,	:SET CT_PTR GET PTR
	LHL	R2,SCBBLK+SCTSNR,R9,	:GET CT_SEND_RQ_NORM RELEASE PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTPTR,R9,	:SET CT_PTR RELEASE PTR
	JAL	R5,D.CEAU,,		:JUMP CALL CT_ENTRY_ADD_OR_UPDATE
	LHL	R2,SCBBLK+SCTPTG,R9,	:GET WORKING GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTSNG,R9,	:SET CT_SEND_RQ_NORM TO NEW
	LHL	R2,SCBBLK+SCTPTR,R9,	:GET CT_PTR RELEASE PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R2,SCBBLK+SCTSNR,R9,	:SET CT_SEND_RQ_NORM RELEASE PTR
	JR	R8			:RETURN

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.STI2
	JR	R8			:RETURN

:	EFI=EXPEDITED & RRI=RQ
:	-------------------------------------
D.STI3
	JAL	R4,GETCL,,
	JAL	R4,CLEMP5
	LHL	R7,SCBBLK+SCTSER,R9,	:GET RELEASE PTR FOR CT_SEND_RQ_EXP
	LHL	R0,BBUFER+MUSNF,R10,	:GET SNF FROM MUCB
	STH	R0,CMDBLK+CLLNG,R7,	:STORE INTO CT_SEND_RQ_EXP_ID
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R3,		:GET RQ_CODE FROM RU
	STH	R0,CMDBLK,R7,		:SET CT_SEND_RQ_EXP_DFC_RQ_CODE
	STH	R6,CMDBLK+CLPTR,R7,	:UPDATE NEXT CMDLST PTR
	STH	R6,SCBBLK+SCTSER,R9,	:LINK NEW ENTRY
	STH	R7,SCBBLK+SCSREE,R9,	:SET CT_SEND_RQ_EXP_ENTRY_PTR
	JR	R8			:RETURN

:	EFI=EXPEDITED & RRI=RSP
:	---------------
D.STI4
	JR	R8			:RETURN

:	D.SFSM	-(DFC.SEND_FSMS) TO UPDATE ALL FSMS HAVING SEND RQ OR
:	SEND RSP INPUTS.
:	PAGE 5-48 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R14 (1ST LEVEL CALL),R9 (SCB_PTR) R10 (MU_PTR)
:	OUTPUT	:
:	LINK	:R8
:	WORKING	:
D.SFSM
	ST	R8,RGSAV8,,
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.SFS0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.SFS0	HS
	HC	D.SFS1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.SFS2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.SFS3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.SFS4-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.SFS1
	LB	R1,SCBBLK+SCFHDX,R9,	:SET UP #FSM_HDX INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFQER,R9,	:SET UP #FSM_QEC_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFIRS,R9,	:SET UP #FSM_IMM_RQ_MODE_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFCHS,R9,	:SET UP #FSM_CHAIN_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFBSM,R9,	:SET UP #FSM_BSM INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFCBR,R9,	:SET UP #FSM_CONTROL_BSM_RSP_RCV
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCHDRR,R9,	:SET UP #FSM_CONTROL_HDX_RSP_RCV
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCHDRS,R9,	:SET UP #FSM_CONTROL_HDX_RSP_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSBR,R9,	:SET UP #FSM_SBI_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFEBS,R9,	:SET UP #FSM_EBCD_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFRTR,R9,	:SET UP #FSM_RTR INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFQKS,R9,	:SET UP #FSM_QRI_CHECK_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFQCS,R9,	:SET UP #FSM_QRI_CHAIN_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	J	D.SFS5			:RETURN

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.SFS2
	LB	R1,SCBBLK+SCFQES,R9,	:SET UP #FSM_QEC_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFIRR,R9,	:SET UP #FSM_IMM_RQ_MODE_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFCHR,R9,	:SET UP #FSM_CHAIN_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFCBS,R9,	:SET UP #FSM_CONTROL_BSM_RSP_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCHDRS,R9,	:SET UP #FSM_CONTROL_HDX_RSP_SEND
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSBS,R9,	:SET UP #FSM_SBI_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFRTR,R9,	:SET UP #FSM_RTR INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	J	D.SFS5			:RETURN

:	EFI=EXPEDITED & RRI=RQ
:	-------------------------------------
D.SFS3
	LB	R1,SCBBLK+SCFQES,R9,	:SET UP #FSM_QEC_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSBS,R9,	:SET UP #FSM_SBI_SEND INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	J	D.SFS5			:RETURN

:	EFI=EXPEDITED & RRI=RSP
:	---------------
D.SFS4
	LB	R1,SCBBLK+SCFQER,R9,	:SET UP #FSM_QEC_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSHT,R9,	:SET UP #FSM_SHUTD INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R1,SCBBLK+SCFSBR,R9,	:SET UP #FSM_SBI_RCV INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
D.SFS5
	L	R8,RGSAV8,,
	JR	R8			:RETURN

:	D.STCL	-(SEND_CT_CLEANUP) TO CLEAN UP CORRELATION TABLES.
:	PAGE 5-49 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR)
:	OUTPUT	:
:	LINK	:R8
:	WORKING	:
D.STCL
	ST	R8,RGSAV8,,
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.STC0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.STC0	HS
	HC	D.STC1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.STC2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.STC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.STC4-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.STC1
	JAL	R7,R.RQN,,		:CALL RQN
	J	D.STCB			:JUMP,IF NOT OK
	J	D.STC7
D.STCB
	LHL	R6,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	LB	R0,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY 
	LR	R1,R0			:SAVE CONTAINTS FOR NEXT CHECK
	NHI	R0,CT.ENT		:MASK OFF OTHER BITS
	CLHI	R0,WCNCAN		:CT_ENTRY_TYPE=WHOLE_CHAIN_NO_CANCEL?
	JN	D.STC7			:JUMP,IF NOT
	NHI	R1,CT.RNC		:MASK OFF OTHER BITS
	JE	D.STC7			:JUMP,IF CT_RSP_TO_NOT_CANCEL<>RECEIVED
:	REMOVE CT_NORM_ENTRY FROM CT_SEND_RQ_NORM DISCRAD 
:	CLH	R6,SCBBLK+SCTPTG,R9,	:IS R6 = CT_PTR GET PTR (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR (01/03/85 MIA)
	CR	R6,R5			:COMP WITH R6 (01/03/85 MIA)
	JN	D.SDC5			:CT_NORM_ENTRY SHOULD EQU CT_PTR
:	CLH	R6,SCBBLK+SCTSNG,R9,	:IS R6 = CT_SND_RQ_NRM? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM (01/03/85 MIA)
	CR	R6,R5			:COMPARE WITH R6 (01/03/85 MIA)
	JN	D.SDC5			:THIS 2 PTRS SHOULD BE EQU
:	CLH	R6,SCBBLK+SCTSNR,R9,	:IS LIST EMPTY? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTSNR,R9,	:GET REL POINTER (01/03/85 MIA)
	CR	R6,R5			:COMPARE WITH R6 (01/03/85 MIA)
	JE	D.STCA			:CALL #FSM_QRI_CHECK_SEND,IF EMPTY
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT LIST PTR
	JE	D.SDC5			:CRASH,IF EMPTY
	STH	R7,SCBBLK+SCTSNG,R9,	:UPDATE GET PTR
	STH	R7,SCBBLK+SCTPTG,R9,	:UPDATE GET PTR
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	JAL	R4,RELCL,,		:DISCARD CMD LIST
	JAL	R4,PBB,,		:RELEASE CT PTR (BUFFER)
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
D.STC7
	LHL	R6,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM GET PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
:	CLH	R6,SCBBLK+SCTSNR,R9,	:COMPARE TO REL PTR (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTSNR,R9,	:GET RELEASE PTR (01/03/85 MIA)
	CR	R6,R5			:COMP GET AND REL PTR (01/03/85 MIA)
	JN	D.STCD			:RETURN,IF NOT EMPTY(CT_SEND_RQ_NORM)
D.STCA
:	CALL #FSM_QRI_CHECK_SEND('NO_OUTSTANDING_RQS')
	LB	R1,SCBBLK+SCFQKS,R9,	:SET UP #FSM_QRI_CHECK_SEND
	LHI	R0,FS.NOR		:'NO_OUTSTANDING_RQS'
	LIS	R6,FS.CAL		:SET UP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	J	D.STCD			:RETURN

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.STC2
	LHL	R6,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
:	CLH	R6,SCBBLK+SCTPTR,R9,	:COMPARE TO REL PTR (01/03/84 MIA)
	LHL	R5,SCBBLK+SCTPTR,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R6,R5			:COMP GET AND REL PTR (01/03/85 MIA)
:	JE	D.SDC5			:JUMP,IF CT_PTR EMPTY(08/05/86/CHS)
	JE	D.STCD			:EXIT, IF CT_PTR EMPTY(08/05/86/CHS)
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	LB	R0,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY 
	NHI	R0,CT.ENT		:MASK OFF OTHER BITS
	CLHI	R0,WCNCAN		:CT_ENTRY_TYPE=WHOLE_CHAIN_NO_CANCEL?
	JE	D.STC8			:JUMP,IF YES
	CLHI	R0,ONLCAN		:CT_ENTRY_TYPE=CANCEL_ONLY?
	JE	D.STC8			:JUMP,IF YES
	CLHI	R0,PARCHA		:CT_ENTRY_TYPE=PARTIAL_CHAIN?
	JE	D.STC9			:JUMP,IF YES
:	CT_ENTRY_TYPE=WHOLE_CHAIN_WITH_CANCEL
:	----------------------------------
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JN	D.STC9			:JUMP,IF RU_CTGY<>DFC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CANCEL		:IS RQ_CODE=CANCEL?
	JN	D.STC9			:JUMP IF NOT
:	CT_ENTRY_TYPE=WHOLE_CHAIN_NO_CANCEL OR CANCEL_ONLY
:	REMOVE CT_NORM_ENTRY FROM CT_RCV_RQ_NORM DISCRAD 
:	----------------------------------------------
D.STC8
:	CLH	R6,SCBBLK+SCTPTG,R9,	:IS R6 = CT_PTR GET PTR (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTPTG,R9,	:GET CT_PTR GET PTR (01/03/85 MIA)
	CR	R6,R5			:COMP GET AND REL PTR (01/03/85 MIA)
	JN	D.SDC5			:CT_NORM_ENTRY SHOULD EQU CT_PTR
:	CLH	R6,SCBBLK+SCTRNG,R9,	:IS R6 = CT_RCV_RQ_NRM? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTRNG,R9,	:GET CT_RCV_RQ_NORM (01/03/85 MIA)
	CR	R6,R5			:COMP GET AND REL PTR (01/03/85 MIA)
	JN	D.SDC5			:THIS 2 PTRS SHOULD BE EQU
:	CLH	R6,SCBBLK+SCTRNR,R9,	:IS LIST EMPTY? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTRNR,R9,	:GET RELEASE PTR (01/03/85 MIA)
	CR	R6,R5			:COMP GET AND REL PTR (01/03/85 MIA)
	JE	D.SDC5			:CRASH,IF LIST EMPTY
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT LIST PTR
	JE	D.SDC5			:CRASH,IF EMPTY
	STH	R7,SCBBLK+SCTRNG,R9,	:UPDATE GET PTR
	STH	R7,SCBBLK+SCTPTG,R9,	:UPDATE GET PTR
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	JAL	R4,RELCL,,		:DISCARD CMD LIST
	JAL	R4,PBB,,		:RELEASE CT PTR (BUFFER)
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	J	D.STCD			:RETURN
:	CT_ENTRY_TYPE=PARTIAL_CHAIN
:	------------------------
D.STC9
	LB	R0,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY 
	OHI	R0,CT.RNC		:SET CT_RSP_TO_NOT_CANCEL TO SENT
	STB	R0,BBUFER+CLARG6,R3,	:UPDATE NEW VALUE IN CMDLST
	J	D.STCD			:RETURN

:	EFI=EXPEDITED & RRI=RQ
:	-------------------------------------
D.STC3
	J	D.STCD			:RETURN

:	EFI=EXPEDITED & RRI=RSP
:	-------------------------------------
D.STC4
:	REMOVE CT_RCV_RQ_EXP_ENTRY FROM CT_RCV_RQ_EXP AND DISCARD
	LHL	R6,SCBBLK+SCRREE,R9,	:GET CT_RCV_RQ_EXP_ENTRY_PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
	LHL	R4,SCBBLK+SCTREG,R9,	:GET CT_RCV_RQ_EXP GET PTR?
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	CR	R6,R4			:IS IT CT_RCV_RQ_EXP GET PTR?
	JN	D.STC5			:JUMP IF NOT EQUAL
	LH	R3,CMDBLK+CLPTR,R4,	:GET NEXT CMD LST PTR
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
	STH	R3,SCBBLK+SCTREG,R9,	:UPDATE GET PTR
	LIS	R3,0
	STH	R3,SCBBLK+SCRREE,R9,	:CLEAR CT_RCV_RQ_EXP_ENTRY_PTR
	JAL	R4,RELCL,,		:RELEASE COMMAND LST (R6)
	J	D.STCD			:RETURN
D.STC5
:	LH	R3,CMDBLK+CLPTR,R4,	:GET NEXT CMD LST PTR (01/03/85 MIA)
	LHL	R3,CMDBLK+CLPTR,R4,	:GET NEXT CMD LST PTR (01/03/85 MIA)
	JE	D.CRA2			:CRASH,IF PTR NOT SETUP OK
:	CLH	R3,SCBBLK+SCTRER,R9,	:IS IT CT_RCV_RQ_EXP? (01/03/85 MIA)
	LHL	R5,SCBBLK+SCTRER,R9,	:GET CT_RQCV_RQ_EXP PTR (01/03/85 MIA)
	CR	R3,R5			:COMPARE POINTERS (01/03/85 MIA)
	JE	D.STC6			:JUMP,IT IS ERROR
	CR	R6,R3			:IS IT THE PTR LOOKING FOR?
	JEFS	D.STCC			:JUMP,IF YES
	LR	R4,R3			:GET CURRENT PTR
	J	D.STC5			:CONTINUE FOR NEXT
D.STCC
	LH	R5,CMDBLK+CLPTR,R3,	:GET NEXT PTR
	STH	R5,CMDBLK+CLPTR,R4,	:UPDATE PREVIOUS CMDLST NEXT PTR
	LIS	R3,0
	STH	R3,SCBBLK+SCRREE,R9,	:CLEAR CT_RCV_RQ_EXP_ENTRY_PTR
	JAL	R4,RELCL,,		:RELEASE CMDLST (R6)
D.STCD
	L	R8,RGSAV8,,
	JR	R8			:RETURN
D.STC6
	J	D.SDC5

:	D.BBCN	-(BETWEEN_BRACKETS_CONDITION) TO DETERMINE THE BETWEEN
:	BRACKETS CONDITION.
:	PAGE 5-58 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR) R5,R8 (PREVIOUS CALL LINK REGISTER)
:	OUTPUT	:R0 CONTAINS YES (1) OR NO (0)
:	LINK	:R8
:	WORKING	:
D.BBCN
	LHI	R0,NO			:SET 'NO' FOR RETURN
	LB	R1,SCBBLK+SCFBSM,R9,	:SET UP #FSM_BSM INDEX
	JER	R8			:ENTRY FOR FSM IS NOOP,IGNORE
	LB	R2,SCBBLK+SCSTAT,R1,R9	:GET FSM CURRENT STATE
	CLHI	R2,FS.ST1		:IS IT 'BETB' STATE?
	JNR	R8			:RETURN,IF NOT 'BETB'
	LB	R2,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JN	D.BBC5			:JUMP,IF IT IS RCV
:	MUCB.DIRECTION=SEND
:	-------------------
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.BBC0,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.BBC0	HS
	HC	D.BBC1-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.BBC2-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.BBC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.BBC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.BBC1
	LB	R1,SCBBLK+SCFCHS,R9,	:SET UP #FSM_CHAIN_SEND
	JER	R8			:ENTRY FOR FSM IS NOOP,IGNORE
	J	D.BBC9

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.BBC2
	LB	R1,SCBBLK+SCFCHR,R9,	:SET UP #FSM_CHAIN_RCV
	JER	R8			:ENTRY FOR FSM IS NOOP,IGNORE
D.BBC9
	LB	R2,SCBBLK+SCSTAT,R1,R9	:GET FSM CURRENT STATE
	CLHI	R2,FS.ST1		:IS IT 'BETC' STATE?
	JN	D.BBC3			:RETURN,IF NOT 'BETC'
D.BBC4
	LHI	R0,YES			:RETURN 'YES' IF IT IS 'BETC'
	JR	R8			:RETURN

:	EFI=EXPEDITED & RRI=RQ
:	EFI=EXPEDITED & RRI=RSP
:	-------------------------------------
D.BBC3
	LHI	R0,NO			:SET 'NO' FOR RETURN
	JR	R8			:NORMAL RETURN,IF NOT OK TO DISCARD


:	MUCB.DIRECTION=RCV
:	-------------------
D.BBC5
	JAL	R4,R.EFRR,,		:JUMP TO CHECK EFI AND RRI
	LHL	R5,D.BBC6,R1,R1		:GET ENTRY PTR FOR EACH CONDITION
	J	A.COD2,R5,

D.BBC6	HS
	HC	D.BBC7-A.COD2		:ENTRY PTR FOR NORMAL&RQ
	HC	D.BBC8-A.COD2		:ENTRY PTR FOR NORMAL&RSP
	HC	D.BBC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RQ
	HC	D.BBC3-A.COD2		:ENTRY PTR FOR EXPEDITED&RSP

:	EFI=NORMAL & RRI=RQ
:	-------------------------------------
D.BBC7
	LB	R1,SCBBLK+SCFCHR,R9,	:SET UP #FSM_CHAIN_RCV
	JER	R8			:ENTRY FOR FSM IS NOOP,IGNORE
	J	D.BBC9

:	EFI=NORMAL & RRI=RSP
:	-------------------------------------
D.BBC8
	LB	R1,SCBBLK+SCFCHS,R9,	:SET UP #FSM_CHAIN_SEND
	JER	R8			:ENTRY FOR FSM IS NOOP,IGNORE
	J	D.BBC9


:	D.NQFW	-(USAGE_CHECKS_NORMAL_RQ_DFC) THIS PROCEDURE PERFORMS USAGE 
:	CHECKS FOR NORMAL-FLOW DFC REQUEST.
:	PAGE 5-64 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR) R5,R8 (PREVIOUS CALL LINK REGISTER)
:	OUTPUT	:R1 CONTAINS DATA FOR USAGE_SENSE
:	LINK	:R4
:	WORKING	:
D.NQFW
:	###WHEN USAGE_SENSE=USAGE_CHECKS_NORMAL_RQ_DFC_1
:	================================================
	JAL	R6,D.NQED,,		:CALL USAGE_NORMAL_RQ_DFC_1
	LR	R1,R1			:GET USAGE_SENSE
	JNR	R4			:RETURN,IF USAGE_SENSE<>0
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R2,BBUFER,R1,		:GET RQ_CODE
	LHL	R1,SCBBLK+SCDFNR,R9,	:GET SCB.DFC ALLOWED BIT ARRAY
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	D.NQF0			:JUMP,IF IT IS SEND
:	MUCB.DIRECTION=RECEIVE (R2-RQ_CODE,R1-ALLOWED BIT ARRAY)
:	----------------------
:	###WHEN (RO_CODE=BID & SCB.DFC_BID_RCV=ALLOWED)####
:	===================================================
	CLHI	R2,BID			:IS RQ_CODE=BID?
	JN	D.NQF7			:JUMP,IF NOT
	THI	R1,SC.BDR		:TEST FOR BIT ARRAY FOR BID
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQF7
:	###WHEN (RO_CODE=BIS & SCB.DFC_BIS_RCV=ALLOWED)####
:	===================================================
	CLHI	R2,BIS			:IS RQ_CODE=BIS?
	JN	D.NQF8			:JUMP,IF NOT
	THI	R1,SC.BSR		:TEST FOR BIT ARRAY FOR BIS
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQF8
:	###WHEN (RO_CODE=CANCEL & SCB.DFC_CANCEL_RCV=ALLOWED)####
:	===================================================
	CLHI	R2,CANCEL		:IS RQ_CODE=CANCEL?
	JN	D.NQF9			:JUMP,IF NOT
	THI	R1,SC.CNR		:TEST FOR BIT ARRAY FOR CANCEL
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQF9
:	###WHEN (RO_CODE=CHASE & SCB.DFC_CHASE_RCV=ALLOWED)####
:	===================================================
	CLHI	R2,CHASE		:IS RQ_CODE=CHASE?
	JN	D.NQFA			:JUMP,IF NOT
	THI	R1,SC.CHR		:TEST FOR BIT ARRAY FOR CHASE
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQFA
:	###WHEN (RO_CODE=LUSTAT & SCB.DFC_LUSTAT_RCV=ALLOWED)####
:	===================================================
	CLHI	R2,LUSTAT		:IS RQ_CODE=LUSTAT?
	JN	D.NQFB			:JUMP,IF NOT
	THI	R1,SC.LSR		:TEST FOR BIT ARRAY FOR LUSTAT
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQFB
:	###WHEN (RO_CODE=QC & SCB.DFC_QC_RCV=ALLOWED)####
:	===================================================
	CLHI	R2,QC			:IS RQ_CODE=QC?
	JN	D.NQFC			:JUMP,IF NOT
	THI	R1,SC.QCR		:TEST FOR BIT ARRAY FOR QC
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQFC
:	###WHEN (RO_CODE=RTR & SCB.DFC_RTR_RCV=ALLOWED)####
:	===================================================
	CLHI	R2,RTR			:IS RQ_CODE=RTR?
	JN	D.NQFE			:JUMP,IF NOT
	THI	R1,SC.RTR		:TEST FOR BIT ARRAY FOR RTR
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQFE
	LHI	R1,.RQEFN		:SET USAGE_SENSE TO '1003'
	J	D.NQFF			:JUMP TO NEXT
D.NQFD
	LIS	R1,0			:SET USAGE_SENSE TO 0
	J	D.NQFF			:JUMP TO NEXT
:	MUCB.DIRECTION=SEND (R2-RQ_CODE,R1-ALLOWED BIT ARRAY)
:	----------------------
D.NQF0
:	###WHEN (RO_CODE=BID & SCB.DFC_BID_SEND=ALLOWED)####
:	===================================================
	CLHI	R2,BID			:IS RQ_CODE=BID?
	JN	D.NQF1			:JUMP,IF NOT
	THI	R1,SC.BDS		:TEST FOR BIT ARRAY FOR BID
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQF1
:	###WHEN (RO_CODE=BIS & SCB.DFC_BIS_SEND=ALLOWED)####
:	===================================================
	CLHI	R2,BIS			:IS RQ_CODE=BIS?
	JN	D.NQF2			:JUMP,IF NOT
	THI	R1,SC.BSS		:TEST FOR BIT ARRAY FOR BIS
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQF2
:	###WHEN (RO_CODE=CANCEL & SCB.DFC_CANCEL_SEND=ALLOWED)####
:	===================================================
	CLHI	R2,CANCEL		:IS RQ_CODE=CANCEL?
	JN	D.NQF3			:JUMP,IF NOT
	THI	R1,SC.CNS		:TEST FOR BIT ARRAY FOR CANCEL
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQF3
:	###WHEN (RO_CODE=CHASE & SCB.DFC_CHASE_SEND=ALLOWED)####
:	===================================================
	CLHI	R2,CHASE		:IS RQ_CODE=CHASE?
	JN	D.NQF4			:JUMP,IF NOT
	THI	R1,SC.CHS		:TEST FOR BIT ARRAY FOR CHASE
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQF4
:	###WHEN (RO_CODE=LUSTAT & SCB.DFC_LUSTAT_SEND=ALLOWED)####
:	===================================================
	CLHI	R2,LUSTAT		:IS RQ_CODE=LUSTAT?
	JN	D.NQF5			:JUMP,IF NOT
	THI	R1,SC.LSS		:TEST FOR BIT ARRAY FOR LUSTAT
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQF5
:	###WHEN (RO_CODE=QC & SCB.DFC_QC_SEND=ALLOWED)####
:	===================================================
	CLHI	R2,QC			:IS RQ_CODE=QC?
	JN	D.NQF6			:JUMP,IF NOT
	THI	R1,SC.QCS		:TEST FOR BIT ARRAY FOR QC
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
D.NQF6
:	###WHEN (RO_CODE=RTR & SCB.DFC_RTR_SEND=ALLOWED)####
:	===================================================
	CLHI	R2,RTR			:IS RQ_CODE=RTR?
	JN	D.NQFE			:JUMP,IF NOT
	THI	R1,SC.RTS		:TEST FOR BIT ARRAY FOR RTR
	JN	D.NQFD			:JUMP TO RETURN ,IF ALLOWED
	J	D.NQFE			:JUMP TO SET USAGE_SENSE TO '1003'
D.NQFF
	LR	R1,R1			:CHECK USAGE_SENSE
	JNR	R4			:RETURN,IF USAGE_SENSE<>0
:	#WHEN (SCB.SEND_RCV_MODE=FULL_DUPLEX & CDI=CD)####
:	======================================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.CDI		:MASK OUT OTHER BITS FOR CDI
	JE	D.NQFI			:JUMP,IF CDI<>CD
	LB	R0,SCBBLK+SCSRMD,R9,	:GET BYTE 7 OF BIND
	NHI	R0,SC.SRM		:MASK OFF OTHER BITS FOR SEND_RCV_MODE
	CLHI	R0,FULLDX		:IS IT FULL_DUPLEX?
	JN	D.NQFI			:JUMP,IF MODE<>FULL_DUPLEX
	LHI	R1,.UECDN		:SET USAGE_SENSE TO '400D'
	JR	R4			:RETURN
D.NQFI
:	#WHEN (SCB.USING_BRACKETS=NO & (EBI=EB | BBI=BB))####
:	======================================================
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAMETERS
	NHI	R0,SC.UBK		:MASK OFF OTHER BITS FOR USING_BRACKETS
	JN	D.NQFH			:JUMP,IF USING_BRACKETS=YES
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	THI	R0,MU.EBI		:TEST BITS FOR EBI
	JNFS	D.NQFG			:JUMP,IF EBI=EB
	THI	R0,MU.BBI		:TEST BITS FOR BBI
	JEFS	D.NQFH			:JUMP,IF NOT (BBI=BB | EBI=EB)
D.NQFG
	LHI	R1,.UEEBI		:SET USAGE_SENSE TO '400C'
	JR	R4
D.NQFH
:	#WHEN (SCB.HALF_SESSION=PRI & MUCB.DIRECTION=SEND |
:		SCB.HALF_SESSION=SEC & MUCB.DIRECTION=RECEIVE)
:	======================================================
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	D.NQFK			:JUMP,IF IT IS SEND
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION
	NHI	R0,SC.SES		:MASK OFF OTHER BITS
	JN	D.NQFL			:JUMP,IF IT IS PRI & RECEIVE
	J	D.NQFM
D.NQFK
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION
	NHI	R0,SC.SES		:MASK OFF OTHER BITS
	JE	D.NQFL			:JUMP,IF IT IS SEC & SECOND
:	((SEND&PRI) | (RECEIVE&SEC))
:	----------------------------
D.NQFM
:	###WHEN (SCB.PRI_EB_IND=MAY_NOT_SEND & EBI=EB)####
:	==================================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.EBI		:MASK OUT OTHER BITS FOR EBI
	JE	D.NQFJ			:JUMP,IF EBI<>EB
	LB	R0,SCBBLK+SCPLUP,R9,	:GET BIND BYTE 4
	NHI	R0,SC.PEB		:MASK FOR PRI_EB_IND
	JN	D.NQFJ			:PRI_EB_IND=MAY_SEND
	J	D.NQF.			:ELSE,JUMP
:	NOT ((SEND&PRI) | (RECEIVE&SEC))
:	-------------------------------
D.NQFL
:	###WHEN (SCB.SEC_EB_IND=MAY_NOT_SEND & EBI=EB)####
:	==================================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.EBI		:MASK OUT OTHER BITS FOR EBI
	JE	D.NQFJ			:JUMP,IF EBI<>EB
	LB	R0,SCBBLK+SCSLUP,R9,	:GET BIND BYTE 5
	NHI	R0,SC.SEB		:MASK FOR SEC_EB_IND
	JN	D.NQFJ			:SEC_EB_IND=MAY_SEND
D.NQF.
	LHI	R1,.UEEBN		:SET USAGE_SENSE TO '4004'
	JR	R4			:RETURN
D.NQFJ
	LIS	R1,0			:SET USAGE_SENSE TO '0000'
	JR	R4			:RETURN

:	D.NQMH	-(USAGE_CHECKS_NORMAL_RQ_FMD) THIS PROCEDURE PERFORMS USAGE 
:	CHECKS FOR NORMAL-FLOW FM DATA REQUESTS.
:	PAGE 5-66 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR) R5,R8 (PREVIOUS CALL LINK REGISTER)
:	OUTPUT	:R1 CONTAINS DATA FOR USAGE_SENSE
:	LINK	:R4
:	WORKING	:
D.NQMH
:	###WHEN (SCB.ALT_CODE=NOT_USED & CSI=CODE1)####
:	===============================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.CSI		:MASK OUT OTHER BITS FOR CSI
	JE	D.NQMA			:JUMP,IF CSI<>CODE1
	LB	R0,SCBBLK+SCCLUP,R9,	:GET BIND BYTE 6
	NHI	R0,SC.ALC		:MASK FOR ALT_CODE
	JNFS	D.NQMA			:SCB.ALT_CODE=MAY_BE_USED
	LHI	R1,.UECSI		:SET USAGE_SENSE TO '4010'
	JR	R4
D.NQMA
:	###WHEN (SCB.SEND_RCV_MODE=FULL_DUPLEX & CDI=CD)####
:	===============================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.CDI		:MASK OUT OTHER BITS FOR CDI
	JE	D.NQM0			:JUMP,IF CDI<>CD
	LB	R0,SCBBLK+SCSRMD,R9,	:GET BYTE 7 OF BIND
	NHI	R0,SC.SRM		:MASK OFF OTHER BITS FOR SEND_RCV_MODE
	CLHI	R0,FULLDX		:IS IT FULL_DUPLEX?
	JN	D.NQM0			:JUMP,IF MODE<>FULL_DUPLEX
	LHI	R1,.UECDN		:SET USAGE_SENSE TO '400D'
	JR	R4			:RETURN
D.NQM0
:	###WHEN (SCB.USING_BRACKETS=NO & (BBI=BB | EBI=EB))####
:	===============================================
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAMETERS
	NHI	R0,SC.UBK		:MASK OFF OTHER BITS FOR USING_BRACKETS
	JN	D.NQM7			:JUMP,IF USING_BRACKETS=YES
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	THI	R0,MU.EBI		:TEST BITS FOR EBI
	JNFS	D.NQM1			:JUMP,IF EBI=EB
	THI	R0,MU.BBI		:TEST BITS FOR BBI
	JEFS	D.NQM7			:JUMP,IF NOT (BBI=BB | EBI=EB)
D.NQM1
	LHI	R1,.UEEBI		:SET USAGE_SENSE TO '400C'
	JR	R4
D.NQM7
:	###WHEN (CDI=CD & EBI=EB)####
:	===============================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	THI	R0,MU.EBI		:TEST BITS FOR EBI
	JE	D.NQM2			:JUMP,IF EBI<>EB
	THI	R0,MU.CDI		:TEST BITS FOR CDI
	JEFS	D.NQM2			:JUMP,IF NOT (CDI=CD & EBI=EB)
D.NQM9
	LHI	R1,.UECDI		:SET USAGE_SENSE TO '4009'
	JR	R4
D.NQM2
:	###WHEN (FI=FMH & BCI<>BC)####
:	===============================================
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	LR	R1,R0
	NHI	R1,MU.BCI		:MASK OUT OTHER BITS FOR BCI
	JN	D.NQM5			:JUMP,IF BCI=BC
	LB	R2,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R2,MU.FI		:MASK OUT OTHER BITS FOR FI
	JEFS	D.NQM3			:JUMP,IF FI<>FMH
	LHI	R1,.UEFI		:SET USAGE_SENSE TO '400F'
	JR	R4
D.NQM3
:	###WHEN (BBI=BB & BCI<>BC)####
:	===============================================
	LB	R2,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R2,MU.BBI		:MASK OUT OTHER BITS FOR BBI
	JEFS	D.NQM4			:JUMP,IF BBI<>BB
	LHI	R1,.UEBBI		:SET USAGE_SENSE TO '4003'
:	JR	R6			:(8/15/84/CHS)
	JR	R4			:(8/15/84/CHS)
D.NQM4
:	###WHEN (EBI=EB &BCI<>BC)####
:	============================
	LB	R2,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R2,MU.EBI		:MASK OUT OTHER BITS FOR EBI
	JEFS	D.NQM5			:JUMP,IF EBI<>EB
D.NQM6
	LHI	R1,.UEEBN		:SET USAGE_SENSE TO '4004'
	JR	R4			:RETURN
D.NQM5
	NHI	R0,MU.ECI		:MASK OUT OTHER BITS FOR ECI
	JN	D.NQM8			:JUMP,IF ECI=EC
:	###WHEN (ECI<>EC & CDI=CD)####
:	==============================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.CDI		:MASK OUT OTHER BITS FOR CDI
	JN	D.NQM9			:JUMP,IF CDI=CD
:	###WHEN (RQD & ECI<>EC & MUCB.DIRECTION=SEND)####
:	==================================================
	JAL	R7,R.RQD,,		:CALL RQD
	J	D.NQM8			:JUMP,IF NOT OK (SKIP RETURN FOR OK)
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JN	D.NQM8			:JUMP,IF IT IS NOT SEND
D.NQME
	LHI	R1,.UEDRN		:SET USAGE_SENSE TO '4007'
	JR	R4			:RETURN
D.NQM8
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	D.NQMB			:JUMP,IF IT IS SEND
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION
	NHI	R0,SC.SES		:MASK OFF OTHER BITS
	JN	D.NQMD			:JUMP,IF IT IS PRI & RECEIVE
	J	D.NQMC
D.NQMB
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION
	NHI	R0,SC.SES		:MASK OFF OTHER BITS
	JE	D.NQMD			:JUMP,IF IT IS SEC & SECOND
:	((SEND&PRI) | (RECEIVE&SEC))
:	----------------------------
D.NQMC
:	###WHEN (SCB.PRI_EB_IND=MAY_NOT_SEND & EBI=EB)####
:	================================================================
	LB	R0,SCBBLK+SCPLUP,R9,	:GET BIND BYTE 4
	LR	R1,R0			:SAVE
	NHI	R0,SC.PEB		:MASK FOR PRI_EB_IND
	JN	D.NQN0			:PRI_EB_IND=MAY_SEND
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.EBI		:MASK OUT OTHER BITS FOR EBI
	JN	D.NQM6			:JUMP,IF EBI=EB
:	###WHEN (SCB.PRI_CHAIN_USE=SINGLE & NOT (BCI=BC & ECI=EC))####
:	================================================================
D.NQN0
	NHI	R1,SC.PCU		:MASK FOR PRI_CHAIN_USE
	JN	D.NQN2			:JUMP,IF NOT SINGLE (SINGLE=0)
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	LR	R1,R0
	NHI	R0,MU.ECI		:MASK OUT OTHER BITS FOR ECI
	JE	D.NQN1			:JUMP,IF ECI<>EC
	NHI	R1,MU.BCI		:MASK OUT OTHER BITS FOR BCI
	JNFS	D.NQN2			JUMP,IF BCI=BC
D.NQN1
	LHI	R1,.UEBCI		:SET USAGE_SENSE TO '400B'
	JR	R4
:	###WHEN (RQD & SCB.PRI_DEF_RSP_CHAIN=NOT_ALLOWED)####
:	=======================================================
D.NQN2
	LB	R2,SCBBLK+SCCHRP,R9,	:GET PRI_CHAIN_RSP
	THI	R2,SC.DRC		:TEST FOR PRI_DEF_RSP_CHAIN
	JN	D.NQN3			:JUMP,PRI_DEF_RSP_CHAIN ALLOWED
	JAL	R7,R.RQD,,		:CALL RQD
	J	D.NQN3			:JUMP,IF NOT OK
	J	D.NQME			:SET USAGE_SENSE TO '4007' IF RQD OK
:	###WHEN (RQE & ECI= EC & SCB.PRI_EXCP_RSP_CHAIN=NOT_ALLOWED)####
:	=======================================================
D.NQN3
	JAL	R7,R.RQE,,		:CALL RQE
	J	D.NQN5			:JUMP,IF RQE NOT OK
	THI	R2,SC.ERC		:TEST FOR PRI_EXCP_RSP_CHAIN
	JN	D.NQN5			:JUMP,PRI_EXCP_RSP_CHAIN ALLOWED
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.ECI		:MASK OUT OTHER BITS FOR ECI
	JN	D.NQN4			:JUMP,IF ECI=EC
:	###WHEN (RQE & ECI<>EC & SCB.PRI_EXCP_RSP_CHAIN=NOT_ALLOWED &
:	###	PRI_DEF_RSP_CHAIN=NOT_ALLOWED)####
:	=======================================================
	THI	R2,SC.DRC		:TEST FOR PRI_DEF_RSP_CHAIN
	JNFS	D.NQN5			:JUMP,PRI_DEF_RSP_CHAIN ALLOWED
D.NQN4
	LHI	R1,.UEERN		:SET USAGE_SENSE TO '4006'
	JR	R4			:RETURN
:	###WHEN (RQN & SCB.PRI_NO_RSP_CHAIN=NOT_ALLOWED)####
:	=======================================================
D.NQN5
	THI	R2,SC.NRC		:TEST FOR PRI_NO_RSP_CHAIN
	JN	D.NQMF			:JUM,PRI_NO_RSP_CHAIN ALLOWED
	JAL	R7,R.RQN,,		:CALL RQN
	J	D.NQMF			:JUMP,IF RQN NOT OK
	LHI	R1,.UENRN		:SET USAGE_SENSE TO '400A'
	JR	R4			:RETURN
:	NOT ((SEND&PRI) | (RECEIVE&SEC))
:	-------------------------------
D.NQMD
:	###WHEN (SCB.SEC_EB_IND=MAY_NOT_SEND & EBI=EB)####
:	================================================================
	LB	R0,SCBBLK+SCSLUP,R9,	:GET BIND BYTE 4
	LR	R1,R0			:SAVE
	NHI	R0,SC.SEB		:MASK FOR SEC_EB_IND
	JN	D.NQN7			:SEC_EB_IND=MAY_SEND
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.EBI		:MASK OUT OTHER BITS FOR EBI
	JN	D.NQM6			:JUMP,IF EBI=EB
:	###WHEN (SCB.SEC_CHAIN_USE=SINGLE & NOT (BCI=BC & ECI=EC))####
:	================================================================
D.NQN7
	NHI	R1,SC.SCU		:MASK FOR SEC_CHAIN_USE
	JN	D.NQN8			:JUMP,IF NOT SINGLE (SINGLE=0)
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	LR	R1,R0
	NHI	R0,MU.ECI		:MASK OUT OTHER BITS FOR ECI
	JE	D.NQN1			:JUMP,IF ECI<>EC
	NHI	R1,MU.BCI		:MASK OUT OTHER BITS FOR BCI
	JE	D.NQN1			:JUMP,IF BCI<>BC
:	###WHEN (RQD & SCB.SEC_DEF_RSP_CHAIN=NOT_ALLOWED)####
:	=======================================================
D.NQN8
	LB	R2,SCBBLK+SCCHRS,R9,	:GET SEC_CHAIN_RSP
	LR	R0,R2			:SAVE
	NHI	R0,SC.DRC		:MASK FOR SEC_DEF_RSP_CHAIN
	JN	D.NQN9			:JUMP,SEC_DEF_RSP_CHAIN ALLOWED
	JAL	R7,R.RQD,,		:CALL RQD
	J	D.NQN9			:JUMP,IF NOT OK
	J	D.NQME			:SET USAGE_SENSE TO '4007' IF RQD OK
:	###WHEN (RQE & ECI= EC & SCB.SEC_EXCP_RSP_CHAIN=NOT_ALLOWED)####
:	=======================================================
D.NQN9
	JAL	R7,R.RQE,,		:CALL RQE
	J	D.NQNA			:JUMP,IF RQE NOT OK
	LR	R0,R2			:GET SEC_CHAIN_RSP
	NHI	R0,SC.ERC		:MASK FOR SEC_EXCP_RSP_CHAIN
	JN	D.NQNA			:JUMP,SEC_EXCP_RSP_CHAIN ALLOWED
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.ECI		:MASK OUT OTHER BITS FOR ECI
	JN	D.NQN4			:JUMP,IF ECI=EC
:	###WHEN (RQE & ECI<>EC & SCB.SEC_EXCP_RSP_CHAIN=NOT_ALLOWED &
:	###	SEC_DEF_RSP_CHAIN=NOT_ALLOWED)####
:	=======================================================
	LR	R0,R2			:GET SEC_CHAIN_RSP
	NHI	R0,SC.DRC		:MASK FOR SEC_DEF_RSP_CHAIN
	JE	D.NQN4			:JUMP,IF SEC_DEF_RSP_CHAIN NOT ALLOWED
:	###WHEN (RQN & SCB.SEC_NO_RSP_CHAIN=NOT_ALLOWED)####
:	=======================================================
D.NQNA
	LR	R0,R2			:GET SEC_CHAIN_RSP
	NHI	R0,SC.NRC		:MASK FOR SEC_NO_RSP_CHAIN
	JN	D.NQMF			:JUM,SEC_NO_RSP_CHAIN ALLOWED
	JAL	R7,R.RQN,,		:CALL RQN
	J	D.NQMF			:JUMP,IF RQN NOT OK
	LHI	R1,.UENRN		:SET USAGE_SENSE TO '400A'
	JR	R4			:RETURN
D.NQMF
	LIS	R1,0			:SET USAGE_SENSE TO '0000'
	JR	R4

:	D.NRSP	-(USAGE_CHECKS_NORMAL_RSP) THIS PROCEDURE PERFORMS USAGE 
:	CHECKS FOR NORMAL-FLOW RESPONSES.
:	PAGE 5-67 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR) R5,R8 (PREVIOUS CALL LINK REGISTER)
:	OUTPUT	:R1 CONTAINS DATA FOR USAGE_SENSE
:	LINK	:R4
:	WORKING	:
D.NRSP
:	###WHEN (BCI<>BC | ECI<>EC)####
:	===============================
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	THI	R0,MU.ECI		:TEST BITS FOR ECI
	JE	D.NRS0			:JUMP,IF ECI<>EC
	THI	R0,MU.BCI		:TEST BITS FOR BCI
	JN	D.NRS1			:JUMP,IF (BCI=BC & ECI=EC)
D.NRS0
	IF	JAPANESE
	LHL	R1,SCBBLK+SCBLUC,R9,	:R1 = LUC
	LO	GBLDEF
	LB	R0,LUCTAB+LUCSYS,R1,	:R0 = SYSTEM TYPE
	FO	GBLDEF
	CLHI	R0,FUJITSU		:A FUJITSU SYSTEM?
	JEFS	D.NRS1			:YES, IGNORE BCI AND ECI ERROR
	EI	(JAPANESE)
	LHI	R1,.UEBCI		:SET USAGE_SENSE TO '400B'
	JR	R4
:	###WHEN (SDI<>RTI)####
:	===============================
D.NRS1
	LB	R0,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	NHI	R0,MU.RTI		:MASK OUT OTHER FOR RTI
	SRHLS	R0,4			:GET PROPER BIT POSITION
	LB	R3,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R3,MU.SDI		:MASK OFF OTHER BITS
	SRHLS	R3,2			:GET PROPER BIT POSITION
	CR	R3,R0			:CHECK SDI AND RTI
	JEFS	D.NRS2			:JUMP,IF SDI=RTI
	LHI	R1,.UESDI		:SET USAGE_SENSE TO '4013'
	JR	R4
D.NRS2
	LHL	R6,SCBBLK+SCTNPT,R9,	:GET CT_NORM_ENTRY_PTR
	JE	D.CRA2,,		:CRASH,IF PTR SETUP NOT RIGHT
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET CT PTR
	LB	R0,BBUFER+CLARG6,R3,	:GET CONTAINTS OF CT_ENTRY 
	LR	R1,R0			:SAVE CONTAINTS FOR NEXT CHECK
	NHI	R0,CT.ENT		:MASK OFF OTHER BITS
	CLHI	R0,WCWCAN		:CT_ENTRY_TYPE=WHOLE_CHAIN_WITH_CANCEL?
	JN	D.NRSB			:JUMP,IF NOT
	LHL	R0,BBUFER+CLARG3,R3,	:GET CT_END_SNF
:	CLH	R0,BBUFER+MUSNF,R10,	:COMP SNF TO CT_END_SNF (12/6/84 MIA)
	LHL	R1,BBUFER+MUSNF,R10,	:GET SNF (12/6/84 MIA)
	CR	R0,R1			:COMPARE THEM (12/6/84)
	JN	D.NRSB			:JUMP,IF NOT EQUAL
:	###WHEN (CT_ENTRY_TYPE=WHOLE_CHAIN_WITH_CANCEL & SNF=CT_END_SNF)####
:	============================================================
:	###WHEN (RU_CTGY<>DFC)####
:	==========================
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JE	D.NRS4			:JUMP,IF RU_CTGY=DFC
D.NRS3
	LHI	R1,.UERUG		:SET USAGE_SENSE TO '4011'
	JR	R4			:RETURN
D.NRS4
:	###WHEN (FI<>FMH)####
:	=====================
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.FI		:MASK OUT OTHER BITS FOR FI
	JNFS	D.NRS6			:JUMP,IF FI=FMH (FMH=1)
D.NRS5
	LHI	R1,.UEFI		:SET USAGE_SENSE TO '400F'
	JR	R4
D.NRS6
:	###WHEN (DR1I<>DR1 | DR2I<>DR2)####
:	===============================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	THI	R0,MU.DR1		:TEST BITS FOR DR1I
	JEFS	D.NRS7			:JUMP,IF DR1I<>DR1
	THI	R0,MU.DR2		:TEST BITS FOR DR2I
	JEFS	D.NRS8			:JUMP,IF NOT (DR1I<>DR1 | DR2I=DR2)
D.NRS7
	LHI	R1,.UEDRI		:SET USAGE_SENSE TO '4014'
	JR	R4
D.NRS8
:	###WHEN (RQ_CODE<>CANCEL)####
:	=============================
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,CANCEL		:IS RQ_CODE=CANCEL?
	JE	D.NRSA			:JUMP,IF YES
D.NRS9
	LHI	R1,.UERQD		:SET USAGE_SENSE TO '4012'
	JR	R4
D.NRSA
	LIS	R1,0			:SET USAGE_SENSE TO '0000'
	JR	R4			:RETURN

:	###WHEN NOT (CT_ENTRY_TYPE=WHOLE_CHAIN_WITH_CANCEL & SNF=CT_END_SNF)
:	============================================================
D.NRSB
:	###WHEN (DR1I<>CT_DR1I | DR2I<>CT_DR2I)####
:	============================================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	LR	R1,R0
	NHI	R0,MU.DR1		:MASK OUT OTHER BITS FOR DR1I
	NHI	R1,MU.DR2		:MASK OUT OTHER BITS FOR DR2I
	LB	R2,BBUFER+CLARG5+1,R3,	:GET CT_RH_RU_INFO
	LR	R7,R2
	NHI	R2,MU.DR1		:CHECK CT_DR1I
	NHI	R7,MU.DR2		:CHECK CT_DR2I
	CR	R0,R2			:COMPARE DR1I TO CT_DR1I
	JN	D.NRS3			:USAGE_SENSE TO '4011' IF NOT EQUAL
	CR	R1,R7			:COMPARE DR2I TO CT_DR2I
	JN	D.NRS3			:USAGE_SENSE TO '4011' IF NOT EQUAL
:	###WHEN (RU_CTGY<>CT_RU_CTGY)####
:	=================================
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	LB	R0,BBUFER+CLARG6,R3,	:GET CT_RU_CTGY
	NHI	R0,MU.CTG		:MASK OFF OTHER BITS
	CR	R1,R0			:COMPAE RU_CTGY TO CT_RU_CTGY
	JN	D.NRS3			:RU_CTGY<>CT_RU_CTGY,SET '4011'
:	###WHEN (RU_CTGY=DFC & FI<>FMH)####
:	============================================
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JNFS	D.NRSE			:JUMP,IF RU_CTGY<>DFC
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.FI		:MASK OUT OTHER BITS FOR FI
	JE	D.NRS5			:JUMP,IF FI<>FMH (FMH=0)
D.NRSE
:	###WHEN (RU_CTGY=DFC & RQ_CODE<>CT_DFC_RQ_CODE)
:	============================================
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JN	D.NRSF			:JUMP,IF RU_CTGY<>DFC
	BBLOAD	R2,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R2,		:GET RQ_CODE
	CLB	R0,BBUFER+CLARG4,R3,	:IS RQ_CODE=CT_DFC_RQ_CODE?
	JN	D.NRS9			:JUMP,IF RQ_CODE<>CT_DFC_RQ_CODE
:	###WHEN (RU_CTGY=FMD & SCB.TYPE_OF_SESSION=LU_LU & RTI=POS &
:		FI=FMH & SCB.FM_HDR_USAGE=FM_HEADERS)####
:	============================================================
D.NRSF
	CLHI	R1,MU.FMD		:IS RU_CTGY=FMD?
	JN	D.NRSA			:JUMP,IF RU_CTGY<>FMD
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.FI		:MASK OUT OTHER BITS FOR FI
	JE	D.NRSA			:JUMP,IF FI<>FMH (FMH=0)
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.RTI		:CHECK MU.RTI BIT
	JN	D.NRSA			:RTI<>POS,JUMP RETURN
	LB	R0,SCBBLK+SCSSTY,R9,	:GET SCB.TYPE_OF_SESSION
	CLHI	R0,LULU			:IS THIS SESSION LU-LU?
	JN	D.NRSA			:SESSION<>LU_LU,JUMP RETURN
	LB	R0,SCBBLK+SCCLUP,R9,	:GET BIND BYTE 6
	NHI	R0,SC.FMH		:MASK FOR FM_HDR__USAGE
	JE	D.NRSA			:SCB.FM_HDR_USAGE<>FM_HEADERS,JUMP
	J	D.NRS5			:JUMP TO SET USAGE_SENSE '400F'

:	D.EQCK	-(USAGE_CHECKS_EXP_RQ) THIS PROCEDURE PERFORMS USAGE 
:	CHECKS FOR EXPEDITED-FLOW REQUESTS.
:	PAGE 5-62 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR) R5,R8 (PREVIOUS CALL LINK REGISTER)
:	OUTPUT	:R1 CONTAINS DATA FOR USAGE_SENSE
:	LINK	:R4
:	WORKING	:
D.EQCK
:	###WHEN (RU_CTGY<>DFC)####
:	=========================================
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JEFS	D.EQC0			:JUMP,IF RU_CTGY=DFC
	LHI	R1,.UERUG		:SET USAGE_SENSE TO '4011'
	JR	R4			:RETURN
D.EQC0
:	###WHEN (FI<>FMH)####
:	=========================================
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	THI	R0,MU.FI		:TEST BITS FOR FI
	JNFS	D.EQC1			:JUMP,IF FI=FMH (FMH=1)
	LHI	R1,.UEFI		:SET USAGE_SENSE TO '400F'
	JR	R4
D.EQC1
:	###WHEN (BCI<>BC | ECI<>EC)####
:	=========================================
	THI	R0,MU.ECI		:TEST BITS FOR ECI
	JEFS	D.EQC2			:JUMP,IF ECI<>EC
	THI	R0,MU.BCI		:TEST BITS FOR BCI
	JNFS	D.EQC3			:JUMP,IF (BCI=BC & ECI=EC)
D.EQC2
	LHI	R1,.UEBCI		:SET USAGE_SENSE TO '400B'
	JR	R4
D.EQC3
:	###WHEN (DR1I<>DR1 | DR2I<>DR2 | ERI=ER)####
:	=========================================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	THI	R0,MU.DR1		:TEST BITS FOR DR1I
	JEFS	D.EQC4			:JUMP,IF DR1I<>DR1
	THI	R0,MU.DR2		:TEST BITS FOR DR2I
	JNFS	D.EQC4			:JUMP,IF DR2I=DR2
	THI	R0,MU.ERI		:TEST BITS FOR ERI
	JEFS	D.EQC5			:JUMP,IF ERII<>ERI
D.EQC4
	LHI	R1,.UEDRI		:SET USAGE_SENSE TO '4014'
	JR	R4
D.EQC5
:	###WHEN (QRI=QR)####
:	=========================================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.QRI		:MASK OUT OTHER BITS FOR QRI
	JEFS	D.EQC6			:JUMP,IF QRI<>QR
	LHI	R1,.UEQRI		:SET USAGE_SENSE TO '4015'
	JR	R4
D.EQC6
:	###WHEN (BBI=BB | EBI=EB)####
:	=========================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	THI	R0,MU.EBI		:TEST BITS FOR EBI
	JNFS	D.EQC7			:JUMP,IF EBI=EB
	THI	R0,MU.BBI		:TEST BITS FOR BBI
	JEFS	D.EQC8			:JUMP,IF NOT (BBI=BB | EBI=EB)
D.EQC7
	LHI	R1,.UEEBI		:SET USAGE_SENSE TO '400C'
	JR	R4
D.EQC8
:	###WHEN (CDI=CD)####
:	=========================================
	THI	R0,MU.CDI		:TEST BITS FOR CDI
	JEFS	D.EQC9			:JUMP,IF CDI<>CD
	LHI	R1,.UECDI		:SET USAGE_SENSE TO '4009'
	JR	R4
D.EQC9
:	###WHEN (CSI=CODE1)####
:	=========================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.CSI		:MASK OUT OTHER BITS FOR CSI
	JEFS	D.EQCA			:JUMP,IF CSI<>CODE1 (CODE1=1)
	LHI	R1,.UECSI		:SET USAGE_SENSE TO '4010'
	JR	R4
D.EQCA
:	###WHEN (EDI=ED)####
:	=========================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.EDI		:MASK OUT OTHER BITS FOR EDI
	JEFS	D.EQCB			:JUMP,IF EDI<>CODE1 (CODE1=1)
	LHI	R1,.UEEDI		:SET USAGE_SENSE TO '4016'
	JR	R4
D.EQCB
:	###WHEN (PDI=PD)####
:	=========================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.PDI		:MASK OUT OTHER BITS FOR PDI
	JEFS	D.EQCC			:JUMP,IF PDI<>CODE1 (CODE1=1)
	LHI	R1,.UEPDI		:SET USAGE_SENSE TO '4017'
	JR	R4
D.EQCC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R2,BBUFER,R1,		:GET RQ_CODE
	LHL	R1,SCBBLK+SCDFER,R9,	:GET SCB.DFC ALLOWED BIT ARRAY
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	D.EQD0			:JUMP,IF IT IS SEND
:	MUCB.DIRECTION=RECEIVE (R2-RQ_CODE,R1-ALLOWED BIT ARRAY)
:	----------------------
:	###WHEN (RQ_CODE=QEC & SCB.DFC_QEC_RCV=ALLOWED)
:	=========================================
	CLHI	R2,QEC			:IS RQ_CODE=QEC?
	JN	D.EQCD			:JUMP,IF NOT
	THI	R1,SC.QER		:TEST FOR BIT ARRAY FOR QEC
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQCD
:	###WHEN (RQ_CODE=RELQ & SCB.DFC_RELQ_RCV=ALLOWED)
:	=========================================
	CLHI	R2,RELQ			:IS RQ_CODE=RELQ?
	JN	D.EQCE			:JUMP,IF NOT
	THI	R1,SC.RLR		:TEST FOR BIT ARRAY FOR RELQ
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQCE
:	###WHEN (RQ_CODE=RSHUTD & SCB.DFC_RSHUTD_RCV=ALLOWED)
:	=========================================
	CLHI	R2,RSHUTD		:IS RQ_CODE=RSHUTD?
	JN	D.EQCF			:JUMP,IF NOT
	THI	R1,SC.RSR		:TEST FOR BIT ARRAY FOR RSHUTD
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQCF
:	###WHEN (RQ_CODE=SBI & SCB.DFC_SBI_RCV=ALLOWED)
:	=========================================
	CLHI	R2,SBI			:IS RQ_CODE=SBI?
	JN	D.EQCG			:JUMP,IF NOT
	THI	R1,SC.SBR		:TEST FOR BIT ARRAY FOR SBI
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQCG
:	###WHEN (RQ_CODE=SHUTC & SCB.DFC_SHUTC_RCV=ALLOWED)
:	=========================================
	CLHI	R2,SHUTC		:IS RQ_CODE=SHUTC?
	JN	D.EQCH			:JUMP,IF NOT
	THI	R1,SC.SCR		:TEST FOR BIT ARRAY FOR SHUTC
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQCH
:	###WHEN (RQ_CODE=SHUTD & SCB.DFC_SHUTD_RCV=ALLOWED)
:	=========================================
	CLHI	R2,SHUTD		:IS RQ_CODE=SHUTD?
	JN	D.EQCI			:JUMP,IF NOT
	THI	R1,SC.SDR		:TEST FOR BIT ARRAY FOR SHUTD
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQCI
:	###WHEN (RQ_CODE=SIG & SCB.DFC_SIG_RCV=ALLOWED)
:	=========================================
	CLHI	R2,SIG			:IS RQ_CODE=SIG?
	JN	D.EQC.			:JUMP,IF NOT
	THI	R1,SC.SGR		:TEST FOR BIT ARRAY FOR SIG
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQC.
	LHI	R1,.RQEFN		:SET USAGE_SENSE TO '1003'
	JR	R4			:RETURN
D.EQCJ
	LIS	R1,0			:SET USAGE_SENSE TO 0
	JR	R4
:	MUCB.DIRECTION=SEND (R2-RQ_CODE,R1-ALLOWED BIT ARRAY)
:	----------------------
D.EQD0
:	###WHEN (RQ_CODE=QEC & SCB.DFC_QEC_SEND=ALLOWED)
:	=========================================
	CLHI	R2,QEC			:IS RQ_CODE=QEC?
	JN	D.EQD1			:JUMP,IF NOT
	THI	R1,SC.QES		:TEST FOR BIT ARRAY FOR QEC
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQD1
:	###WHEN (RQ_CODE=RELQ & SCB.DFC_RELQ_SEND=ALLOWED)
:	=========================================
	CLHI	R2,RELQ			:IS RQ_CODE=RELQ?
	JN	D.EQD2			:JUMP,IF NOT
	THI	R1,SC.RLS		:TEST FOR BIT ARRAY FOR RELQ
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQD2
:	###WHEN (RQ_CODE=RSHUTD & SCB.DFC_RSHUTD_SEND=ALLOWED)
:	=========================================
	CLHI	R2,RSHUTD		:IS RQ_CODE=RSHUTD?
	JN	D.EQD3			:JUMP,IF NOT
	THI	R1,SC.RSS		:TEST FOR BIT ARRAY FOR RSHUTD
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQD3
:	###WHEN (RQ_CODE=SBI & SCB.DFC_SBI_SEND=ALLOWED)
:	=========================================
	CLHI	R2,SBI			:IS RQ_CODE=SBI?
	JN	D.EQD4			:JUMP,IF NOT
	THI	R1,SC.SBS		:TEST FOR BIT ARRAY FOR SBI
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQD4
:	###WHEN (RQ_CODE=SHUTC & SCB.DFC_SHUTC_SEND=ALLOWED)
:	=========================================
	CLHI	R2,SHUTC		:IS RQ_CODE=SHUTC?
	JN	D.EQD5			:JUMP,IF NOT
	THI	R1,SC.SCS		:TEST FOR BIT ARRAY FOR SHUTC
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQD5
:	###WHEN (RQ_CODE=SHUTD & SCB.DFC_SHUTD_SEND=ALLOWED)
:	=========================================
	CLHI	R2,SHUTD		:IS RQ_CODE=SHUTD?
	JN	D.EQD6			:JUMP,IF NOT
	THI	R1,SC.SDS		:TEST FOR BIT ARRAY FOR SHUTD
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
D.EQD6
:	###WHEN (RQ_CODE=SIG & SCB.DFC_SIG_SEND=ALLOWED)
:	=========================================
	CLHI	R2,SIG			:IS RQ_CODE=SIG?
	JN	D.EQC.			:JUMP,IF NOT
	THI	R1,SC.SGS		:TEST FOR BIT ARRAY FOR SIG
	JN	D.EQCJ			:JUMP TO RETURN ,IF ALLOWED
	J	D.EQC.			:JUMP TO SET USAGE_SENSE TO '1003'

:	D.ERSP	-(USAGE_CHECKS_EXP_RSP) THIS PROCEDURE PERFORMS USAGE 
:	CHECKS FOR EXPEDITED-FLOW RESPONSES.
:	PAGE 5-63 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR) R5,R8 (PREVIOUS CALL LINK REGISTER)
:		 R7 (CT_PTR)
:	OUTPUT	:R1 CONTAINS DATA FOR USAGE_SENSE
:	LINK	:R4
:	WORKING	:
D.ERSP
:	###WHEN (RU_CTGY<>DFC)####
:	====================================
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R1,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
	CLHI	R1,MU.DFC		:IS RU_CTGY=DFC?
	JEFS	D.ERS0			:JUMP,IF RU_CTGY=DFC
	LHI	R1,.UERUG		:SET USAGE_SENSE TO '4011'
	JR	R4			:RETURN
D.ERS0
:	###WHEN (FI<>FMH)####
:	====================================
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.FI		:MASK OUT OTHER BITS FOR FI
	JNFS	D.ERS1			:JUMP,IF FI=FMH (FMH=1)
	LHI	R1,.UEFI		:SET USAGE_SENSE TO '400F'
	JR	R4
D.ERS1
:	###WHEN (SDI<>RTI)####
:	====================================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.ERI		:CHECK MU.RTI BIT
	SRHLS	R0,4			:PUT IN 1ST POSITION (03/17/86 MIA)
	LB	R3,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R3,MU.SDI		:MASK OFF OTHER BITS
	SRHLS	R3,2			:GET PROPER BIT POSITION
	CR	R3,R0			:CHECK SDI AND RTI
	JEFS	D.ERS2			:JUMP,IF SDI=RTI
	LHI	R1,.UESDI		:SET USAGE_SENSE TO '4013'
	JR	R4
D.ERS2
:	###WHEN (BCI<>BC | ECI<>EC)####
:	====================================
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	THI	R0,MU.ECI		:TEST BITS FOR ECI
	JEFS	D.ERS3			:JUMP,IF ECI<>EC
	THI	R0,MU.BCI		:TEST BITS FOR BCI
	JNFS	D.ERS4			:JUMP,IF (BCI=BC & ECI=EC)
D.ERS3
	LHI	R1,.UEBCI		:SET USAGE_SENSE TO '400B'
	JR	R4
D.ERS4
:	###WHEN (DR1I<>DR1 | DR2I<>DR2)####
:	====================================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	THI	R0,MU.DR1		:TEST BITS FOR DR1I
	JEFS	D.ERS5			:JUMP,IF DR1I<>DR1
	THI	R0,MU.DR2		:TEST BITS FOR DR2I
	JEFS	D.ERS6			:JUMP,IF NOT (DR1I<>DR1 | DR2I=DR2)
D.ERS5
	LHI	R1,.UEDRI		:SET USAGE_SENSE TO '4014'
	JR	R4
D.ERS6
:	###WHEN (QRI=QR)####
:	====================================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.QRI		:MASK OUT OTHER BITS FOR QRI
	JEFS	D.ERS7			:JUMP,IF QRI<>QR
	LHI	R1,.UEQRI		:SET USAGE_SENSE TO '4015'
	JR	R4
D.ERS7
:	((MUCB.DIRECTION=SEND & RQ_CODE<>CT_RCV_RQ_EXP_DFC_RQ_CODE)
:	| (MUCB.DIRECTION=RECEIVE & RQ_CODE<>CT_SEND_RQ_EXP_DFC_RQ_CODE))
:	==================================================================
	LHL	R7,SCBBLK+SCRREE,R9,	:GET CT_RCV_RQ_EXP_ENTRY_PTR
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R3,		:GET RQ_CODE FROM RU
	LB	R1,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JEFS	D.ERS8			:JUMP,IF IT IS SEND
	LHL	R7,SCBBLK+SCSREE,R9,	:GET CT_SEND_RQ_EXP_ENTRY_PTR
D.ERS8
	CLH	R0,CMDBLK,R7,		:CT_SEND_RQ_EXP_DFC_RQ_CODE=RQ_CODE?
					:CT_RCV_RQ_EXP_DFC_RQ_CODE=RQ_CODE?
	JEFS	D.ERS9			:JUMP,IF EQUAL
	LHI	R1,.UERQD		:SET USAGE_SENSE TO '4012'
	JR	R4
D.ERS9
	LIS	R1,0
	JR	R4			:ELSE,SET USAGE_SENSE='0000'

:	D.NQED	-(USAGE_CHECKS_NORMAL_RQ_DFC_1) THIS PROCEDURE PERFORMS
:	FORMAT CHECKS ON NORMAL-FLOW DFC REQUEST.
:	PAGE 5-65 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MUCB PTR) R5,R8,R4 (PREVIOUS CALL LINK REGISTER)
:	OUTPUT	:R1 CONTAINS DATA FOR USAGE_SENSE
:	LINK	:R6
:	WORKING	:
D.NQED
:	###WHEN (FI<>FMH)####
:	=======================
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	NHI	R0,MU.FI		:MASK OUT OTHER BITS FOR FI
	JNFS	D.NQE0			:JUMP,IF FI=FMH (FMH=1)
	LHI	R1,.UEFI		:SET USAGE_SENSE TO '400F'
	JR	R6
D.NQE0
:	###WHEN (BCI<>BC & ECI<>EC)####
:	=====================================
	LB	R0,BBUFER+MURHF1,R10,	:GET MURHF1
	THI	R0,MU.ECI		:TEST BITS FOR ECI
	JEFS	D.NQE1			:JUMP,IF ECI<>EC
	THI	R0,MU.BCI		:TEST BITS FOR BCI
	JNFS	D.NQE2			:JUMP,IF (BCI=BC & ECI=EC)
D.NQE1
	LHI	R1,.UEBCI		:SET USAGE_SENSE TO '400B'
	JR	R6
D.NQE2
:	###WHEN (CSI=CODE1)####
:	=====================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.CSI		:MASK OUT OTHER BITS FOR CSI
	JEFS	D.NQE3			:JUMP,IF CSI<>CODE1 (CODE1=1)
	LHI	R1,.UECSI		:SET USAGE_SENSE TO '4010'
	JR	R6
D.NQE3
:	###WHEN (EDI=ED)####
:	=====================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.EDI		:MASK OUT OTHER BITS FOR EDI
	JEFS	D.NQE4			:JUMP,IF EDI<>CODE1 (CODE1=1)
	LHI	R1,.UEEDI		:SET USAGE_SENSE TO '4016'
	JR	R6
D.NQE4
:	###WHEN (PDI=PD)####
:	=====================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	NHI	R0,MU.PDI		:MASK OUT OTHER BITS FOR PDI
	JEFS	D.NQE5			:JUMP,IF PDI<>CODE1 (CODE1=1)
	LHI	R1,.UEPDI		:SET USAGE_SENSE TO '4017'
	JR	R6
D.NQE5
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU-PTR FROM MUCB
	LB	R0,BBUFER,R3,		:GET RQ_CODE FROM RU
	CLHI	R0,BID			:IS RQ-CODE=BID?
	JE	D.UNQ0			:JUMP,IF IT IS
	CLHI	R0,BIS			:IS RQ-CODE=BIS?
	JE	D.UNQ0			:JUMP,IF IT IS
	CLHI	R0,RTR			:IS RQ-CODE=RTR?
	JE	D.UNQ0			:JUMP,IF IT IS
	CLHI	R0,CANCEL		:IS RQ-CODE=CANCEL?
	JE	D.UNQ1			:JUMP,IF IT IS
	CLHI	R0,CHASE		:IS RQ-CODE=CHASE?
	JE	D.UNQ1			:JUMP,IF IT IS
	CLHI	R0,QC			:IS RQ-CODE=QC?
	JE	D.UNQ1			:JUMP,IF IT IS
	CLHI	R0,LUSTAT		:IS RQ-CODE=LUSTAT?
	JE	D.UNQ2			:JUMP,IF IT IS
	LIS	R1,0
	JR	R6			:ELSE,SET USAGE_SENSE='0000'
:	RQ_CODE=BID | RQ_CODE=BIS | RQ_CODE=RTR
:	---------------------------------------
D.UNQ0
:	###WHEN (DR1I<>DR1 | DR2I<>DR2 | ERI=ER)####
:	============================================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	THI	R0,MU.DR1		:TEST BITS FOR DR1I
	JEFS	D.UNQ4			:JUMP,IF DR1I<>DR1
	THI	R0,MU.DR2		:TEST BITS FOR DR2I
	JNFS	D.UNQ4			:JUMP,IF DR2I=DR2
	THI	R0,MU.ERI		:TEST BITS FOR ERI
	JEFS	D.UNQ3			:JUMP,IF ERII<>ERI
D.UNQ4
	LHI	R1,.UEDRI		:SET USAGE_SENSE TO '4014'
	JR	R6
D.UNQ3
:	###WHEN (BBI=BB | EBI=EB)#####
:	============================================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	THI	R0,MU.EBI		:TEST BITS FOR EBI
	JNFS	D.UNQA			:JUMP,IF EBI=EB
	THI	R0,MU.BBI		:TEST BITS FOR BBI
	JEFS	D.UNQ5			:JUMP,IF NOT (BBI=BB | EBI=EB)
D.UNQA
	LHI	R1,.UEEBI		:SET USAGE_SENSE TO '400C'
	JR	R6
D.UNQ5
:	###WHEN (CDI=CD)####
:	============================================
	THI	R0,MU.CDI		:TEST BITS FOR CDI
	JEFS	D.UNQ9			:JUMP,IF CDI<>CD
D.UNQ7
	LHI	R1,.UECDI		:SET USAGE_SENSE TO '4009'
	JR	R6
D.UNQ9
	LIS	R1,0
	JR	R6			:ELSE,SET USAGE_SENSE='0000'
:	RQ_CODE=CANCEL | RQ_CODE=CHASE | RQ-CODE=QC
:	-------------------------------------------
D.UNQ1
:	###WHEN (DR1I<>DR1 | DR2I<>DR2 | ERI=ER)####
:	============================================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	THI	R0,MU.DR1		:TEST BITS FOR DR1I
	JE	D.UNQ4			:JUMP,IF DR1I<>DR1
	THI	R0,MU.DR2		:TEST BITS FOR DR2I
	JN	D.UNQ4			:JUMP,IF DR2I=DR2
	THI	R0,MU.ERI		:TEST BITS FOR ERI
	JN	D.UNQ4			:JUMP,IF ERI=ER
:	###WHEN (BBI=BB)####
:	==============================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	THI	R0,MU.BBI		:TEST BITS FOR BBI
	JEFS	D.UNQ6			:JUMP,IF BBI<>BB
	LHI	R1,.UEBBI		:SET USAGE_SENSE TO '4003'
	JR	R6
:	###WHEN (EBI=EB & CDI=CD)####
:	==============================
D.UNQ6
	THI	R0,MU.EBI		:TEST BITS FOR EBI
	JE	D.UNQ9			:JUMP,IF EBI<>EB
	THI	R0,MU.CDI		:TEST BITS FOR CDI
	JE	D.UNQ9			:JUMP,IF NOT (CDI=CD & EBI=EB)
	J	D.UNQ7			:JUMP TO SET USAGE_SENSE '4009'
:	RQ_CODE=LUSTAT
:	-------------------------------------------
D.UNQ2
:	###WHEN (DR1I<>DR1 & DR2I<>DR2)####
:	==============================
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	THI	R0,MU.DR1		:TEST BITS FOR DR1I
	JNFS	D.UNQ8			:JUMP,IF DR1I=DR1
	THI	R0,MU.DR2		:TEST BITS FOR DR2I
	JNFS	D.UNQ8			:JUMP,IF DR2I=DR2
	J	D.UNQ4			:DR1I<>DR1 & DR2I<>DR2,SET '4014'
D.UNQ8
:	###WHEN (EBI=EB & CDI=CD)####
:	==============================
	LB	R0,BBUFER+MURHF3,R10,	:GET MURHF3
	THI	R0,MU.EBI		:TEST BITS FOR EBI
	JE	D.UNQ9			:JUMP,IF EBI<>EB
	THI	R0,MU.CDI		:TEST BITS FOR CDI
	JE	D.UNQ9			:JUMP,IF NOT (CDI=CD & EBI=EB)
	J	D.UNQ7			:CDI=CD & EBI=EB,SET '4009'

:	D.RSPO	-(RESPONSE_OWED) TO TEST IF,IN HALF_DUPLEX SEND/RECEIVE
:	MODE, THERE ARE PREVIOUSLY RECEIVED REQUESTS THAT HAVE NOT BEEN
:	RESPONDED TO,AND,IF SO,TO SET SENSE CODE '200D'
:	PAGE 5-43 ON FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MU PTR) R9 (SCB_PTR) R14 (CALL ADDRESS)
:	OUTPUT	:R0 (CONTAINS 'NO'OR 'YES')
:	LINK	:R6
:	WORKING	:
D.RSPO
	LHI	R0,NO			:INITIAL VALUE FOR RETURN
	LB	R2,SCBBLK+SCSRMD,R9,	:GET BYTE 7 OF BIND
	NHI	R2,SC.SRM		:MASK OFF OTHER BITS FOR SEND_RCV_MODE
	CLHI	R2,HDXCON		:IS IT HDX_CONTENTION?
	JE	D.RSP1			:JUMP,IF S/R MODE=HDX_CONTENTION
	CLHI	R2,HDXFF		:IS IT HDX_FLIP_FLOP?
	JNR	R6			:RETURN 'NO',IF NOT HDX_FLIP_FLOP
D.RSP1
	LHL	R4,SCBBLK+SCTRNG,R9,	:GET CT_RCV_RQ_NORM GET PTR
:	CLH	R4,SCBBLK+SCTRNR,R9,	:COMPARE TO REL PTR (01/03/84 MIA)
	LHL	R2,SCBBLK+SCTRNR,R9,	:GET RELEASE PTR (01/03/85 MIA
	CR	R4,R2			:COMP GET AND REL PTR (01/03/85 MIA)
	JER	R6			:RETURN 'NO',IF EMPTY(CT_RCV_RQ_NORM)
	LHL	R2,CMDBLK+CLPTR,R4,	:GET NEXT PTR
	JE	D.SDC5			:CRASH,IF EMPTY IN NEXT PTR
	BBLOAD	R3,CMDBLK+CLARG,R4,	:GET CT PTR
	LB	R0,BBUFER+CLARG5+1,R3,	:GET CT_RH INF.
	NHI	R0,CT.ERI		:IS IT ERI ON?
	JE	D.RSP2			:SEND SENSE CODE,IF NO
	ST	R6,RGSAV6,,		:SAVE RETURN ADDRESS
	STH	R2,SCBBLK+SCTRNG,R9,	:UPDAT CT PTR
	LR	R6,R4
	JAL	R4,RELCL,,		:RELEASE CT_PTR
	JAL	R4,PBB,,		:RELEASE CT_PTR
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	L	R6,RGSAV6,,		:GET BACK ORIGINAL REG.
	LHI	R0,NO			:INITIAL VALUE FOR RETURN
	J	D.RSP1			:REPEAT
D.RSP2
	LHI	R1,.SEROB		:RESPONSE OWED BEFORE SENDING REQ
	ST	R1,BBUFER+MUSCKS,R10,	:SET SEND_CHECK_SENSE
	LHI	R0,YES			:RETURN 'YES'
	JR	R6

:	(6/22/84/CHS)
:	D.RPEP	-(RSP_EXPECTED) TO TEST IF,IN HALF_DUPLEX SEND/RECEIVE
:	MODE, THERE ARE PREVIOUSLY SENT REQUESTS THAT HAVE NOT BEEN
:	RESPONDED TO,AND,IF SO,TO SET SENSE CODE '200D'
:	NOT DEFINED IN FAPL
:	--------------------------------------------------------------
:	THE USAGES OF REGISTERS ARE ---
:	INPUT	:R10 (MU PTR) R9 (SCB_PTR) R14 (CALL ADDRESS)
:	OUTPUT	:R0 (CONTAINS 'NO'OR 'YES')
:	LINK	:R6
:	WORKING	:
D.RPEP
	LHI	R0,NO			:INITIAL VALUE FOR RETURN
	LB	R2,SCBBLK+SCSRMD,R9,	:GET BYTE 7 OF BIND
	NHI	R2,SC.SRM		:MASK OFF OTHER BITS FOR SEND_RCV_MODE
	CLHI	R2,HDXCON		:IS IT HDX_CONTENTION?
	JE	D.RPE1			:JUMP,IF S/R MODE=HDX_CONTENTION
	CLHI	R2,HDXFF		:IS IT HDX_FLIP_FLOP?
	JNR	R6			:RETURN 'NO',IF NOT HDX_FLIP_FLOP
D.RPE1
	LHL	R4,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM GET PTR
:	CLH	R4,SCBBLK+SCTSNR,R9,	:COMPARE TO REL PTR(01/03/85 MIA)
	LHL	R2,SCBBLK+SCTSNR,R9,	:GET RELEASE PTR (01/03/85 MIA)
	CR	R4,R2			:COMP GET AND REL PTR (01/03/85 MIA)
	JER	R6			:RETURN 'NO',IF EMPTY(CT_SEND_RQ_NORM)
	LHL	R2,CMDBLK+CLPTR,R4,	:GET NEXT PTR
	JE	D.SDC5			:CRASH,IF EMPTY IN NEXT PTR
	BBLOAD	R3,CMDBLK+CLARG,R4,	:GET CT PTR
	LB	R0,BBUFER+CLARG5+1,R3,	:GET CT_RH INF.
	NHI	R0,CT.ERI		:IS IT ERI ON?
	JER	R6			:NO, CAN NOT DELETE REMAINING ct_ENTRY
	ST	R6,RGSAV6,,		:SAVE RETURN ADDRESS
	STH	R2,SCBBLK+SCTSNG,R9,	:UPDAT CT PTR
	LR	R6,R4
	JAL	R4,RELCL,,		:RELEASE CT_PTR
	JAL	R4,PBB,,		:RELEASE CT_PTR
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
	L	R6,RGSAV6,,		:GET BACK ORIGINAL REG.
	LHI	R0,NO			:INITIAL VALUE FOR RETURN
	J	D.RPE1			:REPEAT
:	(6/22/84/CHS)

D.CRA2
	JAL	R10,CRASH,,
	BC	0,0,0,CRQDFC

	FO	CBKDEF
	FO	BBUFER
	FO	CMDLST
	FO	MAIN

	EM
    
	SUBTTL	SNA PACKAGE(MAIN PROCESSES) - DATA FLOW CONTROL LAYER
:	MODULE NAME IN COMMAND FILE -- SDCC00.F00

:	*****************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) - ORIGINAL DESIGN AND CODING
:	*****************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT THE FUNCTIONS OF DFC LAYER
:	(PLEASE REFER TO CHAPTER 5 IN THE SNA FAPL MANUAL)
:	--------------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CBKDEF
	LO	CMDLST
	LO	MAIN

	SEG	A.CODE

:	D.DQTD	-(DEQUEUE.Q_TC_TO_DFC)THE FUNCTION OF THIS PROCEDURE IS
:	TO DEQUEUE A REQUEST OR A RESPONSE FROM Q_TC_TO_DFC AND CALL THE
:	D.FCRV (DFC.RCV) PROCEDURE TO PROCESS IT.
:	PAGE 5-40 ON FAPL
:	----------------------------------------------------------------
:	THE USAGE OF THE REGISTERS ARE ---
:	INPUT	:R5 (ENTRY OF THIS ROUTINE) R13 (NCB OF THE CURRENT NODE)
:	OUTPUT	:
:	LINK	:R14
:	WORKING	:
D.DQTD
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.OPQ		:IS IT OPEN_QUEUE?
	JN	D.CRAS			:CRASH,IF NOT

D.DQTF
	LHI	R1,NO			:CLEAR DEQUEUE_ALLOWED
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR FOR THIS SESSION
	JLE	D.DQT0			:CRASH,IF SCB_PTR NULL
:	CHECK THE QUEUE INFORMATION AND SET THE DQALLOW BIT VALUE
:	---------------------------------------------------------
	LHL	R6,SCBBLK+SCQTDG,R9,	:CHECK GET AND RELEASE PTR
:	CLH	R6,SCBBLK+SCQTDR,R9,	: (01/03/85 MIA)
	LHL	R0,SCBBLK+SCQTDR,R9,	:GET RL PTR (01/03/85 MIA)
	CR	R6,R0			:COMP THEM (01/03/85 MIA
	JE	D.DQT0			:JUMP,IF NO MU (ERROR?????)
	BBLOAD	R10,CMDBLK+CLARG,R6,	:R10 POINTS TO OFFSET OF MUCB
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK OFF OTHER BITYS FOR RRI
	JN	D.DQTE			:JUMP,IF RRI=RSP
	LB	R0,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH (6/26/84/CHS)
	NHI	R0,MU.BIU		:CHECK SEGMENT INDICATOR (6/26/84/CHS)
	JE	D.DQTE			:IF NOT BBIU, DEQUE (6/26/84/CHS)
:	IF FIRST_ENTRY(SCB.Q_TC_TO_DFC)->RRI<>RSP
:	-----------------------------------------
D.DQT7
	LB	R0,SCBBLK+SCSRMD,R9,	:GET BYTE 7 OF BIND
	NHI	R0,SC.SRM		:MASK OFF OTHER BITS FOR SEND_RCV_MODE
	CLHI	R0,FULLDX		:IS IT FULL_DUPLEX?
	JE	D.DQTE			:JUMP,IF SCB.SEND_RCV_MODE=FULL_DUPLEX
:	IF SCB.SEND_RCV_MODE<>FULL_DUPLEX AND RRI<>RSP
:	----------------------------------------------
D.DQT8
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAMETERS
	NHI	R0,SC.UBK		:MASK OFF OTHER BITS FOR USING_BRACKETS
	JE	D.DQT3			:JUMP,IF USING_BRACKETS<>YES
:	IF SCB.USING_BRACKETS=YES
:	--------------------------
	LB	R0,SCBBLK+SCMSSP,R9,	:GET DFC_MISC_SESSION_PARAMETERS
	NHI	R0,SC.1SP		:MASK OFF OTHER BITS FOR FIRST_SPEAKER
	JN	D.DQTE			:JUMP,IF FIRST_SPEAKER=YES
:	IF SCB.FIRST_SPEAKER<>YES,DO FSM HANDLE
:	--------------------------------------------
D.DQT9
:	IF #FSM_HDX=(*S,R) THEN DO
	LB	R3,SCBBLK+SCFHDX,R9,	:GET INDEX OF #FSM_HDX
	LB	R2,SCBBLK+SCSTAT,R3,R9	:GET FSM CURRENT STATE
	CLHI	R2,FS.ST2		:IS IT (S,<>R)
	JE	D.DQT2			:JUMP,IF YES
	CLHI	R2,FS.ST4		:IS IT (S,<>R)
	JE	D.DQT2			:JUMP,IF YES
	LHI	R3,FSCQCS		:GET INDEX OF FSM_QRI_CHECK_SEND
	LB	R2,SCBBLK+SCSTAT,R3,R9	:GET FSM CURRENT STATE
	CLHI	R2,FS.ST1		:IS IT RESET STATE?
	JN	D.DQTE			:JUMP,IF IT IS NOT RESET STATE
	LHI	R3,FSCBBI		:GET INDEX OF FSM_BSM_BIDDER
	LB	R2,SCBBLK+SCSTAT,R3,R9	:GET FSM CURRENT STATE
	CLHI	R2,FS.ST4		:IS IT PEND_INB?
	JE	D.DQT2			:JUMP,IF IT IS PEND_INB STATE
	LHL	R7,SCBBLK+SCTSNG,R9,	:GET CT_SEND_RQ_NORM GET PTR
:	CLH	R7,SCBBLK+SCTSNR,R9,	:COMP TO RL PTR (01/03/85 MIA)
	LHL	R0,SCBBLK+SCTSNR,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R7,R0			:COMP POINTERS (01/03/85 MIA)
	JE	D.DQTE			:JUMP,IF CT_SEND_RQ_NORM EMPTY
D.DQTB
:	LH	R6,CMDBLK+CLPTR,R7,	:GET NEXT PTR (01/03/85 MIA)
:	CLH	R6,SCBBLK+SCTSNR,R9,	:LAST ENTRY? (01/03/85 MIA)
	LHL	R6,CMDBLK+CLPTR,R7,	:GET NEXT PTR (01/03/85 MIA)
	LHL	R0,SCBBLK+SCTSNR,R9,	:GET RL PTR (01/03/85 MIA)
	CR	R6,R0			:COMP POINTERS (01/03/85 MIA)
	JE	D.DQTA			:YES,JUMP TO GET LAST_ENTRY
	LR	R7,R6			:CONTINUE
	J	D.DQTB
D.DQTA
	BBLOAD	R3,CMDBLK+CLARG,R7,	:GET CT PTR
	LB	R0,BBUFER+CLARG4,R3,	:GET CT_DFC_RQ_CODE
	CLHI	R0,BID			:IS IT BID?
	JE	D.DQT2			:JUMP,IF YES
	J	D.DQTE			:JUMP TO SET DEQUEUE_ALLOWED YES
:	IF SCB.USING_BRACKETS<>YES
:	--------------------------
D.DQT3
	LB	R0,SCBBLK+SCSRMD,R9,	:GET BYTE 7 OF BIND
	NHI	R0,SC.SRM		:MASK OFF OTHER BITS FOR SEND_RCV_MODE
	CLHI	R0,HDXCON		:IS IT HDX_CONTENTION?
	JE	D.DQT4			:JUMP,IF YES
:	IF SCB.SEND_RCV_MODE<>HDX_CONTENTION,HANDLE
:	------------------------------------------------
:	IF FSM_HDX_FF=(*S,R) THEN SET TO YES
	LHI	R3,FSCHFF		:GET INDEX OF FSM_HDX_FF
	LB	R2,SCBBLK+SCSTAT,R3,R9	:GET FSM CURRENT STATE
	CLHI	R2,FS.ST2		:IS IT (S,<>R)
	JE	D.DQT2			:JUMP,IF YES
	CLHI	R2,FS.ST4		:IS IT (S,<>R)
	JE	D.DQT2			:JUMP,IF YES
	J	D.DQTE			:JUMP TO SET DEQUEUE_ALLOWED YES
:	IF SCB.SEND_RCV_MODE=HDX_CONTENTION,HANDLE
:	------------------------------------------------
D.DQT4
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION TYPE
	NHI	R0,SC.SES		:MASK OFF OTHER BITS
	JN	D.DQT5			:JUMP,IF IT IS PRIMARY
	LB	R0,SCBBLK+SCSRMD,R9,	:GET BYTE 7 OF BIND
	NHI	R0,SC.CWN		:MASK FOR SCB.CONT_WIN
	JN	D.DQT6			:JUMP,IF IT IS NOT SECONDARY
	J	D.DQTE			:JUMP TO SET DEQUEUE_ALLOWED YES
D.DQT5
	LB	R0,SCBBLK+SCSRMD,R9,	:GET BYTE 7 OF BIND
	NHI	R0,SC.CWN		:MASK FOR SCB.CONT_WIN
	JN	D.DQTE			:JUMP,IF IT IS PRIMARY
:	IF NOT (HALF_SESSION=PRI&CONT_WIN=PRI | HALF_SESSION=SEC&
:	CONT_WIN=SEC)
:	------------------------------------------------------------
:	IF FSM_HDX_CONT_LOSER=(*S,R)
D.DQT6
	LHI	R3,FSCHCL		:GET INDEX_CONT_LOSER
	LB	R2,SCBBLK+SCSTAT,R3,R9	:GET FSM CURRENT STATE
	CLHI	R2,FS.ST2		:IS IT STATE 2? (S,<>R)
	JE	D.DQT2			:JUMP,IF FSM_HDX_CONT_LOSER<>(*S,R)
D.DQTE
	LHI	R1,YES			:SET DEQUEUE_ALLOWED TO YES
	J	D.DQT2

:	CHECK DEQUEUE IS ALLOWED OR NOT
:	-------------------------------
D.DQT2
	LR	R1,R1			:GET DEQUEUE_ALLOWED CONTAINT
	JE	D.DQT1			:JUMP,IF NOT SET (NOT YES TO DEQUEUE)
:	REMOVE MU FROM SCB.Q_TC_TO_DFC
	LHL	R6,SCBBLK+SCQTDG,R9,	:CHECK GET AND RELEASE PTR
:	CLH	R6,SCBBLK+SCQTDR,R9,	: (01/03/85 MIA)
	LHL	R0,SCBBLK+SCQTDR,R9,	:GET REL PTR (01/03/85 MIA)
	CR	R6,R0			:COMP POINTERS (01/03/85 MIA)
	JE	D.DQT0			:JUMP,IF NO MU (ERROR?????)
	BBLOAD	R10,CMDBLK+CLARG,R6,	:R10 POINTS TO OFFSET OF MUCB
:	LH	R7,CMDBLK+CLPTR,R6,	:CHECK NEXT CMDLST (03/15/85 MIA)
	LHL	R7,CMDBLK+CLPTR,R6,	:CHECK NEXT CMDLST (03/15/85 MIA)
	JE	CLERR,,			:CRASH,WHEN ADVANCING AN EMPTY LIST
	STH	R7,SCBBLK+SCQTDG,R9,
	CR	R7,R0			:LAST IN QUEUE? (03/15/85 MIA)
	JNFS	D.DQTG			:JUMP IF NOT (03/15/85 MIA)
	LB	R4,SCBBLK+SCBREL,R9,	:GET SCB REL # (03/15/85 MIA)
	RBT	R4,NCBBLK+NDQTDF,R13,	:RESET DATA PRESENT (03/15/85 MIA)
D.DQTG	JAL	R4,RELCL,,		:RELEASE CURRENT CMDLST
	LHI	R2,DFCRCV		:GET 'DFC.RCV' PROC. #
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,DQTCDC		:DEQUEUE.Q_TC_TO_DFC IS SENDING PROC.
	JAL	R13,D.RSEN,,		:CALL COMMON 'SEND' STATEMENT
D.DQT1
	JR	R14			:RETURN TO CALLING PROCEDURE
D.DQT0
	J	D.CRA1			:CRASH,IF NO ENTRY AVAILABLE

	SUBTTL	DATA FLOW CONTROL LAYER -- RECEIVING LOGIC

:	D.FCRV	-(DFC.RCV) TO ENFORCE THE PROPER DATA FLOW CONTROL 
:	PROTOCOLS FOR RECEIVED REQUESTS AND RESPONSES.
:	PAGE 5-50 ON FAPL
:	---------------------------------------------------------
:	THE USAGE OF THE REGISTERS ARE ---
:	INPUT	:R5 (ADDRESS OF THIS ROUTINE) R13 (NCB OF THE NODE)
:	OUTPUT	:
:	LINK	:R14
:	WORKING	:R10 (ASSIGNED FOR MU PTR)
D.FCRV
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.UNB		:IS IT UNBIND REQUEST?
	JER	R14			:IS IT UNBIND SIGNAL RSP,RETURN
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	D.CRAS			:CRASH,IF NOT NO_SIGNAL
D.FCR7
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR FOR THIS SESSION
	JLE	D.CRAS			:CRASH,IF SCB_PTR NULL
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS IT VALID BUFFER PTR?
	JN	D.CRAS			:CRASH,IF NOT
	LHI	R15,FCPSRV		:SET TO SPS.RCV FOR DESTINATION
	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	D.FCR8			:JUMP,BY PASS IF NOT 1ST SEG
:	LB	R4,BBUFER+MURHF1,R10,	:GET MURHF1
:	NHI	R4,MU.CTG		:MASK OFF OTHER BITS FOR RU_CTG
:	CLHI	R4,MU.FMD		:IS RU_CTGY=FMD?
:	JEFS	D.FCR3			:JUMP,IF RU_CTGY=FMD
	LB	R4,SCBBLK+SCSSTY,R9,	:GET SCB.TYPE_OF_SESSION
	CLHI	R4,LULU			:IS THIS SESSION LU-LU?
	JEFS	D.FCR3			:JUMP,IF YES
	LHI	R15,FCNSRV		:SET DESTINATION PROC. TO SNS.RCV
D.FCR3
	JAL	R8,D.RFMT,,		:CALL RCV_FORMAT TO FORMAT INPUT
	JAL	R8,D.RTIN,,		:CALL RCV_CT_INITIALIZE
	JAL	R8,D.RVCK,,		:CALL RCV_CHECKS
	IF	IG2RSP
:	J	D.FCR1			:(08/05/86/CHS)
	J	D.FCR4			:TO D.FCR4 AND CONTINUE(08/05/86/CHS)
	ELSE
	J	D.FCR0			:NORMAL RETURN IF NOT OK
	EI
:	RCV_CHECKS=OK
:	-------------
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	LR	R1,R0
	NHI	R0,MU.ECI		:MASK OUT OTHER BITS FOR ECI
	JNFS	D.FCR5			:JUMP,IF ECI=EC
	NHI	R1,MU.BCI		:MASK OUT OTHER BITS FOR BCI
	JEFS	D.FCR4			:JUMP,IF BCI<>BC
D.FCR5
	JAL	R8,D.RFSM,,		:CALL RCV_FSM,IF BCI=BC | ECI=EC
D.FCR4
	JAL	R8,D.RTCL,,		:CLEAN UP CORRELATION TABLE
	JAL	R8,D.RDCK,,		:DISCARD CHECK
	J	D.FCR1			:JUMP,IF NOT DISCARD
:	IF BETWEEN_BRACKETS_CONDITION=YES,SEND 'BETB' TO FMD.RCV
:	JAL	R8,D.BBCN,,		:CALL BETWEEN_BRACKETS_CONDITION
:	LR	R0,R0			:CHECK THE RETURN CODE 
:	JE	D.FCR2			:JUMP,BETWEEN_BRACKETS_CONDITION<>YES
:	LR	R2,R15			:GET DEST. PROCEDURE
:	LHI	R0,SG.BTB		:SET 'BETB' SIGNAL
:	LHI	R1,DFCRCV		:DFC.RCV  IS SENDING PROCEDURE
:	JAL	R13,D.GSEN,,		:CALL SEND SIGNAL ROUTINE
:	DISCARD MU
:	-------------------
D.FCR2
	JAL	R8,R.DSMU,,		:DISCRAD MU
	JR	R14			:RETURN
D.FCR1
:	SEND MU TO FMD.RCV
:	--------------------
	LR	R2,R15			:GET DESTINATION PROCE.
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,DFCRCV		:DFC.RCVD IS SENDING PROCEDURE
	JAL	R13,D.RSEN,,		:CALL COMMON 'SEND' STATEMENT
:	IF BETWEEN_BRACKETS_CONDITION=YES,SEND 'BETB' TO FMD.RCV
:	JAL	R8,D.BBCN,,		:CALL BETWEEN_BRACKETS_CONDITION
:	LR	R0,R0			:CHECK THE RETURN CODE 
:	JER	R14			:RETURN,BETWEEN_BRACKETS_CONDITION<>YES
:	LR	R2,R15			:GET DESTIN. PROC
:	LHI	R0,SG.BTB		:SET 'BETB' SIGNAL
:	LHI	R1,DFCRCV		:DFC.RCV  IS SENDING PROCEDURE
:	JAL	R13,D.GSEN,,		:CALL SEND SIGNAL ROUTINE
	JR	R14			:RETURN

:	PRE_PROCESSING FOR THE MIDDLE,LAST SEGMENTS
:	-------------------------------------------
D.FCR8
	LR	R2,R15			:GET DESTINATION PROCE.
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,DFCRCV		:DFC.RCVD IS SENDING PROCEDURE
	JAL	R13,D.RSEN,,		:CALL COMMON 'SEND' STATEMENT
	JR	R14			:RETURN

:	RCV_CHECKS<>OK CALL UPM_RECEIVE_CHECKS_PROCESS
:	----------------------------------------------------
D.FCR0
	LHI	R1,DFCRCV		:SET SENDING PROCESS
	JAL	R4,U.RCKP,,		:CALL UPM_RECEIVE_CHECKS_PROCESS
	JR	R14			:RETURN

:	D.GSEN	-DFC SEND COMMON ROUTINE (RECEIVING) FOR SIGNAL
:	------------------------------------------------------
:	INPUT	-R9 (SCB_PTR) R10 (MUCB_PTR)
:		 R0,R1,R2 (PARAMETERS FOR SEND ROUTINE)
:	LINK	-R13
D.GSEN
	JAL	R4,GBB,,		:CREATE NEW DQE (R3 IS NEW DQE)
	J	D.CRA1			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	ST	R9,BBUFER+DQSCB,R3,	:SETUP SCB_PTR
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQMUPR,R3,	:SET MU PTR TO THE CURRENT MU
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	STH	R7,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO NULL
	STB	R7,BBUFER+DQNWCM,R3,	:SET DQNWCM TO 'NULL'
	JAL	R8,SEND,,		:JUMP TO EXECUTE 'SEND' STATEMENT
	JR	R13			:RETURN

:	D.RSEN	-DFC SEND COMMON ROUTINE (RECEIVING)
:	--------------------------------
:	INPUT	-R9 (SCB_PTR) R10 (MUCB_PTR)
:		 R0,R1,R2 (PARAMETERS FOR SEND ROUTINE)
:	LINK	-R13
D.RSEN
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	D.CRA1			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	ST	R9,BBUFER+DQSCB,R3,	:SETUP SCB_PTR
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO -1
	STH	R7,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO 'NULL'
	STB	R7,BBUFER+DQNWCM,R3,	:SET DQNWCM TO 'NULL'
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	JR	R13			:RETURN

	SUBTTL	DATA FLOW CONTROL LAYER -- SENDING LOGIC

:	D.FCSD	-(DFC.SEND) TO ENFORCE THE PROPER DATA FLOW CONTROL 
:	PROTOCOLS FOR SENDING REQUESTS AND RESPONSES.
:	PAGE 5-41 ON FAPL
:	---------------------------------------------------------
:	THE USAGE OF THE REGISTERS ARE ---
:	INPUT	:R5 (ADDRESS OF THIS ROUTINE) R13 (NCB OF THE NODE)
:		:R12(PTR TO CURRENT EV)
:	OUTPUT	:
:	LINK	:R14
:	WORKING	:R10 (ASSIGNED FOR MU PTR)
D.FCSD
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	D.CRAS			:CRASH,IF NOT

D.FCS4
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR FOR THIS SESSION
	JLE	D.CRAS			:CRASH,IF SCB_PTR NULL
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS IT VALID BUFFER PTR?
	JN	D.CRAS			:CRASH,IF NOT
	LB	R0,BBUFER+MUSCHK,R10,	:GET SEND_CHECK_SENSE BIT
	JN	D.CRAS			:CRASH,IF SEND_CHECK_SENSE SET
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR
	LB	R1,BBUFER+MUBIUF,R10,	:SET UP TH.DAF CONTAINTS
	NHI	R1,MU.BIU		:CHECK THE BBIU INDICATOR
	JE	D.FCS8			:JUMP,BY PASS IF NOT 1ST SEG
	JAL	R8,T.CSCK,,		:CALL TC.CPMGR.SEND_CHECKS
	J	D.FCS9			:JUMP,IF NO GOOD
	JAL	R8,D.SNCK,,		:CALL DFC.SEND_CHECKS
	IF	IG2RSP
	J	D.FCS3
	ELSE
	J	D.FCS9			:JUMP,IF NO GOOD
	EI
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,MU.RRI		:MASK OFF OTHER BITS
	JN	D.FCS7			:JUMP,IF IT IS 1 (RSP)
:	MODIFICATION FOR FAPL:: NOTIFY SVC.MGR AT ANYCASE
:	-------------------------------------------------
:	IF RRI=RQ THEN CALL SEND_SNF_ASSIGN
	JAL	R8,D.SSNA,,		:CALL SEND_SNF_ASSIGN
:	SEND MU (WITH SEND_CHECK_SENSE BIT OFF) TO SENDING_PROCEDURE
:	---------------------------------------
D.FCS7
	LIS	R0,0
	STB	R0,BBUFER+MUSCHK,R10,	:SET SEND_CHECK_SENSE BIT
:	LB	R2,EVBLK+EVSPRO,R12,	:GET SEND_PROCEDURE(9/18/84/CHS)
:	LHI	R1,DFCSND		:DFC.SEND IS SENDING PROCEDURE(9/18/84/CHS)
:	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL(9/18/84/CHS)
:	JAL	R8,D.FSEN,,		:CALL SEND COMMON ROUTINE(9/18/48/CHS)
D.FCS0
	JAL	R8,D.STIN,,		:CALL SEND_CT_INITIALIZE
	JAL	R8,D.SDCK,,		:DISCARD CHECK
	J	D.FCS1			:JUMP,IF NOT DISCARD
:	DISCARD MU
	JAL	R8,R.DSM1,,		:DISCRAD RU PTR IN MUCB,NOT MUCB PTR
	JAL	R8,D.STCL,,		:CALL SEND_CT_CLEANUP
:	J	D.FCSY			:TO INFORM LUSEND (10/6/84 MIA)
	LB	R2,EVBLK+EVSPRO,R12,	:GET SENDING PROCEDURE (10/6/84 MIA)
					:(1.F07/06/04/87/DB/START)
:	LU SVC ONLY DISCARDS MUCB FOR LUSEND. FOR OTHER SENDING PROCEDURES
:	THE MUCB IS DISCARDED HERE AND LU SVC IS NOT INFORMED.
:	J	D.FCSZ			:JUMP TO INFORM LU SVC (10/6/84 MIA)
	CLHI	R2,LUSEND		:SENDING PROCEDURE = LUSEND?
	JE	D.FCSZ			:YES,INFORM LU SVC 
	LR	R3,R10			:NO
	JAL	R4,PBB,,		:DISCARD MUCB
	JAL	R4,R.PBB,,		:ADJUST BUFFER QUOTAS
	JR	R14			:RETURN
					:(1.F07/06/04/87/DB/END)

D.FCS1
	JAL	R8,D.SFSM,,		:CALL SEND_FSMS
:	SEND MU TO CPMGR.SEND
:	IF BETWEEN_BRACKETS_CONDITION=YES,SEND 'BETB' TO SENDING_PROCEDURE
	LHI	R2,TCCMSD		:GET 'CPMGR.SEND' PROC. #
	LHI	R1,DFCSND		:DFC.SEND IS SENDING PROCEDURE
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R8,D.FSEN,,		:CALL COMMON 'SEND' STATEMENT
:	JAL	R8,D.BBCN,,		:CALL BETWEEN_BRACKETS_CONDITION
:	LR	R0,R0			:CHECK THE RETURN CODE 
:	JE	D.FCS2			:JUMP,BETWEEN_BRACKETS_CONDITION<>YES
:	LHI	R1,DFCSND		:DFC.SEND IS SENDING PROCEDURE
:	LB	R2,EVBLK+EVSPRO,R12,	:GET SEND_PROCEDURE
:	LHI	R0,SG.BTB		:SET 'BETB' SIGNAL
:	JAL	R13,D.GSEN,,		:CALL SEND SIGNAL ROUTINE
D.FCS2
	JAL	R8,D.STCL,,		:CLEAN UP CORRELATION TABLE

:	(9/18/84/CHS)	GENERATE MUCB - LUSEND NEEDS IT
D.FCSX
	LB	R2,EVBLK+EVSPRO,R12,	:IF NO LUSEND, RETURN
	CLHI	R2,LUSEND
	JNR	R14
	JAL	R4,GBB,,		:CREATE NEW MUCB IN R3
	J	D.CRAS			:CRASH, IF NO BUFFER AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LB	R4,BBUFER+MUDADP,R10,	:COPY MUDADP FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MUDADP,R3,	:
	LB	R4,BBUFER+MUOADP,R10,	:COPY MUOADP FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MUOADP,R3,	:
	LB	R4,BBUFER+MURHF1,R10,	:COPY MURHF1 FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MURHF1,R3,	:
	LB	R4,BBUFER+MURHF2,R10,	:COPY MURHF2 FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MURHF2,R3,	:
	LB	R4,BBUFER+MURHF3,R10,	:COPY MURHF3 FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MURHF3,R3,	:
	LB	R4,BBUFER+MUBIUF,R10,	:COPY MUBIUF FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MUBIUF,R3,	:
	LR	R10,R3			:R10 = NEW MUCB
D.FCSY
	LHI	R2,LUSEND		:SET UP R2 AGAIN
D.FCSZ					:(10/6/84 MAI)
	LIS	R0,0
	STB	R0,BBUFER+MUSCHK,R10,	:SET SEND_CHECK_SENSE BIT
	LHI	R1,DFCSND		:DFC.SEND IS SENDING PROCEDURE
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R8,D.FSEN,,		:CALL SEND COMMON ROUTINE
:	(9/18/84/CHS)	END OF GENERATION MUCB INSERTION
	JR	R14			:RETURN

:	CHECK BAD SEND IS 2ND RSP TYPE OR NOT
:	---------------
D.FCS3
	LR	R0,R0
	JE	D.FCS9			:NOT RSP ERROR
	JAL	R8,D.STIN,,		:CALL SEND-CT-INITIALIZE(08/05/86/CHS)
	JAL	R8,D.STCL,,		:CLEAN UP CORR TABLE(08/05/86/CHS)
	LIS	R0,0
	STB	R0,BBUFER+MUSCHK,R10,	:SET SEND_CHECK_SENSE BIT
:	LB	R2,EVBLK+EVSPRO,R12,	:GET SEND_PROCEDURE(9/20/84/CHS)
:	LHI	R1,DFCSND		:DFC.SEND IS SENDING PROCEDURE(9/20/84/CHS)
:	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL(9/20/84/CHS)
:	JAL	R8,D.FSEN,,		:CALL SEND COMMON ROUTINE(9/20/84/CHS)
	LHI	R2,TCCMSD		:GET 'CPMGR.SEND' PROC. #
	LHI	R1,DFCSND		:DFC.SEND IS SENDING PROCEDURE
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R8,D.FSEN,,		:CALL COMMON 'SEND' STATEMENT
:	JR	R14			:RETURN(9/20/84/CHS)
	J	D.FCSX			:TO NOTIFY LUSEND, IF NECESSARY

:	PRE_PROCESSING FOR THE MIDDLE,LAST SEGMENTS
:	-------------------------------------------
D.FCS8
	LHI	R2,TCCMSD		:GET 'CPMGR.SEND' PROC. #
	LHI	R1,DFCSND		:DFC.SEND IS SENDING PROCEDURE
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R8,D.FSEN,,		:CALL COMMON 'SEND' STATEMENT
	JR	R14			:RETURN

:	TC.CPMGR.SEND_CHECKS=NG | DFC.SEND_CHECKS=NG
:	--------------------------------------------
D.FCS9
	JAL	R8,D.STIN,,		:CALL SEND-CT-INITIALIZE(08/05/86/CHS)
	JAL	R8,D.STCL,,		:CLEAN UP CORR TABLE(08/05/86/CHS)
	LIS	R0,1
	STB	R0,BBUFER+MUSCHK,R10,	:SET SEND_CHECK_SENSE BIT
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,DFCSND		:GET SENDING PROCEDURE #
	LB	R2,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	JAL	R8,D.FSEN,,		:CALL COMMON 'SEND' STATEMENT
	JR	R14			:RETURN

:	D.FSEN	-DFC SEND COMMON ROUTINE (SENDING)
:	--------------------------------
:	INPUT	-R9 (SCB_PTR) R10 (MUCB_PTR) R15 (LUCB_PTR)
:		 R0,R1,R2 (PARAMETERS FOR SEND ROUTINE)
:	LINK	-R8
D.FSEN
	ST	R8,RGSAV8,,		:SAVE RETURN ADDRESS
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	D.CRA1			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	STH	R15,BBUFER+DQLUCB,R3,	:STORE LUCB PTR
	ST	R9,BBUFER+DQSCB,R3,	:SETUP SCB_PTR
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	STB	R7,BBUFER+DQNWCM,R3,	:SET DQNWCM TO 'NULL'
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	L	R8,RGSAV8,,		:GET RETURN ADDRESS BACK
	JR	R8			:RETURN

D.CRAS
	JAL	R10,CRASH,,
	BC	0,0,0,CRQDFC

D.CRA1
	J	NOENT5,,

	FO	CBKDEF
	FO	CMDLST
	FO	MAIN

	EM
 
	SUBTTL	SNA PACKAGE(MAIN PROCESSES) - FMD LAYER
:	MODULE NAME IN COMMAND FILE -- SFCC03.F00

:***************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:******************************************************


:-----------------------------------------------------------------
:	THIS PACKAGE IS DESIGNED TO SUPPORT FUNCTIONS OF SNA FMD LAYER.
:	THE FMD LAYER IS DIVIDED INTO TWO PARTS -- NETWORK SERVICE (NS)
:	AND PRESENTATION SERVICE (PS).
:-----------------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	MAIN
	LO	GBLDEF
	LO	CBKDEF
	LO	CMDLST
	SEG	A.CODE

:---------------------------------------------------------------------:
: FMD LAYER NETWORK SERVICE -- THE FOLLOWING CATEGORIES               :
: F.NSXX -- NETWORK SERVICE MAIN ROUTINES (SNS.RCV,SNS.SEND --        :
:           SSCP_SSCP,SSCP_LU,SSCP_PU AND PUCP_PU HALF-SESSIONS)      :
: F.CSXX -- NETWORK SERVICE CONFIGURATION SERVICES (IN SSCP.SVC_MGR)  :
: F.MSXX -- NETWORK SERVICE MAINTENANCE SERVICES (SNS.MN--SSCP_LU)    :
: F.NOXX -- NETWORK SERVICE NETWORK OPERATOR SERVICES                 :
: F.USXX -- NETWORK SERVICE MEASUREMENT SERVICES                      :
: F.GSXX -- NETWORK SERVICE MANAGEMENT SERVICES (SNS.MA --SSCP_LU AND :
:           SSCP_PU HALF-SESSIONS)                                    :
:---------------------------------------------------------------------:
	SEG	A.DATA
NFYPOF	HS	(MAXLUN+$A15)/$A16	:NOTIFY POWER OFF BIT ARRAY
LUPOFF	HS	(MAXLUN+$A15)/$A16	:ACTLU LONG FORM POWER OFF BIT ARRAY
	SEG	A.CODE

:	F.NSRV	-(SNS.RCV) ROUTE CURRENT NS RQ OR RSP TO CORRECT NETWORK
:	SERVICE PROCEDURE.
:	NOTE --
:	(1)SSCP-LU,SEND DATA TO SNS.MN.RCV,SNS.MA.RCV,SNS.SS.RCV
:	(2)SSCP-PU,SEND DATA TO PU.SVC_MGR.NS.RCV,SSCP.SVC_MGR.CS.RCV
:	   AND SNS.MA.RCV
:	(3)SSCP-SSCP,SEND DATA TO SNS.SS.RCV
:	PAGE 6-16 ON FAPL
:	--------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-R9 (SCB_PTR)
:
F.NSRV	LHL	R13,NCBPTR,RNODE,RNODE	:GET NODE CONTROL BLOCK PTR
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB_PTR FROM NODE TABLE
	JLE	F.CRA1			:CRASH,IF SCB_PTR NULL
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU_PTR FROM EV
	THI	R10,BUFFLG		:IS IT VALID BUFFER?
	JN	F.CRA1			:CRASH,IF NOT
:FIND LUCB POINTER (01/23/87 MIA)
	LB	R3,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R3,PU.T4		:TYPE 4?
	JNFS	F.NSRY			:JUMP IF NOT
	LB	R3,BBUFER+MUOADP,R10,	:LUCB INDEXED BY ORIGIN LU#
	JFS	F.NSRZ			:JUMP TO CONTINUE
F.NSRY	LB	R3,BBUFER+MUDADP,R10,	:LUCB INDEXED BY DEST LU#
F.NSRZ	LHL	R15,PUCPTR,RNODE,RNODE	:GET PUC POINTER
	LHL	R15,PUCTAB+PUCLUC,R15,	:GET POINTER TO 1ST LUCB FOR PU
	AH	R3,LUCTAB+LUCT.D,R15,	:GET REL# OF LU
	LHL	R15,LUCPTR,R3,R3	:GET LUCB POINTER
:END OF INSERTION (01/23/87 MIA)
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU_PTR FROM MUCB
	LB	R0,BBUFER+1,R3,		:NS FIELD_FORMATTED HEADER (2ND BYTE)
	LB	R1,BBUFER+MURHF1,R10,	:GET MURHF1 (4/24/85/CHS)
	THI	R1,MU.SDI		:SENSE CODE INCLUDED? (4/24/85/CHS)
	JEFS	F.NSRX			:NO, SKIP (4/24/85/CHS)
	LB	R0,BBUFER+5,R3,		:ELSE, NS HEADER 4-BYTE OFF(4/24/85/CHS)
F.NSRX					:(4/24/85/CHS)
	NHI	R0,@NSH180		:MASK OFF THE 1ST BIT
	LB	R1,SCBBLK+SCSSTY,R9,	:GET SESSION TYPE
	LHL	R5,F.NSR0,R1,R1		:GET ENTRY PTR
	J	F.NSR0,R5,

F.NSR0	HS	0
	HC	F.NSR1-F.NSR0		:FOR SSCP-PU (TYPE=0)
	HC	F.NSR2-F.NSR0		:FOR SSCP-LU (TYPE=1)
	HC	F.NSR3-F.NSR0		:FOR SSCP-SSCP (TYPE=2)
	HC	F.NSR4-F.NSR0		:FOR ERROR SESSION TYPE

:	====================
:	SSCP-PU TYPE
:	=========================
F.NSR1
	CLHI	R0,NSCFSV		:IS NS_CATEGORY=CONFIGURATION_SERVICE?
	JE	F.NSR6			:JUMP,IF YES
	CLHI	R0,NSMTSV		:IS NS_CATEGORY=MAINTENANCE_SERVICE?
	JE	F.NSRA			:JUMP,IF YES
	J	F.NSR5			:JUMP,ERROR NS_CATEGORY
:	SSCP_PU -- NS_CATEGORY(1:7)=CONFIGURATION_SERVICE
:	-----------------------------------------------
F.NSR6
:	======================
:	SSCP-LU TYPE
:	==================
F.NSR2
	LB	R2,BBUFER+MURHF1,R10,	:GET MURHF1
	THI	R2,MU.FI		:IS FI BIT SET?
	JE	F.NSR9			:JUMP,IF FI<>NSH
	THI	R2,MU.RRI		:SEE IF A RSP(4/23/85/CHS)
	JN	F.NSR9			:RSP, PASS TO LU.SVC(4/23/85/CHS)
:	J	F.CRA2			:ELSE, FUNCTION NOT SUPPORTED(4/23/85/CHS)
	NHI	R2,MU.CTG		:CHECK RU_CTGY
	CLHI	R2,MU.FMD		:IS IT FMD?
	JN	F.NSR9			:JUMP,IF NOT
	CLHI	R0,NSMTSV		:IS NS_CATEGORY=MAINTENANCE_SERVICE?
	JE	F.NSR7			:JUMP,IF YES
	CLHI	R0,NSSESV		:IS NS_CATEGORY=SESSION_SERVICE?
	JE	F.NSR8			:JUMP,IF YES
	CLHI	R0,NSMGSV		:IS NS_CATEGORY=MANAGEMENT_SERVICE?
	JE	F.NSRB			:JUMP,IF YES
	J	F.NSR5			:JUMP,NS_CATEGORY ERROR
:	FI<>NSH (SSCP_LU)
:	-----------------------
F.NSR9
	LHI	R2,FCPSRV		:SET DESTINATION PROCESS
	LHI	R1,FCNSRV		:SET SENDING PROCESS
	LHI	R0,SG.NOS		:SET INPUT SIGNAL
	JAL	R13,D.RSEN,,		:CALL SEND COMMON ROUTINE
	JR	R14			:RETURN

:	=====================
:	SSCP-SSCP TYPE
:	============================
F.NSR3
	CLHI	R0,NSSESV		:IS NS_CATEGORY=SESSION_SERVICE?
	JE	F.NSR8			:JUMP,IF YES
	J	F.NSR5			:NS_CATEGORY ERROR

:********************************************************
:	SEE FAPL CHAPTER-9 (NS.MANAGEMENT & MAINTENANCE SERVICE)
:********************************************************

:	SSCP_LU -- NS_CATEGORY(1:7)=MANAGEMENT_SERVICE
:	-------------------------------------------
F.NSRB
	J	F.CRA2			:CRASH FOR TESTING
	JR	R14			:RETURN FROM MANAGEMENT SERVICE

:	SSCP_LU -- NS_CATEGORY(1:7)=MAINTENANCE_SERVICE
:	----------------------------------------
F.NSR7
	J	F.CRA2			:CRASH FOR TESTING
	JR	R14			:RETURN FROM MAINTENANCE SERVICE

:	SSCP_PU -- NS_CATEGORY(1:7)=MAINTENANCE_SERVICE
:	-----------------------------------------------
F.NSRA
	J	F.CRA2			:CRASH FOR TESTING
	JR	R14			:RETURN

:********************************************************
:	SEE FAPL CHAPTER-8 (NS.SESSSION SERVICE)
:********************************************************
:	SSCP_LU -- NS_CATEGORY(1:7)=SESSION_SERVICE
:	SSCP_SSCP -- NS_CATEGORY(1:7)=SESSION_SERVICE
:	-------------------------------------------
:BEGIN	(09/05/86 YLH)
:	CURRENTLY SESSION SERVICE ONLY HANDLES SSCP->LU NOTIFY REQUEST
:
F.NSR8	LB	R0,BBUFER+2,R3,		:GET FMD NS REQUEST CODE
	CLHI	R0,NOTIFY		:REQUEST CODE=NOTIFY?
	JN	F.NSR9			:NO, SEND THIS REQUEST TO LU.SVC
	LB	R0,BBUFER+3,R3,		:YES, GET THE CONTROL VECTOR KEY
	CLHI	R0,0C			:ONLY VECTOR KEY '0C' IS SUPPORTED
	JN	F.CRA2			:CRASH, IF VECTOR KEY <> 0C
:
:	CHECK SLU CAPABILITIES
:
	LB	R0,BBUFER+5,R3,		:GET LU CAPABILITIES
	NHI	R0,03			:MASK FOR SLU CAPABILITIES
	CLHI	R0,01			:IF CAN NOT ACT AS SLU THEN
	JE	F.PWFF			:JUMP TO POWER OFF HANDLING ROUTINE
	CLHI	R0,03			:IF CAN NOW ACT AS SLU THEN
	JE	F.PWON			:JUMP TO POWER ON HANDLING ROUTINE
	J	F.CRA2
	GL	V.SNNW,S.PCR1,SLUSAV,V.CLEA
:
:	NOTIFY(POWER OFF)
:	THIS PIECE OF LOGIC IS ENTERED WHEN NOTIFY REQUEST WITH CAN NOT
:	ACT AS SLU IS RECEIVED.
:	SET POWER OFF INDICATOR IN NOTIFY POWER OFF BIT ARRAY AND RESPONSE.
:
F.PWFF	LHL	R0,LUCTAB+LUCT.N,R15,	:GET RELATIVE LU #
	SBT	R0,NFYPOF,,		:SET FLAG
	LHI	R0,0FF			:INIT SSCP_LU LINE #
	STB	R0,LUCTAB+LULUW3,R15,
	STM	R0,SLUSAV,,		:SAVE REGISTERS
	LR	R9,R15			:LET R9 HAS THE LUCB PTR
	JAL	R12,V.CLEA,,		:CLEAR LU_LU PARAMETERS
	LM	R0,SLUSAV,,		:RESTORE REGISTERS
	LIS	R0,NN.RES		:INIT STATE
	STB	R0,LUCTAB+LUSSTA,R15,
	LIS	R0,0			:CLEAR SSCP_LU SESSION
	BBSSCB	R0,LUCTAB+LUSSCB,R15,
	LHI	R0,TRUNCA		:TRUNCATE (02/05/87 YLH)
	JAL	R5,R.MUPR,,		:CREATE POSITIVE RESPONSE (02/05/87 YLH)		
	LHI	R0,SG.NOS		:SET INPUT SIGNAL
	LHI	R1,FCNSRV		:SET SENDING PROCESS ROUTINE
	LHI	R2,DFCSND		:SET DESTINATION PROCESS ROUTINE
	JAL	R13,D.RSEN,,		:CALL SEND COMMON ROUTINE
:
:	IF LU IS ACTIVATED THEN DECREMENT THE # OF ACTIVE LU IN THE PU
:	CONTROL BLOCK
:
	TBT	R0,LUPOFF,,		:IF RSP(ACTLU) LONG FORM WITH POWER
	JN	F.PWF1			:OFF INDICATOR STILL ON, THEN THIS
					:LU HAS NOT BEEN ACTIVATED YET
	LHL	R8,PUCPTR,RNODE,RNODE	:GET PUCB PTR
	LB	R0,PUCTAB+PUALUN,R8,	:GET # OF ACTIVE LU
	SIS 	R0,1			:AND DECREMENT IT
	STB	R0,PUCTAB+PUALUN,R8,
:
:	SEND CLOSE CMD WITH POWER OFF SUBCMD TO THE NIO
:
F.PWF1	LHI	R1,XCLOSE		:SET CMD
	LHI	R3,E.POFF		:SET POWER OFF SUBCMD
	LIS	R0,0
	JAL	R8,V.SNNW,,		:CALL ROUTINE TO SEND CMD
	JR	R14
:
:	NOTIFY WITH SLU CAN NOW ACT AS SLU -
:
F.PWON
:
:	IF THE NOTIFY(POWER OFF) OR RSP(ACTLU) WITH CAN NOT ACT AS SECONDARY 
:	LU HAS NOT BEEN FORMERLY RECEIVED THEN PASSES THE NOTIFY(POWER ON)
:	TO THE LU SERVICE MANAGER
:
	LHL	R0,LUCTAB+LUCT.N,R15,	:GET RELATIVE LU #
	RBT	R0,NFYPOF,,		:RESET THE NOTIFY(POWER OFF) FLAG
	JNFS	F.PWO1			:JUMP IF POWER WAS OFF
	RBT	R0,LUPOFF,,		:RESET THE RSP(ACTLU) LONG FORM POWER
					:OFF FLAG
	JE	F.NSR9			:PASS IT TO THE LU SERVICE MANAGER
:
:	RETURN A POSITIVE RESPONSE TO THE NOTIFY(POWER ON)
:
F.PWO1	RBT	R0,LUPOFF,,		:RESET RSP(ACTLU) FLAG
	LHI	R0,TRUNCA		:TRUNCATE (02/05/87 YLH)
	JAL	R5,R.MUPR,,		:CREATE POSITIVE RESPONSE (02/05/87 YLH)
	LHI	R0,SG.NOS		:SET INPUT SIGNAL
	LHI	R1,FCNSRV		:SET SENDING PROCESS ROUTINE
	LHI	R2,DFCSND		:SET DESTINATION PROCESS ROUTINE
	JAL	R13,D.RSEN,,		:CALL SEND COMMON ROUTINE
:
:	CONTINUE AS A POSITIVE RSP(ACTLU) IS RECEIVED
:
	LHL	R8,PUCPTR,RNODE,RNODE	:RESTORE PUC POINTER (02/05/87 YLH)
	LHI	R0,NN.ALU		:SET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	LB	R0,PUCTAB+PUALUN,R8,	:GET ACTIVE LU #
	BBSSCB	R9,LUCTAB+LUSSCB,R15,	:SET SCB PTR IN LUCB
	AIS	R0,1
	STB	R0,PUCTAB+PUALUN,R8,	:INCREASE ACTIVE LU #
	LHI	R3,E.POSR		:SET CMD LIST INF. FIELD
	LIS	R0,0
	LHI	R1,XINIT		:SET UP CMD TYP INIT RSP
	JAL	R8,V.SNNW,,
	JR	R14
:
:END (09/05/86 YLH)
:
:	NS_CATEGORY ERROR
:	----------------------
F.NSR5
:	ERROR SESSION TYPE
:	------------------
F.NSR4
	J	F.CRA2			:CRASH FOR TESTING
	JR	R14

:	F.NSSD	-(SNS.SEND) ROUTE CURRENT NETWORK SERVICES RQ OR RSP
:	TO DFC.SEND
:	PAGE 6-18 ON FAPL
:	--------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-
F.NSSD
	JR	R14

:---------------------------------------------------------------------:
: FMD LAYER PRESENTATION SERVICE -- CONTAINS THE FOLLOWING ROUTINES   :
: F.PSXX -- PRESENTATION SERVICE MAIN ROUTINES (SPS.RCV,SPS.SEND --   :
:           ONLY IN LU-LU HALF-SESSION)                               :
:---------------------------------------------------------------------:

:	F.PSRV	-(SPS.RCV) ROUTE CURRENT LU-LU RQ OR RSP TO NETWORK IO
:	PAGE (SEE LU-LU SESSION TYPE MANUAL)
:	NOTE -- THE FUNCTIONS OF THIS ROUTINE ARE AS FOLLOWS,
:	(1)SEND DATA INTO LU.SVC_MGR.PS,LU.SVC_MGR.SYNC_PT
:	(2)PERFORM USER LOGON PROCEDURES( NOT TYMNET LOGON PROCEDURES) SUCH
:	   AS 3270 SCREEN HANDLE,SCREEN DISPLAY
:	--------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-
:	THE SAME AS L.RCV (SEE SLMV00.F00)
F.PSRV
	JR	R14

:	F.PSSD	-(SPS.SEND) GET DATA FROM LU.SVC_MGR AND SEND DATA TO
:	LOWER LAYERS (DFC) TO PROCESS.
:	PAGE (SEE LU-LU SESSION TYPE MANUAL)
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-
:	THE SAME AS L.SEND (SEE SLMV00.F00)
F.PSSD
	JR	R14

F.CRA1
	JAL	R10,CRASH,,
	BC	0,0,0,CRQFMD
F.CRA2
:	LHI	R0,.RRFNS		:GET FUNCTION NOT SUPPORT
	LHI	R0,.RQEFN		:(3.F01/06/15/87/DB)
					:REQUEST REJECT CATEGORY
	JAL	R5,R.MUNR,,		:CALL CHANGE_MU_TO_NEG_RSP
	LHI	R2,DFCSND		:SET DESTINATION 
	LHI	R1,FCNSRV		:SET SENDING
	LHI	R0,SG.NOS
	JAL	R13,D.RSEN
	JR	R14			:RETURN
	JAL	R10,CRASH,,
	BC	0,0,0,CRQFMD

	FO	MAIN
	FO	GBLDEF
	FO	CBKDEF
	FO	CMDLST

	EM

  
	SUBTTL	SNA PACKAGE (UTILITY ROUTINES) - PU SERVICE MANAGER

:	***************************************
:	REVISION HISTORY --
:	01/18/84 (NCS) -- ORIGINAL DESIGN AND CODING
:	**************************************************

	RA	0
	MO	.,SNAPKG

	LO	CBKDEF
	LO	GBLDEF
	LO	CMDLST
	LO	MAIN

	SEG	A.DATA
SLUSAV	WS	10
SAVRG3	WS	1
SAVRG4	WS	1
SAVRG7	WS	1
SAVRG8	WS	1
	BND	2
TB.FMP	
	BC	PROF00,PROF02,PROF03,PROF04,PROF05,PROF06,PROF07,PROF17,PROF18
TB.FML	EQ	.-TB.FMP
	BND	2
TB.TSP	
	BC	PROF01,PROF02,PROF03,PROF04,PROF05,PROF07,PROF17
TB.TSL	EQ	.-TB.TSP

	SEG	A.CODE

:	THIS PACKAGE CONTAINS ROUTINES WHICH ARE USED TO SUPPORT 
:	PU.SVC_MGR FUNCTIONS.
:	------------------------------------------------------------

:*******************************************************************
:		UTILITY ROUTINES FOR NAU.SVC_MGR 
:*******************************************************************

:	V.RQCK	-(RQ_CHECKS) PAGE 13-48 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS-
:	INPUT	-R13 (NCB PTR) R9 (SCB PTR) R10 (MU PTR)
:	OUTPUT	-R2 CONTAINS YES,NO
:	LINK	-R8 (RETURN ADDRESS)
V.RQCK
	LR	R9,R9			:CHECK SCB_PTR NULL OR NOT
	JLE	V.RQC8			:JUMP,IF SCB_PTR=NULL
	JAL	R6,V.RQPR,,		:CHECK RQ_PARAMETER
	LR	R1,R1			:GET RETURN CODE FROM RQ_PARAMETER
	JE	V.RQC7			:JUMP,IF RQ_PARAMETER RETURN NG
	JAL	R6,V.TPSS,,		:CALL TYPE_SESSION
	LR	R2,R2			:CHECK RETURN CODE
	JE	V.RQC7			:JUMP,IF RETURN CODE 'NO'
:	CALL SEND_OR_RECEIVE_CHECK(#FSM_SESS),IF RETURN NO,RETURN OK
:	ELSE GOTO V.RQC5
:	--------------------------------
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	V.RQC5			:RETURN 'TRUE' FROM FSM
	LHI	R2,YES			:YES,SEND_OR_RECEIVE_CHECK(#FSM_SESS)
	JR	R8			:RETURN
V.RQC5
	LHI	R1,.RRMDI		:SET MODE INCONSISTENCY '8009'
	LHI	R2,NO			:SET RQ RETURN NO GOOD
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.RQC9			:JUMP,IF IT IS SEND
	STH	R1,BBUFER+MURHSN,R10,	:SET SNC TO '8009'
	JR	R8			:RETURN
V.RQC9
	ST	R1,BBUFER+MURCKS,R10,	:SET RECEIVE_CHECK_SENSE
	JR	R8			:RETURN
V.RQC7
	LHI	R2,NO			:RETURN NG
	JR	R8			:RETURN
:	SCB_PTR=NULL
:	--------------
V.RQC8
	JAL	R6,V.RQPR,,		:CHECK RQ_PARAMETER
	LR	R1,R1			:GET RETURN CODE FROM RQ_PARAMETER
	JE	V.RQC7			:JUMP,IF RQ_PARAMETER RETURN NG
:	CALL FUNCTION_SUPPORTED?????
:	----------------------------
:	CRASH,IF SCB_PTR=NULL
:	-----------------------
	LHI	R2,YES			:YES,SEND_OR_RECEIVE_CHECK(#FSM_SESS)
	JR	R8			:RETURN

:	V.RSCK	-(RSP_CHECKS) PAGE 13-49 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS-
:	INPUT	-R13 (NCB PTR) R9 (SCB PTR) R10 (MU PTR)
:	OUTPUT	-R2 CONTAINS YES,NO
:	LINK	-R8 (RETURN ADDRESS)
V.RSCK
	ST	R8,SAVRG8,,
	LR	R9,R9			:CHECK SCB_PTR NULL OR NOT
	JLE	V.RSC8			:JUMP,IF SCB_PTR=NULL
	JAL	R6,V.RSPR,,		:CHECK RSP_PARAMETER
	LR	R1,R1			:GET RETURN CODE FROM RSP_PARAMETER
	JE	V.RSC7			:JUMP,IF RSP_PARAMETER RETURN NG
	JAL	R6,V.TPSS,,		:CALL TYPE_SESSION
	LR	R2,R2			:CHECK RETURN CODE
	JE	V.RSC7			:JUMP,IF RETURN CODE 'NO'
:	SEND_OR_RECEIVE_CHECK(#FSM_SESS)
:	--------------------------------
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.FNC		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	THI	R6,TRUE			:CHECK OUTPUT FROM FSM
	JN	V.RSC5			:RETURN 'TRUE' FROM FSM
	LHI	R2,YES			:YES,SEND_OR_RECEIVE_CHECK(#FSM_SESS)
	J	V.RSC1
V.RSC5
:	LHI	R1,.RRMDI		:SET MODE INCONSISTENCY '8009'(5/20/86/CHS)
	LHI	R1,.MODCN		:SET MODE INCONSISTENCY '0809'(5/20/86/CHS)
	J	V.RSC6			:JUMP TO SET CHECK SENSE
V.RSC7
	LHI	R2,NO			:RETURN NG
	J	V.RSC1
V.RSC8
:	LHI	R1,.RRSLE		:SET SESSION LIMIT EXCEED '8005'(5/20/86/CHS)
	LHI	R1,.NOSES		:SET TO NO SESSION '8005'(5/20/86/CHS)
V.RSC6
	LHI	R2,NO			:SET RSP RETURN NO GOOD
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.RSC9			:JUMP,IF IT IS SEND
	ST	R1,BBUFER+MURCKS,R10,	:SET RECEIVE_CHECK_SENSE
	J	V.RSC1
V.RSC9
	ST	R1,BBUFER+MUSCKS,R10,	:SET SEND_CHECK_SENSE
V.RSC1
	L	R8,SAVRG8,,		:GET BACK REGISTER
	JR	R8			:RETURN

:	V.TPSS	-(TYPE_SESSION) VERIFIES THAT THE REQUEST OR RESPONSE
:	IS FOR THE CORRECT TYPE OF SESSION. THIS PROCEDURE IS CALLED
:	ONLY WHEN A SESSION CONTROL BLOCK IS PRESENT.
:	PAGE 13-50 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS-
:	INPUT	-R13 (NCB PTR) R5 (CB_TYPE) R10 (MU PTR) R9 (SCB PTR)
:	OUTPUT	-NORMAL RETURN,IF NOT OK. SKIP RETURN,IF OK
:	LINK	-R6 (RETURN ADDRESS)
V.TPSS
	LB	R2,SCBBLK+SCACFG,R9,	:GET SCB.SCB_TYPE
	NHI	R2,SC.BFS		:MASK FOR SESSION TYPE
	LB	R1,SCBBLK+SCSSTY,R9,	:GET SCB.TYPE_OF_SESSION
	LHL	R4,V.TPS0,R1,R1		:GET ENTRY PTR FOR DIFFERENT SESSION
	J	V.TPS0,R4,
V.TPS0	HS
	HC	V.TP10-V.TPS0		:SSCP_PU SESSION
	HC	V.TP20-V.TPS0		:SSCP_LU SESSION
	HC	V.TP30-V.TPS0		:SSCP_SSCP SESSION
	HC	V.TP40-V.TPS0		:LU_LU SESSION
	HC	V.TP50-V.TPS0		:PUCP_PU

:	=================================================
:	SCB.TYPE_OF_SESSION=SSCP_PU
:	==========================================
V.TP10
	LR	R2,R2			:CHECK SCB.SCB_TYPE
	JE	V.TP15			:JUMP,IF SCB_TYPE=HALF_SESSION
	J	V.TPS1
:	SCB.TYPE_OF_SESSION=SSCP_PU (SCB_TYPE=HALF_SESSION)
:	---------------------------------------------------
V.TP15
	BBLOAD	R2,BBUFER+MURUPT,R10,	:GET RU_PTR FROM MUCB
	LB	R1,BBUFER,R2,		:GET RQ_CODE
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION BYTE
	NHI	R0,SC.SES		:CHECK PRI OR SEC?
	JE	V.TP19			:JUMP,IT IS SECONDARY
:	HALF_SESSION IS PRIMARY
:	-------------------------
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.TP17			:JUMP,IF IT IS SEND
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JN	V.TP16			:JUMP,IF RRI=RSP
:	SSCP_PU,PRIMARY,RECEIVE,RQ
:	----------------------------
	CLHI	R1,DACTPU		:IS RQ_CODE=DACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	SSCP_PU,PRIMARY,RECEIVE,RSP
:	--------------------
V.TP16
	CLHI	R1,DACTPU		:IS RQ_CODE=DACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,ACTPU		:IS RQ_CODE=ACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	MUCB.DIRECTION=SEND (SESSION IS PRIMARY)
:	------------------------------------------
V.TP17
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JE	V.TP18			:JUMP,IF RRI=RQ
:	SSCP_PU,PRIMARY,SEND,RSP
:	------------------------
	CLHI	R1,DACTPU		:IS RQ_CODE=DACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	SSCP_PU,PRIMARY,SEND,RQ
:	------------------------
V.TP18
	CLHI	R1,DACTPU		:IS RQ_CODE=DACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,ACTPU		:IS RQ_CODE=ACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	HALF_SESSION IS SECONDARY
:	-------------------------
V.TP19
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.TP1B			:JUMP,IF IT IS SEND
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JN	V.TPS1			:IF RRI=RSP,JUMP TO SET RC 'NO'
:	SSCP_PU,SECONDARY,RECEIVE,RQ
:	----------------------------
	CLHI	R1,DACTPU		:IS RQ_CODE=DACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,ACTPU		:IS RQ_CODE=ACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	MUCB.DIRECTION=SEND (SESSION IS SECONDARY)
:	------------------------------------------
V.TP1B
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JE	V.TPS1			:IF RRI=RQ,JUMP TO SET RETURN CODE 'NO'
:	SSCP_PU,SECONDARY,SEND,RSP
:	----------------------------
	CLHI	R1,DACTPU		:IS RQ_CODE=DACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,ACTPU		:IS RQ_CODE=ACTPU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1

:	========================================================
:	SCB.TYPE_OF_SESSION=SSCP_LU
:	==============================================================
V.TP20
	LR	R2,R2			:CHECK SCB.SCB_TYPE
	JE	V.TP25			:JUMP,IF SCB_TYPE=HALF_SESSION
	J	V.TPS1
:	SCB.TYPE_OF_SESSION=SSCP_LU (SCB_TYPE=HALF_SESSION)
:	---------------------------------------------------
V.TP25
	BBLOAD	R2,BBUFER+MURUPT,R10,	:GET RU_PTR FROM MUCB
	LB	R1,BBUFER,R2,		:GET RQ_CODE
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION BYTE
	NHI	R0,SC.SES		:CHECK PRI OR SEC?
	JE	V.TP29			:JUMP,IT IS SECONDARY
:	HALF_SESSION IS PRIMARY
:	-------------------------
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.TP27			:JUMP,IF IT IS SEND
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JN	V.TP26			:JUMP,IF RRI=RSP
	CLHI	R1,DACTLU		:IS RQ_CODE=DACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
V.TP26
	CLHI	R1,DACTLU		:IS RQ_CODE=DACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,ACTLU		:IS RQ_CODE=ACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	MUCB.DIRECTION=SEND (SESSION IS PRIMARY)
:	------------------------------------------
V.TP27
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JE	V.TP28			:JUMP,IF RRI=RQ
	CLHI	R1,DACTLU		:IS RQ_CODE=DACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
V.TP28
	CLHI	R1,DACTLU		:IS RQ_CODE=DACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,ACTLU		:IS RQ_CODE=ACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	HALF_SESSION IS SECONDARY
:	-------------------------
V.TP29
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.TP2B			:JUMP,IF IT IS SEND
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JN	V.TPS1			:IF RRI=RSP,JUMP TO SET RC 'NO'
	CLHI	R1,DACTLU		:IS RQ_CODE=DACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,ACTLU		:IS RQ_CODE=ACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	MUCB.DIRECTION=SEND (SESSION IS SECONDARY)
:	------------------------------------------
V.TP2B
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JE	V.TPS1			:IF RRI=RQ,JUMP TO SET RETURN CODE 'NO'
	CLHI	R1,DACTLU		:IS RQ_CODE=DACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,ACTLU		:IS RQ_CODE=ACTLU?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	========================================================
:	SCB.TYPE_OF_SESSION=SSCP_SSCP
:	=====================================================
V.TP30
	J	V.TPS1

:	================================================
:	SCB.TYPE_OF_SESSION=LU_LU
:	=========================================================
V.TP40
	LR	R2,R2			:CHECK SCB.SCB_TYPE
	JE	V.TP45			:JUMP,IF SCB_TYPE=HALF_SESSION
	J	V.TPS1
:	SCB.TYPE_OF_SESSION=LU_LU (SCB_TYPE=HALF_SESSION)
:	---------------------------------------------------
V.TP45
	BBLOAD	R2,BBUFER+MURUPT,R10,	:GET RU_PTR FROM MUCB
	LB	R1,BBUFER,R2,		:GET RQ_CODE
	LB	R0,SCBBLK+SCACFG,R9,	:GET HALF_SESSION BYTE
	NHI	R0,SC.SES		:CHECK PRI OR SEC?
	JE	V.TP49			:JUMP,IT IS SECONDARY
:	HALF_SESSION IS PRIMARY
:	-------------------------
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.TP47			:JUMP,IF IT IS SEND
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JN	V.TP46			:JUMP,IF RRI=RSP
	CLHI	R1,UNBIND		:IS RQ_CODE=UNBIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
V.TP46
	CLHI	R1,UNBIND		:IS RQ_CODE=UNBIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,BIND			:IS RQ_CODE=BIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	MUCB.DIRECTION=SEND (SESSION IS PRIMARY)
:	------------------------------------------
V.TP47
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JE	V.TP48			:JUMP,IF RRI=RQ
	CLHI	R1,UNBIND		:IS RQ_CODE=UNBIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
V.TP48
	CLHI	R1,UNBIND		:IS RQ_CODE=UNBIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,BIND			:IS RQ_CODE=BIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	HALF_SESSION IS SECONDARY
:	---------------------------------
V.TP49
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JN	V.TP4B			:JUMP,IF IT IS RECEIVE
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JN	V.TP4A			:JUMP,IF RRI=RSP
	CLHI	R1,UNBIND		:IS RQ_CODE=UNBIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
V.TP4A
	CLHI	R1,UNBIND		:IS RQ_CODE=UNBIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,BIND			:IS RQ_CODE=BIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
:	MUCB.DIRECTION=RECEIVE (SESSION IS PRIMARY)
:	------------------------------------------
V.TP4B
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JE	V.TP4C			:JUMP,IF RRI=RQ
	CLHI	R1,UNBIND		:IS RQ_CODE=UNBIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1			:NORMAL RETURN ,IT IS NOT 'OK'
V.TP4C
	CLHI	R1,UNBIND		:IS RQ_CODE=UNBIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	CLHI	R1,BIND			:IS RQ_CODE=BIND?
	JE	V.TPS3			:RETURN CODE 'YES' IN R2
	J	V.TPS1

:	============================================================
:	SCB.TYPE_OF_SESSION=PUCP_PU
:	============================================================
V.TP50
	J	V.TPS1
V.TPS3
	LHI	R2,YES			:SET RETURN CODE TO 'YES'
	JR	R6			:RETURN
V.TPS1
	LHI	R2,NO			:SET RETURN CODE TO 'NO'
	LHI	R1,.MODCN		:SET MODE INCONSISTENT '0809'
	LHI	R3,MUSCKS		:GET OFFSET OF SEND_CHECK_SENSE
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JEFS	V.TPS2			:JUMP,IF IT IS SEND
	LHI	R3,MURCKS		:GET OFFSET OF RECEIVE_CHECK_SENSE
V.TPS2
	ST	R1,BBUFER,R3,R10	:STORE USAGE_SENSE INTO MUCB
	JR	R6			:NORMAL RETURN

:	V.RQPR	-(RQ_PARAMETERS) PAGE 13-54 ON FAPL
:	THIS PROCEDURE VERIFIES THAT THE PARAMETERS CONTAINED IN THE RQ 
:	ARE VALID.
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS-
:	INPUT	-R13 (NCB PTR) R10 (MU PTR) R9 (SCB PTR)
:	OUTPUT	-R1 (RETURN CODE YES,NO)
:	LINK	-R6 (RETURN ADDRESS)
V.RQPR
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU PTR FROM MUCB
	LHI	R1,NO			:INIT VALUE FOR NG
	LIS	R5,0			:CLEAR SENSE CODE
	LB	R0,BBUFER,R3,		:GET RQ_CODE FROM RU
	JAL	R4,R.SCSH,,		:SEARCH FOR RQ_CODE TYPE
	LHL	R4,V.RQPF,R2,R2
	J	V.RQPF,R4
V.RQPF	HS
	HC	V.RQP4-V.RQPF		:RQ_CODE=ACTPU
	HC	V.RQP3-V.RQPF		:RQ_CODE=ACTLU
	HC	V.RQP5-V.RQPF		:RQ_CODE=BIND
	HC	V.RQP6-V.RQPF		:RQ_CODE=ACCDRM
	HC	V.RQP6-V.RQPF		:RQ_CODE=DACTPU
	HC	V.RQP6-V.RQPF		:RQ_CODE=DACTLU
	HC	V.RQP6-V.RQPF		:RQ_CODE=UNBIND
	HC	S.PCRA-V.RQPF		:RQ_CODE=DACDRM
	HC	S.PCRA-V.RQPF		:RQ_CODE=ERROR

:	RQ IS ACTLU
:	------------
V.RQP3
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JN	V.RQP9			:JUMP,IF IT IS NOT SEND
	LB	R0,BBUFER+ALUTAC,R3,	:GET TYPE.ACTIVATION
	CLHI	R0,COLD			:IS IT COLD TYPE
	JE	V.RQP9			:JUMP,IF YES
	CLHI	R0,ERP			:IS IT ERP TYPE
	JEFS	V.RQP9			:JUMP,IF YES
	LI	R5,IP3501		:SET INVALID PARAMETER '08350001'
V.RQP9
	LB	R0,BBUFER+ALUPFL,R3,	:GET TYPE.ACTIVATION
	LR	R4,R0
	NHI	R0,AP.TSP		:MASK FOR TS.PROFILE
	CLHI	R0,PROF01		:IS TS.PROFILE=1
	JN	V.RQP1			:JUMP,IF TS.PROFILE<>1
	SRHLS	R4,AD.FMP		:SHIFT FOR FM.PROFILE
	CLHI	R4,PROF00		:IS FM.PROFILE=0?
	JE	V.RQP6			:JUMP,IF FM.PROFILE<>0
	CLHI	R4,PROF06		:IS FM.PROFILE=6?
	JE	V.RQP6			:JUMP,IF IT IS 6
V.RQP1
	LI	R5,IP3502		:SET INVALID PARAMETER '08350002'
	J	V.RQP7
:	RQ IS ACTPU
:	--------------
V.RQP4
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JN	V.RQP0			:JUMP,IF IT IS NOT SEND
	LB	R0,BBUFER+APUTAC,R3,	:GET TYPE.ACTIVATION
	NHI	R0,AP.ACT		:MASK FOR TYP.ACTIVATION
	CLHI	R0,COLD			:IS IT COLD?
	JE	V.RQP0			:JUMP,IF ITS COLD
	CLHI	R0,ERP			:IS IT ERP?
	JEFS	V.RQP0			:JUMP,IF IT IS ERP
	LI	R5,IP3501		:SET INVALID PARAMETER '08350001'
V.RQP0
	LB	R0,BBUFER+APUPFL,R3,	:GET FM AND TS PROFILE
	LR	R1,R0
	NHI	R1,AP.TSP		:MASK OFF FOR TS.PROFILE
	SRHLS	R0,AD.FMP		:SHIFT FOR FM.PROFILE
	CLHI	R0,PROF00		:IS PROFILE 0 (FM)
	JE	V.RQP2			:JUMP,IF FM.PROFILE=0
	CLHI	R0,PROF05		:IS FM.PROFILE=5?
	JN	V.RQPA			:JUMP,IF FM.PROFILE<>0,5
V.RQP2
	CLHI	R1,PROF01		:IS TS.PROFILE=1
	JE	V.RQP6			:JUMP,IF TS.PROFILE=0
	CLHI	R1,PROF05		:IS TS.PROFILE=5?
	JE	V.RQP6			:JUMP,IF TS.PROFILE=5
V.RQPA
	LI	R5,IP3502		:SET INVALID PARAMETER '08350002'
	J	V.RQP7
:	RQ IS BIND
:	----------------
V.RQP5
	LB	R0,BBUFER+BINTYP,R3,	:GET BIND_RQ.FORMAT
	LR	R1,R0
	SRHLS	R1,4			:GET BIND.RQ_FORMAT
	JN	V.RQPE			:JUMP,IF FORMAT<>0
	CLHI	R0,NGONON		:IS IT NONNEGOTIABLE?
	JEFS	V.RQPD			:JUMP,IF YES
	CLHI	R0,NGOYES		:IS IT NEGOTIABLE?
	JEFS	V.RQPD			:JUMP,IF YES
V.RQPE
	LI	R5,IP3501		:SET INVALID PARAMETER '08350001'
V.RQPD
	LB	R0,BBUFER+BINFMP,R3,	:GET BIND_RQ.FM_PROFILE
	CLHI	R0,PROF02		:IS TS_PROFILE=2?
	JE	V.RQPC			:JUMP,IF YES
	CLHI	R0,PROF03		:IS TS_PROFILE=3?
	JE	V.RQPC			:JUMP,IF YES
	CLHI	R0,PROF04		:IS TS_PROFILE=4?
	JE	V.RQPC			:JUMP,IF YES
	CLHI	R0,PROF07		:IS TS_PROFILE=7?
	JE	V.RQPC			:JUMP,IF YES
	CLHI	R0,PROF18		:IS TS_PROFILE=18?
	JEFS	V.RQPC			:JUMP,IF YES
	LI	R5,IP3502		:SET INVALID PARAMETER '08350002'
V.RQPC
	LB	R0,BBUFER+BINTSP,R3,	:GET BIND_RQ.TS_PROFILE
	CLHI	R0,PROF02		:IS TS_PROFILE=2?
	JE	V.RQP6			:JUMP,IF YES
	CLHI	R0,PROF03		:IS TS_PROFILE=3?
	JE	V.RQP6			:JUMP,IF YES
	CLHI	R0,PROF04		:IS TS_PROFILE=4?
	JE	V.RQP6			:JUMP,IF YES
	CLHI	R0,PROF07		:IS TS_PROFILE=7?
	JE	V.RQP6			:JUMP,IF YES
	LI	R5,IP3503		:SET INVALID PARAMETER '08350003'
	J	V.RQP7

:	OTHER RQS (DACTLU,DACTPU,UNBIND....)
:	----------
V.RQP6
	LHI	R1,YES			:RETURN OK
:	CHECK SENS CODE
:	---------------
V.RQP7
	LR	R5,R5			:CHECK SENSE
	JER	R6			:RETURN R1,IF SENSE=0
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.RQP8			:JUMP,IF IT IS SEND
	ST	R5,BBUFER+MURCKS,R10,	:SET RECEIVE_CHECK_SENSE
	JR	R6			:RETURN
V.RQP8
	ST	R5,BBUFER+MUSCKS,R10,	:SET SEND_CHECK_SENSE
	JR	R6			:ELSE,PROCESS AND RETURN

:	V.RSPR	-(RSP_PARAMETERS) PAGE 13-56 ON FAPL
:	THIS PROCEDURE VERIFIES THAT THE PARAMETERS CONTAINED IN THE RSP 
:	ARE VALID.
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS-
:	INPUT	-R13 (NCB PTR) R7 (CB_TYPE) R10 (MU PTR) R9 (SCB PTR)
:	OUTPUT	-R1 (RETURN CODE YES,NO)
:	LINK	-R6 (RETURN ADDRESS)
V.RSPR
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU PTR FROM MUCB
	LHI	R1,NO			:INIT VALUE FOR NG
	LIS	R5,0			:CLEAR SENSE CODE
	LHL	R7,BBUFER+MUDCF,R10,	:GET DCF LENGTH
	SHI	R7,RHLENG		:GET LENGTH OF RU
	JLE	V.RSP0			:JUMP,IF RU LENGTH <0
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.RTI		:CHECK MU.RTI BIT
	JN	V.RSP6			:JUMP,IF RTI=NEG
	LB	R0,BBUFER,R3,		:GET RQ_CODE FROM RU
	JAL	R4,R.SCSH,,		:SEARCH FOR RQ_CODE TYPE
	LHL	R4,V.RSPA,R2,R2
	J	V.RSPA,R4
V.RSPA	HS
	HC	V.RSP4-V.RSPA		:RQ_CODE=ACTPU
	HC	V.RSP3-V.RSPA		:RQ_CODE=ACTLU
	HC	V.RSP5-V.RSPA		:RQ_CODE=BIND
	HC	V.RSP6-V.RSPA		:RQ_CODE=ACCDRM
	HC	V.RSP6-V.RSPA		:RQ_CODE=DACTPU
	HC	V.RSP6-V.RSPA		:RQ_CODE=DACTLU
	HC	V.RSP6-V.RSPA		:RQ_CODE=UNBIND
	HC	S.PCRA-V.RSPA		:RQ_CODE=DACDRM
	HC	S.PCRA-V.RSPA		:RQ_CODE=ERROR

:	RSP IS ACTLU
:	------------
V.RSP3
	CLHI	R7,ALUPTP		:IS RU LENGTH LEGAL?
	JLE	V.RSP0			:JUMP,IF LENGTH NOT LEGAL
	LB	R0,BBUFER+ALUPTP,R3,	:GET TYPE.ACTIVATION
	CLHI	R0,COLD			:IS IT COLD TYPE
	JE	V.RSP9			:JUMP,IF YES
	CLHI	R0,ERP			:IS IT ERP TYPE
	JEFS	V.RSP9			:JUMP,IF YES
	LI	R5,IP3501		:SET INVALID PARAMETER '08350001'
V.RSP9
	CLHI	R7,ALPPFL		:IS RU LENGTH LEGAL?
	JLE	V.RSP6			:JUMP,IF LENGTH FINISH
	LB	R0,BBUFER+ALPPFL,R3,	:GET TYPE.ACTIVATION
	LR	R4,R0
	NHI	R0,AP.TSP		:MASK FOR TS.PROFILE
	CLHI	R0,PROF01		:IS TS.PROFILE=1
	JN	V.RSP1			:JUMP,IF TS.PROFILE<>1
	SRHLS	R4,AD.FMP		:SHIFT FOR FM.PROFILE
	CLHI	R4,PROF00		:IS FM.PROFILE=0?
	JEFS	V.RSP2			:JUMP,IF FM.PROFILE=0
	CLHI	R4,PROF06		:IS FM.PROFILE=6?
	JN	V.RSP1			:JUMP,IF FM.PROFILE<>6
V.RSP2
	LHI	R1,YES			:SET RC TO YES
	J	V.RSP7			:JUMP TO PROCESS SENSE
V.RSP1
	LI	R5,IP3502		:SET INVALID PARAMETER '08350002'
	J	V.RSP7
:	RSP IS ACTPU
:	--------------
V.RSP4
	CLHI	R7,APUFTA		:IS RU LENGTH LEGAL?
	JLE	V.RSP0			:JUMP,IF LENGTH NOT LEGAL
	LB	R0,BBUFER+APUFTA,R3,	:GET TYPE.ACTIVATION
	NHI	R0,AP.ACT		:MASK FOR TYPE ACTIVATION
	CLHI	R0,COLDNI		:IS IT COLDNI?(IPL NOT REQ.)
	JE	V.RSP6			:JUMP,IF ITS COLD
	CLHI	R0,COLDIP		:IS IT COLDIP?(IPL REQ.)
	JE	V.RSP6			:JUMP,IF ITS COLD
	CLHI	R0,ERP			:IS IT ERP?
	JE	V.RSP6			:JUMP,IF IT IS ERP
	LI	R5,IP3501		:SET INVALID PARAMETER '08350001'
	J	V.RSP7			:JUMP TO HANDLE SENS
:	RSP IS BIND
:	----------------
V.RSP5
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF LENGTH
	CLHI	R0,RSPLN1		:IS IT RSP_OF_LENGTH_ONE?
	JE	V.RSP6			:JUMP,IF NONEXTENDED NONNEGOTIABLE
V.RSPB
	LB	R0,BBUFER+BINTYP,R3,	:GET BIND_RQ.FORMAT
	LR	R4,R0
	SRHLS	R4,4			:GET BIND.RQ_FORMAT
	JN	V.RSP0			:JUMP,IF FORMAT<>0
	CLHI	R0,NGONON		:IS IT NONNEGOTIABLE?
	JE	V.RSP2			:JUMP,IF YES
	CLHI	R0,NGOYES		:IS IT NEGOTIABLE?
	JE	V.RSP2			:JUMP,IF YES
V.RSP0
	LI	R5,IP3501		:SET INVALID PARAMETER '08350001'
	J	V.RSP7			:JUMP

:	OTHER RSPS (DACTLU,DACTPU,UNBIND....)
:	----------
V.RSP6
	LHI	R1,YES			:RETURN OK
:	CHECK SENS CODE
:	---------------
V.RSP7
	LR	R5,R5			:CHECK SENSE
	JER	R6			:RETURN R1,IF SENSE=0
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.RSP8			:JUMP,IF IT IS SEND
	LHI	R1,YES			:SET RC TO YES
	LHI	R5,.RRISP		:SET INVALID SESSION PARAMETER (084E)
	ST	R5,BBUFER+MURCKS,R10,	:SET RECEIVE_CHECK_SENSE
	JR	R6			:RETURN
V.RSP8
	LHI	R1,NO			:SET RC TO NG
	ST	R5,BBUFER+MUSCKS,R10,	:SET SEND_CHECK_SENSE
	JR	R6			:ELSE,PROCESS AND RETURN

:	V.SARQ	-(SESSACT.REQUEST) PAGE 13-66 ON FAPL
:	SAVE THE PARAMETERS CONTAINED IN THE ACTIVATION REQUESTS IN SCB
:	-----------------------------------------------------------------
:	THE USAGE OF REGISTERS-
:	INPUT	-R13 (NCB PTR) R9 (SCB PTR) R10 (MUCB PTR)
:		 R3 (1ST LEVEL CALL FOR FSM)
:	OUTPUT	-
:	LINK	-R4 (RETURN ADDRESS)
:	WORKING	-R5 (FOR SUBJECT ROUTINE CALL) R7 (FOR RU_PTR)
V.SARQ
	ST	R3,SAVRG3,,
	ST	R4,SAVRG4,,
	LB	R1,SCBBLK+SCACFG,R9,	:GET HALF_SESSION BYTE
	NHI	R1,@SC.SES		:CLEAR HALF_SESSION BIT
	LHI	R2,SC.SES		:GET SCB.HALF_SESSION
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JEFS	V.SAR0			:JUMP,IF IT IS SEND
	LIS	R2,0			:TURN OFF FOR SEC HALF_SESSION
V.SAR0
	OR	R1,R2			:SET HALF_SESSION
	STB	R1,SCBBLK+SCACFG,R9,	:STORE HALF_SESSION BYTE
	BBLOAD	R7,BBUFER+MURUPT,R10,	:GET RU PTR FROM MUCB
	LB	R0,BBUFER,R7,		:GET RQ_CODE FROM RU
	CLHI	R0,ACTLU		:IS RQ_CODE=ACTLU?
	JE	V.SAR3			:JUMP,IF IT IS ACTLU
	CLHI	R0,ACTPU		:IS RQ_CODE=ACTPU?
	JE	V.SAR2			:JUMP,IF IT IS ACTPU
	CLHI	R0,BIND			:IS RQ_CODE=BIND?
	JE	V.SAR1			:JUMP,IF IT IS BIND
	CLHI	R0,ACCDRM		:IS RQ_CODE=ACTCDRM?
	JE	V.SAR5			:JUMP,IT IS ACTCDRM
	J	V.SAR5
:	RQ_CODE=BIND
:	---------------
V.SAR1
	LHI	R1,LULU			:SETUP SSCP_PU SESSION
	STB	R1,SCBBLK+SCSSTY,R9,	:GET SCB.TYPE_OF_SESSION
	LB	R0,BBUFER+BINTSP,R7,	:GET BIND_RQ.TS_PROFILE
	STB	R0,SCBBLK+SCTSPF,R9,	:SET SCB.TS_PROFILE
	JAL	R5,V.TSPF,,		:CALL TS_PROFILE_PROCESS
	LB	R0,BBUFER+BINFMP,R7,	:GET BIND_RQ.FM_PROFILE
	STB	R0,SCBBLK+SCFMPF,R9,	:SET SCB.FM_PROFILE
	LB	R0,BBUFER+BINPSF,R7,	:GET BIND_RQ.PS_PROFILE
	STB	R0,SCBBLK+SCPSUF,R9,	:SET SCB.PS_PROFILE
	LHI	R6,BINPSU		:SET 1ST BYTE IN BIND_RQ
	LHI	R2,SCCYSL		:SET END OF OFFSET
	LHI	R1,SCPSUG		:SET BEGINNING OF OFFSET
	JAL	R5,V.SCUP,,		:CALL ROUTINE TO MOVE BIND_RQ INTO SCB
	JAL	R5,V.FMPF,,		:CALL FM_PROFILE_PROCESS
	LHI	R1,LMSSMR		:SET FOR LU.SVC_MGR.SS.RCV
	STB	R1,SCBBLK+SCSVMV,R9,	:SETUP #SVC_MGR
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.SAR5			:IF IT IS SEND
	LB	R0,SCBBLK+SCTFFG,R9,	:GET RQ_CODE SUPPORTED IND.
	NHI	R0,SC.CRV		:IS SCB.SC_CRV ALLOWED?
	JE	V.SAR5			:JUMP,IF NOT ALLOWED
	LHI	R6,BINCKY		:SET 1ST BYTE IN BIND_RQ
	LHI	R2,SCSQUS		:SET END OF OFFSET
	LHI	R1,SCCYKF		:SET BEGINNING OF OFFSET
	JAL	R5,V.SCUP,,		:CALL TO MOVE BIND_RQ INTO SCB
	J	V.SAR5
:	RQ_CODE=ACTPU
:	---------------
:	R10 -- MUCB PTR, R7 -- RU PTR
V.SAR2
	LHI	R1,SSCPPU		:SETUP SSCP_PU SESSION
	STB	R1,SCBBLK+SCSSTY,R9,	:GET SCB.TYPE_OF_SESSION
	LB	R0,BBUFER+APUPFL,R7,	:GET FM AND TS PROFILE
	LR	R1,R0
	NHI	R0,AP.TSP		:MASK OFF FOR TS.PROFILE
	SRHLS	R1,AD.FMP		:SHIFT FOR FM.PROFILE
	STB	R1,SCBBLK+SCFMPF,R9,	:SET FM.PROFILE IN SCB
	STB	R0,SCBBLK+SCTSPF,R9,	:SET TS.PROFILE IN SCB
	LHI	R1,SMCSMR		:INIT #SVC.MGR TO SSCP.SVC_MGR.CS.RCV
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JEFS	V.SAR4			:JUMP,IF IT IS SEND
	LHI	R1,PMNSMR		:SET FOR PU.SVC_MGR.NS.RCV
V.SAR4
	STB	R1,SCBBLK+SCSVMV,R9,	:SETUP #SVC_MGR
V.SAR5
	L	R3,SAVRG3,,
	L	R4,SAVRG4,,
	JR	R4			:RETURN
:	RQ_CODE=ACTLU
:	---------------
:	R10 -- MUCB PTR, R7 -- RU PTR
V.SAR3
	LHI	R1,SSCPLU		:SETUP SSCP_LU SESSION
	STB	R1,SCBBLK+SCSSTY,R9,	:GET SCB.TYPE_OF_SESSION
	LB	R0,BBUFER+ALUPFL,R7,	:GET FM AND TS PROFILE
	LR	R1,R0
	NHI	R0,AP.TSP		:MASK OFF FOR TS.PROFILE
	SRHLS	R1,AD.FMP		:SHIFT FOR FM.PROFILE
	STB	R1,SCBBLK+SCFMPF,R9,	:SET FM.PROFILE IN SCB
	STB	R0,SCBBLK+SCTSPF,R9,	:SET TS.PROFILE IN SCB
	LHI	R1,SMCSMR		:INIT #SVC.MGR TO SSCP.SVC_MGR.CS.RCV
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	V.SAR4			:JUMP,IF IT IS SEND
:	SETUP SVC_MGR FOR PU.NS INSTEAD OF LU.SS?????
	LHI	R1,LMSSMR		:SET FOR LU.SVC_MGR.SS.RCV
	LHI	R1,PMNSMR		:SET FOR PU.SVC_MGR.NS.RCV
	J	V.SAR4			:GOTO SETUP #SVC_MGR

:	V.SASP	-(SESSACT.RESPONSE)PAGE 13-68 ON FAPL
:	SAVE THE PARAMETERS CONTAINED IN THE ACTIVATION RESPONSES IN SCB
:	-----------------------------------------------------------------
:	THE USAGE OF REGISTERS-
:	INPUT	-R13 (NCB PTR) R9 (SCB PTR) R10 (MUCB PTR)
:		 R3 (1ST LEVEL CALL FOR FSM)
:	WORKING	-R5 (FOR SUBJECT ROUTINE CALL) R7 (FOR RU_PTR)
:	OUTPUT	-
:	LINK	-R4 (RETURN ADDRESS)
V.SASP
	ST	R3,SAVRG3,,
	ST	R4,SAVRG4,,
	BBLOAD	R7,BBUFER+MURUPT,R10,	:GET RU PTR FROM MUCB
	LB	R0,BBUFER,R7,		:GET RQ_CODE FROM RU
	CLHI	R0,ACTLU		:IS RQ_CODE=ACTLU?
	JE	V.SAS3			:JUMP,IF IT IS ACTLU
	CLHI	R0,ACTPU		:IS RQ_CODE=ACTPU?
	JE	V.SAS2			:JUMP,IF IT IS ACTPU
	CLHI	R0,BIND			:IS RQ_CODE=BIND?
	JE	V.SAS1			:JUMP,IF IT IS BIND
	CLHI	R0,ACCDRM		:IS RQ_CODE=ACTCDRM?
	JNR	R4			:RETURN,IF IT IS NOT ACTCDRM
:	RQ_CODE=ACTCDRM
:	---------------
	J	V.SAS9			:JUMP TO INIT
:	RQ_CODE=BIND
:	---------------
V.SAS1
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF LENGTH
	CLHI	R0,RSPLN1		:IS IT RSP_OF_LENGTH_ONE?
	JE	V.SAS7			:JUMP,IF YES (NEGOTIABLE BIND)
	LB	R0,BBUFER+BIPTYP,R7,	:GET BIND_RSP.TYPE
	JN	V.SAS7			:JUMP,IF NONNEGOTIABLE
	J	V.SAS9			:JUMP TO INIT
:	RQ_CODE=ACTPU
:	---------------
:	R10 -- MUCB PTR, R7 -- RU PTR
V.SAS2
	LB	R1,SCBBLK+SCACFG,R9,	:GET HALF_SESSION BYTE
	LR	R0,R1			:SAVE
	NHI	R0,@SC.PFR		:SET REQUEST_RECEIVE TO NOT ALLOWED
	NHI	R1,SC.SES		:CHECK PRI OR SEC?
	JE	V.SAS4			:JUMP,IT IS SECONDARY
	STB	R0,SCBBLK+SCACFG,R9,	:STORE INTO SCB
V.SAS4
	LB	R1,BBUFER+APUFTA,R7,	:GET ACTPU(RSP) FORMAT BYTE
	NHI	R1,AP.FMT		:MASK OUT FOR FORMAT BITS
	SRHLS	R1,AD.FMT		:SHIFT FOR FORMAT TYPE
	LHL	R5,V.SAS0,R1,R1		:GET ENTRY FOR EACH CASE
	J	V.SAS0,R5,		:JUMP
V.SAS0	HS
	HC	V.SAS5-V.SAS0		:ENTRY PTR FOR FORMAT.0
	HC	V.SAS6-V.SAS0		:ENTRY PTR FOR FORMAT.1
	HC	V.SASA-V.SAS0		:ENTRY PTR FOR FORMAT.2
	HC	V.SASB-V.SAS0		:ENTRY PTR FOR FORMAT.3

:	ACTPU_RSP.FORMAT=0
:	------------------
V.SAS5
	J	V.SASC			:JUMP TO INIT
:	ACTPU_RSP.FORMAT=1
:	------------------
V.SAS6
	LB	R1,BBUFER+APUFDA+2,R7,	:GET CONTROL VECTOR KEY
	CLHI	R1,VC.K07		:IS IT VECTOR '07'?
	JN	S.PCRA			:CRASH,IF NOT VECTOR '07'
	LB	R1,BBUFER+APUFDA+3,R7,	:GET REQUEST_RECEIVE
V.SASD
	NHI	R1,AP.FMD		:MASK FOR FMD BITS
	JN	V.SASB			:JUMP IF IT IS SET
V.SASC
	STB	R0,SCBBLK+SCACFG,R9,	:STORE INTO SCB
	J	V.SAS9			:JUMP TO INIT
:	ACTPU_RSP.FORMAT=2
:	------------------
V.SASA
	LB	R1,BBUFER+APUFDA+0A,R7,	:GET CONTROL VECTOR KEY
	CLHI	R1,VC.K07		:IS IT VECTOR '07'?
	JN	S.PCRA			:CRASH,IF NOT VECTOR '07'
	LB	R1,BBUFER+APUFDA+0B,R7,	:GET REQUEST_RECEIVE
	J	V.SASD
:	ACTPU_RSP.FORMAT=3
:	------------------
V.SASB
	OHI	R0,SC.PFR		:SET REQUEST_RECEIVE TO ALLOWED
	STB	R0,SCBBLK+SCACFG,R9,	:STORE INTO SCB
	J	V.SAS9			:JUMP TO INIT

:	RQ_CODE=ACTLU
:	---------------
:	R10 -- MUCB PTR, R7 -- RU PTR
V.SAS3
	LHL	R0,BBUFER+MUDCF,R10,	:GET DCF LENGTH
	CLHI	R0,RSPLN2		:IS IT RSP_OF_LENGTH_TWO?
	JN	V.SAS8			:JUMP,IF NOT
	LHI	R0,RU0256		:SET RU SIZE TO 256 BYTES (X'85')
	STB	R0,SCBBLK+SCSMRU,R9,	:SET SEC_SEND_MAX_RU_SIZE
	STB	R0,SCBBLK+SCPMRU,R9,	:SET PRI_SEND_MAX_RU_SIZE
	J	V.SAS9
:	DCF<>RSP_OF_LENGTH_TWO
V.SAS8
	LB	R0,BBUFER+ALPPFL,R7,	:GET FM AND TS PROFILE
	LR	R1,R0
	NHI	R0,AP.TSP		:MASK OFF FOR TS.PROFILE
	SRHLS	R1,AD.FMP		:SHIFT FOR FM.PROFILE
	STB	R1,SCBBLK+SCFMPF,R9,	:SET FM.PROFILE IN SCB
	STB	R0,SCBBLK+SCTSPF,R9,	:SET TS.PROFILE IN SCB
	J	V.SAS9			:JUMP TO INIT
:	FOR NONNEGOTIABLE BIND -- DON'T UPDATE PROFILE
:	-----------------------------------------------
V.SAS9
	JAL	R5,V.TSPF,,		:CALL TS_PROFILE_PROC
	JAL	R5,V.FMPF,,		:CALL FM_PROFILE_PROC
V.SAS7
	JAL	R5,D.IDFC,,		:CALL SESSACT.DFC_INITIALIZE
	JAL	R5,D.RDFC,,		:CALL SESSACT.DFC_RESET
	JAL	R5,T.ITC,,		:CALL SESSACT.TC_INITIALIZE
	JAL	R5,T.RTC,,		:CALL SESSACT.TC_RESET
	L	R3,SAVRG3,,
	L	R4,SAVRG4,,
	JR	R4			:RETURN

:	V.FMPF	-(FM_PROFILE_PROC) PAGE 13-70 ON FAPL
:	---------------------------------------------
:	INPUT	-R9 (SCB_PTR) R10 (MUCB_PTR) R4 (2ND LEVEL CALL)
:		 R3 (1ST LEVEL CALL) R7 (RU_PTR)
:	LINK	-R5
V.FMPF
	LB	R0,SCBBLK+SCFMPF,R9,	:SET SCB.FM_PROFILE
	JAL	R4,V.FMSH,,		:SEARCH FOR DESIRED PROFILE
	LHL	R4,V.FM90,R2,R2		:FOR THE PROCESS ROUTINE
	J	V.FM90,R4
V.FM90	HS
	HC	V.FM00-V.FM90		:PROFILE 00
	HC	V.FM02-V.FM90		:PROFILE 02
	HC	V.FM03-V.FM90		:PROFILE 03
	HC	V.FM04-V.FM90		:PROFILE 04
	HC	V.FM05-V.FM90		:PROFILE 05
	HC	V.FM06-V.FM90		:PROFILE 06
	HC	V.FM07-V.FM90		:PROFILE 07
	HC	V.FM17-V.FM90		:PROFILE 17
	HC	V.FM18-V.FM90		:PROFILE 18
	HC	S.PCRA-V.FM90		:ERROR PROFILE

:	SCB.FM_PROFILE=PROFILE_00 (PAGE 13-71 ON FAPL)
:	-------------------------
V.FM00
	LHI	R0,SC.DRC		:SET PRI_DEF_RSP_CHAIN ALLOWED
	STB	R0,SCBBLK+SCCHRP,R9,	:STORE INTO SCB
	STB	R0,SCBBLK+SCCHRS,R9,	:SET SEC_DEF_RSP_CHAIN ALLOWED
	LB	R0,SCBBLK+SCPLUP,R9,	:GET BIND BYTE 4 IN SCB
:	PRI_CHAIN_USE=SINGLE,PRI_RQ_MODE=IMMED.,PRI_COMPR_IND=NO_COMP.
:	PRI_EB_IND=MAY_NOT_SEND
	NHI	R0,@(SC.PCU+SC.PID+SC.PCP+SC.PEB)
	STB	R0,SCBBLK+SCPLUP,R9,	:SET PRI_CHAIN_USE,PRI_RQ_MODE
					:PRI_COMPR_IND,PRI_EB_IND IN SCB
	LB	R0,SCBBLK+SCSLUP,R9,	:GET BIND BYTE 5 IN SCB
:	SEC_CHAIN_USE=SINGLE,SEC_RQ_MODE=IMMED.,SEC_COMPR_IND=NO_COMP.
:	SEC_EB_IND=MAY_NOT_SEND
	NHI	R0,@(SC.SCU+SC.SID+SC.SCP+SC.SEB)
	STB	R0,SCBBLK+SCSLUP,R9,	:SET SEC_CHAIN_USE,SEC_RQ_MODE
					:SEC_COMPR_IND,SEC_EB_IND IN SCB
	LB	R0,SCBBLK+SCCLUP,R9,	:GET FM_HDR_USAGE,BRACKETS_RESET_STATE
:	FM_HDR_USAGE=NO_FM_HEADERS,BRACKETS_RESET_STATE=BRACKETS_NOT_USED
:	ALT_CODE=NOT_USED
	NHI	R0,@(SC.FMH+SC.BRS+SC.ALC)
	STB	R0,SCBBLK+SCCLUP,R9,	:SET FM_HDR_USAGE,BRACKETS_RESET_STATE
					:ALT_CODE IN SCB
	LB	R0,SCBBLK+SCSRMD,R9,	:SET SEND_RCV_MODE,RECOVERY_RESP
	NHI	R0,@SC.SRM		:MASK OFF SEND_RCV_MODE
	OHI	R0,HDXCON+SC.RVR
	NHI	R0,@SC.CWN		:CONT_WIN=SEC
	STB	R0,SCBBLK+SCSRMD,R9,	:SET SEND_RCV_MODE,RECOVERY_RESP
					:CONT_WIN IN SCB
	LB	R0,SCBBLK+SCTFFG,R9,	:GET RQ_CODE SUPPORTED IND.
:	PRI_RSP_MODE=IMMED.,SEC_RSP_MODE=IMMED.
	NHI	R0,@(SC.PSM+SC.SSM)
	STB	R0,SCBBLK+SCTFFG,R9,	:STORE INTO SCB
	JR	R5			:RETURN

:	SCB.FM_PROFILE=PROFILE_02
:	-------------------------
V.FM02
	JR	R5			:RETURN
:	SCB.FM_PROFILE=PROFILE_03 (PAGE 13-73 ON FAPL -- FM_PROFILE_3)
:	------------------------------------------------------------
V.FM03
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JN	V.FM23			:JUMP,IF RRI=RSP
:	BIND REQUEST CONDITION
:	-----------------------
	LB	R0,BBUFER+BINPRI,R7,	:GET BIND BYTE 4
	STB	R0,SCBBLK+SCPLUP,R9,	:SET PRI_CHAIN_USE,PRI_RQ_MODE
					:PRI_COMPR_IND,PRI_EB_IND IN SCB
	LB	R0,BBUFER+BINSEC,R7,	:GET BIND BYTE 5
	STB	R0,SCBBLK+SCSLUP,R9,	:SET SEC_CHAIN_USE,SEC_RQ_MODE
					:SEC_COMPR_IND,SEC_EB_IND IN SCB
	LB	R0,BBUFER+BINCOM,R7,	:GET BIND BYTE 6
	STB	R0,SCBBLK+SCCLUP,R9,	:SET FM_HDR_USAGE,BRACKETS_RESET_STATE
					:BRKT_TERM_RULE,ALT_CODE IN SCB
	LB	R0,BBUFER+BINCOM+1,R7,	:GET BIND BYTE 7
	STB	R0,SCBBLK+SCSRMD,R9,	:SET SEND_RCV_MODE,RECOVERY_RESP
					:CONT_WIN,HDX_FF_RESET_STATE IN SCB
	J	V.FM33			:JUMP TO NEXT STEP
:	BIND RESPONSE CONDITION
:	-----------------------
V.FM23
	LB	R0,BBUFER+BIPPRI,R7,	:GET BIND RSP BYTE 4
	STB	R0,SCBBLK+SCPLUP,R9,	:SET PRI_CHAIN_USE,PRI_RQ_MODE
					:PRI_COMPR_IND,PRI_EB_IND IN SCB
	LB	R0,BBUFER+BIPSEC,R7,	:GET BIND RSP BYTE 5
:(3.F01/08/24/87/ACH/BEGIN)
	LHL	R6,SCBBLK+SCBLUC,R9,	:GET LUBTAB ENTRY
	LHL	R6,LUCTAB+LUCLNC,R6,	:
	LB	R6,LNCTAB+LNCNFG,R6,
	NHI	R6,LN.SRU		:SINGLE RU CHAIN?
	JE	V.FM24
	NHI	R0,@SC.SCU
V.FM24
:(3.F01/08/24/87/ACH/END)
	STB	R0,SCBBLK+SCSLUP,R9,	:SET SEC_CHAIN_USE,SEC_RQ_MODE
					:SEC_COMPR_IND,SEC_EB_IND IN SCB
	LB	R0,BBUFER+BIPCOM,R7,	:GET BIND RSP BYTE 6
	STB	R0,SCBBLK+SCCLUP,R9,	:SET FM_HDR_USAGE,BRACKETS_RESET_STATE
					:BRKT_TERM_RULE,ALT_CODE IN SCB
	LB	R0,BBUFER+BIPCOM+1,R7,	:GET BIND RSP BYTE 7
	STB	R0,SCBBLK+SCSRMD,R9,	:SET SEND_RCV_MODE,RECOVERY_RESP
					:CONT_WIN,HDX_FF_RESET_STATE IN SCB
V.FM33
	JAL	R6,V.CNRS,,		:CALL CHAIN_RSP_SET
	LB	R0,SCBBLK+SCTFFG,R9,	:GET RQ_CODE SUPPORTED IND.
:	PRI_RSP_MODE=IMMED.,SEC_RSP_MODE=IMMED.
	NHI	R0,@(SC.PSM+SC.SSM)
	STB	R0,SCBBLK+SCTFFG,R9,	:STORE INTO SCB
	JR	R5			:RETURN

:	SCB.FM_PROFILE=PROFILE_04
:	-------------------------
V.FM04
:	SCB.FM_PROFILE=PROFILE_05
:	-------------------------
V.FM05
:	SCB.FM_PROFILE=PROFILE_06
:	-------------------------
V.FM06
:	SCB.FM_PROFILE=PROFILE_07
:	-------------------------
V.FM07
:	SCB.FM_PROFILE=PROFILE_17
:	-------------------------
V.FM17
:	SCB.FM_PROFILE=PROFILE_18
:	-------------------------
V.FM18
	JR	R5			:RETURN

:	V.CNRS	-CHAIN_RSP_SET (PAGE 13-79 ON FAPL)
:	---------------------------------------------
:	INPUT	-R9 (SCB_PTR) R10 (MUCB_PTR) R4 (2ND LEVEL CALL)
:		 R3 (1ST LEVEL CALL) R5 (3RD LEVEL CALL) R7 (RU_PTR)
:	LINK	-R6
V.CNRS
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JN	V.CNR0			:JUMP,IF RRI=RSP
	LB	R2,BBUFER+BINPRI,R7,	:GET BIND REQUEST BYTE 4
	NHI	R2,BD.CNR		:MASK FOR PRI_CHAIN_RSP
	LB	R1,BBUFER+BINSEC,R7,	:GET BIND REQUEST BYTE 5
	NHI	R1,BD.CNR		:MASK FOR SEC_CHAIN_RSP
	J	V.CNR1			:JUMP FOR NEXT STEP
V.CNR0
	LB	R2,BBUFER+BIPPRI,R7,	:GET BIND RESPONSE BYTE 4
	NHI	R2,BD.CNR		:MASK FOR PRI_CHAIN_RSP
	LB	R1,BBUFER+BIPSEC,R7,	:GET BIND RESPONSE BYTE 5
	NHI	R1,BD.CNR		:MASK FOR SEC_CHAIN_RSP
:	ACCORDING TO R2 (CHAIN_RSP_PRI)
:	------------------------------------------------------------
V.CNR1
	SRHLS	R2,AD.CNR		:SHIFT FOR POSITION ADJUST (DEF.?????)
	SRHLS	R1,AD.CNR		:SHIFT FOR POSITION ADJUST (DEF.?????)
	LHL	R2,V.CNR2,R2,R2		:GET ENTRY PTR FOR EACH CASE
	J	V.CNR2,R2,
V.CNR2	HS
	HC	V.CNR3-V.CNR2		:NO_RESPONSE
	HC	V.CNR4-V.CNR2		:EXCP_RESPONSE
	HC	V.CNR5-V.CNR2		:DEF_RESPONSE
	HC	V.CNR6-V.CNR2		:DEF_OR_EXCP__RESPONSE

:	CHAIN_RSP_PRI -- NO_RESPONSE
:	-----------------------------
V.CNR3
	LHI	R0,SC.NRC		:SET PRI_NO_RSP_CHAIN ALLOWED
	STB	R0,SCBBLK+SCCHRP,R9,	:STORE INTO SCB
	J	V.CNRC			:JUMP FOR CHAIN_RSP_SEC
:	CHIAN_RSP_PRI -- EXCP_RESPONSE
:	------------------------------
V.CNR4
	LHI	R0,SC.ERC		:SET PRI_EXCP_RSP_CHAIN ALLOWED
	STB	R0,SCBBLK+SCCHRP,R9,	:STORE INTO SCB
	J	V.CNRC			:JUMP FOR CHAIN_RSP_SEC
:	CHAIN_RSP_PRI -- DEF_RESPONSE
:	------------------------------
V.CNR5
	LHI	R0,SC.DRC		:SET PRI_DEF_RSP_CHAIN ALLOWED
	STB	R0,SCBBLK+SCCHRP,R9,	:STORE INTO SCB
	J	V.CNRC			:JUMP FOR CHAIN_RSP_SEC
:	CHAIN_RSP_PRI -- DEF_OR_EXCP_RESPONSE
:	-------------------------------------
V.CNR6
	LHI	R0,SC.DRC+SC.ERC	:SET PRI_DEF & EXCP_RSP_CHAIN ALLOWED
	STB	R0,SCBBLK+SCCHRP,R9,	:STORE INTO SCB
	J	V.CNRC			:JUMP FOR CHAIN_RSP_SEC

:	ACCORDING TO R1 (CHAIN_RSP_SEC) TO UPDATE
:	------------------------------------------------------------
V.CNRC
	LHL	R1,V.CNR7,R1,R1		:GET ENTRY PTR FOR EACH CASE
	J	V.CNR7,R1,
V.CNR7	HS
	HC	V.CNR8-V.CNR7		:NO_RESPONSE
	HC	V.CNR9-V.CNR7		:EXCP_RESPONSE
	HC	V.CNRA-V.CNR7		:DEF_RESPONSE
	HC	V.CNRB-V.CNR7		:DEF_OR_EXCP__RESPONSE

:	CHAIN_RSP_SEC -- NO_RESPONSE
:	-----------------------------
V.CNR8
	LHI	R0,SC.NRC		:SET SEC_NO_RSP_CHAIN ALLOWED
	STB	R0,SCBBLK+SCCHRS,R9,	:STORE INTO SCB
	JR	R6			:RETURN
:	CHIAN_RSP_SEC -- EXCP_RESPONSE
:	------------------------------
V.CNR9
	LHI	R0,SC.ERC		:SET SEC_EXCP_RSP_CHAIN ALLOWED
	STB	R0,SCBBLK+SCCHRS,R9,	:STORE INTO SCB
	JR	R6			:RETURN
:	CHAIN_RSP_SEC -- DEF_RESPONSE
:	------------------------------
V.CNRA
	LHI	R0,SC.DRC		:SET SEC_DEF_RSP_CHAIN_ALLOWED
	STB	R0,SCBBLK+SCCHRS,R9,	:STORE INTO SCB
	JR	R6			:RETURN
:	CHAIN_RSP_SEC -- DEF_OR_EXCP_RESPONSE
:	-------------------------------------
V.CNRB
	LHI	R0,SC.DRC+SC.ERC	:SET SEC_DEF & EXCP_RSP_CHAIN ALLOWED
	STB	R0,SCBBLK+SCCHRS,R9,	:STORE INTO SCB
	JR	R6			:RETURN

:	V.TSPF	-(TS_PROFILE_PROC) PAGE 13-70 ON FAPL
:	---------------------------------------------
:	INPUT	-R9 (SCB_PTR) R10 (MUCB_PTR) R4 (2ND LEVEL CALL)
:		 R3 (1ST LEVEL CALL) R7 (RU_PTR)
:	LINK	-R5
V.TSPF
	LB	R0,SCBBLK+SCTSPF,R9,	:SET SCB.TS_PROFILE
	JAL	R4,V.TSSH,,		:SEARCH FOR DESIRED PROFILE
	LHL	R4,V.TS90,R2,R2		:FOR THE PROCESS ROUTINE
	J	V.TS90,R4
V.TS90	HS
	HC	V.TS01-V.TS90		:PROFILE 01
	HC	V.TS02-V.TS90		:PROFILE 02
	HC	V.TS03-V.TS90		:PROFILE 03
	HC	V.TS04-V.TS90		:PROFILE 04
	HC	V.TS05-V.TS90		:PROFILE 05
	HC	V.TS07-V.TS90		:PROFILE 07
	HC	V.TS17-V.TS90		:PROFILE 17
	HC	S.PCRA-V.TS90		:ERROR PROFILE

:	SCB.TS_PROFILE=PROFILE_01 (PAGE 13-80)
:	-------------------------
V.TS01
	LIS	R0,0
	STB	R0,SCBBLK+SCTSUG,R9,	:SET SEC_STAGING_IND,SEC_RCV_PACING_CNT
	STB	R0,SCBBLK+SCSRPC,R9,	:SET SEC_SEND_PACING_CNT
	LB	R1,SCBBLK+SCSSTY,R9,	:GET SCB.TYPE_OF_SESSION
	CLHI	R1,SSCPPU		:IS IT SSCP_PU SESSION?
	JNFS	V.TS31			:JUMP,IF NOT
	STB	R0,SCBBLK+SCSMRU,R9,	:SET SEC_SEND_MAX_RU_SIZE
	STB	R0,SCBBLK+SCPMRU,R9,	:SET PRI_SEND_MAX_RU_SIZE
V.TS31
	STB	R0,SCBBLK+SCTPUG,R9,	:SET PRI_STAGING_IND,PRI_SEND_PAC_CNT
	STB	R0,SCBBLK+SCPRPC,R9,	:SET PRI_RCV_PACING_CNT
	LHI	R0,IDENTI		:SET IDENTIFERS FOR SQN_USAGE
	STB	R0,SCBBLK+SCSQUS,R9,	:SET SCB.SQN_USAGE
	LB	R0,SCBBLK+SCTFFG,R9,	:SET RQ_CODE SUPPORTED IND.
:	SET SC_CLEAR,SC_RQR,SC_SDT AND SC_STSN TO NOT ALLOWED
	NHI	R0,@(SC.CLR+SC.RQR+SC.SDT+SC.STN+SC.CRV)
	STB	R0,SCBBLK+SCTFFG,R9,	:SET RQ_CODE SUPPORTED IND.
	JR	R5			:RETURN

:	SCB.TS_PROFILE=PROFILE_02
:	-------------------------
V.TS02
:	SCB.TS_PROFILE=PROFILE_03 (PAGE 13-81 ON FAPL -- TS_PROFILE_3)
:	-----------------------------------------------------------
V.TS03
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK FOR RRI
	JN	V.TS43			:JUMP,IF RRI=RSP
:	BIND REQUEST CONDITION
:	-----------------------
	LB	R0,BBUFER+BINTSU,R7,	:GET BIND REQUEST BYTE 8
	STB	R0,SCBBLK+SCTSUG,R9,	:SET SEC_STAGING_IND,SEC_RCV_PACING_CNT
	LB	R0,BBUFER+BINTSU+1,R7,	:GET BIND REQUEST BYTE 9
	STB	R0,SCBBLK+SCSRPC,R9,	:SET SEC_SEND_PACING_CNT
	LB	R0,BBUFER+BINTSU+2,R7,	:GET BIND REQUEST BYTE 10
	STB	R0,SCBBLK+SCSMRU,R9,	:SET SEC_SEND_MAX_RU_SIZE
	LB	R0,BBUFER+BINTSU+3,R7,	:GET BIND REQUEST BYTE 11
	STB	R0,SCBBLK+SCPMRU,R9,	:SET PRI_SEND_MAX_RU_SIZE
	LB	R0,BBUFER+BINTSU+4,R7,	:GET BIND REQUEST BYTE 12
	STB	R0,SCBBLK+SCTPUG,R9,	:SET PRI_STAGING_IND,PRI_SEND_PAC_CNT
	LB	R0,BBUFER+BINTSU+5,R7,	:GET BIND REQUEST BYTE 13
	STB	R0,SCBBLK+SCPRPC,R9,	:SET PRI_RCV_PACING_CNT
	LB	R0,BBUFER+BINCRP,R7,	:GET BIND REQUEST BYTE 26
	LR	R1,R0			:SAVE 
	NHI	R0,BD.CGL		:GET BIND.RQ_CRYPTOGRAPHY_LENGTH
	JE	V.TS53			:JUMP,IF CRYPTOGRAPHY.LENGTH=0
	NHI	R1,BD.CSL		:GET CRYPTOGRAPHY_SESSION_LEVEL
	STB	R1,SCBBLK+SCCYSL,R9,	:SET SESSION_LEVEL IN SCB
	LB	R0,BBUFER+BINCIP,R7,	:GET BIND REQUEST BYTE 27
	STB	R0,SCBBLK+SCCYEM,R9,	:SET ENCIPHER_METHOD,CIPHER_METHOD
	J	V.TS53			:JUMP FOR NEXT STEP
:	BIND RESPONSE CONDITION
:	-----------------------
V.TS43
	LB	R0,BBUFER+BIPTSU,R7,	:GET BIND RESPONSE BYTE 8
	STB	R0,SCBBLK+SCTSUG,R9,	:SET SEC_STAGING_IND,SEC_RCV_PACING_CNT
	LB	R0,BBUFER+BIPTSU+1,R7,	:GET BIND RESPONSE BYTE 9
	STB	R0,SCBBLK+SCSRPC,R9,	:SET SEC_SEND_PACING_CNT
	LB	R0,BBUFER+BIPTSU+2,R7,	:GET BIND RESPONSE BYTE 10
	STB	R0,SCBBLK+SCSMRU,R9,	:SET SEC_SEND_MAX_RU_SIZE
	LB	R0,BBUFER+BIPTSU+3,R7,	:GET BIND RESPONSE BYTE 11
	STB	R0,SCBBLK+SCPMRU,R9,	:SET PRI_SEND_MAX_RU_SIZE
	LB	R0,BBUFER+BIPTSU+4,R7,	:GET BIND RESPONSE BYTE 12
	STB	R0,SCBBLK+SCTPUG,R9,	:SET PRI_STAGING_IND,PRI_SEND_PAC_CNT
	LB	R0,BBUFER+BIPTSU+5,R7,	:GET BIND RESPONSE BYTE 13
	STB	R0,SCBBLK+SCPRPC,R9,	:SET PRI_RCV_PACING_CNT
V.TS53
	LHI	R0,SEQNUM		:SET SEQUENCE_NUMBERS
	LB	R1,NCBBLK+NDPUTY,R13,	:GET PU_TYPE FOR THIS PU
	CLHI	R1,PU.T1		:IS THIS PU_TYPE=T1?
	JNFS	V.TS63			:JUMP,IF NOT PU_T1
	LHI	R0,NOSEQU		:SET NO_SNF
V.TS63
	STB	R0,SCBBLK+SCSQUS,R9,	:SET SCB.SQN_USAGE
	LHI	R0,SC.CLR		:SET SC.CLEAR ALLOWED
	NHI	R0,@SC.RQR		:SET SC.RQR NOT ALLOWED
	OHI	R0,SC.SDT		:SET SC_SDT ALLOWED
	NHI	R0,@SC.STN		:SET SC_STSN NOT ALLOWED
	LB	R1,SCBBLK+SCCYSL,R9,	:GET CRYPTOGRAPHY_SESSION_LEVEL
	CLHI	R1,SELECT		:IS IT SELECTIVE?
	JE	V.TS23			:JUMP,IF SELECTIVE
	CLHI	R1,MANDAT		:IS ITS MANDATORY?
	JNFS	V.TS33			:JUMP,IF IT IS NOT MANDATORY
V.TS23
	OHI	R0,SC.CRV		:SET SC_CRV ALLOWED
V.TS33
	STB	R0,SCBBLK+SCTFFG,R9,	:SET RQ_CODE SUPPORTED IND.
	JR	R5			:RETURN

:	SCB.TS_PROFILE=PROFILE_04
:	-------------------------
V.TS04
:	SCB.TS_PROFILE=PROFILE_05
:	-------------------------
V.TS05
:	SCB.TS_PROFILE=PROFILE_07
:	-------------------------
V.TS07
:	SCB.TS_PROFILE=PROFILE_17
:	-------------------------
V.TS17
	JR	R5			:RETURN

:	V.RSVC	-UTILITY ROUTINE TO CALL #FSM_SESS (OPTION???)
:	AND SEND 'RESET' TO #SVC_MGR
:	------------------------------------------------------
:	THE USAGE OF REGISTERS -
:	INPUT	-
:	OUTPUT	-
:	LINK	-R15 (R15 NEEDS TO BE SAVED BEFORE BEING CALLED)
V.RSVC
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS INDEX
	LHI	R0,FS.HRT		:SET UP SIGNAL FOR RESET HIERARCHICAL
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM_SESS ROUTINE
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	S.PCR1			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LB	R2,SCBBLK+SCSVMV,R9,	:GET #SVC_MGR FOR DESTINATION PROC.
	LHI	R0,SG.RES		:SET 'RESET' FOR FSM INPUT
	LHI	R1,PMCSMR		:GET SENDING PROCEDURE #
	ST	R9,BBUFER+DQSCB,R3,	:STORE SCB PTR INTO DQE
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	BBSTOR	R7,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	STH	R7,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO NULL
	STB	R7,BBUFER+DQNWCM,R3,	:SET NETWORK CMD TO NULL
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	JR	R15			:RETURN

:	V.SCER	-UTILITY ROUTINE TO SEND 'SG.ERR' TO LU.SVC_MGR
:	DURING LU_LU SESSION
:	------------------------------------------------------
:	THE USAGE OF REGISTERS -
:	INPUT	-R0 (SIGNAL FOR SVC.MGR) R1 (SENDING PROCEDURE)
:	OUTPUT	-
:	LINK	-R8
V.SCER
	ST	R8,SAVRG8,,
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	S.PCR1			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
:	LB	R2,SCBBLK+SCSVMV,R9,	:GT DST SVC_MGR (01/08/86 MIA)
	LHI	R2,LURCV		:DEST SRV_MGR (01/08/86 MIA)
	ST	R9,BBUFER+DQSCB,R3,	:STORE SCB PTR INTO DQE
	STH	R15,BBUFER+DQLUCB,R3,	:SET LUCB PTR
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	BBSTOR	R7,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	STB	R7,BBUFER+DQNWCM,R3,	:SET NETWORK CMD TO NULL
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	L	R8,SAVRG8,,		:GET BACK REGISTER
	JR	R8			:RETURN

:	V.SSVC	-UTILITY ROUTINE TO CALL #FSM_SESS,AND SEND MU
:	TO #SVC_MGR
:	------------------------------------------------------
:	THE USAGE OF REGISTERS -
:	INPUT	-R15 (LUCB_PTR) R9 (SCB_PTR) R10 (MUCB_PTR)
:	OUTPUT	-
:	LINK	-R7 (R7 NEEDS TO BE SAVED BEFORE BEING CALLED)
V.SSVC
	ST	R7,SAVRG7,,
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LB	R2,SCBBLK+SCSVMV,R9,	:GET #SVC_MGR FOR DESTINATION PROC.
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,PMCSMR		:GET SENDING PROCEDURE #
	JAL	R8,D.FSEN,,		:CALL COMMON SEND ROUTINE
	L	R7,SAVRG7,,
	JR	R7			:RETURN

:	ROUTINE TO FIND THE LUCB WHICH MATCHS THE CURRENT SCB
:	-----------------------------------------------------------
:	INPUT	-R8 (FOR PUCTAB PTR) R9 (FOR SCB_PTR) R15 (FOR 1ST LUCTAB PTR)
:	LINK	-R5
R.SCLU
	LIS	R2,1			:SET R2 TO 1ST LU
R.SCL1
	AHI	R15,LUCLEN		:GET NEXT LUCB PTR
	LB	R4,LUCTAB+LUCADR,R15,	:GET THIS LU RELATIVE TO PU
	CLB	R4,SCBBLK+SCMYID,R9,	:IS EQU TO LU IN SCB
	JER	R5			:JUMP,IF FIND THE MATCHED ONE
	AIS	R2,1			:INC. LU PROCESSED #
	CLB	R2,PUCTAB+PUMLUN,R8,	:IS FINISHED?
	JL	R.SCL1			:CONTINUE,IF NOT FINISHED
	J	S.PCRA			:CRASH,CAN'T MATCH SCB ID TO LUCB #

:	V.SNNW	-ROUTINE TO SEND CMD TO NETWORK IO
:	------------------------------------------------------
:	INPUT	-R15 (LUCB POINTER) R1 (CMD TYPE) R3 (CMD INFORMATION)
:		 R0 (SENSE CODE FOR NEGATIVE RSP)
:	LINK	-R8
V.SNNW
	JAL	R4,GETCL,,		:GET COMMAND LIST
	J	S.PCRA			:CRASH,IF EMPTY
	LHL	R7,LUCTAB+LUNWCP,R15,	:GET PUT PTR
	STB	R1,CMDBLK+CLCMD,R7,	:SET COMMAND TYPE
	STB	R3,CMDBLK+CLCMDS,R7,	:SET COMMAND INFORMATION
	LIS	R0,0			:INITIAL VALUE
	STH	R0,CMDBLK+CLLNG,R7,	:CLEAR CMD CATEGORY
	BBSTOR	R0,CMDBLK+CLARG,R7,	:STORE COMMAND RELATED INF.
	STH	R6,CMDBLK+CLPTR,R7,	:LINK NEW ENTRY
	STH	R6,LUCTAB+LUNWCP,R15,	:UPDATE NEW PUT PTR
	STH	R6,LUCTAB+LUNWCR,R15,	:UPDATE NEW RELEASE PTR
	LHL	R2,LUCTAB+LUCT.N,R15,	:GET REL. # FOR THIS LU IN ALL LU'S
	SBT	R2,CPSNNW,,		:SET DATA PRESENT FOR NIO
	JR	R8			:RETURN

:	THIS ROUTINE IS USED TO SUPPORT FM PROFILE SEARCH
:	-----------------------------------------------------------
:	INPUT	-R0 (PROFILE TYPE)
:	LINK	-R4
:	OUTPUT	-R2 (INDEX TO TB.FMP)
V.FMSH
	LHI	R2,TB.FML-1
V.FMS1
	CLB	R0,TB.FMP,R2,		:CHECK CURRENT PROFILE TO TABLE
	JER	R4			:YES,RETURN
	SIS	R2,1
	JGEBS	V.FMS1
	LHI	R2,TB.FML
	JR	R4			:RETURN

:	THIS ROUTINE IS USED TO SUPPORT TS PROFILE SEARCH
:	-----------------------------------------------------------
:	INPUT	-R0 (PROFILE TYPE)
:	LINK	-R4
:	OUTPUT	-R2 (INDEX TO TB.TSP)
V.TSSH
	LHI	R2,TB.TSL-1
V.TSS1
	CLB	R0,TB.TSP,R2,		:CHECK CURRENT PROFILE TO TABLE
	JER	R4			:YES,RETURN
	SIS	R2,1
	JGEBS	V.TSS1
	LHI	R2,TB.TSL
	JR	R4			:RETURN

	SUBTTL	SCB RELATED UTILITY ROUTINES

:	*****GET ONE FREE SCB AND CREATE SESSION_ID,#FSM_SESS*****
:	V.SCCR	-(SCB_CREATE) CREATES AN SCB AND INITIALIZES THE SCB
:	ACCORDING TO THE TYPE OF SESSION THAT WILL BE SUPPORTED.
:	ALLOCATES SPACE FOR THE TCCB TO SUPPORT TRANSMISSION LAYER.
:	PAGE 13-86 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS-
:	INPUT	-R13 (NCB PTR) R10 (MUCB_PTR) R15 (LUCB_PTR)
:	OUTPUT	-R9 (SCB PTR) NORMAL RETURN (SCB_PTR=NULL),ELSE,SKIP RETURN
:	LINK	-R6 (RETURN ADDRESS)
V.SCCR
	LB	R1,NCBBLK+NDDEVN,R13,	:GET LU & PU # IN THIS NODE
	SRHLS	R1,4
	STB	R1,SCATIM,,		:SAVE SCB_LST LOOP CNT
	LIS	R5,0
V.SCCE
	SLHLS	R5,2			:FW INDEX(03/02/85/CHS)
	L	R1,NCBBLK+NDSCLS,R5,R13,:GET SCB_LST
	SRHLS	R5,2			:SHIFT R5 BACK(03/02/85/CHS)
	XI	R1,NEGONE		:GET FREE SCB_LIST BITS
	JFFO	R1,V.SCC1		:JUMP,ON FINDING SCB FREE
:	AIS	R5,1			:(5/16/85/CHS)
	CLB	R5,SCATIM,,		:CHECK END OR NOT
	JGE	V.SCC0
	AIS	R5,1			:NEXT FW (5/16/85/CHS)
	J	V.SCCE			:ELSE ,CONTINUE
V.SCC1
	LR	R0,R2
:	(4/21/86/CHS)
:	IF FWSCB IS 1, SCBPTR'S ARE IN FULL-WORD
	IF	FWSCB
	SLHLS	RNODE,1			:MAKE FW INDEX
	L	R9,SCBPTR,RNODE,RNODE	:GET PTR TO SCB TABLE AREA
	SRHLS	RNODE,1
	ELSE
	LHL	R9,SCBPTR,RNODE,RNODE	:GET PTR TO SCB TABLE AREA
	EI	(FWSCB)
	LHI	R8,SCLENG		:GET LENGTH OF SCB
	LR	R4,R5			:SAVE CURRENT SCB_LST LOOP PTR
:	SLHLS	R4,4			:(03/02/85/CHS)
	SLHLS	R4,5			:(03/02/85/CHS)1 FW = 32 BITS
	AR	R0,R4			:ADD OFFSET TO SCB_LST
	LB	R1,NCBBLK+NDDEVN,R13,	:GET LU & PU # IN THIS NODE
	SLHLS	R1,1
	CR	R1,R0			:IS RELATIVE # OF SCB IN RANGE?
	JL	V.SCC0			:JUMP,IF OUT OF RANGE
	MHR	R0,R8
	AR	R9,R0
:	R3 (SCB_LIST PTR) R2 (INDEX OF CURRENT SCB IN SCB_LIST)
:	R9 (CURRENT SCB PTR)
:	-------------------------------------------------------------
	LHL	R1,SCBBLK+SCTCCB,R9,	:GET SCB.TC_CB_PTR
:	CLHI	R5,BFSESS		:IS THIS CALLED BY BF_SESS?
:	JNFS	.+8			:JUMP,IF NOT BF_SESS
:	L	R1,SCBBLK+SCSTBC,R9,	:GET SEC_TO_BF_TC_CB_PTR
	LR	R1,R1			:IS TCCB PTR=NULL?
	JGE	V.SCC2			:JUMP,IF NOT SEC_TO_BF_TC_CB_PTR=NULL
:	IF SCB.TC_CB_PTR=NULL,DISCARD SCB
:	IF SCB.SEC_TO_BF_TC_CB_PTR=NULL,DISCARD SEC_TO_BF_TC_CB_PTR
:	-----------------------------------
V.SCC0
	LCS	R9,1			:RESET SCB_PTR TO NULL
:	CHECK SCB_PTR AGAIN
:	--------------------
V.SCC2
	LR	R9,R9			:IS SCB_PTR=NULL?
	JLER	R6			:YES,RETURN
:	O.K. CONDITION, SET SCB_LIST PTR TO IND. THIS SCB BEEN ASSIGNED
:	--------------------------------------------------------
:	STB	R2,SCBBLK+SCBREL,R9,	:SET RELATIVE SCB # IN NODE
	SLHLS	R5,2			:SHIFT INDEX FOR FULLWORD OFFSET
	SBT	R2,NCBBLK+NDSCLS,R5,R13,:SET SCB TO 'NOT FREE'
	LB	R1,NCBBLK+NDPUTY,R13,	:GET PU_TYPE FOR THIS PU
	CLHI	R1,PU.T1		:IS THIS PU_TYPE=T1?
	JE	V.SCC3			:JUMP,IF YES
	CLHI	R1,PU.T2		:IS THIS PU_TYPE=T2?
	JE	V.SCC4			:JUMP,IF IT IS T2
	CLHI	R1,PU.T4		:IS THIS PU_TYPE=T4?
	JE	V.SCC6			:JUMP,IF IT IS T4
	CLHI	R1,PU.T5		:IS THIS PU_TYPE=T5?
	JE	V.SCC6			:JUMP,IF IT IS T5
	J	S.PCRA			:CRASH,IF NODE TYPE ERROR
:	NCB.PU_TYPE=T1
:	--------------
V.SCC3
	LB	R4,BBUFER+MULSID,R10,	:GET CONTAINT OF LSID
	STB	R4,SCBBLK+SCLSID,R9,	:SCB.LOCAL_SESSION_ID=LSID
	J	V.SCC8			:JUMP TO CONTINUE
:	NCB.PU_TYPE=T2
:	--------------
V.SCC4
	LB	R0,BBUFER+MUDADP,R10,	:GET DAFPRIME IN R0
	LB	R4,BBUFER+MUOADP,R10,	:GET OAFPRIME
	LB	R3,BBUFER+MUDIRE,R10,	:GET MUCB.DIRECTION
	JE	V.SCC5			:JUMP,IF IT IS SEND
	STB	R0,SCBBLK+SCMYID,R9,	:SET SCB.THIS_ID=DAFPRIME
	STB	R4,SCBBLK+SCOTID,R9,	:SET SCB.PARTNER_ID=OAFPRIME
	J	V.SCC8			:JUMP TO CONTINUE
V.SCC5
	STB	R0,SCBBLK+SCOTID,R9,	:SET SCB.PARTNER_ID=DAFPRIME
	STB	R4,SCBBLK+SCMYID,R9,	:SET SCB.THIS_ID=OAFPRIME
	J	V.SCC8
:	NCB.PU_TYPE=T4|T5
:	-----------------
V.SCC6
	IF	FN.BND			:IF SWITCH IS ON
	LCS	R0,0
	STH	R0,SCBBLK+SCVRBP,R9,	:SET SCB.VRCBPTR TO NULL
	L	R0,BBUFER+MUOSAF,R10,	:GET OSAF IN R0
	L	R4,BBUFER+MUDSAF,R10,	:GET DSAF (R4)
	LHL	R1,BBUFER+MUOEAF,R10,	:GET OEF (R1)
	LHL	R3,BBUFER+MUDEAF,R10,	:GET DEF(R3)
	LB	R2,BBUFER+MUDIRE,R10,	:GET MUCB.DIRECTION
	JE	V.SCC7			:JUMP,IF IT IS SEND
:	NCB.PU_TYPE=T4|T5 & MUCB.DIRECTION=RECEIVED
:	---------------------------------------
	ST	R0,SCBBLK+SCPTSA,R9,	:SCB.PARTNER_SA=OSAF
	ST	R4,SCBBLK+SCNYSA,R9,	:SCB.THIS_SA=DSAF
	STH	R1,SCBBLK+SCPTEA,R9,	:SCB.PARTNER_EA=OEF
	STH	R3,SCBBLK+SCMYEA,R9,	:SCB.THIS_EA=DEF
	J	V.SCC8
	ELSE
	J	V.SCC4			:ASSUME PU_TYPE=T2 TO SET UP ADDRESS
	EI
:	NCB.PU_TYPE=T4|T5 & MUCB.DIRECTION=SEND
:	---------------------------------------
V.SCC7
	ST	R4,SCBBLK+SCPTSA,R9,	:SCB.PARTNER_SA=DSAF
	ST	R0,SCBBLK+SCNYSA,R9,	:SCB.THIS_SA=OSAF
	STH	R3,SCBBLK+SCPTEA,R9,	:SCB.PARTNER_EA=DEF
	STH	R1,SCBBLK+SCMYEA,R9,	:SCB.THIS_EA=OEF
:	SELECT (RQ_CODE)
:	=================
V.SCC8
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU PTR FROM MUCB
	LB	R0,BBUFER,R3,		:GET RQ_CODE FROM RU
	CLHI	R0,ACTLU		:IS RQ_CODE=ACTLU?
	JE	V.SCC9			:JUMP,IF IT IS ACTLU
	CLHI	R0,ACTPU		:IS RQ_CODE=ACTPU?
	JE	V.SCCA			:JUMP,IF IT IS ACTPU
	CLHI	R0,BIND			:IS RQ_CODE=BIND?
	JE	V.SCCB			:JUMP,IF IT IS BIND
	CLHI	R0,ACCDRM		:IS RQ_CODE=ACTCDRM?
	JNR	R6			:RETURN,IF IT IS NOT ACTCDRM
:	RQ_CODE=ACTCDRM
:	---------------
	JR	R6			:NORMAL RETURN FOR ERROR????
:	LHI	R0,FSCSSP		:FSM_SESS_SSCP_SSCP_PRI_OR_SEC
:	J	V.SCCC
:	RQ_CODE=ACTLU
:	-------------
V.SCC9
:	CLHI	R5,HALFSS		:IS CB_TYPE=HALF_SESSION?
:	JEFS	.+0A			:JUMP,IF IT IS HALF_SESSION
:	LHI	R0,FSCBSL		:FSM_SESS_BF_CP_LU
:	J	V.SCCC			:SETUP ENTRY PTR FOR SCB.#FSM_SESS
	BBSSCB	R9,LUCTAB+LUSSCB,R15,	:STORE SCB_PTR INTO LUCB
	LHI	R1,SSCPLU		:SSCP_LU SESSION
	LHI	R0,FSCSLP		:FSM_SESS_CP_LU_PRI
	LHI	R2,CG.LU		:SET RESOURCE CATEGORY TO LU
	LB	R3,BBUFER+MUDIRE,R10,	:GET MUCB.DIRECTION
	JE	V.SCCC			:JUMP,IF IT IS SEND
	LHI	R0,FSCSLS		:FSM_SESS_CP_LU_SEC
	J	V.SCCC			:JUMP TO SETUP INDEX
:	RQ_CODE=ACTPU
:	-------------
V.SCCA
:	CLHI	R5,HALFSS		:IS CB_TYPE=HALF_SESSION?
:	JEFS	.+0A			:JUMP,IF IT IS HALF_SESSION
:	NEED TO CHECK NRCB.RESOURCE_TYPE=T2 ?????
:	LHI	R0,FSCBS2		:FSM_SESS_BF_CP_PU_T2
:	J	V.SCCC			:SETUP ENTRY PTR FOR SCB.#FSM_SESS
	LHI	R0,FSCSPP		:FSM_SESS_CP_PU_PRI
	LHI	R1,SSCPPU		:SSCP_PU SESSION
	LHI	R2,CG.SCP		:SET RESOURCE CATEGORY TO SSCP
	LB	R3,BBUFER+MUDIRE,R10,	:GET MUCB.DIRECTION
	JE	V.SCCC			:JUMP,IF IT IS SEND
	LHI	R0,FSCSPS		:FSM_SESS_CP_PU_SEC
	LHI	R2,CG.PU		:SET RESOURCE CATEGORY TO PU
	J	V.SCCC			:JUMP TO SETUP INDEX
:	RQ_CODE=BIND
:	------------
V.SCCB
:	CLHI	R5,HALFSS		:IS CB_TYPE=HALF_SESSION?
:	JEFS	.+0A			:JUMP,IF IT IS HALF_SESSION
:	LHI	R0,FSCBLL		:FSM_SESS_BF_LU_LU
:	J	V.SCCC			:SETUP ENTRY PTR FOR SCB.#FSM_SESS
	BBSSCB	R9,LUCTAB+LULSCB,R15,	:STORE SCB_PTR INTO LUCB
	STH	R15,SCBBLK+SCBLUC,R9,	:STORE LUC OFFSET INTO SCB (6/29/84/CHS)
	LHI	R0,FSCLLP		:FSM_SESS_LU_LU_PRI
	LHI	R2,CG.LU		:SET RESOURCE CATEGORY TO LU
	LHI	R1,LULU			:SETUP LU_LU SESSION
	LB	R3,BBUFER+MUDIRE,R10,	:GET MUCB.DIRECTION
	JEFS	V.SCCC			:JUMP,IF IT IS SEND
	LHI	R0,FSCLLS		:FSM_SESS_LU_LU_SEC
V.SCCC
	STB	R1,SCBBLK+SCSSTY,R9,	:SET SESSION TYPE
	STB	R0,SCBBLK+SCFSMS,R9,	:SETUP SCB.#FSM_SESS INDEX
	STB	R2,NCBBLK+NDRCAT,R13,	:SETUP RESOURCE CATEGORY
	LB	R0,SCBBLK+SCACFG,R9,	:GET ACTIVATION FLAG
:	MASK OUT HAL_SESSION,HAL_SESSION TYPE
	NHI	R0,@(SC.BFS+SC.SES)
	LB	R3,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JNFS	V.SCCH			:JUMP,IF IT IS RCV
	OHI	R0,SC.SES		:SET TO PRIMARY
V.SCCH
	STB	R0,SCBBLK+SCACFG,R9,	:SET HALF_SESSION IN SCB
	J	4,R6			:SKIP RETURN,IF SCB_PTR IS OK

:	*****UPDATE THE CONTAINTS OF N BYTES IN SCB*****
:	V.SCUP	-SCB MULTIPLE BYTES UPDATE ROUTINE
:	--------------------------------------------------------------
:	INPUT	-R7 (RU_PTR) R6 (1ST BYTE LOCATION IN RU)
:		 R3 (1ST LEVEL CALL) R4 (2ND LEVEL CALL) R9 (SCB_PTR)
:		 R2 (END OF OFFSET) R1 (BEGINNING OF OFFSET)
:	LINK	-R5 (RETURN)
:	WORKING	-R0,R1
V.SCUP
	CR	R1,R2			:CHECK END OF OFFSET
	JGE	S.PCRA			:CRASH,IF END OF OFFSET ERROR
V.SCU1
	LB	R0,BBUFER,R6,R7		:GET BYTE FROM RU
	STB	R0,SCBBLK,R1,R9		:STORE BYTE INTO SCB
	AIS	R6,1			:UPDATE BYTE LOCATION IN RU
	AIS	R1,1			:UPDATE OFFSET IN SCB
	CR	R1,R2			:IS FINISH?
	JL	V.SCU1			:JUMP TO CONTINUE FOR NEXT
	JR	R5			:RETURN,IF FINISH

	SUBTTL	ROUTINES TO HANDLE ERROR RECOVERY

:	ROUTINE TO SCAN ALL THE LU IN CURRENT NODE WHEN
:	SVC.MGR RECEIVED LINK CMD FROM NIO
:	-------------------------------------------------
:	INPUT	-R12,R15,R14
:	OUTPUT	-
:	LINK	-R7
V.LDWN
	ST	R7,RGSAV7,,		:SAVE RETURN ADDRESS
	LIS	R0,0
	STB	R0,SCATIM,,		:SET UP CURRENT SCAN PTR
	LHL	R8,PUCPTR,RNODE,RNODE	:GET PUCPTR FOR THIS NODE
	LHL	R15,PUCTAB+PUCLUC,R8,	:GET 1ST LUCB FOR THIS NODE
	LB	R0,PUCTAB+PUMLUN,R8,	:GET TOTAL NUMBER OF LU
	STB	R0,SCAEND,,		:SET UP END PTR FOR SCANNING
V.LDW0
	LB	R1,SCATIM,,		:GET CURRENT SCAN PTR
	AIS	R1,1			:FOR NEXT ONE
	CLB	R1,SCAEND,,		:IS TIME TO BE FINISHED?
	JGE	V.LDW3			:JUMP,IF YES
	STB	R1,SCATIM,,		:SAVE CURRENT LU
	AHI	R15,LUCLEN		:FOR CURRENT LUCTAB PTR
	BBLSCB	R9,LUCTAB+LULSCB,R15,	:GET LU_LU SCB_PTR
	JE	V.LDW1			:JUMP,IF NO LU-LU SCB
	LB	R0,NCBBLK+NDRSTF,R13,	:GET COUNTER (7/23/84/CHS)
	AIS	R0,1			:INCREASE COUNTER (7/23/84/CHS)
	STB	R0,NCBBLK+NDRSTF,R13,	:UPDATE COUNTER(7/23/84/CHS)
	LHI	R0,SG.LDW		:SET UP SIGNAL
	LHI	R1,PMNSMS		:SET UP SENDING PROCESS
	JAL	R8,V.SCER,,		:CALL ROUTINE TO INF. LU
	JFS	V.LDWA			:JUMP TO CONTINUE (08/06/85 MIA)
V.LDW1	LR	R9,R15			:COPY LUCB PTR (08/06/85 MIA)
	JAL	R12,V.CLEA		:CLEAN UP LU SERVICE (08/06/85 MIA)
V.LDWA	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SSCB_PTR
	JE	V.LDW0			:JUMP,IF NO SSCP_LU
	JAL	R8,V.SCDS,,		:CALL DISCARD SCB_PTR
	JAL	R8,V.LUCL,,		:CLEAN UP LUCTAB
	LHL	R8,PUCPTR,RNODE,RNODE	:GET PUCPTR FOR THIS NODE
	LB	R0,PUCTAB+PUALUN,R8,	:GET ACTIVE LU #
	JLE	S.PCRA,,		:CRASH,IF NO ACTIVE LU
	SIS	R0,1
	STB	R0,PUCTAB+PUALUN,R8,	:DECREASE ACTIVE LU #
	J	V.LDW0			:GO FOR NEXT LU
V.LDW3
	LHL	R8,PUCPTR,RNODE,RNODE	:GET PUCPTR FOR THIS NODE
	LHL	R15,PUCTAB+PUCLUC,R8,	:GET 1ST LUCB FOR THIS NODE
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SCB_PTR FOR SSCP_PU
	JE	V.LDW4			:NO SCB_PTR
	JAL	R8,V.SCDS,,		:CALL DISCARD SCB_PTR
	JAL	R8,V.LUCL,,		:CLEAN UP LUCTAB
	LHI	R0,NN.PLW		:SET PENDING FOR LINK DOWN
	STB	R0,LUCTAB+LUSSTA,R15,	:SET TO PENDING FOR LKDW RSP
V.LDW4
:
:BEGIN (12/04/86 YLH)
:	FLUSH THE DLC->SNA RECEIVE QUEUE
:
	LHL	R9,PCBPTR,RNODE,RNODE	:GET ASSOCIATE PCBBLK POINTER
	LHL	R8,PCBBLK+PCQBRG,R9,	:GET DLC->SNA RCV Q GET PTR
V.LDW5	LHL	R4,PCBBLK+PCQBRR,R9,	:GET DLC->SNA RCV Q RELEASE PTR
	CR	R8,R4			:EMPTY QUEUE?
	JE	V.LDW6			:JUMP IF QUEUE IS EMPTY
	BBLOAD	R3,CMDBLK+CLARG,R8,	:GET POINTER TO DATA BUFFERS
	JAL	R5,R.PBBC,,		:RELEASE BUF CHAIN WITH DATA
	LR	R6,R8			:COPY POINTER TO CMD LINK
	LHL	R8,CMDBLK+CLPTR,R6,	:GET POINTER TO NEXT LINK
	JAL	R4,RELCL,,		:RELEASE THE LINK
	J	V.LDW5			:TRY NEXT CMD LINK
V.LDW6	STH	R8,PCBBLK+PCQBRG,R9,	:STORE DLC->SNA RCV Q GET PTR
	LHL	R9,PUCPTR,RNODE,RNODE	:GET ASSOCIATE PUCTAB POINTER
	LB	R5,PUCTAB+PUCT.N,R9,	:GET REL PU#
	RBT	R5,DPDLPC,,		:RESET DATA PRESENT FLAG
:
:END (12/04/86 YLH)
:
	L	R7,RGSAV7,,		:GET RETURN ADDRESS
	JR	R7			:RETURN

:	V.LUCL	-CLEAN UP LUCTAB DURING THE ERROR RECOVERY
:	---------------------------------------------------
V.LUCL
:	NEED TO CLEAN UP LUCB CMD QUEUE (RECEIVEING DIRECTION)
	LHI	R0,NN.RES		:CLEAR LUCB STATUS
	STB	R0,LUCTAB+LUSSTA,R15,	:CLEAR STATUS
	LIS	R0,0			:INIT VALUE
	BBSSCB	R0,LUCTAB+LUSSCB,R15,	:CLEAR SSCP_LU SCB_PTR
	ST	R8,RGSAV8,,		:SAVE RETURN ADDRESS
V.LUC1
	LHL	R6,LUCTAB+LUSNCG,R15,	:GET CMD QUEUE GET PTR
:	CLH	R6,LUCTAB+LUSNCR,R15,	:END OF QUEUE? (01/03/85 MIA)
	LHL	R7,LUCTAB+LUSNCR,R15,	:GET RL PTR (01/03/85 MIA)
	CR	R6,R7			:COMP POINTERS (01/03/85 MIA)
	JE	V.LUC2			:JUMP,IF FINISHED
	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMDLST PTR
	JE	S.PCRA			:CRASH,IF NXT CMD=NULL
	STH	R7,LUCTAB+LUSNCG,R15,	:UPDATE GET PTR
	JAL	R4,RELCL,,		:RELEASE CMDLST
	J	V.LUC1			:CONTINUE
V.LUC2
	LHL	R8,LUCTAB+LUCT.N,R15,	:GET REL LU # (03/12/85 MIA)
	RBT	R8,CPNWSN,,		:RESET CMD PRESENT (03/12/85 MIA)
	L	R8,RGSAV8,,		:GET RETURN ADDRESS
	JR	R8			:RETURN

:	ROUTINE TO SCAN ALL THE LU IN CURRENT NODE WHEN
:	SVC.MGR RECEIVED DEACT/ACT DURING LU_LU SESSION
:	-------------------------------------------------
:	INPUT	-R12,R15,R14,R1(CMD),R3(SUB-CMD)
:	OUTPUT	-
:	LINK	-R7
V.ALSC
	ST	R7,RGSAV7,,		:SAVE RETURN ADDRESS
	ST	R9,RGSAV9,,		:SAVE SCB_PTR
	LIS	R0,0
	STB	R0,SCATIM,,		:SET UP CURRENT SCAN PTR
	LHL	R8,PUCPTR,RNODE,RNODE	:GET PUCPTR FOR THIS NODE
	LHL	R15,PUCTAB+PUCLUC,R8,	:GET 1ST LUCB FOR THIS NODE
	LB	R0,PUCTAB+PUMLUN,R8,	:GET TOTAL NUMBER OF LU
	STB	R0,SCAEND,,		:SET UP END PTR FOR SCANNING
V.ALS0
	LB	R1,SCATIM,,		:GET CURRENT SCAN PTR
	AIS	R1,1			:FOR NEXT ONE
	CLB	R1,SCAEND,,		:IS TIME TO BE FINISHED?
	JGE	V.ALS3			:JUMP,IF YES
	STB	R1,SCATIM,,		:SAVE CURRENT LU
	AHI	R15,LUCLEN		:FOR CURRENT LUCTAB PTR
	BBLSCB	R9,LUCTAB+LULSCB,R15,	:GET LU_LU SCB_PTR
:LU_SVC NEEDS TO BE INFORMED OR CLEANED UP IMMEDIATELY (04/01/86 MIA).
:	JE	V.ALS1			:JUMP,IF NO LU-LU SCB
	JNFS	V.ALSX			:JUMP IF LU-LU ACTIVE
	LR	R0,R12			:SAVE THE REGISTER
	LR	R1,R9			:SAVE R9
	LR	R9,R15			:COPY LUCB POINTER
	JAL	R12,V.CLEA		:CLEAN UP LU_SVC
	LR	R9,R1			:RESTORE R9
	LR	R12,R0			:RESTORE R12
	JFS	V.ALS1			:JUMP TO CONTINUE
V.ALSX	EQ	.
:END OF INSERTION (01/04/86 MIA).
	LHI	R0,SG.ERR		:SET UP SIGNAL
	LHI	R1,PMNSMR		:SET UP SENDING PROCESS
	JAL	R8,V.SCER,,		:CALL ROUTINE TO INF. LU
V.ALS1
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SSCB_PTR
	JE	V.ALS0			:JUMP,IF NO SSCP_LU
	JAL	R8,V.SCDS,,		:CALL DISCARD SCB_PTR
:	POSSIBLE RACE CONDITION?????
:	----------------------------
	JAL	R8,V.LUCL,,		:CLEAN UP LUCB
	J	V.ALS0			:GO FOR NEXT LU
V.ALS3
	LHL	R8,PUCPTR,RNODE,RNODE	:GET PUCPTR FOR THIS NODE
	LHL	R15,PUCTAB+PUCLUC,R8,	:GET 1ST LUCB FOR THIS NODE
	L	R7,RGSAV7,,		:GET RETURN ADDRESS
	L	R9,RGSAV9,,		:GET ORIGINAL SCB_PTR
	JR	R7			:RETURN

:	COMMON ROUTINE FOR CURRENT LU TO INF. LU.SVC_MGR,AND NIO
:	-----------------------------------------------------------
V.ONSC
	ST	R7,RGSAV7,,
	ST	R9,RGSAV9,,		:SAVE SCB
	LR	R9,R4
	JAL	R8,V.SNNW,,		:SEND STATUS CMD TO NIO
	LHI	R0,SG.ERR		:SET 'SG.ERR' SIGNAL FOR SVC.MGR
	LHI	R1,PMNSMR		:SET SENDING PROCEDURE #
	JAL	R8,V.SCER,,		:JUMP TO INF LU.SVC_MGR
	L	R9,RGSAV9,,		:GET BACK SCB_PTR
	L	R7,RGSAV7,,
	JR	R7

:::::::::::::::::::::::::::::::::
:: THIS ROUTINE CLEANS NIO->SNA DATA QUEUE AND RESETS LU SERVICE
:: MANAGER STATE BYTES.
:::::::::::::::::::::::::::::::::

V.CLEA	EQ	.
V.CLE3	LHL	R8,LUCTAB+LUSNDG,R9,	:GET NTW->SNA DATA Q GET PTR
:V.CLE4	CH	R8,LUCTAB+LUSNDR,R9,	:COMP WITH REL (01/03/85 MIA)
V.CLE4	LHL	R4,LUCTAB+LUSNDR,R9,	:GETREL PTR (01/03/85 MIA)
	CR	R8,R4			:COMP POINTERS (01/03/85 MIA)
	JE	V.CLE6			:JUMP IF QUEUE IS EMPTY
	LH	R5,CMDBLK+CLCMD,R8,	:GET COMMAND
	JL	V.CLE5			:JUMP IF NO DATA BUFFER
	BBLOAD	R3,CMDBLK+CLARG,R8,	:GET POINTER TO DATA BUFFERS
	JAL	R5,R.PBBC,,		:RELEASE BUF CHAIN WITH DATA
V.CLE5	LR	R6,R8			:COPY POINTER TO CMD LINK
	LHL	R8,CMDBLK+CLPTR,R6,	:GET POINTER TO NEXT LINK
	JAL	R4,RELCL,,		:RELEASE THE LINK
	J	V.CLE4			:TRY NEXT CMD LINK
V.CLE6	STH	R8,LUCTAB+LUSNDG,R9,	:UPDATE NTW->SNA DATA Q GET PTR
	LHL	R5,LUCTAB+LUCT.N,R9,	:GET REL LU # (03/12/85 MIA)
	RBT	R5,DPNWSN,,		:RESET DATA PRESENT (03/12/85 MIA)

:RESET STATE FOR TERMINAL INTERFACE IS TRANSPARENT STATE.
:RESET STATE FOR HOST INTERFACE IS LOCAL STATE.
:SHOW IT IN LUSVC STATE BYTE. ALSO CLEAR LUSVC WORK BYTE.
	IF	TERMIF&HOSTIF
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JNFS	V.CLEK			:JUMP IF NOT
	EI
	IF	TERMIF
	GL	TRPSTA
	LHI	R5,TRPSTA		:PREPARE TRANSPARENT STATE
	EI
	IF	TERMIF&HOSTIF
	JFS	V.CLEL			:JUMP TO CONTINUE
	EI
	IF	HOSTIF
	GL	LOCSTA
V.CLEK	LHI	R5,LOCSTA		:PREPARE LOCAL STATE
	EI
V.CLEL	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	STB	R5,LUCTAB+LULUW1,R9,	:CLEAR LUSVC 2ND WORK BYTE
	JR	R12			:RETURN TO TIMEOUT SCHEDULER

S.PCRA
	JAL	R10,CRASH,,
	BC	0,0,0,CRQRES

S.PCR1
	J	NOENT5,,

	FO	CBKDEF
	FO	MAIN
	FO	GBLDEF
	FO	CMDLST

	EM

    
	SUBTTL	SNA PACKAGE(MAIN PROCESSES) - SSCP SERVICE MANAGER

:	**************************************************
:	REVISION HISTORY --
:	01/18/84 (NCS) -- ORIGINAL DESIGN AND CODING
:	****************************************************

	RA	0
	MO	.,SNAPKG

	LO	CMDLST
	LO	BBUFER
	LO	CBKDEF
	LO	GBLDEF

:	--------------------------------------------------------------------
:	THIS PACKAGE IS DESIGNED TO SUPPORT SSCP SERVICE MANAGER
:	(SSCP.SVC_MGR) WHICH CONTAINS-
:	S.SCXX -- SSCP.SVC_MGR.CS (CONFIGURATION SERVICE)
:	S.SMXX -- SSCP.SVC_MGR.MA (MAINTENANCE SERVICE)
:	S.SSXX -- SSCP.SVC_MGR.SS (SSCP SESSION SERVICE)
:	S.SGXX -- SSCP.SVC_MGR.MN (MANAGEMENT SERVICE)
:	-------------------------------------------------------------------
LNGFM	EQ	5			:ACTLU RESPOSNSE LONG FORM LENGTH
CNTLVT	EQ	8			:RU OFFSET FOR RSP(ACTLU) VECTOR KEY
VTDATF	EQ	2			:OFFSET FOR LU CAPABILITY
	SEG	A.CODE

:	S.SMRV	-(SSCP.SVC_MGR.MA.RCV) SSCP.SVC_MGR MAINTENANCE SERVICE.
:	-----------------------------------------------------------------
S.SMRV
:	S.SGRV	-(SSCP.SVC_MGR.MN.RCV) SSCP.SVC_MGR MANAGEMENT SERVICE.
:	-----------------------------------------------------------------
S.SGRV
:	S.SSRV	-(SSCP.SVC_MGR.SS.RCV) SSCP.SVC_MGR SESSION SERVICE.
:	-----------------------------------------------------------------
S.SSRV
	JR	R14			:RETURN

	SUBTTL	SSCP SERVICE MANAGER (CONFIGURATION SERVICE) -- RECEVING

:	S.SCRV	-(SSCP.SVC_MGR.CS.RCV) SSCP.SVC_MGR CONFIGURATION SERVICE.
:	PAGE 7-50 ON FAPL
:	-----------------------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-R13 (NCB-PTR) R12 (EV_PTR)
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-
S.SCRV
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.NOS		:IS IT NO_SIGN?
	JE	S.SCR0			:JUMP,IF IT IS

S.SCR0
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR FOR THIS SESSION
	JLE	S.CRAS			:CRASH,IF SCB_PTR NULL
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK OFF OTHER BITS
	JE	S.SCR2			:JUMP IF RRI<>RSP
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	LR	R4,R0			:SETUP R4 FOR WORKING REGISTER
	NHI	R4,MU.SC		:MASK OFF OTHER BITS
	CLHI	R4,MU.SC
	JN	S.SCR1			:JUMP,IF RU_CTGY<>SC
	BBLOAD	R1,BBUFER+MURUPT,R10,	:R1 CONTAINS RU PTR
	JLE	S.CRAS			:CRASH,IF SCB_PTR NULL
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,ACTPU		:IS RQ_CODE=ACTPU?
	JE	M.APRS			:JUMP,IF RQ_CODE=ACTPU
	CLHI	R0,DACTPU		:IS RQ_CODE=DACTPU?
	JE	M.DPRS			:JUMP,IF RQ_CODE=DACTPU
	CLHI	R0,ACTLU		:IS RQ_CODE=ACTLU?
	JE	M.ALRS			:JUMP,IF RQ_CODE=ACTLU
	CLHI	R0,DACTLU		:IS RQ_CODE=DACTLU?
	JE	M.DLRS			:JUMP,IF RQ_CODE=DACTLU
:	RU_CTGY<>SC,OR, RQ_CODE<>ACTPU|ACTLU|DACTPU|DACTLU
:	------------------------------------------------------
S.SCR1
	J	S.CRAS			:CRASH
:	RRI=RQ (RCV RQ FROM DEVICE)
:	-------------------------------
:	ONLY WHEN SON_CAUSE FOR VIRTUAL_ROUTE CONDITION HAPPENING
S.SCR2
	BBLOAD	R1,BBUFER+MURUPT,R10,	:R1 CONTAINS RU PTR
	JLE	S.CRAS			:CRASH,IF SCB_PTR NULL
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,DACTPU		:IS IT DACTPU RQ?
	JE	M.DPQR			:JUMP,IF IT IS DACTPU
	CLHI	R0,DACTLU		:IS IT DACTLU RQ?
	JE	M.DLQR			:JUMP IF YES
	J	S.CRAS			:ELSE CRASH

:	M.DPQR	-RECEIVE DACTPU REQUEST FROM PU_T2 (PAGE 7-52 ON FAPL)
:	=================================================================
M.DPQR
:	RQ_CODE = DACTPU
:	------------------
:	CHECK THE POSSIBLE CURRENT PU STATE,
:	(1)PU & LU IDLE,
:	(2)PU ACTIVE,LU IDLE,
:	(3)PU & LU ACTIVE,
:	(4)PU IDLE,LU ACTIVE,
:	------------------------------------------------------------
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	CLHI	R0,NN.APU		:IS CURRENT PU STATE ACTIVE?
	JN	S.CRAS			:JUMP TO CRASH (FOR DEBUGGING)
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	JN	S.CRAS			:IF PU ACTIVE,SOME LU STILL ACTIVE
	LHI	R0,NN.RES		:GET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE NEW STATE
	LIS	R0,0
	STB	R0,PUCTAB+PUALUN,R8,	:CLEAR ACTIVE LU #
	LHI	R0,TRUNCA		:SET 'TRUNCATE' PARAMETER
	JAL	R5,R.MUPR,,		:CALL CHANGE_MU_TO_POS_RSP(TRUNCATE)
	J	M.APP0			:JUMP TO SEND MU TO PU.CSC

:	M.DLQR	-RECEIVE DACTLU REQUEST FROM PU_T2 (PAGE 7-58 ON FAPL)
:	==============================================================
M.DLQR
:	RQ_CODE = DACTLU
:	------------------
:	CHECK THE POSSIBLE CURRENT PU STATE,
:	(1)PU & LU IDLE,
:	(2)PU ACTIVE,LU IDLE,
:	(3)PU & LU ACTIVE,
:	(4)PU IDLE,LU ACTIVE,
:	------------------------------------------------------------
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHL	R12,PUCTAB+PUCLUC,R8,	:GET 1ST LU TABLE PTR
	LB	R0,LUCTAB+LUSSTA,R12,	:NEW STATE FOR NODE CONTROL
	CLHI	R0,NN.APU		:IS CURRENT PU STATE ACTIVE?
	JN	S.CRAS			:JUMP TO CRASH (FOR DEBUGGING)
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	JE	S.CRAS			:IF PU ACTIVE,AND NO LU ACTIVE
	LHI	R0,NN.RES		:GET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE NEW STATE
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	SIS	R0,1
	STB	R0,PUCTAB+PUALUN,R8,	:UPDATE ACTIVE LU #
	LHI	R0,TRUNCA		:SET 'TRUNCATE' PARAMETER
	JAL	R5,R.MUPR,,		:CALL CHANGE_MU_TO_POS_RSP(TRUNCATE)
	J	M.APP0

:	RECEIVE ACTPU(RSP) FROM PERIPHERIAL DEVICE
:	===========================================
:	M.APRS	(CS.ACTPU_RSP) PAGE 7-54 ON FAPL
:	RECEIVE ACTPU RESPONSE FROM PU,THE FOLLOWING FUNCTIONS ARE PERFORMED
:	(1)SEND COMMAND LIST (COMMAND CODE--ACTPU,SCB PTR--SSCP_PU) TO 
:	   NETWORK MONITOR
:	(2)CHECK ACTPU RESPONSE TYPE AND OTHER PARAMETERS,IF NECESSARY,
:	   STORE THOSE INFORMATION IN SCB?????
M.APRS
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	JN	S.CRAS			:JUMP,IF STILL SOME LU ACTIVE
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT STATE FROM NODE CONTROL
	CLHI	R0,NN.PAP		:IS CURRENT PENDING FOR ACTPU RSP?
	JN	S.CRAS			:JUMP TO INF. NET CONTROL&DELETE MU
	LHI	R3,E.POSR		:SET CMD LIST INF.
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.RTI		:CHECK MU.RTI BIT
	JN	M.APR4			:RTI<>POS,JUMP TO SET ERROR CODE
:	UPDATE LUCB INFORMATION
:	-----------------------
	LHI	R0,NN.APU		:SET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	BBSSCB	R9,LUCTAB+LUSSCB,R15,	:SET SCB PTR IN LUCB
M.APR0
	LIS	R0,0
:	SEND COMMAND FROM SNA TO NIO
:	----------------------------
M.APR1
	LHI	R1,XINIT		:SETUP CMD TYPE INIT RSP
M.APR2
	JAL	R8,V.SNNW,,		:ROUTINE TO SEND CMD FROM SNA TO NIO
:	DISCARD MUCB PTR AND INPUT DATA FRAME
:	--------------------------------------
	JAL	R8,R.DSMU,,		:CALL DISCARD MU ROUTINE
	JR	R14			:RETURN
:	NETWORK CONTROL STATE NOT MATCH TO CURRENT RSP
:	----------------------------------------------
M.APR3
	LHI	R3,E.STAT		:SET UP STATE ERROR
	J	M.APR0			:SEND CMD TO NETWORK CONTROL
:	RESPONSE FROM DEVICE IS NEGATIVE
:	--------------------------------
:	THE SENSE CODES SHOULD BE PROCESSED FOR ERROR RECOVERY INF.
M.APR4
	LIS	R0,0
	BBSSCB	R0,LUCTAB+LUSSCB,R15,	:CLEAR SCB PTR IN LUCB
	LHI	R0,NN.RES		:SET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	LB	R0,BBUFER+MURHF1,R10,	:GET RH INF. FROM MUCB
	NHI	R0,MU.SDI		:MASK FOR SDI 
	JE	S.CRAS			:CRASH,WHEN SDI NOT SET
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE CODE FROM MUCB
	LHI	R3,E.NEGR		:SET UP NEGATIVE RSP
	J	M.APR1			:SEND CMD CODE TO NETWORK CONTROL

:	RECEIVE DACTPU(RSP) FROM PERIPHERIAL DEVICE
:	===========================================
:	M.DPRS	(CS.DACTPU_RSP) PAGE 7-56 ON FAPL
M.DPRS
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	JN	S.CRAS			:JUMP,IF STILL SOME LU ACTIVE
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT LU STATE
	CLHI	R0,NN.PDP		:IS PENDING FOR DACTPU RSP?
	JN	S.CRAS			:GOTO SET STATE ERROR
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.RTI		:CHECK MU.RTI BIT
	JN	M.DPR3			:RTI<>POS,JUMP TO SET ERROR CODE
:	UPDATE LUCB INFORMATION
:	-----------------------
	LHI	R0,NN.RES		:SET NEW STATE FOR IDLE LU
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	LIS	R0,0
	BBSSCB	R0,LUCTAB+LUSSCB,R15,	:CLEAR SCB PTR IN LUCB
:	DISCARD SCB_PTR
:	----------------
M.DPR0
	LHI	R3,E.POSR		:SET CMD LIST INF. FIELD
	JAL	R8,V.SCDS,,		:DISCARD SCB_PTR
	LIS	R0,0
M.DPR1
	LHI	R1,XCLOSE		:SET UP CMD SUBCMD TYPE
	J	M.APR2			:JUMP TO SEND CMD TO NIO AND DISCARD MU
M.DPR2
	LHI	R3,E.STAT		:SET UP STATE ERROR
	J	M.DPR1			:SEND CMD TO NETWORK CONTROL
:	RESPONSE FROM DEVICE IS NEGATIVE
:	--------------------------------
M.DPR3
	LHI	R0,NN.RES		:SET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	LB	R0,BBUFER+MURHF1,R10,	:GET RH INF. FROM MUCB
	NHI	R0,MU.SDI		:MASK FOR SDI 
	JE	S.CRAS			:CRASH,WHEN SDI NOT SET
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE CODE FROM MUCB
	LHI	R3,E.NEGR		:SET UP NEGATIVE RSP
	J	M.DPR1			:SEND CMD CODE TO NETWORK CONTROL

:	RECEIVE ACTLU(RSP) FROM PERIPHERIAL DEVICE
:	===========================================
:	M.ALRS	(CS.LU_RSP) PAGE 7-60 ON FAPL
:	(1)SSCP_LU IS NOT PENDING FOR ACTLU RSP
:	(2)SSCP_PU IS NOT ACTIVE
:	(3)CHECK THE RESPONSE TYPE
M.ALRS
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHL	R12,PUCTAB+PUCLUC,R8,	:GET 1ST LU TABLE PTR
	LB	R0,LUCTAB+LUSSTA,R12,	:GET CURRENT STATE FROM NODE CONTROL
	CLHI	R0,NN.APU		:IS PU STATE IN ACTIVE?
	JN	S.CRAS			:CRASH (PU IS NOT ACTIVE,RCV ACTLU)
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT LU STATE
	CLHI	R0,NN.PAL		:IS SSCP SEND OUT ACTLU?
	JN	S.CRAS			:CRASH,IF NOT
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.RTI		:CHECK MU.RTI BIT
	JN	M.APR4			:RTI<>POS,JUMP TO SET ERROR CODE
:
:BEGIN  (09/05/86 YLH)
:	POSITIVE ACTLU RESPONSE -
:	IF SHORT FORM THEN
:	  PREPARE TO SEND INIT POSITIVE RESPONSE TO THE NIO
:
	LHL	R0,LUCTAB+LUCT.N,R15,	:GET REL# OF LU
	RBT	R0,LUPOFF,,		:RESET LU POWER OFF BIT ARRAY
	RBT	R0,NFYPOF,,		:RESET NOTIFY POWER OFF
	LHL	R0,BBUFER+MUDCF,R10,	:GET BIU LENGTH
	CLHI	R0,LNGFM		:IF BIU LESS THAN 5, IT IS SHORT FORM
	JL	M.ALRC
:
:	RSP(ACTLU) LONG FORM -
:	CURRENTLY ONLY CONTROL VECTOR KEY '0C' AND SLU CAPABILITIES SUPPORTED
:
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R0,BBUFER+CNTLVT,R3,	:GET CONTROL VECTOR KEY
	CLHI	R0,0C			:CRASH, IF IT IS NOT 0C
	JN	S.CRAS
:
:	IF SLU CAN ACT AS SLU THEN
:	  PREPARE TO SEND INIT POSITIVE RESPONSE TO THE NIO
:	ELSE
:	  SET ACTLU LONG FORM RESPONSE POWER OFF INDICATOR
:	  DISCARD MUCB PTR AND INPUT DATA RAME
:
	LB	R0,BBUFER+CNTLVT+VTDATF,R3,	:GET VECTOR DATA FIELD
	NHI	R0,02			:CAN IT ACT AS SLU?
	JN	M.ALRC			:YES
	LHL	R0,LUCTAB+LUCT.N,R15,	:GET RELATIVE LU #
	SBT	R0,LUPOFF,,		:SET POWER OFF INDICATOR
	JAL	R8,R.DSMU,,		:DISCARD MUCB PTR AND DATA FRAME
	JR	R14
:
:END	(09/05/86 YLH)
:
:	UPDATE LUCB INFORMATION
:	------------------------
M.ALRC	LHI	R0,NN.ALU		:SET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	LB	R0,PUCTAB+PUALUN,R8,	:GET ACTIVE LU #
	BBSSCB	R9,LUCTAB+LUSSCB,R15,	:SET SCB PTR IN LUCB
	AIS	R0,1
	STB	R0,PUCTAB+PUALUN,R8,	:INCREASE ACTIVE LU #
	LHI	R3,E.POSR		:SET CMD LIST INF. FIELD
	J	M.APR0			:SEND CMD TO NIO
:	NETWORK CONTROL STATE NOT MATCH TO CURRENT RSP
:	----------------------------------------------
M.ALR0
	LHI	R3,E.STAT		:SET UP STATE ERROR
	J	M.APR1			:SEND CMD TO NETWORK CONTROL
:	RESPONSE FROM DEVICE IS NEGATIVE
:	--------------------------------
M.ALR1
	LHI	R0,NN.RES		:SET NEW STATE FOR IDLE LU
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	LHI	R3,E.NEGR		:SET UP NEGATIVE RSP
	J	M.APR1			:SEND CMD CODE TO NETWORK CONTROL

:	RECEIVE DACTLU(RSP) FROM PERIPHERIAL DEVICE
:	===========================================
:	M.DLRS	(CS.LU_RSP) PAGE 7-60 ON FAPL
:	(1)SSCP_PU IS NOT ACTIVE
:	(2)SSCP_LU IS NOT PENDING FOR DACTLU(RSP)
:	(3)CHECK RESPONSE TYPE
M.DLRS
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHL	R12,PUCTAB+PUCLUC,R8,	:GET 1ST LU TABLE PTR
	LB	R0,LUCTAB+LUSSTA,R12,	:GET CURRENT STATE FROM NODE CONTROL
	CLHI	R0,NN.APU		:IS PU STATE IN ACTIVE?
	JN	S.CRAS			:CRASH (PU IS NOT ACT.,RCV DACTLU)
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT LU STATE
	CLHI	R0,NN.PDL		:IS SSCP SEND OUT DACTLU?
	JN	S.CRAS			:CRASH,IF NOT
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	NHI	R0,MU.RTI		:CHECK MU.RTI BIT
	JN	M.DPR3			:RTI<>POS,JUMP TO SET ERROR CODE
:	UPDATE LUCB INFORMATION
:	-----------------------
	LB	R0,PUCTAB+PUALUN,R8,	:GET ACTIVE LU #
	SIS	R0,1
	STB	R0,PUCTAB+PUALUN,R8,	:DECREASE ACTIVE LU #
	LHI	R0,NN.RES		:SET NEW STATE FOR IDLE LU
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	LIS	R0,0
	BBSSCB	R0,LUCTAB+LUSSCB,R15,	:CLEAR SCB PTR IN LUCB
	J	M.DPR0			:JUMP TO DISCRAD SCB & SEND CMD TO NIO
:	NETWORK CONTROL STATE NOT MATCH TO CURRENT RSP
:	----------------------------------------------
M.DLR0
	LHI	R3,E.STAT		:SET UP STATE ERROR
	J	M.DPR1			:SEND CMD TO NETWORK CONTROL
:	RESPONSE FROM DEVICE IS NEGATIVE
:	--------------------------------
M.DLR1
	LHI	R3,E.NEGR		:SET UP NEGATIVE RSP
	J	M.DPR1			:SEND CMD CODE TO NETWORK CONTROL

	SUBTTL	SSCP SERVICE MANAGER (CONFIGURATION SERVICE) -- SENDING

:	S.SCSD	-(SSCP.SVC_MGR.CS.SEND) SSCP.SVC_MGR CONFIGURATION SERVICE.
:	RECEIVES ALL INPUT FROM NETWORK I/O (OR FROM NETWORK MONITOR),
:	AND ROUTES THE INPUT TO THE APPROPRIATE PROCEDURE FOR PROCESSING.
:	PAGE 7-48 ON FAPL
:	-----------------------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-R13 (NCB_PTR),R12 (EV_PTR)
S.SCSD
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.ZAP		:IS IT ZAPPER RESPONSE?
	JE	S.SCC0			:YES,JUMP TO SEND RSP FOR NIO
	CLHI	R1,SG.LDW		:IS IT LINK DOWN RESPONSE?
	JE	S.SCL1			:YES,JUMP TO SEND RSP FOR NIO
	CLHI	R1,SG.NOS		:IS IT OUT OF RANGE?
	JG	S.CRAS			:CRASH,IF YES
S.SCS0
:	GET EV.PARMPTR (CONTAINS CMD INF. OR DATA PTR)
:	GET EV.NWCMR (CONTAINS COMMAND TYPE).
:	GET EV.LUCB (CONTAINS LUCB PTR)
:	GET EV.MULN (CONTAINS DATA LENGTH)
:	GET PROPER ROUTINES TO HANDLE EACH COMMAND.
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	J	S.SCS1
	LB	R0,BBUFER+MUSCHK,R10,	:GET SEND_CHECK_SENSE BIT
	JN	S.CRAS			:CRASH,IF SEND_CHECK_SENSE SET
	J	S.CRAS			:SEND_CHECK_SENSE NOT SET,CRASH
S.SCS1
	LB	R1,EVBLK+EVNWCM,R12,	:GET CMD TYPE FROM EVBLK
	LHL	R2,EVBLK+EVMULN,R12,	:GET MSG LENGTH (ONLY FOR DATA)
	BBLOAD	R0,EVBLK+EVPRMP,R12,	:GET CMD INF. OR DATA LENGTH FROM EVBLK
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR
	CLHI	R1,MXSNNW		:IS IT OUT OF RANGE?
	JG	S.CRAS			:YES,CRASH
	LHL	R5,S.SCS2,R1,R1		:GET TABLE PTR FOR PROCESS
	J	S.SCS2,R5,		:JUMP TO ROUTINE
S.SCS2	HS
	HC	S.CRAS-S.SCS2		:ERROR COMMAND
	HC	M.APPR-S.SCS2		:INIT COMMAND
	HC	M.DPPR-S.SCS2		:CLOSE COMMAND
	HC	S.SCLD-S.SCS2		:LNK DOWN COMMAND
	HC	S.SCCD-S.SCS2		:CKT DOWN COMMAND

:	INIT COMMAND HANDLER
:	====================
:	M.APPR	-(CS.PU_PROC) HANDLES ACTPU OR DACTPU FROM NETWORK MONITOR
:	AND SEND ACTPU OR DACTPU TO PU.SVC_MGR.CSC_MGR.SEND
:	PAGE 7-52 ON FAPL
:	-------------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-R13(NCB_PTR),R10(MU_PTR),R15(LUCB_PTR)
M.APPR
	LB	R4,LUCTAB+LUCADR,R15,	:GET ASSIGNED LU NUMBER
	JN	M.ALPR			:JUMP,IF LU TYPE (LUCADR<>0) FOR LU
:	(1)INPUT IS ACTPU
:	   CHECK THE STATE OF CURRENT PU (IN LINENODE CONTROL BLOCK)
:	   IF PU ALREADY ACTIVE,SEND -ACTPU AND ERROR CONDITION TO NETWORK
:	   CONTROL (QUEUE THE CMD IN LINENODE CONTROL BLOCK COMMAD QUEUE).
:	   IF PU NOT ACTIVE,CREATE MU FOR ACTPU,AND SEND MU TO
:	   PU.SVC_MGR.CSC_MGR.SEND.
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SCB_PTR
	JG	S.CRAS			:SCB_PTR<>NULL IN LUCB,CRASH
	LB	R0,LUCTAB+LUSSTA,R15,	:GET STATUS OF CURRENT LU (PU)
	CLHI	R0,NN.RES		:IS IT RESET STATE?
	JN	S.CRAS			:JUMP,IF NOT CRASH??
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	JN	S.CRAS			:JUMP,IF STILL SOME LU ACTIVE
	LHI	R0,NN.PAP		:SET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	JAL	R4,GBB,,		:GET BIG BUFFERLET
	J	S.CRAS			:JUMP TO CRASH,IF NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LR	R10,R3			:SETUP MUCB PTR
	LIS	R0,0			:SET DAF
	LIS	R1,0			:SET OAF
	JAL	R8,R.CTRH,,		:SETUP TH & RH IN MUCB
:	JAL	R4,U.IAEX,,		:ASSIGN EXPEDITED SEQ. #
	LHL	R8,LUCTAB+LUAPLP,R15,	:GET ACTPU RQT STRING PTR
	AI	R8,SEG|A.CODE|
	LB	R2,0,R8,		:GET LENGTH OF STRING
:	SETUP R10 -- MUCB PTR, R2 -- STRING CNT, R8 -- STRING PTR
	JAL	R7,R.CRUU,,		:MOVE DATA INTO MUCB
M.APP0
	JAL	R4,GBB,,		:CREATE NEW DQE IN R3
	J	S.CRA1			:CRASH,IF NO ENTRY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LHI	R2,PMCSMS		:SET DEST. (PU.SVC_MGR.CSC_MGR.SEND)
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,SMCSMS		:GET SEND PROC. (SSCP.SVC_MGR.CS.SEND)
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MU PTR INTO DQE
	STH	R15,BBUFER+DQLUCB,R3,	:SET LUCB PTR
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	ST	R7,BBUFER+DQSCB,R3,	:SET SCB PTR TO 'NULL'
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQPRMP,R3,	:SET PARAMETER PTR TO 'NULL'
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	STB	R7,BBUFER+DQNWCM,R3,	:CLEAR NETWORK CMD
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT
	JR	R14			:RETURN

:	M.ALPR	-(CS.LU_PROC) HANDLES ACTLU OR DACTLU FROM NETWORK MONITOR
:	AND SEND ACTLU OR DACTLU TO PU.SVC_MGR.CSC_MGR.SEND
:	PAGE 7-58 ON FAPL
:	-------------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-
:	OUTLUT	-
:	LINK	-R14
:	WORKING	-
M.ALPR
:	CHECK TO SEE THIS LU IS ACTIVE OR NOT
:	(1) ACTIVE,INFORM NETWORK MONITOR THAT ERROR CONDITION?????
:	(2) RESET,UPDATE LU CURRENT STATE AND SEND ACTLU OR DACTLU TO
:	    PU.SVC_MGR.CSC_MGR.SEND
:	CHECK THE CMD TYPE FROM NETWORK MONITOR:?????
:	(1) ACTLU,CREATE MU(R10-ACTLU)
:	(2) DACTLU,CREATE MU (R10-DACTLU)
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SCB_PTR
	JG	S.CRAS			:SCB_PTR<>NULL IN LUCB,CRASH
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHL	R7,PUCTAB+PUCLUC,R8,	:GET 1ST LU CONTROL BLOCK PTR
	LB	R0,LUCTAB+LUSSTA,R7,	:GET PU CURRENT STATE
	CLHI	R0,NN.APU		:IS IT ACTIVE PU?
	JN	S.CRAS			:JUMP,IF NOT CRASH??
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT LU STATE
	CLHI	R0,NN.PDL		:CHECK STATE
	JGE	S.CRAS			:STATE IS NOT RIGHT
	LHI	R0,NN.PAL		:SET NEW STATE (PENDING FOR ACTLU)
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	JAL	R4,GBB,,		:GET BIG BUFFERLET
	J	S.CRAS			:JUMP TO CRASH,IF NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LR	R10,R3			:SETUP MUCB PTR
	LB	R0,LUCTAB+LUCADR,R15,	:GET LU # FOR DAF
	LIS	R1,0			:SET OAF
	JAL	R8,R.CTRH,,		:SETUP TH & RH IN MUCB
	LB	R0,LUCTAB+LUCADR,R15,	:GET REL LU# IN THIS NODE
	STB	R0,BBUFER+MUDADP,R10,	:SETUP DESTINATION ADDRESS
:	JAL	R4,U.IAEX,,		:ASSIGN EXPEDITED SEQ. #
	LHL	R8,LUCTAB+LUAPLP,R15,	:GET ACTLU RQT STRING PTR
	AI	R8,SEG|A.CODE|
	LB	R2,0,R8,		:GET LENGTH OF STRING
:	SETUP R10 -- MUCB PTR, R2 -- STRING CNT, R8 -- STRING PTR
	JAL	R7,R.CRUU,,		:MOVE DATA INTO MUCB
	J	M.APP0			:GOTO SEND MU TO PU.SVC_MGR.CSC.SEND

:	CLOSE COMMAND HANDLER
:	====================
:	M.DPPR	-(CS.PU_PROC) HANDLES DACTPU FROM NETWORK CONTROL
:	SEND DACTPU TO PU.SVC_MGR.CSC_MGR.SEND
:	---------------------------------------------------------
M.DPPR
	LB	R4,LUCTAB+LUCADR,R15,	:GET ASSIGNED LU NUMBER
	JN	M.DLPR			:JUMP,IF LU<>0 (FOR LU)
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SCB_PTR
	JE	S.CRAS			:SCB_PTR=NULL IN LUCB,CRASH
	LB	R0,LUCTAB+LUSSTA,R15,	:GET STATUS OF CURRENT LU (PU)
	CLHI	R0,NN.APU		:IS IT ACTIVE PU STATE?
	JN	S.CRAS			:JUMP,IF NOT CRASH??
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	JN	S.CRAS			:JUMP,IF STILL SOME LU ACTIVE
	LHI	R0,NN.PDP		:SET NEW STATE TO PENDING DACTPU RSP
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	JAL	R4,GBB,,		:GET BIG BUFFERLET
	J	S.CRAS			:JUMP TO CRASH,IF NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LR	R10,R3			:SETUP MUCB PTR
	LIS	R0,0			:SET DAF
	LIS	R1,0			:SET OAF
	JAL	R8,R.CTRH,,		:SETUP TH & RH IN MUCB
:	JAL	R4,U.IAEX,,		:ASSIGN EXPEDITED SEQ. #
	LHL	R8,LUCTAB+LUDPLP,R15,	:GET DACTPU RQT STRING PTR
	AI	R8,SEG|A.CODE|
	LB	R2,0,R8,		:GET LENGTH OF STRING
:	SETUP R10 -- MUCB PTR, R2 -- STRING CNT, R8 -- STRING PTR
	JAL	R7,R.CRUU,,		:MOVE DATA INTO MUCB
	J	M.DLP1			:GOTO SEND MU TO PU.SVC_MGR.CSC.SEND

:	M.DLPR	-(CS.PU_PROC) HANDLES DACTLU FROM NETWORK CONTROL
:	SEND DACTLU TO PU.SVC_MGR.CSC_MGR.SEND
:	---------------------------------------------------------
M.DLPR
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SCB_PTR
	JE	S.CRAS			:SCB_PTR=NULL IN LUCB,CRASH
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHL	R7,PUCTAB+PUCLUC,R8,	:GET 1ST LU CONTROL BLOCK PTR
	LB	R0,LUCTAB+LUSSTA,R7,	:GET PU CURRENT STATE
	CLHI	R0,NN.APU		:IS IT ACTIVE PU?
	JN	S.CRAS			:JUMP,IF NOT CRASH??
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT LU STATE
	CLHI	R0,NN.ALU		:CHECK STATE
	JN	S.CRAS			:STATE IS NOT RIGHT
	LHI	R0,NN.PDL		:SET NEW STATE (PENDING FOR DACTLU)
	STB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	JAL	R4,GBB,,		:GET BIG BUFFERLET
	J	S.CRAS			:JUMP TO CRASH,IF NO BUFFER
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LR	R10,R3			:SETUP MUCB PTR
	LB	R0,LUCTAB+LUCADR,R15,	:GET LU # FOR DAF
	LIS	R1,0			:SET OAF
	JAL	R8,R.CTRH,,		:SETUP TH & RH IN MUCB
	LB	R0,LUCTAB+LUCADR,R15,	:GET REL LU# IN THIS NODE
	STB	R0,BBUFER+MUDADP,R10,	:SETUP DESTINATION ADDRESS
:	JAL	R4,U.IAEX,,		:ASSIGN EXPEDITED SEQ. #
	LHL	R8,LUCTAB+LUDPLP,R15,	:GET DACTLU RQT STRING PTR
	AI	R8,SEG|A.CODE|
	LB	R2,0,R8,		:GET LENGTH OF STRING
:	SETUP R10 -- MUCB PTR, R2 -- STRING CNT, R8 -- STRING PTR
	JAL	R7,R.CRUU,,		:MOVE DATA INTO MUCB
M.DLP1
	LHI	R2,PMCSMS		:SET DEST. (PU.SVC_MGR.CSC_MGR.SEND)
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,SMCSMS		:GET SEND PROC. (SSCP.SVC_MGR.CS.SEND)
	JAL	R8,D.FSEN,,		:CALL SEND COMMON ROUTINE
	JR	R14			:RETURN

:	CKT DOWN COMMAND HANDLER
:	====================
:	(1)SSCP_LU ARE ACTIVE,SEND 'RESET' TO LU.SVC TO RESET
:	   SUBJECT LU_LU SESSION (CLEAR SCB,....)
:	(2)SSCP_PU IS ACTIVE,CLEAR SCB,UPDATE LUCB INFORMATION
S.SCCD
	LB	R4,LUCTAB+LUCADR,R15,	:GET ASSIGNED LU NUMBER
	JE	S.SCC1			:JUMP,IF LU=0 (PU)????
	BBLSCB	R9,LUCTAB+LULSCB,R15,	:GET SCB_PTR FOR LU_LU
	JE	S.SCC2			:IF NO LU_LU,JUMP
	LHI	R0,SG.ZAP		:ELSE,SEND 'SG.ZAP' FOR LU.SVC.MGR
	LHI	R1,SMCSMS		:SET SENDING PROCEDURE #
	JAL	R8,V.SCER,,		:JUMP TO INF LU.SVC_MGR
:	JAL	R5,IZSCB,,		:INIT SESSION CONTROL BLOCK
:	JAL	R5,IZPCB,,		:INIT PATH CONTROL BLOCK
:	JAL	R5,IZNCB,,		:INIT NODE CONTROL BLOCK
:	JAL	R5,IZEVB,,		:INIT ENVIRON CONTROL BLOCK
	JR	R14			:RETURN

:	NO LU_LU SESSION,RECEIVE CKT DOWN FROM NIO
:	------------------------------------------
S.SCC2
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SCB_PTR
	JE	S.SCC1			:JUMP,IF NO SSCP_LU SCB_PTR
	STM	R0,SLUSAV,,
	LR	R9,R15			:GET LUCTAB INTO R9
	JAL	R12,V.CLEA,,		:CALL LU.SVC CLEAN UP ROUTINE
	LM	R0,SLUSAV,,
:	JAL	R4,V.IZSC,,		:CALL SCB_PTR CLEAN UP
	J	S.SCC1			:JUMP TO SEND RSP TO NIO

:	NO CIRCUIT SETUP, RECEIVE XCKTDW CMD FOR THAT LU
:	------------------------------------------------
S.SCC0
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SCB_PTR
	JE	S.SCC1			:JUMP,IF NO SSCP_LU SCB_PTR
:	JAL	R4,V.IZSC,,		:CALL SCB_PTR CLEAN UP
:	SEND CKT DOWN RESPONSE TO NIO
:	-----------------------------
S.SCC1
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR
	LHI	R1,XCKTDW		:SETUP CMD RSP TO XCKTDW
:	LIS	R3,E.POSR		:SET UP FOR POSITIVE RESPONSE (04/03/87 YLH)
	LB	R3,LUCTAB+LUSSTA,R15,	:PASS CURRENT LUSSTA TO THE NIO (04/03/87 YLH)
	JAL	R8,V.SNNW,,		:ROUTINE TO SEND CMD FROM SNA TO NIO
	JR	R14			:RETURN

:	LINK DOWN COMMAND HANDLER
:	=========================
S.SCLD
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LB	R4,LUCTAB+LUCADR,R15,	:GET ASSIGNED LU NUMBER
	JN	S.CRAS			:CRASH,IF LU<>0,WHEN RCV LINKDOWN
	LB	R0,LUCTAB+LUSSTA,R15,	:SEE IF NN.PLW STATE (7/23/84/CHS)
	CLHI	R0,NN.PLW		:(7/23/84/CHS)
	JER	R14			:YES, RETURN (7/23/84/CHS)
	JAL	R7,V.LDWN,,		:INF. LU.SVC.MGR AGAIN
	LHL	R13,NCBPTR,RNODE,RNODE
	LB	R0,NCBBLK+NDRSTF,R13,	:ALL RSP'ED? (7/23/84/CHS)
	LR	R0,R0			:(7/23/84/CHS)
	JNR	R14			:NO, RETURN (7/23/84/CHS)
	LIS	R0,NN.RES		:SET STATE TO RESET(7/23/84/CHS)
	STB	R0,LUCTAB+LUSSTA,R15,	:(7/23/84/CHS)
	LHI	R1,XLNKDW		:INFORM NIO(7/23/84/CHS)
	JAL	R8,V.SNNW,,		:(7/23/84/CHS)
	JR	R14			:RETURN (7/23/84/CHS)
:	JR	R14			:RETURN

:	RECEIVE LINK DOWN RESPONSE FROM LU
:	----------------------------------
S.SCL1
:	(7/23/84/CHS) THE LOGIC IS MODIFIED
:	NEED TO SCAN ALL SCBS TO MAKE SURE FINISHED CLEAN UP
:	LB	R0,NCBBLK+NDDEVN,R13,	:GET DEVICE # FROM NCB
:	SRHLS	R0,4
:	STB	R0,SCATIM,,		:FOR SCB SCANE LOOP
:	LIS	R1,0
:	STB	R1,SCAEND,,		:INIT FOR 1ST SCB_LST IND.
:	L	R1,NCBBLK+NDSCLS,R1,R13	:GET NEW SCB_LIST 
:	ST	R1,SCASAV,,		:SAVE SCB_LIST IN SAVE AREA
:	JAL	R7,V.SLST,,		:CALL ROUTINE TO GET ANY SCB
:	LR	R9,R9
:	JGR	R14			:RETURN,IF NOT FINISHED YET
	LB	R0,NCBBLK+NDRSTF,R13,	:GET COUNTER (7/23/84/CHS)
	LR	R0,R0			:(7/23/84/CHS)
	JER	R14			:EXTRA, RETURN (7/23/84/CHS)
	SIS	R0,1			:DECREASE COUNTER (7/23/84/CHS)
	STB	R0,NCBBLK+NDRSTF,R13,	:(7/23/84/CHS)
	LR	R0,R0			:(7/23/84/CHS)
	JNR	R14			:NOT DONE, RETURN(7/23/84/CHS)
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHL	R15,PUCTAB+PUCLUC,R8,	:GET 1ST LU TABLE PTR
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT STATE
	CLHI	R0,NN.PLW		:IS IT PENDING FOR LINK RSP?
	JNR	R14			:JUMP,IF NOT
	LIS	R0,NN.RES
	STB	R0,LUCTAB+LUSSTA,R15,	:SET STATE TO RESET
	LHI	R1,XLNKDW		:SETUP CMD RSP TO XLNKDW
	LIS	R3,E.POSR		:SET UP FOR POSITIVE RESPONSE
	JAL	R8,V.SNNW,,		:ROUTINE TO SEND CMD FROM SNA TO NIO
	JR	R14			:RETURN
S.CRAS
	JAL	R10,CRASH,,
	BC	0,0,0,CRQSVC

S.CRA1
	J	NOENT5,,
	FO	CMDLST
	FO	BBUFER
	FO	CBKDEF
	FO	GBLDEF

	EM
  
	SUBTTL	SNA PACKAGE(MAIN PROCESSES) - PU SERVICE MANAGER

:	****************************************************
:	REVISION HISTORY --
:	01/18/84 (NCS) -- ORIGINAL DESIGN AND CODING
:	****************************************************

	RA	0
	MO	.,SNAPKG

	LO	CBKDEF
	LO	GBLDEF
	LO	CMDLST
	LO	OSCAN			:(01/27/87 YLH)
	LO	MAIN
	GL	HSTINI
:	--------------------------------------------------------------------
:	THIS PACKAGE IS DESIGNED TO SUPPORT PU SERVICE MANAGER WHICH CONTAINS-
:	S.PCXX -- PU.SVC_MGR.CSC_MGR 
:	S.PRXX -- PU.SVC_MGR.PC_ROUTE_MGR
:	S.PNXX -- PU.SVC_MGR.NS
:	S.PLXX -- PU.SVC_MGR.LINK_MGR
:	-------------------------------------------------------------------

	SEG	A.DATA

	SEG	A.CODE

:---------------------------------------------------------------------:
:****** PU.SVC_MGR.PC_ROUTE_MGR (PU PATH CONTROL ROUTE MANAGER) ******:
:---------------------------------------------------------------------:

:	S.PRMR	-(PU.SVC_MGR.PC_ROUTE_MGR.RCV) TO CALL THE 
:	APPROPRIATE PROCEDURE TO PROCESS A SIGNAL,REQUEST, OR
:	RESPONSE SENT TO THE PATH CONTROL ROUTE MANAGER
:	COMPONENT OF PU.SVC_MGR.
:	PAGE 12-13 ON FAPL
:	--------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-
S.PRMR
	JR	R14			:RETURN

	SUBTTL	PU COMMON SESSION CONTROL MANAGER -- SENDING LOGIC

:---------------------------------------------------------------------:
:****** PU.SVC_MGR.CSC_MGR (COMMON SESSION CONTROL MANAGER) **********:
:---------------------------------------------------------------------:

:	S.PCSD	-(PU.SVC_MGR.CSC_MGR.SEND) THIS PROCEDURE RECEIVES THE
:	REQUESTS FOR SESSION ACTIVATION AND DEACTIVATION FROM THE 
:	NAU.SVC_MGR.
:	PAGE 13-35 ON FAPL
:	---------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-R12 (CURRENT EV PTR)
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-
S.PCSD
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS BUFFER PTR VALID?
	JN	S.PNCR			:JUMP,IF NOT VALID BUFFER PTR
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LB	R1,NCBBLK+NDPUTY,R13,	:GET PU_TYPE FOR THIS PU
	CLHI	R1,PU.T1		:IS THIS PU_TYPE=T1?
	JE	S.P1S0			:JUMP,IF YES
	CLHI	R1,PU.T2		:IS THIS PU_TYPE=T2?
	JE	S.P1S0			:JUMP,IF IT IS T2
	CLHI	R1,PU.T4		:IS THIS PU_TYPE=T4?
	JE	S.P4S0			:JUMP,IF IT IS T4
	CLHI	R1,PU.T5		:IS THIS PU_TYPE=T5?
	JE	S.P4S0			:JUMP,IF IT IS T5
	J	S.PNCR			:ELSE,CRASH
:	PU.SVC_MGR.CSC_MGR.T1_OR_T2_SEND (PAGE 13-37) ON FAPL
:	-----------------------------------------------------
S.P1S0
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	S.PNCR			:CRASH,IF NOT

S.P1S1
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK OFF OTHER BITS
	JN	S.P1S2			:JUMP IF RRI=RSP
	JAL	R8,V.RQCK,,		:CALL RQ_CHECKS
	LR	R2,R2			:IS RETURN CODE YES?
	JE	S.P1S7			:JUMP,IF RETURN CODE NOT OK
	JAL	R4,U.IAEX,,		:JUMP TO ASSIGN EXPEDITED SEQ #
	J	S.P1S3			:JUMP,IF RQ_CHECKS IS OK
S.P1S2
	JAL	R8,V.RSCK,,		:CALL RSP_CHECKS
	LR	R2,R2			:IS RETURN CODE YES?
:	JE	S.P1S7			:JUMP,IF RETURN CODE NOT OK(5/20/86/CHS)
	JE	S.P1S4			:JUMP,IF RETURN CODE NOT OK(5/20/86/CHS)
S.P1S3
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LR	R10,R10			:CHECK MU_PTR=NULL?
	JLR	R14			:RETURN,IF MU_PTR=NULL
S.P1S4
	LHI	R1,PMCSMS		:GET SENDING PROCEDURE #
S.P1S5
	LHI	R2,PCT2SD		:SET UP PC_T2.SEND
	LB	R0,NCBBLK+NDPUTY,R13,	:GET PU_TYPE FOR THIS PU
	CLHI	R0,PU.T2		:IS THIS PU_TYPE=T2?
	JEFS	S.P1S6			:JUMP,IF IT IS T2
	LHI	R2,PCT1SD		:SET UP PC_T1.SEND FOR DESTINATION
S.P1S6
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	JAL	R8,D.FSEN,,		:CALL COMMON 'SEND' ROUTINE
	J	S.P4S3			:JUMP TO SEND NOTIFICATION
:	SEND SEND_CHECK TO SENDING PROCEDURE
:	-------------------------------------
S.P1S7
	LB	R2,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	LIS	R0,1
S.P1S8
	STB	R0,BBUFER+MUSCHK,R10,	:SET SEND_CHECK_SENSE BIT
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LHI	R1,PMCSMS		:GET SENDING PROCEDURE #
	JAL	R8,D.FSEN,,		:CALL COMMON 'SEND' ROUTINE
	JR	R14			:RETURN
:	RECEIVE RESET_HIERARCHICAL RESPONSE SIGNAL FROM SVC_MGR
:	----------------------------------------------
S.P1S9
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS INDEX
	LHI	R0,FS.HRP		:SET HIERARCHICAL_RESET_RESPONSE
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	JR	R14			:RETURN

:	PU.SVC_MGR.CSC_MGR.T4_OR_T5_SEND (PAGE 13-38) ON FAPL
:	-----------------------------------------------------
S.P4S0
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	S.PNCR			:CRASH,IF NOT
	LB	R0,EVBLK+EVSPRO,R12,	:GET SENDING PROCESS
	CLHI	R0,PMCSBR		:IS IT FROM PU.SVC_MGR.PC_ROUTE.RCV?
	JE	S.P4S5			:JUMP,IF YES

:	LB	R3,BBUFER+MUDADP,R10,	:GET DAFPRIME
:	LB	R4,BBUFER+MUOADP,R10,	:GET OAFPRIME
:	JAL	R7,V.SCSC,,		:CALL SCB_LIST SCANNER
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK OFF OTHER BITS
	JN	S.P4S4			:JUMP IF RRI=RSP
	LR	R9,R9			:CHECK SCB PTR
	JGFS	S.P4S1			:JUMP,IF SCB NOT NULL
:	ACTIVATION REQUEST FROM SVC_MGR AND THE SCB_PTR=NULL
:	-------------------------------------------------------
	JAL	R6,V.SCCR,,		:CALL SCB_CREATE
	J	S.PNCR			:CRASH,IF SCB_PTR=NULL
:	DEACTIVATION REQUESTS FROM SVC_MGR
:	-----------------------------------
S.P4S1
	JAL	R8,V.RQCK,,		:CALL RQ_CHECKS
	LR	R2,R2			:IS RETURN CODE YES?
	JE	S.P1S7			:JUMP,IF RETURN CODE NOT OK
	JAL	R4,U.IAEX,,		:JUMP TO ASSIGN EXPEDITED SEQ #
S.P4S2
	LB	R1,SCBBLK+SCFSMS,R9,	:SET UP #FSM_SESS INDEX
	LIS	R0,0			:CLEAR FSMINPUT
	LIS	R6,FS.CAL		:SETUP ROUTINE TYPE
	JAL	R3,R.FSMR,,		:CALL FSM ROUTINE
	LR	R10,R10			:CHECK MU_PTR=NULL?
	JLR	R14			:RETURN,IF MU_PTR=NULL
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LHI	R2,PCT2SD		:SET UP PC_T2.SEND
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,PMCSMS		:GET SENDING PROCEDURE #
	JAL	R8,D.FSEN,,		:CALL COMMON 'SEND' ROUTINE
S.P4S3
	LB	R2,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	CLHI	R2,LUSEND		:IS IT SEND BY LV.SVC_MGR?
	JNR	R14			:RETURN,IF NOT
:	(9/18/84/CHS)	GENERATE MUCB - LUSEND NEEDS IT
	JAL	R4,GBB,,		:CREATE NEW MUCB IN R3
	J	S.PNCR			:CRASH, IF NO BUFFER AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LB	R4,BBUFER+MUDADP,R10,	:COPY MUDADP FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MUDADP,R3,	:
	LB	R4,BBUFER+MUOADP,R10,	:COPY MUOADP FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MUOADP,R3,	:
	LB	R4,BBUFER+MURHF1,R10,	:COPY MURHF1 FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MURHF1,R3,	:
	LB	R4,BBUFER+MURHF2,R10,	:COPY MURHF2 FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MURHF2,R3,	:
	LB	R4,BBUFER+MURHF3,R10,	:COPY MURHF3 FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MURHF3,R3,	:
	LB	R4,BBUFER+MUBIUF,R10,	:COPY MUBIUF FROM OLD TO NEW MUCB
	STB	R4,BBUFER+MUBIUF,R3,	:
	LHI	R2,LUSEND		:SET UP R2 AGAIN
	LR	R10,R3			:R10 = NEW MUCB
:	(9/18/84/CHS)	END OF GENERATION MUCB INSERTION
	LIS	R0,0			:CLEAR SEND_SENSE_CHECK BIT
	J	S.P1S8			:JUMP TO SEND NOTIFICATION FOR LU.SVC
:	RESPONSE FROM SVC_MGR
:	---------------------
S.P4S4
	JAL	R8,V.RSCK,,		:CALL RSP_CHECKS
	LR	R2,R2			:IS RETURN CODE YES?
:	JE	S.P1S7			:JUMP,IF RETURN CODE NOT OK(5/20/86/CHS)
	JE	S.P1S4			:JUMP,IF RETURN CODE NOT OK(5/20/86/CHS)
:	DO WE NEED TO CHECK --
:	(1)IF RSP IS FOR DACTLU,DACTPU, HOW TO DO WITH SCB_PTR?????
	J	S.P4S2			:JUMP TO CALL #FSM_SESS,SEND MU TO PC
:	IT IS DSIAPTCHED BY PU.SVC_MGR.PC_ROUTE_MGR.RCV
:	-------------------------------------------------
S.P4S5
	J	S.PNCR			:CRASH,IT IS ERROR

	SUBTTL	PU COMMON SESSION CONTROL MANAGER -- RECEIVING LOGIC

:	S.PCRV	-(PU.SVC_MGR.CSC_MGR.RCV) THIS PROCEDURE RECEIVES
:	THE REQUESTS AND RESPONSES FOR SESSION ACTIVATION AND
:	DEACTIVATION FROM PATH CONTROL. THE REQUEST OR RESPONSE
:	IS ROUTED TO THE APPROPRIATE CSC_MGR.RCV ROUTINE.
:	PAGE 13-41 ON FAPL
:	---------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-R12 (CURRENT EV PTR)
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-
S.PCRV
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS BUFFER PTR VALID?
	JN	S.PNCR			:JUMP,IF NOT VALID BUFFER PTR
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR
	LB	R1,NCBBLK+NDPUTY,R13,	:GET PU_TYPE FOR THIS PU
	CLHI	R1,PU.T1		:IS THIS PU_TYPE=T1?
	JE	S.P1RV			:JUMP,IF YES
	CLHI	R1,PU.T2		:IS THIS PU_TYPE=T2?
	JE	S.P1RV			:JUMP,IF IT IS T2
	CLHI	R1,PU.T4		:IS THIS PU_TYPE=T4?
	JE	S.P4RV			:JUMP,IF IT IS T4
	CLHI	R1,PU.T5		:IS THIS PU_TYPE=T5?
	JE	S.P4RV			:JUMP,IF IT IS T5
	J	S.PNCR			:ELSE,CRASH

:	S.P1RV	-(PU.SVC_MGR.CSC_MGR.T1_T2_RCV) THIS PROCEDURE RECEIVES
:	THE REQUESTS AND RESPONSES FOR SESSION ACTIVATION AND DEACTIVATION
:	FROM CSC.MGR_RCV (S.PCRV).
:	(1) THE REQUEST OR RESPONSE IS VERIFIED
:	    (A) CHECKING THAT THE REQUEST OR RESPONSE CAN FLOW ON THE SESSION
:	    (B) CHECKING PARAMETERS WITHIN THE RU (FM AND TS PROFILE)
:	    (C) MAKING THE STATE RECEIVE CHECKS
:	    IF THE VERIFICATION OF THE RU IS SUCCESSFUL,THE RU IS SENT TO 
:	    TO THE NAU.SVC_MGR, OTHERWISE THE REQUEST IS CHANGED TO A -RSP
:	    AND SENT BACK TO PATH CONTROL.
:	(2) THE SESSION CONTROL BLOCK IS CREATED
:	PAGE 13-42 ON FAPL
:	----------------------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-R12 (CURRENT EV PTR) R14 (1ST-LEVEL CALL)
:	OUTPUT	-
:	LINK	-(NO LINK REGISTER NEEDED)
:	WORKING	-
S.P1RV
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.UNB		:IS DEACTIVATE-REQUEST SIGNAL ?
	JE	S.PRMR			:RETURN,DO NOTHING
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	S.PNCR			:CRASH,IF NOT
	LB	R0,BBUFER+MUDADP,R10,	:GET MUDADP FROM MUCB
	JAL	R5,R.LUAS,,		:ASSIGN LUCB TO MUOADP (R15)
	J	S.P1R8			:FAILURE,NORMAL RETURN
	LB	R4,BBUFER+MUDADP,R10,	:GET DAFPRIME
	LB	R3,BBUFER+MUOADP,R10,	:GET OAFPRIME
	JAL	R7,V.SCSC,,		:CALL SCB_LIST SCANNER
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R4,MU.RRI		:SET UP RQ/RSP
	JN	S.P1R2			:JUMP,IF IT IS RSP
	JAL	R8,V.RQCK,,		:CALL RQ_CHECKS
	LR	R2,R2			:IS RETURN CODE YES?
	JE	S.P1R4			:JUMP,IF RETURN CODE NOT OK
	LR	R9,R9			:CHECK SCB_PTR IS NULL OR NOT
	JG	S.P1R1			:JUMP,IF NOT
S.P1R0
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET RU PTR
	JLE	S.PNCR			:CRASH,IF NO SCB_PTR
	LB	R0,BBUFER,R3,		:GET RQ_CODE
	CLHI	R0,UNBIND		:IS IT UNBIND?
	JE	S.P1R9			:YES,JUMP
					:(3.F01/06/19/87/DB/START)
	CLHI	R0,DACTLU		:IS IT DACTLU?
	JE	S.P1R9			:YES, DON'T CREATE SCB
					:(3.F01/06/19/87/DB/END)
	JAL	R6,V.SCCR,,		:CALL SCB_CREATE
	J	S.P1R5			:JUMP,IF SCB_PTR=NULL
S.P1R1
	JAL	R7,V.SSVC,,		:CALL #FSM_SESS AND SEND MU TO #SVC_MGR
	JR	R14			:RETURN
:	RRI=RSP
:	-------
S.P1R2
	LR	R9,R9			:CHECK SCB_PTR
:	JLE	S.PNCR			:CRASH,IF NO SCB_PTR (5/16/86/CHS)
	JLE	S.P1R8			:DISCARD MU, IF NO SCB_PTR(5/16/86/CHS)
	LHL	R1,SCBBLK+SCESQN,R9,	:GET EXPEDITED SEQ #
:	CLH	R1,BBUFER+MUSNF,R10,	:IS SEQ # OK? (12/6/84 MIA)
	LHL	R5,BBUFER+MUSNF,R10,	:GET SNF (12/6/84 MIA)
	CR	R1,R5			:IS IT OK? (12/6/84 MIA)
	JE	S.P1R3			:JUMP,IF OK
	LHI	R0,.SEQER		:SET SEQUENCE NUMBER ERROR (2001)
	J	S.P1R6			:SEND MU TO PC
S.P1R3
	JAL	R8,V.RSCK,,		:CALL RSP_CHECKS
	LR	R2,R2			:CHECK RETURN CODE
	JE	S.P1R8			:JUMP,IF RSP_CHECKS NOT OK
	JAL	R7,V.SSVC,,		:CALL #FSM_SESS AND SEND MU TO #SVC_MGR
:	DISCARD SCB_PTR (OPTION ?????)
:	-----------------
	JR	R14			:RETURN
:	RQ_CHECKS RETURN CODE IS NG
:	-----------------------------
S.P1R4
	L	R0,BBUFER+MURCKS,R10,	:GET RECEIVE_CHECK_SENSE
	J	S.P1R6			:SEND MU TO PC
:	SCB_PTR=NULL,WHEN RRI=RQ
:	--------------------------
S.P1R5
	LHI	R0,.RRISR		:SET INSUFFICIENT RESOURCE (0812)
S.P1R6
	JAL	R5,R.MUNR,,		:CALL CHANGE_MU_TO_NEG_RSP
	LHI	R1,PMCSMR		:SET SENDING PROCEDURE
	J	S.P1S5			:SEND MU TO PC
:	RECEIVE RESET_HIERARCHICAL REQUEST FROM SON.SVC_MGR
:	---------------------------------------------------
S.P1R7
	JAL	R15,V.RSVC,,		:SEND RESET_HIERARCHICAL SIG. TO SVC
	JR	R14			:RETURN
:	DISCRAD MU WHEN RSP_CHECKS NOT OK
:	---------------------------------
S.P1R8
	JAL	R8,R.DSMU,,		:CALL ROUTINE TO DISCARD MU
	JR	R14			:RETURN

:	RECEIVE UNBIND DURING LU NOT ACTIVE
:	-----------------------------------
S.P1R9
	LHI	R0,.PELUD		:SET LU NOT ACTIVE (8009)
	J	S.P1R6			:JUMP TO SEND NEGATIVE RSP

:	S.P4RV	-(PU.SVC_MGR.CSC_MGR.T4_T5_RCV) THIS PROCEDURE RECEIVES
:	THE REQUESTS AND RESPONSES FOR SESSION ACTIVATION AND DEACTIVATION
:	FROM CSC.MGR_RCV (S.PCRV).
:	(1) THE REQUEST OR RESPONSE IS VERIFIED
:	    (A) CHECKING THAT THE REQUEST OR RESPONSE CAN FLOW ON THE SESSION
:	    (B) CHECKING PARAMETERS WITHIN THE RU (FM AND TS PROFILE)
:	    (C) MAKING THE STATE RECEIVE CHECKS
:	    IF THE VERIFICATION OF THE RU IS SUCCESSFUL,THE RU IS SENT TO 
:	    TO THE NAU.SVC_MGR, OTHERWISE (A)THE REQUEST IS CHANGED TO A -RSP
:	    AND SENT BACK TO PATH CONTROL.(B)IN SPECIAL CASE,RU OR RESPONSE
:	    IS DISCARDED.
:	(2) THE SESSION CONTROL BLOCK IS CREATED
:	PAGE 13-44 ON FAPL
:	----------------------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-R12 (CURRENT EV PTR) R14 (1ST-LEVEL CALL)
:	OUTPUT	-
:	LINK	-(NO LINK REGISTER NEEDED)
:	WORKING	-
S.P4RV
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.UNB		:IS DEACTIVATE_REQUEST SIGNAL?
	JE	S.PRMR			:RETURN,DO NOTHING
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	S.PNCR			:CRASH,IF NOT
S.P4R0
	LB	R0,BBUFER+MUOADP,R10,	:GET MUOADP FROM MUCB
	JAL	R5,R.LUAS,,		:ASSIGN LUCB TO MUOADP (R15)
	J	S.P1R8			:FAILURE,NORMAL RETURN
	LB	R4,BBUFER+MUDADP,R10,	:GET DAFPRIME
	LB	R3,BBUFER+MUOADP,R10,	:GET OAFPRIME
	JAL	R7,V.SCSC,,		:CALL SCB_LIST SCANNER
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R0,MU.RRI		:MASK OFF OTHER BITS
	JN	S.P4R4			:JUMP IF RRI=RSP
:	CALL RQ_CHECKS TO CHECK RQ_PARAMETERS
:	-------------------------------------
	JAL	R8,V.RQCK,,		:CALL RQ_CHECKS
	LR	R2,R2			:IS RETURN CODE YES?
	JN	S.P4R1			:JUMP,IF RETURN CODE OK
	L	R0,BBUFER+MURCKS,R10,	:GET RECEIVE_CHECK_SENSE
	JAL	R5,R.MUNR,,		:CALL CHANGE_MU_TO_NEG_RSP
	J	S.P1S4			:JUMP TO SEND MU TO PC
S.P4R1
	LR	R9,R9			:CHECK SCB_PTR IS NULL OR NOT
	JGFS	S.P4R3			:JUMP,IF NOT
S.P4R2
	JAL	R6,V.SCCR,,		:CALL SCB_CREATE
	J	S.P4R9			:JUMP,IF SCB_PTR=NULL
S.P4R3
	JAL	R7,V.SSVC,,		:CALL #FSM_SESS AND SEND MU TO #SVC_MGR
	JR	R14			:RETURN
:	RRI=RSP
:	-------
S.P4R4
	LR	R9,R9
	JLE	S.P1R8,,		:CALL DISCARD MUCB,IF NO SCB_PTR
:	LHL	R1,SCBBLK+SCESQN,R9,	:GET EXPEDITED SEQ #
:	CLH	R1,BBUFER+MUSNF,R10,	:IS SEQ # OK?
:	JE	S.P4R5			:JUMP,IF OK
:	LHI	R0,.SEQER		:SET SEQUENCE NUMBER ERROR (2001)
:	J	S.P1R6			:SEND MU TO PC
S.P4R5
	JAL	R8,V.RSCK,,		:CALL RSP_CHECKS
	LR	R2,R2			:CHECK RETURN CODE
	JE	S.P1R8			:JUMP,IF RSP_CHECKS NOT OK
	LB	R0,BBUFER+MUDIRE,R10,	:GET DIRECTION BYTE
	JE	S.P4R6			:JUMP,IF IT IS SEND
	L	R1,BBUFER+MURCKS,R10,	:SET RECEIVE_CHECK_SENSE
	CLHI	R1,.RRISP		:IS RECEIVE_CHECK_SENSE=084E
	JN	S.P4R6			:JUMP,IF RECEIVE_CHECK_SENSE<>084E
	STH	R1,BBUFER+MURHSN,R10,	:SET SNC TO RECEIVE_CHECK_SENSE
	LB	R0,BBUFER+MURHF2,R10,	:GET MURHF2
	OHI	R0,MU.RTI		:SET RTI TO NEG
	STB	R0,BBUFER+MURHF2,R10,	:SET RTI IN MUCB
S.P4R6
	JAL	R7,V.SSVC,,		:CALL #FSM_SESS AND SEND MU TO #SVC_MGR
	LB	R0,BBUFER+MURHF2,R10,	:GET RTI BYTE FROM MUCB
	NHI	R0,MU.RTI		:CHECK RTI BIT
	JN	S.P4R7			:JUMP,IF RTI=NEG
	LHL	R0,BBUFER+MURHSN,R10,	:GET SNC FROM MUCB
	CLHI	R0,.RRNAU		:IS SNC=080D?
	JE	S.P4R8			:YES,JUMP
	CLHI	R0,.RRNAN		:IS SNC=080E?
	JE	S.P4R8			:YES,JUMP
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU_PTR IN R1
	JLE	S.PNCR			:CRASH,IF NO SCB_PTR
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,DACTPU		:IS IT 'DACTPU'?
	JE	S.P4R7			:JUMP,IT IS DACTPU
	CLHI	R0,DACTLU		:IS IT 'DACTLU'?
	JE	S.P4R7			:JUMP,IT IS DACTLU
	CLHI	R0,UNBIND		:IS IT 'UNBIND'?
	JE	S.P4R8			:JUMP,IT IS UNBIND
	CLHI	R0,DACDRM		:IS IT 'DACDRM'?
	JNFS	S.P4R8			:JUMP,IF IT IS NOT DACDRM
:	CALL SCB_DISCARD?????
:	----------------------
S.P4R7
:	SCB_PTR WILL BE DISCARDED BY SVC_MGR
	JAL	R8,V.SCDS,,		:CALL DISCARD SCB
S.P4R8
	JR	R14			:RETURN
:	SCB_PTR=NULL,WHEN RRI=RQ
:	--------------------------
S.P4R9
	J	S.P1R5			:JUMP TO SEND MU
:	BOUNDARY FUNCTION SUPPORT
:	-------------------------
S.PCBR
	J	S.PNCR			:CRASH FOR TESTING

	SUBTTL	PU NETWORK SERVICE MANAGER -- RECEIVING LOGIC

:---------------------------------------------------------------------:
:****** PU.SVC_MGR.NS_MGR (PU NETWORK SERVICES MANAGER) **************:
:---------------------------------------------------------------------:

:	S.PNRV	-(PU.SVC_MGR.NS.RCV) RECEIVES ALL INPUT TO THE
:	PU.SVC_MGR.NS AND ROUTE THE INPUT TO THE APPROPRIATE
:	ROUTINE FOR FURTHER PROCESSING. THE ROUTING THAT TAKES
:	PLACE IS DETERMINED BY THE PROCEDURE THAT SEND THE 
:	CURRENT PIU OR SIGNAL, AND THE CONTENT OF THE PIU OR SIGNAL.
:	PAGE 11-28 ON FAPL MANUAL
:	-----------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-R12 (EV PTR)
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-R10 (MU_PTR)
S.PNRV
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.ERR		:IS IT 'ABNORMAL_RESET' SIGNAL
	JER	R14			:RETURN
	CLHI	R1,SG.UNB		:'UNBIND' SIGNAL? (MIA, 8/28/84)
	JER	R14			:RETURN (MIA, 8/28/84)
	CLHI	R1,SG.NOS		:IS IT NO_SIGNAL?
	JN	S.PNCR			:CRASH,IF NOT

S.PNR0
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS BUFFER PTR VALID?
	JN	S.PNCR			:JUMP,IF NOT VALID BUFFER PTR
	LB	R0,BBUFER+MUSCHK,R10,	:GET SEND_CHECK_SENSE BIT
	JN	S.PNCR			:CRASH,IF SEND_CHECK_SENSE SET
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LB	R0,EVBLK+EVSPRO,R12,	:GET SEND_PROCESS
	CLHI	R0,PMNSMR		:DISPATCHED_BY (PU.SVC_MGR.NS.RCV)
	JE	S.PNR1			:JUM,IF YES
	CLHI	R0,FCNSRV		:IS DISPATCHED_BY (SNS.RCV)
	JE	S.PNR1			:JUMP,IF YES
	CLHI	R0,PMCSMR		:DISPATCHED_BY (PU.SVC_MGR.CSC_MGR.RCV)
	JE	N.SCPR			:JUM,IF YES
	CLHI	R0,TCSCRV		:IS DISPATCHED_BY (TC.SC.RCV)
	JE	N.SCPR			:JUMP,IF YES
	CLHI	R0,PCBFRV		:IS DISPATCHED_BY (BF.PC.RCV)
	JE	S.PNR2			:JUMP,IF YES
	CLHI	R0,PCT2RV		:IS DISPATCHED_BY (PC_T2.RCV)
	JE	S.PNR3			:JUMP,IF YES
:	DISPATCHED_BY (UPM_CNMS) BY (PU.SVC_MGR.LINK_MGR) ??????
:	--------------------------------------------------------
:	DISPATCHED_BY (PU.SVC_MGR.NS.RCV | SNS.RCV)
:	----------------------------------------------------
S.PNR1
:	DISPATCHED_BY (BF.PC.RCV)
:	-------------------------
S.PNR2
:	DISPATCHED_BY (PC.T2.RCV)
:	-------------------------
S.PNR3
	J	S.PNCR			:CRASH FOR TESTING

:	RECEIVE 'RESET' SIGNAL FROM DISPATCHER
:	----------------------------------------
S.PNR4
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LB	R1,LUCTAB+LUSSTA,R15,	:GET CURRENT LU STATUS
	CLHI	R1,NN.PDL		:IS PENDING FOR DACTLU
	JE	S.PNS9			:YES,JUMP
	CLHI	R1,NN.PAL		:IS PENDING FOR ACTLU
	JE	S.PNSB			:YES,JUMP
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LB	R1,LUCTAB+LUSSTA,R15,	:GET CURRENT LU STATUS
	CLHI	R1,NN.PDP		:IS PENDING FOR DACTPU
	JE	S.PNR5			:YES,JUMP
	CLHI	R1,NN.PAP		:IS PENDING FOR ACTPU
	JE	S.PNR6			:YES,JUMP
	JR	R14			:RETURN
S.PNR5
:	NEED TO CHECK ALL LU FINISHED
	J	S.PNS5			:JUMP TO SEND RESPONSE TO DEVICE
S.PNR6
:	NEED TO CHECK ALL LU FINISHED
	J	S.PNS7			:JUMP TO SEND RESPONSE TO DEVICE

:	DISPATCHED_BY (PU.SVC_MGR.CSC_MGR.RCV | TC.SC.RCV)
:	====================================================
:	N.SCPR	-(NS.SC_PROC) UPON RECEIPT OF ACTPU, A POSITIVE OR NEGATIVE
:	RESPONSE IS CREATED.
:	PAGE 11-30 ON FAPL
:	------------------------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-R12 (CURRENT EV PTR) R14 (1ST-LEVEL CALL)
:		-R9 (SCB_PTR) R15 (LUCB_PTR)
:	OUTPUT	-
:	LINK	-(NO LINK REGISTER NEEDED)
:	WORKING	-
N.SCPR
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU_PTR IN R1
	JLE	S.PNCR			:CRASH,IF NO SCB_PTR
	LB	R0,BBUFER,R1,		:GET RQ_CODE
	CLHI	R0,DACTPU		:IS IT 'DACTPU'?
	JE	N.SCDP			:JUMP,IT IS DACTPU
	CLHI	R0,SDT			:IS IT 'SDT'?
	JE	N.SCP2			:JUMP,IT IS SDT
	CLHI	R0,ACTPU		:IS IT 'ACTPU'?
	JE	N.SCAP			:JUMP,IT IS ACTPU
	CLHI	R0,ACTLU		:IS IT 'ACTLU'?
	JE	N.SCAL			:JUMP,IT IS ACTLU
	CLHI	R0,DACTLU		:IS IT 'DACTLU'?
	JE	N.SCDL			:JUMP,IT IS DACTLU
:	ERROR RQ_CODE,CRASH FOR DEBUGGING
:	---------------------------------
	J	S.PNCR

:	RECEIVING SDT FROM HOST
:	=======================
N.SCP2
	LHI	R0,TRUNCA		:SET 'TRUNCATE' PARAMETER
	JAL	R5,R.MUPR,,		:CALL CHANGE_MU_TO_POS_RSP(TRUNCATE)
	LHI	R2,TCSCSD		:SET DEST. TC.SC.SEND
	J	N.SCD2			:JUMP TO SEND MU

:	RQ_CODE = ACTPU
:	===============
:	CHECK THE POSSIBLE CURRENT PU STATE,
:	(1)SOME SSCP_LU ARE ALREADY ACTIVE
:	(2)SSCP_PU IS ALREADY ACTIVE
:	(3)CHECK ACTPU FORMAT
:	(4)SEND RESPONSE TO PU.CSC.SEND
N.SCAP
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
:CLEAR NON-CLEAR BYTE IN LUCB (01/30/86 MIA).
	XR	R1,R1			:CLEAR LU COUNTER
	LR	R3,R15			:COPY LUCB POINTER
	XR	R7,R7			:CLEAR THE REGISTER
N.SCAA	AIS	R1,1			:INCREASE LU COUNTER
	CLB	R1,PUCTAB+PUMLUN,R8,	:EVERYTHING DONE?
	JGEFS	N.SCAB			:JUMP IF SO
	AHI	R3,LUCLEN		:ADVANCE LUCB POINTER
	STB	R7,LUCTAB+LUCSCC,R3,	:CLEAR NON-CLEAR BYTE IN LUCB
	JBS	N.SCAA			:CONTINUE
N.SCAB	EQ	.
:END OF INSERTION (01/30/86 MIA).
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
:	JN	S.PNCR			:SOME LU ACTIVE (10/18/85 MIA)
	JN	N.EAPU			:JUMP TO RESET (10/18/85 MIA)
	LB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	CLHI	R0,NN.RES		:IS CURRENT PU STATE RESET?
	JN	N.EAPU			:JUMP TO INF. LU.SVC_MGR
:	CHECK THE SSCP_ID -- ACTION IS IGNORED
:	--------------------------------------
N.SCA0
	LHI	R0,NN.APU		:GET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE STATE TO ACTIVE PU
	BBSSCB	R9,LUCTAB+LUSSCB,R15,	:SET SCB PTR IN LUCB
:	SEND POSITIVE RESPONSE WHEN RECEIVE ACTPU FROM HOST
:	---------------------------------------------------
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET BTUCB+BTU PTR
	JLE	S.PNCR			:CRASH,IF NO SCB_PTR
:HARDCODED RSP(ACTPU) REPLACED BY SYSGENED (01/08/85 MIA)
:	LB	R1,BBUFER+APUTAC,R3,	:GET TYPE.ACTIVATION
:	NHI	R1,AP.ACT		:MASK FOR TYP.ACTIVATION
:	CLHI	R1,COLD			:IS IT COLD TYPE?
:	JE	N.SCA1			:YES,JUMP
:	LB	R2,G.APUE,,		:GET ACTPU (RSP) LENGTH (ERP)
:	LA	R8,G.APUE,,		:GET ACTPU (RSP) PTR (ERP)
:	JFS	N.SCA2			:JUMP TO SET UP MU
:N.SCA1
:	LB	R2,G.APUR,,		:GET ACTPU (RSP) LENGTH (COLD)
:	LA	R8,G.APUR,,		:GET ACTPU (RSP) PTR (COLD)
:N.SCA2
:	JAL	R7,R.CRUU,,		:MOVE DATA INTO MUCB PTR
	LB	R0,BBUFER+APUTAC,R3,	:SAVE TYPE OF ACTIVATION
	LHL	R8,LUCTAB+LUAPLP,R15,	:GET PTR TO RSP(ACTPU)
	AI	R8,SEG|A.CODE|		:MAKE ABSOLUTE ADDR
	LB	R2,0,R8			:GET RSP(ACTPU) LENGTH
	JAL	R7,R.CRUU,,		:MOVE RSP(ACTPU) DATA
	LB	R7,BBUFER+APUTAC,R3,	:GET SYSGENED TYPE OF ACTIV
	NHI	R7,@AP.ACT		:CLEAR TYPE OF ACTIVATION
	NHI	R0,AP.ACT		:GET ACT TYPE FROM HOST
	OR	R7,R0			:MERGE INTO THE BYTE
	STB	R7,BBUFER+APUTAC,R3,	:UPDATE IT
:END OF REPLACEMENT (02/08/85 MIA).
	LIS	R0,RCVD			:OVERRIDE DIRECTION
	STB	R0,BBUFER+MUDIRE,R10,
	LIS	R0,NOTRUN
	JAL	R5,R.MUPR,,		:CHANGE_MU_TO_POS_RSP(NO-TRUNCATE)
:	R1 (CMD TYPE) R3 (CMD STATUS) R0 (SENSE CODE)
:	---------------------------------------------
N.SCA3
	LHI	R1,XINIT		:SETUP CMD TYPE 'INIT' RESPONSE
	LHI	R3,E.POSR		:CMD STATUS FIELD IN CMDLST
	JAL	R8,V.SNNW,,		:SEND STATUS CMD TO NIO
	J	N.SCD1			:JUMP TO SEND MU
:	RECEIVING ACTPU FROM HOST,BUT: PU IS NOT IDLE
:	SEND NEGATIVE RESPONSE TO PU.CSC.SEND
:	------------------------------------------------------
:	SEND SENSE DATA (FUNCTION ACTIVE,RESOURCE-SHARING LIMIT REACHED
:	OR INVALID STATION SSCP/ID)
N.SCA4
	CLHI	R0,NN.APU		:IS IT CURRENT ACTIVE?
	JN	S.PNCR			:CRASH,IF NOT
	LHI	R0,.RRRLR		:SET RESOURCE-SHARING LIMIT REACHED
	JAL	R5,R.MUNR,,		:CALL CHANGE_MU_TO_NEG_RSP
	J	N.SCD1			:JUMP TO SEND MU

:	RECEIVING ACTLU FROM HOST
:	===========================
:	CHECK THE POSSIBLE CURRENT PU STATE,
:	(1)CURRENT SSCP_LU IS NOT RESET
:	(2)CURRENT SSCP_LU IS RESET
:	(3)CHECK THE FORMAT OF ACTLU STRING
:	(4)RESPONSE AND INFORME NIO
N.SCAL
	XR	R8,R8			:CLEAR THE REGISTER (05/13/86 MIA)
	STH	R8,SCBBLK+SCESQN,R9,	:CLEAR EXP SEQ# (05/13/86 MIA)
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHL	R12,PUCTAB+PUCLUC,R8,	:GET 1ST LU TABLE PTR
:
:BEGIN (03/13/86 YLH)
:	IF	HDPSUP
:	GL	LUSCRN,H.SNST
:	LB	R0,LUCTAB+LUCSCN,R12,	:GET SCREEN STATE
:	JE	H.SCAZ			:JUMP IF NO SCREEN CONTROL
:	XR	R5,R5			:ASSUME NO CIRCUIT
:	LHL	R0,LUCTAB+LUCDCB,R12,	:CIRCUIT STILL THERE?
:	JEFS	H.SCAY			:JUMP IF NOT
:	LR	R0,R9			:SAVE R9
:	LR	R9,R12			:COPY LUCB POINTER
:	LHI	R4,HSTINI		:HOST INITIATED
:	JAL	R6,H.SNST		:SEND SCREEN STATUS TO TIF
:	LR	R9,R0			:RESTORE R9
:	LHI	R5,LUSCRN		:INDICATE SCREEN CONTROL
:H.SCAY	STB	R5,LUCTAB+LUCSCN,R12,	:UPDATE SCREEN STATUS
:	EI
:END (03/13/86 YLH)
:
H.SCAZ	LB	R0,LUCTAB+LUSSTA,R12,	:NEW STATE FOR NODE CONTROL
	CLHI	R0,NN.APU		:IS CURRENT PU STATE ACTIVE?
	JN	S.PNCR			:JUMP TO CRASH (FOR DEBUGGING)
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT LU STATE
	CLHI	R0,NN.RES		:IS CURRENT LU IN RESET STATE?
	JN	N.EALU			:JUMP,IF NOT IN RESET STATE
:	ACTLU FORMATS CHECKING, ACTION: IGNORE
:	--------------------------------------
:	UPDATE LUCB INFORMATION
:	-----------------------
N.SCA5
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHI	R0,NN.ALU		:GET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE STATE TO ACTIVE LU
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	AIS	R0,1
	STB	R0,PUCTAB+PUALUN,R8,	:UPDATE ACTIVE LU #
	BBSSCB	R9,LUCTAB+LUSSCB,R15,	:SET SCB PTR IN LUCB
:	SEND POSITIVE RESPONSE TO PU.CSC.SEND
:	-------------------------------------
:	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTUCB+BTU PTR
:	JAL	R5,PBBC,,		:RELEASE BUFFER 
N.SCA6
:REPLACEMENT FOR HARDCODED RSP(ACTLU) (02/08/85 MIA).
:	LB	R2,G.ALUR,,		:GET ACTPU (RSP) LENGTH
:	LA	R8,G.ALUR,,		:GET ACTPU (RSP) PTR
	LHL	R8,LUCTAB+LUAPLP,R15,	:GET POINTER TO RSP(ACTLU)
	AI	R8,SEG|A.CODE|		:MAKE ABSOLUTE ADDR
	LB	R2,0,R8			:GET RSP(ACTLU) LENGTH
:END OF REPLACEMENT (02/08/85 MIA).
	LHL	R3,LUCTAB+LUCDCB,R15,	:SEE IF CIRCUIT THERE (4/29/85/CHS)
	JEFS	N.SCAX			:NO, USE TYMFILE DATA(4/29/85/CHS)
	LIS	R2,2			:IF CIRCUIT, SHORT RSP(ACTLU) (4/29/85/CHS)
N.SCAX					:(4/29/85/CHS)
	BBLOAD	R3,BBUFER+MURUPT,R10,	:GET BTUCB+BTU PTR(02/08/85/CHS)
	LB	R0,BBUFER+APUTAC,R3,	:GET TYPE OF ACTIVATION (02/11/85 MIA)
	JAL	R7,R.CRUU,,		:MOVE DATA INTO MUCB PTR
	STB	R0,BBUFER+APUTAC,R3,	:UPDATE TYPE OF ACTIV (02/11/85 MIA)
	LIS	R0,RCVD			:OVERRIDE DIRECTION
	STB	R0,BBUFER+MUDIRE,R10,
	LIS	R0,NOTRUN
	JAL	R5,R.MUPR,,		:CHANGE_MU_TO_POS_RSP(NO-TRUNCATE)
:	R1 (CMD TYPE) R3 (CMD STATUS) R0 (SENSE CODE)
:	---------------------------------------------
	LHL	R5,LUCTAB+LUCT.N,R15,	:GET OVERALL LU # (10/684 MMIA)
	TBT	R5,BDPDLU,,		:ACTLU PENDING? (10/6/84 MIA)
	JE	N.SCA3			:JUMP IF NOT (10/6/84 MIA)
	LHI	R1,PMNSMR		:SENDING PREDURERE (10/6/84 MIA)
	LHI	R2,LURCV		:TO LU_RCV (10/6/84 MIA)
	LHI	R0,SG.RTN		:RETURN SIGNAL (10/6/84 MIA)
	JAL	R8,D.FSEN,,		:SEND THE SIGNAL (10/6/84 MIA)
	J	N.SCA3			:JUMP TO INF. NIO AND RSP TO DEVICE

:	RECEIVING DACTPU FROM HOST
:	===========================
:	CHECK THE POSSIBLE CURRENT PU STATE,
:	(1)SSCP_LU ARE STILL ACTIVE
:	(2)SSCP_PU IS NOT ACTIVE
:	(3)CHECK DACTPU FORMAT
:	(4)SEND RESPONSE AND UPDATE LUCB
:	------------------------------------------------------------
N.SCDP
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
:	THE FOLLOWING CHECKS WILL BE PERFORMED IN #FSM_SESS,
:	AND ERROR (SON) CONDITION WILL SEND 'RESET' TO CSC_MGR.SON
:	-----------------------------------------------------------
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	JN	N.EDPU			:IF SOME LU STILL ACTIVE
	LB	R0,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	CLHI	R0,NN.APU		:IS CURRENT PU STATE ACTIVE?
	JN	S.PNCR			:JUMP TO CRASH (FOR DEBUGGING)
:	UPDATE LUCB
:	-----------
N.SCD0
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHI	R0,NN.RES		:GET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE NEW STATE
	LIS	R0,0
	STB	R0,PUCTAB+PUALUN,R8,	:CLEAR ACTIVE LU #
:	SEND POSITIVE RESPONSE
:	-----------------------
	LHI	R0,TRUNCA		:SET 'TRUNCATE' PARAMETER
	JAL	R5,R.MUPR,,		:CALL CHANGE_MU_TO_POS_RSP(TRUNCATE)
	LHI	R1,XCLOSE		:SETUP CMD TYPE 'CLOSE'
	LHI	R3,E.POSR		:CMD STATUS FOR CMDLST
	JAL	R8,V.SNNW,,		:SEND STATUS CMD TO NIO
N.SCD1
	LHI	R2,PMCSMS		:SET DEST. (PU.SVC_MGR.CSC_MGR.SEND)
N.SCD2
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,PMNSMR		:GET SENDING PROC. (PU.SVC_MGR.NS.RCV)
	JAL	R8,D.FSEN,,		:CALL COMMON 'SEND' ROUTINE
	JR	R14			:RETURN

:	RECEIVING DACTLU FROM HOST
:	===========================
:	CHECK THE POSSIBLE CURRENT PU STATE,
:	(1)SSCP_PU IS NOT ACTIVE
:	(2)SSCP_LU IS NOT ACTIVE
:	(3)CALL LU.SVC TO PROCESS RESET
:	(4)CHECK DACTLU FORMAT
:	------------------------------------------------------------
N.SCDL
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHL	R12,PUCTAB+PUCLUC,R8,	:GET 1ST LU TABLE PTR
:	THE FOLLOWING CHECKS WILL BE PERFORMED IN #FSM_SESS,
:	AND ERROR (SON) CONDITION WILL SEND 'RESET' TO CSC_MGR.SON
:	-----------------------------------------------------------
	LB	R0,LUCTAB+LUSSTA,R12,	:NEW STATE FOR NODE CONTROL
	CLHI	R0,NN.APU		:IS CURRENT PU STATE ACTIVE?
	JN	S.PNCR			:JUMP TO CRASH (FOR DEBUGGING)
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	JE	S.PNCR			:IF PU ACTIVE,AND NO LU ACTIVE
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT SSCP_LU STATE
	CLHI	R0,NN.ALU		:IS CURRENT STATE ACTIVE?
	JN	S.PNCR			:CRASH,IF NOT
	LHI	R4,0FF			:INIT THE REGISTER (09/26/85 MIA)
	STB	R4,LUCTAB+LULUW3,R15,	:INIT SSCP-LU LINE # (09/26/85 MIA)
	BBLSCB	R4,LUCTAB+LULSCB,R15,	:GET LU_LU SCB
	JG	N.EDLU			:JUMP,IF LU_LU SCB_PTR THERE
:	LHL	R8,LUCTAB+LUCDCB,R15,	:GET DCB PTR (04/26/85 MIA)
:	JEFS	N.SCD3			:JUMP,IF NO DCB YET (04/26/85 MIA)
:	ST	R12,SAVRG8		: (7/20/84/CHS)
	STM	R0,SLUSAV,,		:SAVE REGS (7/20/84/CHS)
	LR	R9,R15			:SET R9 = LUC OFFSET (7/20/84/CHS)
	JAL	R12,V.CLEA,,		:CLEAR LU-LU PARAMETERS
:	L	R12,SAVRG8		:(7/20/84/CHS)
	LM	R0,SLUSAV,,		:(7/20/84/CHS)
:	UPDATE LUCB INFORMATION
:	-----------------------
N.SCD3
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHI	R0,NN.RES		:GET NEW STATE
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE NEW STATE
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	SIS	R0,1
	STB	R0,PUCTAB+PUALUN,R8,	:UPDATE ACTIVE LU #
	LIS	R0,0
	BBSSCB	R0,LUCTAB+LUSSCB,R15,	:SET SCB PTR (NULL) IN LUCB
:	INFORME THE SUBJECT LU_LU SESSION TO RESET ????
:	INFORME THE NIO FOR THE HOST STATUS
:	---------------------------------
	LHI	R1,XCLOSE		:SETUP CMD TYPE 'CLOSE'
	LHI	R3,E.POSR		:CMD STATUS FOR CMDLST
	JAL	R8,V.SNNW,,		:SEND STATUS CMD TO NIO
:	SEND POSITIVE RESPONSE TO PU.CSC.SEND
:	-------------------------------------
	LHI	R0,TRUNCA		:SET 'TRUNCATE' PARAMETER
	JAL	R5,R.MUPR,,		:CALL CHANGE_MU_TO_POS_RSP(TRUNCATE)
	J	N.SCD1

	SUBTTL	PU NETWORK SERVICE MANAGER -- SENDING

:	S.PNSD	-(PU.SVC_MGR.NS_MGR) 
:	RECEIVES ALL INPUT FROM NETWORK I/O (OR FROM NETWORK MONITOR),
:	AND ROUTES THE INPUT TO THE APPROPRIATE PROCEDURE FOR PROCESSING.
:	-----------------------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-
:	OUTPUT	-
:	LINK	-R14
:	WORKING	-R13 (NCB_PTR),R12 (EV_PTR)
S.PNSD
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.ZAP		:IS IT ZAPPER RESPONSE FROM LU
	JE	S.PNC0			:YES,LU FIN. CLEAN UP,SEND RSP TO NIO
	CLHI	R1,SG.LDW		:IS IT LNK DOWN RESPONSE FROM LU
	JE	S.PNL1			:YES,LU FIN. CLEAN UP
	CLHI	R1,SG.NOS		:IS IT OUT OF RANGE?
	JG	S.CRAS			:CRASH,IF YES
:	GET EV.PARMPTR (CONTAINS CMD INF. OR DATA PTR)
:	GET EV.NWCMR (CONTAINS COMMAND TYPE).
:	GET EV.LUCB (CONTAINS LUCB PTR)
:	GET EV.MULN (CONTAINS DATA LENGTH)
:	GET PROPER ROUTINES TO HANDLE EACH COMMAND.
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MU PTR FROM EV
	THI	R10,BUFFLG		:IS BUFFER PTR VALID?
	JN	S.PNS0			:JUMP,IF NOT FOR BUFFER
	LB	R0,BBUFER+MUSCHK,R10,	:GET SEND_CHECK_SENSE BIT
	JN	S.CRAS			:CRASH,IF SEND_CHECK_SENSE SET
	J	S.CRAS			:SEND_CHECK_SENSE NOT SET,CRASH
S.PNS0
	LB	R1,EVBLK+EVNWCM,R12,	:GET CMD TYPE FROM EVBLK
	LHL	R2,EVBLK+EVMULN,R12,	:GET MSG LENGTH (ONLY FOR DATA)
	BBLOAD	R0,EVBLK+EVPRMP,R12,	:GET CMD INF. OR DATA LENGTH FROM EVBLK
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR
	CLHI	R1,MXSNNW		:IS IT OUT OF RANGE?
	JG	S.CRAS			:YES,CRASH
	LHL	R5,S.PNS1,R1,R1		:GET TABLE PTR FOR PROCESS
	J	S.PNS1,R5,		:JUMP TO ROUTINE
S.PNS1	HS
	HC	S.CRAS-S.PNS1		:ERROR CMD
	HC	S.PNS2-S.PNS1		:INIT COMMAND
	HC	S.PNS2-S.PNS1		:CLOSE COMMAND
	HC	S.PNLD-S.PNS1		:LINK DOWN CMD
	HC	S.PNCD-S.PNS1		:CKT DOWN COMMAND

:	INIT COMMAND HANDLER
:	====================
S.PNIT
:	CLOSE COMMAND HANDLER
:	====================
S.PNTE
	J	S.CRAS			:CRASH,FOR CURRENT CMD

:	RESET COMMAND HANDLER
:	=====================
S.PNS2
	LB	R1,LUCTAB+LUSSTA,R15,	:NEW STATE FOR NODE CONTROL
	CLHI	R1,NN.ASE		:IS IT OUT OF RANGE
	JGE	S.CRAS			:CRASH,IF YES
	LHL	R5,S.PNS3,R1,R1		:GET TABLE PTR FOR EACH STATE
	J	S.PNS3,R5,		:JUMP

S.PNS3	HS
	HC	S.CRAS-S.PNS3		:CRASH,STATE=RESET
	HC	S.PNS4-S.PNS3		:STATE=PENDING FOR DACTPU
	HC	S.PNS6-S.PNS3		:STATE=PENDING FOR ACTPU
	HC	S.CRAS-S.PNS3		:CRASH,STATE=RESET
	HC	S.PNS8-S.PNS3		:STATE=PENDING FOR DACTLU
	HC	S.PNSA-S.PNS3		:STATE=PENDING FOR ACTLU
	HC	S.CRAS-S.PNS3		:CRASH,STATE=RESET
	HC	S.CRAS-S.PNS3		:CRASH,STATE=RESET

:	PENDING FOR DACTPU (RECEIVING CLOSE RSP FROM NIO)
:	--------------------------------------------
S.PNS4
	JAL	R7,V.ALSC,,		:INF. LU.SVC.MGR AGAIN
S.PNS5
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SCB_PTR FROM LUCB
	JE	S.CRAS			:JUMP TO CRASH FOR MISMATCH SCB_PTR
	BBLOAD	R10,SCBBLK+SCMUPS,R9,	:GET PREVIOUS MU_PTR
	JLE	S.CRAS			:CRASH,IF NOT MU_PTR
	J	N.SCD0			:GOTO SEND RSP FOR DEVICE

:	PENDING FOR ACTPU (RECEIVING RESET RSP FROM NIO)
:	--------------------------------------------
S.PNS6
	JAL	R7,V.ALSC,,		:INF. LU.SVC.MGR AGAIN
S.PNS7
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SCB_PTR FROM LUCB
	JE	S.CRAS			:JUMP TO CRASH FOR MISMATCH SCB_PTR
	BBLOAD	R10,SCBBLK+SCMUPS,R9,	:GET PREVIOUS MU_PTR
	JLE	S.CRAS			:CRASH,IF NOT MU_PTR
	J	N.SCA0			:GOTO SEND RSP FOR DEVICE

:	PENDING FOR DACTLU (RECEIVING RESET RSP FROM NIO)
:	--------------------------------------------
S.PNS8
	BBLSCB	R9,LUCTAB+LULSCB,R15,	:GET LU_LU SCB
:	JE	S.CRAS			:JUMP TO CRASH (F02/9/21/87/HS/BEGIN)
	JE	S.PNS9			:SEND ACK EVEN IF NO LU_LU SCB 
					:(HOWEVER, THIS CASE SHOULD NEVER OCCUR
					:AND LU_LU SCB SHOULD ALWAYS BE THERE)
	XR	R0,R0
:(F03/12/07/87/HS/START)
:	STB	R0,LUCTAB+LULUW1,R9,	:CLEAR LU_SVC WORK STORAGE (F02/9/21/87/HS/END)
:	STB	R0,LUCTAB+LULUW1,R15,	:(F03/12/18/87/DB)
:(F03/12/07/87/HS/END)

	LHI	R0,SG.ERR		:SET 'SG.ERR' SIGNAL FOR LU.SVC
	LHI	R1,PMNSMR		:SET SNEDING PROCEDURE
	JAL	R8,V.SCER,,		:JUMP TO INF. LU.SVC
S.PNS9
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SCB_PTR FROM LUCB
	JE	S.CRAS			:JUMP TO CRASH FOR MISMATCH SCB_PTR
	BBLOAD	R10,SCBBLK+SCMUPS,R9,	:GET PREVIOUS MU_PTR
	JLE	S.CRAS			:CRASH,IF NOT MU_PTR
	J	N.SCD3			:GOTO SEND RSP FOR DEVICE

:	PENDING FOR ACTLU (RECEIVING RESET RSP FROM NIO)
:	--------------------------------------------
S.PNSA
	BBLSCB	R9,LUCTAB+LULSCB,R15,	:GET LU_LU SCB
:	JE	S.CRAS			:JUMP TO CRASH (01/23/87 YLH)
	JE	S.PNSB			:NO NEED TO SEND ANOTHER 'SG.ERR' TO
					:THE LU.SVC IF NO LU_LU SCB (01/23/87 YLH)
	XR	R0,R0			:(F02/9/21/87/HS)
:(F03/12/07/87/HS/START)
:	STB	R0,LUCTAB+LULUW1,R9,	:CLEAR LU_SVC WORK STORAGE (F02/9/21/87/HS)
:	STB	R0,LUCTAB+LULUW1,R15,	:(F03/12/18/87/DB)
:(F03/12/07/87/HS/END)

	LHI	R0,SG.ERR		:SET 'SG.ERR' SIGNAL FOR LU.SVC
	LHI	R1,PMNSMR		:SET SENDING PROCEDURE
	JAL	R8,V.SCER,,		:JUMP TO INF. LU.SVC
	JR	R14			:RETURN (01/23/87 YLH)
S.PNSB
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SCB_PTR FROM LUCB
	JE	S.CRAS			:JUMP TO CRASH FOR MISMATCH SCB_PTR
	BBLOAD	R10,SCBBLK+SCMUPS,R9,	:GET PREVIOUS MU_PTR
	JLE	S.CRAS			:CRASH,IF NOT MU_PTR
	J	N.SCA5			:GOTO SEND RSP FOR DEVICE


:	CKT DOWN COMMAND HANDLER
:	====================
:	(1)SSCP_LU ARE ACTIVE,SEND 'RESET' TO LU.SVC TO RESET
:	   SUBJECT LU_LU SESSION (CLEAR SCB,....)
:	(2)SSCP_PU IS ACTIVE,CLEAR SCB,UPDATE LUCB INFORMATION
S.PNCD
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LB	R4,LUCTAB+LUCADR,R15,	:GET ASSIGNED LU NUMBER
	JE	S.PNC1			:JUMP,IF LU=0 (PU)????
	BBLSCB	R9,LUCTAB+LULSCB,R15,	:GET SCB_PTR FOR LU_LU
:IF NOTIFY OPTION WAS CHOSEN INFORM LU SERVICE ANYWAY (01/07/86 MIA)
	IF	1-BNDNTF
	JE	S.PNC2			:IF NO LU_LU,JUMP
	ELSE
	JNFS	S.PNCX			:JUMP IF LU-LU EXISTS
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SCB_PTR FOR SSCP-LU
	JE	S.PNC2			:JUMP IF NO SSCP-LU
S.PNCX	EQ	.
	EI
	LHI	R0,SG.ZAP		:ELSE,SEND 'SG.ZAP' FOR LU.SVC.MGR
	LHI	R1,PMNSMS		:SET SENDING PROCEDURE #
	JAL	R8,V.SCER,,		:JUMP TO INF LU.SVC_MGR
	JR	R14			:RETURN
:	JAL	R5,IZSCB,,		:INIT SESSION CONTROL BLOCK
:	JAL	R5,IZPCB,,		:INIT PATH CONTROL BLOCK
:	JAL	R5,IZNCB,,		:INIT NODE CONTROL BLOCK
:	JAL	R5,IZEVB,,		:INIT ENVIRON CONTROL BLOCK
:	NO LU_LU SESSION,RECEIVE CKT DOWN FROM NIO
:	------------------------------------------
S.PNC2
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SCB_PTR
	JE	S.PNC1			:JUMP,IF NO SSCP_LU SCB_PTR
	STM	R0,SLUSAV,,
	LR	R9,R15			:GET LUCTAB INTO R9
	JAL	R12,V.CLEA,,		:CALL LU.SVC CLEAN UP ROUTINE
	LM	R0,SLUSAV,,
:	JAL	R4,V.IZSC,,		:CALL SCB_PTR CLEAN UP
	J	S.PNC1			:JUMP TO SEND RSP TO NIO

:	NO CIRCUIT SETUP, RECEIVE XCKT DOWN CMD FOR THAT LU
:	-----------------------------------------------
S.PNC0
	BBLSCB	R9,LUCTAB+LUSSCB,R15,	:GET SSCP_LU SCB_PTR
	JE	S.PNC1			:JUMP,IF NO SSCP_LU SCB_PTR
:	JAL	R4,V.IZSC,,		:CALL SCB_PTR CLEAN UP
:	CALL ROUTINE TO CLEAR LUCB
:	RECEIVE SIGNAL FOR ZAP FINISHED FROM LU
:	----------------------------
S.PNC1
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LHI	R1,XCKTDW		:SET CMD RSP TO XCKTDW
:	LIS	R3,E.POSR		:SET UP FOR POSITIVE RESPONSE (04/03/87 YLH)
	LB	R3,LUCTAB+LUSSTA,R15,	:PASS CURRENT LUSSTA TO THE NIO (04/03/87 YLH)
	JAL	R8,V.SNNW,,		:ROUTINE TO SEND CMD FROM SNA TO NIO
	JR	R14			:RETURN

:	LINK DOWN COMMAND HANDLER
:	=========================
S.PNLD
	LHL	R15,EVBLK+EVLUCB,R12,	:GET LUCB PTR FROM EV
	LB	R4,LUCTAB+LUCADR,R15,	:GET ASSIGNED LU NUMBER
	JN	S.PNCR			:CRASH,IF LU<>0,WHEN RCV LINKDOWN
	LB	R0,LUCTAB+LUSSTA,R15,	:SEE IF NN.PLW STATE (7/23/84/CHS)
	CLHI	R0,NN.PLW		:(7/23/84/CHS)
	JER	R14			:YES, RETURN (7/23/84/CHS)
	JAL	R7,V.LDWN,,		:INF. LU.SVC.MGR AGAIN
	LHL	R13,NCBPTR,RNODE,RNODE
	LB	R0,NCBBLK+NDRSTF,R13,	:ALL RSP'ED ? (7/23/84/CHS)
	LR	R0,R0			: (7/23/84/CHS)
	JNR	R14			:NO, RETURN (7/23/84/CHS)
	LIS	R0,NN.RES		:SET STATE TO RESET (7/23/84/CHS)
	STB	R0,LUCTAB+LUSSTA,R15,	:(7/23/84/CHS)
	LHI	R1,XLNKDW		:INFORM NIO (7/23/84/CHS)
	JAL	R8,V.SNNW,,		:(7/23/84/CHS)
	JR	R14			:RETURN (7/23/84/CHS)
:	JR	R14			:RETURN

:	RECEIVE SIGNAL FOR LNK DOWN FINISHED FROM LU
:	----------------------------
S.PNL1
:	(7/23/84/CHS) THE LOGIC IS MODIFIED
:	SCAN ALL SCB_PTR TO MAKE SURE ALL SCB FINISHED
:	LB	R0,NCBBLK+NDDEVN,R13,	:GET DEVICE # FROM NCB
:	SRHLS	R0,4
:	STB	R0,SCATIM,,		:FOR SCB SCANE LOOP
:	LIS	R1,0
:	STB	R1,SCAEND,,		:INIT FOR 1ST SCB_LST IND.
:	L	R1,NCBBLK+NDSCLS,R1,R13	:GET NEW SCB_LIST 
:	ST	R1,SCASAV,,		:SAVE SCB_LIST IN SAVE AREA
:	JAL	R7,V.SLST,,		:CALL ROUTINE TO GET ANY SCB
:	LR	R9,R9
:	JGR	R14			:RETURN,IF NOT FINISHED YET
	LB	R0,NCBBLK+NDRSTF,R13,	:GET COUNTER (7/23/84/CHS)
	LR	R0,R0			:(7/23/84/CHS)
	JER	R14			:EXTRA, RETURN (7/23/84/CHS)
	SIS	R0,1			:DECREASE COUNTER (7/23/84/CHS)
	STB	R0,NCBBLK+NDRSTF,R13,	:UPDATE COUNTER (7/23/84/CHS)
	LR	R0,R0			:(7/23/84/CHS)
	JNR	R14			:NOT DONE, RETURN (7/23/84/CHS)
	LHL	R8,PUCPTR,RNODE,RNODE	:GET NODE NETWORK CONTROL PTR
	LHL	R15,PUCTAB+PUCLUC,R8,	:GET 1ST LU TABLE PTR
	LB	R0,LUCTAB+LUSSTA,R15,	:GET CURRENT STATE
	CLHI	R0,NN.PLW		:IS IT PENDING FOR LINK RSP?
	JNR	R14			:JUMP,IF NOT
	LIS	R0,NN.RES
	STB	R0,LUCTAB+LUSSTA,R15,	:SET STATE TO RESET
	LHI	R1,XLNKDW		:SET CMD RSP TO XLNKDW
	LIS	R3,E.POSR		:SET UP FOR POSITIVE RESPONSE
	JAL	R8,V.SNNW,,		:ROUTINE TO SEND CMD FROM SNA TO NIO
	JR	R14			:RETURN

	SUBTTL	PU COMMON SESSION CONTROL MANAGER -- SON LOGIC

:	S.PCON	-PU.SVC_MGR.CSC_MGR.SON (PAGE 13-47 ON FAPL)
:	----------------------------------------------------
:	THE USAGE OF REGISTERS--
:	INPUT	-R12 (CURRENT EV PTR) R14 (1ST-LEVEL CALL)
:	OUTPUT	-
:	LINK	-(NO LINK REGISTER NEEDED)
:	WORKING	-
S.PCON
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	L	R9,NCBBLK+NDSSCB,R13,	:GET SCB PTR
	CLHI	R1,SG.RES		:IS IT 'HIERARCHICAL_RESET'
	JE	S.PCO1			:JUMP,IF YES
	CLHI	R1,SG.SGO		:IS IT 'SSCP_GONE'?
	JE	S.PCO2			:JUMP,IF YES
	J	S.PNCR			:OTHER SIGNAL,CRASH
:	INPUT SIGNAL IS HIERARCHICAL_RESET
:	-----------------------------------
S.PCO1
:	JAL	R8,V.SCDS,,		:CALL ROUTINE TO DISCARD SCB_PTR
:					:DONT DISCARD SCB_PTR (9/12/84/CHS)
	JR	R14			:RETURN TO DISPATCHER

:	INPUT SIGNAL IS SSCP_GONE
:	-----------------------------------
S.PCO2
	JAL	R8,V.SCDS,,		:CALL DISCARD SCB
	JR	R14			:RETURN

	SUBTTL	PU SERVICE MANAGER -- ERROR RECOVERY PROCEDURE

:	N.EAPU	-WHEN SOME SSCP_LU ARE ACTIVE,HOST SEND ACTPU TO INTERFACE
:	------------------------------------------------------------------
:	RECEIVING ACTPU FROM HOST, BUT: LOWER LEVEL SESSIONS (SSCP_LU,
:	LU_LU) ARE STILL ACTIVE.
N.EAPU
	LHI	R0,NN.PAP		:SET FOR PENDING ACTPU
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE NEW STATE
	LIS	R0,0
	STB	R0,PUCTAB+PUALUN,R8,	:RESET ACTIVE LU #
	LHI	R1,XINIT		:SET UP CMD 'INIT' REQUEST
	LIS	R3,E.REST		:SETUP STATUS OF CMD
	JAL	R8,V.SNNW,,		:SEND CMD TO NIO
	JAL	R7,V.ALSC,,		:TO SCAN ALL SCB_PTR,ANDINF. LU
	BBSTOR	R10,SCBBLK+SCMUPS,R9,	:SAVE MU_PTR FOR NEXT RSP
	JR	R14			:RETURN

:	N.EALU	-RECEIVING ACTLU FROM HOST, BUT: SSCP_LU IS NOT RESET
:	-----------------------------------------------------
:	CHECK THE SUBJECT LU_LU SESSION: CALL RESET PROCEDURE WHEN LU_LU 
:	IS ACTIVE, ELSE, SEND NEGATIVE RESPONSE
N.EALU
	CLHI	R0,NN.ALU		:IS SSCP_LU ALREADY ACTIVE
	JN	S.PNCR			:CRASH,IF SSCP_LU IS NOT ACTIVE
:	BBLSCB	R4,LUCTAB+LULSCB,R15,	:GET LU_LU SCB (10/14/86 YLH)
:	JE	N.SCA6			:JUMP IF NO LU_LU ACT (04/01/86 MIA)
:	JE	N.EAL1			:JUMP IF NO LU_LU ACT (04/01/86 MIA) (10/14/86 YLH)
	LHI	R0,NN.PAL		:SET FOR PENDING ACTLU
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE NEW STATE
	LB	R0,PUCTAB+PUALUN,R8,	:GET CURRENT ACTIVE LU #
	JE	S.PNCR			:CRASH,IF NOT ACTIVE SSCP_LU
	SIS	R0,1
	STB	R0,PUCTAB+PUALUN,R8,	:UPDATE ACTIVE LU #
	LHI	R1,XINIT		:SET UP CMD 'INIT' REQUEST
	LIS	R3,E.REST		:SETUP STATUS OF CMD
	JAL	R7,V.ONSC,,		:CALL ROUTINE TO INF. NIO & LU.SVC
	BBSTOR	R10,SCBBLK+SCMUPS,R9,	:SAVE MU_PTR FOR NEXT RSP
	JR	R14			:RETURN
:
:START DELETING (10/14/86 YLH)
:CLEAN UP LU_SVC AND CONTINUE (04/01/86 MIA).
:N.EAL1	LR	R0,R12			:SAVE R12
:	LR	R1,R9			:SAVE R9
:	LR	R9,R15			:COPY LUCB POINTER
:	JAL	R12,V.CLEA		:CLEAN UP LU_SVC
:	LR	R9,R1			:RESTORE R9
:	LR	R12,R0			:RESTORE R12
:	J	N.SCA6			:JUMP TO CONTINUE
:END OF INSERTION (04/12/86 MIA).
:END OF DELETING (10/14/86 YLH)
:
:	N.EDLU	-RECEIVING DACTLU FROM HOST, BUT: LU_LU IS NOT RESET
:	------------------------------------------------------------
:	(1) INF. LU.SVC TO PROCESS SUBJECT LU_LU CLOSE
:	(2) PROCESS SSCP_LU CLOSE PROCEDURE
N.EDLU
	BBLSCB	R4,LUCTAB+LULSCB,R15,	:GET LU_LU SCB
	JE	S.PNCR			:JUMP TO CRASH FOR MISMATCH SCB_PTR
	LHI	R0,NN.PDL		:SET FOR PENDING DACTLU
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE NEW STATE
	LHI	R1,XCLOSE		:SET UP CMD 'CLOSE' REQUEST
	LIS	R3,E.REST		:SETUP STATUS OF CMD
	JAL	R7,V.ONSC,,		:CALL ROUTINE TO INF. NIO & LU.SVC
	BBSTOR	R10,SCBBLK+SCMUPS,R9,	:SAVE MU_PTR FOR NEXT RSP
	JR	R14			:RETURN

:	N.EDPU	-RECEIVING DACTPU FROM HOST, BUT: SSCP_LU ARE ACTIVE
:	------------------------------------------------------------
:	(1) INF. LU.SVC TO PROCESS SUBJECT LU_LU CLOSE
:	(2) PROCESS SSCP_LU CLOSE PROCEDURE
N.EDPU
	LHI	R0,NN.PDP		:SET FOR PENDING DACTPU
	STB	R0,LUCTAB+LUSSTA,R15,	:UPDATE NEW STATE
	LHI	R1,XCLOSE		:SET UP CMD 'CLOSE' REQUEST
	LIS	R3,E.REST		:SETUP STATUS OF CMD
	JAL	R8,V.SNNW,,		:SEND CMD TO NIO
	JAL	R7,V.ALSC,,		:CALL SCAN ALL SCB_PTR,INF. LU
	BBSTOR	R10,SCBBLK+SCMUPS,R9,	:SAVE MU_PTR FOR NEXT RSP
	JR	R14			:RETURN

S.PNCR
	JAL	R10,CRASH,,
	BC	0,0,0,CRQPVC

	FO	CBKDEF
	FO	GBLDEF
	FO	CMDLST
	FO	OSCAN			(01/27/87 YLH)

	EM

    	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN

:::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS ALL DATA AND STORAGE DEFINITIONS TO SUPPORT
:: LU SERVICE MANAGER.
:::::::::::::::::::::::::::::::::::

	SEG	A.DATA

::LU_SVC STATES (3 HIGH BITS IN LULUST)

TRPSTA	EQ	0^5	:TRANSPARENT STATE
LOCSTA	EQ	1^5	:LOCAL STATE
PTRSTA	EQ	2^5	:PENDING TRANSPARENT STATE (AFTER FINISH LOG)
PLCSTA	EQ	3^5	:PENDING LOCAL STATE (AFTER START LOGON)
	IF	HDPSUP!VTISUP
DSPSTA	EQ	4^5	:DSP STATE
	EI

LUMSTA	EQ	4	:MAX NUMBER OF LU_SVC STATES DEFINED

	IF	HDPSUP
LUMHST	EQ	5	:MAX NUMBER OF LU_SVC STATES DEFINED FOR HPAD
	EI

	IF	VTISUP
LUMTST	EQ	5	:MAX NUMBER OF LU_SVC STATES DEFINED FOR TDSP
	EI

:LU_SVC WAITING INDICATOR (4TH BIT IN LULUST)

WAITRS	EQ	1^4

:LU_SVC SUBSTATES
:
:: COMMON SUBSTATES
LUOKST	EQ	0	:NOTHING SPECIAL
LUBDST	EQ	0F	:BAD SUBSTATE (UNABLE TO CONTINUE)
LUSBST	EQ	0F	:MAXIMUM SUBSTATE POSSIBLE (SUBSTATE MASK)

:SUBSTATES OF TRANSPARENT STATE FOR TERMINAL INTERFACE (NO SUBSTATES
:FOR HOST INTERFACE).
LUTRLG	EQ	01	:DISCOVERED SERVICE SCREEN REQUEST,
			:WAITING FOR START LOGON FROM NIO

:SUBSTATES OF LOCAL STATE FOR TERMIANL INTERFACE (NO SUBSTATES
:FOR HOST INTERFACE).
:
:SEND DIRECTION SUBSTATES
LULCIC	EQ	01	:WITHIN CHAIN WHICH DOES NOT END BRACKET OR
			:CHANGE DIRECTION
LULCLB	EQ	02	:LAST CHAIN ELEMENT AND END BRACKET OR CHANGE
			:DIRECTION
LULCIB	EQ	03	:END OF BRACKET BUT NOT LAST CHAIN ELEMENT
:
:RECEIVE DIRECTION SUBSTATES
LULCCL	EQ	04	:NEGATIVE RESPONSE RECEIVED (CLEAN SENDING
			:SIDE DATA QUEUE).

:SUBSTATES OF PENDING TRANSPARENT STATE (MORE SUBSTATES MUST BE CODED FOR
:PRINTER SUUPORT) FOR TERMINAL INTERFACE.
LUPTUB	EQ	01	:UNBIND SENT

:SUBSTATES OF PENDING TRANSPARENT STATE (MORE SUBSTATES MUST BE CODED FOR
:NOTIFY) FOR HOST INTERFACE.
LUPTON	EQ	01	:LUSTAT POWER ON (NOW AVAILABLE) SENT

:SUBSTATES OF PENDING LOCAL STATE FOR TERMINAL INTERFACE
LUPLSR	EQ	01	:ALL RSP'S ALREADY SENT
LUPLCH	EQ	02	:CHASE SENT
LUPLUB	EQ	03	:UNBIND SENT
LUPLBD	EQ	04	:BIND SENT
LUPLST	EQ	05	:SDT SENT

:SUBSTATES OF PENDING LOCAL STATE FOR HOST INTERFACE
LUPLSR	EQ	01	:ALL SSCP-LU RSP'S ALREADY SENT
LUPLSH	EQ	02	:RSHUTD OR TERM-SELF ALREADY SENT
LUPLCL	EQ	03	:READY TO CLEAN

:------------------
:STRUCTURE OF LUCB LUSVC STORAGE BYTE.
LULUBD	EQ	80	:LOCAL SESSION INTERRUPTED END-TO-END SESSION
LULUNR	EQ	40	:GENERATE "NOT READY" MSG
LULUFN	EQ	20	:FINAL STATE OF TIMEOUT PROCESS
LULUSO	EQ	10	:RSP FOR SC CATEGORY MSG OUTSTANDING
LULUNG	EQ	08	:NEGATIVE RESPONSE PENDING FOR RCV
LULURP	EQ	04	:RESPONSE PENDING FOR RCV
LULUCD	EQ	02	:CHANGE DIRECTION PENDING FOR SEND
LULUSG	EQ	01	:LAST SEGMENT PENDING FOR SEND
:------------------

:STRUCTURE OF THE SECOND WORK BYTE OF LUSVC.
:THIS BYTE IS USED IN DSP MODE AS WORK BYTE.
LULUDR	EQ	80	:DEFINITE RESPONSE PENDING FOR SEND
LULULU	EQ	40	:RSP(LUSTAT) IS PENDING FOR GENERATED LUSTAT
LULUUB	EQ	20	:UNBIND GENERATED IN TRANSPARENT MODE
LULUSL	EQ	07	:SAVED SIGNAL-1 (MAX SIG IS 8)

:NO OTHER BITS ARE USED YET.
:------------------

:STRUCTURE OF LU SVC NON-CLEAR STORAGE BYTE (NOT RESTORED BY LU SVC
:CLEARING PROCEDURE).
LUSVCB	EQ	80	:-RSP(BIND) WAS ISSUED BY HIF
LUSVCF	EQ	40	:-RSP(FMD) WAS ISSUED BY HIF

:NO OTHER BITS ARE USED YET.
:-------------------

:STRUCTURE OF PRINTER STATE HALFWORD (LUADCB IS USED IN CASE OF
:LOCAL COPY FUNCTION FOR THIS PUPOSE).
LUSPRT	EQ	0E000	:3 HIGH BITS - START PRINTER STATE
WSFLGT	EQ	01FFF	:THE REST - LENGTH OF STRUCTURED FIELD + 1,
			:		0 IF 3270 CMD IS NOT WSF

:SUBSTATES WITHIN LUSPTR.
LUSPS0	EQ	0^0D	:SEARCH FOR NEXT STRUCTURED FIELD
LUSPS1	EQ	1^0D	:GOT 1ST BYTE OF STRUCTURED FIELD LENGTH
LUSPS2	EQ	2^0D	:GOT 2ND BYTE OF STRUCTURED FIELD LENGTH
LUSPS3	EQ	3^0D	:GOT STRUCTURED FIELD ID
LUSPS4	EQ	4^0D	:GOT PID
LUSPS5	EQ	5^0D	:GOT PARTITION COMMAND
LUSPS6	EQ	6^0D	:GOT WCC
:--------------------------------

:LUSVC CRASH CODES.
:ASSIGN ALL CRASH CODES TO CRQLVC - COMMON CRASH CODE FOR LU SERVICE
:MANAGER.
CR.ILU	EQ	CRQLVC
CR.NBF	EQ	CRQLVC
CR.LSN	EQ	CRQLVC
CR.TMP	EQ	CRQLVC
CR.TSP	EQ	CRQLVC
CR.NSE	EQ	CRQLVC
CR.NDT	EQ	CRQLVC
CR.IMG	EQ	CRQLVC
CR.NCK	EQ	CRQLVC
CR.FID	EQ	CRQLVC
CR.WNA	EQ	CRQLVC
CR.LUL	EQ	CRQLVC
CR.LCH	EQ	CRQLVC
CR.TCK	EQ	CRQLVC
CR.WSG	EQ	CRQLVC

:SNA SENSE CODES PROCESSED IN LUSVC TERMINAL INTERFACE.
LUCDSN	EQ	829	:CHANGE DIRECTION REQUIRED
LUBYSN	EQ	82D	:LU BUSY

:SNA SENSE CODES PROCESSED IN LUSVC HOST INTERFACE.
LUNNSN	EQ	80A	:-RSP(BIND), SSCP WILL NOT BE NOTIFIED
LUNFSN	EQ	845	:-RSP(BIND), SSCP WILL BE NOTIFIED (4/22/85/CHS)
LUONSN	EQ	82B	:NOW AVAILABLE, SCREEN LOST
LUOFSN	EQ	831	:POWER OFF
LUNSSN	EQ	1007	:CATEGORY NOT SUPPORTED
LUIRSN	EQ	0002	:INTERVENTION REQUIRED SENSE CODE (PRINTER)
LUBRSN	EQ	814	:BRACKET BID REJECT
LUPSSN	EQ	807	:PRINTER BUSY
LUPLSN	EQ	82F	:PRINTER UNAVAILABLE

:SNA SIGNAL CODES PROCESSED BY LU SERVICE MANAGER.
LURQSG	EQ	1	:REQUEST TO SEND SIGNAL

:LU SERVICE MANAGER TIMEOUT VALUES.
TM.LUS	EQ	20	:RUN LUSVC TIMEOUT ROUTINE EVERY 32 SECS.(8/29/86/CHS)

:	CANNED MESSAGES SENT ON SSCP-LU SESSION

	IF	TERMIF

LUNRMG	EQ	SNT50T	:INTERFACE NOT READY

LUDRMG	EQ	SNT51T	:MESSAGE DISCARDED

LUGBMG	EQ	SNT52T	:HIT SYS/REQ KEY TO RETURN TO SLU-LU SCREEN

	EI	(TERMIF)
:LU_SVC CONSTANTS

LUINV	EQ	1	:TEST FOR INVALID HALF-WORD POINTERS
LUCHNI	EQ	80	:CHAINS ALLOWED SCB INDICATOR
LURTYP	EQ	30	:RESPONSE TYPE SCB INDICATOR
LUDRI	EQ	20	:DEFINITE RESPONSE SCB INDICATOR

THDISP	EQ	0	:DISPLACEMENT OF TH HEADER IN DATA
			:MESSAGE FROM NIO

LUCTEI	EQ	10	:EXP RSP IND IN CT ELEMENT

FIDLGT	BC	1A,0A,0A,6,2	:TABLE OF LENGTHS FOR FIDF, FID0,
				:FID1, FID2, FID3, FID4 (THIS ORDER)

DFCTAB	BC	LUSTAT,RTR,BIS,SBI,QEC,QC,RELQ,CANCEL,CHASE
	BC	SHUTD,SHUTC,RSHUTD,BID,SIG	:TABLE OF DFC RQ CODES
DFCTBE	EQ	.			:END OF DFC TABLE

DUMDCB	EQ	4	:VALUE FOR DUMMY DCB POINTER
FID2LG	EQ	6	:LENGTH OF FID2 TH HEADER

	IF	TERMIF
SDTLGT	EQ	1	:LENGTH OF SDT CANNED RU
SDTCAN	BC	0A0	:SDT CANNED RU
UBDCAN	BC	32,01	:UNBIND CANNED RU
	EI

UBDLGT	EQ	2	:LENGTH OF UNBIND CANNED RU
UBDNRM	EQ	1	:NORMAL REASON FOR UNBIND
UBDRSN	EQ	99	:NON-EXISTANT IN SNA REASON FOR UNBIND

	IF	HOSTIF
	IF	RSHTSW	:IF RSHUTD ALLOWED
RSHLGT	EQ	1	:LENGTH OF RSHUTD CANNED RU
RSHCAN	BC	0C2	:RSHUTD CANNED RU
	ELSE
TSFLGT	EQ	6	:LENGTH OF TERMINATE-SELF CANNED RU
:TSFCAN	BC	01,06,83,00,0F3,00	:TERM-SELF CANNED MESSAGE
TSFCAN	BC	01,06,83,40,0F3,00	:(3.F01/06/16/87/DB)
	EI
LUONLG	EQ	5	:LENGTH OF LUSTAT POWER ON CANNED MESSAGE
LUONCN	BC	04,08,2B,00,00	:LUSTAT POWER ON CANNED MESSAGE
LUOFLG	EQ	5	:LENGTH OF LUSTAT POWER OFF CANNED MESSAGE
LUOFCN	BC	04,08,31,00,00	:LUSTAT POWER OFF CANNED MESSAGE
LUCDLG	EQ	5	:LENGTH OF LUSTAT CHANGE DIRECTION MESSAGE
LUCDCN	BC	04,00,02,00,00	:LUSTAT NOTHIN TO SEND, CD MESSAGE
LUAVCN	BC	04,00,01,00,00	:LUSTAT NOW AVAILABLE CANNED MESSAGE
LUAVLG	EQ	5	:LENGTH OF LUSTAT AVAILABLE CANNED MESSAGE
NTFYLG	EQ	0B	:LENGTH OF NOTIFY CANNED MESSAGE(4/22/85/CHS)
NTFYCN	BC	81,06,20,0C,06,03,00,01,00,00,00 :(4/22/85/CHS) READY
			:NOTIFY CANNED MESSAGE(4/22/85/CHS)
NTFYNC	BC	81,06,20,0C,06,01,00,01,00,00,00 :(4/22/85/CHS) NOT READY
			:NOTIFY CANNED MESSAGE(4/22/85/CHS)
	EI

:
:BEGIN (11/12/86 YLH)
:
:DEFINE THE UNBIND REASON CODES WHICH RETAIN THE NETWORK CIRCUIT
:
	IF	UNBNDS
UBNTBL	BC	RETNUM		:NUMBER OF REASON CODES
N	EQ	1
	RE	RETNUM
	BC	RCOD|N|		:REASON CODE
N	EQ	N+1
	ER
	EI(UNBNDS)
:
:END (11/12/86 YLH)
:

:LOCAL STORAGE AREAS

LURGSV	HS	20	:REGISTER SAVE AREA
LURGS1	HS	20	:ALTERNATE REGISTER SAVE AREA

	FO	MAIN	
	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER

	EM
    	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN
	
::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS CONSTANTS AND DATA
:: AREAS FOR LU SERVICE MANAGER IN DSP MODE.
::::::::::::::::::::::::::::::::::::::

:SUBSTATES OF DSP STATE (BITS IN LULUST BYTE IN LUCB).
LUDPSG	EQ	01		:SIGNAL WAS GENERATED AND SENT
LUDPKB	EQ	02		:LAST KEYBOARD RESTORE BIT FROM WCC
LUDPCL	EQ	04		:CLEANING IN PROGRESS
LUDPER	EQ	08		:EXR INDICATOR (06/17/86 YLH)

:STRUCTURE OF LU SVC WORK BYTE (THE REST OF THE BITS ARE USED AS IN
:LOCAL MODE).
LULUFA	EQ	80		:FINAL BIT FOR ACK TIMEOUT
LULUAK	EQ	40		:ACK PENDING
LULUCD	EQ	02		:CHANGE DIRECTION PENDING FOR RCV
LULUCN	EQ	01		:CANCEL PENDING FOR SEND

:SENSE CODES USED FOR DSP SUPPORT.
LUBDSN	EQ	821		:BAD BIND PARAMETERS

:SIGNAL CODES USED FOR DSP SUPPORT.
LURQSG	EQ	1		:REQUEST TO SEND SIGNAL

:TYPES OF UNBIND CHECKED FOR DSP SUPPORT.
LUUBFR	EQ	2		:BIND FORTHCOMING


	IF	HOSTIF
:CANNED "COMMAND UNRECOGNIZED" MESSAGE.
:	FROM SNA 1.06, IT IS FORMATED AS 'SSCP-LU' RU FIRST
LUURMG	EQ	SNH50T		:COMMAND UNRECOGNIZED
	EI

:SYSTEM REQUEST KEY DEFINITIONS.
ATTAID	EQ	0FF		:ATTENTION KEY AID (GENERATED BY CMT)
SRQAID	EQ	0F0		:SYSTEM REQUEST KEY AID (GENERATED BY CMT)
WSTCMD	EQ	0FF		:WRITE STATUS COMMAND (FROM HIF TO CMT)

:SCREEN STATES.
LUSUNW	EQ	0		:UNOWNED
LUSSYS	EQ	1		:SYSTEM
LUSAPL	EQ	2		:APPLICATION
LUSFUW	EQ	3		:FORCE UNOWNED (03/20/86 YLH)

:ERROR IN OPERATOR'S INPUT (SENT AS THE SCREEN STATE IN WRITE STATUS COMMAND)
LUSERR	EQ	4		:ERROR IN INPUT

:SEQUENCE NUMBER OF HOST INITIATED STATUS (02/24/86 YLH)
HSTINI	EQ	40

:STRUCTURE OF LUCB SCREEN STATE BYTE (LUCSCN).
LUSCRN	EQ	80		:SCREEN STATES SUPPORTED BY TIF
LUCLLU	EQ	40		:CLEAN UP LU-LU MESSAGES
LUCLCP	EQ	20		:CLEAN UP SSCP-LU MESSAGES
LUSCOP	EQ	10		:CHAIN IS OPEN
LUSSOP	EQ	08		:SEGMENT IS OPEN
LUSSCN	EQ	03		:SCREEN STATUS (UNOWNED, SYSTEM, APPLICATION)

:	IF	HDPSUP
	IF	HDPSUP!VTISUP	:(3.F00/10/14/87/DB)

	SEG	A.DATA

:CANNED SIGNAL MESSAGE WITH REQUEST TO SEND SIGNAL CODE.
SIGCAN	BC	0C9,0,1,0,0	:SIG, REQUEST TO SEND
SIGLGT	EQ	5		:LENGTH OF SIGNAL MESSAGE

:CANNED CANCEL MESSAGE.
CANCAN	BC	83		:CANCEL
CANLGT	EQ	1		:LENGTH OF CANCEL MESSAGE

:CANNED LUSTAT MESSAGE.
	HS	0		:ALLIGN TO HALF-WORD BOUNDARY
	BC	0		:SKIP ONE BYTE
LUSTCN	BC	04,00,00,00,00	:LUSTAT, STATUS CODE NOT SPECIFIED
LUSTLG	EQ	5		:LENGTH OF LUSTAT

:CANNED SHUTC MESSAGE.
SHTCAN	BC	0C1		:SHUTC
SHTLGT	EQ	1		:LENGTH OF SHUTC MESSAGE

	EI

	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER
	FO	MAIN

	EM
    	MO	.,SNTPKG

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN
	
::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS CONSTANTS AND DATA
:: AREAS FOR LU SERVICE MANAGER FOR VIRTUAL TERMINAL INTERFACE IN DSP MODE
::::::::::::::::::::::::::::::::::::::

	IF	VTISUP

	SEG	A.DATA

:SUBSTATES OF DSP STATE (BITS IN LULUST BYTE IN LUCB).
LUTDBR	EQ	01		:BRACKET TERMINATION PENDING
LUTDFL	EQ	02		:SENDING OF A DATA MESSAGE IN PROGRESS
LUDPCL	EQ	04		:CLEANING IN PROGRESS
LUDPER	EQ	08		:EXR INDICATOR (06/17/86 YLH)

:STRUCTURE OF LU SVC WORK BYTE IS THE SAME AS IN HOST DSP MODE,
:EXCEPT LULUCD IS CHANGE DIRECTION DOR SEND.

:STRUCTURE OF LUCB SCREEN STATE BYTE (LUCSCN) IS THE SAME AS IN HOST
:DSP MODE.

:STRUCTURE OF LULUW2.
LULURT	EQ	80			:WAIT FOR RTR
LUTDCD	EQ	40			:CHANGE DIRECTION FOR RECEIVE
LUSYRQ	EQ	08			:SYSTEM REQUEST CYCLE
LUSTSQ	EQ	07			:STATE BITS FOR SYS/REQ

:SNA BIT DEFINITIONS FOR VTI.
LUBDBR	EQ	20			:BRACKET USAGE

:CANNED MESSAGES FOR VTI.
BIDCAN	BC	0C8			:CANNED BID MESSAGE
BIDLGT	EQ	1			:LENGTH OF BID MESSAGE

:SCREEN SIZE CONSTANTS.
SCRN24	EQ	$A 24			:SCREEN DEPTH
SCRN80	EQ	$A 80			:SCREEN WIDTH

	EI	(VTISUP)

	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER
	FO	MAIN

	EM
 	MO	.,SNTPKG

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN
	LO	SNAPKG

:::::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS ALL UTILITY ROUTINES
:: TO SUPPORT LU SERVICE MANAGER IN TERMINAL DSP MODE.
:::::::::::::::::::::::::::::::::::::::::

	SEG	A.CODE

	IF	VTISUP

	GL	L.PTCH,HSBADR,L.PTCD,L.CLER,NOBUFF

::::::::::::::::::::::::::::::::::::::::::
:: THE FOLLOWING ROUTINE MAPS DATA MESSAGE (DSP COMMAND)
:: INTO SSCP-LU MESSAGE.
:: THE ROUTINE CREATES MUCB AND RETURNS ITS ADDRESS IN R10.
:: IT ALSO CONVERTS 3270 DATA STREAM FROM DSP COMMAND MESSAGE
:: INTO SNA CHARACTER STREAM IF CERTAIN LIMITATION ARE MET.
:: THE RETURN CODE OF 0 IN R0 MEANS SUCCESSFUL CONVERSION,
:: OTHERWISE 1 IS RETURNED. OTHER REGISTERS ARE PRESERVED.
::::::::::::::::::::::::::::::::::::::::::

L.MTSC	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LR	R15,R7			:SAVE SCB POINTER
	JAL	R4,GBB,,		:GET BUFFERLET FOR MUCB
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	LR	R10,R3			:COPY MUCB POINTER

:FILL MUDIRE, MUOADP AND MUDADP
	LIS	R4,SENT			:GET SEND INDICATOR FOR DIRECTION
	STB	R4,BBUFER+MUDIRE,R10,	:PUT IT IN MUCB
	XR	R4,R4			:CLEAR THE REGISTER
	STB	R4,BBUFER+MUSCHK,R10,	:CLEAR SENSE-CHECK
	XR	R4,R4			:CLEAR THE REGISTER
	STB	R4,BBUFER+MUOADP,R10,	:PUT IT IN MUCB DESINATION
	LB	R4,LUCTAB+LUCADR,R9,	:GET SECONDARY LOCAL ADDRESS
	STB	R4,BBUFER+MUDADP,R10,	:PUT IT IN MUCB ORIGINATION

:NOW GET POINTER TO THE MESSAGE
	BBLOAD	R2,CMDBLK+CLARG,R8,	:POINTER TO PIU FROM NIO
	BBSTOR	R2,BBUFER+MUCBTU,R10,	:STORE IT IN MUCB

:FILL IN 1ST BYTE OF TH AND RH INFORMATION.
	LR	R4,R1			:COPY SUBCOMMAND
	NHI	R4,NSDTIS		:LEAVE SEGM INFO ONLY
	XHI	R4,NSDTIS		:INVERT IT
	SLLS	R4,2			:SHIFT TO THE RIGHT POSITION
	OHI	R4,FID2^4		:INDICATE FID2
	STB	R4,BBUFER+MUBIUF,R10,	:STORE IT IN MUCB
	LR	R4,R1			:COPY SUBCOMMAND
	NHI	R4,NSDTIC		:LEAVE CHAINING INFO ONLY
	XHI	R4,NSDTIC		:INVERT IT
	SRLS	R4,2			:SHIFT TO THE RIGHT POSITION
	STB	R4,BBUFER+MURHF1,R10,	:STORE 1ST BYTE OF RH IN MUCB
	LHI	R4,MU.DR1		:PREPARE DEFINIE RESPONSE CHAIN
	STB	R4,BBUFER+MURHF2,R10,	:STORE 2ND BYTE OF RH IN MUCB
	XR	R4,R4			:NO BRACKET INFORMATION
	STB	R4,BBUFER+MURHF3,R10,	:STORE 3RD BYTE OF RH IN MUCB

:FILL IN SEQUENCE NUMBER FIELD.
	LHL	R4,SCBBLK+SCSQSC,R15,	:GET PREVIOUS ID
	THI	R1,NSDTLS		:1ST SEGMENT?
	JEFS	L.MTSS			:JUMP IF NOT
	AIS	R4,1			:INCREASE IT BY 1
	STH	R4,SCBBLK+SCSQSC,R15,	:PUT IT BACK
L.MTSS	STH	R4,BBUFER+MUSNF,R10,	:STORE IT IN MUCB

:PREPARE REGISTERS FOR CONVERSION.
	LHL	R5,CMDBLK+CLLNG,R8,	:GET LENGTH OF MSG
	SIS	R5,FID2LG		:ADJUST FOR TH LENGTH
	LIS	R8,FID2LG		:DISPLACEMENT TO SOURCE BUFFER
	JAL	R4,GBB,,		:GET BUFFER FOR CONVERTED MSG
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LR	R11,R3			:SAVE POINTER TO NEW BTU
	LR	R13,R8			:DISPLACEMENT TO NEW MSG BUFFER
	XR	R15,R15			:NEW MSG LENGTH COUNTER
	LB	R14,LUCTAB+LULUW3,R9,	:SAVED ROW#
	LB	R12,LUCTAB+LULUW2,R9,	:SAVED COLUMN#

:ADJUST REGISTERS FOR THE FIRST SEGMENT.
	THI	R1,NSDTLS		:FIRST SEGMENT?
	JN	L.MTS2			:JUMP IF NOT
	SIS	R5,3			:ADJUST MSG LENGTH FOR RH
	AIS	R8,3			:ADJUST SOURCE BUFFER DIPSLACEMENT
	AIS	R13,3			:ADJUST NEW MSG BUFFER DISPLACEMENT

:ONLY TWO 3270 COMMANDS WILL BE CONVERTED (WRITE AND ERASE/WRITE).
	THI	R1,NSDTLC		:FIRST IN CAHIN?
	JN	L.MTS2			:JUMP IF NOT
	LB	R0,BBUFER,R2,R8		:GET 3270 COMMAND CODE
	CHI	R0,WCMD			:WRITE COMMAND?
	JEFS	L.MTS1			:JUMP IF SO
	CHI	R0,EWCMD		:ERASE/WRITE?
	JN	L.MTSF			:CONVERSION FAILURE IF NOT
L.MTS1	SIS	R5,2			:ADJUST REMAING LENGTH
	JLE	L.MTSF			:FAILURE IF NOTHING LEFT
	AIS	R8,2			:ADJUST DISPLACEMENT TO SOURCE BUFFER
	LB	R0,LUCTAB+LUCSYS,R9,	:GET VENDOR CODE
	CHI	R0,HITACHI		:HITACHI?
	JNFS	L.MTS2			:JUMP IF NOT
	SIS	R5,1			:ADJUST FOR 1 EXTRA BYTE IN WCC
	JLE	L.MTSF			:FAILURE IF NOTHING LEFT
	AIS	R8,1			:ADJUST DISPLACEMENT TO SOURCE BUFFER

:START OF CONVERSION LOOP.
L.MTS2	CHI	R8,BBFLSZ-BBFPSZ	:END OF SOURCE BUFFERLET?
	JLFS	L.MTS3			:JUMP IF NOT
	XR	R8,R8			:BEGINNING OF NEW BUFFERLET
	BBLOAD	R2,BBUFER+BBFLSZ-BBFPSZ,R2,	:NEXT BUFFERLET IN CHAIN
L.MTS3	LB	R0,BBUFER,R2,R8		:GET NEXT CHAR FROM SOURCE MSG
	CHI	R0,SP.			:CONTROL CHARACTER?
	JL	L.MTS4			:JUMP IF SO

:THIS IS A GRAPHIC CHARACTER. PUT IT IN THE NEW MESSAGE.
L.MTSP	JAL	R6,L.PTCH		:PUT THE CHAR IN NEW MSG BUFFER
	AIS	R12,1			:ADVANCE SCREEN POSITION
	CHI	R12,SCRN80		:PAST 80?
	JLFS	L.MTSN			:JUMP IF NOT
	XR	R12,R12			:BACK TO COLUMN 0
	AIS	R14,1			:ADVNACE ROW NUMBER
	CHI	R14,SCRN24		:PAST LINE 24
	JLFS	L.MTSN			:JUMP IF NOT
	XR	R14,R14			:BACK TO LINE 0
L.MTSN	AIS	R8,1			:ADVANCE SOURCE BUFFER DISPLACEMENT
	SIS	R5,1			:DECREASE SOURCE MSG COUNTER
	JG	L.MTS2			:CONTINUE UNTIL FINISHED
	JL	L.MTSF			:FAILURE IF EXHAUSTED

:MAPPING FINISHED. PUT RU POINTER AND DCF IN MUCB AND RETURN WITH 0 RC.
:RELEASE BUFFERLETS WITH THE SOURCE MESSAGE.
L.MTSE	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET SOURCE BTU POINTER
	BBSTOR	R11,BBUFER+MUCBTU,R10,	:SAVE POINTER TO NEW BTU
	AIS	R11,FID2LG		:POINT TO RU
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.BIU		:FIRST SEGMENT?
	JEFS	L.MTST			:JUMP IF NOT
	AIS	R11,3			:ADJUST RU POINTER FOR RH
L.MTST	BBSTOR	R11,BBUFER+MURUPT,R10,	:PUT RU POINTER IN MUCB
	STH	R15,BBUFER+MUDCF,R10,	:STORE DATA COUNT FIELD
	STB	R12,LUCTAB+LULUW2,R9,	:SAVE CURRENT COLUMN NUMBER
	STB	R14,LUCTAB+LULUW3,R9,	:SAVE CURRENT ROW NUMBER
	L	R11,LURGSV+2C,,		:RESTORE THE REGISTER
	JAL	R5,R.PBBC,,		:RELEASE BUFFERLET WITH SOURCE MSG
	ST	R10,LURGSV+28,,		:PUT MUCB POINTER IN R10 AREA
	LM	R0,LURGSV,,		:RESTORE ALL REGISTRES
	XR	R0,R0			:NORMAL RETURN CODE
	JR	R5			:AND RETURN

:CONTROL CHARACTER IN THE SOURCE DATA STREAM. ONLY SF, SBA, IC AND
:RA ORDERS ARE PROCESSED (THEY ARE THE ONLY ONES USED IN SNA HIF).
L.MTS4	CHI	R0,SF.			:START FIELD?
	JE	L.MTS5			:JUMP IF SO
	CHI	R0,SBA.			:SBA ORDER?
	JE	L.MTS7			:JUMP IF SO
	CHI	R0,IC.			:INSERT CURSOR?
	JE	L.MTSN			:IGNORE IT
	CHI	R0,RA.			:REPEAT TO ADDRESS?
	JE	L.MTS8			:JUMP IF SO
	CHI	R0,NULL.		:NULL CHARACTER?
	JE	L.MTS6			:JUMP IF SO
	J	L.MTSF			:OTHERWISE CONVERSION FAILURE

:SF ORDER. SKIP NEXT BYTE (2 BYTES FOR HITACHI).
L.MTS5	JAL	R4,L.GTCR		:GET SOURCE CHARACTER
	LB	R4,LUCTAB+LUCSYS,R9,	:GET VENDOR CODE
	CHI	R4,HITACHI		:HITACHI?
	JN	L.MTSN			:TO MAIN LOOP IF NOT
	JAL	R4,L.GTCR		:GET NEXT SOURCE CHARACTER
	J	L.MTSN			:RETURN TO MAIN LOOP

:NULL CHARACTER. REPLACE IT BY SPACE.
L.MTS6	LHI	R0,SP.			:PRETEND SPACE WAS RECEIVED
	J	L.MTSP			:RETURN TO MAIN LOOP

:SBA ORDER. THERE IS NO WAY TO PROCESS IT IF THE BUFFER POSITION
:JUMPS IN THE MIDDLE OF A SCREEN LINE. ALSO, SNA HIF DOES NOT
:GENERATE THIS KIND OF SBA. THE ROUTINE WILL GENERATE A NUMBER
:OF NEW LINE (NL) CHARACTERS TO MATCH SBA.
L.MTS7	AIS	R8,1			:ADVANCE SOURCE BUFFER DISPLACEMENT
	SIS	R5,1			:DECREASE SOURCE BUFFER COUNTER
	JLE	L.MTSF			:FAILURE IF LAST CHAR
	JAL	R4,L.GTCR		:OBTAIN NEXT CHAR
	LR	R1,R0			:SAVE IT
	JAL	R4,L.GTCR		:OBTAIN ONE MORE CHAR
	JAL	R4,L.CADR		:FIND ROW AND COLUMN NUMBERS
	LR	R1,R1			:COLUMN 0?
	JN	L.MTSF			:FAILURE IF NOT
	LR	R4,R14			:SAVE ROW NUMBER
	LR	R14,R0			:COPY NEW ROW NUMBER
	LR	R12,R12			:BEGINNING OF SCREEN LINE?
	JEFS	L.MTSL			:JUMP IF SO
	SIS	R4,1			:OTHERWISE ONE EXTRA NL REQUIRED
L.MTSL	LR	R12,R1			:COPY NEW COLUMN NUMBER
	SR	R0,R4			:NUMBER OF NL'S TO PUT
	JE	L.MTSN			:RETURN IF NONE REQUIRED
	JGFS	L.MTSA			:JUMP IF NO WRAPAROUND
	AHI	R0,SCRN24		:OTHERWISE WRAP AROUND
L.MTSA	LR	R1,R0			:COPY NL COUNTER
	LHI	R0,NL.			:PREPARE NEW LINE CHARACTER
L.MTSB	JAL	R6,L.PTCH		:PUT NL IN NEW MSG BUFFER
	SIS	R1,1			:DECREASE NL COUNTER
	JGBS	L.MTSB			:CONTINUE UNTIL FINISHED
	J	L.MTSX			:JUMP TO CONTINUE

:REPEAT TO ADDRESS ORDER RECEIVED. FILL THE NEW BUFFER WITH THE
:SPECIFIED FILL CHARACTER THE REQUIRED NUMBER OF TIMES.
L.MTS8	AIS	R8,1			:ADVANCE SOURCE BUFFER DISPLACEMENT
	SIS	R5,1			:DECREASE SOURCE MSG COUNTER
	JLE	L.MTSF			:FAILURE IF ALL FINISHED
	JAL	R4,L.GTCR		:GET NEXT CHAR
	LR	R1,R0			:COPY IT
	JAL	R4,L.GTCR		:GET SECOND PART OF ADDR
	JAL	R4,L.CADR		:CALCULATE ROW AND COLUMN#
	LR	R4,R14			:COPY CURRENT ROW NUMBER
	LR	R6,R12			:COPY CURRENT COLUMN NUMBER
	LR	R14,R0			:NEW ROW NUMBER
	LR	R12,R1			:NEW COLUMN NUMBER
	SR	R0,R4			:DIFFERENCE IN ROW NUMBERS
	LHI	R4,SCRN80		:GET SCREEN WIDTH
	MHR	R0,R4			:# OF FILL CHARS TO GET TO NEW ROW
	SR	R1,R6			:DIFFERENCE IN COLUMN NUMBERS
	AR	R1,R0			:TOTAL NUMBER OF FILL CHARS
	JE	L.MTSF			:FAILURE IF NONE
	JGFS	L.MTSU			:JUMP IF NO WRAPAROUND
	AHI	R1,SCRN80*SCRN24	:ADJUST FOR WRAPAROUND
L.MTSU	JAL	R4,L.GTCR		:GET FILL CHARACTER
	CHI	R0,SP.			:GRAPHIC?
	JGEFS	L.MTSV			:JUMP IF SO
	LHI	R0,SP.			:OTHERWISE REPLACE BY BLANK
L.MTSV	JAL	R6,L.PTCH		:PUT CHAR IN NEW MSG BUFFER
	SIS	R1,1			:DECREASE COUNTER OF FILL CHARS
	JGBS	L.MTSV			:CONTINUE UNTIL FINISHED
L.MTSX	LR	R5,R5			:ANY CHARS REMAINING
	JG	L.MTS2			:CONTINUE IF SO
	J	L.MTSE			:OTHERWISE END OF CONVERSION

:CONVERSION TO SNA CHARACTER STREAM FAILED. RETURN WITH RETCODE OF 1.
L.MTSF	ST	R10,LURGSV+28,,		:PUT MUCB POINTER IN R10 AREA
	LR	R3,R11			:COPY POINTER TO NEW MSG BUFFERS
	L	R11,LURGSV+2C,,		:RESTORE R11
	JAL	R5,R.PBBC,,		:RELEASE BUFFERS WITH NEW MSG
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	LIS	R0,1			:ABNORMAL RETURN CODE
	JR	R5			:RETURN

:::::::::::::::::::::::
:: THE FOLLOWING ROUTINE CONVERTS 3270 ADDRESS INTO ROW# AND COLUMN#.
:: INPUT: R1 - 1ST BYTE OF 3270 ADDRESS,
::	  R0 - 2ND BYTE OF 3270 ADDRESS.
:: OUTPUT: R0 - ROW#
::	   R1 - COLUMN#
:: DESTORYS R6
:: LINK:  R4
L.CADR	LB	R6,LUCTAB+LUCSYS,R9,	:GET VENDOR CODE
	CHI	R6,HITACHI		:HITACHI?
	JEFS	L.CAD2			:JUMP IF SO

:NON-HITACHI ADDRESS CONVERSION.
	NHI	R0,3F			:LEAVE ESSENTIAL BITS OF 2ND BYTE
	NHI	R1,3F			:LEAVE ESSENTAIL BITS OF 1ST BYTE
	SLLS	R1,6			:SHIFT HIGH PART OF ADDR
L.CAD1	OR	R0,R1			:MERGE LOW AND HIGH PARTS OF ADDR
	LHI	R6,SCRN80		:GET SCREEN WIDTH
	DR	R0,R6			:QUOTIENT - ROW#, REMAINDER - COL#
	JR	R4			:RETURN

:HITACHI ADDRESS CONVERSION.
L.CAD2	NHI	R1,1F			:5 BITS OF 1ST BYTE
	NHI	R0,3F			:6 BITS OF 2ND BYTE
	SLLS	R0,5			:SHIFT HIGH PART OF ADDRESS
	JBS	L.CAD1			:JUMP TO CONTINUE

:::::::::::::::::::::::::::::
:: THE FOLLOWING ROUTINE IS CALLED DURING 3270/SCS CONVERSION TO GET
:: THE NEXT CHARACTER FROM THE SOURCE MESSAGE.
:: INPUT: R2 - CURRENT BUFFERLET WITH THE SOURCE MESSAGE,
::	  R8 - DISPLACEMENT WITHIN THE BUFFERLET WITH THE SOURCE MESSAGE.
:: OUTPUT: R0 - CHARACTER FETCHED
:: LINK: R4
:::::::::::::::::
L.GTCR	CHI	R8,BBFLSZ-BBFPSZ	:END OF BUFFERLET?
	JLFS	L.GTC1			:JUMP IF NOT
	XR	R8,R8			:BEGINNING OF NEXT BUFFERLET
	LB	R2,BBUFER+BBFLSZ-BBFPSZ,R2,	:ADVANCE TO NEXT BUFFERLET
L.GTC1	LB	R0,BBUFER,R2,R8		:FETCH THE CHAR
	AIS	R8,1			:ADVANCE TO NEXT CHAR
	SIS	R5,1			:DECREASE SOURCE MSG COUNTER
	JGER	R4			:NORMAL RETURN IF FETCH OK
	J	L.MTSF			:OTHERWISE CONVERSION FAILURE

:::::::::::::::::::::::::::
:: THE FOLLOWING ROUTINE CONVERTS ONE SEGMENT SSCP-LU MESSAGE
:: INTO 3270 DATA STREAM.
L.CVRT	LHL	R14,BBUFER+MUDCF,R10,	:GET DATA COUNT FOR THE RECEIVED MSG
	LB	R8,LUCTAB+LULUW2,R9,	:GET CURRENT COLUMN NUMBER
	LB	R12,LUCTAB+LULUW3,R9,	:GET CURRENT ROW NUMBER
	SIS	R14,3			:ADJUST DATA COUNT FOR RH
	AR	R14,R8			:PLUS CURRENT COLUMN NUMBER
	LHI	R5,SCRN80		:PREPARE SCREEN WIDTH
	DR	R14,R5			:QUONT - ADV TO ROWS, REMNDER - COL#
	AR	R14,R12			:NEW ROW NUMBER
	CHI	R14,SCRN24		:WRAP AROUND?
	JLFS	L.CVR1			:JUMP IF NOT
	SHI	R14,SCRN24		:WRAP AROUND
L.CVR1	STB	R15,LUCTAB+LULUW2,R9,	:SAVE NEW COLUMN NUMBER
	STB	R14,LUCTAB+LULUW3,R9,	:SAVE NEW ROW NUMBER
	JAL	R4,GBB,,		:GET BUFFERLET FOR CONVERTED MSG
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBR,,		:COUNT IT
	LHI	R0,AIDENT		:PREPARE ENTER AID
	STB	R0,BBUFER+9,R3,		:PUT IT IN THE BUFFERLET
	LHI	R5,SCRN24-1		:PREPARE SCREEN DEPTH
	LHI	R1,SCRN80-1		:PREPARE SCREEN WIDTH
	LR	R4,R14			:COPY CURSOR POSITION AFTER MSG
	LR	R1,R15			:COPY COLUMN NUMBER OF CURSOR
	JAL	R6,HSBADR		:CALCULATE 3270 ADDR
	STH	R0,BBUFER+0A,R3,	:PUT IT IN BUFFERLET
	LHI	R0,SBA.			:PREPARE SBA ORDER
	STB	R0,BBUFER+0C,R3,	:PUT IT IN BUFFERLET
	LR	R4,R12			:COPY ROW OF MSG BEGINNING
	LR	R1,R8			:COPY COLUMN OF MSG BEGINNING
	JAL	R6,HSBADR		:CALCULATE 3270 ADDR
	EXBR	R1,R0			:GET 1ST BYTE OF ADDR
	STB	R1,BBUFER+0D,R3,	:PUT 1ST BYTE OF ADDR IN BUFFERLET
	STB	R0,BBUFER+0E,R3,	:PUT 2ND BYTE OF ADDR IN BUFFERLET
	LIS	R13,0F			:PREPARE INDEX TO BUFFERLET
	LIS	R15,9			:6 CHARS ALREADY THERE + RH
	BBLOAD	R2,BBUFER+MUCBTU,R10,	:GET POINTER TO MSG TO CONVERT
	LR	R12,R2			:SAVE IT
	LHI	R8,9			:INDEX TO RU TO CONVERT
	LHL	R5,BBUFER+MUDCF,R10,	:GET DATA COUNT TO CONVERT
	SIS	R5,3			:ADJUST FOR RH
	LR	R14,R3			:SAVE POINTER TO NEW MSG BUFFER

:3270 HEADER WAS ALREADY CREATED. NOW COPY ALL GRAPHICS INTO THE CONVERTED
:MSG BUFFERS.
L.CVR2	JAL	R4,L.GTCR		:GET NEXT SOURCE CHARACTER
	JAL	R6,L.PTCH		:PUT INTO NEW BUFFERS
	SIS	R5,1			:DECREASE CHARACTER COUNT
	JGBS	L.CVR2			:CONTINUE UNTIL FINISHED

:EVERYTHING IS DONE. REPLACE DATA COUNT AND BTU POINTER IN MUCB AND
:RELEASE BUFFERLET WITH THE ORIGINAL SSCP-LU MESSAGE.
	STH	R15,BBUFER+MUDCF,R10,	:SAVE NEW DATA COUNT
	BBSTOR	R14,BBUFER+MUCBTU,R10,	:SAVE NEW BTU POINTER
	AIS	R14,9			:RU POINTER
	BBSTOR	R14,BBUFER+MURUPT,R10,	:SAVE NEW RU POINTER
	LR	R3,R12			:COPY POINTER TO OLD BTU
	JAL	R5,R.PBRC,,		:RELEASE BUFFERLETS WITH OLD MSG
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	JR	R5			:AND RETURN

:V.GNMU - GENERATE MUCB TO PREPARE FOR RSP FOR AN OUTSTANDING
:ELEMENT IN THE CORRELATION TABLE.
:INPUT - R8, POINTER TO A CORRELATION TABLE ELEMENT.
:OUTPUTS - R10, CONTAINS POINTER TO MUCB, 0 IF NO MUCB IS GENERATED.
:THE FORMAT OF MUCB IS SUCH THAT IT IS READY FOR L.GNRP TO
:GENERATE +RSP.
:	   R1, CONTAINS RQ CODE OF AN OUTSTANDING ELEMENT OF
:THE CORRELATION TABLE.
:LINK - R5.
V.GNMU	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	XR	R10,R10			:PREPARE FOR NO MUCB
	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET PTR TO BUF WITH CT
	LB	R5,BBUFER+CLARG5+1,R4,	:GET BYTE WITH RH2
	THI	R5,MU.ERI		:EXCEPTION RSP?
	JN	V.GNM3			:JUMP IF SO
:
:FOR DFC OR FMD REQUESTS MUCB IS GENERATED.
:
	JAL	R4,GBB,,		:GET BUFFERLET FOR MUCB
	J	NOBUFF,,		:JUMP IF NONE AVAILABLE(09/09/86/CHS) RX3
	JAL	R4,R.GBB,,		:COUNT IT
	LR	R10,R3			:COPY BUFFERLET POINTER
	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET PTR TO BUF WITH CT
	LB	R5,BBUFER+CLARG6,R4,	:GET BYTE WITH RU CATEGORY
	NHI	R5,MU.CTG		:LEAVE RU CATEGORY ONLY
	JEFS	V.GNM2			:JUMP IF FMD
	OHI	R5,MU.FI		:OTHERWISE SHOW FORMATTED RQ
:
:PREPARE INFORMATION IN THE MUCB THAT WILL BE USED TO GENERATE THE POSITIVE
:RESPONSE.
:
V.GNM2	STB	R5,BBUFER+MURHF1,R10,	:STORE IT IN MUCB
	LB	R5,BBUFER+CLARG5+1,R4,	:GET BYTE CONTAINING RH BYTE 2
	STB	R5,BBUFER+MURHF2,R10,	:STORE IT IN MUCB
	LB	R1,BBUFER+CLARG4,R4,	:GET RQ CODE
	LHL	R5,BBUFER+CLARG3,R4,	:GET END SEQ #
	STH	R5,BBUFER+MUSNF,R10,	:PUT IT IN MUCB
	LHI	R5,FID2^4		:PREPARE 1ST BYTE OF TH
	STB	R5,BBUFER+MUBIUF,R10,	:PUT IT IN MUCB
	LB	R5,LUCTAB+LUCADR,R9,	:GET ADDR OF SECONDARY LU
	LB	R4,LUCTAB+LUPRIL,R9,	:GET ADDR OF PRIMARY LU
	STB	R5,BBUFER+MUOADP,R10,	:PUT SEC IN MUCB
	STB	R4,BBUFER+MUDADP,R10,	:PUT PRI IN MUCB
	ST	R1,LURGSV+4,,		:SAVE R1
V.GNM3	ST	R10,LURGSV+28,,		:SAVE R10
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	JR	R5			:AND RETURN

:::::::::::::::::::::::::::
:: THE FOLLOWING ROUTINE QUEUES NIO->SNA COMMAND AHEAD OF
:: NIO->SNA DATA QUEUE.
:: INPUT: R0 - COMMAND AND SUBCOMMAND (2 BYTES),
::	  R1 - CONTENTS OF LENGTH BYTES (2 BYTES).
:: LINK: R10
::::::::::::::::::::
L.NSST	JAL	R4,GETCL,,		:GET COMMAND LINK
	J	L.CLER			:JUMP IF NONE AVAILABLE
	LHL	R7,LUCTAB+LUSNDG,R9,	:GET CURRENT GET POINTER
	STH	R6,LUCTAB+LUSNDG,R9,	:UPDATE WITH NEW GET POINTER
	STH	R7,CMDBLK+CLPTR,R6,	:QUEUE OLD LINK TO NEW
	STH	R0,CMDBLK+CLCMD,R6,	:FILL IN COMMAND AND SUBCOMMAND
	STH	R1,CMDBLK+CLLNG,R6,	:FILL IN LENGTH BYTES
	LHL	R6,LUCTAB+LUCT.N,R9,	:GET REL# OF LUCB
	SBT	R6,DPNWSN,,		:SHOW DATA PRESENT
	JR	R10			:AND RETURN

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	THIS ROUTINE GENERATES AN SYS/RQ COMMAND INFORMING THE SNA HIF	:
:	THAT AN SYSTEM REQUEST KEY HAS BEEN ENTERED AND SENDS IT AS AN	:
:	END-TO-END MESSAGE TO THE NIO.					:
:									:
:	R5 CONTAINS THE SCREEN STATUS WHEN THIS ROUTINE IS CALLED.	:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	SEG	A.DATA
RSTEMP	WS	1			:TEMP STORAGE AREA FOR LINK REG.
R4TEMP	WS	1			:TEMP STORAGE AREA FOR LINK REG.

	SEG	A.CODE
:
:L.GSRQ	ST	R4,R4TEMP		:SAVE THE LINK REGISTER(4/7/87/CHS)
L.GSRQ	ST	R4,R4TEMP,,		:SAVE THE LINK REGISTER(4/7/87/CHS)
	JAL	R4,GBB,,		:GET A BUFFERLET FOR SYS/RQ
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBR,,		:COUNT THE BUFFERLET
	LHI	R0,SRQAID		:PREPARE SYS/RQ AID
	STB	R0,BBUFER+FID2LN+3,R3,	:PUT IT IN THE BUFFERLET
	LB	R4,LUCTAB+LULUW2,R9,	:GET THE SYS/RQ CMD SEQ#
	LR	R2,R4			:COPY THE BYTE
	AIS	R4,1			:INC. IT
	NHI	R4,LUSTSQ		:MOD 08
	NHI	R2,@LUSTSQ		:SEQ# IS THE LEAST SIG. 3 BITS
	OR	R2,R4
	STB	R2,LUCTAB+LULUW2,R9,	:SAVE THE SEQ#
	AIS	R4,1			:SEQ# IS 1 GREATER THAN SAVED
	LB	R4,BAIOIC,R4		:6/8 BIT CONVERSION
	STB	R4,BBUFER+FID2LN+4,R3,	:PUT IT IN SYS/RQ
	LB	R5,BAIOIC,R5
	STB	R5,BBUFER+FID2LN+5,R3,	:PUT STATUS IN SYS/RQ
	LHI	R2,FID2LN+3		:SYS/RQ COMMAND LENGTH
	LHI	R0,SNETEM^8!NSDTCD	:INDICATE END-TO-END MSG. AND CD.
	JAL	R5,L.PTCD		:SEND IT TO THE NIO
:	L	R4,R4TEMP		:RESTORE THE LINK REGISTER(4/07/87/CHS)
	L	R4,R4TEMP,,		:RESTORE THE LINK REGISTER(4/07/87/CHS)
	JR	R4			:AND RETURN
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	THIS ROUTINE IS CALLED WHEN THE SNA VIRTUAL TIF IS CONFIGURED	:
:	WITH AN SNA HIF.  IT CHECKS WHETHER THE MESSAGE FROM TERMINAL	:
:	IS IN THE SAME SESSION AS IT IS KNOWN BY THE TIF.		:
:	IF THEY DO NOT MATCH, AN SYS/RQ COMMAND IS SENT TO THE HIF, THE	:
:	SCREEN CONTROL STATUS IS UPDATED, AND THE SYS/RQ CYCLE IS	:
:	ENTERED.							:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:L.CSYN	ST	R4,RSTEMP		:SAVE LINK REG.(4/07/87/CHS)
L.CSYN	ST	R4,RSTEMP,,		:SAVE LINK REG.(4/07/87/CHS)
	LB	R5,LUCTAB+LUCSCN,R9,	:GET THE SCRN CNTL BYTE
	LR	R3,R5			:COPY IT
	NHI	R3,@LUSSCN		:CLEAN THE SCRN STATUS
	NHI	R5,LUSSCN		:LEAVE THE SCRN STATUS
	LB	R4,BBUFER+MUOADP,R10,	:IS IT AN SSCP_LU MSG?
	JN	L.CSY1			:NO, CHECK LU_LU
	CLHI	R5,LUSSYS		:TERMINAL AND TIF IN SYNC?
	JE	L.CSY3			:YES, RETURN
	LHI	R5,LUSSYS		:NO, UPDATE SCRN STATUS
	JFS	L.CSY2			:CONTINUE
L.CSY1	CLHI	R5,LUSAPL		:TERMINAL AND TIF IN SYNC?
	JE	L.CSY3			:YES, RETURN
	LHI	R5,LUSSYS		:NO, UPDATE SCRN STATUS
L.CSY2	OR	R3,R5
	STB	R3,LUCTAB+LUCSCN,R9,	:SAVE THE SCRN CNTL BYTE
	LB	R3,LUCTAB+LULUW2,R9,	:ENTER THE SYS/RQ CYCLE
	OHI	R3,LUSYRQ
	STB	R3,LUCTAB+LULUW2,R9,
	JAL	R4,L.GSRQ		:GENERATE THE SYS/RQ CMD AND SEND
					:IT TO THE HIF
:L.CSY3	L	R4,RSTEMP		:RESTORE THE LINK REG(4/07/87/CHS)
L.CSY3	L	R4,RSTEMP,,		:RESTORE THE LINK REG(4/07/87/CHS)
	JR	R4			:RETURN

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	THIS ROUTINE COMAPRES THE CONTENTS OF THE R2 WITH A TABLE THAT  :
:	ADDRESS IS CONTAINED IN THE R5.					:
:	THE FIRST HALFWORD OF THE TABLE IS THE TABLE LENGTH.		:
:	IF R2 MATCHES ANY ENTRY OF THE TABLE, R0 IS RETURNED WITH 0.	:
:	IF NON OF THE TABLE ENTRIES EQUATE TO R2, R0 IS RETURNED WITH	:
:	NON-ZERO.							:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
COMTBL	LHL	R3,0,R5			:GET THE TABLE LENGTH
COMTB1	LHL	R0,0,R3,R5		:GET A TABLE ENTRY
	CR	R2,R0			:IS R2 EQUATE TO THIS ENTRY?
	JE	COMTB2			:YES
	SIS	R3,2			:DECREMENT TABLE LENGTH
	JGBS	COMTB1			:REPEAT IF MORE TO COMPARE
	LIS	R0,1			:RETURN R0 WITH NON-ZERO
	JFS	COMTB3
COMTB2	XR	R0,R0			:RETURN R0 WITH 0
COMTB3	JR	R4

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	THIS ROUTINE CATEGORIZES THE STATUS CODE RECEIVED IN THE	:
:	LUSTAT INTO THREE STATUS AND RETURNS IT IN THE R0.		:
:	STATUS CODE = 0 : RECOVERABLE STATUS.				:
:	STATUS CODE = 1 : SHORT TERM UNAVAILABLE.			:
:	STATUS CODE = 2 : LONG TERM UNAVAILABLE.			:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
SCODE0	EQ	0			:STATUS CODE 0
SCODE1	EQ	1			:STATUS CODE 1
SCODE2	EQ	2			:STATUS CODE 2
:
:L.STCK	ST	R5,RSTEMP		:SAVE RETURN ADDRESS(4/07/87/CHS)
L.STCK	ST	R5,RSTEMP,,		:SAVE RETURN ADDRESS(4/07/87/CHS)
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET POINTER TO RU
	LB	R2,BBUFER+1,R5,		:GET 1ST BYTE OF STATUS CODE
	EXBR	R2,R2			:PUT IT IN 2ND BYTE OF REG
	LB	R5,BBUFER+2,R5,		:GET 2ND BYTE OF STATUS CODE
	OR	R2,R5			:PUT IT IN R2
	LA	R5,RCSTBL		:LOAD ADDR. OF RECOVERABLE STATUS
					:CODE TABLE
	JAL	R4,COMTBL		:COMPARE (R2) WITH STATUS TBL ENTRIES
	LR	R0,R0			:COMPARED?
	JE	L.STC2			:YES, RETURN
	LA	R5,STUTBL		:LOAD ADDR. OF SHORT TERM UNAVAILABLE
					:STATUS CODE TABLE
	JAL	R4,COMTBL		:COMPARE (R2) WITH STATUS TBL ENTRIES
	LR	R0,R0			:COMPARED?
	JEFS	L.STC1			:YES, SET STATUS CODE IN R0
	LIS	R0,SCODE2		:NO, IT IS A LONG TERM UNAVAILABLE
	JFS	L.STC2			:STATUS
L.STC1	LIS	R0,SCODE1
:L.STC2	L	R5,RSTEMP		:RESTORE RETURN ADDRESS(4/07/87/CHS))
L.STC2	L	R5,RSTEMP,,		:RESTORE RETURN ADDRESS(4/07/87/CHS))
	JR	R5			:RETURN
:
:	RECOVERABLE LUSTAT STATUS CODE TABLE
:
RCSTBL	HC	09,082B,00,01,02,03,04,05,06,07
:
:	SHORT TERM UNAVAILABLE LUSTAT STATUS CODE TABLE
:
STUTBL	HC	02,0848,400A


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	THIS ROUTINE QUEUES A COMMAND ONTO THE SNA->NIO DATA_QUEUE	:
:	WITHOUT RELEASING IT TO THE HIGH LEVEL SCHEDULER.		:
:									:
: INPUTS:	R9 - PTR TO LU						:
:		R0 - COMMAND AND SUBCOMMAND				:
:		R2 - DATA LENGTH (OR GARBAGE)				:
:		R3 - DATA BUFFER POINTER (OR GARBAGE)			:
:		R5 - LINK						:
:									:
: OUTPUTS:	R7 - PTR TO FILLED CMD					:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
L.PTCE	LHR	R4,R0			:EXPAND COMMAND SIGN
	JGEFS	L.PTE1			:JUMP IF NOT A COMMAND
	XR	R3,R3			:OTHERWISE CLEAN BUF POINTER
L.PTE1	JAL	R4,GETCL,,		:GET A NEW CMD BUF (R6 HAS THE PTR)
	J	L.CLER			:JUMP IF NON AVAILABLE
	LHL	R7,LUCTAB+LUNWDR,R9,	:GET SNA->NIO RELEASE PTR
	STH	R6,CMDBLK+CLPTR,R7,	:CHAIN NEW LINK TO OLD
	STH	R6,LUCTAB+LUNWDR,R9,	:UPDATE THE RELEASE POINTER
	STH	R0,CMDBLK+CLCMD,R7,	:FILL IN COMMAND AND SUBCD
	STH	R2,CMDBLK+CLLNG,R7,	:FILL IN DATA LENGTH
	BBSTOR	R3,CMDBLK+CLARG,R7,	:FILL IN DATA BUFFER ADDR
	JR	R5			:AND RETURN

	EI

	FO	MAIN
	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER
	FO	SNAPKG

	EM
	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN

:::::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAIN ALL INITIALIZATION, TIMEOUT AND UTILITY ROUTINES
:: TO SUPPORT LU SERVICE MANAGER.
:::::::::::::::::::::::::::::::::::::::::

	SEG	A.CODE

:ALL JUMP TABLES IN THIS MODULE ARE BASED HERE.
L.BASE	EQ	.

:NO BUFFERLETS ARE AVAILABLE ROUTINE.
NOBUFF	JAL	R10,CRASH,,		:CRASH
	HC	0
	BC	4*R5,CR.NBF		:NO BUFFERLETS CRASH CODE

:NO CMD LINKS ROUTINE.
L.CLER	J	CLERR,,			:JUMP TO NO CMD LINKS ROUTINE
::::::::::::::::::::::::::::::::::
:: INITIALIZATION ROUTINE FOR LU SERVICE MANAGER
L.INIT	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LHI	RNODE,MAXPUN-1		:GET MAX NUMBER OF NODES - 1
L.INI1	LHL	R14,PUCPTR,RNODE,RNODE	:GET POINTER TO PUCB
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
	LHL	R9,PUCTAB+PUCLUC,R14,	:GET POINTER TO 1ST LUCB
	LB	R15,PUCTAB+PUMLUN,R14,	:GET # OF LU'S FOR NODE

:SKIP LUCB #0, IT IS FOR PU STREAM, WE DO NOT PROCESS IT.
L.INI2	AHI	R9,LUCLEN		:GET NEXT LUCB
	SIS	R15,1			:DECREASE NUMBER OF LU'S
	JE	L.INI4			:JUMP IF FINISHED WITH NODE

:SHOW THAT NO LU-LU SCB EXISTS AND CLEAN LUSVC STATE AND WORK BYTES.
:	LCS	R5,1			:PREPARE -1
	XR	R5,R5			:CLEAR THE REGISTER
	BBSSCB	R5,LUCTAB+LULSCB,R9,	:INIT LU-LU SCB POINTER
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CLHI	R5,PU.T4		:PU TYPE 4?
	JNFS	L.INI5			:JUMP IF HOST INTERFACE
	LIS	R5,TRPSTA		:INIT TO TRANSPARENT STATE
	JFS	L.INI3			:JUMP TO CONTINUE
L.INI5	LHI	R5,LOCSTA		:INIT TO LOCAL STATE
L.INI3	STB	R5,LUCTAB+LULUST,R9,	:INIT LUSVC STATE BYTE
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:INIT LUSVC WORK BYTE
	STB	R5,LUCTAB+LULUW1,R9,	:INIT LUSVC 2ND WORK BYTE
	J	L.INI2			:CONTINUE FOR ALL LU'S

:CONTINUE FOR ALL NODES.
L.INI4	SIS	RNODE,1			:GET NEXT NODE
	JGE	L.INI1			:CONTINUE UNTIL DONE FOR ALL

:SCHEDULE LU SERVICE MANAGER TIMEOUT PROCESS.
	LA	R0,L.TMOT		:GET ADDR OF TIMEOUT PROCESS
	L	R1,FASTC,,		:GET FAST CLOCK
	AHI	R1,RATE*TM.LUS		:NEXT TIME TO CALL TIMEOUT
	JAL	R5,TOPUT,,		:SCHEDULE TIMEOUT PROCESS

:RESTORE ALL REGISTERS AND RETURN.
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	JR	R5			:AND RETURN

::::::::::::::::::::::::::
:: TIMEOUT PROCESSING ROUTINE FOR LU SERVICE MANAGER.
:: THE MAIN ASSUMPTION FOR THIS ROUTINE IS THAT
:: IF A REQUEST WAS SENT TO THE END USER WHICH
:: REQUIRES A DEFINITE RESPONSE THEN THIS RESPONSE MUST BE
:: RECEIVED BACK WITHIN RESONABLE TIME (LUSVC TIMEOUT) OR
:: OTHERWISE SOMETHING IS WRONG WITH THIS END USER.
:: CURRENTLY THERE IS ONE TIMEOUT VALUE FOR ALL LOGICAL UNITS
:: SERVICED BY THIS INTERFACE.
:
:: L.TMOT IS THE ENTRY POINT OF TIMEOUT PROCESSING.
:: IT IS SCHEDULED BY STANDARD TIMEOUT ROUTINE FOR THE INTERFACE.
:: ALL LOGICAL UNITS FOR THE INTERFACE ARE SCANNED, TIMEOUT
:: PRCESSING ROUTINE FOR GIVEN LOGICAL UNIT IS CALLED AND
:: THEN THE NEXT EXECUTION OF THIS TIMEOUT LOGIC IS SCHEDULED.
:
:: FIRST SCAN ALL LU'S FOR THE INTERFACE.
L.TMOT	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LHI	RNODE,MAXPUN-1		:GET MAX NUMBER OF NODES
L.TMO1	LHL	R14,PUCPTR,RNODE,RNODE	:GET PUC PTR FOR THIS NODE
	LHL	R9,PUCTAB+PUCLUC,R14,	:POINT TO 1ST LUCB
	LB	R15,PUCTAB+PUMLUN,R14,	:GET MAX NUMBER OF LU'S

: LUCB FOR SSCP (HIF) OR PU (TIF) MUST BE SKIPPED (LU #0).
L.TMO2	AHI	R9,LUCLEN		:POINT TO NEXT LUCB
	SIS	R15,1			:NUMBER OF LU'S TO SCAN
	JE	L.TMO4			:JUMP IF ALL LU'S FOR THE NODE

:IF LU IS ACTIVE (SSCP-LU SESSION EXIST) PERFORM TIMEOUT PROCESSING.
	BBLSCB	R5,LUCTAB+LUSSCB,R9,	:GET POINTER TO SSCP-LU SCB
:	THI	R5,LUINV		:IS IT VALID?
:	JNBS	L.TMO2			:JUMP IF NOT
	JEBS	L.TMO2			:JUMP IF NOT VALID
	JAL	R12,L.TMPR		:PERFORM TIMEOUT PROCESSING
	J	L.TMO2			:SCAN NEXT LUCB

:CONTINUE TO SCAN FOR ALL NODES IN THE INTERFACE.
L.TMO4	SIS	RNODE,1			:POINT TO NEXT NODE
	JGE	L.TMO1			:SCAN THIS NODE IF NOT FINISHED

:RESTORE ALL REGISTERS AND SCHEDULE TIMEOUT ROUTINE FOR NEXT TIME.
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	AHI	R1,RATE*TM.LUS		:NEXT TIME TO CALL THIS ROUTINE
	JAL	R5,TOPUT,,		:PUT US ON TIMEOUT LIST
	J	TORET,,			:AND RETURN

::::::::::::::::::::::::::
:: THIS ROUTINE PERFORMS ACTUAL TIMEOUT PROCESSING FOR ONE LU.
:  2 BITS (LULUFN AND LULUSO) IN LUSVC WORK BYTE CONTROL THE LOGIC OF
:  THIS ROUTINE.
:  IF LULUSO IS ON FOR TERMINAL IF IT MEANS THAT RSP FOR SC CATEGORY RQ IS
:  OUTSTANDING (ASSUMPTION IS THAT NO MORE THAN 1 SUCH RSP IS
:  OUTSTANDING).
:  FOR HOST INTERFACE LULUSO BIT ON MEANS THAT CLEANUP TIMER WAS SET AS
:  A RESULT OF A RESET SIGNAL.
:  IF IT IS OFF NO RSP FOR SC RQ IS OUTSTANDING (CLEANUP NOT
:  PENDING FOR HOST INTERFACE) AND WE CHECK IF
:  THERE IS ANYTHING OUTSTANDING IN CORRELATION TABLES (FMD AND DFC
:  RQ'S ARE ALWAYS REFLECTED IN CORRELATION TABLES, WHEREAS SC
:  RQ'S BYPASS CORRELATION TABLE PROCESSING).
:  LULUFN BIT OFF MEANS THAT THIS IS THE FIRST TIME THAT THE EVENT
:  (NO RSP FOR OUR RQ OR CLEANUP) HAPPENED. IT COULD BE THAT WE SENT THIS RQ
:  VERY RECENTLY. WE WILL WAIT FOR THE 2ND OCCURENCE OF THE EVENT
:  TO MAKE SURE THAT WE WAITED ALREADY LONG ENOUGH.
:  THE ACTION TAKEN IN CASE OF THE OCCURENCE OF THE EVENT
:  DEPENDS ON WHETHER LUSVC IS ALREADY IN BAD SUBSTATE (PEND CLEANUP) OR NOT.
:  IF IT WAS NOT BAD SUBSTATE WE NOTIFY NIO AND GO TO BAD SUBSTATE.
:  IF WE ARE ALREADY THERE IT COULD HAPPEN ONLY DURING RESET SEQUENCE.
:  IN THIS CASE WE CLEAR NTW->SNA DATA QUEUE, DESTROY LU-LU SCB,
:  PUT US IN RESET STATE AND NOTIFY PU SERVICE MANAGER THAT
:  RESET PROCESS WAS FINISHED.
L.TMPR	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	SRLS	R5,5			:GET STATE BITS ONLY
	JER	R12			:NO CHECKING IF TRANSP STATE
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULUSO		:SC RSP OUTSTANDING?
	JE	L.TMP7			:JUMP IF NOT

:A RESPONSE IS OUTSTANDING. CHECK IF IT HAPPENS 2ND TIME.
L.TMP0	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULUFN		:IS IT FINAL?
	JNFS	L.TMP2			:JUMP IF SO

:IT IS ONLY 1ST TIME THAT RSP IS OUTSTANDING. TURN ON
:FINAL INDICATOR (IF RESPONSE IS RECEIVED UNTIL NEXT TIMEOUT
:PROCESSING IT WILL BE TURNED OFF).
L.TMP1	OHI	R5,LULUFN		:TURN ON FINAL BIT
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	JR	R12			:RETURN TO TIMEOUT SCHEDULER

:RSP WAS NOT RECEIVED BETWEEN 2 CONSEQUITIVE TIMEOUT CALLS.
:FOR HOST INTERFACE CLEANUP TIMEOUT ELAPSED.
:IF WE ARE NOT IN BAD SUBSTATE GO TO BAD SUBSTATE AND INFORM NIO.
:SAME FOR HOST INTERFACE IF CLEANUP NOT PENDING.
L.TMP2	IF	TERMIF&HOSTIF
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
	LB	R4,NCBBLK+NDPUTY,R13,	:GET NODE TYPE
	CHI	R4,PU.T4		:TERMINAL INTERFACE?
	JNFS	L.TMPH			:JUMP IF SO
	EI
	IF	TERMIF
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	NHI	R5,LUSBST		:GET LUSVC SUBSTATE
	CHI	R5,LUBDST		:IS IT BAD SUBSTATE?
	JE	L.TMP3			:JUMP IF SO
	EI
	IF	TERMIF&HOSTIF
	JFS	L.TMPI			:JUMP TO CONTINUE
	EI
	IF	HOSTIF
L.TMPH
:	THI	R5,LULUSO		:IS CLEANUP PENDING?
:	JN	L.TMP3			:JUMP IF SO
	JNR	R12			:EXIT IF SO
	EI
L.TMPI	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:CLEAR LUSVC WORK BYTE
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUBDST		:SET BAD SUBSTATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	LHI	R0,SNERR^8!SNERTO	:PREPARE TERM STATUS ERROR
	JAL	R5,L.PTCD		:PASS CMD TO NIO
	JR	R12			:RETURN TO TIMEOUT SCHEDULER

:WE ARE ALREADY IN BAD STATE (CLEANUP FOR HOST INTERFACE)
:AND WE STAYED IN THIS STATE FOR AT
:LEAST ONE FULL TIMEOUT PERIOD. WE ASSUME THAT BY THIS TIME NIO
:PROCESSED ERROR CMD (IT WAS SENT BY LUSVC WHEN BAD SUBSTATE WAS SET).
:THEN NIO SENT VIA NTW->SNA COMMAND QUEUE RESET COMMAND. THEN LUSVC
:ISSUED UNBIND AND PROBABLY DISCARDED UNBIND REPONSE (RSHUTD AND
:RSHUTD RESPONSE FOR HOST INTERFACE). NOW IS THE TIME
:TO CLEAR NTW->SNA DATA QUEUE, DESTROY LU-LU SCB, UPDATE LUSVC STATE
:TO RESET AND INFORM COMMON SESSION CONTROL THAT CLEAR PROCESS WAS
:COMPLETED.
:
:THIS IS ALSO AND ENTRY POINT FOR IMMEDIATE CLEANING SUBROUTINE WITH
:LINK REGISTER R12.
:
:FIRST CLEAN NTW->SNA DATA QUEUE (SEND DIRECTION).
L.CLEA	EQ	.
L.TMP3	LHL	R8,LUCTAB+LUSNDG,R9,	:GET NTW->SNA DATA Q GET PTR
:L.TMP4	CH	R8,LUCTAB+LUSNDR,R9,	:COMPARE WITH RELEASE POINTER
L.TMP4	LHL	R5,LUCTAB+LUSNDR,R9,	:GET RELEASE POINER
	CR	R8,R5			:COMPARE POINTERS
	JE	L.TMP6			:JUMP IF QUEUE IS EMPTY
	LH	R5,CMDBLK+CLCMD,R8,	:GET COMMAND
	JL	L.TMP5			:JUMP IF NO DATA BUFFER
	BBLOAD	R3,CMDBLK+CLARG,R8,	:GET POINTER TO DATA BUFFERS
	JAL	R5,R.PBBC,,		:RELEASE BUF CHAIN WITH DATA
L.TMP5	LR	R6,R8			:COPY POINTER TO CMD LINK
	LHL	R8,CMDBLK+CLPTR,R6,	:GET POINTER TO NEXT LINK
	JAL	R4,RELCL,,		:RELEASE THE LINK
	J	L.TMP4			:TRY NEXT CMD LINK
L.TMP6	STH	R8,LUCTAB+LUSNDG,R9,	:UPDATE NTW->SNA DATA Q GET PTR
	LHL	R5,LUCTAB+LUCT.N,R9,	:GET REL LU #
	RBT	R5,DPNWSN,,		:RESET DATA PRESENT

:RESET STATE FOR TERMINAL INTERFACE IS TRANSPARENT STATE.
:RESET STATE FOR HOST INTERFACE IS LOCAL STATE.
:SHOW IT IN LUSVC STATE BYTE. ALSO CLEAR LUSVC WORK BYTE.
	IF	TERMIF&HOSTIF
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JNFS	L.TMPK			:JUMP IF NOT
	EI
	IF	TERMIF
	LHI	R5,TRPSTA		:PREPARE TRANSPARENT STATE
	EI
	IF	TERMIF&HOSTIF
	J	L.TMPL			:JUMP TO CONTINUE
	EI
	IF	HOSTIF
L.TMPK	EQ	.
	IF	HDPSUP
	LHL	R5,LUCTAB+LUCDCB,R9,	:GET DCB POINTER
	JEFS	L.TMPX			:JUMP IF NO DCB
	XR	R4,R4			:CLEAR THE REGISTER
	STH	R4,DCBLKS+DCBRUL,R5,	:CLEAR MUX RU LENGTH
	STH	R4,DCBLKS+DCBRUS,R5,	:CLEAR CURRENT RU LENGTH
	EI
L.TMPX	LHI	R5,LOCSTA		:PREPARE LOCAL STATE
	EI
L.TMPL	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE

:IF LU-LU SCB EXISTS DESTROY IT.
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET POINTER TO LU-LU SCB
:	THI	R7,LUINV		:IS IT VALID?
:	JN	L.TMPE			:JUMP IF NOT
	JE	L.TMPE			:JUMP IF NOT VALID
:	LCS	R5,1			:PREPARE -1
	XR	R5,R5			:CLEAR THE REGISTER
	BBSSCB	R5,LUCTAB+LULSCB,R9,	:UPDATE LU-LU SCB POINTER
	STM	R0,LURGS1,,		:SAVE ALL REGISTERS
	LR	R9,R7			:POINT TO SCB TO RELEASE
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
	JAL	R8,V.SCDS,,		:RELEASE SCB
	LM	R0,LURGS1,,		:RESTORE ALL REGISTERS

:SEND DQE WITH RESET COMPLETED SIGNAL TO COMMON SESSION CONTROL.
L.TMPE
					:(3.f00/06/18/87/db/start)
	LB	R2,LUCTAB+LULUW2,R9,	:GET PROC ORIG SIGNAL
	JER	R12			:RETURN IF NOWHERE TO SEND
					:(3.f00/06/18/87/db/end)
	JAL	R4,GBB,,		:GET BUFFER FOR DQE
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	LB	R0,LUCTAB+LULUW1,R9,	:GET LUSVC 2ND WORK BYTE
	NHI	R0,LULUSL		:GET SIGNAL-1
	AIS	R0,1			:GET SIGNAL
	XR	R5,R5			:CLEAR THE RIGISTER
	STB	R5,LUCTAB+LULUW1,R9,	:CLEAR LUSVC 2ND WORK BYTE
:	LB	R2,LUCTAB+LULUW2,R9,	:GET PROC ORIG SIGNAL(3.f00/06/18/87/db)
:	JER	R12			:RETURN IF NOWHERE TO SEND(3.f00/06
					:/18/87/db)
	LHI	R1,LURCV		:FAKE LURCV AS ORIGINATOR
:	BBLSCB	R7,BBUFER+LUSSCB,R9,	:GET SSCP-LU SCB POINTER(8/22/84/CHS)
	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET SSCP-LU SCB POINTER(8/22/84/CHS)
	ST	R7,BBUFER+DQSCB,R3,	:PUT IT IN DQE
	STH	R9,BBUFER+DQLUCB,R3,	:PUT LUCB POINTER IN DQE
	LCS	R8,1			:'NULL' OTHER FIELDS (8/22/84/CHS)
	BBSTOR	R8,BBUFER+DQMUPR,R3,	:MUCB PTR FIELD (8/22/84/CHS)
	STH	R8,BBUFER+DQMULN,R3,	:MUCB LENGTH FIELD (8/22/84/CHS)
	JAL	R8,SEND,,		:SEND DQE
	JR	R12			:RETURN TO TIMEOUT SCHEDULER

:NO SC RSP OUTSTANDING. CHECK CORRELATION TABLES. THE RESPONSE NUMBER
:OUTSTANDING MUST CHANGE BETWEEN 2 TIMEOUT CALLS, OTHERWISE SOMETHING
:IS WRONG.
L.TMP7	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET POINTER TO LU-LU SCB
:	THI	R7,LUINV		:IS IT VALID?
:	JNFS	L.TMP8			:JUMP IF NO LU-LU SESSION
	JEFS	L.TMP8			:JUMP IF NO LU-LU SESSION
	JAL	R5,L.CTCK		:CHECK LU-LU CORRELATION TABLES
	LR	R0,R0			:ANY MOVEMENT THERE?
	JN	L.TMP0			:SOMETHING WRONG, JUMP
L.TMP8	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:POINT TO SSCP-LU SCB
:	THI	R7,LUINV		:IS POINTER VALID
:	JNR	R12			:RETURN TO SCHED IF NOT
	JER	R12			:RETURN TO SCHED IF NOT VALID
	JAL	R5,L.CTCK		:CHECK SSCP-LU CORRELATION TB
	LR	R0,R0			:ANY MOVEMENT THERE?
	JN	L.TMP0			:SOMETHING WRONG, JUMP

:ALL OK WITH CORRELATION TABLES. RESET FINAL BIT IN LUSVC WORK BYTE.
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUFN		:RESET FINAL BIT
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	JR	R12			:RETURN TO TIMEOUT SCHEDULER

::::::::::::::::::::::::::
:: UTILITY ROUTINES FOR LU SERVICE MANAGER
::::::::::::::::::::::::::

:---------------------
:MAP TO CANONICAL
:THIS ROUTINE TAKES A DATA MESSAGE FROM NTW -> SNA DATA QUEUE AND
:MAPS IT TO CANONICAL FORMAT. IT IS SIMILAR IN FUNCTIONS TO R.MTCN
:EXCEPT IT WORKS FOR DIFFERENT DIRECTION OF TRANSMISSION.
:MAPPING PROCESS DEPENDS ON LU_SVC STATE.
:IN TRANSPARENT STATE THE INFORMATION IS MOSTLY TAKEN FROM THE
:DATA MESSAGE ITSELF (EXCEPT FOR LENGTH AND DESTINATION AND
:ORIGINATION ADRESSES).
:IN LOCAL STATE TH AND RH ARE NOT FILLED BY NETIO LOGON MODULE.
:THIS ROUTINE GOES TO COMMAND FROM NIO OR VARIOUS CONTROL BLOCKS
:TO OBTAIN TH AND RH INFORMATION AND PUT IT IN MUCB (NOT TH AND RH).
:
:THIS ROUTINE DOES NOT DESTROY ANY REGISTERS EXCEPT R10
:
:OUTPUT R10 - POINTER TO MUCB

L.MTCN	STM	R0,LURGSV,,	:SAVE ALL REGISTERS
	LR	R9,R4		:SAVE POINTER TO LUCB
	LR	R10,R3		:SAVE LU_SVC STATUS
	JAL	R4,GBB,,	:GET BUFFERLET FOR MUCB
	J	NOBUFF		:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,	:COUNT THE BUFFERLET

:FILL MUDIRE, MUOADP AND MUDADP
	LIS	R4,SENT		:GET SEND INDICATOR FOR DIRECTION
	STB	R4,BBUFER+MUDIRE,R3,	:PUT IT IN MUCB
	XR	R4,R4			:CLEAR THE REGISTER
	STB	R4,BBUFER+MUSCHK,R3,	:CLEAR SENSE-CHECK
	IF	TERMIF&HOSTIF
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JNFS	L.MTCH			:JUMP IF NOT
	EI
	IF	TERMIF
	LB	R4,LUCTAB+LUPRIL,R9,	:GET PRIMARY LOCAL ADDRESS
	STB	R4,BBUFER+MUOADP,R3,	:PUT IT IN MUCB ORIGINATION
	LB	R4,LUCTAB+LUCADR,R9,	:GET SECONDARY LOCAL ADRESS
	STB	R4,BBUFER+MUDADP,R3,	:PUT IT IN MUCB DESTINATION
	EI
	IF	TERMIF&HOSTIF
	JFS	L.MTCI			::JUMP TO CONTINUE
	EI
	IF	HOSTIF
L.MTCH	LB	R4,LUCTAB+LUPRIL,R9,	:GET PRIMARY LOCAL ADDRESS
	STB	R4,BBUFER+MUDADP,R3,	:PUT IT IN MUCB DESINATION
	LB	R4,LUCTAB+LUCADR,R9,	:GET SECONDARY LOCAL ADDRESS
	STB	R4,BBUFER+MUOADP,R3,	:PUT IT IN MUCB ORIGINATION
	EI
:NOW GET POINTER TO THE MESSAGE
L.MTCI	BBLOAD	R2,CMDBLK+CLARG,R8,	:POINTER TO PIU FROM NIO
	BBSTOR	R2,BBUFER+MUCBTU,R3,	:STORE IT IN MUCB
:PROCESSING IS DIFFERNT FROM THIS POINT FOR TRANSPARENT AND LOCAL.
	IF	TERMIF
	IF	HOSTIF
	IF	1-HDPSUP
	CHI	R5,PU.T4	:TERMINAL INTERFACE
	JNFS	L.MTCA		:JUMP IF NOT
	EI
	EI
	LR	R10,R10		:IS IT LOCAL MODE?
	JN	L.MTCL		:JUMP IF SO
	ELSE			:IF TERM IF NOT SYSGENED
	IF	HOSTIF&HDPSUP
	LR	R10,R10		:IS IT DSP MODE
	JN	L.MTCL		:JUMP IF SO
	EI
	EI

:FOR TRANSPARENT MODE THE REST OF INFORMATION IS TAKEN FROM
:END-TO-END MESSAGE
L.MTCA	LB	R4,BBUFER+THDISP,R2,	:GET 1ST BYTE OF TH
	STB	R4,BBUFER+MUBIUF,R3,	:SAVE IT IN MUCB
	AHI	R4,10		:FID NUMBERS ARE 0-5 NOW
	NHI	R4,0F0		:IF WE LEAVE ONLY THIS HALF-BYTE
	SRLS	R4,3			:MAKE HALF WORD POINTER TO FID TBL
	LHL	R4,L.MTCT,R4	:GET POINTER TO PROCESSING ROUTINE
	J	L.BASE,R4	:AND JUMP THERE

:------------------

:VECTOR TABLE FOR PROCESSING ROUTINES DEPENDING ON FID
L.MTCT	HC	L.MTCF-L.BASE		:ROUTINE FOR FIDF
	HC	L.MTC0-L.BASE		:ROUTINE FOR FID0
	HC	L.MTC1-L.BASE		:ROUTINE FOR FID1
	HC	L.MTC2-L.BASE		:ROUTINE FOR FID2
	HC	L.MTC3-L.BASE		:ROUTINE FOR FID3
	HC	L.MTC4-L.BASE		:ROUTINE FOR FID4

:------------------

:FID DEPENDENT PROCESSING ROUTINES

L.MTCF					:FIDF NOT IMPLEMENTED
L.MTC0					:FID0 NOT IMPLEMENTED
L.MTC1					:FID1 NOT IMPLEMENTED
L.MTC3					:FID3 NOT IMPLEMENTED
L.MTC4	JAL	R10,CRASH,,		:FID4 NOT IMPLEMENTED
	HC	0
	BC	4*R4,CR.FID		:CRASH

:FID2 PROCESSING ROUTINE

:FIRST CHECK IN THE TH OF END-TO-END MESSAGE IF IT WAS SSCP OR PU

L.MTC2	LHL	R4,BBUFER+THDISP+2,R2,	:GET DAF AND OAF
	LBR	R10,R4			:SEPARATE 2ND BYTE
	JNFS	L.MT21			:NO CORRECTION TO OAF IF NOT 0
	IF	TERMIF&HOSTIF
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JNFS	L.MT20			:CRASH IF NOT
	EI
	IF	HOSTIF&(1-TERMIF)
	JFS	L.MT20			:GO CRASH
	EI
	IF	TERMIF
	STB	R10,BBUFER+MUOADP,R3,	:CORRECT MUCB
	EI
L.MT21	XR	R4,R10			:GET DAF
	JNFS	L.MT22			:NO CORRECTION NEEDED IF NOT 0
	IF	TERMIF&HOSTIF
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JEFS	L.MT20			:CRASH IF SO
	EI
	IF	HOSTIF
	STB	R4,BBUFER+MUDADP,R3,	:CORRECT MUCB
	JFS	L.MT22			:JUMP TO CONTINUE
	EI
L.MT20	JAL	R10,CRASH,,		:SERIOUS DESIGN PROBLEM
	HC	0
	BC	4*R4,CR.WNA		:IT MUST NOT HAPPEN

:FILL IN MUCB LENGTH AND REMAINING TH FIELDS

L.MT22	LHL	R4,CMDBLK+CLLNG,R8,	:GET DATA MESSAGE LENGTH
	SIS	R4,6			:ADJUST IT FOR TH LENGTH
	STH	R4,BBUFER+MUDCF,R3,	:FILL DATA COUNT FIELD
	LHL	R4,BBUFER+THDISP+4,R2,	:GET SEQUENCE NUMBER
	STH	R4,BBUFER+MUSNF,R3,	:PUT IT IN MUCB
	AIS	R2,6			:ADJUST FOR TH LENGTH

:FILL MUCB WITH RH INFORMATION

L.MTCR	LB	R4,BBUFER+MUBIUF,R3,	:GET SEGMENTATION INFORMATION
	THI	R4,MU.BIU		:IS IT 1ST SEGMENT
	JE	L.MTCK			:NO RH, JUMP IF NOT 1ST SEG
	AIS	R2,3			:ADJUST FOR RH LENGTH
	LB	R4,BBUFER-3+THDISP,R2,	:GET 1ST RH BYTE (04/23/84 NCS)
	STB	R4,BBUFER+MURHF1,R3,	:PUT IT IN MUCB
	LB	R4,BBUFER-2+THDISP,R2,	:GET 2ND RH BYTE (04/23/84 NCS)
	STB	R4,BBUFER+MURHF2,R3,	:PUT IT IN MUCB
	LB	R4,BBUFER-1+THDISP,R2,	:GET 3RD RH BYTE (04/23/84 NCS)
	STB	R4,BBUFER+MURHF3,R3,	:PUT IT IN MUCB

:PUT SENSE DATA IN MUCB
	LB	R4,BBUFER-3+THDISP,R2,	:GET 1ST BYTE OF RH
	NHI	R4,MU.SDI		:SENSE DATA PRESENT?
	JE	L.MTCE			:JUMP IF NO SENSE DATA
	LB	R4,BBUFER+THDISP,R2,	:GET 1ST BYTE OF SENSE DATA
	STB	R4,BBUFER+MURHSN,R3,	::PUT IT IN MUCB
	LB	R4,BBUFER+1+THDISP,R2,	:GET 2ND BYTE OF SENSE DATA
	STB	R4,BBUFER+1+MURHSN,R3,	:PUT IT IN MUCB
	LB	R4,BBUFER+2+THDISP,R2,	:GET 3RD BYTE OF SENSE DATA
	STB	R4,BBUFER+2+MURHSN,R3,	:PUT IT IN MUCB
	LB	R4,BBUFER+3+THDISP,R2,	:GET 4TH BYTE OF SENSE DATA
	STB	R4,BBUFER+3+MURHSN,R3,	:PUT IT IN MUCB
	AIS	R2,4			:ADJUST FOR SENSE DATA LENGTH

:MAPPING FINISHED. PUT RU POINTER IN MUCB AND RETURN
L.MTCE	BBSTOR	R2,BBUFER+MURUPT,R3,	:PUT RU POINTER IN MUCB
	ST	R3,LURGSV+28,,		:PUT MUCB POINTER IN R10 AREA
	LM	R0,LURGSV,,		:RESTORE ALL REGISTRES
	JR	R5			:AND RETURN

:FOR THE SEGMANTS DIFFERNRT THAN LAST CLEAR RH INFORMATION.
L.MTCK	XR	R4,R4			:CLEAR THE REGISTER
	STB	R4,BBUFER+MURHF1,R3,	:CLEAR RH1
	STB	R4,BBUFER+MURHF2,R3,	:CLEAR RH2
	STB	R4,BBUFER+MURHF3,R3,	:CLEAR RH3
	J	L.MTCE			:JUMP TO CONTINUE

	IF	TERMIF!(HOSTIF&HDPSUP)
:MAP TO CANONICAL IN LOCAL MODE
:SOME OF MUCB FIELDS WERE ALREADY FILLED
:THE REST OF TH AND ALL RH INFORMATION IS TAKEN FROM NTW->SNA COMMAND
:AFTER MATCHING IT WITH BIND OPTIONS AND DFC STATES
L.MTCL	EQ	.
	IF	TERMIF&HOSTIF&HDPSUP
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JNFS	L.MTLA			:JUMP IF NOT
	EI
	IF	TERMIF
	LB	R5,LUCTAB+LUPRIL,R9,	:GET LOCAL PRIMARY ADDR
	STB	R5,BBUFER+MUOADP,R3,	:PUT IT IN MUCB ORIGINATION
	LB	R5,LUCTAB+LUCADR,R9,	:GET LOCAL SECONDARY ADDR
	STB	R5,BBUFER+MUDADP,R3,	:PUT IT IN MUCB DESTINATION
	EI
	IF	TERMIF&HOSTIF&HDPSUP
	JFS	L.MTLB			:JUMP TO CONTINUE
	EI
	IF	HOSTIF&HDPSUP
L.MTLA	LB	R5,LUCTAB+LUCADR,R9,	:GET LOCAL SECONDARY ADDR
	STB	R5,BBUFER+MUOADP,R3,	:PUT IT IN MUCB ORIGINATION
	LB	R5,LUCTAB+LUPRIL,R9,	:GET LOCAL PRIMARY ADDR
	STB	R5,BBUFER+MUDADP,R3,	:PUT IT IN MUCB DESTINATION
	EI
L.MTLB	BBLSCB	R10,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
:	THI	R10,LUINV		:ODD POINTER?
:	JEFS	L.MTL1			:JUMP IF EVEN
	JNFS	L.MTL1			:JUMP IF INVALID
	JAL	R10,CRASH,,		:LU-LU SCB NOT SET
	HC	0
	BC	4*R9,CR.LUL		:LOGICAL UNIT LOGIC PROBLEM

:FILL IN TH INFORAMTION
L.MTL1	LR	R4,R1			:COPY SIBCOMMAND BYTE
	NHI	R4,3			:LEAVE SEGMENTATION INFO ONLY
	SLLS	R4,2			:PUT IT IN BITS 4 AND 5
	XHI	R4,FID2^4!MU.BIU!MU.EIU	:SHOW FID2 AND INVERT SEG CODE
	STB	R4,BBUFER+MUBIUF,R3,	:PUT 1ST BYTE OF TH IN MUCB
	LHL	R4,CMDBLK+CLLNG,R8,	:GET DATA MSG LENGTH
	SIS	R4,FID2LG		:ADJUST FOR FID2 TH LENGTH
	STH	R4,BBUFER+MUDCF,R3,	:PUT IT INTO DATA COUNT FIELD
	AIS	R2,FID2LG		:ADVANCE BUFFER POINTER FOR TH

:FILL IN RH INFORMATION
	THI	R1,NSDTLS		:IS IT 1ST SEGMENT?
	JN	L.MTCE			:EVERYTHING FINISHED IF NOT
	AIS	R2,3			:ADJUST FOR RH LENGTH
	IF	TERMIF&HOSTIF&HDPSUP
	LB	R6,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R6,PU.T4		:TERMINAL INTERFACE?
	JNFS	L.MTLC			:JUMP IF NOT
	EI
	IF	TERMIF
	LB	R6,SCBBLK+SCPLUP,R10,	:GET FM USAGE INFORMATION
	EI
	IF	TERMIF&HOSTIF&HDPSUP
	JFS	L.MTLD			:JUMP TO CONTINUE
	EI
	IF	HOSTIF&HDPSUP
L.MTLC	LB	R6,SCBBLK+SCSLUP,R10,	:GET FM USAGE INFORMATION
	EI
L.MTLD	LR	R4,R1			:COPY SUBCOMMAND BYTE
:	SLLS	R4,2			:CHAINING INFO IN LST BITS(8/15/84/CHS)
	SRLS	R4,2			:CHAINING INFO IN LST BITS(8/15/84/CHS)
	NHI	R4,3			:CLEAN EVERYTHING ELSE
	JEFS	L.MTL2			:JUMP IF SINGLE-ELEMENT CHAIN
	THI	R6,LUCHNI		:OTHERWISE CHECK FM USAGE
	JNFS	L.MTL2			:MULTI-ELEM CHAINS OK, JUMP
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R4,CR.LCH		:BAD CHAINING INFO FROM NIO
:FIRST RH BYTE GENERATED IS (RQ, FMD, -FMH, -SD). BCI AND ECI ARE
:TAKEN FROM NTW->SNA COMMAND.
L.MTL2	XHI	R4,3			:INVERT CHAINING CODING
	STB	R4,BBUFER+MURHF1,R3,	:PUT 1ST RH BYTE IN MUCB
	
:SECOND RH BYTE CONTAINS TYPE OF RESPONSE INFORMATION.
:NO RESPONSE CHAINS ARE NOT ALLOWED FOR LU_T2.
:DEFINITE RESPONSE OR EXCEPTION RESPONSE ARE THE BIND OPTIONS.
:IF DEFINITE REPONSE IS ALLOWED IT IS GENERATED IN RH HEADER.
	LHI	R4,MU.ERI!MU.DR1	:PREPARE TO REQUEST EXCEP RSP
	THI	R6,LUDRI		:IS DEF RSP ALLOWED IN BIND?
	JE	L.MTL3			:JUMP IF NOT
	THI	R1,NSDTFC		:IS IT THE LAST ELEM OF CHAIN?
	JN	L.MTL3			:JUMP IF NOT
:	(08/05/86/CHS)	NSR815
	LB	R7,LUCTAB+LUCSYS,R9,	:R7 = SYS TYPE, R9 = LUC
	CLHI	R7,HITACHI		:HITACHI ?
	JN	L.MTLX			:NO, SET TO DEFINITE
	LB	R7,BBUFER,R2,		:R7 = AID BYTE
	CLHI	R7,AIDCLR		:CLEARN KEY ?
	JE	L.MTL3			:YES, SET TO EXCEPTION
	CLHI	R7,AIDPA1		:PA1 KEY ?
	JE	L.MTL3			:YES, SET TO EXCEPTION
	CLHI	R7,AIDPA2		:PA2 KEY ?
	JE	L.MTL3			:YES, SET TO EXCEPTION
	CLHI	R7,AIDPA3		:PA3 KEY ?
	JE	L.MTL3			:YES, SET TO EXCEPTION
L.MTLX
:	(08/05/86/CHS) END OF NSR815
	LHI	R4,MU.DR1		:REQUEST DEF RSP FOR LAST ELEM
:THE 2ND RH BYTE WILL CONTAIN ALSO (-QRI, -PI)
L.MTL3	STB	R4,BBUFER+MURHF2,R3,	:PUT 2ND RH BYTE IN MUCB

	IF	TERMIF&HOSTIF&HDPSUP
	LB	R7,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R7,PU.T4		:TERMINAL INTERFACE?
	JN	L.MTLF			:JUMP IF NOT
	EI

	IF	TERMIF
:THIRD RH BYTE CONTAINS BRACKETING AND CHANGE DIRECTION INFORMATION
:BEGIN BRACKET IS GENERATED IF FSM_BSM_BIDDER IS IN BETB OR PEND_BB
:STATES.
:BRACKET IS NOT TERMINATED UNTIL NTW->SNA COMMAND SPECIFIES CHANGE
:DIRECTION. WHEN IT IS SPECIFIED AND BRACKET IS ALLOWED TO TERMINATE
:IT IS TERMINATED. OTHERWISE CHANGE DIRECTION IS SPECIFIED IN RH
:INSTEAD OF END OF BRACKET.
	LB	R5,BBUFER+MURHF1,R3,	:GET RH BYTE 1
	THI	R5,MU.BCI		:BEGIN CHAIN?
	JEFS	L.MTLY			:JUMP IF NOT
	LB	R7,SCBBLK+SCSTAT+FSCBBI,R10,	:GET FSM_BSM_BIDDER ST
	LHI	R4,MU.BBI		:PREPARE TO BEGIN BRACKET
	CHI	R7,FS.ST1		:IS FSM_BSM_BIDDER IN BETB?
	JEFS	L.MTL4			:JUMP TO BEGIN BRKT IF SO
	CHI	R7,FS.ST3		:IS IT IN PEND_BB
	JEFS	L.MTL4			:BEGIN BRACKET IF SO
L.MTLY	XR	R4,R4			:OTHERWISE SPECIFY -BB
L.MTL4	LB	R6,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R1,NSDTCD		:IS CHANGE DIR IN NTW->SNA CMD
	JE	L.MTL5			:JUMP IF NOT

:CHANGE DIRECTION SPECIFIED IN NTW->SNA COMMAND. GENERATE EB OR CD.
:THE DIFFERENCE IS THAT EBI IS GENERATED IN THE FIRST ELEMENT OF
:THE CHAIN WHEREAS CDI IS IN THE LAST CHAIN ELEMENT. CHANGE DIRECTION
:IN NTW->SNA COMMAND MUST BE SPECIFIED IN THE FIRST CHAIN ELEMENT.
	THI	R5,MU.BCI		:BEGIN CHAIN?
	JEFS	L.MTLZ			:JUMP IF NOT
	THI	R1,NSDTEB		:IS EB ALLOWED BY CMD?
	JE	L.MTL6			:JUMP IF SO
:	LB	R5,BBUFER+MURHF1,R3,	:GET 1ST RH BYTE
L.MTLZ	THI	R5,MU.ECI		:LAST CHIAN ELEMENT?
	JNFS	L.MTL8			:JUMP IF SO
	OHI	R6,LULUCD		:CHANGE DIRECTION PENDING
	JFS	L.MTL7			:JUMP TO CONTINUE		
L.MTL8	OHI	R4,MU.CDI		:OTHERWISE GENERATE CD
	NHI	R6,@LULUCD		:CLEAR PENDING CHANGE DIRECT
	JFS	L.MTL7			:AND CONTINUE
L.MTL6	OHI	R4,MU.EBI		:GENERATE EB

:THE REST OF 3RD BYTE RH DATA IS (-CS, -ED, -PD).
L.MTL7	STB	R4,BBUFER+MURHF3,R3,	:PUT 3RD BYTE OF RH IN MUCB
	STB	R6,LUCTAB+LULUWK,R9,	:STORE UPDATED LUSVC WORK BYT
	J	L.MTCE			:JUMP TO RESTORE REGS AND RET
:CHECK IF CHANGE DIRECTION IS PENDING AND GENERATE IT IF SO
L.MTL5	THI	R6,LULUCD		:IS CHANGE DIRECTION PENDING?
	JEBS	L.MTL7			:JUMP TO CONTINUE IF NOT
	LB	R5,BBUFER+MURHF1,R3,	:GET 1ST BYTE OF RH
	THI	R5,MU.ECI		:LAST CHAIN ELEMENT?
	JE	L.MTL7			:CONTINUE IF NOT
	J	L.MTL8			:GENERATE CD AND CONTINUE
	EI

	IF	HOSTIF&HDPSUP

:IN CASE OF DSP SUPPORT HOST INTERFACE LOGIC WILL GENERATE BB IF
:BSM_FIRST_SPEAKER IS IN BETB STATE AND THIS IS THE FIRST CHAIN ELEMENT.
:CD WILL BE ALWAYS SPECIFIED FOR THE LAST CHAIN ELEMENT.
L.MTLF	XR	R4,R4			:START WITH 0 FOR 3RD BYTE OF RH
	THI	R1,NSDTLC		:FIRST CHAIN ELEMENT?
	JNFS	L.MTLG			:JUMP IF NOT
	LB	R7,SCBBLK+SCCLUP,R10,	:GET BYTE 6 OF BIND
	NHI	R7,20			:GET BIT 2
	JEFS	L.MTLG			:JUMP IF BRACKETS NOT USED
	LB	R7,SCBBLK+SCSTAT+FSCBFP,R10,	:GET FSM_BSM_FSP ST
	CHI	R7,FS.ST1		:BETB STATE?
	JNFS	L.MTLG			:JUMP IF NOT
	OHI	R4,MU.BBI		:BEGIN BRACKET
L.MTLG	THI	R1,NSDTFC		:LAST CHAIN ELEMENT?
	JNFS	L.MTLH			:JUMP IF NOT
	OHI	R4,MU.CDI		:CHANGE DIRECTION
L.MTLH	STB	R4,BBUFER+MURHF3,R3,	:PUT 3RD BYTE OF RH IN MUCB
	J	L.MTCE			:JUMP TO CONTINUE

	EI

	EI

::::::::::
:: PUT A COMMAND IN SNA->NTW QUEUE
:: INPUTS:	R9 - PTR TO LU
::		R0 - COMMAND AND SUBCOMMAND
::		R2 - DATA LENGTH (OR GARBAGE)
::		R3 - DATA BUFFER POINTER (OR GARBAGE)
::		R5 - LINK
::
:: OUTPUTS:	R7 - PTR TO FILLED CMD
::
:: DESTROYS:	R4, R6
::
L.PTCD	LHR	R4,R0			:EXPAND COMMAND SIGN
	JGEFS	L.PTC1			:JUMP IF NOT COMMAND
	XR	R3,R3			:OTHERWISE CLEAN BUF POINTER
L.PTC1	JAL	R4,GETCL,,		:GET A NEW LINK
	J	L.CLER			:JUMP IF EMPTY
	LHL	R7,LUCTAB+LUNWDR,R9,	:GET SNA->NTW RELEASE PTR
	STH	R6,CMDBLK+CLPTR,R7,	:CHAIN NEW LINK TO OLD
	STH	R6,LUCTAB+LUNWDR,R9,	:UPDATE RELEASE POINTER
	STH	R6,LUCTAB+LUNWDP,R9,	:UPDATE PUT POINTER
	LHL	R6,LUCTAB+LUCT.N,R9,	:GET LUCTAB REL ID #
	SBT	R6,DPSNNW,,		:SET CMD PRESENT BIT
	STH	R0,CMDBLK+CLCMD,R7,	:FILL IN COMMAND AND SUBCD
	STH	R2,CMDBLK+CLLNG,R7,	:FILL IN DATA LENGTH
	BBSTOR	R3,CMDBLK+CLARG,R7,	:FILL IN DATA BUFFER ADDR
	JR	R5			:AND RETURN

:::::::::::::::::::
:: ROUTINE TO CHECK SENSE CODE IN MUCB IF L.SEND RECEIVED
::  A NEGATIVE NOTIFICATION FROM LOWER SNA LAYERS.
::  THIS ROUTINE MUST DETERMINE BY EXAMINING THE SENSE CODE
::  WHETHER THIS IS A TRANSIENT RACE CONDITION IN SNA FSMS
::  (IN WHICH CASE RETRANSMISSION COULD RESOLVE THE PROBLEM)
::  OR A PERMANENT PROBLEM. RETURN CODE (IN R0) IS 0 IN THE
::  FIRST CASE AND NON-ZERO IN THE SECOND.
::
:: INPUTS: R10 - POINTER TO MUCB.
:: OUTPUTS: R0 - RETURN CODE.
:: CAN DESTROY: R4, R6, R7.
:: LINK: R5
::::
::
L.RMCK	LA	R6,L.CSTB		:GET ADDR OF SENSE CHECK TABLE
	LHL	R0,BBUFER+MUSCKS,R10,	:GET SEND SENSE-CHECK CODE
	J	L.SNCK			:JUMP TO CONTINUE

:SENSE CHECK CODE TABLE. CURRENTLY EMPTY.

L.CSTB	EQ	.
	HC	L.CSTE-L.CSTB		:LENGTH+2
L.CSTE	EQ	.

:::::::::::::::::::::::::
:: THE FOLLOWING ROUTINE CHECKS THE SENSE CODE IF NEGATIVE
:: RESPONSE WAS RECEIVED IN LOCAL MODE. DEPENDING ON THE SENSE
:: CODE IT GIVES THE RETURN CODE OF 0 IF WE CAN TRY TO REPEAT
:: SEND OPERATION OR NON-ZERO IF IT IS IMPOSSIBLE OR USELESS.
:: INPUTS: R10 - POINTER TO MUCB
:: OUTPUTS: R0 - RETURN CODE
:: LINK:    R5
::
L.RCCK	LA	R6,L.CRTB		:GET ADDR OF SENSE CODES TABLE
	LB	R4,BBUFER+MURHSN,R10,	:GET 1ST BYTE OF SENSE CODE
	LB	R0,BBUFER+MURHSN+1,R10,	:GET 2ND BYTE OF SENSE CODE
	EXBR	R4,R4			:SHIFT THE 1ST BYTE
	OR	R0,R4			:GET SENSE CODE
	J	L.SNCK			:JUMP TO CONTINUE

:SENSE CODE TABLE.
L.CRTB	EQ	.
	HC	L.CRTE-L.CRTB		:LENGTH+2
	HC	82A			:CONTENTION
	HC	82D			:LU BUSY
L.CRTE	EQ	.

::::::::::::::::::::::::::::
:: THIS PROCEDURE CHECKS STATUS CODE RECEIVED IN LUSTAT.
:: THE ACTION COULD BE EITHER REDISPLAY THE PREVIOUS
:: SCREEN OR ABORT LU-LU SESSION DEPENDING ON STATUS CODE.
:: RETURN CODE OF 0 CORRESPONDS TO REDISPLAY, NON-ZERO IS
:: UNABLE TO CONTINUE.
:: INPUTS: R10 - POINTER TO MUCB
:: OUTPUTS: R0 - RETURN CODE
:: LINK:    R5
::
L.LUCK	BBLOAD	R6,BBUFER+MURUPT,R10,	:GET RU POINTER
	LHL	R0,BBUFER+1,R6,		:GET STATUS
	LA	R6,L.LSTB		:GET ADDR OF STAT TABLE
	J	L.SNCK			:JUMP TO CONTINUE

:STATUS TABLE. CURRENTLY EMPTY.
L.LSTB	EQ	.
	HC	L.LSTE-L.LSTB		:LENGTH+2
	HC	82B			:PRESENTATION SPACE DESTROYED
L.LSTE	EQ	.

:COMMON ROUTINE TO CHECK STATUS OR SENSE CODE. EXPECTS CODE TO CHECK
:IN R0. R6 CONTAINS THE ADDR OF TABLE WITH "GOOD" CODES, 1ST 2 BYTES
:OF THE TABLE CONTAIN ITS LENGTH+2. CODES IN THE TABLE ARE IN ASSENDING
:ORDER. OUTPUT IS R0=0 IF CODE IS IN THE TABLE, OTHERWISE R0=1.
:LINK ON R5.
L.SNCK	LHL	R4,0,R6			:GET TABLE LENGTH+2
L.SNC1	SIS	R4,2			:DECREASE THE LENGTH
	JEFS	L.SNC2			:JUMP IF END OF TABLE
	CH	R0,0,R6,R4		:COMPARE CODE WITH TABLE
	JLBS	L.SNC1			:JUMP IF LESS
	JGFS	L.SNC2			:JUMP IF NOT FOUND
	XR	R0,R0			:FOUND MATCH
	JR	R5			:RETURN
L.SNC2	LIS	R0,1			:MATCH NOT FOUND
	JR	R5			:RETURN

:::::::::::::::::::::::::
:THE FOLLOWING ROUTINE GENERATES RESPONSE WITH THE SENSE CODE
:INDICATED IN R0 (0 FOR +RSP).
:IT EXPECTS ALSO A VALID MUCB WITH THE POINTER IN R10.
:THE REPONSE WILL HAVE THE SAME FID, RU CATEGORY, DR INDICATORS
:AND SNF AS THE ORIGINAL MUCB. ORIGINATION AND DESTINATION
:FIELDS WILL BE REVERSED. OTHER FIELDS WILL BE SET AS
:REQUIRED FOR REPONSE.
:R1 MUST CONTAIN RU CODE IF RU CATEGORY IS DIFFERNT FROM FMD.
:R9 MUST HAVE POINTER TO LUCB.
:
:OUTPUTS - R10 CONTAINS POINTER TO UPDATED MUCB (INPUT MUCB IS DESTROYED).
:	 - R3 CONTAINS POINTER TO DQE WITH FILLED IN WITH LUCB AND
:		SCB POINTERS.
:
:LINK ON R5.
:NO OTHER REGISTERS ARE DESTROYED.
:
:FIRST GET BUFFERLET FOR REPONSE BODY.
L.GNRP	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	JAL	R4,GBB,,		:GET BUF FOR RSP BODY
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	BBSTOR	R3,BBUFER+MUCBTU,R10,	:PUT BUF PTR IN MUCB

:CHANGE MUCB DIRECTION TO SEND AND EXCHANGE ORIGINATION AND DESTINATION
:ADRESSES.
	LIS	R5,SENT			:PREPARE SEND DIRECTION
	STB	R5,BBUFER+MUDIRE,R10,	:PUT IT IN MUCB
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MUSCHK,R10,	:CLEAR SENSE-CHECK
	LB	R5,BBUFER+MUDADP,R10,	:GET DESTINATION ADDR
	LB	R4,BBUFER+MUOADP,R10,	:GET ORIGINATION ADDR
	STB	R5,BBUFER+MUOADP,R10,	:UPDATE MUCB ORIGINATION ADDR
	STB	R4,BBUFER+MUDADP,R10,	:UPDATE MUCB DESTINATION ADDR

:UPDATE 1ST BYTE OF TH INFORMATION TO ONE SEGMENT MESSAGE.
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	OHI	R5,MU.BIU!MU.EIU	:SET BEG AND END OF SEG
	STH	R5,BBUFER+MUBIUF,R10,	:UPDATE 1ST BYTE OF TH

:CALCULATE TH LENGTH
	AHI	R5,10			:SHIFT FID F->4 TO 0->5
	LBR	R5,R5			:CLEAR OVERFLOW
	SRLS	R5,4			:MAKE INDEX TO TH LENGTH TABLE
	LB	R2,FIDLGT,R5,		:GET TH LENGTH

:PREPARE POINTER TO RU AND DATA COUNT FIELD.
	AR	R3,R2			:POINT TO RH
	AIS	R3,3			:POINT TO RU
	LIS	R4,3			:PREPARE TO SEND NO RU

:PREPARE RH BYTES 1 AND 2 FOR +RSP
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	LB	R6,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	OHI	R5,MU.RRI!MU.BCI!MU.ECI	:ONE RU CHAIN RSP
	NHI	R6,@MU.RTI		:POSITIVE RSP
	LR	R0,R0			:ANY SENSE DATA?
	JE	L.GNR1			:JUMP IF +RSP REQUESTED

:FOR NEGATIVE RESPONSE INDICATE IT, COPY SENSE DATA IN MUCB
:AND INCREASE RU POINTER AND DATA COUNT FIELD BY 4 BYTES.
	OHI	R5,MU.SDI		:SENSE DATA INCLUDED
	OHI	R6,MU.RTI		:RESPOONSE TYPE NEGATIVE
	AIS	R3,4			:POINT TO RU AFTER SENSE DATA
	AIS	R4,4			:INCREASE DATA COUNT
	STB	R0,BBUFER+MURHSN+1,R10,	:COPY 2ND BYTE OF SENSE DATA
	EXBR	R0,R0			:EXCHANGE SENSE DATA BYTES
	STB	R0,BBUFER+MURHSN,R10,	:COPY 1ST BYTE OF SENSE DATA
	XR	R0,R0			:PREPARE TO ZERO 3RD AND 4TH
	STB	R0,BBUFER+MURHSN+2,R10,	:ZERO 3RD BYTE OF SENSE DATA
	STB	R0,BBUFER+MURHSN+3,R10,	:ZERO 4TH BYTE OF SENSE DATA

:FOR RU CATEGORY OTHER THAN FMD COPY RQ CODE (1 BYTE OF R1) IN RU.
L.GNR1	LR	R0,R5			:COPY 1ST BYTE OF RH
	NHI	R0,MU.CTG		:IS IT FMD CATEGORY?
	JEFS	L.GNR0			:JUMP IF SO
	STB	R1,BBUFER,R3,		:COPY RQ CODE IN RU
	AIS	R4,1			:INCRESE DATA COUNT
:	JFS	L.GNR2			:JUMP TO CONTINUE(4/23/85/CHS)
	J	L.GNR2			:JUMP TO CONTINUE(4/23/85/CHS)

:IF FMD RQ IS FORMATED COPY 3 BYTES OF RQ CODE IN RU.
L.GNR0	THI	R5,MU.FI		:IS IT FORMATTED?
:	JEFS	L.GNR2			:JUMP IF NOT (02/05/87 YLH)
	JE	L.GNR2			:JUMP IF NOT (02/05/87 YLH)
:	EXHR	R0,R1			:1ST BYTE OF RU IN LAST BYTE OF R0 (02/05/87 YLH)
	BBLOAD	R8,BBUFER+MURUPT,R10,	:GET RU POINTER (02/05/87 YLH)
	LB	R0,BBUFER,R8,		:GET 1ST BYTE OF RU (02/05/87 YLH)
	STB	R0,BBUFER,R3,		:PUT 1ST BYTE OF RU IN MSG BUFFER
:	EXBR	R0,R1			:EXCHANGE 2ND AND 3RD BYTE OF RU (02/05/87 YLH)
:	STB	R0,BBUFER,R3,		:PUT 2ND BYTE OF RU IN MSG BUFFER(4/22/85/CHS)
	LB	R0,BBUFER+1,R8,		:GET 2ND BYTE OF RU (02/05/87 YLH)
	STB	R0,BBUFER+1,R3,		:PUT 2ND BYTE OF RU IN MSG BUFFER(4/22/85/CHS)
:	STB	R1,BBUFER+1,R3,		:PUT 3RD BYTE OF RU IN MSG BUFFER(4/22/85/CHS)
	LB	R0,BBUFER+2,R8,		:GET 3ND BYTE OF RU (02/05/87 YLH)
:	STB	R1,BBUFER+2,R3,		:PUT 3RD BYTE OF RU IN MSG BUFFER(4/22/85/CHS)
	STB	R0,BBUFER+2,R3,		:PUT 3RD BYTE OF RU IN MSG BUFFER (02/05/87 YLH)
	AIS	R4,3			:INCREASE DATA COUNT (4/22/85/CHS)

:UPDATE RH AND DCF IN MUCB.
L.GNR2	STH	R4,BBUFER+MUDCF,R10,	:UPDATE DATA COUNT FIELD
	BBSTOR	R3,BBUFER+MURUPT,R10,	:UPDATE POINTER TO RU
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE 1ST BYTE OF RH
	STB	R6,BBUFER+MURHF2,R10,	:UPDATE 2ND BYTE OF RH
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MURHF3,R10,	:ZERO 3RD BYTE OF RH

:OBTAIN BUFFERLET FOR DQE AND FILL IT WITH LUCB AND SCB POINTERS.
	JAL	R4,GBB,,		:GET BUF FOR DQE
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	IF	TERMIF&HOSTIF
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JNFS	L.GNR5			:JUMP IF NOT
	EI
	IF TERMIF
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGIN ADDR
	EI
	IF	TERMIF&HOSTIF
	JFS	L.GNR6			:JUMP TO CONTINUE
	EI
	IF	HOSTIF
L.GNR5	LB	R5,BBUFER+MUDADP,R10,	:GET DEST ADDR
	EI
L.GNR6	JEFS	L.GNR3			:JUMP IF SSCP-LU
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB ADDR
	JFS	L.GNR4			:JUMP TO CONTINUE
L.GNR3	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET SSCP-LU SCB ADDR
L.GNR4	ST	R7,BBUFER+DQSCB,R3,	:FILL IN SCB POINTER
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:FILL IN DQE MUCB POINTER
	STH	R9,BBUFER+DQLUCB,R3,	:FILL IN LUCB POINTER
	ST	R3,LURGSV+0C,,		:OVERRIDE R3 IN SAVE AREA
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	JR	R5			:AND RETURN

	IF	TERMIF
::::::::::::::::::::::::::::
:THE FOLLOWING ROUTINE GENERATES SSCP-LU DATA MESSAGE.
:INPUTS: R8 - POINTER TO CANNED MESSAGE, R1 - LENGTH OF MSG.
:IT EXPECTS ALSO A VALID MUCB WITH THE POINTER IN R10.
:THE MESSAGE WILL HAVE THE SAME FID AS ORIGINAL MUCB.
:ORIGINATION AND DESTINATION FIELDS WILL BE REVERSED AND DESTINATION
:REPLACED BY 0. OTHER FIELDS WILL BE SET AS REQUIRED.
:R9 MUST HAVE POINTER TO LUCB.
:
:OUTPUTS - R10 CONTAINS POINTER TO UPDATED MUCB (INPUT MUCB IS DESTROYED).
:	 - R3 CONTAINS POINTER TO DQE WITH FILLED IN WITH LUCB AND
:		SCB POINTERS.
:
:LINK ON R5.
:NO OTHER REGISTERS ARE DESTROYED.
:
:FIRST GET BUFFERLET FOR REQUEST BODY (THIS PROCEDURE ASSUMES THAT
:THE LENGTH OF THE MESSAGE DOES NOT EXCEED BUFFERLET LENGTH).
L.GNMG	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	JAL	R4,GBB,,		:GET BUF FOR RQ BODY
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	BBSTOR	R3,BBUFER+MUCBTU,R10,	:PUT BUF PTR IN MUCB

:CHANGE MUCB DIRECTION TO SEND AND EXCHANGE ORIGINATION AND DESTINATION
:ADRESSES.
	LIS	R5,SENT			:PREPARE SEND DIRECTION
	STB	R5,BBUFER+MUDIRE,R10,	:PUT IT IN MUCB
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MUSCHK,R10,	:CLEAR SENSE-CHECK
	LB	R4,BBUFER+MUOADP,R10,	:GET ORIGINATION ADDR
	STB	R5,BBUFER+MUOADP,R10,	:UPDATE MUCB ORIGINATION ADDR
	STB	R4,BBUFER+MUDADP,R10,	:UPDATE MUCB DESTINATION ADDR

:UPDATE 1ST BYTE OF TH INFORMATION TO ONE SEGMENT MESSAGE.
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	OHI	R5,MU.BIU!MU.EIU	:SET BEG AND END OF SEG
	STH	R5,BBUFER+MUBIUF,R10,	:UPDATE 1ST BYTE OF TH

:CALCULATE TH LENGTH
	AHI	R5,10			:SHIFT FID F->4 TO 0->5
	LBR	R5,R5			:CLEAR OVERFLOW
	SRLS	R5,4			:MAKE INDEX TO TH LENGTH TABLE
	LB	R2,FIDLGT,R5,		:GET TH LENGTH

:PREPARE POINTER TO RU AND DATA COUNT FIELD.
	AR	R3,R2			:POINT TO RH
	AIS	R3,3			:POINT TO RU
	LIS	R4,3			:PREPARE LENGTH OF RH
	AR	R4,R1			:PREPARE DATA COUNT FIELD

:COPY CANNED MESSAGE INTO BUFFERLET (ASSUMED THAT 1 IS ENOUGH)
L.GNM1	SIS	R1,1			:DECREASE COUNTER
	JLFS	L.GNM2			:JUMP IF NEGATIVE
	LB	R5,0,R8,R1		:GET NEXT BYTE OF CANNED MSG
	STB	R5,BBUFER,R3,R1		:STORE IT INTO THE BUF
	JBS	L.GNM1			:AND CONTINUE

:UPDATE DATA COUNT FIELD AND RU POINTER IN MUCB.
L.GNM2	STH	R4,BBUFER+MUDCF,R10,	:UPDATE DTATA COUNT FIELD
	BBSTOR	R3,BBUFER+MURUPT,R10,	:UPDATE RU POINTER

:UPDATE RH FIELDS. FOR BYTE 2 OF RH WE HAVE TO LOOK IN SCB
:TO SEE WHAT KIND OF RESPONSE TO REQUEST.
	LHI	R5,MU.BCI!MU.ECI	:INDICATE ONE-RU CHAIN
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE 1ST BYTE OF RH
	BBLSCB	R1,LUCTAB+LUSSCB,R9,	:GET PTR TO SSCP-LU SCB
:	LB	R6,SCBBLK+SCPLUP,R1,	:GET FM USAGE BYTE
:	NHI	R6,LURTYP		:GET FORM OF RSP ALLOWED
:	JEFS	L.GNM4			:JUMP IF NO RSP ALLOWED
:	THI	R6,LUDRI		:IS DEF RSP ALLOWED?
:	JEFS	L.GNM3			:JUMP IF NOT
	LHI	R5,MU.DR1		:PREPARE FOR DR1
:	JFS	L.GNM5			:JUMP TO CONTINUE
:L.GNM3	LHI	R5,MU.ERI		:PREPARE FOR EXP RSP
:	JFS	L.GNM5			:JUMP TO CONTINUE
:L.GNM4	XR	R5,R5			:PREPARE FOR NO RSP
L.GNM5	STB	R5,BBUFER+MURHF2,R10,	:UPDATE 2ND BYTE OF RH
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MURHF3,R10,	:CLEAR 3RD BYTE OF RH

:GET EXPEDITED SEQUENCE NUMBER FROM SCB, INCREASE IT BY 1 AND
:PUT IN MUCB.
	LHL	R5,SCBBLK+SCESQN,R1,	:GET EXP SEQ NUMBER
:	AIS	R5,1			:INCREASE IT BY 1
	STH	R5,BBUFER+MUSNF,R10,	:STORE IT IN MUCB

:OBTAIN BUFFER FOR DQE, FILL IT WITH SCB AND LUCB POINTERS AND RETURN.
	JAL	R4,GBB,,		:GET A BUFFERLET
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	ST	R1,BBUFER+DQSCB,R3,	:FILL DQE SCB POINTER
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:FILL IN DQE MUCB PTR
	STH	R9,BBUFER+DQLUCB,R3,	:FILL DQE LUCB POINTER

:PUT R3 IN REGISTER SAVE AREA (TO BE RESTORED TO THE NEW VALUE).
	ST	R3,LURGSV+0C,,		:SAVE R3
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	JR	R5			:AND RETURN
	EI

::::::::::::::::::::::
:: L.SCRQ - THE ROUTINE TO GENERATE RQ OF SC CATEGORY.
:: L.DFSL - THE ROUTINE TO GENERATE SSCP-LU DFC RQ.
:: L.DFLL - THE ROUTINE TO GENERATE LU-LU DFC RQ.
:: RH BYTE 3 IN GENERATED DFC RQ'S IS 0.
:  INPUTS: R8 - POINTER TO CANNED RU
:	   R0 - LENGTH OF BIU
:	   R9 - POINTER TO LUCB
:
:  OUTPUTS:R10 - POINTER TO MUCB
:	   R3 - POINTER TO DQE WITH FILLED IN SCB AND LUCB POINTERS
:
:ENTRY POINTR FOR SSCP-LU DFC MESSAGE.
L.DFSL	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LIS	R14,1			:SHOW THAT SSCP-LU DFC WAS REQUEST
	JFS	L.SCR0			:JUMP TO CONTINUE

:ENTRY POINT FOR LU-LU DFC MESSAGE.
L.DFLL	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LIS	R14,2			:SHOW THAT LU-LU DFC WES REQUESTED
	JFS	L.SCR0			:JUMP TO CONTINUE

:ENTRY POINT FOR SC MESSAGE.
L.SCRQ	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	XR	R14,R14			:SHOW THAT SC RQ WAS REQUESTED

:  AQUIRE BUFFER FOR MUCB.
L.SCR0	JAL	R4,GBB,,		:GET BUFFERLET FOR MUCB
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	LR	R10,R3			:COPY POINTER TO MUCB
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MUSCHK,R10,	:CLEAR SENSE-CHECK

:GET FIRST BUFFER FOR MESSAGE ITSELF AND UPDATE POINTERS TO IT
:IN MUCB.
	JAL	R4,GBB,,		:GET FIRST BUF FOR MSG
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	BBSTOR	R3,BBUFER+MUCBTU,R10,	:STORE POINTER IN MUCB
	LR	R4,R3			:COPY POINTER TO PIU
	LHI	R1,FID2LG+3		:GET DISPLACEMENT OF RU
	AR	R4,R1			:POINT TO RU
	BBSTOR	R4,BBUFER+MURUPT,R10,	:STORE IT IN MUCB

:INITIALIZE COPY LOOP.
	STH	R0,BBUFER+MUDCF,R10,	:STORE DATA COUNT FIELD
	SIS	R0,3			:NUMBER OF CHAR TO COPY

:COPY RU IN THE BUFFERLETS. FIRST CHECK IF WE REACHED THE END
:OF BUFFER AND AQUIRE NEXT BUFFER IF SO.
L.SCR1	CHI	R1,BBFLSZ-BBFPSZ	:END OF BUFFERLET?
	JNFS	L.SCR2			:JUMP IF NOT
	LR	R1,R3			:OTHERWISE SAVE OLD POINTER
	JAL	R4,GBB,,		:GET NEXT BUFFERLET
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	BBSTOR	R3,BBUFER+BBFLSZ-BBFPSZ,R1,	:CHAIN TO OLD BUF
	XR	R1,R1			:CLEAN BUFFER INDEX

:COPY NEXT CHARACTER FROM CANNED AREA TO BUFFERLET AND UPDATE
:INDICES.
L.SCR2	LB	R5,0,R8			:GET NEXT CHARACTER
	STB	R5,BBUFER,R3,R1		:PUT IT INTO BUFFERLET
	AIS	R1,1			:INCREASE BUFFERLET INDEX
	AIS	R8,1			:INCREASE CANNED MSG INDEX
	SIS	R0,1			:DECREASE CHAR COUNT
	JG	L.SCR1			:CONTINUE TO COPY UNTIL DONE

:FILL IN MUCB. FIRST FILL RH BYTE 1.
	LR	R14,R14			:WAS IT SC REQUEST?
	JEFS	L.SCRA			:JUMP IF SO
	LHI	R5,MU.DFC!MU.FI!MU.BCI!MU.ECI	:PREPARE RH BYTE 1 FOR DFC

:PREPARE SCB ADDR FOR DFC CATEGORY MESSAGES.
	CHI	R14,1			:IS IT SSCP-LU DFC RQ?
	JE	L.SCRB			:JUMP IF SO
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:POINT TO LU-LU SCB
	J	L.SCR3			:JUMP TO CONTINUE

:PREPARE RH BYTE 1 FOR SC RQ.
L.SCRA	LHI	R5,MU.SC!MU.FI!MU.BCI!MU.ECI	:PREPARE SC RH BYTE 1

:TYPE OF REPONSE IN RH BYTE 2 DEPENDS ON SCB FM USAGE BYTE.
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET PTR TO LU-LU SCB
:	THI	R7,LUINV		:IS IT VALID?
:	JEFS	L.SCR3			:JUMP IF SO
:	LHR	R7,R7			:EXPAND SCB POINTER
	JFS	L.SCR3			:JUMP TO CONTINUE
L.SCRB	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET PTR TO SSCP-LU SCB
	STB	R5,BBUFER+MURHF1,R10,	:STORE RH BYTE 1 IN MUCB
	J	L.SCRY			:JUMP TO CONTINUE
L.SCR3	STB	R5,BBUFER+MURHF1,R10,	:STORE RH BYTE 1 IN MUCB
:	IF	TERMIF&HOSTIF
:	LB	R4,NCBBLK+NDPUTY,R13,	:GET PU TYPE
:	CHI	R4,PU.T4		:TERMINAL INTERFACE?
:	JNFS	L.SCRU			:JUMP TO CONTINUE
:	EI
:	IF	TERMIF
:	LB	R6,SCBBLK+SCPLUP,R7,	:GET FM USAGE FROM SCB
:	EI
:	IF	TERMIF&HOSTIF
:	JFS	L.SCRV			:JUMP TO CONTINUE
:	EI
:	IF	HOSTIF
:L.SCRU	LB	R6,SCBBLK+SCSLUP,R7,	:GET FM USAGE FROM SCB
:	EI
:L.SCRV	NHI	R6,LURTYP		:GET TYPE OF RESPONSE
:	JEFS	L.SCR5			:JUMP IF NO RESPONSE
:	THI	R6,LUDRI		:DEFINITE RESPONSE?
:	JEFS	L.SCR4			:JUMP IF ONLY EXP RSP
L.SCRY	LHI	R5,MU.DR1		:INDICATE DR1
:	JFS	L.SCR6			:JUMP TO CONTINUE
:L.SCR4	LHI	R5,MU.DR1!MU.ERI	:INDICATE EXP RSP
:	JFS	L.SCR6			:JUMP TO CONTINUE
:L.SCR5	XR	R5,R5			:INDICATE NO RESPONSE
L.SCR6	STB	R5,BBUFER+MURHF2,R10,	:UPDATE RH BYTE 2

:NO USEFUL INFORMATION IN RH BYTE 3
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MURHF3,R10,	:UPDATE RH BYTE 3

:FILL IN TH AND THE REST OF MUCB FIELDS.
	LIS	R5,SENT			:INDICATE SEND DIRECTION
	STB	R5,BBUFER+MUDIRE,R10,	:UPDATE MUCB
	CHI	R14,1			:WAS IT SSCP-LU DFC?
	JNFS	L.SCRF			:JUMP IF NOT
	XR	R5,R5			:SHOW THAT PRIMARY IS SSCP?
	JFS	L.SCRG			:JUMP TO CONTINUE
L.SCRF	LB	R5,LUCTAB+LUPRIL,R9,	:GET ADDR OF PRI STATION
L.SCRG	EQ	.
	IF	TERMIF&HOSTIF
	LB	R4,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R4,PU.T4		:TERMINAL INTERFACE
	JNFS	L.SCRZ			:JUMP IF NOT
	EI
	IF	TERMIF
	STB	R5,BBUFER+MUOADP,R10,	:PUT IT IN MUCB ORIGINATION
	LB	R5,LUCTAB+LUCADR,R9,	:GET ADDR OF SEC STATION
	STB	R5,BBUFER+MUDADP,R10,	:PUT IT IN MUCB DESTINATION
	EI
	IF	TERMIF&HOSTIF
	JFS	L.SCRX
	EI
	IF	HOSTIF
L.SCRZ	STB	R5,BBUFER+MUDADP,R10,	:PUT PRI ADDR IN MUCB DEST
	LB	R5,LUCTAB+LUCADR,R9,	:GET ADDR OF SEC STATION
	STB	R5,BBUFER+MUOADP,R10,	:PUT IT IN MUCB ORIGINATION
	EI
L.SCRX	LR	R14,R14			:IS IT SC?
	JNFS	L.SCRH			:JUMP IF NOT
	LHI	R5,FID2^4!MU.BIU!MU.EIU!MU.EFI	:PREPARE 1ST BYT OF TH
	JFS	L.SCRI			:JUMP TO CONTINUE
L.SCRH	LHI	R5,FID2^4!MU.BIU!MU.EIU	:PREPARE 1ST BYTE OF TH FOR DFC
L.SCRI	STB	R5,BBUFER+MUBIUF,R10,	:UPDATE MUCB
	CHI	R14,2			:IS IT LU-LU DCF
	JEFS	L.SCRK			:NO SEQ # HERE IF SO
	LHL	R5,SCBBLK+SCESQN,R7,	:GET EXP SEQ #
:	AIS	R5,1			:INCREASE IT BY 1
	STH	R5,BBUFER+MUSNF,R10,	:PUT IT IN MUCB

:ACQUIRE BUFFERLET FOR DQE AND FILL IT WITH SCB AND LUCB POITERS.
L.SCRK	LR	R1,R7			:SAVE POINTER TO SCB
	JAL	R4,GBB,,		:GET A BUFFERLET FOR DQE
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	ST	R1,BBUFER+DQSCB,R3,	:FILL IN SCB PTR
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:FILL IN MUCB PTR
	STH	R9,BBUFER+DQLUCB,R3,	:FILL IN LUCB PTR

:SET BITS IN LUSVC WORK BYTE - SC RSP OUTSTANDING 1ST TIME.
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	OHI	R5,LULUSO		:SHOW SC RSP OUTSTANDING
	NHI	R5,@LULUFN		:THIS IS 1ST TIME IN TIMEOUT
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE

:RESTORE ALL REGISTERS EXCEPT R3 AND R10.
	ST	R3,LURGSV+0C,,		:UPDATE R3 IN SAVE AREA
	ST	R10,LURGSV+28,,		:UPDATE R10 IN SAVE AREA
	LM	R0,LURGSV,,		:RESTORE ALL OTHER REGISTERS
	JR	R5			:AND RETURN


::::::::::::::::::::::::::::::
:: THIS ROUTINE IS USED IN TIMEOUT PROCESSING TO CHECK WHETHER
:  SOME OF THE PREVIOUSLY OUTSTANDING RESPONSES WERE SATISFIED.
:  TO ACCOMPLISH THIS GOAL IT COMPARES THE ENDING NUMBER IN THE
:  FIRST CORRELATION TABLE ELEMENT WITH THE NUMBER WHICH WAS
:  SAVED IN SCB FOR THE PREVIOUS EXECUTION OF THIS ROUTINE
:  FOR THE SAME SCB. IF THE NUMBER CHANGED RETURN CODE 0 IS
:  GENERATED. OTHERWISE RETURN CODE IS 1.
:  INPUT:	R7 - POINTER TO SCB.
:  DESTROYS:    R6
:  RETURN CODE:	R0
:  LINK:	R5
L.CTCK	XR	R0,R0			:PREPARE GOOD RETURN CODE
	LH	R6,SCBBLK+SCTSNG,R7,	:GET GET PTR TO CT QUEUE
	CH	R6,SCBBLK+SCTSNR,R7,	:IS THE QUEUE EMPTY
	JER	R5			:RETURN IF SO
	LHL	R6,SCBBLK+SCTSNG,R7,	:GET GET PTR TO CT QUEUE
	BBLOAD	R6,CMDBLK+CLARG,R6,	:GET PTR TO 1ST CT
	LHL	R0,BBUFER+CLARG5,R6,	:GET RH BYTES FROM CT
	THI	R0,LUCTEI		:EXP RSP IND ON?
	JEFS	L.CTC0			:JUMP IF NORMAL FLOW (6/27/84/CHS)
:	JNFS	L.CTC0			:JUMP IF SO (6/27/84/CHS)
:	LH	R6,BBUFER+CLARG3,R6,	:GET END NUMBER FROM CT(6/27/84/CHS)
:	CH	R6,SCBBLK+SCLRPN,R7,	:SAME AS BEFORE?(6/27/84/CHS)
:	JEFS	L.CTC1			:JUMP IF SO(6/27/84/CHS)
:	STH	R6,SCBBLK+SCLRPN,R7,	:OTHERWISE SAVE IT IN SCB(6/27/84/CHS)
L.CTC0	XR	R0,R0			:SHOW EVERYTHING IS OK
	JR	R5			:AND RETURN
:L.CTC1	LIS	R0,1			:SHOW THAT NO MOVEMENT (6/22/84/CHS)
L.CTC1					: (6/22/84/CHS)
	L	R0,BBUFER+CLARG7,R6,	:GET TIME_STAMP (6/22/84/CHS)
	CL	R0,SLOWC,,		:TIME UP? (6/22/84/CHS)
	JG	L.CTC0			:NO, OK. (6/22/84/CHS)
	LIS	R0,1			:SHOW THAT NO MOVEMENT (6/22/84/CHS)
	JR	R5			:AND RETURN

::::::::::::::::::::::::::
:: THIS ROUTINE MATCHES RQ CODE OF DFC MSG WITH THE TABLE OF DFC TYPE
:: RQ CODES (THEY ARE IN ASSENDING ORDER THERE). IF THE MATCH IS FOUND
:: OUTPUT REGISTER CONTAINS SEQUENTIAL NUMBER OF THE CODE IN THE
:: TABLE. OTHERWISE IT POINTS TO THE END OF THE TABLE.
:: INPUT: R0 - DFC RQ CODE.
:: OUTPUT: R6 - DFC RQ NUMBER IN DFC CODE TABLE.
:: LINK:  R5
L.DFCT	LHI	R6,DFCTBE-DFCTAB-1	:START AT THE END OF DFC TABLE
L.DFC1	CLB	R0,DFCTAB,R6,		:MATCH RQ CODE WITH TABLE
	JER	R5			:RETURN IF MATCH FOUND
	JGFS	L.DFC2			:JUMP IF PAST THE CODE VALUE
	SIS	R6,1			:OTHERWISE CONTINUE TO TRY
	JGEBS	L.DFC1			:UNTIL THE TABLE IS EXHAUSTED

:NO MATCH FOUND. POINT TO THE END OF DFC TABLE.
L.DFC2	LHI	R6,DFCTBE-DFCTAB	:POINT TO THE END OF THE TABLE
	JR	R5			:AND RETURN

::::::::::::::::::::::::::::::::::::::
:: THIS ROUTINE GENERATES DUMMY (RH-ONLY) FMD TO BE SENT TO THE TERMINAL.
:: R10 CONTAINS MUCB FOR THIS MESSAGE. DESTINATION 0 (SSCP) IS GENERATED.
:: LINK ON R5.
	IF	TERMIF
L.GNDS	STM	R0,LURGSV,,		:PRESERVE ALL REGISTERS
	JAL	R4,GBB,,		:OBTAIN BUFFERLET FOR MUCB
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LR	R10,R3			:COPY BUFFERLET POINTER
	LIS	R4,SENT			:INDICATE SEND DIRECTION
	STB	R4,BBUFER+MUDIRE,R10,	:STORE IT IN MUCB
	LB	R5,LUCTAB+LUCADR,R9,	:GET ADDR OF SEC
	STB	R5,BBUFER+MUDADP,R10,	:STORE IT IN MUCB
	XR	R5,R5			:PRIMARY IS SSCP
	STB	R5,BBUFER+MUDADP,R10,	:STORE IT IN MUCB
	STB	R5,BBUFER+MUSCHK,R10,	:CLEAR SENSE-CHECK
	LHI	R5,FID2^4!MU.BIU!MU.EIU	:FID2 AND 1 SEGMENT
	STB	R5,BBUFER+MUBIUF,R10,	:1ST BYTE OF TH
	LHI	R5,MU.BCI!MU.ECI	:FMD AND 1 CHAIN
	STB	R5,BBUFER+MURHF1,R10,	:1ST BYTE OF RH
	LHI	R5,MU.DR1		:DEF RSP
	STB	R5,BBUFER+MURHF2,R10,	:2ND BYTE OF RH
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MURHF3,R10,	:3RD BYTE OF RH
	LIS	R5,3			:LENGTH OF RH
	STH	R5,BBUFER+MUDCF,R10,	:STORE IT IN MUCB
	JAL	R4,GBB,,		:AQUIRE BUFFERLET FOR MSG
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	BBSTOR	R3,BBUFER+MUCBTU,R10,	:STORE BTU POINTER IN MUCB
	AIS	R3,FID2LG+3		:POINT TO DUMMY RU
	BBSTOR	R3,BBUFER+MURUPT,R10,	:STORE IT IN MUCB
	ST	R10,LURGSV+28,,		:UPDATE R10 SAVE AREA
	LM	R0,LURGSV,,		:RETORE ALL REGISTERS
	JR	R5			:AND RETURN
	EI

	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER

	EM
	MO	.,SNTPKG

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN
	LO	SNAPKG

	IF	VTISUP

::::::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS A CODE FOR TERMINAL DSP SUPPORT (SEND SIDE) OF
:: LU SERVICE MANAGER.
::::::::::::::::::::::::::::::::::::::::::

	SEG	A.CODE
::::::::::::::::::::::::::::::::::
:ENTRY POINTS FOR LU SEND PROCESS FOR HOST DSP SUPPORT ARE L.DPST (STATUS
:COMMAND FORM NIO) AND L.DPET (END-TO-END MESSAGE FROM NIO).

L.BASE	EQ	.			:BASE  POINT FOR VTI

:::::::::::::::::::::::::::::::::::
:: L.DPST - STATUS COMMAND FROM NIO. THIS COMMAND IS NEVER GENERATED
:: BY NIO ITSELF, BUT BY LU-SVC WHENVER THERE IS A NEED TO SEND
:: SNA CONTROL MESSAGE. THE TYPE OF MESSAGE TO BE GENERATED IS
:: DEFINED BY SUBCOMMAND BYTE. 7 TYPES OF REQUESTS ARE CURRENTLY VALID:
::      NSSTTR	EQ	1	:START LOGON (NETWORK SERVICE)
::      NSSTNW	EQ	2	:START LOGON (RETURN FROM NSM)
::	NSTDUB	EQ	3	:SEND UNBIND
::	NSTDBD	EQ	4	:SEND BIND
::	NSTDST	EQ	5	:SEND SDT
::      NSTDNE	EQ	6	:GENERATE ERROR CMD TO NIO
::	NSTDBI	EQ	7	:SEND BID
:::::::::::::::::::::::::::
L.DPST	LR	R9,R4			:COPY LUCB POINTER
	CHI	R1,NSTDMX		:MAXIMUM SUBCOMMAND DEFINED
	GL	L.PLFN
	JG	L.PLFN			:ERROR IF GREATER SUBCOMMAND
	LB	R5,LUCTAB+LULUST,R9,	:GET LU-SVC STATE BYTE
	OHI	R5,WAITRS		:WAIT FOR RSP BEFORE DOING MORE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	SIS	R1,NSTDMN		:ADJUST FOR SMALLEST VALID SUBCOMMAND
	LHL	R5,L.DPTB,R1,R1		:GET POINTER TO PROCESSING ROUTINE
	J	L.BASE,R5		:JUMP TO PROCESSING ROUTINE

	GL	L.PTUB,L.PLBD,L.PLSD
L.DPTB	HC	L.DPRL-L.BASE		:REQUEST LOGON
	HC	L.DPRN-L.BASE		:RETURN FROM NSM
	HC	L.PTUB-L.BASE		:SEND UNBIND
	HC	L.PLBD-L.BASE		:SEND BIND
	HC	L.PLSD-L.BASE		:SEND SDT
	HC	L.DPNE-L.BASE		:GENERATE ERROR TO NIO
	HC	L.DPSB-L.BASE		:SEND BID

:LOGON WAS REQUESTED (NETWORK SERVICE SCREEN CALLED BY THE USER).
:GO TO PENDING LOCAL MODE TO SERVICE LOGON REQUEST.
L.DPRL	LHI	R5,PLCSTA		:PREPARE PENDING LOCAL MODE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE BYTE
	JR	R14			:AND RETURN

:RETURN FROM NSM. IF THIS IS A CONNECTION TO NON-SNA HOST
:REPLACE CMD BY STATUS & SEND BIND AND INDICATE ERROR RECOVERY.
L.DPRN	LB	R5,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	NHI	R5,@WAITRS		:RESET WAIT BIT
	OHI	R5,LUDPCL!LUDPER	:INDICATE CLEANING
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU_SCV STATE BYTE
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE BYTE
	THI	R5,LUSCRN		:THE PARTNER IS SNA?
	JN	L.DPSN			:JUMP IF SO
	LHL	R6,LUCTAB+LUSNDG,R9,	:GET POINTER TO CMD LINK
	LHI	R5,NSSTAT^8!NSTDBD	:START WITH BIND
	STH	R5,CMDBLK+CLCMD,R6,	:REPLACE COMMAND AND SUBCOMMAND
	LIS	R5,SNERRD+1		:INDICATE RE-DISPLAY
	STH	R5,CMDBLK+CLLNG,R6,	:PUT IT INTO CMD LINK
	JR	R14			:AND RETURN

:RETURN TO CONVERSATION WITH SNA HOST.
:THIS ROUTINE TO BE CODED LATER.
L.DPSN	JAL	R10,CRASH,,
	HC	0
	BC	4*R4,CR.TMP

:GENERATE ERROR TO NIO AND REMOVE CMD LINK. ERROR CODE IS
:TAKEN FROM CMD LINK LENGTH BYTE AND DECREASED BY 1.
L.DPNE	LB	R5,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	NHI	R5,@WAITRS		:RESET WAIT BIT
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE BYTE
	LHL	R6,LUCTAB+LUSNDG,R9,	:GET POINTER TO CMD LINK
	LHL	R5,CMDBLK+CLLNG,R6,	:GET ERROR CODE + 1
	SIS	R5,1			:OBTAIN ERROR CODE
	LHI	R0,SNERR^8		:PREPARE ERROR COMMAND TO NIO
	OR	R0,R5			:MERGE ERROR CODE
	JAL	R5,L.PTCD		:SEND IT TO NIO
	J	L.RMD0			:JUMP TO REMOVE CMD LINK

:SEND BID PROCESSING ROUTINE. FIRST DOUBLE CHECK IF BID IS STILL VALID
:TO SEND AND SEND IF SO.
L.DPSB	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JE	L.RMD0			:JUMP IF NO LU-LU SESSION
	LB	R5,SCBBLK+SCSTAT+FSCBUA,R7,	:GET BIU-ASSEMBLY FSM
	JNR	R14			:RETURN IF NOT FINISHED
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7,	:GET IMM-RCV FSM
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCBBI,R7,	:GET FSM-BIDDER
	CHI	R5,FS.ST1		:STILL BETWEEN BRACKETS?
	JN	L.RMD0			:JUMP IF NOT
	LA	R8,BIDCAN,,		:POINT TO CANNED BID MSG
	LHI	R0,BIDLGT+3		:LENGTH OF BID + RH
	JAL	R5,L.DFLL		:GENERATE BID
	LHI	R2,DFCSND		:DESTINATION DFC_SEND
	LHI	R1,LUSEND		:ORIGINATION LU_SEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND IT
	JR	R14			:AND RETURN
	
:::::::::::::::::::::::::::::::::::
:: L.DPET - SEND END-TO-END MESSAGE FROM NIO. THE ROUTINE CHECKS
:: IF SNA IS PREPRAED TO SEND THE DATA MESSAGE TO THE SECONDARY
:: (TESTS IF THE SESSION IS ACTIVE AND IN THE SEND STATE). IF
:: SO THE MESSAGE IS MAPPED TO CANONICAL FORM OF SNA LAYER AND
:: SENT OVER TO DFC LAYER. iF THE TEST FAILS THE CONTROL IS
:: PASSED EITHER BACK TO THE DISPATCHER (TO WAIT AND SEE IF
:: THE SESSION GETS INTO THE SEND STATE BY ITSELF) OR VARIOUS
:: SESSION CONTROL OR ERROR RECOVERY ROUTINES.


:FIRST CHECK IF CLEANING IS REQUIRED.
L.DPET	LR	R9,R4			:COPY LUCB POINTER
	LB	R5,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	THI	R5,LUDPCL		:CLEANING REQUESTED?
	JN	L.DPCL			:JUMP IF SO

:IF LU-LU SESSION DOES NOT EXIST JUMP TO SESSION CONTROL ROUTINE.
L.DPE0	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JE	L.DPBD			:JUMP IF NO LU-LU
	LB	R5,SCBBLK+SCSTAT+FSCDSA,R7,	:GET SDT-CLEAR FSM
	CHI	R5,FS.ST3		:DATA TRAFFIC ALLOWED?
	JN	L.DPDT			:JUMP IF NOT

:CHECK IF THIS IS FIRST SEGMENT OF THE FIRST RU IN CHAIN.
	THI	R1,NSDTLS!NSDTLC	:1ST SEGMENT, 1ST IN CHAIN?
	JN	L.DPE2			:JUMP IF NOT
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE BYTE
	THI	R5,LUSCRN		:SCREEN STATE SUPPORT?
	JEFS	L.DPE1			:JUMP IF NOT
	BBLOAD	R5,CMDBLK+CLARG,R8,	:GET POINTER TO MESSAGE
	LB	R5,BBUFER+THDISP+FID2LG+3,R5,	:GET 3270 CMD
	CHI	R5,WSTCMD		:WRITE STATUS FROM HIF?
	JE	L.DPWS			:JUMP IF SO

:LU TYPE 2 HAS IMMEDIATE REQUEST MODE. IF RSP FOR PREVIOUS RQD
:WAS NOT YET RECEIVED OR SENT RETURN WITHOUT DOING ANYTHING (HOPEFULLY NEXT
:TIME RSP WILL NE RECEIVED AND WE WILL BE ABLE TO SEND).
L.DPE1	THI	R1,NSDTLS		:1ST SEGMENT?
	JN	L.DPE3			:JUMP IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCBUA,R7,	:GET BIU_ASSEMBLY FSM
	JNR	R14			:RETURN IF NOT FINISHED
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7, :GET IMM_RCV STATE
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:RETURN IF NOT

:CHECK BRACKET STATE AND JUMP TO SEND BID IF BETWEEN BRACKETS.
	LB	R5,SCBBLK+SCCLUP,R7,	:GET COMMON PROTOCOLS IN BIND
	THI	R5,LUBDBR		:BRACKETS USED?
	JEFS	L.DPE2			:JUMP IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCBBI,R7,	:GET FSM_BIDDER
	CHI	R5,FS.ST1		:BETWEEN BRACKETS?
	JE	L.DPBI			:JUMP TO SEND BID IF SO
	CHI	R5,FS.ST2		:IN-BRACKETS?
	JEFS	L.DPE2			:JUMP IF SO
	CHI	R5,FS.ST3		:RSP(BID) RECEIVED?
	JNR	R14			:WAIT IF NOT

:CHECK HALF-DUPLEX FLIP-FLOP.
L.DPE2	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7, :GET HALF-DUPLEX FLIP-FLOP
	CHI	R5,FS.ST3		:STATE 3?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:WAIT IF SO
	JG	L.DPHR			:RECOVER IF GREATER THAN 5

:IF CANCEL IS PENDING AS INDICATED BY LUSVC WORK BYTE GENERATE CANCEL
:MESSAGE ANS SEND IT. THE MESSAGE ITSELF IS NOT SENT THIS TIME (IT
:WAS SENT DURING PREVIOUS EXECUTION OF LU.SEND WHEN PEND INDICATOR
:WAS SET AND LEFT IN NIO->SNA DATA QUEUE TO CAUSE THE SCHEDULER
:TO CALL LUSCV AGAIN). THE MESSAGE WILL BE REMOVED BY REMOVE ROUTINE
:WHEN IT PROCESSES CANCEL NOTIFICATION FROM LOWER SNA LAYERS.
L.DPE3	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULUCN		:CANCEL PENDING?
	JE	L.DPE4			:JUMP IF NOT
	NHI	R5,@LULUCN		:RESET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LR	R9,R4			:COPY LUCB POINTER
L.DPEC	LA	R8,CANCAN,,		:POINT TO CANNED CANCEL MSG
	LHI	R0,CANLGT+3		:LENGTH OF CANCEL (+RH)
	JAL	R5,L.DFLL		:GENERATE CANCEL
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	OHI	R5,MU.CDI		:CHANGE DIRECTION
	STB	R5,BBUFER+MURHF3,R10,	:UPDATE 3RD BYTE OF RH
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LUSEND		:ORIGINATION LU.SEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN

:MAP MESSAGE TO CANONICAL.
L.DPE4	LR	R4,R9			:COPY LUCB POINTER
	THI	R1,NSDTCD		:CHANGE DIRECTION FROM NIO?
	JE	L.DPEX			:JUMP IF NOT
	THI	R1,NSDTEB		:END OF BRACKET PROHIBITED?
	JN	L.DPEX			:JUMP IF SO
	THI	R1,NSDTLC!NSDTLS	:1ST SEGM OF 1ST IN CHAIN?
	JEFS	L.DPEY			:JUMP IF SO
	NHI	R1,@NSDTCD		:FAKE NO CHANGE DIRECTION
	LB	R5,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	OHI	R5,LUTDBR		:BRCKET TERMINATION PENDING
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE BYTE
	J	L.DPEX			:JUMP TO CONTINUE
L.DPEY	THI	R1,NSDTFC!NSDTFS	:ALSO LAST SEGM OF LAST IN CHAIN?
	JN	L.DPEX			:JUMP IF NOT
	LHL	R3,CMDBLK+CLPTR,R8,	:GET POINTER TO NEXT CMD LINK
	LHL	R5,LUCTAB+LUSNDR,R9,	:GET RELEASE POINTER
	CR	R3,R5			:MORE DATA?
	JE	L.DPEX			:JUMP IF NOT
	LB	R5,CMDBLK+CLCMD,R3,	:GET NEXT COMMAND CODE
	CHI	R5,NSETEM		:DATA MESSAGE?
	JNFS	L.DPEX			:JUMP IF NOT
	NHI	R1,@NSDTCD		:FAKE NO CHANGE DIRECTION
	STB	R1,CMDBLK+CLCMDS,R8,	:UPDATE CURRENT CMD LINK
L.DPEX	JAL	R5,L.MTCN		:MAP TO CANONICAL
	LHL	R5,SCBBLK+SCSQSC,R7,	:GET LATEST SEQ NUMBER
	STH	R5,BBUFER+MUSNF,R10,	:STORE IT IN MUCB

:IF CANCEL IS REQUESTED BY NIO INDICATE IT IN LUSVC WORK BYTE. ALSO
:FORCE LAST SEGMENT BUT NOT THE LAST CHAIN ELEMENT.
	THI	R1,NSDTCN		:CANCEL REQUESTED BY NIO?
	JE	L.DPEE			:JUMP IF NOT
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	OHI	R5,LULUCN		:SET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	OHI	R5,MU.EIU		:FORCE LAST SEGMENT
:	STB	R5,LUCTAB+LULUWK,R10,	:UPDATE 1ST BYTE OF TH (02/26/87 YLH)
	STB	R5,BBUFER+MUBIUF,R10,	:UPDATE 1ST BYTE OF TH (02/26/87 YLH)
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,@MU.ECI		:FORCE NOT THE LAST CHAIN ELEMENT
:	STB	R5,LUCTAB+MURHF1,R10,	:UPDATE 1ST BYTE OF RH (02/26/87 YLH)
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE 1ST BYTE OF RH (02/26/87 YLH)

:IF NIO REQUESTED END-TO-END ACK SET ACK INDICATOR IN LUSVC WORK BYTE.
L.DPEE	THI	R1,NSDTAK		:ACK REQUESTED BY NIO?
	JEFS	L.DPEF			:JUMP IF NOT
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUFA		:RESET ACK TIMEOUT BIT
	OHI	R5,LULUAK		:SET ACK PENDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE

:TURN ON THE FLAG IN LU-SVC STATE BYTE IF NOT THE CURRENT MESSAGE
:IS NOT FINISHED WITH WHAT IS BEING SENT.
L.DPEF	LB	R5,LUCTAB+LULUST,R9,	:GET LU-SVC STATE BYTE
	THI	R1,NSDTFC!NSDTFS	:LAST SEGM IN LAST CHAIN?
	JEFS	L.DPEI			:JUMP IF SO
	OHI	R5,LUTDFL		:TURN ON THE FLAG
	JFS	L.DPEK			:JUMP TO CONTINUE
L.DPEI	NHI	R5,@LUTDFL		:TURN OFF THE FLAG
L.DPEK	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU-SVC STATE BYTE

:CREATE DQE AND FILL IT IN.
	LR	R1,R7			:SAVE SCB POINTER
	JAL	R4,GBB,,		:GET BUFFERLET FOR DQE
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	ST	R1,BBUFER+DQSCB,R3,	:FILL IN DQE SCB POINTER
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:FILL IN MUCB POINTER
	STH	R9,BBUFER+DQLUCB,R3,	:FILL IN LUCB POINTER
	LHI	R2,DFCSND		:SHOW DFC.SEND AS DEST
	LHI	R1,LUSEND		:ORIGINATION LU.SEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL

:IN MULTI-SEGMENT MESSAGE THE FIRST SEGMENT WILL BE REMOVED FROM
:NIO->SNA QUEUE ONLY AFTER POSITIVE NOTIFIACTION FROM LOWER
:SNA LAYERS. THE REST OF THE SEGMENTS ARE REMOVED IMMEDIATELY EXCEPT
:FOR THE CASE WHEN CANCEL IS PENDING.
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUCB WORK BYTE
	THI	R5,LULUCN		:CANCEL PENDING?
	JN	L.DPEG			:JUMP IF SO
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	NHI	R5,MU.BIU		:1ST SEGMENT?
	JN	L.DPEG			:JUMP IF SO
	LR	R6,R8			:COPY POINTER TO CMD LINK
	LHL	R5,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK
	JE	L.CLER			:JUMP IF EMPTY PTR
	STH	R5,LUCTAB+LUSNDG,R9,	:ADVANCE GET POINTER
	JAL	R4,RELCL,,		:RELEASE THE LINK
	LHL	R4,LUCTAB+LUSNDR,R9,	:GET RELEASE POINTER
	CR	R4,R5			:COMPARE GET AND RELEASE
	JNFS	L.DPEG			:JUMP IF NOT LAST
	LHL	R4,LUCTAB+LUCT.N,R9,	:GET REL LU #
	RBT	R4,DPNWSN,,		:RESET DATA PRESENT

:SEND MU TO LOWER LAYER AND RETURN.
L.DPEG	JAL	R8,SEND,,		:SEND DQE TO LOWER LAYER
	JR	R14			:AND RETURN

:NO LU-LU SESSION. IF THE SCREEN IS NOT CONTROLLED BY HIF (THAT IS
:IF WE ARE IN SESSION WITH NON-SNA HIF) PREPARE TO SEND BIND
:BY QUEUEING NIO->SNA STATUS COMMAND AHEAD OF THE END-TO-END MESSAGE.
L.DPBD	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE BYTE
	THI	R5,LUSCRN		:SCREEN CONTROL?
	JNFS	L.DPB1			:JUMP IF SO
	LHI	R0,NSSTAT^8!NSTDBD	:STATUS COMMAND WITH BIND REQUEST
	XR	R1,R1			:INDICATE NO ERROR RECOVERY
	JAL	R10,L.NSST		:QUEUE AHEAD OF CURRENT QUEUE
	JR	R14			:AND RETURN

:NO LU-LU SESSION AND SCREEN STATE IS CONTROLLED BY HIF (THAT IS
:WE ARE IN SESSION WITH SNA HIF). CHECK IF THE DATA MESSAGE QUEUED
:IS WRITE STATUS FROM HIF. IF NOT CONVERT IT TO SCS AND SEND ON
:SSCP-LU SESSION.
L.DPB1	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET SSCP-LU SCB POINTER
	THI	R1,NSDTLS!NSDTLC	:FIRST SEGM OF FIRST IN CHAIN?
	JE	L.DPB2			:JUMP IF SO
	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET POINTER TO MSG BUFFER
	LB	R4,BBUFER+THDISP+FID2LG+3,R4,	:GET 3270 COMMAND CODE
	CHI	R4,WSTCMD		:WRITE STATUS?
	JE	L.DPWS			:JUMP IF SO
	THI	R5,LUSYRQ		:IN SYS-REQ CYCLE?
	JN	L.DPCE			:GET RID OF THE MESSAGE IF SO

:LU-LU SESSION DOES NOT EXIST.
:CHECK WHETHER SSCP-LU STATE MACHINE ALLOWS TO SEND AND SEND THE
:MESSAGE IF SO AFTER CONVERTING IT TO SNA CHARATER STREAM.
	LB	R5,SCBBLK+SCSTAT+FSCBUA,R7,	:GET BIU_ASSEMBLY STATE
	JNR	R14			:RETURN IF BETS
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX_FF STATE
	CHI	R5,FS.ST3		:STATE 3?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST6		:STATE 6?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST8		:STATE 8?
	JER	R14			:CANNOT SEND, RETURN

:LU TYPE 2 HAS IMMEDIATE REQUEST MODE. IF RSP FOR PREVIOUS RQD
:WAS NOT YET RECEIVED RETURN WITHOUT DOING ANYTHING (HOPEFULLY NEXT
:TIME RSP WILL NE RECEIVED AND WE WILL BE ABLE TO SEND).
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7, :GET IMM_RCV STATE
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO
	JFS	L.DPB0			:JUMP TO CONTINUE

:THIS IS END-TO-END MESSAGE TO BE CONVERTED TO SCS AND SENT ON
:SSCP-LU SESSION.
L.DPB2	THI	R5,LUSYRQ		:IN SYS-REQ CYCLE?
	JN	L.DPCE			:GET RID OF THE MESSAGE IF SO
L.DPB0	JAL	R5,L.MTSC		:CONVERT TO SCS
	LR	R0,R0			:SUCCESSFUL CONVERSION?
	JE	L.DPBA			:JUMP IF SO

:3270/SCS CONVERSION FAILED. INFORM NIO AND GO INTO CLEANING.
	LHI	R0,SNERR^8!SNERRD	:REQUEST NIO TO RE-DISPLAY
	JAL	R5,L.PTCD		:PUT REQUEST IN THE QUEUE
	LB	R5,LUCTAB+LULUST,R9,	:GET LU-SVC STATE BYTE
	OHI	R5,LUDPCL		:INDICATE CLEANING
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU-SVC STATE BYTE
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO BTU
	JAL	R5,R.PBBC,,		:RELEASE BUFFERS WITH BTU
	LR	R3,R10			:COPY MUCB POINTER
	JAL	R4,R.PBB,,		:RELEASE MUCB BUFFER
	J	L.RMD0			:JUMP TO REMOVE CMD LINK

:CANCEL IS NOT ALLOWED ON SSCP-LU SESSION.
:IF WE HAVE CANCEL INDICATOR ON IGNORE IT, BUT FORCE LAST SEGMENT AND
:LAST CHAIN ELEMENT.
L.DPBA	THI	R1,NSDTCN		:WAS CANCEL REQUESTED?
	JE	L.DPEE			:JUMP IF NOT
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULUCN		:CANCEL PENDING?
	JN	L.DPBL			:JUMP IF SO
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	LR	R0,R5			:SAVE IT
	OHI	R5,MU.EIU		:FORCE LAST SEGMENT
	STB	R5,BBUFER+MUBIUF,R10,	:UPDATE 1ST BYTE OF TH
	THI	R0,MU.BIU		:1ST SEGMENT?
	JEFS	L.DPBK			:JUMP IF NOT
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	OHI	R5,MU.ECI		:FORCE LAST CHAIN ELEMENT
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE 1ST BYTE OF RH
	J	L.DPEE			:JUMP TO CONTINUE

:THIS IS NOT THE 1ST SEGMENT OF SSCP-LU MSG AND CANCEL WAS REQUESTED.
:WE HAVE TO FORCE THE LAST CHAIN ELEMENT IF CORRELATION TABLES
:SHOW THAT LAST LAST ELEMENT OF THE CHAIN WAS NOT SENT.
:FIRST CHECK CORRELATION TABLE. IF NOT COMPLETE CHAIN SHOW THAT
:CANCEL IS PENDING.
L.DPBK	LHL	R5,SCBBLK+SCTSNG,R7,	:GET CT ELEMENT
	LHL	R4,SCBBLK+SCTSNR,R7,	:GET RELEASE POINTER
	CR	R5,R4			:ANYTHING THERE?
	JE	L.DPEE			:JUMP IF NOT
	LB	R5,BBUFER+CLARG6,R5,	:GET BYTE WITH CT TYPE
	NHI	R5,CT.ENT		:GET CT TYPE
	JN	L.DPEE			:JUMP IF COMPLETE CHAIN
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	OHI	R5,LULUCN		:SHOW THAT CANCEL IS PENDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	L.DPEE			:JUMP TO CONTINUE

:CANCEL IS PENDING AND THIS IS SSCP-LU MSG.
:WE CANNOT GENERATE CANCEL, BUT WE MUST FORCE THE LAST CHAIN ELEMENT.
:GENERATE DUMMY (RH-ONLY) FMD AND SHOW LAST (BUT NOT FIRST) CHAIN ELEMENT.
:ALSO RESET CANCEL PENDING (REMOVE PROCESS WILL REMOVE CMD LINK WITH
:CANCEL REQUEST AFTER THAT).
L.DPBL	NHI	R5,@LULUCN		:RESET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
L.DPBN	JAL	R5,L.GNDS		:GENERATE DUMMY RU
	LB	R5,BBUFER+MURHF2,R10,	:GET BYTE 2 OF RH
	NHI	R5,@MU.ERI		:CLEAR ERI
	STB	R5,BBUFER+MURHF2,R10,	:UPDATE BYTE 2 OF RH
	LHL	R5,SCBBLK+SCSQSC,R7,	:GET PREVIOUS ID
	AIS	R5,1			:INCREASE IT BY 1
	STH	R5,SCBBLK+SCSQSC,R7,	:UPDATE ID IN SCB
	STH	R5,BBUFER+MUSNF,R10,	:UPDATE MUCB
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,@MU.BCI		:NOT 1ST CHAIN ELEMENT
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE 1ST BYTE OF RH
	J	L.DPEE			:JUMP TO CONTINUE

:REQUEST TO SEND BID. THIS IS DONE BY QUEUEING STATUS COMMAND WITH BID
:REQUEST AHEAD OF NIO->SNA DATA QUEUE.
L.DPBI	LHI	R0,NSSTAT^8!NSTDBI	:STATUS COMMAND WITH BID REQUEST
	XR	R1,R1			:INDICATE NO ERROR RECOVERY
	JAL	R10,L.NSST		:QUEUE IN FRONT OF NIO->SNA DATA Q
	JR	R14			:AND RETURN
	
:CLEAN-BIT WAS ON. IT MEANS THAT NEGATIVE RSP
:WAS RECEIVED FROM THE TERMINAL. BEFORE WE CAN SEND ANYTHING ELSE
:WE HAVE TO PURGE ALL DATA MESSAGES (IF ANY)
:WHICH BELONG TO THE OLD CHAIN.
L.DPCL	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULUNG		:-RSP PENDING?
	JNR	R14			:RETURN IF SO
	THI	R1,NSDTLS		:1ST SEGMENT?
	JN	L.DPCE			:JUMP IF NOT
	THI	R1,NSDTLC		:1ST CHAIN ELEMENT?
	JN	L.DPCE			:JUMP IF NOT
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	NHI	R5,@LUSBST		:CLEAR SUBSTATE INFORMATION
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,LULUFA!LULUAK	:CLEAR ALL BUT ACK INFO
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUW1,R9,	:CLEAR LUSVC 2ND WORK BYTE
	J	L.DPE0			:JUMP TO CONTINUE

:RELEASE CMD LINK AND ASSOCIATED BUFFERS WITH MESSAGE.
L.DPCE	BBLOAD	R3,CMDBLK+CLARG,R8,	:GET PTR TO BUFFER CHAIN
	JAL	R5,R.PBBC,,		:RELEASE BUF CHAIN WITH MSG
	J	L.RMD0			:JUMP TO REMOVE CMD LINK

:ERROR RECOVERY WHILE IN LU-LU SESSION.
L.DPDT
L.DPHR	LB	R5,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	NHI	R5,@WAITRS		:CLEAR WAIT FOR RESPONSE
	OHI	R5,LUDPCL!LUDPER	:INDICATE CLEANING IN BOTH DIR
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE BYTE
	LB	R5,LUCTAB+LULUWK,R9,	:GET LU_SVC WORK BYTE
	NHI	R5,@LULUFN&@LULUSO	:CLEAN TIMEOUT
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LU_SVC WORK BYTE
	LHI	R0,NSSTAT^8!NSTDUB	:START WITH UNBIND
	LIS	R1,SNERRD+1		:INDICATE TO RE-DISPLAY
	JAL	R10,L.NSST		:QUEUE CMD LINK
	JR	R14			:AND RETURN

:SYS/RQ MSG WAS RECEIVED FROM SNA HIF. THIS COULD BE EITHER IN RESPONSE
:FOR SYS/RQ MSG FROM TIF (IN WHICH CASE SEQ# IS NOT 0) OR
:UNSOLOCITIED SYS/RQ FROM HIF (SEQ# = 0)
L.DPWS	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET POINTER TO MESSAGE BUFFER
	LB	R5,BBUFER+FID2LN+4,R4,	:GET SEQ#
	NHI	R5,3F			:LEAVE 6 BITS ONLY
	JE	L.DPWH			:JUMP IF SO

:SYS/RQ CAME IN RESPONSE FOR TIF'S SYS/RQ. IF IT IS NOT THE MOST
:CURRENT SYS/RQ DISCARD IT.
	LB	R6,LUCTAB+LULUW2,R9,	:GET WORK BYTE WITH SEQ#
	NHI	R6,LUSTSQ		:LEAVE SEQ# BITS ONLY
	AIS	R6,1			:SYS/RQ SEQ# IS 1 GREATER
	CR	R5,R6			:LATEST SYS/RQ?
	JN	L.DPCE			:DISCARD IF NOT

:IF THIS WAS THE LATEST SYS/RQ COMPARE THE LAST KNOWN SCREEN STATUS.
:ISSUE ONE EXTRA SYS/RQ IF TIF'S INFORMATION DOES NOT MATCH HIF.
	LB	R6,BBUFER+FID2LN+5,R4,	:GET SCREEN STATE FROM HIF
	LB	R5,LUCTAB+LUCSCN,R9,	:GET TIF'S SCREEN STATE
	XR	R6,R5			:MATCH THEM
	NHI	R6,LUSSCN		:LEAVE SCREEN STATE BITS ONLY
	JEFS	L.DPW1			:JUMP IF 
	NHI	R5,LUSSCN		:CURRENT SCREEN STATE IN TIF
	JAL	R4,L.GSRQ		:GENERATE SYS/RQ MSG TO HIF
	J	L.DPCE			:DISCARD SYS/RQ FROM HIF

:SYS/RQ CYCLE IS COMPLETE. ISSUE OUTSTANDING RSP'S FOR SSCP-LU AND LU-LU.
L.DPW1	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET POINTER TO LU-LU SCB
	JE	L.DPW4			:JUMP IF NO LU-LU
	LHL	R8,SCBBLK+SCTRNG,R7,	:GET CT GET POINTER
L.DPW2	LHL	R5,SCBBLK+SCTRNR,R7,	:GET CT RELEASE POINTER
	JE	L.DPW4			:JUMP IF ALL FINISHED
	JAL	R5,V.GNMU		:GENERATE MU FOR RSP
	LR	R10,R10			:MU GEGERATED?
	JE	L.DPW3			:JUMP IF NOT
	XR	R0,R0			:PREPARE FOR +RSP
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE BYTE
	NHI	R5,LUSSCN		:LEAVE STATE BITS ONLY
	CHI	R5,LUSAPL		:APPLICATION?
	JEFS	L.DPWX			:JUMP IF SO
	LHI	R0,LUBYSN		:OTHERWISE INDICATE LU BUSY
L.DPWX	JAL	R5,L.GNRP		:GENERATE RSP
	LHI	R2,DFCSND		:TO DFC.SEND
	LHI	R1,LUSEND		:FROM LU.SEND
	LIS	R0,SG.NOS		:GENERATE NO SIGNAL
	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	JAL	R8,SEND,,		:SEND RSP
	LM	R0,LURGSV,,		:RESTTORE ALL REGISTERS
L.DPW3	LHL	R8,CMDBLK+CLPTR,R8,	:GET NEXT CT GET POINTER
	J	L.DPW2			:JUMP TO CONTINUE
L.DPW4	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET POINTER TO SSCP-LU SCB
	LHL	R8,SCBBLK+SCTRNG,R7,	:GET CT GET POINTER
L.DPW5	LHL	R5,SCBBLK+SCTRNR,R7,	:GET CT RELEASE POINTER
	JE	L.DPW7			:JUMP IF ALL FINISHED
	JAL	R5,V.GNMU		:GENERATE MU FOR +RSP
	LR	R10,R10			:MU GENERATED?
	JE	L.DPW6			:JUMP IF NOT
	XR	R0,R0			:PREPARE FOR +RSP
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE BYTE
	NHI	R5,LUSSCN		:LEAVE STATE BITS ONLY
	CHI	R5,LUSAPL		:APPLICATION
	JNFS	L.DPWY			:JUMP IF NOT
	LHI	R0,LUBYSN		:OTHERWISE PREPARE FOR LU BUSY
L.DPWY	JAL	R5,L.GNRP		:GENERATE RSP
	LHI	R2,DFCSND		:TO DFC.SEND
	LHI	R1,LUSEND		:FROM LU.SEND
	LIS	R0,SG.NOS		:GENERATE NO SIGNAL
	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	JAL	R8,SEND,,		:SEND RSP
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
L.DPW6	LHL	R8,CMDBLK+CLPTR,R8,	:GET NEXT CT GET POINTER
	J	L.DPW5			:JUMP TO CONTINUE
L.DPW7	LB	R5,LUCTAB+LULUW2,R9,	:GET BYTE WITH SYS/RQ CONTROL
	NHI	R5,@LUSYRQ		:CLEAR SYS/RQ CYCLE
	STB	R5,LUCTAB+LULUW2,R9,	:UPDATE SYS/RQ CONTROL BYTE
	LB	R5,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	NHI	R5,@LUTDBR&@LUTDFL	:CLEAR PENDING SEND BITS
	OHI	R5,LUDPCL!LUDPER	:INDICATE CLEANING IN BOTH DIRECTIONS
	J	L.DPCE			:JUMP TO DISCARD SYS/RQ FROM HIF

:UNSOLICITED SYS/RQ FROM HIF. GENERATE BIND OR UNBIND.
L.DPWH	LB	R5,BBUFER+FID2LN+5,R4,	:GET SCREEN STATE BYTE
	NHI	R5,LUSSCN		:LEAVE SCREEN STATE BITS ONLY
	CHI	R5,LUSAPL		:APPLICATION?
	JN	L.DPWU			:JUMP TO ISSUE UNBIND IF NOT

:GENERATE BIND REPLACING GENNED PRESENTAION LAYER PARARMETERS WITH
:WHAT IS COMING FROM HIF.
	LR	R12,R8			:SAVE CMD LINK POINTER
	LHL	R8,LUCTAB+LUBNDP,R9,	:GET GENNED BIND POINTER
	LB	R0,PSEG+1,R8,		:GET BIND LENGTH
	AIS	R0,3			:ADJUST LENGTH FOR RH
	LA	R8,PSEG+1,R8,		:POINT TO BIND RU
	JAL	R5,L.SCRQ		:GENERATE CANNED BIND
	LHL	R5,CMDBLK+CLLNG,R12,	:GET WRITE STATUS LENGTH
	SIS	R5,FID2LN+6		:COMPARE WITH MINIMUM LENGTH
	JLE	L.DPWB			:JUMP IF NO BIND PARMS TO CHANGE
	LB	R5,BBUFER+FID2LN+6,R4,	:GET REMAINING LENGTH OF WS
	JEFS	L.DPWB			:JUMP IF NO MORE DATA
	BBLOAD	R3,BBUFER+MURUPT,R10,	:POINT TO BIND RU
L.DPWA	LB	R6,BBUFER+FID2LN+6,R4,R5	:GET NEXT BYTE WITH BIND PARMS
	STB	R6,BBUFER+SCPSUG-SCFMPF+2,R3,R5	:COPY INTO BIND
	SIS	R5,1			:DECREASE MSG COUNTER
	JGBS	L.DPWA			:CONTINUE TO COPY UNTIL FINISHED
L.DPWB	LHI	R0,NSSTAT^8!NSTDBD	:PREPARE TO REPLACE CMD
L.DPWE	LHI	R5,MU.DR1		:FORCE DEFINITE RESPONSE
	STB	R5,BBUFER+MURHF2,R10,	:UPDATE MUCB
	BBLOAD	R3,CMDBLK+CLARG,R12,	:GET POINTER TO WRITE ST MSG
	JAL	R5,R.PBBC,,		:RELEASE IT
	STH	R0,CMDBLK+CLCMD,R12,	:REPLACE CMD BY STATUS COMMAND
	XR	R0,R0			:CLEAR THE REGISTER
	STH	R0,CMDBLK+CLLNG,R12,	:NO ERROR RECOVERY
	BBSTOR	R0,CMDBLK+CLARG,R12,	:NO BUFFER POINTER
	LHI	R2,PMCSMS		:SEND TO CSC
	LHI	R1,LUSEND		:FROM LU.SEND
	LIS	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND IT
	JR	R14			:AND RETURN

:IGNORE WRITE STATUS IF SYSTEM, OTHERWISE SEND UNBIND.
L.DPWU	CHI	R5,LUSSYS		:SYSTEM?
	JEFS	L.DPWT			:JUMP IF SO
	LR	R12,R8			:COPY CMD LINK POINTER
	LA	R8,UBDCAN,,		:POINT TO CANNED UNBIND
	LHI	R0,UBDLGT+3		:LENGTH OF UNBIND
	JAL	R5,L.SCRQ		:GENERATE UNBIND
	LHI	R0,NSSTAT^8!NSTDUB	:PREPARE TO REPLACE CMD
	J	L.DPWE			:JUMP TO CONTINUE
L.DPWT	BBLOAD	R3,CMDBLK+CLARG,R8,	:GET POINTER TO WS MSG
	JAL	R5,R.PBBC,,		:RELEASE BUFFERLET WITH WS
	J	L.RMD0			:JUMP TO REMOVE CMD LINK

:::::::::::::::::::::::::::::::::
:: REMOVE PROCESSING ROUTINE IN DSP MODE.
:: IF SEND OPERATION WAS SUCCESSFUL THE CMD LINK IS REMOVED
:: FROM NIO->SNA DATA QUEUE IF CANCEL IS NOT PENDING.
:: IN THIS SPECAIL CASE THE LINK IS NOT REMOVED TO INDICATE
:: TO THE HIGH LEVEL SCHEDULER THAT LU.SEND MUST BE CALLED.
:
:: FIRST CHECK THAT SEND OPERATION WAS SUCCESSFUL.
L.RMDP	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE-CHECK BYTE
	GL	L.RMTF
	JN	L.RMTF			:JUMP IF NOT OK

:	(9/18/84/CHS)	DISCARD MUCB FIRST
	LR	R3,R10			:SET UP R3
	JAL	R4,PBB,,		:REALSE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
:	(9/18/84/CHS) END OF DISCARD MUCB INSERTION

:IF CANCEL IS PENDING DO NOT REMOVE CMD LINK.
	LB	R6,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R6,LULUCN		:IS CANCEL PENDING?
	JNR	R14			:RETURN IF SO

:CHECK IF THIS IS NOTIFICATION FOR A SERVICE MESSAGE GENERATED
:AS A RESULT OF STATUS COMMAND.
	LHL	R6,LUCTAB+LUSNDG,R9,	:GET NTW->SNA GET PTR
	LB	R5,CMDBLK+CLCMD,R6,	:GET NTW->SNA COMMAND CODE
	CHI	R5,NSSTAT		:STATUS COMMAND?
	JE	L.RMDE			:JUMP IF NOT

:FOR END-TO-END MESSAGE IN DSP MODE AN EXTRA DUMMY EB-RU MAY BE GENERATED
	CHI	R5,NSETEM		:END-TO-END MESSAGE?
	JN	L.RMD0			:JUMP IF NOT
	LB	R4,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	THI	R4,LUTDBR		:BRACKET TERMINATION PENDING?
	JE	L.RMD0			:JUMP IF NOT
	LB	R5,CMDBLK+CLCMDS,R6,	:GET NTW->SNA SUBCOMMAND CODE
	THI	R5,NSDTFC!NSDTFS	:LAST SEGM OF LAST IN CHAIN?
	JN	L.RMD0			:JUMP IF NOT
	NHI	R4,@LUTDBR		:RESET PENDING BRACKET TERMINATION
	STB	R4,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE BYTE
	LHL	R5,CMDBLK+CLPTR,R6,	:GET POINTER TO NEXT CMD LINK
	LHL	R4,LUCTAB+LUSNDR,R9,	:GET RELEASE POINTER
	CR	R5,R4			:MORE DATA?
	JEFS	L.RMDN			:JUMP IF SO
	LB	R5,CMDBLK+CLCMD,R5,	:GET NEXT COMMAND CODE
	CHI	R5,NSETEM		:NEXT DATA ALREADY THERE?
	JE	L.RMD0			:REMOVE CURRENT CMD LINK
L.RMDN	LHI	R5,NSDTCD		:FAKE CHANGE DIRECTION FROM NIO
	STB	R5,CMDBLK+CLCMDS,R6,	:UPDATE SUBCOMMAND
	LHI	R5,FID2LN+3		:GET LENGTH OF DUMMY RU
	STH	R5,CMDBLK+CLLNG,R6,	:UPDATE CMD LENGTH FIELD
	LR	R9,R6			:SAVE THE REGISTER
	JAL	R4,GBB,,		:GET A BUFFER FOR DUMMY RU
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	BBSTOR	R3,CMDBLK+CLARG,R9,	:SAVE BUFFER POINTER
	JR	R14			:AND RETURN

:IF SUBCOMMAND WAS FOR BID REMOVE THE COMMAND LINK.
L.RMDE	LB	R5,CMDBLK+CLCMDS,R6,	:GET NTW->SNA SUBCOMMAND CODE
	CHI	R5,NSTDBI		:BID SUBCOMMAND?
	JE	L.RMD0			:JUMP TO REMOVE THE LINK OF SO

:INCREASE THE SUBCOMMAND BY 1 TO PREPARE FOR THE NEXT SERVICE MESSAGE.
	AIS	R5,1			:INCREASE THE SUBCOMMAND
	STB	R5,CMDBLK+CLCMDS,R6,	:UPDATE SUBCOMMAND IN CMD LINK

:IF ERROR RECOVERY IS INDICATED IN THE LENGTH FIELD OF CMD LINK
:THE LAST SUBCOMMAND IS TO SEND ERROR TO NIO, OTHERWISE IT IS SDT.
	LIS	R4,NSTDNE+1		:PREPARE TO FINISH AT ERROR
	LHL	R6,CMDBLK+CLLNG,R6,	:GET ERROR INDICATOR
	JNFS	L.RMD1			:JUMP IF ERROR RECOVERY
	SIS	R4,1			:OTHERWISE FINISH WITH SDT
L.RMD1	CR	R4,R5			:TIME TO FINISH?
	JNR	R14			:RETURN IF NOT

:REMOVE CMD FROM NTW->SNA DATA QUEUE.
L.RMD0	LHL	R6,LUCTAB+LUSNDG,R9,	:GET NTW->SNA GET PTR
	LHL	R5,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK
	JE	L.CLER			:ERROR IF NO NEXT LINK
	STH	R5,LUCTAB+LUSNDG,R9,	:UPDATE NTW->SNA GET PTR
	JAL	R4,RELCL,,		:RELEASE THE LINK
	LHL	R4,LUCTAB+LUSNDR,R9,	:GET REL PTR
	CR	R5,R4			:COMPARE GET AND REL PTR
	JNR	R14			:RETURN IF NOT THE LAST
	LHL	R4,LUCTAB+LUCT.N,R9,	:GET REL LU #
	RBT	R4,DPNWSN,,		:RESET DATA PRESENT
	JR	R14			:AND RETURN

	FO	SNTPKG

	EI				:END OF REMOVE ROUTINES FOR DSP HOST

	FO	MAIN	
	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER
	FO	SNAPKG

	EM
 	MO	.,SNTPKG

	LO	SNAPKG
	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::								      ::
:: THIS MODULE CONTAINS THE CODE TO SUPPORT THE RECEIVING SIDE OF THE ::
:: VIRTUAL TERMINAL INTERFACE LU SEVICE MANAGER DSP MODE.	      ::
:: 								      ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	IF	VTISUP

	SEG	A.CODE

:
:DISTINGUISH THE MESSAGES THAT COME FROM TERMINAL FROM THE NOTIFICATIONS
:THAT COME FROM LOWER SNA LAYER FOR PREVIOUSLY SENT REQUESTS OR RESPONSES.
:
L.RCDP	LB	R5,BBUFER+MUDIRE,R10,	:GET MU DIRECTION
	CHI	R5,SENT			:IS IT NOTIFICATION?
	JE	L.RDNT,,		:JUMP IF SO
:
:BEGIN (06/17/86 YLH)
:
:IF EXCEPTIONAL REQUEST RECEIVED, THE WHOLE CHAIN IS DISCARDED.
:THE 1ST BIT OF THE DSP SUBSTATE (THE 4TH BIT OF THE LU SERVICE
:MANAGER STATE BYTE) IS THE EXCEPTIONAL REQUEST RECEIVED INDICATOR.
:
	LB	R5,LUCTAB+LULUWK,R9,	:GET LU_SVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:GOT SOMETHING, NO TIMEOUT
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LU_SVC WORK BYTE
	LB	R5,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	THI	R5,LUDPER		:EXCEPTIONAL REQUEST RECEIVED?
	JE	L.RCD1			:NO, CONTINUE
	LB	R5,BBUFER+MUBIUF,R10,	:YES, GET 1ST BYTE OF THE TH
	THI	R5,MU.BIU		:1ST SEGMENT OF A NEW CHAIN?
	JE	L.RCDD			:NO, DISCARD IT
	LB	R5,BBUFER+MURHF1,R10,	:YES, GET 1ST BYTE OF THE RH
	THI	R5,MU.CTG		:ONLY FMD RU_CTGY IS INTERESTED
	JN	L.RCD1
	THI	R5,MU.BCI		:BEGINNING OF A CHAIN?
	JE	L.RCDD			:NO, DISCARD IT
	LB	R5,LUCTAB+LULUST,R9,	:YES, CLEAR THE EXR INDICATOR
	NHI	R5,@LUDPER
	STB	R5,LUCTAB+LULUST,R9,	:STORE BACK TO THE LU_SVC BYTE
L.RCD1	EQ	.			:AND CONTINUE
:
:END (06/17/86 YLH)
:
:ASSUMPTION IS MADE THAT ONLY FMD CAN HAVE MULTISEGMENT MESSAGES.
:UPON RECEIPT OF THE LAST SEGMENT MESSAGE, THE LU SERVICE MANAGER MAY
:GENERATE A REPSONSE (AS INDICATED IN RH HEADER AND REFLECTED IN LUSVC
:WORK BYTE BY PENDING REPSONSE BITS) AND SEND IT BACK AS NEEDED.
:
:FIRST CHECK IF THE RECEIVED MESSAGE COMES IN 1ST SEGMENT.
:
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.BIU		:IS IT 1ST SEGMENT?
	JN	V.RCDF			:JUMP IF SO
:
:NOT A FIRST SEGMENT MESSAGE.
:FURTHER DIFFERENTIATE AN INTERMEDIATE SEGMENT MESSAGE FROM A LAST SEGMENT
:MESSAGE.
:
	XR	R4,R4			:PREPARE FOR NO RESPONSE
	THI	R5,MU.EIU		:IS IT THE LAST SEGMENT?
	JN	L.RCDL			:JUMP IF SO
:
:FOR AN INTERMEDIATE SEGMENT MESSAGE.
:  IF THE TIF IS CONFIGURED WITH A NON-SNA HIF (SYSTEM REQUEST KEY IS NOT
:  SUPPORTED), DISCARD ANY INTERMEDIATE SEGMENT SSCP_LU MESSAGE.  AN LU_LU
:  MESSAGE IS PASSED TO NIO WITH SEGMENTATION, CHAINING, AND CHANGE DIRECTION
:  INFORMATION SET IN SNA->NIO SUBCOMMAND.
:
:  IF THE TIF IS CONFIGURED WITH AN SNA HIF (SYSTEM REQUEST KEY IS SUPPORTED),
:  FURTHER CHECKINGS ARE REQUIRED TO ENSURE THE SCREEN OWNERSHIP SESSION'S
:  SYNCHRONIZATION BETWEEN THE TERMINAL AND THE TIF AND WHETHER THE TIF AND
:  HIF ARE IN SYS/RQ CYCLE (SYSTEM REQUEST KEY HAS BEEN SENT TO THE HIF AND
:  YET RECEIVED ANY RESPONSE).  IF THE TIF AND HIF ARE OUT OF SYNC, AN SYS/RQ
:  COMMAND IS PASSED TO THE NIO AND THE PROCESSED MESSAGES ARE QUEUED ON
:  THE SNA->NIO DATA_Q WITHOUT RELEASING ITS POINTER UNTIL THE TIF AND HIF
:  BACK IN SYNC.  IF THE TIF AND HIF ARE IN SYNC, DEPENDING ON THE EXISTENCE
:  OF THE LU_LU SESSION, AN SSCP_LU MESSAGE IS CONVERTED TO A 3270 DATA
:  MESSAGE OR DISCARDED.  A CONVERTED SSCP_LU MESSAGE IS SENT TO THE NIO
:  WITH THE SEGMENTATION, CHAINING, AND CHANGE DIRECTION INFORMATION SET IN
:  THE SNA->NIO SUBCOMMAND JUST LIKE AN LU_LU MESSAGE IS HANDLED.
:
	LB	R0,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS BYTE
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGIN ADDR
	JE	L.RCD3			:JUMP IF SSCP_LU
:
:LU_LU INTERMEDIATE SEGMENT MESSAGE.
:
	THI	R0,LUSCRN		:IS IT CONFIGURED WITH SNA HIF?
	JE	L.RCD2			:JUMP IF NON-SNA HIF
	JAL	R4,L.CSYN,,		:IF SNA HIF, CHECK IN SYNC
L.RCD2	XR	R4,R4			:NO RESPONSE NEEDED
	LIS	R0,SNDTIS		:INDICATE INTERMEDIATE SEGMENT MSG.
	J	V.RDFA			:AND CONTINUE
:
:SSCP_LU INTERMEDIATE SEGMENT MESSAGE.
:
L.RCD3	THI	R0,LUSCRN		:IS IT CONFIGURED WITH SNA HIF?
	JE	L.RCDD			:DISCARD SSCP_LU MSG IF NON-SNA HIF
	JAL	R4,L.CSYN,,		:CHECK SYNCHRONIZATION
	JAL	R5,L.CVRT,,		:CONVERT THE MESSAGE TO 3270
	XR	R4,R4			:NO RESPONSE NEEDED
	LIS	R0,SNDTIS		:INDICATE INTERMEDIATE SEGMENT
	J	V.RDFA			:JUMP TO CONTINUE

:
:FOR A LAST BUT NOT FIRST SEGMENT MESSAGE.
:  THE 1ST 2 BYTES OF THE RH HEADER ARE SAVED INTO MUCB.  ISSUE A RESPONSE IF
:  IT IS REQUIRED (RESPONSE INFORMATION ARE KEPT IN LU SVC WORK BYTE).
:
:  IF THE TIF IS CONFIGURED WITH A NON-SNA HIF (SYSTEM REQUEST KEY IS NOT
:  SUPPORTED), DISCARD ANY LAST SEGMENT SSCP_LU MESSAGE.  AN LU_LU MESSAGE IS
:  PASSED TO NIO WITH SEGMENTATION, CHAINING, AND CHANGE DIRECTION INFORMATION SET
:  SET IN SNA->NIO SUBCOMMAND.
:
:  IF THE TIF IS CONFIGURED WITH AN SNA HIF (SYSTEM REQUEST KEY IS SUPPORTED),
:  FURTHER CHECKINGS ARE REQUIRED TO ENSURE THE SCREEN OWNERSHIP SESSION'S
:  SYNCHRONIZATION BETWEEN THE TERMINAL AND THE TIF AND WHETHER THE TIF AND
:  HIF ARE IN SYS/RQ CYCLE (SYSTEM REQUEST KEY HAS BEEN SENT TO THE HIF AND
:  YET RECEIVED ANY RESPONSE).  IF THE TIF AND HIF ARE OUT OF SYNC, AN SYS/RQ
:  COMMAND IS PASSED TO THE NIO AND THE PROCESSED MESSAGES ARE QUEUED ON
:  THE SNA->NIO DATA_Q WITHOUT RELEASING ITS POINTER UNTIL THE TIF AND HIF
:  BACK IN SYNC.  IF THE TIF AND HIF ARE IN SYNC, DEPENDING ON THE EXISTENCE
:  OF THE LU_LU SESSION, AN SSCP_LU MESSAGE IS CONVERTED TO A 3270 DATA
:  MESSAGE OR DISCARDED.  A CONVERTED SSCP_LU MESSAGE IS SENT TO THE NIO
:  WITH THE SEGMENTATION, CHAINING, AND CHANGE DIRECTION INFORMATION SET IN
:  THE SNA->NIO SUBCOMMAND JUST LIKE AN LU_LU MESSAGE IS HANDLED.
:
L.RCDL	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB PTR
	LHL	R8,SCBBLK+SCTRNG,R7,	:GET CT TABLE GET PTR
	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET PTR TO BUF WITH CT
	LB	R5,BBUFER+CLARG5+1,R4,	:GET THE RU'S RH2
	NHI	R5,MU.DR1!MU.DR2!MU.QRI	:LEAVE DR1, DR2, AND QRI ONLY
	STB	R5,BBUFER+MURHF2,R10,	:PUT IT IN MUCB
	LB	R5,BBUFER+CLARG6,R4,	:GET THE RU CATEGORY
	NHI	R5,MU.CTG
	STB	R5,BBUFER+MURHF1,R10,	:STORE IT IN MUCB
	LB	R0,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS BYTE
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGIN ADDR
	JN	L.RCD5			:JUMP IF LU_LU SESSION MESSAGE
:
:SSCP_LU LAST SEGMENT MESSAGE.
:
	THI	R0,LUSCRN		:IS IT CONFIGURED WITH SNA HIF?
	JE	L.RCDD			:IF NON-SNA HIF, DSICARD MSG.
	JAL	R4,L.CSYN,,		:IF SNA HIF, CHECK SYNC.
	JAL	R5,L.CVRT,,		:CONVERT MSG TO 3270
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULURP&@LULUNG	:CLEAR PENDING RSP BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R4,LULURP		:PREPARE FOR +RSP
	J	V.RDFA			:JUMP TO CONTINUE
:
:LU_LU SESSION LAST SEGMENT MESSAGE.
:
L.RCD5	THI	R0,LUSCRN		:IS IT CONFIGURED WITH SNA HIF?
	JE	L.RCD6			:JUMP IF NON-SNA HIF
	JAL	R4,L.CSYN,,		:IF SNA HIF, CHECK IN SYNC
:
L.RCD6	LIS	R0,SNDTLS		:INDICATE LAST SEGMENT(8/16/84/CHS)
	LB	R4,LUCTAB+LULUWK,R9,	:GET LU_SVC WORK BYTE
	LR	R3,R4			:COPY LU_SVC WORK BYTE
	NHI	R4,LULURP!LULUNG	:LEAVE RSP BITS ONLY
	NHI	R3,@LULURP&@LULUNG	:CLEAR PENDING RSP BITS
	STB	R3,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	V.RDFA			:JUMP TO CONTINUE
:
:DISCARD THE RECEIVED MSG AND THE MUCB
:
L.RCDD	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG SEGMENT
	JAL	R5,R.PBRC,,		:RELEASE BUF CHAIN
	LR	R3,R10			:COPY PTR TO MUCB
	JAL	R4,PBB,,		:RELEASE BUF WITH MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:
:CODE EXECUTION ENTERS HERE WHEN A FIRST SEGMENT MESSAGE IS RECEIVED.
:IF THE TIF IS CONFIGURED WITH AN SNA HIF, SYNCHRONIZATOIN AND SYS/RQ
:CYCLE SHOULD BE HANDLED.
:DEPENDING ON THE RU CATEGORY, MESSAGES ARE HANDLED DIFFERENTLY.
:
V.RCDF	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RSP?
	JN	L.RCD7			:JUMP IF SO
:
:FOR EXCEPTION REQUEST, REPLY WITH -RSP.
:
	THI	R5,MU.SDI		:SENSE-DATA INCLUDED?
	JE	L.RCD7			:JUMP IF NOT
	LB	R5,LUCTAB+LULUST,R9,	:FOR EXCEPTIONAL REQUEST  (06/17/86 YLH)
	OHI	R5,LUDPER		:SET THE EXR BIT IN (06/17/86 YLH)
	STB	R5,LUCTAB+LULUST,R9,	:LU_SVC (06/17/86 YLH)
:	LB	R5,BBUFER+MURUPT,R10,	:GET RU POINTER(9/13/84/CHS)
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER(9/13/84/CHS)
	LB	R1,BBUFER,R5,		:GET RU CODE
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE CODE
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU POINTER
	JAL	R5,R.PBRC,,		:RELEASE BUFFER WITH BTU
	J	V.RDFE			:JUMP TO CONTINUE

L.RCD7	NHI	R5,MU.CTG		:GET RU CATEGORY
	SRLS	R5,4			:MAKE A HALF-WORD INDEX
	LHL	R5,V.RDPT,R5		:GET PTR TO PROCESSING ROUTINE
	J	L.BASE,R5		:VECTOR EXECUTION

:TABLE OF PROCESSING ROUTINES DEPENDING ON RU CATEGORY
V.RDPT	HC	V.RDFM-L.BASE		:PTR TO FMD PROC ROUTINE
	HC	V.RDNC-L.BASE		:PTR TO NC PROC ROUTINE
	HC	V.RDDF-L.BASE		:PTR TO DFC PROC ROUTINE
	HC	V.RDSC-L.BASE		:PTR TO SC PROC ROUTINE

:
:FMD 1ST SEGMENT MESSAGE PROCESSING ROUTINE.
:  FIRST SEPARATE REQUEST FROM RESPONSE.
:
V.RDFM	LB	R1,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R1,MU.RRI		:IS IT A RESPONSE?
	JN	V.RDRP			:JUMP IF SO
:
:FMD REQUEST.
:  IF THE TIF IS CONFIGURED WITH A NON-SNA HIF (SYSTEM REQUEST KEY IS NOT
:  SUPPORTED), AN SSCP_LU MESSAGE IS AN ERROR AND ERROR PROCEDURE SHOULD
:  BE PERFORMED.  AN LU_LU MESSAGE IS PASSED TO NIO WITH SEGMENTATION,
:  CHAINING, AND CHANGE DIRECTION INFORMATION SET IN SNA->NIO SUBCOMMAND.
:
:  IF THE TIF IS CONFIGURED WITH AN SNA HIF (SYSTEM REQUEST KEY IS SUPPORTED),
:  FURTHER CHECKINGS ARE REQUIRED TO ENSURE THE SCREEN OWNERSHIP SESSION'S
:  SYNCHRONIZATION BETWEEN THE TERMINAL AND THE TIF AND WHETHER THE TIF AND
:  HIF ARE IN SYS/RQ CYCLE (SYSTEM REQUEST KEY HAS BEEN SENT TO THE HIF AND
:  YET RECEIVED ANY RESPONSE).  IF THE TIF AND HIF ARE OUT OF SYNC, AN SYS/RQ
:  COMMAND IS PASSED TO THE NIO AND THE PROCESSED MESSAGES ARE QUEUED ON
:  THE SNA->NIO DATA_Q WITHOUT RELEASING ITS POINTER UNTIL THE TIF AND HIF
:  BACK IN SYNC.  IF THE TIF AND HIF ARE IN SYNC, DEPENDING ON THE EXISTENCE
:  OF THE LU_LU SESSION, AN SSCP_LU MESSAGE IS CONVERTED TO A 3270 DATA
:  MESSAGE OR DISCARDED.  A CONVERTED SSCP_LU MESSAGE IS SENT TO THE NIO
:  WITH THE SEGMENTATION, CHAINING, AND CHANGE DIRECTION INFORMATION SET IN
:  THE SNA->NIO SUBCOMMAND JUST LIKE AN LU_LU MESSAGE IS HANDLED.
:
:SEPARATE AN SSCP_LU MESSAGE FROM AN LU_LU MESSAGE
:
	LB	R0,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS
	LB	R1,BBUFER+MUDADP,R10,	:GET DEST ADDR
	JN	V.RDF2			:JUMP IF LU_LU MSG
:
:SSCP-LU MESSAGE HAS TO BE SCANNED FOR NSM COMMAND.
:PREPRARE POINTERS FOR SCANNING DATA MESSAGE FOR SERVICE SCREEN
:REQUEST.
:
	LHL	R6,LUCTAB+LUCT.N,R9,	:GET REL LU # FOR INTERFACE
	LHI	R4,NSMLEN		:GET LENGTH OF SCAN PTR TBL
	MHR	R6,R4			:PTR TO NSMTBL IN R6
	BBLOAD	R4,BBUFER+MURUPT,R10,	:GET RU PTR
	LHL	R7,NSMTBL+NSMKAE,R6,	:GET TYPE CMD STRING
	LHL	R6,NSMTBL+NSMKWD,R6,	:GET PTR TO COMMAND STRING
	LHL	R5,PSEG,R6,		:GET COMMAND WORD LENGTH
V.RDT6	LB	R0,PSEG+1,R6,R5		:GET NEXT BYTE (FROM END)
	LB	R1,BBUFER-1,R4,R5	:GET IT FROM MSG
	LR	R7,R7			:IF NOT ASCII, NO CONVERSION
	JNFS	V.RDTW			:SKIP
	LB	R1,BCDASC,R1,		:CONVERT TO ASCII
V.RDTW
	XR	R0,R1			:COMPARE THEM
	NHI	R0,5F			:MASK UPPER-LOWER CASE AND PARITY
	JNFS	V.RDTE			:JUMP IF NO MATCH
	SIS	R5,1			:OTHERWISE CONTINUE
	JG	V.RDT6			:TO LOOP UNTIL BEGINNING
:
:REQUEST FOR SERVICE SCREEN WAS FOUND. NOTIFY NIO.
:
	LHI	R0,SNRQLG^8		:PREPARE REQUEST LOGON CMD
	JAL	R5,L.PTCD,,		:SHIP IT TO NIO
	JFS	V.RDTF			:JUMP TO CONTINUE

V.RDTE	XR	R0,R0			:INDICATE NO MATCH
	
:FMD 1ST SEGMENT SSCP_LU MESSAGE PROCESSING HANDLER.
:  FIND THE HIF THAT THE TIF IS CONFIGURED WITH.
:
V.RDTF	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN CONTROL BYTE
	THI	R5,LUSCRN		:IS IT CONFIGURED WITH SNA HIF?
	JN	V.RDFS			:JUMP IF SNA HIF
:
:FOR NON-SNA HIF, AN SSCP_LU MESSAGE IS NOT SUPPOSED TO OCCUR
:IF IT IS NOT NSM COMMAND. CHECK IF NSM COMMAND, IF NOT
:  SEND ERROR MESSAGE TO THE TERMINAL IF NO LU_LU SESSION.
:  UNBIND THE LU_LU SESSION THEN BIND IT AGAIN IF LU_LU SESSOIN EXISTS.
:
:
:INSERT UNBIND STATUS COMMAND AT THE BEGINNING OF THE NIO->SNA DATA_Q.
:
	LHL	R5,LUCTAB+LULSCB,R9,	:IS LU_LU SESSION EXIST?
	JEFS	V.RDF0			:JUMP IF NOT
	LR	R0,R0			:CHECK IF NSM
	JNFS	V.RDF0			:JUMP IF SO
	LHI	R0,NSSTAT^8!NSTDUB	:UNBIND STATUS COMMAND
	LIS	R1,SNERRD+1		:REQUEST TO RE-DISPLAY
	ST	R10,LURGSV,,		:SAVE THE REGISTER
	JAL	R10,L.NSST		:QUEUE ERROR RECOVERY REQUEST
	L	R10,LURGSV,,		:RESTORE THE REGISTER
V.RDF0	BBLOAD	R3,BBUFER+MUCBTU,R10,	:DISCARD THE MESSAGE
	JAL	R5,R.PBRC,,		:RELEASE BUF CHAIN
	XR	R0,R0			:PREPARE FOR +RSP
	J	V.RDFD			:JUMP TO SEND +RSP

:
:SSCP_LU 1ST SEGMENT MESSAGE AND CONFIGURED WITH AN SNA HIF
:
:  CONVERT THE MESSAGE TO 3270 DATA STREAM IF NECESSARY
:  PREAPRE CHANGE DIRECTION INDICATOR IN R0 IF THIS IS AN END OF CHAIN MSG
:  PREPARE RESPONSE INDICATOR IN R4 FOR LAST SEGMENT MESSAGE.
:
V.RDFS	JAL	R4,L.CSYN,,		:CHECK SYNC.
	JAL	R5,L.CVRT,,		:CONVERT TO 3270
	XR	R4,R4			:PREPARE FOR NO RESPONSE
	XR	R0,R0			:PREPARE FOR NO CD
	LB	R6,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R6,MU.ECI		:END OF CHAIN?
	JEFS	V.RDF1			:JUMP IF NOT
	LHI	R0,SNDTCD		:PREPARE CHANGE DIRECTION
V.RDF1	THI	R1,MU.EIU		:IS IT THE LAST SEGMENT?
	JE	V.RDF7			:NO RSP IF SO
	LIS	R4,LULURP		:PREPARE FOR +RSP
	J	V.RDF7			:JUMP TO CONTINUE

:
:FMD 1ST SEGMENT LU_LU MESSAGE PROCESSING HANDLER.
:  DETERMINE THE TYPE OF HIF THAT THE TIF IS CONFIGURED WITH
:  IF SNA HIF, SYNCHRONIZATION AND SYS/RQ CYCLE NEED TO BE CONSIDERED
:  ADJUST SEQUENCE NUMBER IN RECEIVE DIRECTION.
:
V.RDF2	THI	R0,LUSCRN		:IS IT CONFIGURED WITH SNA HIF?
	JE	V.RDF3			:JUMP IF NON-SNA HIF
	JAL	R4,L.CSYN,,		:IF SNA HIF, CHECK SYNC.
V.RDF3	LIS	R7,0
	STB	R7,LUCTAB+LULUW3,R9,	:CLEAR LULUW3(6/25/85/CHS)
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU_LU SCB PTR(6/25/85/CHS)
	LCS	R5,1			:PREPARE -1
	AHM	R5,SCBBLK+SCADJR,R7,	:ADJUST THE SEQ #
:
:PREPARE RESPONSE TYPE IN R4 AND LULUWK.
:  +RSP IF EITHER OF THE DEFINITE RESPONSE BITS IS SET IN RH2.
:  PUT RESPONSE INDICATOR IN R4 ONLY FOR THE LAST SEGMENT MSG.
:
	LB	R4,LUCTAB+LULUWK,R9,	:GET PREVIOUS LUCB WORK BYTE
	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R5,MU.DR1!MU.DR2	:IS IT DEFIN RSP CHAIN?
	JE	V.RDF4			:JUMP IF NOT
	THI	R5,MU.ERI		:EXP RSP CHAIN?
	JNFS	V.RDF4			:JUMP IF SO
	OHI	R4,LULURP		:PREPARE FOR +RSP
	STB	R4,LUCTAB+LULUWK,R9,	:UPDATE THE LUCB WORK BYTE
V.RDF4	NHI	R4,LULURP!LULUNG	:CLEAR EVERYTHING BUT RSP INFO.
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:LAST SEGMENT?
	JNFS	V.RDF5			:JUMP IF SO
	XR	R4,R4			:NO RSP IF NOT LAST SEGMENT
:
:PREPARE THE CHANGE DIRECTION INDICATOR FOR THE NIO.
:  CHANGE DIRECTION INDICATOR IS SET WHENEVER THE END BRACKET OR
:  CHANGE DIRECTION BIT IN RH3 IS SET.
:
V.RDF5	XR	R0,R0			:INIT THE SNA->NIO SUBCMD
	LB	R3,LUCTAB+LULUW2,R9,	:GET BYTE WITH RECEIVE CD
	NHI	R3,@LUTDCD		:CLEAR CD INDICATOR IN LUCB WORK BYTE
	LB	R6,BBUFER+MURHF1,R10,	:GET RH1
	THI	R6,MU.ECI		:END OF CHAIN?
	JE	V.RDF6			:NO, NO CHANGE DIRECTION
	LB	R6,BBUFER+MURHF3,R10,	:GET RH3
	THI	R6,MU.EBI!MU.CDI	:END OF BRACKET OR CD?
	JEFS	V.RDF6			:JUMP IF NOT
	LHI	R0,SNDTCD		:SHOW CD IN SNA->NIO SUBCOMMAND
	OHI	R3,LUTDCD		:INDICATE CHANGE DIRECTION
V.RDF6	STB	R3,LUCTAB+LULUW2,R9,	:UPDATE LUCB WORK BYTE
:
:DISCARD THE DUMMY RU (RU CONTAINS RH ONLY) THAT HAS NO SEGMENTATION,
:CHAINING, OR CHANGE DIRECTION INFORMATION TO BE PASSED TO NIO.
:
V.RDF7	LB	R6,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	NHI	R6,MU.BIU!MU.EIU	:LEAVE SEGMENTATION INFO IN R6
	LB	R3,BBUFER+MURHF1,R10,	:GET RH1
	NHI	R3,MU.BCI!MU.ECI	:LEAVE CHAINING INFO IN R3
	LHL	R5,BBUFER+MUDCF,R10,	:GET DATA COUNT FIELD
	SIS	R5,3			:SUBTRACT RH LENGTH
	JG	V.RDF9			:JUMP IF DATA THERE
	CHI	R6,MU.BIU!MU.EIU	:ONLY SEGMENT?
	JN	V.RDF9			:JUMP IF NOT
	LR	R3,R3			:INTERMEDIATE CHAIN ELE?
	JE	V.RDF8			:YES, DISCARD IT
	CHI	R3,MU.BCI!MU.ECI	:NO, ONLY CHAIN?
	JN	V.RDF9			:JUMP IF NOT
	LB	R5,LUCTAB+LUBPSG,R9,	:ETX ONLY IS GENERATED BY DSP NIO?
	JEFS	V.RDF8			:JUMP IF SO
	LB	R5,BBUFER+MURHF3,R10,	:GET RH3
	THI	R5,MU.EBI!MU.CDI	:ANY CHANGE DIRECTION INFO THERE?
	JNFS	V.RDF9			:JUMP IF SO
V.RDF8	LR	R8,R4			:OTHERWISE SAVE RSP TYPE
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU POINTER
	JAL	R5,R.PBRC,,		:RELEASE THE MESSAGE
	J	V.RDFC			:JUMP TO CONTINUE
:
:PREPARE CHAINING AND SEGMENTATION FOR SNA->NIO SUBCOMMAND.
:COMBINED WITH CHANGE DIRECTION INDICATOR AND SAVED IN R0.
:  R3 HAS SEGMENTATION INFO. AND R6 HAS CHAINING INFO.
:
V.RDF9	SLLS	R3,2			:PUT CHAINING INFO IN RIGHT PLACE
	SRLS	R6,2			:PUT SEG INFO IN RIGHT PLACE
	OR	R3,R6			:COMBINE CHAIN AND SEG INFO
	XHI	R3,SNDTIC!SNDTIS	:INVERT CHAIN AND SEG INFO
	OR	R0,R3			:COMPLETE SUBCOMMAND BYTE
:
:THE DATA MESSAGE IS PASSED TO NIO AS END-TO-END DATA MESSAGE.
:  IF IN SYS/RQ CYCLE, QUEUE THE DATA TO SNA->NIO DATA_Q WITHOUT
:  RELEASING IT.
:
V.RDFA	OHI	R0,SNETEM^8		:PREPARE E-T-E MSG CMD
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG BUFFER
	LIS	R2,FID2LG		:GET LENGTH OF TH HEADER
	AH	R2,BBUFER+MUDCF,R10,	:OVERALL LENGTH OF MSG
	LR	R8,R4			:SAVE THE RESPONSE INFO.
	JAL	R5,L.PTCD		:NO, SHIP CMD TO NIO
:
:IF NO RESPONSE IS NEEDED, RELEASE MUCB.
:
V.RDFC	LR	R5,R8			:COPY THE RESPONSE INFO.
	THI	R5,LULURP		:ANY RESPONSE NEEDED?
	JE	V.RDFE			:NO, DISCARD THE MUCB
	LB	R0,LUCTAB+LULUW2,R9,	:GET SYS/RQ STATUS
	THI	R0,LUSYRQ		:IN SYS/RQ CYCLE
	JN	V.RDFE			:NO RSP IF SO
:
:GENERATE SENSE CODE AND SAVE IT IN R0 (0 FOR +RSP).
:R5 CONTAINS THE RESPONSE INFORMATION.
:
	XR	R0,R0			:INIT SENSE CODE TO 0 (+RSP)
	THI	R5,LULUNG		:IS IT -RSP?
	JE	V.RDFD			:JUMP IF NOT
	LHI	R0,LUONSN		:-RSP: 'PRESENTATION SPACE LOST'
:
:GENERATE RESPONSE AND SEND IT TO DFC.SEND.
:
V.RDFD	JAL	R5,L.GNRP		:GENERATE RESPONSE
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUCB WORK BYTE
	NHI	R5,@LULURP&@LULUNG	:CLEAR RESPONSE TYPE BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUCB WORK BYTE
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND THE RESPONSE
	JR	R14			:AND RETURN
:
:NO RESPONSE IS NEEDED FOR THIS REQUEST
:DISCARD THE MUCB
:
V.RDFE	LR	R3,R10			:OTHERWISE COPY MUCB POINTER
	JAL	R4,PBB,,		:RELEASE MUCB BUFFER
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
: 	VIRTUAL TIF FMD RESPONSE PROCESSING HANDLER.			:
:									:
:	SEND AN END-TO-END ACK. MESSAGE TO THE NIO IF NEEDED.		:
:	FOR NEGATIVE RESPONSE, IF THE SENSE CODE INDICATES LU BUSY,	:
:	IT IS TREATED AS THE SYS/RQ KEY HAS BEEN ENTERED.  OTHERWISE,	:
:	A CANCEL REQUEST IS SENT TO THE TERMINAL.  THE RESPONSE AND THE :
:	MUCB ARE THEN DISCARDED.					:
:	FOR POSITIVE RESPONSE, NOTHING NEEDS TO BE PROCESSED.  THE	:
:	RESPONSE ITSELF AND THE MUCB ARE DISCARDED.			:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	SEG	A.DATA
BSNTBL	HC	01,00
	SEG	A.CODE
:
V.RDRP	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R5,MU.RTI		:IS IT +RSP?
	JE	V.RDP2			:JUMP IF +RSP
:
:FMD -RSP RECEIVED
:  IF THE -RSP INDICATES LU BUSY (SYS/RQ KEY HAS BEEN ENTERED), THEN THE
:  SNA HIF SHOULD BE NOTIFIED AND THE SYS/RQ CYCLE BE ENTERED.
:  FOR ALL OTHER -RSP, A CANCEL SHOULD BE SENT ONLY ON LU_LU SESSION AND
:  THE CHAIN-SEND FSM IS AT BETWEEN CHAINS.
:
	LHL	R2,BBUFER+MURHSN,R10,	:GET 1ST 2 BYTES OF THE SENSE CODE
	LB	R0,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS
	THI	R0,LUSCRN		:SNA HIF?
	JE	V.RDP1			:NO
	CLHI	R2,LUBYSN		:LU BUSY?
	JN	V.RDP1			:NO, CONTINUE
	LR	R5,R0			:COPY SCREEN STATE BYTE
	NHI	R0,@LUSSCN		:CLEAN THE SCRN STATUS
	NHI	R5,LUSSCN		:LEAVE SCREEN STATUS ONLY
	CHI	R5,LUSUNW		:UNOWNED?
	JE	V.RDP2			:JUMP IF SO
	LB	R5,BBUFER+MUOADP,R10,	:SSCP-LU?
	JEFS	V.RDPX			:JUMP IF SO
	LHI	R5,LUSAPL		:APPLICATION
	JFS	V.RDPY			:JUMP TO CONTIFUE
V.RDPX	LHI	R5,LUSSYS		:OTHERWISE SYSTEM
V.RDPY	OR	R0,R5			:NEW SCREEN STATE
	STB	R0,LUCTAB+LUCSCN,R9,	:SAVE THE SCRN CNTL BYTE
	LB	R3,LUCTAB+LULUW2,R9,	:ENTER THE SYS/RQ CYCLE
	OHI	R3,LUSYRQ
	STB	R3,LUCTAB+LULUW2,R9,
	JAL	R4,L.GSRQ		:GENERATE THE SYS/RQ CMD AND
					:SEND IT TO THE HIF
	J	V.RDP2
:
:GO INTO THE BAD STATE AND SEND CMD TO NIO.
:
:V.RDP1	LA	R5,BSNTBL		:RECOVERABLE SENSE CODE TABLE(4/7/85/CHS)
V.RDP1	LA	R5,BSNTBL,,		:RECOVERABLE SENSE CODE TABLE(4/7/85/CHS)
	JAL	R4,COMTBL		:IS THIS A RECOVERABLE -RSP?
	LR	R0,R0
	JN	V.RDP2			:YES
	LB	R3,LUCTAB+LULUST,R9,	:NO, GO INTO THE BAD STATE
	OHI	R3,LUBDST
	STB	R3,LUCTAB+LULUST,R9,
	LHI	R0,SNERR^8+SCODE2	:ERROR CMD WITH STATUS TYPE
	JAL	R5,L.PTCD
:
:SEND CANCEL TO TERMINAL IF POSSIBLE
:
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	LB	R5,SCBBLK+SCSTAT+FSCCSD,R7,	:GET CHAIN-SEND FSM
	CHI	R5,FS.ST1		:BETWEEN CHAINS?
	JE	V.RDP2			:JUMP IF NOT
	STM	R0,LURGS1,,		:SAVE ALL REGISTERS
	LA	R8,CANCAN,,		:POINT TO CANNED CANCEL MSG
	LHI	R0,CANLGT+3		:LENGTH OF CANCEL RU + RH
	JAL	R5,L.DFLL		:GENERATE CANCEL MSG
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MURHF3,R10,	:GET RH BYTE 3
	OHI	R5,MU.CDI		:FORCE CHANGE DIRECTION
	STB	R5,BBUFER+MURHF3,R10,	:UPDATE RH BYTE 3
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND THE MESSAGE
	LM	R0,LURGS1,,		:RESTORE ALL REGISTERS
:                 
:IF END-TO-END ACK. IS REQUESTED, SEND AN ACK. BACK TO THE NIO.
:
V.RDP2	LB	R5,LUCTAB+LULUWK,R9,	:GET LUCB WORK BYTE
	THI	R5,LULUAK		:WAS ACK REQUESTED?
	JE	L.RCDD			:JUMP TO DISCARD MUCB&MSG IF NOT
	NHI	R5,@LULUFA&@LULUAK	:CLEAR ACK RELATED BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUCB WORK BYTE
	LHI	R0,SNETEM^8!SNDTAK	:PREPARE ACK TO NIO
	XR	R3,R3			:THIS IS TO SHOW ACK RSP
	JAL	R5,L.PTCD		:PASS ACK TO NIO
	J	L.RCDD			:JUMP TO DISCARD MUCB&RSP

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	IF NC CATEGORY MESSAGES ARE RECEIVED AT THIS POINT, IT MUST BE	:
:	SERIOUS DESIGN PROBLEM.						:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
V.RDNC	JAL	R10,CRASH,,
	HC	0
	BC	4*R5,CR.IMG

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	CONTROL ENTERS HERE WHEN DFC CATEGORY MESSAGES ARE RECEIVED.	:
:	DETERMINE THE MESSAGE TYPE AND JUMP TO EXECUTE THE DFC MESSAGE	:
:	ACCORDINGLY.							:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
V.RDDF	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN CONTROL BYTE
	THI	R5,LUSCRN		:SCREEN CONROL AT HIF
	JEFS	V.RDD1			:JUMP IF NOT
	JAL	R4,L.CSYN		:CHECK SCREEN SYNCRONIZATION
V.RDD1	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R0,BBUFER,R5,		:GET RQ CODE
	JAL	R5,L.DFCT,,		:DETERMINE DFC MSG. TYPE
	LHL	R5,V.DFTB,R6,R6		:GET PTR TO MSG. PROCESSING ROUTINE
	J	L.BASE,R5,,		:JUMP TO MSG. PROCESSING ROUTINE
:
:DFC MESSAGES PROCESSING ROUTINE TABLE.
:
V.DFTB	HC	V.LUST-L.BASE		:LUSTAT PROCESSING ROUTINE
	HC	V.RTR-L.BASE		:RTR PROCESSING ROUTINE
	HC	V.BIS-L.BASE		:BIS PROCESSING ROUTINE
	HC	V.SBI-L.BASE		:SBI PROCESSING ROUTINE
	HC	V.QEC-L.BASE		:QEC PROCESSING ROUTINE
	HC	V.QC-L.BASE		:QC PROCESSING ROUTINE
	HC	V.RELQ-L.BASE		:RELQ PROCESSING ROUTINE
	HC	V.CANC-L.BASE		:CANCEL PROCESSING ROUTINE
	HC	V.CHAS-L.BASE		:CHASE PROCESSING ROUTINE
	HC	V.SHUD-L.BASE		:SHUTD PROCESSING ROUTINE
	HC	V.SHUC-L.BASE		:SHUTC PROCESSING ROUTINE
	HC	V.RSHT-L.BASE		:RSHUTD PROCESSING ROUTINE
	HC	V.BID-L.BASE		:BID PROCESSING ROUTINE
	HC	V.SIG-L.BASE		:SIG PROCESSING ROUTINE
	HC	V.INV-L.BASE		:INVALID DFC CODE ROUTINE
:
:INVALID DFC MESSAGES FOR VIRTUAL TERMINAL INTERFACE.
:
V.SBI
V.BIS
V.QEC
V.QC
V.RELQ
V.SHUD
V.SHUC
V.INV	EQ	.
	LR	R5,R10			:SAVE POINTER TO MUCB
	JAL	R10,CRASH,,		:CRASH
	HC	0
	BC	4*R5,CR.IMG		:INVALID MESSAGE CRASH CODE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	CHASE PROCESSING ROUTINE.					:
:	WHEN CHASE REQUEST IS RECEIVED, THE LU SERVICE MANAGER NEEDS TO	:
:	SEND POSITIVE RESPONSES TO ALL UNRESPONDED LU-LU REQUESTS THAT	:
:	ARE INDICATED IN THE RECEIVE CORRELATION TABLE.			:
:	THE POSITIVE RESPONSE TO CHASE IS THEN SENT AFTER ALL REQUESTS	:
:	HAVE BEEN REPLIED.						:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
V.CHAS	ST	R10,LURGS1,,		:SAVE MUCB POINTER
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB PTR
	LHL	R8,SCBBLK+SCTRNG,R7,	:GET CT TABLE GET PTR
V.CHA1	LHL	R5,SCBBLK+SCTRNR,R7,	:GET CT TABLE RELEASE PTR
	CR	R8,R5			:ANY UNRESPONDED REQUESTS?
	JE	V.CHAE			:NO, JUMP TO RESPONSE TO CHASE
:
:GENERATE +RSP FOR LU-LU DFC OR FMD RQ.
:THIS IS DONE BY L.GNRP SUBROUTINE. HOWEVER BEFORE WE CALL IT
:WE HAVE TO CREATE MUCB WITH THE INFORMATION THAT ARE REQUIRED BY
:THIS SUBROUTINE. THE INFORMATION CORRESPONDS TO RQ, NOT RSP.
:ONLY THE INFORMATION USED IN L.GNRP IS FILLED IN CORRECTLY.
:
	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET PTR TO BUF WITH CT
	LB	R5,BBUFER+CLARG5+1,R4,	:GET BYTE WITH RH2
	THI	R5,MU.ERI		:EXCEPTION RSP?
	JN	V.CHA3			:JUMP IF SO
	LB	R5,BBUFER+CLARG4,R4,	:GET RQ CODE
	CHI	R5,CHASE		:CHASE?
	JE	V.CHA3			:YES, NO RESPONSE TO CHASE
:
:FOR DFC OR FMD REQUESTS (EXCEPT CHASE), A POSITIVE RESPONSE IS GENERATED
:AND SENT TO THE DFC.SEND ROUTINE.
:
	JAL	R4,GBB,,		:GET BUFFERLET FOR MUCB
	J	NOBUFF,,		:JUMP IF NONE AVAILABLE(09/09/86/CHS) RX3
	JAL	R4,R.GBB,,		:COUNT IT
	LR	R10,R3			:COPY BUFFERLET POINTER
	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET PTR TO BUF WITH CT
	LB	R5,BBUFER+CLARG6,R4,	:GET BYTE WITH RU CATEGORY
	NHI	R5,MU.CTG		:LEAVE RU CATEGORY ONLY
	JEFS	V.CHA2			:JUMP IF FMD
	OHI	R5,MU.FI		:OTHERWISE SHOW FORMATTED RQ
:
:PREPARE INFORMATION IN THE MUCB THAT WILL BE USED TO GENERATE THE POSITIVE
:RESPONSE.
:
V.CHA2	STB	R5,BBUFER+MURHF1,R10,	:STORE IT IN MUCB
	LB	R5,BBUFER+CLARG5+1,R4,	:GET BYTE CONTAINING RH BYTE 2
	STB	R5,BBUFER+MURHF2,R10,	:STORE IT IN MUCB
	LB	R1,BBUFER+CLARG4,R4,	:GET RQ CODE
	LHL	R5,BBUFER+CLARG3,R4,	:GET END SEQ #
	STH	R5,BBUFER+MUSNF,R10,	:PUT IT IN MUCB
	LHI	R5,FID2^4		:PREPARE 1ST BYTE OF TH
	STB	R5,BBUFER+MUBIUF,R10,	:PUT IT IN MUCB
	LB	R5,LUCTAB+LUCADR,R9,	:GET ADDR OF SECONDARY LU
	LB	R4,LUCTAB+LUPRIL,R9,	:GET ADDR OF PRIMARY LU
	STB	R5,BBUFER+MUOADP,R10,	:PUT SEC IN MUCB
	STB	R4,BBUFER+MUDADP,R10,	:PUT PRI IN MUCB
	XR	R0,R0			:+RSP (NO SENSE CODE)
	JAL	R5,L.GNRP		:GENERATE +RSP
	LHI	R2,DFCSND		:SHOW DFC.SEND AS DESTINATION
	LHI	R1,LURCV		:FROM LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	JAL	R8,SEND,,		:SEND DQE
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
V.CHA3	LHL	R8,CMDBLK+CLPTR,R8,	:GET NEXT ELEMENT OF CT
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET SCB POINTER
	J	V.CHA1			:GO CHECK NEXT CT ENTRY
:
:ALL REQUESTS ON THE RECEIVE CORRELATION TABLE HAVE BEEN RESPONDED,
:SEND POSITIVE RESPONSE TO CHASE.
:
V.CHAE	L	R10,LURGS1,,		:GET POINTER TO CHASE MUCB
	XR	R0,R0			:INDICATE +RSP
	LHI	R1,CHASE		:RQ CODE CHASE
	J	RTNRSP

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	RTR PROCESSING ROUTINES.					:
:	IF RTR IS EXPECTED THEN A POSITIVE RESPONSE IS RETURNED.	:
:	ELSE A NEGATIVE RESPONSE IS RETURNED.				:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
V.RTR	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JN	V.RDNC			:ERROR IF RSP
:
	LHI	R0,.NGRTR		:ASSUME NEGATIVE RESPONSE
	LHI	R1,RTR			:RTR RQ CODE
	LB	R5,LUCTAB+LULUW2,R9,	:GET THE LU 2ND WORK BYTE
	THI	R5,LULURT		:IS THIS RTR EXPECTED?
	JE	RTNRSP			:NO, GENERATE NEGATIVE RSP
	NHI	R5,@LULURT		:RESET WAIT RTR FLAGS
	STB	R5,LUCTAB+LULUW2,R9,
	LB	R5,LUCTAB+LULUST,R9,	:GET THE LU STATE BYTE
	NHI	R5,@WAITRS		:RESET WAIT FOR RESPONSE FLAG
	STB	R5,LUCTAB+LULUST,R9,
	XR	R0,R0			:PREPARE FOR +RSP
	J	RTNRSP

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	CANCEL PROCESSING ROUTINES.					:
:	IF CANCEL RESPONSE IS RECEIVED THEN DISCARD IT.			:
:	IF CANCEL REQUEST IS RECEIVED THEN INFORM NIO AND RETURN A	:
:	POSITIVE RESPONSE.						:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
V.CANC	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JN	L.RCDD			:DISCARD IF RSP
:
	JAL	R4,GBB,,		:GET A BUFFERLET FOR DUMMY FMD
	J	NOBUFF			:NON AVAILABLE
	JAL	R4,R.GBR,,		:COUNT IT
	LHI	R0,SNETEM^8!SNDTLC!SNDTCN	:SEND THIS DUMMY FMD MSG. TO
					:NIO AS LAST SEG. AND SET CANCEL IND.
	LIS	R2,FID2LG+3		:DUMMY RU MSG.
	JAL	R5,L.PTCD		:PASS CMD TO NIO
	XR	R0,R0			:PREPARE +RSP
	LHI	R1,CANCEL		:CANCEL RQ CODE
	J	RTNRSP

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	RSHUTD PROCESSING ROUTINE.					:
:	IF RSHUTD RESPONSE IS RECEIVED THEN MUST BE ERROR.		:
:	IF RSHUTD REQUEST IS RECEIVED THEN AN ERROR COMMAND WITH UNABLE :
:	TO CONTINUE SUBCOMMAND IS PASSED TO THE NIO.  THE NIO SHOULD	:
:	RESPOND WITH A CLEAR COMMAND, WHICH IN TURN CAUSES AN UNBIND TO :
:	GET SEND TO THE SECONDARY HALF-SESSION.				:
:	ALSO, THE LU SERVICE MANAGER STATE GOES INTO BAD STATE AND A	:
:	POSITIVE RESPONSE TO THE RSHUTD IS RETURNED.			:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
V.RSHT	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JN	V.RDNC			:ERROR IF RSP
:
	LHI	R0,SNERR^8!SCODE2	:PREPARE ERROR CMD WITH UNABLE TO CONTINUE
	JAL	R5,L.PTCD		:PASS IT TO NIO
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUBDST		:GO TO BAD SUBSTATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	XR	R0,R0			:PREPARE FOR +RSP
	STB	R0,LUCTAB+LULUWK,R9,	:CLEAR LUSVC WORK BYTE
	LHI	R1,RSHUTD		:PREPARE RSHUTD RQ CODE
	J	RTNRSP			:JUMP TO SEND +RSP

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	SIGNAL PROCESSING ROUTINE.					:
:	IF SIGNAL RESPONSE IS RECEIVED THEN DISCARD IT.			:
:	IF SIGNAL REQUEST IS RECEIVED AND IT IS A REQUEST TO SEND 	:
:	SIGNAL.  THE SIGNAL IS CONVERTED TO 'ATTN KEY' EQUIVALENT	:
:	INTERNAL MESSAGE AND SHIPPED TO PAIRED HIF IF SNA HIF IS	:
:	CONFIGURED.  OTHERWISE, THE SIGNAL IS DISCARDED.		:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	SEG	A.DATA
	SEG	A.CODE
V.SIG	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JN	L.RCDD			:DISCARD IF RSP
:
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN CONTROL BYTE
	THI	R5,LUSCRN		:COUPLED WITH SNA HIF?
	JE	V.SIG1			:NO, SEND +RSP
	BBLOAD	R8,BBUFER+MURUPT,R10,	:YES, GET RU PTR
	LHL	R8,BBUFER+1,R8,		:GET SIGNAL CODE
	CHI	R8,LURQSG		:IS IT REQUEST TO SEND SIGNAL?
	JN	V.SIG1			:NO, SEND +RSP
:
:SEND ATTN KEY EQUIVALENT INTERNAL MESSAGE TO THE SNA HIF
:
	JAL	R4,GBB,,		:GET A BUFFERLET
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBR,,		:COUNT IT
	LHI	R0,ATTAID		:PREPARE ATTENTION AID
	STB	R0,BBUFER+FID2LN+3,R3,	:PUT IT IN THE BUFFERLET
	LHI	R2,FID2LN+3		:ATTN KEY COMMAND LENGTH
	LHI	R0,SNETEM^8!SNDTCD	:INDICATE END-TO-END MSG. AND CD.
	JAL	R5,L.PTCD		:SEND IT TO THE NIO
V.SIG1	LHI	R1,SIG			:PREPARE FOR SIGNAL RSP
	XR	R0,R0			:INDICATE +RSP
	J	RTNRSP			:RETURN POSITIVE RESPONSE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	LUSTAT HANDLING ROUTINE.					:
:	WHEN AN LUSTAT IS RECEIVED, THE STATUS CODE IS CATEGORIZED INTO :
:	3 CATEGORIES: 1) RECOVERABLE, 2) SHORT TERM UNAVAILABLE, AND 3)	:
:	LONG TERM UNAVAILABLE.  AN ERROR COMMAND WITH ONE OF THE 3	:
:	STATUS CODE CATEGORIES IS SENT TO THE NIO AND POSITIVE RESPONSE :
:	TO THE RECEIVED LUSTAT IS RETURNED TO THE TERMINAL.		:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
V.LUST	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:IS IT RQ OR RSP?
	JN	V.INV			:CRASH IF RSP
:
:CHECK STATUS CODE.
:STATUS CODE CATEGORY IS RETURNED IN THE R0.
:  R0 = 0 : RECOVERABLE STATUS
:  R0 = 1 : SHORT TERM UNAVAILABLE STATUS
:  R0 = 2 : LONG TERM UNAVAILABLE STATUS
:
	JAL	R5,L.STCK,,		:CHECK STATUS CODE
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	CLHI	R0,SCODE1		:SHORT TERM UNAVAILABLE STATUS CODE?
	JN	V.LUS1			:JUMP IF NO
	LB	R3,LUCTAB+LULUW2,R9,	:GET SYS/RQ CONTROL BYTE
	THI	R3,LUSYRQ		:IN SYS/RQ CYCLE
	JE	V.LUS3			:SEND RSP IF SO
	LR	R3,R0			:SAVE THE STATUS CODE
	LHI	R0,NSSTAT^8!NSTDUB	:UNBIND STATUS COMMAND
	XR	R1,R1
	ST	R10,LURGSV,,		:SAVE THE REGISTER
	JAL	R10,L.NSST		:QUEUE ERROR RECOVERY REQUEST
	L	R10,LURGSV,,		:RESTORE THE REGISTER
	LR	R0,R3			:RESTORE STATUS BYTE
	OHI	R5,LUDPCL		:INDICATE CLEANING
	J	V.LUS2
:
:UPDATE LUSVC STATE BYTE AND SEND CMD TO NIO.
:
V.LUS1	CLHI	R0,SCODE0		:RECOVERABLE?
	JEFS	V.LUS2			:YES
	OHI	R5,LUBDST		:NO, GO INTO BAD STATE
V.LUS2	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	OHI	R0,SNERR^8		:ERROR CMD WITH STATUS TYPE
	JAL	R5,L.PTCD
:
:GENERATE +RSP AND DISCARD LUSTAT.
:
V.LUS3	XR	R0,R0			:POSITIVE RESPONSE
	LHI	R1,LUSTAT		:PREPARE FOR LUSTAT RSP
RTNRSP	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO THE BTU
	JAL	R5,R.PBRC,,		:RELEASE BBUFER WITH THE RU
	JAL	R5,L.GNRP		:GENERATE RSP
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LHI	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND THE MESSAGE
	JR	R14			:AND RETURN

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	BID HANDLING ROUTINE.						:
:	VTI RECEIVES ONLY BID RESPONSE.					:
:	IF POSITIVE BID RESPONSE IS RECEIVED, THE 'WAIT FOR RESPONSE'	:
:	BIT IN THE LULUST IS RESET AND THE BID REQUEST ELEMENT ON THE	:
:	NIO->SNA DATA_Q IS REMOVED.					:
:	IF NEGATIVE BID RESPONSE IS RECEIVED AND THE SENSE CODE		:
:	INDICATES THAT THE RTR IS NOT FORTHCOMING, THEN THE PROCESSES	:
:	IS THE SAME AS FOR POSITIVE BID RESPONSE.  OTHERWISE (THE RTR	:
:	IS NOT FORHTCOMING), THE 'WAIT FOR RTR' BIT IN THE LULUST IS	:
:	SET AND THE BID REQUEST ELEMENT ON THE NIO->SNA DATA_Q IS	:
:	REMOVED.							:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
V.BID	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JE	V.RDNC			:ERROR IF REQUEST
:
	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R5,MU.RTI		:POSISTIVE RSP?
	JE	V.BID0			:YES, JUMP
:
:NEGATIVE BID RESPONSE
:
	LHL	R2,BBUFER+MURHSN,R10,	:GET THE SENSE CODE
	CLHI	R2,.RRBJF		:RTR FORTHCOMING?
	JE	V.BID1			:YES
:
:FOR POSITIVE BID RESPONSE OR NEGATIVE BID RESPONSE AND RTR NOT FORTHCOMING,
:RESET 'WAIT FOR RESPONSE' BIT.
:
V.BID0	LB	R0,LUCTAB+LULUST,R9,	:GET THE LUSVC BYTE
	NHI	R0,@WAITRS		:CLEAR WAIT FOR RESPONSE BIT
	STB	R0,LUCTAB+LULUST,R9,	:RESTORE THE LUSVC BYTE
	J	V.BID2
:
:FOR NEGATIVE BID RESPONSE AND RTR FORTHCOMING, SET 'WAIT FOR RTR' BIT.
:
V.BID1	LB	R0,LUCTAB+LULUW2,R9,	:GET LU 2ND WORK BYTE
	OHI	R0,LULURT		:INDICATE WAIT FOR RTR
	STB	R0,LUCTAB+LULUW2,R9,	:RESTORE IT
:
V.BID2	J	L.RCDD			:JUMP TO DISCARD THE MESSAGE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:									:
:	CONTROL ENTERS HERE WHEN SC CATEGORY MESSAGES ARE RECEIVED.	:
:	ONLY BIND, UNBIND, AND SDT POSITIVE RESPONSES ARE EXPECTED.	:
:	ALL OTHER TYPE OF SC MESSAGES LEAD TO CRASH.			:
:									:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
V.RDSC	LB	R1,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R1,MU.RRI		:IS IT A RESPONSE?
	JE	V.RDNC			:CRASH, IF IT IS A SC REQUEST
:
:	FOR SC RESPONSES, ONLY BIND, UNBIND, AND SDT POSITIVE RESPONSES
:	ARE PROCESSED
:
	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R5,MU.RTI		:IS IT +RSP?
	JN	V.RDNC			:CRASH, IF IT IS A SC -RSP
:
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R0,BBUFER,R5,		:GET RQ CODE
	CLHI	R0,BIND			:BIND?
	JE	V.RDS1			:JUMP IF SO
	CLHI	R0,UNBIND		:UNBIND?
	JE	V.RDS1
	CLHI	R0,SDT			:SDT?
	JN	V.RDNC			:CRASH, FOR OTHER SC RESPONSES
:
:	FOR BIND, UNBIND, AND SDT +RSP, CLEAR THE WAIT FOR RESPONSE BIT
:	IN THE LULUST
:
V.RDS1	LB	R0,LUCTAB+LULUST,R9,	:GET THE LUSVC BYTE
	NHI	R0,@WAITRS		:CLEAR WAIT FOR RESPONSE BIT
	STB	R0,LUCTAB+LULUST,R9,	:RESTORE THE LUSVC BYTE
	J	L.RCDD			:JUMP TO DISCARD MUCB&RSP

L.RDNT	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE CHECK BYTE
	JER	R14			:RETURN IF OK
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R5,CR.NCK

	EI (VTISUP)

	FO	SNAPKG
	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER
	FO	MAIN	

	EM
 	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN

:::::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS ALL UTILITY ROUTINES
:: TO SUPPORT LU SERVICE MANAGER IN HOST DSP MODE.
:::::::::::::::::::::::::::::::::::::::::

	SEG	A.CODE

	IF	HDPSUP!VTISUP
:
:	THE FOLLOWING ROUTINE PUTS A CHARACTER INTO A BUFFERLET.
:	INPUTS: R0 - CHARACTER TO PUT INTO BUFFER.
:		R3 - BUFFER POINTER.
:		R13 - 1ST FREE PLACE IN THE BUFFER (BUFFER INDEX).
:		R15 - OVERALL COUNT OF CHARACTERS ALREADY IN THE BUFFERS FOR
:		THIS MESSAGE.
:		LINK:	R6
:
L.PTCH
H.PTCH
	ST	R6,LURGS1,,		:SAVE R6
	ST	R7,LURGS1+4,,		:SAVE R7
	ST	R11,LURGS1+8,,		:SAVE R11
	CLHI	R13,BBFLSZ-BBFPSZ	:END OF BUFFER?
	JL	H.PTC1			:JUMP IF NOT THE END OF BUF
	LR	R11,R3			:OTHERWISE SAVE BUFFER POINTER
	JAL	R4,GBB,,		:OBTAIN NEXT BUFFERLET
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	BBSTOR	R3,BBUFER+BBFLSZ-BBFPSZ,R11,	:CHAIN NEX BUFFER TO OLD
	L	R11,LURGSV+2C,,
	JAL	R4,R.GBR,,		:COUNT THE BUFFERLET
	LIS	R13,0			:INIT BUFFER INDEX BX.OUT
H.PTC1
	STB	R0,BBUFER,R13,R3	:PUT THE CHAR IN THE BUFFER
	AIS	R15,1			:INCREASE OVERALL CHAR COUNT
	AIS	R13,1			:ADVANCE BUFFER INDEX
	L	R11,LURGS1+8,,		:RESTORE R11
	L	R7,LURGS1+4,,		:RESTORE R7
	L	R6,LURGS1,,		:RESTORE R6
	JR	R6			:AND RETURN
	
:	HSBADR:	CALCULATE THE 3270 I/O ADDRESS
:	-------
:	INPUT:	R5 - MAX LINE #
:	INPUT:	R4 - CUR LINE #
:	INPUT:	R2 - CUR COL #
:	INPUT:	R1 - MAX COL #
:	OUTPUT:	R0 - 3270 I/O CODE
:	LINK REG.:	R6
HSBADR
	ST	R6,LURGS1,,		:SAVE R6
	LR	R0,R1
	AIS	R0,1
	MHR	R4,R0
	AR	R4,R2
	LR	R6,R4
	LB	R0,LUCTAB+LUCSYS,R9,	:SEE IF HITACHI
	CLHI	R0,HITACHI
	JE	HSBAD1			:YES, SKIP
	NHI	R4,03F
	NHI	R6,0FC0
	SRHLS	R6,6
	LO	BSUB
	LB	R0,BAIOIC,R6,
	EXBR	R0,R0
	LB	R6,BAIOIC,R4,
	FO	BSUB
	OR	R0,R6
	L	R6,LURGS1,,		:RESTORE R6
	JR	R6
HSBAD1
	NHI	R4,01F			:LAST 5 BITS
	OHI	R4,0E0			:
	EXBR	R4,R4			:1ST CHAR
	SRHLS	R6,5			:1ST FEW BITS, AND SHIFT TO RIGHT MOST
	OHI	R6,0C0			:
	LR	R0,R4
	OR	R0,R6
	L	R6,LURGS1,,
	JR	R6

:	(5/17/85/CHS)
	EI	(HDPSUP!VTISUP)

	IF	HDPSUP

::::::::::::::::::::::::::::::::::::::::::
:: THE FOLLOWING ROUTINE MAPS DATA MESSAGE (DSP RESPONSE)
:: INTO SSCP-LU MESSAGE.
:: THE ROUTINE CREATES MUCB AND RETURNS ITS ADDRESS IN R10.
:: IT ALSO CONVERTS 3270 DATA STREAM FROM DSP RESPONSE MESSAGE
:: INTO SNA CHARACTER STREAM IF CERTAIN LIMITATION ARE MET.
:: THE RETURN CODE OF 0 IN R0 MEANS SUCCESSFUL CONVERSION,
:: OTHERWISE 1 IS RETURNED. OTHER REGISTERS ARE PRESERVED.
::::::::::::::::::::::::::::::::::::::::::

H.MTSC	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LR	R9,R4		:SAVE POINTER TO LUCB
	LR	R10,R3		:SAVE LU_SVC STATUS
	LR	R15,R7		:SAVE SCB POINTER
	JAL	R4,GBB,,	:GET BUFFERLET FOR MUCB
	J	NOBUFF		:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,	:COUNT THE BUFFERLET

:FILL MUDIRE, MUOADP AND MUDADP
	LIS	R4,SENT		:GET SEND INDICATOR FOR DIRECTION
	STB	R4,BBUFER+MUDIRE,R3,	:PUT IT IN MUCB
	XR	R4,R4			:CLEAR THE REGISTER
	STB	R4,BBUFER+MUSCHK,R3,	:CLEAR SENSE-CHECK
	XR	R4,R4			:CLEAR THE REGISTER
	STB	R4,BBUFER+MUDADP,R3,	:PUT IT IN MUCB DESINATION
	LB	R4,LUCTAB+LUCADR,R9,	:GET SECONDARY LOCAL ADDRESS
	STB	R4,BBUFER+MUOADP,R3,	:PUT IT IN MUCB ORIGINATION

:NOW GET POINTER TO THE MESSAGE
	BBLOAD	R2,CMDBLK+CLARG,R8,	:POINTER TO PIU FROM NIO
	BBSTOR	R2,BBUFER+MUCBTU,R3,	:STORE IT IN MUCB

:CONVERSION WILL BE PERFORMED ONLY IF THE WHOLE DSP RESPONSE
:IS REPRESENTED AS ONE SEGMENT ONE CHAIN SNA MESSAGE.
	NHI	R1,@NSDTCD		:MASK CHANGE DIRECTION BIT
	JN	H.MTSF			:FAILURE IF ANYTHING ELSE IS ON

:FILL IN 1ST BYTE OF TH AND RH INFORMATION.
	LHI	R4,FID2^4!MU.BIU!MU.EIU	:SHOW FID2 AND ONE SEGMENT
	STB	R4,BBUFER+MUBIUF,R3,	:STORE IT IN MUCB
	LHI	R4,MU.BCI!MU.ECI	:PREPARE BC&EC
	STB	R4,BBUFER+MURHF1,R3,	:STORE 1ST BYTE OF RH IN MUCB
	LHI	R4,MU.DR1		:PREPARE DEFINIE RESPONSE CHAIN
	STB	R4,BBUFER+MURHF2,R3,	:STORE 2ND BYTE OF RH IN MUCB
	XR	R4,R4			:NO BRACKET INFORMATION
	STB	R4,BBUFER+MURHF3,R3,	:STORE 3RD BYTE OF RH IN MUCB

:FILL IN SEQUENCE NUMBER FIELD.
	LHL	R4,SCBBLK+SCSQSC,R15,	:GET PREVIOUS ID
	AIS	R4,1			:INCREASE IT BY 1
	STH	R4,SCBBLK+SCSQSC,R15,	:PUT IT BACK
	STH	R4,BBUFER+MUSNF,R3,	:STORE IT IN MUCB

:NOW CONVERT 3270 DATA STREAM INTO SNA CHARACTER STREAM.
:ONLY READ MODIFY AID WILL BE ACCEPTED.
	LHL	R5,CMDBLK+CLLNG,R8,	:GET LENGTH OF MSG
	SIS	R5,FID2LG+3		:ADJUST FOR TH AND RH LENGTH
	LR	R6,R2			:COPY BTU POINTER
	AIS	R2,FID2LG+3		:POINT TO RU
	LB	R0,BBUFER,R2,		:GET AID
	CHI	R0,AIDENT		:IS IT READ MODIFIED?
	JN	H.MTSF			:FAILURE IF NOT
	LIS	R4,3			:CURRENT LENGTH IS 3 (WITH RH)
	SIS	R5,3			:NUMBER OF REMAIN CHAR (SKIP CURS)
	JLE	H.MTSE			:JUMP IF ALL DONE

	JAL	R4,FNCRLN		:FIND ROW # OF CURSOR (5/15/85/CHS)
	STB	R0,LUCTAB+LULUW3,R9,	:UPDATE ROW # (5/15/85/CHS)

	LIS	R4,3			:SET UP R4 = 3 AGAIN

:PREPARE FOR CONVERSION LOOP. 3270 MESSAGE WILL BE COPIED INTO THE
:SAME BUFFERS. 3270 ORDERS WILL BE ELIMINATED AND THE WHOLE MESSAGE
:SHIFTED TO THE BEGINNING OF BUFFER CHAIN.
	LR	R7,R6			:R6 POINTS TO NEW BUF, R7 TO OLD
	LHI	R8,FID2LG+3		:INIT SCS BUFFER INDEX
	LHI	R9,FID2LG+6		:INIT 3270 BUFFER INDEX

:CONVERSION LOOP STARTS HERE.
:FIRST SWITCH TO NEXT BUFFERLET IF REACHED THE END.
:THE CONVERTED MESSAGE BUFFER COULD BE ADVANCED ONLY BY 1 CHARACTER
:AT A TIME, BUT THE ORINGINAL MESSAGE BUFFER COULD BE ADVANCED BY EITHER
:1 OR 3 (WHEN 2 BYTE ADDRESS IS SKIPPED) AT A TIME.
H.MTS1	CHI	R8,BBFLSZ-BBFPSZ	:COMPARE NEW INDEX WITH BUF SIZE
	JLFS	H.MTS2			:JUMP IF NOT THE END
	XR	R8,R8			:BEGINNING OF NEXT BUFFER
	BBLOAD	R6,BBUFER+BBFLSZ-BBFPSZ,R6,	:POINT TO NEXT BUFFER
H.MTS2	CHI	R9,BBFLSZ-BBFPSZ	:COMPARE OLD INDEX WITH BUF SIZE
	JLFS	H.MTS3			:JUMP IF NOT THE END
	SHI	R9,BBFLSZ-BBFPSZ	:INIT INDEX OF NEXT BUFFER
	BBLOAD	R7,BBUFER+BBFLSZ-BBFPSZ,R7,	:POINT TO THE NEXT BUFFER

:ONLY SF,SA AND SBA ORDERS ARE ALLOWED IN THE MESSAGE. OTHERWISE
:THE MESSAGE CONVERSION FAILS. VALID ORDERS ARE THROWN AWAY.
H.MTS3	LB	R0,BBUFER,R7,R9		:GET NEXT CHARACTER
	CHI	R0,SP.			:GRAPHIC CHARACTER?
	JGE	H.MTS4			:JUMP IF SO
	SIS	R5,2			:NEXT 2 CHARS WILL BE SKIPPED
	AIS	R9,2			:ADVANCE BUFFER INDEX
	CHI	R0,SF.			:SF ORDER?
	JE	H.MTS5			:JUMP IF SO
:	CHI	R0,SA.			:SA ORDER?
:	JE	H.MTS5			:JUMP IF SO
	CHI	R0,SBA.			:SBA ORDER?
	JEFS	H.MTS5			:JUMP IF SO
	J	H.MTSF			:FAILURE IF NOT
H.MTS4	STB	R0,BBUFER,R6,R8		:STORE NEXT CHAR BACK IN BUFFER
	AIS	R8,1			:ADVANCE NEW BUFFER INDEX
	AIS	R4,1			:INCREASE DATA COUNT
H.MTS5	AIS	R9,1			:ADVANCE OLD BUFFER INDEX
	SIS	R5,1			:DECREASE COUNT OF REMAIN CHARS
	JG	H.MTS1			:CONTINUE UNTIL FINISHED

:IF SHIFTING PROCESS MADE SOME BUFFERLETS UNUSED RELEASE THEM.
	CR	R6,R7			:COMPARE LAST BUFFERLETS USED
	JE	H.MTSE			:EVERYTHING DONE IF MATCH
	XR	R5,R5			:PREPARE TO CLEAR CHAINING POINTER
	LR	R0,R3			:SAVE MUCB POINTER
	LR	R9,R2			:SAVE RU POINTER
	LR	R10,R4			:SAVE DATA COUNT FIELD
	BBLOAD	R3,BBUFER+BBFLSZ-BBFPSZ,R6,	:POINT TO 1ST UNUSED BUF
	BBSTOR	R5,BBUFER+BBFLSZ-BBFPSZ,R6,	:SHOW THE END OF BUF CHAIN
	JAL	R5,R.PBBC,,		:RELEASE UNUSED BUFFERS
	LR	R3,R0			:RESTORE MUCB POINTER
	LR	R2,R9			:RESTORE RU POINTER
	LR	R4,R10			:RESTORE DATA COUNT FIELD

:MAPPING FINISHED. PUT RU POINTER AND DCF IN MUCB AND RETURN WITH 0 RC.
H.MTSE	BBSTOR	R2,BBUFER+MURUPT,R3,	:PUT RU POINTER IN MUCB
	STH	R4,BBUFER+MUDCF,R3,	:STORE DATA COUNT FIELD
	ST	R3,LURGSV+28,,		:PUT MUCB POINTER IN R10 AREA
	LM	R0,LURGSV,,		:RESTORE ALL REGISTRES
	XR	R0,R0			:NORMAL RETURN CODE
	JR	R5			:AND RETURN

:CONVERSION TO SNA CHARACTER STREAM FAILED. RETURN WITH RETCODE OF 1.
H.MTSF	ST	R3,LURGSV+28,,		:PUT MUCB POINTER IN R10 AREA
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	LIS	R0,1			:ABNORMAL RETURN CODE
	JR	R5			:RETURN


:	(5/17/85/CHS) THE H.CVRT ROUTINE IS RE-CODED
:
:	THE FOLLOWING ROUTINE CONVERTS SSCP-LU MESSAGE (SCS CHARACTER STREAM)
:	INTO 3270 CHARACTER STREAM MESSAGE. ONLY RU IS CONVERTED.
:	THE MESSAGE IS REBUFFERED.
:	INPUTS: R10 - MUCB POINTER.
:		R9 - LUCB POINTER.
:	LINK:   R5.
:	ALL REGISTERS ARE PRESERVED.
:
:	REGISTERS USAGE:
:		R15	- BC.OUT
:		R14	- BH.OUT
:		R13	- BX.OUT
:		R12	- BC.IN
:		R11	- BA.IN
:		R10	- MUCB
:		R9	- LUCB
:		R8	- BX.IN
:		R7	- LINK FOR H.PTCH
:		R6	- LINK FOR WSBADR
:		R5	- MAX LINE#
:		R4	- WORK/LINK
:		R3	- BA.OUT
:		R2	- CURRENT COLUMN POSITION
:		R1	- MAX COLUMN
:		R0	- WORK
:
:	FIRST PREPARE FOR MAIN LOOP.
					:(F02/12/16/87/DB/START)
	SEG	A.DATA
CURCOL	BS	1			:TEMP STAORAGE FOR CURRENT COLUMN
	SEG	A.CODE
					:(F02/12/16/87/DB/END)
H.CVRT	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LHL	R4,LUCTAB+LUCDCB,R9,	:R4 = DCB
	LB	R0,DCBLKS+DCBRFS,R4,	:R0 = REMOTE DEVICE TYPE
	LHI	R5,$A11			:ASSUME SMALL SCRENN (480)
	LHI	R1,$A39			:...
	NHI	R0,SCRNSZ		:GET SCREEN SIZE INDICATOR
	JEFS	H.CVR1			:SMALL SCREEN, SKIP
	LHI	R5,$A23			:ELSE LARGE SCREEN (1920)
	LHI	R1,$A79			:...
H.CVR1
	JAL	R4,GBB,,		:GET 1ST BUFFERLET FOR CONVERTED MSG
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBR,,		:COUNT THE BUFFERLET
	LR	R14,R3			:SAVE BUFFER POINTER
	BBLOAD	R11,BBUFER+MUCBTU,R10,	:R11 = BTU
	LIS	R13,FID2LG		:R13 (BX.OUT) INIT
	LR	R8,R13			:INIT R8 (BX.IN)
	LHL	R12,BBUFER+MUDCF,R10,	:R12 = BC.IN
	LIS	R15,0			:INIT R15 (BC.OUT)
	LB	R2,LUCTAB+LULUW1,R9,	:CURRENT COLUMN IN CURRENT LINE

:THE SCREEN HAS TO BE CLEARED IF SSCP-LU MSG IS DISPLAYED AFTER DACTLU
:(IF CIRCUIT RETAINED) OR UNBIND. 0FF IS MOVED IN THE LINE # IN THESE
:CASES. LULUW3 IS CLEARED HERE, AND LINE # IS SAVED IN R4 TO BE
:USED LATER IN THIS ROUTINE TO GENERATE EITHER WRITE OR ERASE/WRITE
:(09/26/85 MIA).
	LB	R4,LUCTAB+LULUW3,R9,	:GET LINE #
	CHI	R4,0FF			:HAVE TO CLEAR?
	JNFS	H.CVR0			:JUMP IF NOT
	XR	R0,R0			:CLEAR THE REGISTER
	STB	R0,LUCTAB+LULUW3,R9,	:CLEAR LINE #
:	END OF INSERTION (09/26/85 MIA).

H.CVR0	LB	R0,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R0,MU.BIU		:1ST SEGMENT?
	JE	H.CVR3			:JUMP IF NOT
	SIS	R12,3			:ADJUST BC.IN DCF FOR RH SIZE
	AIS	R15,3			:ADJUST BC.OUT DCF FOR RH SIZE
	AIS	R13,3			:ADJUST BX.OUT
	LR	R8,R13			:ADJUST BX.OUT

:	FOR THE FIRST SEGMENT OF THE FIRST CHAIN ELEMENT, PUT
:	3270 WRITE COMMAND AND WCC AT THE BEGINNING OF THE NEW MESSAGE.
:	THE LINE # TO DISPLAY THE MESSAGE IS IN LULUW3
	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R0,MU.BCI		:1ST CHAIN ELEMENT?
	JE	H.CVR3			:JUMP IF NOT
	LIS	R2,0			:INIT COLUMN POSITION TO 0
	STB	R2,LUCTAB+LULUW1,R9,	:NO CHARS IN CURRENT LINE
	LHI	R0,WCMD			:PREPARE WRITE COMMAND
	CHI	R4,0FF			:CLEAR THE SCREEN? (09/26/85 MIA)
	JNFS	H.CVRY			:JUMP IF NOT (09/26/85 MIA)
	LHI	R0,EWCMD		:PREPARE ERASE/WRITE (09/26/85 MIA)
H.CVRY	STB	R0,BBUFER,R13,R3	:PUT IT IN THE BUFFER
	AIS	R13,1			:ADVANCE BX.OUT
	AIS	R15,1			:INCREASE DATA CNT BC.OUT
	LB	R0,LUCTAB+LUCSYS,R9,	:SEE IF HITACH T-560
	CLHI	R0,HITACHI		:... *** REAMRK
	JE	H.CVRZ			:YES, SKIP
	LHI	R0,WCCKM		:PREPARE WCC
	STB	R0,BBUFER,R13,R3	:PUT IT IN THE BUFFER
	AIS	R13,1			:ADVANCE BX.OUT
	AIS	R15,1			:INCREASE DATA CNT BC.OUT
	J	H.CVRW			:SKIP
H.CVRZ
	LHI	R0,CB2KM		:PREPARE CB2 PAIR
	STB	R0,BBUFER+1,R13,R3,	:PUT 2ND CB2 BYTE TO BUFFER
	EXBR	R0,R0
	STB	R0,BBUFER,R13,R3,	:PUT 1ST CB2 BYTE TO BUFFER
	AIS	R13,2			:ADVANCE BX.OUT
	AIS	R15,2			:INCREASE DATA CNT BC.OUT
H.CVRW
	LHI	R0,SBA.
	STB	R0,BBUFER,R13,R3,
	AIS	R13,1			:ADVANCE BX.OUT
	AIS	R15,1			:INCREASE DATA COUNT BC.OUT
:	SBA(L-1,C.M), SF.,PROC.,SBA(L,0)
	LB	R4,LUCTAB+LULUW3,R9,	:GET CURRENT LINE#
	SIS	R4,1			:CALCULATE PREVIOUS LINE
	JGEFS	H.CVR2			:NOT OUT OF RANGE, SKIP
	LR	R4,R5			:SET TO MAX LINE#
H.CVR2
	LR	R2,R1			:SET R2 = C.M
	JAL	R7,WSBADR		:SBA(L-1,C.M)
	LHI	R0,SF.			:SF.
	JAL	R6,H.PTCH		:WRITE SF.
	LHI	R0,ATPAD		:PROCTECT FIELD
	LB	R6,LUCTAB+LUCSYS,R9,	:SEE IF HITACH
	CLHI	R6,HITACH		:...
	JNFS	H.CVRV			:NO, SKIP
	LHI	R0,HAPAD		:HITACHI ATTRIBUTE CHARS
	ST	R0,CRSAV0,,		:SAVE R0
	EXBR	R0,R0
	JAL	R6,H.PTCH
	L	R0,CRSAV0,,		:RESTORE R0
H.CVRV
	JAL	R6,H.PTCH		:WRITE FIELD ATTRIBUE
	LHI	R0,SBA.
	JAL	R6,H.PTCH
	LB	R4,LUCTAB+LULUW3,R9,	:R4 = LNE
	LIS	R2,0			:R2 = COL 0
	JAL	R7,WSBADR		:SBA(L,0)
:	EXCEPT LAST NL., EVERY NL. IS REPLACED BY 
:		L = L + 1, C = 0
:		RTA(L,0), NULL.
:
:	FOR NON NL. CHAR, 
:		WRITE CHAR,
:		C = C + 1
:		IF C > C.M THEN C=0, L=L+1
H.CVR3
	CLHI	R12,1			:LAST CHAR IN INPUT?
	JE	H.CVR9			:YES, SKIP
H.CVR4
	LB	R0,BBUFER,R11,R8	:GET CHAR FROM IN BUFFER
	CLHI	R0,NL.			:IS IT NEW LINE?
	JN	H.CVR6			:JUMP IF NOT
:	NL. , BUT NOT THE LAST ONE
	LHI	R0,RA.			:RTA(L,C.M)
	JAL	R6,H.PTCH		:WRITE RA.
	JAL	R4,NXTLNE		:NL ALWAYS MOVE TO NEXT LINE
	STB	R0,LUCTAB+LULUW3,R9,	:UPDATE NEW CUR LNE
	LR	R4,R0
	LIS	R2,0			:COL 0 OF NEW LINE
	JAL	R7,WSBADR		:WRITE RTA(L,0)
	LHI	R0,NULL.		:WRITE NULL.
	JAL	R6,H.PTCH		:...
	J	H.CVR7			:TO ADVANCE BX.IN AND BX.OUT
:	NON NL. CHAR
H.CVR6
	JAL	R6,H.PTCH		:WRITE THE CHAR
	AIS	R2,1			:INCREASE COL
	CR	R2,R1			:EXCEED MAX COL?
	JLEFS	H.CVR7			:NO, SKIP
	JAL	R4,NXTLNE		:L = L + 1
	STB	R0,LUCTAB+LULUW3,R9,	:UPDATE CURRENT LINE #
	LIS	R2,0			:COL 0
:	ADVANCE BX.IN AND BX.OUT
H.CVR7
	AIS	R8,1			:ADVANCE BUFFER INDEX BX.IN
	CHI	R8,BBFLSZ-BBFPSZ	:DID WE REACH THE END OF BUF?
	JLFS	H.CVR8			:JUMP IF NOT
	BBLOAD	R11,BBUFER+BBFLSZ-BBFPSZ,R11,	:GET NEXT BUFF IN BA.IN
	LIS	R8,0			:INIT BX.IN
H.CVR8
	SIS	R12,1			:DECREASE DATA COUNT BC.IN
	JG	H.CVR3			:REPEAT IF MORE
	STB	R2,LUCTAB+LULUW1,R9,	:SAVE CUR COL
	J	H.CVRD			:TO  END OF CONCERSION

:	LAST CHAR, CHECK IF LAST CHAIN AND LAST SEGMENT
H.CVR9
:	LB	R0,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH (07/11/85 MIA)
	LB	R0,LUCTAB+LULUW2,R9,	:GET SAVED RH INFO (07/11/85 MIA)
	THI	R0,MU.ECI		:LAST CHAIN?
	JE	H.CVR4			:NO, SKIP
	LB	R0,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R0,MU.EIU		:LAST SEGMENT?
	JE	H.CVR4			:JUMP IF NOT
	LB	R0,BBUFER,R11,R8,	:GET NEXT CHAR
	CLHI	R0,NL.			:NL. ?
	JE	H.CVRA			:YES, SKIP
	JAL	R6,H.PTCH		:WRITE THE LAST CHAR
	AIS	R2,1			:INC COL
					:(f02/12/16/87/DB/START)
:	CR	R2,R1			:EXCEED LINE WIDTH?
:	JLEFS	H.CVRA			:NO, SKIP
	CLHI	R2,32			: > COLUMN 50?
	JLE	H.CVRB			:NO, DON'T BUMP THE ROW
					:(F02/12/16/87/DB/END)
	JAL	R4,NXTLNE		:YES, ADVANCE LINE
	STB	R0,LUCTAB+LULUW3,R9,	:...
	LIS	R2,0			:COL 0
	J	H.CVRB			:TO SET UP ATTRIBUTE(6/26/85/CHS)
H.CVRA
	CR	R2,R1			:FILL NULL AT THE REMAINING OF THE LINE
	JE	H.CVRB			:LAST COL
	LHI	R0,RA.			:WRITE RA.
	JAL	R6,H.PTCH		:...
	LB	R4,LUCTAB+LULUW3,R9,	:GET CUR LNE
	LR	R2,R1			:C = C.M
	JAL	R7,WSBADR		:WRITE SBA(L,C.M)
	LHI	R0,NULL.
	JAL	R6,H.PTCH
					:(F02/12/16/87/DB/START)
	LHI	R0,SBA.		
	JAL	R6,H.PTCH
	LB	R4,LUCTAB+LULUW3,R9,
	SIS	R4,1
	JAL	R7,WSBADR		:PREVIOUS ROW, COLUMN 80
	LB	R2,CURCOL,,
					:(F02/12/16/87/DB/END)
H.CVRB
	LHI	R0,SF.			:INSERT FIELD ATTRIBUTE
	JAL	R6,H.PTCH		:...
	LHI	R0,ATUAD
	LB	R6,LUCTAB+LUCSYS,R9,	:SEE IF HITACH
	CLHI	R6,HITACHI		:...
	JNFS	H.CVRU			:NO, SKIP
	LHI	R0,HAUAD		:HITACHI ATTRIBUTE CHARS
	ST	R0,CRSAV0,,		:SAVE R0
	EXBR	R0,R0
	JAL	R6,H.PTCH
	L	R0,CRSAV0,,		:RESTORE R0
H.CVRU
	JAL	R6,H.PTCH
	AIS	R2,1			:ATTRIBUTE BYTE(6/26/85/CHS)
	LHI	R0,SBA.
	JAL	R6,H.PTCH
	CR	R2,R1			:NEED TO ADVANCE TO NEXT LNE?(6/26/85/CHS)
	JLEFS	H.CVRX			:NO, SKIP(6/26/85/CHS)
	JAL	R4,NXTLNE		:ADVANCE TO NEXT LINE
	STB	R0,LUCTAB+LULUW3,R9,	:...
	LIS	R2,0
H.CVRX					:(6/2/85/CHS)
	STB	R2,LUCTAB+LULUW1,R9,	:COL 0
:	LR	R4,R0
	LB	R4,LUCTAB+LULUW3,R9,	:(F02/12/16/87/DB)
	JAL	R7,WSBADR		:SBA(L,0)
	LHI	R0,IC.			:PREPARE INSERT CURSOR
	JAL	R6,H.PTCH		:INSERT AT THE 1ST COL
					:(F02/12/16/87/DB/START)
:	LHI	R0,RA.
:	JAL	R6,H.PTCH
:	LB	R4,LUCTAB+LULUW3,R9,
::	AIS	R4,2			:(6/25/85/CHS)
:	CR	R4,R5
:	JLEFS	H.CVRCD		:SKIP
:	LIS	R4,0
:H.CVRC
:	LR	R2,R1
:	JAL	R7,WSBADR
:	LHI	R0,NULL.
:	JAL	R6,H.PTCH
	JAL	R4,NXTLNE		:ADVANCE TO NEXT LINE
	STB	R0,LUCTAB+LULUW3,R9,
	LIS	R2,0
	LHI	R0,SBA.
	JAL	R6,H.PTCH
	LB	R4,LUCTAB+LULUW3,R9,
	JAL	R7,WSBADR
					:(F02/12/16/87/DB/END)
	LHI	R0,SF.			:PREPARE START FIELD
	JAL	R6,H.PTCH		:PUT IT IN BUFFER
	LHI	R0,ATPAD		:GET FIELD ATTRIBUTES
	LB	R6,LUCTAB+LUCSYS,R9,	:SEE IF HITACH
	CLHI	R6,HITACHI		:...
	JNFS	H.CVRQ			:NO, SKIP
	LHI	R0,HAPAD		:HITACHI ATTRIBUTE CHARS
	ST	R0,CRSAV0,,		:SAVE R0
	EXBR	R0,R0
	JAL	R6,H.PTCH
	L	R0,CRSAV0,,		:GET 2ND BYTE
H.CVRQ
	JAL	R6,H.PTCH		:PUT THEM IN THE BUFFER

:	END OF CONVERSION ROUTINE.
:	UPDATE BTU, RU AND DCF FIELD IN MUCB
:	RELEASE IN BUFFERS
H.CVRD
	STH	R15,BBUFER+MUDCF,R10,	:UPDATE DATA COUNT FIELD IN MUCB
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET OLD BTU POINTER
	BBSTOR	R14,BBUFER+MUCBTU,R10,	:UDATE NEW BTU POINTER
	AIS	R14,FID2LG+3		:POINT TO RU
	BBSTOR	R14,BBUFER+MURUPT,R10,	:UPDATE NEW RU POINTER
	L	R11,LURGSV+2C,,		:RESTORE R11
	JAL	R5,R.PBRC,,		:RELEASE OLD BUFFERLET CHAIN
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	JR	R5			:AND RETURN

:	NXTLNE:	INCREASE TO NEXT DISPLAY LINE
:	-------
:	INPUT:	R9 = LUCB
:		R1 = MAX COL
:		R5 = MAX LNE
:	OUTPUT:	R0 = NEXT DISPLAY LINE
:	LINE REG.:	 R4
:	
NXTLNE
	LB	R0,LUCTAB+LULUW3,R9,	:GET CURRENT LINE #
	AIS	R0,1			:INCREASE BY 1
	CR	R0,R5			:COMPARE
:	JL	NXTLN1			:WITHIN RANGE
	JLE	NXTLN1			:(F01/12/15/87/DB)
	LIS	R0,1			:ELSE INIT TO LINE 0
NXTLN1
	JR	R4

:	WSBADR:	WRITE BADDR
:	------
:	INPUT:
:		R1	-MAX COL
:		R4	-CUR LNE
:		R2	-CUR COL
:		R5	-MAX LNE
:	OUTPUT:	...
:	LINE REG.:	R7
WSBADR
	JAL	R6,HSBADR		:CALCULATE THE BAIO CODES
	ST	R0,CRSAV0,,		:SAVE R0
	EXBR	R0,R0			:GET 1ST BYTE
	JAL	R6,H.PTCH
	L	R0,CRSAV0,,		:GET 2ND BYTE
	JAL	R6,H.PTCH
	JR	R7			:RETURN


::::::::::::::::::::::::::::::::::
:: THE FOLLOWING ROUTINE CHECK BIND PARAMETERS.
:: INPUT: R10 - POINTER TO MUCB, R9 - LUCB.
:: RETURN CODE: R0 (0 - OK, 1 - NOT GOOD)
:: LINK:  R5
:: CAN DESTROY R2 - R8.
:
:: THIS CODE CHECKS ONLY SCREEN SIZE.
:: THE REST OF THIS ROUTINE IS TO BE CODED LATER.
	IF	EWALSW			:E/W ALT SWITCH ON
H.CKBD	LHL	R4,LUCTAB+LUCDCB,R9,	:GET DCB ADDR
	LB	R4,DCBLKS+DCBRFS,R4,	:GET BYTE WITH SCREEN SIZE
	NHI	R4,SCRNSZ		:LEAVE SCREEN SIZE BITS ONLY
	CHI	R4,SCRNS2		:SIZE 2 (1920)?
	JG	H.CKBG			:OK IF BIG SIZE
	JL	H.CKBB			:BAD IF SMALL SIZE
	BBLSCB	R4,LUCTAB+LULSCB,R9,	:GET SCB POINTER
	LB	R0,SCBBLK+SCPSUF,R4,	:GET BYTE WITH LU TYPE
	NHI	R0,7F			:GET LU TYPE
	CLB	R0,LUCTUB+LUCTYP,R9,	:COMPARE WITH GEN LU TYPE
	JN	H.CKBB			:JUMP IF NO MATCH
	LB	R0,SCBBLK+SCPSUG+9,R4,	:GET PS USAGE BYTE
	CHI	R0,S19202		:SIZE 2 (1920)?
	JL	H.CKBB			:BAD IF SMALLER
	JE	H.CKBG			:GOOD IF EQUAL
	CHI	R0,S1920F		:WITH ALTERNATE SIZE?
	JNFS	H.CKB1			:JUMP IF NOT
	LB	R0,SCBBLK+SCPSUG+7,R4,	:ALTERNATE VERTICAL SIZE
	CHI	R0,S1920V		:24 ROWS?
	JN	H.CKBB			:BAD IF NOT
	LB	R0,SCBBLK+SCPSUG+8,R4,	:ALTERNATE HORIZ SIZE
	CHI	R0,S1920H		:80 COLUMNS?
	JN	H.CKBB			:BAD IF NOT
H.CKB1	LB	R0,SCBBLK+SCPSUG+5,R4,	:DEFAULT VERTICAL SIZE
	CHI	R0,S1920V		:24 ROWS?
	JNFS	H.CKBB			:BAD IF NOT
	LB	R0,SCBBLK+SCPSUG+6,R4,	:DEFAULT HORIZ SIZE
	CHI	R0,S1920H		:80 COLUMNS?
	JN	H.CKBB			:BAD IF NOT
H.CKBG	XR	R0,R0			:INDICATE BIND IS OK
	JR	R5			:AND RETURN
H.CKBB	LIS	R0,1			:INDICATE BIND IS BAD
	JR	R5			:AND RETURN
	ELSE				:E/W ALT SWITCH IS OFF
H.CKBD	BBLSCB	R4,LUCTAB+LULSCB,R9,	:GET SCB POINTER
	LB	R0,SCBBLK+SCPSUF,R4,	:GET BYTE WITH LU TYPE
	NHI	R0,7F			:GET LU TYPE
	CLB	R0,LUCTAB+LUCTYP,R9,	:COMPARE WITH GEN LU TYPE
	JNFS	H.CKBB			:JUMP IF NO MATCH
	XR	R0,R0			:INDICATE BIND IS OK
	JR	R5			:AND RETURN
H.CKBB	LIS	R0,1			:INDICATE BIND IS BAD
	JR	R5			:AND RETURN
	EI

:::::::::::::::::::::::::::::::::::::::
:: THIS ROUTINE CONVERTS DSP STATUS CODE TO SNA STATUS CODE.
:: THE CODE WILL BE USED FOR LUSTAT ON LU-LU SESSION.
:: INPUT: R1 - DSP STATUS CODE.
:: OUTPUT: R1 - SNA STATUS CODE.
:: LINK:   R5
H.CVLL	LHI	R1,LUONSN		:PRESENTATION SPACE INTRGR LOST
	JR	R5			:RETURN

::::::::::::::::::::::::::::::::::::::
:: THIS ROUTINE CONVERTS DSP STATUS CODE TO SNA STATUS CODE
:: TO BE USED ON SSCP-LU SESSION.
:: INPUT: R1 - DSP STATUS CODE.
:: OUTPUT: R1 - SNA STATUS CODE.
:: LINK:    R5
H.CVSL	LHI	R1,LUONSN		:PRESENTATION SPACE INTGR LOST
	JR	R5			:RETURN

:	(5/15/85/CHS, START)

:	LOCAL WORKING AREA
:	-------------------
	SEG	A.DATA
CRSAV0	WS	1			:SAVE AREA FOR REG 0(1/28/86/CHS)
CRSAV3	WS	1			:SAVE AREA FOR REG 3(9/4/85/CHS)
CRSAV4	WS	1			:SAVE AREA FOR REG 4

	SEG	A.CODE

:	FNCRLN:	FIND CURSOR ROW # (LINE #)
:	-------
:	FIVEN CURSON ADDR, FIND THE ROW NUMBER
:	INPUT:	R2 - ADDR OF THE RQ(RU) MSG BB (1ST SEGMENT)
:	OUTPUT:	R0 = ROW NUMBER

FNCRLN
:
:	(9/4/85/CHS) START OF NEW CODE
	ST	R3,CRSAV3,,		:SAVE R3
	ST	R4,CRSAV4,,		:SAVE R4
	LB	R0,LUCTAB+LUCSYS,R9,	:SEE IF HITACHI
	CLHI	R0,HITACHI
	JN	FNCRLX			:NO, SKIP
	LB	R4,BBUFER+1,R2,		:GET 1ST BYTE OF CURSOR ADDR
	NHI	R4,1F			:5 BITS
	LB	R0,BBUFER+2,R2,		:GET 2ND BYTE OD CURSOR ADDR
	NHI	R0,3F			:6 BITS
	SLHLS	R0,5			:2ND BYTE - MOST SIGNIFICCANT
	J	FNCRLY			:TO CONTINUE
FNCRLX
	LB	R4,BBUFER+1,R2,		:GET 1ST BYTE OF CURSOR ADDR
	NHI	R4,3F			:NEED ONLY ESSENTIAL BITS
	SLHLS	R4,6			:SHIFT INTO PROPER PLACE(6/25/86/CHS)
	LB	R0,BBUFER+2,R2,		:GET 2ND BYTE OF CURSOR ADDR
	NHI	R0,3F			:NEED ONLY ESSENTIAL BITS(6/25/86/CHS)
FNCRLY
	OR	R4,R0			:COMBINE TO GET BYTE ADDR
	LHL	R3,LUCTAB+LUCDCB,R9,	:GET R3 = DCB
	LB	R3,DCBLKS+DCBFST,R3,	:CHECK SCREEN SIZE
	LO	BSUB
	NHI	R3,DEVFSZ
	FO	BSUB
	LHI	R0,$A40			:ASSUME SMALL SCREEN
	CLHI	R3,C480			:SMALL?
	JEFS	FNCRL1			:YES, SKIP
	LHI	R0,$A80			:ELSE, MUST BE LARGE SCREEN
FNCRL1
	LIS	R3,0			:CLEAR R3
	AIS	R4,1
	DR	R3,R0			:(BYTE-ADDR)/SIZE=ROW#
	LR	R0,R4			:R0=R4=ROW #
	L	R3,CRSAV3,,		:RESTORE R3
	L	R4,CRSAV4,,		:RESTORE R4
	JR	R4			:RETURN
:	(9/4/85/CHS) END OF NEW CODE

:	(5/15/85/CHS, END)

:THE FOLLOING SUBROUTINE GENERATES SCREEN CONTROL MESSAGE TO BE
:SENT TO THE TIF. THE MESSAGE EMULATES WRITE-TYPE COMMAND.
:THE FORMAT OF THE MESSAGE IS WSTCMD, SEQ#, SCREEN STATUS.
:THE MESSAGE IS INTERPRETED BY CORRESPONDING TIF (CMT). THE
:ROUTINE PASSES THE GENERATED MESSAGE TO NIO.
:INPUT: R4 - SEQ#,
:	R5 - SCREEEN STATUS (UNOWNED, SYSTEM, APPLICATION)
:LINK:	R6
:ALL REGISTERS ARE PRESERVED.
H.SNST	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	EXBR	R0,R4			:PUT SEQ # IN 2ND BYTE
	NHI	R5,07			:CONVERT THE INTERNAL STATUS CODE (03/10/86 YLH)
	LB	R5,STCVTB,R5		:INTO THE EXTERNAL STATUS CODE (03/10/86 YLH)
	OR	R0,R5			:COMBINE WITH SCREEN STATUS
	JAL	R4,GBB,,		:GET BUFFER FOR STATUS MESSAGE
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBR,,		:COUNT IT
	LHI	R4,WSTCMD		:GET WRITE STATUS CODE
	STB	R4,BBUFER+THDISP+FID2LG+3,R3,	:PUT IT IN BUFFERLET
	STH	R0,BBUFER+THDISP+FID2LG+4,R3,	:PUT THERE SEQ# AND STAT
	LIS	R2,FID2LG+6		:LENGTH OF STATUS MESSAGE
:IF WRITE STATUS IS THE RESULT OF BIND FROM HOST PUT
:PRESENTATION LAYER BIND PARMS AT THE END OF WRITE STATUS (02/25/87 MIA).
:CHECK ON SYS/RQ SUPPORT IS TEMPORARY (UNTIL CMT IS MODIFIED TO ACCEPT
:LONGER WRITE STATUS.
	LHL	R5,LUCTAB+LUCDCB,R9,	:GET DCB POINTTER
	LB	R5,DCBLKS+DCBRIF,R5,	:GET REMOTE DEVICE INFO
	LO	BSUB
	THI	R5,SNASRQ		:REMOTE SUPPORT FOR SYS/RQ?
	FO	BSUB
	JE	H.SNS2			:JUMP IF NOT
	XHI	R0,HSTINI!LUSAPL	:BIND FROM HOST?
	NHI	R0,3F3F			:LEAVE MEANINGFUL BITS ONLY
	JN	H.SNS2			:JUMP IF NOT BIND
	LHI	R5,SCPSLG		:PRESENATION LAYER LENGTH
:	STB	R5,BBUFER+THDISP+FID2LG+5,R3,	:PUT IT IN WS BUFFER
	STB	R5,BBUFER+THDISP+FID2LG+6,R3,	:PUT IT IN WS BUFFER
	BBLOAD	R4,BBUFER+MURUPT,R10,	:POINT TO BIND RU
H.SNS1	LB	R6,BBUFER+SCPSUG-SCFMPF+2,R4,R5	:GET NEXT BYTE OF PRSNT LAYER
:	STB	R6,BBUFER+THDISP+FID2LG+5,R3,R5	:COPY IT IN WS BUFFER
	STB	R6,BBUFER+THDISP+FID2LG+6,R3,R5	:COPY IT IN WS BUFFER
	SIS	R5,1			:DECREASE MSG COUNTER
	JGBS	H.SNS1			:COUNTINUE UNTIL FINISHED
	AHI	R2,SCPSLG+1		:ADJUST WS LENGTH
H.SNS2	EQ	.
:END OF INSERTION (02/25/87 MIA).
	LHI	R0,SNETEM^8!SNDTCD	:END-TO-END MESSAGE
	JAL	R5,L.PTCD		:PASS IT TO NIO
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	JR	R6			:AND RETURN
:
:	INTERNAL TO EXTERNAL SCREEN STATUS CONVERSION TABLE
:
STCVTB	BC	40,0C1,0C2,0C3,0C4

	EI

	IF	HOSTIF

::::::::::::::::::::::::::::::::::::::
:: THIS ROUTINE GENERATES DUMMY (RH-ONLY) FMD TO BE SENT TO THE HOST.
:: R10 CONTAINS MUCB FOR THIS MESSAGE. DESTINATION 0 (SSCP) IS GENERATED.
:: LINK ON R5.
H.GNDS	STM	R0,LURGSV,,		:PRESERVE ALL REGISTERS
	JAL	R4,GBB,,		:OBTAIN BUFFERLET FOR MUCB
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LR	R10,R3			:COPY BUFFERLET POINTER
	LIS	R4,SENT			:INDICATE SEND DIRECTION
	STB	R4,BBUFER+MUDIRE,R10,	:STORE IT IN MUCB
	LB	R5,LUCTAB+LUCADR,R9,	:GET ADDR OF SEC
	STB	R5,BBUFER+MUOADP,R10,	:STORE IT IN MUCB
	XR	R5,R5			:PRIMARY IS SSCP
	STB	R5,BBUFER+MUDADP,R10,	:STORE IT IN MUCB
	STB	R5,BBUFER+MUSCHK,R10,	:CLEAR SENSE-CHECK
	LHI	R5,FID2^4!MU.BIU!MU.EIU	:FID2 AND 1 SEGMENT
	STB	R5,BBUFER+MUBIUF,R10,	:1ST BYTE OF TH
	LHI	R5,MU.BCI!MU.ECI	:FMD AND 1 CHAIN
	STB	R5,BBUFER+MURHF1,R10,	:1ST BYTE OF RH
:	LHI	R5,MU.DR1		:DEF RSP (8/17/84/CHS)
	LHI	R5,MU.DR1!MU.ERI	:EXP DSP (8/17/84/CHS)
	STB	R5,BBUFER+MURHF2,R10,	:2ND BYTE OF RH
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MURHF3,R10,	:3RD BYTE OF RH
	LIS	R5,3			:LENGTH OF RH
	STH	R5,BBUFER+MUDCF,R10,	:STORE IT IN MUCB
	JAL	R4,GBB,,		:AQUIRE BUFFERLET FOR MSG
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	BBSTOR	R3,BBUFER+MUCBTU,R10,	:STORE BTU POINTER IN MUCB
	AIS	R3,FID2LG+3		:POINT TO DUMMY RU
	BBSTOR	R3,BBUFER+MURUPT,R10,	:STORE IT IN MUCB
	ST	R10,LURGSV+28,,		:UPDATE R10 SAVE AREA
	LM	R0,LURGSV,,		:RETORE ALL REGISTERS
	JR	R5			:AND RETURN

	EI

	IF	HDPSUP

:::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: THE FOLLOWING ROUTINE IS USED FOR LOCAL COPY FUNCTION IN VIRTUAL
:: DSP MODE. IT TRIES TO FIND AN LU OF TYPE 3 WHICH MATCHES
:: THE HOST # AND CU OF THE TIF WHOSE CRT USER REQUESTED A LOCAL
:: COPY. IF THIS PRINTER IS NOT BUSY, BSC 3270 COPY COMMAND IS
:: GENERATED AND SENT ON THE VIRTUAL CIRCUIT WITH THIS PRINTER.
:: EXPECTS POINTER TO LUCTAB OF CRT LU ON R9.
:: RETURN CODE ON R0: 0 - PRINTER FOUND, 1 - PRINTER FOUND BUT BUSY,
::   2 - PRINTER NOT FOUND.
:: LINK REGISYER - R5.
:::::::::::::::::::::::::::::::::::::::::::::::::::::::
H.ASGN	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	XR	R1,R1			:PREPARE RETURN CODE
	LHI	R10,NPORT-1		:INIT PORT SEARCH LOOP
	LHL	R12,LUCTAB+LUCDCB,R9,	:POINT TO CRT DCB

:IF PORT IS ACTIVE MATCH ORIGINATION HOST AND CU.
H.ASG1	LHL	R11,PORTAB,R10,R10	:GET DCB FOR THE PORT
	CHI	R11,DUMDCB		:NO VIRTUAL CIRCUIT?
	JE	H.ASG4			:JUMP IF SO
	LH	R0,DCBLKS+DCBRHT,R12,	:GET CRT ORIGIN HOST
	CLH	R0,DCBLKS+DCBRHT,R11,	:COPMARE WITH SEARCH HOST
	JN	H.ASG4			:NEXT PORT IF NO MATCH
	LB	R0,DCBLKS+DCBRCU,R12,	:GET CRT ORIGIN CU
	CLB	R0,DCBLKS+DCBRCU,R11,	:COMPARE WITH SEARCH CU
	JN	H.ASG4			:NEXT PORT IF NO MATCH

:CHECK IF DCB IS IN DSP MODE.
	LIS	R0,D.BDSP		:POINT TO DSP BIT
	TBT	R0,DCBLKS+DCBMOD,R11,	:CHECK DCB MODE
	JE	H.ASG4			:JUMP IF NOT DSP

:CHECK THAT DEVICE IS PRINTER.
	LHL	R8,DCBLKS+DCBLUC,R11,	:GET SEARCH DEVICE LUCB
	JE	H.ASG4			:JUMP IF NOT ATTACHED
	LB	R0,LUCTAB+LUCTYP,R8,	:GET SEARCH DEVICE TYPE
					:(F00/02/23/87/DB/START)
	CHI	R0,LU.T1		:TYPE 1?
	JEFS	H.ASG6			:YES
					:(F00/02/23/87/DB/END)
	CHI	R0,LU.T3		:TYPE 3?
	JN	H.ASG4			:NEXT PORT IF SO

:IF LABELS ARE DEFINED MATCH THE PRINTER LABEL WITH THE CRT LABEL.
:	IF	LABLSW
:	LB	R0,LUCTAB+LUCLAB,R9,	:GET CRT LABEL (09/25/86 YLH)
:	CLB	R0,LUCTAB+LUCLAB,R8,	:COMPARE WITH PRINTER LABEL (09/25/86 YLH)
:	JN	H.ASG4			:NEXT PORT IF NO MATCH (09/25/86 YLH)
:	EI

:FIND OUT IF PRINTER IS BUSY (BETWEEN-BRACKET PRINTER SHARING IS
:ASSUMED).
H.ASG6					:(F00/02/23/87/DB)
	BBLSCB	R7,LUCTAB+LULSCB,R8,	:GET LU-LU SCB POINTER
	JEFS	H.ASG2			:PRINTER NOT BUSY IF NO SESSION
	LB	R0,SCBBLK+SCSTAT+FSCBFP,R7,	:GET FSM-BSM-FSP
	CHI	R0,FS.ST1		:BETWEEN BRACKETS?
	JN	H.ASG5			:PRINTER BUSY IF NOT

:FOUND A PRINTER. GENERATE BSC 3270 COPY COMMAND AND PASS IT TO NIO.
H.ASG2	JAL	R4,GBB,,		:GET BUFFER FOR COPY CMD
	J	NOBUFF			:JUMP IF NONE AVAILBALE
	JAL	R4,R.GBR,,		:COUNT IT
	LHI	R0,CPCMD		:PREPARE COPY CMD
	STB	R0,BBUFER+FID2LG+3,R3,	:PUT IT IN THE BUFFER
	LHI	R0,CCCODE		:PREPARE COPY CONTROL CODE
	STB	R0,BBUFER+FID2LG+4,R3,	:PUT IT IN THE BUFFER
	LB	R0,DCBLKS+DCBRLU,R12,	:GET CRT SOURCE DEV ID
	STB	R0,BBUFER+FID2LG+5,R3,	:PUT IT IN THE BUFFER
	LR	R9,R8			:POINT TO PRINTER LUCB
	LHI	R0,SNETEM^8!SNDTCD	:END-TO-END MESSAGE AND CD
	LIS	R2,FID2LG+3+3		:LENGTH OF COPY MESSAGE
	JAL	R5,L.PTCD		:PASS CMD TO NIO
	XR	R0,R0			:0 RETURN CODE

:RESTORE ALL REGISTERS EXCEPT RETURN CODE (R0) AND RETURN.
H.ASG3	LM	R1,LURGSV+4,,		:RESTORE ALL REGISTERS BUT R0
	JR	R5			:AND RETURN

:TRY NEXT PORT.
H.ASG4	SIS	R10,1			:GET NEXT PORT
	JGE	H.ASG1			:TRY IT UNTIL FINISHED

:GENERATE RETURN CODE.
	LR	R0,R1			:COPY THE REGISTER
	JNBS	H.ASG3			:RETURN CODE 1 IF SOME PRINTER BUSY
	LIS	R0,2			:RETURN CODE 2 IF NO PRINTER
	JBS	H.ASG3			:JUMP TO CONTINUE

:NOTE THAT THERE IS A PRINTER WHICH IS BUSY AND TRY TO FIND ANOTHER ONE.
H.ASG5	LIS	R1,1			:SHOW THAT SOME PRINTER IS BUSY
	JBS	H.ASG4			JUMP TO CONTINUE

:::::::::::::::::::::::::::::::::::::::::::::::
:: THE FOLLOWING ROUTINE CHECKS THE DATA STREAM FOR LU TYPE 2 TO SEE
::  WHETHER THE HOST REQUESTED THE LOCAL COPY FUNCTION.
:: THIS REQUEST IS REFLECTED IN WCC BYTE OF 3270 WRITE TYPE COMMAND
::  BY TURNING ON THE START PRINTER BIT.
:: THIS BIT COULD ALSO BE TURNED ON IN THE LAST WRITE TYPE STRUCTURED
::  FIELD IF THE COMMAND IS WRITE STRUCTURED FIELD.
:: IF LOCAL COPY REQUEST WAS DISCOVERED THE STATUS BITS IN LUADCB
::  ARE TURNED ON. LUADCB IS ALSO USED TO SAVE OTHER INFORMATION
::  RELATED TO LOCAL COPY FUNCTION. SEE THE STRUCTURE OF LUADCB FOR
::  ADDITIONAL INFORMATION.
:: EXPECTS LUCB POINTER ON R9.
:: ALL REGISTERS PRESERVED, LINK ON R5.
:::::::::::::::::::::::::::::::::::::::::::::::::
H.WCPT	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
	CHI	R5,LU.T2		:TYPE 2?
	JN	H.WCPE			:JUMP TO EXIT IF NOT

:FIND OUT IF THIS IS THE FIRST SEGMENT OF RU CHAIN.
	LHL	R4,BBUFER+MUDCF,R10,	:PREPARE DATA COUNT
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.BIU		:1ST SEGMENT?
	JE	H.WCP5			:JUMP IF NOT
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.BCI		:1ST IN CHAIN?
	JE	H.WCP4			:JUMP IF NOT

:THIS IS THE FIRST SEGMENT OF RU CHAIN. CHECK 3270 DATA STREAM COMMAND
:CODE FOR WRITE STRUCTURED FIELD OR OTHER WRITE TYPE COMMAND.
	BBLOAD R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R0,BBUFER,R5,		:GET 3270 COMMAND CODE
	CHI	R0,WSFCMD		:WRITE STRUCTURED FIELD?
	JE	H.WCPF			:JUMP IF SO
	CHI	R0,WCMD			:WRITE COMMAND?
	JEFS	H.WCP1			:JUMP IF SO
	CHI	R0,EWCMD		:ERASE/WRITE?
	JEFS	H.WCP1			:JUMP IF SO
	CHI	R0,EAUCMD		:ERASE/WRITE ALTERNATE?
	JN	H.WCP2			:JUMP OF NOT WRITE TYPE

:THIS IS A WRITE TYPE COMMAND. CHECK WCC FOR START PRINTER.
: IF THE BIT IS ON, TURN IT OFF, BUT SHOW IT IN LUADCB PRINTER STATE.
H.WCP1	LB	R0,BBUFER+1,R5,		:GET WCC
	THI	R0,WCCSPT		:START PRINTER?
	JEFS	H.WCP2			:JUMP IF NOT
	NHI	R0,@WCCSPT		:TURN OFF START PRINTER
	STB	R0,BBUFER+1,R5,		:UPDATE WCC
	LHI	R4,LUSPRT		:PREPARE START PRINTER STATE
	JFS	H.WCP3			:JUMP TO CONTINUE
H.WCP2	XR	R4,R4			:CLEAR PRINTER STATE
H.WCP3	STH	R4,LUCTAB+LUADCB,R9,	:UPDATE PRINTER STATE

:RESTORE REGISTERS AND RETURN.
H.WCPE	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	JR	R5			:AND RETURN

:1ST SEGMENT BUT NOT 1ST CHAIN.
H.WCP4	SIS	R4,3			:ADJUST DATA COUNT
	LIS	R6,8			:DISPLACEMENT OF RU - 1
	JFS	H.WCP6			:JUMP TO CONTINUE

:NOT THE 1ST SEGMENT.
H.WCP5	LIS	R6,5			:DISPLACEMENT OF RU - 1

:INIT MORE REGISTERS.
H.WCP6	XR	R8,R8			:INIT DATA COUNT
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:INIT BUFFER POINTER

:IF THE 3270 COMMAND WAS NOT WRITE STRUCTURED FIEILD THEN RETURN.
:OTHERWISE JUMP TO A PRINTER STATE PROCESSING ROUTINE.
	LHL	R5,LUCTAB+LUADCB,R9,	:GET PRINTER STATE INFO
	LR	R7,R5			:COPY IT
	NHI	R5,WSFLGT		:CLEAR EVERYTHING BUT WSF LNGTH
	JE	H.WCPE			:RETURN IF NOT WSF
	SRLS	R7,0D			:MAKE STATE INDEX
	LHL	R2,H.WCTB,R7,R7		:GET STATE PROCESSING ROUTINE
	J	L.BASE,R2		:JUMP TO PROCESSING ROUTINE

:PRINTER STATE JUMP TABLE.
H.WCTB	HC	H.WCS0-L.BASE		:STATE 0 ROUTINE
	HC	H.WCS1-L.BASE		:STATE 1 ROUTINE
	HC	H.WCS2-L.BASE		:STATE 2 ROUTINE
	HC	H.WCS3-L.BASE		:STATE 3 ROUTINE
	HC	H.WCS4-L.BASE		:STATE 4 ROUTINE
	HC	H.WCS5-L.BASE		:STATE 5 ROUTINE

:FOLLWOING REGISTERS ARE USED IN THE WSF STATE PROCESSING ROUTINES:
:R4 - SNA DCF, R3 - CURRENT BUFFERLET POINTER, R6 - CURRENT BUFFERLET INDEX,
:R5 - REMAINDER OF LENGTH OF STRUCTURED FIELD + 1, R8 - CURRENT DATA COUNT,
:R7 - WSF STATE.

:STATE 0. LOOKING FOR THE FIRST BYTE OF THE NEXT STRUCTURED FIELD.
H.WCS0	LR	R2,R8			:COPY DATA COUNT
	AR	R2,R5			:BYTE NUMBER + 1 FOR NEXT LENGTH
	SR	R2,R4			:COMPARE WITH SNA DCF
	JLEFS	H.WCSA			:JUMP IF WITHIN THIS BUFFER CHAIN
	LR	R5,R2			:COPY REMAINING BYTE NUMBER
	J	H.WCSE			:JUMP TO SAVE STATE FOR NEXT MSG
H.WCSA	AR	R6,R5			:FIND INDEX FOR LENGTH BYTE
	SIS	R5,1			:FIND REMAINING LENGTH
	AR	R8,R5			:UPDATE DATA COUNT
H.WCSB	CHI	R6,BBFLSZ-BBFPSZ	:COMPARE WITH USEFUL BUF SIZE
	JLEFS	H.WCSC			:JUMP IF WITHIN THIS BUFFERLET
	SHI	R6,BBFLSZ-BBFPSZ	:SUBTRACT USEFUL BUFFER SIZE
	BBLOAD	R3,BBUFER+BBFLSZ-BBFPSZ,R3,	:GET NEXT BUFFER POINTER
	JBS	H.WCSB			:JUMP TO CONTINUE
H.WCSC	LB	R5,BBUFER,R3,R6,	:GET FIRST BYTE OF LENGTH
	J	H.WCSG			:JUMP TO GO TO NEXT STATE

:STATE 1. FOUND 1ST CHARACTER OF THE LENGTH WHICH IS ON R5.
:NEXT CHARACTER WILL BE THE 2ND CHARACTER OF THE LENGTH.
H.WCS1	JAL	R2,H.WCNB		:GET NEXT CHAR FROM THE BUFFER
	EXBR	R5,R5			:POSITION FIRST CHAR OF THE LENGTH
	OR	R5,R0			:MERGE THE 2CH CHAR INTO LENGTH
	J	H.WCSN			:JUMP TO GO TO NEXT STATE

:STATE 2. NEXT CHARACTER WILL BE STRUCTERED FIELD ID.
:THE ID OF INTEREST IS OUTBOUND 3270DS.
H.WCS2	JAL	R2,H.WCNB		:GET NEXT CHAR FROM THE BUFFER
	CHI	R0,OUTWSF		:OUTBOUND 3270DS?
	JEFS	H.WCSD			:JUMP IF SO
	LIS	R7,LUSPS5^(-0D)		:PRETEND WE ARE IN STATE5
H.WCSD	J	H.WCSN			:JUMP TO GO TO NEXT STATE

:STATE 3 OR 4. NEXT IS PID OR CMND. WE DO NOT NEED THEM.
H.WCS3
H.WCS4	JAL	R2,H.WCNB		:GET NEXT CHAR FROM THE BUFFER
	J	H.WCSN			:JUMP TO GO TO NEXT STATE

:STATE 5. NEXT CHARACTER WILL BE WCC. IF START PRINTER BIT IS ON
:GO TO STATE 7 (START PRINTER), TURN OFF THE BIT AND STOP SCANNING.
H.WCS5	JAL	R2,H.WCNB		:GET NEXT CHAR FROM THE BUFFER
	THI	R0,WCCSPT		:START PRINTER?
	JE	H.WCSN			:CONTINUE SCANNING IF NOT
	NHI	R0,@WCCSPT		:TURN OFF START PRINTER
	STB	R0,BBUFER,R3,R6		:UPDATE WCC
	LHI	R4,LUSPRT		:PREPARE SATRT PRINTER STATE
	J	H.WCP3			:JUMP TO STOP SCANNING

:END OF PROCESSING FOR WSF STATE ROUTINES.
:GO NO NEXT STATE AND ADVANCE ALL POINTERS.
H.WCSN	SIS	R5,1			:ONE CHAR LESS REMAINED IN LENGTH
H.WCSG	AIS	R8,1			:ONE MORE CHAR PROCESSED
	CR	R8,R4			:REACHED THE END OF DATA?
	JEFS	H.WCSE			:JUMP TO SAVE STATE INFO IF SO
	AIS	R7,1			:INCREASE STATE NUMBER
	CHI	R7,LUSPS6^(-0D)		:REACHED THE LIMIT?
	JNFS	H.WCSF			:JUMP IF NOT
	XR	R7,R7			:RETURN TO STATE 0
H.WCSF	LHL	R2,H.WCTB,R7,R7		:GET NEXT STATE ROUNTINE POINTER
	J	L.BASE,R2		:JUMP TO PROCESSING ROUTINE

:END OF SNA DATA MESSAGE. SAVE STATE AND LENGTH INFORMATION AND RETURN.
H.WCSE	SLLS	R7,0D			:SHIFT STATE INTO PROPER POSITION
	OR	R7,R5			:MERGE REMAINDER OF LENGTH
	STH	R7,LUCTAB+LUADCB,R9,	:SAVE IT IN LUCB
	J	H.WCPE			:JUMP TO RETURN

:BEGINNING OF WSF PROCESSING. INIT REGISTERS, OBTAIN LENGTH OF THE 1ST
:STRUCTURED FIELD AND ENTER WSF PROCESSING STARTING FROM ID BYTE.
H.WCPF	SIS	R4,3			:ADJUST WSF FOR RH LENGTH
	LIS	R6,0B			:POINT BUFFER INDEX TO ID - 1
	LIS	R8,3			:1ST 3 CHARS ALREADY PROCESSED
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:INIT BUFFER POINTER
	LHL	R5,BBUFER+0A,R3,	:GET LENGTH OF 1ST FIELD
	SIS	R5,1			:REMAINING LENGTH + 1
	LIS	R7,LUSPS2^(-0D)		:START FROM STATE 2
	J	H.WCS2			:JUMP TO PROCESSING ROUTINE

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: THIS ROUTINE FETCHES THE NEXT CHARACTER FROM THE BUFFERLET
::  CHAIN.
:: EXPECTS CURRENT BUFFERLET POINTER ON R3 AND CURRENT DISPLACEMENT
::  WITHIN THE BUFFERLET ON R6.
:: NEXT CHARACTER IS ON R0, R6 AND R3 ARE ADVANCED.
:: LINK ON R2.
H.WCNB	AIS	R6,1			:ADVANCE BUFFER INDEX
	CHI	R6,BBFLSZ-BBFPSZ	:END OF BUFFER?
	JNFS	H.WCN1			:JUMP IF NOT
	XR	R6,R6			:START FROM THE BEGINNING
	BBLOAD	R3,BBUFER+BBFLSZ-BBFPSZ,R3,	:POINT TO NEXT BUFFER
H.WCN1	LB	R0,BBUFER,R3,R6		:FETCH NEXT CHARACTER
	JR	R2			:RETURN

	EI

	IF	VHRSUP

::::::::::::::::::::
:: THE FOLLOWING ROUTINE CREATES RESPONSE FOR MESSAGE OF SC CATEGORY.
:: FIRST MUCB IS CREATED FOR RQ AND THEN L.GNRP IS CALLED TO GENERATE RSP.
:: EXPECTS: R9 - POINTER TO LUCB,
::	    R7 - POINTER TO SCB,
::	    R1 - RQ CODE,
::	    R0 - SENSE CODE (0 IN CASE OF +RSP).
:: LINK:    R8
:::::::::::::::::::::
L.GNSR	ST	R7,LURGSV,,		:SAVE SCB POINTER
	JAL	R4,GBB,,		:OBTAIN BUFFERLET FOR MUCB OF RQ
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	LR	R10,R3			:COPY MUCB POINTER
	L	R7,LURGSV,,		:RESTORE SCB POINTER
	LB	R4,SCBBLK+SCOTID,R7,	:GET OTHER LU ID
	STB	R4,BBUFER+MUOADP,R10,	:STORE IT ORIGIN FIELD
	LB	R4,SCBBLK+SCMYID,R7,	:GET THIS LU ID
	STB	R4,BBUFER+MUDADP,R10,	:STORE IT IN DEST FIELD
	LHI	R4,FID2^4!MU.BIU!MU.EIU!MU.EFI	:GET 1ST BYTE OF TH
	STB	R4,BBUFER+MUBIUF,R10,	:STORE IT IN MUCB
	LHL	R4,SCBBLK+SCRESN,R7,	:GET SEQUENCE NUMBER
	STH	R4,BBUFER+MUSNF,R10,	:PUT IN SNF IN MUCB
	LHI	R4,MU.SC!MU.FI!MU.BCI!MU.ECI	:SC CATEGORY, BC&EC
	STB	R4,BBUFER+MURHF1,R10,	:STORE IN 1ST BYTE OF RH
	LHI	R4,MU.DR1		:DEFINITE RESPONSE
	STB	R4,BBUFER+MURHF2,R10,	:STORE IN 2ND BYTE OF RH
	JAL	R5,L.GNRP		:GENERATE RSP
	JR	R8			:AND RETURN
	EI

	FO	MAIN
	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER

	EM
 	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN

:::::::::::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS A CODE TO SUPPORT RECEIVE SIDE
:: FOR LU SEVICE MANAGER IN DSP MODE.
:::::::::::::::::::::::::::::::::::::::::::::::

	IF	HDPSUP

	SEG	A.CODE

:
:FIRST SEPARATE TERMINAL MESSAGES FROM NOTIFICATIONS FOR PREVIOUSLY
:GENERATED REQUESTS AND RESPONSES.
H.RCDP	LB	R5,BBUFER+MUDIRE,R10,	:GET MU DIRECTION
	CHI	R5,SENT			:IS IT NOTIFICATION?
	JE	H.RDNT			:JUMP IF SO
:
:BEGIN (06/17/86 YLH)
:
:IF EXCEPTIONAL REQUEST RECEIVED, THE WHOLE CHAIN IS DISCRADED.
:THE 1ST BIT OF THE DSP SUBSTATE (THE 4TH BIT OF THE LU SERVICE
:MANAGER STATE BYTE) IS THE EXCEPTIONAL REQUEST RECEIVED INDICATOR.
:
	LB	R5,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	THI	R5,LUDPER		:EXCEPTIONAL REQUEST RECEIVED?
	JE	H.RCDC			:NO, CONTINUE
	LB	R5,BBUFER+MUBIUF,R10,	:YES, GET 1ST BYTE OF THE TH
	THI	R5,MU.BIU		:1ST SEGMENT OF A NEW CHAIN?
	JE	H.RCD1			:NO, DISCARD IT
	LB	R5,BBUFER+MURHF1,R10,	:YES, GET 1ST BYTE OF THE RH
	THI	R5,MU.CTG		:ONLY FMD RU_CTGY IS INTERESTED
	JN	H.RCDC
	THI	R5,MU.BCI		:BEGINNING OF A CHAIN?
	JE	H.RCD1			:NO, DISCARD IT
	LB	R5,LUCTAB+LULUST,R9,	:YES, CLEAR THE EXR INDICATOR
	NHI	R5,@LUDPER
	STB	R5,LUCTAB+LULUST,R9,	:STORE BACK TO THE LU_SVC BYTE
H.RCDC	EQ	.			:AND CONTINUE
:
:END (06/17/86 YLH)
:
:IF A MULTISEGMENT MESSAGE RECEIVED WE ASSUME THAT IT IS PART OF
:FMD. THE RECEPTION
:OF THE LAST SEGMENT MAY REQUIRE SENDING BACK A REPSONSE (AS
:INDICATED IN FIRST SEGMENT AND REFLECTED IN LUSVC WORK BYTE
:BY PENDING REPSONSE BITS).
:
:FIRST CHECK IF IT WAS THE 1ST SEGMENT.
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.BIU		:IS IT 1ST SEGMENT?
	JN	H.RCD6			:JUMP IF SO

:NOT THE FIRST SEGMENT. IF IT IS ALSO NOT THE LAST SIMPLY
:PASS IT TO NIO IF LU-LU. FOR SSCP-LU CONVERT TO 3270 AND PASS TO NIO
:IF LU-LU SESSION DOES NOT EXIST AND DISCARD IF IT EXISTS.
:THIS RULE IS TRUE IF TIF DOES NOT SUPPORT SCREEN STATUS.
:IF TIF SUPPORTS IT (LATEST VERSIONS OF CMT) LU-LU SEGMENT IS
:PASSED TO TIF IF SCREEN STATUS IS APPL. SSCP-LU IS CONVERTED
:TO 3270 AND PASSED TO TIF IF SCREEN STATUS IS SYS.
:OTHERWISE THE SEGMENT IS DISCARDED, -RSP(LU BUSY) IS SENT TO HOST
:AND CLEANING MODE IS ENTERED.
	XR	R4,R4			:PREPARE FOR NO RESPONSE
	THI	R5,MU.EIU		:IS IT THE LAST SEGMENT?
	JN	H.RCD2			:JUMP IF SO
	LB	R0,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS BYTE
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGIN ADDR
	JE	H.RCDZ			:JUMP IF SSCP-LU

:INTERMEDIATE SEGMENT FOR LU-LU.
	NHI	R0,@LUCLCP&@LUSCOP&@LUSSOP :DISREGARD SSCP-LU CLEANING
	JE	H.RCD0			:JUMP IF NO SCREEN CONTROL
	CHI	R0,LUSCRN!LUSAPL	:APPL AND NO CLEANING?
	JE	H.RCD0			:SEND IT OVER IF SO
	LB	R0,LUCTAB+LUCSCN,R9,	:OTHERWISE GET SCREEN STATE
	OHI	R0,LUCLLU		:START CLEANING LU-LU
	STB	R0,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATE
	J	H.RCD1			:JUMP TO DISCARD IT

:INTERMEDIATE SEGMENT FOR SSCP-LU.
H.RCDZ	NHI	R0,@LUCLLU&@LUSCOP&@LUSSOP :DISREGARD LU-LU CLEANING
	JEFS	H.RCDX			:JUMP IF NOT SCREEN CONTROL
	CHI	R0,LUSCRN!LUSSYS	:SYS AND NO CLEANING?
	JE	H.RCDY			:SEND IT OVER IF SO
	LB	R0,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS
	OHI	R0,LUCLCP		:INDICATE CLEANING FOR SSCP-LU
	STB	R0,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	J	H.RCD1			:JUMP TO DISCARD IT
H.RCDX	BBLSCB	R5,LUCTAB+LULSCB,R9,	:GET PTR TO LU-LU SCB
	JNFS	H.RCD1			:JUMP IF VALID
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
	CHI	R5,LU.T3		:TYPE 3?
	JEFS	H.RCD1			:RELEASE MSG&MUCB IF SO
					:(F00/02/23/87/DB)
	CHI	R5,LU.T1		:TYPE 1?
	JEFS	H.RCD1			:YES, RELEASE MSG&MUCB
					:(F00/02/23/87/DB)
H.RCDY	JAL	R5,H.CVRT		:CONVERT THE MESSAGE TO 3270
H.RCD0	LIS	R0,SNDTIS		:INDICATE INTERMEDIATE SEGMENT
	J	H.RDFE			:JUMP TO CONTINUE
H.RCD1	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG SEGMENT
	JAL	R5,R.PBRC,,		:RELEASE BUF CHAIN
	LR	R3,R10			:COPY PTR TO MUCB
	JAL	R4,PBB,,		:RELEASE BUF WITH MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:LAST SEGMENT BUT NOT THE FIRST SEGMENT. CHECK IF THE REPONSE IS
:PENDING AND ISSUE IT IF NECESSARY. SEGMENT ITSELF IS PASSED TO NIO OR
:DISCARDED DEPENDING ON WHETHER IT WAS LU-LU OR SSCP-LU AND WHETHER
:LU-LU SESSION EXISTS. IF SCREEN STATUS IS SUPPORTED BY TIF THE
:DECISION IS MADE ON THE BASIS OF SCREEN STATUS.
:ALSO PUT IN MUCB RH BYTES 1 AND 2 SAVED IN LUCB.
H.RCD2	LB	R5,LUCTAB+LULUW2,R9,	:GET SAVED RH1 AND RH2 INFO
	LR	R4,R5			:COPY IT
	NHI	R5,0F0			:LEAVE FIRST NIBBLE ONLY
	THI	R5,40			:QRI IN REQUEST?
	JEFS	H.RCDA			:JUMP IF NOT
	OHI	R5,MU.QRI		:PUT QRI IN THE RIGHT PLACE
H.RCDA	NHI	R4,MU.BCI!MU.ECI 	:SEPARATE RH BYTE 1 INFO
	STB	R4,BBUFER+MURHF1,R10,	:PUT IT IN MUCB
	NHI	R5,MU.DR1!MU.DR2!MU.QRI	:SEPARATE RH BYTE 2 INFO
	STB	R5,BBUFER+MURHF2,R10,	:PUT IT IN MUCB
	LB	R5,BBUFER+MUOADP,R10,	:GET DESTINATION ADDR
	JE	H.RCD3			:FOR SSCP-LU ALWAYS RSP

:LAST SEGMENT FOR LU-LU.
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS
	LR	R0,R5			:COPY IT
	NHI	R5,@LUCLCP&@LUSCOP&@LUSSOP :DISREGARD SSCP-LU CLEANING
	JEFS	H.RCDV			:JUMP IF NO SCREEN CONTROL
	CHI	R5,LUSCRN!LUSAPL	:SCREEN CONTROL AND APPL?
	JEFS	H.RCDV			:SEND OT OVER IF SO
	OHI	R0,LUCLLU		:INDICATE LU-LU CLEANING
	STB	R0,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	J	H.RCD7			:JUMP SO DISCARD AND SEND -RSP
H.RCDV	LIS	R0,SNDTLS		:INDICATE LAST SEGMENT(8/16/84/CHS)
	LIS	R4,0			:ASSUME NO RSP (8/16/84/CHS)
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULURP		:IS REPONSE PENDING?
	JE	H.RDFE			:JUMP TO CONTINUE IF NOT
H.RCD5	LR	R4,R5			:COPY LUSVC WIRK BYTE
	NHI	R4,LULURP!LULUNG	:LEAVE RSP BITS ONLY
	NHI	R5,@LULURP&@LULUNG	:CLEAR PEND RSP BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LIS	R0,SNDTLS		:INDICATE LAST SEGMENT
	J	H.RDFE			:JUMP TO CONTINUE

:LAST SEGMENT FOR SSCP-LU.
H.RCD3	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS
	LR	R0,R5			:COPY IT
	NHI	R5,@LUCLLU&@LUSCOP&@LUSSOP :DISREGARD LU-LU CLEANING
	JEFS	H.RCDU			:JUMP IF NO SCREEN CONTROL
	CHI	R5,LUSCRN!LUSSYS	:SCREEN CONTROL AND SYS?
	JE	H.RCD4			:SEND IT OVER IF SO
	OHI	R0,LUCLCP		:OTHERWISE INDICATE SSCP-LU CLEANING
	STB	R0,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	JFS	H.RCD7			:JUMP TO SEND -RSP
H.RCDU	BBLSCB	R5,LUCTAB+LULSCB,R9,	:GET SCB POINTER
	JEFS	H.RCD4			:JUMP IF NOT VALID
H.RCD7	LHI	R0,LUBYSN		:PREPARE BUSY SENSE CODE
H.RCD9	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG SEGMENT
	JAL	R5,R.PBRC,,		:RELEASE BUF WITH MSG SEG
	J	H.RDF9			:KEEP MUCB FOR RSP
H.RCD4	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
					:(F00/02/23/87/DB/START)
	CHI	R5,LU.T1		:TYPE 1?
	JEFS	H.RC10			:YES
					:(F00/02/23/87/DB/END)
	CHI	R5,LU.T3		:TYPE 3?
	JNFS	H.RCDB			:JUMP IF NOT
H.RC10					:(F00/02/23/87/DB)
	LHI	R0,LUNSSN		:OTHERWISE CATEGORY NOT SUP
	J	H.RCD9			:JUMP TO DISCARD
H.RCDB	JAL	R5,H.CVRT		:CONVERT MSG TO 3270
	LHI	R5,MU.BCI!MU.ECI	:PREPARE 1ST BYTE OF RH FOR RSP
	STB	R5,BBUFER+MURHF1,R10,	:STORE IT IN MUCB
	LHI	R5,MU.DR1		:PREPARE 2ND BYTE OF RH FOR RSP
	STB	R5,BBUFER+MURHF2,R10,	:STORE IT IN MUCB
	LHI	R5,LULURP		:PREPARE FOR +RSP
	J	H.RCD5			:JUMP TO CONTINUE

:FIRST SEGMENT OF A MESSAGE. EXAMINE RH AND VECTOR EXECUTION
:DEPENDING ON RU CATEGORY.
H.RCD6	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH

:FIRST CHECK IF IT WAS EXCEPTION REQUEST. REPLY WITH -RSP IF SO.
	THI	R5,MU.RRI		:RSP?
	JN	H.RCD8			:JUMP IF SO
	THI	R5,MU.SDI		:SENSE-DATA INCLUDED?
	JE	H.RCD8			:JUMP IF NOT
					:(f02/12/16/87/db/start)
	LB	R5,BBUFER+MURHF2,R10,	:GET RTI INDICATOR
	OHI	R5,MU.RTI		:SET RTI INDICATOR
	STB	R5,BBUFER+MURHF2,R10,	:...
					:(F02/12/16/87/DB/END)
	LB	R5,LUCTAB+LULUST,R9,	:IF IT IS AN EXCEPTIONAL REQUEST  (06/17/86 YLH)
	OHI	R5,LUDPER		:SET THE EXR INDICATOR BIT IN (06/17/86 YLH)
	STB	R5,LUCTAB+LULUST,R9,	:LU_SVC (06/17/86 YLH)
:	LB	R5,BBUFER+MURUPT,R10,	:GET RU POINTER(9/13/84/CHS)
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER(9/13/84/CHS)
	LB	R1,BBUFER,R5,		:GET RU CODE
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU POINTER
	JAL	R5,R.PBRC,,		:RELEASE BUFFER WITH BTU
	LHL	R0,BBUFER+MURHSN,R10,	:GET SENSE CODE
	J	H.RDF9			:JUMP TO CONTINUE

H.RCD8	NHI	R5,MU.CTG		:GET RU CATEGORY
	SRLS	R5,4			:MAKE A HALF-WORD INDEX
	LHL	R5,H.RDPT,R5		:GET PTR TO PROCESSING ROUTINE
	J	L.BASE,R5		:VECTOR EXECUTION

:TABLE OF PROCESSING ROUTINES DEPENDING ON RU CATEGORY
H.RDPT	HC	H.RDFM-L.BASE		:PTR TO FMD PROC ROUTINE
	HC	H.RDNC-L.BASE		:PTR TO NC PROC ROUTINE
	HC	H.RDDF-L.BASE		:PTR TO DFC PROC ROUTINE
	HC	H.RDSC-L.BASE		:PTR TO SC PROC ROUTINE

:PROCESSING ROUTINE FOR THE 1ST SEGMENTS OF FMD'S.
:
:FIRST SEPARATE REQUESTS AND RESPONSES.
H.RDFM	LB	R1,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R1,MU.RRI		:IS IT A REPONSE?
	JN	H.RDRP			:JUMP IF SO

:THIS IS A REQUEST. IF IT CAME ON SSCP-LU SESSION PASS IT TO NIO AFTER
:CONVERTING TO 3270 OR DISCARD IT DEPENDING ON THE EXISTENCE OF LU-LU
:SESSION.
:RH BYTE 1 AND BYTE 2 INFORMATION IS SAVED IN LUCB IN CASE OF
:MULTISEGMENT FMD. FIRST 3 BITS OF FMD RQ ARE ALWAYS 0
:WHICH IS ENOUGH TO STORE DR1 AND DR2 INFORMATION FORM THE 2ND RH BYTE
:IN THE SAME WORK BYTE OF LUCB.
	LB	R5,BBUFER+MURHF2,R10,	:GET RH BYTE 2
	THI	R5,MU.QRI		:QRI BIT ON?
	JEFS	H.RDFL			:JUMP IF NOT
	OHI	R5,40			:TURN ON QRI INDICATION
H.RDFL	NHI	R5,MU.DR1!MU.DR2!40	:LEAVE DR1&DR2 INFO IN BYTE 2
	OR	R5,R1			:MIX TOGETHER BYTES 1 AND 2
	STB	R5,LUCTAB+LULUW2,R9,	:SAVE RH1&RH2 INFO IN LUCB

:IF IT IS THE LAST SEGMENT OF SSCP-LU RQ GENERATE +RSP OR -RSP(LU BUSY).
	LB	R1,BBUFER+MUOADP,R10,	:GET ORIGIN ADDR
	JN	H.RDF2			:JUMP IF LU-LU MSG

:FIRST SEGMENT FOR SSCP-LU.
	LB	R1,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	LB	R5,LUCTAB+LUCSCN,R9,	:GET GET SCREEN STATUS
	JE	H.RDFV			:JUMP IF NO SCREEN CONTROL
	NHI	R5,@LUCLCP		:SSCP-LU CLEANING COMPLETE
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	LR	R0,R5			:COPY THE REGISTER
	NHI	R0,@LUCLLU&@LUSCOP&@LUSSOP :DISREGARD LU-LU CLEANING
	CHI	R0,LUSCRN!LUSUNW	:UNOWNED?
	JEFS	H.RDFU			:JUMP IF SO
	CHI	R0,LUSCRN!LUSFUW	:FORCE UNOWNED?
	JEFS	H.RDFU			:JUMP IF SO
	CHI	R0,LUSCRN!LUSSYS	:SYSTEM?
	JE	H.RDF0			:SEND IT OVER IF SO
	OHI	R5,LUCLCP		:INDICATE SSCP-LU CLEANING
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	J	H.RDFZ			:JUMP TO DISCARD AND SEND -RSP
:H.RDFU	OHI	R5,LUSSYS		:GO TO SYSTEM STATE
H.RDFU	NHI	R5,@LUSSCN		:CLEAN UP THE STATUS FLAG (03/21/86 YLH)
	OHI	R5,LUSSYS		:GO TO SYSTEM STATE (03/21/86 YLH)
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	LHI	R4,HSTINI		:HOST INITIATED
	JAL	R6,H.SNST		:SEND STATUS TO TIF
	J	H.RDF0			:SEND THE MESSAGE OVER
H.RDFV	BBLSCB	R4,LUCTAB+LULSCB,R9,	:GET LU-LU SCB PTR
	JE	H.RDF0			:JUMP IF VALID
H.RDFZ	THI	R1,MU.EIU		:LAST SEGMENT?
	JE	H.RCD1			:DISCARD MSG&MUCB IF NOT
	LB	R4,LUCTAB+LUCTYP,R9,	:GET LU TYPE
					:(F00/02/23/87/DB/START)
	CHI	R4,LU.T1		:LU T1?
	JEFS	H.RDFD			:YES
					:(F00/02/23/87/DB/END)
	CHI	R4,LU.T3		:LU T3?
	JN	H.RCD7			:BUSY RSP&DISCARD MSG IF NOT
H.RDFD					:(F00/02/23/87/DB)
	LHI	R0,LUNSSN		:PREPRARE CATEGORY NOT SUPPRT
	J	H.RCD9			:JUMP TO CONTINUE
H.RDF0	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
					:(F00/02/23/87/DB/START)
	CHI	R5,LU.T1		:TYPE 1?
	JE	H.RDFZ			:YES
					:(F00/02/23/87/DB/END)
	CHI	R5,LU.T3		:TYPE 3?
	JE	H.RDFZ			:JUMP IF SO
	JAL	R5,H.CVRT		:CONVERT TO 3270
	XR	R4,R4			:PREPARE FOR NO RESPONSE
	XR	R0,R0			:PREPARE FOR NO CD
	LB	R6,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R6,MU.ECI		:END OF CHAIN?
	JEFS	H.RDF1			:JUMP IF NOT
	LHI	R0,SNDTCD		:PREPARE CHANGE DIRECTION
H.RDF1	THI	R1,MU.EIU		:IS IT THE LAST SEGMENT?
	JE	H.RDF5			:NO RSP IF SO
	LIS	R4,LULURP		:PREPARE FOR +RSP
	J	H.RDF5			:JUMP TO CONTINUE

:THIS IS THE 1ST SEGMENT OF LU-LU FMD RU CHAIN. ADJUST SEQUENCE
:NUMBER IN RECEIVE DIRECTION.
:IF TIF SUPPORTS SCREEN STATES (CMT) PASS MESSAGE TO NIO ONLY IF
:THE SCREEN IS IN APPL STATE, OTHERWISE DISCARD IT.
:H.RDF2	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB PTR(6/25/85/CHS)
H.RDF2	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE
	JE	H.RD1Z			:JUMP IF NO SCREEN CONTROL (3/14/86/CHS)
:	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH (03/11/86 YLH)
:	THI	R5,MU.BCI		:BEGIN CHAIN? (03/11/86 YLH)
	LB	R1,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH (03/11/86 YLH)
	THI	R1,MU.BCI		:BEGIN CHAIN? (03/11/86 YLH)
	JEFS	H.RDFT			:JUMP IF NOT
	NHI	R5,@LUCLLU		:LU-LU CLEANING COMPLETE
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATE
H.RDFT	LR	R1,R5			:COPY SCREEN STATE
	NHI	R1,@LUCLCP&@LUSCOP&@LUSSOP :DISREGARD SSCP-LU CLEANING
	CHI	R1,LUSCRN!LUSAPL	:APPLICATION STATE?
	JEFS	H.RD1Z			:JUMP IF SO
	OHI	R5,LUCLLU		:INDICATE LU-LU CLEANING
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATE
	LB	R1,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R1,MU.EIU		:LAST SEGMENT?
	JN	H.RCD7			:-RSP AND DISCARD IF SO
	J	H.RCD1			:OTHERWISE DISCARD IT
H.RD1Z	LIS	R7,0
	STB	R7,LUCTAB+LULUW3,R9,	:CLEAR LULUW3(6/25/85/CHS)
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB PTR(6/25/85/CHS)
	LCS	R5,1			:PREPARE -1
	AHM	R5,SCBBLK+SCADJR,R7,	:UPDATE ADJUSTMENT TO SEQ #

:FOR LU TYPE 3 (PRINTER) FLOW CONTROL IS PROVIDED BY EITHER GIVING -RSP
:IF THE PREVIOUS CHAIN IS NOT COMPLETELY PROCESSED BY NIO OR BY WAITING
:FOR THIS TO HAPPEN WITHOUT ANY RSP AT ALL. FCNGRP SWITCH SHOWS WHAT
:KIND OF FLOW CONTROL IS BEING USED.
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.BCI		:BEGINNING OF CHAIN?
	JE	H.RDFR			:JUMP IF NOT
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULURP&@LULUNG	:CLEAR RSP BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	IF	FCNGRP			:FOR FLOW CONTR WITH -RSP
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
					:(F00/02/23/87/DB/START)
	CHI	R5,LU.T1		:TYPE 1?
	JEFS	H.RDFY			:YES
					:(F00/02/23/87/DB/END)
	CHI	R5,LU.T3		:TYPE 3?
	JN	H.RDFP			:JUMP IF NOT
H.RDFY					:(F00/02/23/87/DB)
	LHL	R5,LUCTAB+LUNWDG,R9,	:GET SNA->NW GET PTR
	LHL	R4,LUCTAB+LUNWDR,R9,	:GET SNA->NW REL PTR
	CR	R5,R4			:COMPARE THEM
	JEFS	H.RDFP			:JUMP IF QUEUE EMPTY
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	OHI	R5,LULUNG		:PREPARE FOR -RSP FOR THE CHAIN
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	EI

:IN SNA LU TYPE 2 THE KEYBOARD IS RESTORED FOR END OF BRACKET.
:IN BSC WE HAVE TO TURN ON WCC KEYBOARD RESTORE FOR THE LAST CHAIN IN
:THE BRACKET OR GENERATE EXTRA 3270 WRITE COMMAND AND WCC TO RESTORE
:THE KEYBOARD IF IT WAS NOT DONE BY THE HOST APPLICATION.
H.RDFP	LB	R0,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET POINTER TO RU
	LHL	R4,BBUFER+MUDCF,R10,	:GET DATA COUNT FIELD
	SIS	R4,3			:DUMMY RH?
	JE	H.RDFK			:JUMP IF SO
	LB	R4,BBUFER+1,R5,		:GET WCC
	THI	R0,MU.EBI		:END OF BRACKET?
	JN	H.RDFI			:JUMP IF SO

:NOT A DUMMY RH AND -EB. SAVE KEYBOARD RESTORE BIT IN LUCB.
	NHI	R4,WCCKBR		:GET KEYBOARD RESTORE BIT FROM WCC
	SLLS	R4,LUDPKB-WCCKBR	:SHIFT TO FIT IT TO LUSVC STATUS
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATUS BYTE
	NHI	R5,@LUDPKB		:CLEAR KEYBOARD RESTORE
	OR	R5,R4			:PUT NEW KEYBOARD RESTORE THERE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATUS BYTE
	J	H.RDFR			:JUMP TO CONTINUE

:NOT A DUMMY RH AND EB. TURN ON KEYBOARD RESTORE IF IT WAS OFF.
H.RDFI	THI	R4,WCCKBR		:IS KEYBOARD RESTORE ON IN WCC
	JN	H.RDFR			:JUMP IF SO
	OHI	R4,WCCKBR		:OTHERWISE TURN IT ON
	LB	R5,LUCTAB+LUCSYS,R9,	:SEE IF IBM
	CLHI	R5,IBM			:...
	JNFS	H.RDFW			:NO, NO CONVERSION
:	NHI	R4,6			:LEAVE LAST 6 BITS ONLY (09/30/86 YLH)
	NHI	R4,3F			:LEAVE LAST 6 BITS ONLY (09/30/86 YLH)
	LB	R4,BAIOIC,R4,		:CONVERT IT TO VALID WCC
H.RDFW
	STB	R4,BBUFER+1,R5,		:PUT WCC BACK IN BUFFER
	J	H.RDFR			:JUMP TO CONTINUE

:DUMMY RH. IF -BB&EB AND KEYBOARD NOT RESTORED CONVERT IT TO 3270 WRITE
:WITH KEYBOARD RESTORE WCC.
H.RDFK	THI	R0,MU.BBI		:BEGIN BRACKET?
	JN	H.RDFR			:JUMP IF SO
	THI	R0,MU.EBI		:END OF BRACKET?
	JE	H.RDFR			:JUMP IF NOT
	IF	VHRSUP
	LB	R4,LUCTAB+LUCVHR,R9,	:GET VHR STATE BYTE
	THI	R4,LUVHRF		:VHR LU?
	JN	H.RDFR			:JUMP IF SO
	EI
	LB	R4,LUCTAB+LULUST,R9,	:GET LUSVC STATUS BYTE
	THI	R4,LUDPKB		:KEYBOARD ALREADY RESTORED?
	JN	H.RDFR			:JUMP IF SO
	LHI	R4,WCMD			:GET 3270 WRITE CMD
	STB	R4,BBUFER,R5,		:PUT IT IN RU
	LHI	R4,WCCK			:GET KEYBOARD RESTORE WCC
	STB	R4,BBUFER+1,R5,		:PUT IT IN RU
	LIS	R4,2			:PREPARE TO INCREASE DATA COUNT BY 2
	AHM	R4,BBUFER+MUDCF,R10,	:INCREASE IT

:PREPARE RESPONSE TYPE (IF ANY). 
:+RSP IF THIS IS DEFINITE RESPONSE CHAIN.
:THE RESPONSE TYPE IS PREPARED IN LUCB WORK BYTE.
H.RDFR	LB	R4,LUCTAB+LULUWK,R9,	:GET PREVIOUS LUCB WORK BYTE
	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R5,MU.DR1!MU.DR2	:IS IT DEFIN RSP CHAIN?
	JE	H.RDF3			:JUMP IF NOT
					:(3.F01/06/04/87/DB/START)
:	A POSITIVE RESPONSE MUST BE GENERATED FOR AN ERI REQUEST. THIS
:	RESPONSE IS THEN DISCARDED BY DFC LAYER. THIS POSITIVE RESPONSE
:	MUST ONLY BE GENERATED FOR A COMPLETE CHAIN (ECI=SET).
:	THI	R5,MU.ERI		:EXP RSP CHAIN?
:	JNFS	H.RDF3			:JUMP IF SO
	LB	R5,BBUFER+MURHF1,R10,	:GET RH BYTE 0
	THI	R5,MU.ECI		:IS THIS END OF CHAIN?
	JE	H.RDF3			:NO, DON'T GENERATE RSP
					:(3.F01/06/04/87/DB/END)
	OHI	R4,LULURP		:PREPARE FOR +RSP
	STB	R4,LUCTAB+LULUWK,R9,	:UPDATE LUCB WORK BYTE

:FOR THE LAST SEGMENT PREPARE RESPONSE INDICATOR IN R4, OTHERWISE
:INDICATE NO RESPONSE.
H.RDF3	NHI	R4,LULURP!LULUNG	:CLEAR EVERYTHING BUT RSP IND
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:LAST SEGMENT?
	JNFS	H.RDFA			:JUMP IF SO
	XR	R4,R4			:NO RSP IF NOT LAST SEGMENT

:PREPARE CHANGE DIRECTION INDICATION TO BE PASSED TO NIO.
:CHANGE DIRECTION IS SENT BY SNA HOST IN THE FIRST SEGMENT OF
:LAST CHAIN ELEMENT AND NIO EXPECTS IT THE SAME WAY.
:HOWEVER IF BRACKET ENDS CHANGE DIRECTION IS NOT
:INDICATED BY SNA. END OF BRACKET IS SENT INSTEAD WITH THE FIRST
:ELEMENT OF THE CHAIN. NIO HAS NO KNOWLEDGE OF BRACKETING AND WILL
:EXPECT CHANGE DIRECTION AS IN CASE OF NO BRACKETS.
:FIRST LOOK FOR EB INDICATOR AND SHOW PENDING CHANGE DIRECTION IN LUCB
:IF EBI WAS FOUND.
H.RDFA	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	THI	R5,MU.EBI!MU.CDI	:END OF BRACKET OR CD?
	JEFS	H.RDF4			:JUMP IF NOT
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUCB WORK BYTE
	OHI	R5,LULUCD		:INDICATE CHANGE DIRECTION
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUCB WORK BYTE

:NOW PREPARE CHANGE DIRECTION BIT FOR SNA->NIO SUBCOMMAND BYTE.
H.RDF4	XR	R0,R0			:CLEAR SUBCOMMAND
	LB	R6,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R6,MU.ECI		:END OF CHAIN?
	JE	H.RDF5			:NO CHANGE DIRECTION IF SO
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUCB WORK BYTE
	THI	R5,LULUCD		:CHANGE DIRECTION PENDING?
	JEFS	H.RDF5			:JUMP IF NOT
	NHI	R5,@LULUCD		:CLEAR CHANGE DIRECTION
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUCB WORK BYTE
	LHI	R0,SNDTCD		:SHOW CD IN SNA->NIO SUBCOMMAND

:RH-ONLY CHAINS ARE NOT PASSED TO NIO BUT DISCARDED
:IF SEGMENTATION, CHAINING OR CHANGE DIRECTION INFORMATION
:ARE NOT THERE TO BE PASSED TO NIO.
H.RDF5	LHL	R5,BBUFER+MUDCF,R10,	:GET DATA COUNT FIELD
	SIS	R5,3			:SUBTRACT RH LENGTH
	JG	H.RDF6			:JUMP IF DATA THERE
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	NHI	R5,MU.BIU!MU.EIU	:LEAVE SEGMENTATION INFO ONLY
	CHI	R5,MU.BIU!MU.EIU	:FIRST AND LAST SEGMENT?
	JN	H.RDF6			:JUMP IF NOT
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,MU.BCI!MU.ECI	:LEAVE CHAINING INFO ONLY
	JE	H.RDFX			:DISCARD IF DUMMY INTERMEDIATE ELE
	CHI	R5,MU.BCI!MU.ECI	:FIRST AND LAST CHAIN ELEMENT?
	JN	H.RDF6			:JUMP IF NOT
	LB	R5,LUCTAB+LUBPSG,R9,	:ETX ONLY IS GENERATED BY DSP NIO?
	JEFS	H.RDFX			:JUMP OF SO
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	THI	R5,MU.EBI!MU.CDI	:ANY CHANGE DIRECTION INFO THERE?
	JNFS	H.RDF6			:JUMP IF SO
H.RDFX	LR	R8,R4			:OTHERWISE SAVE RSP TYPE
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU POINTER
	JAL	R5,R.PBRC,,		:RELEASE THE MESSAGE
	J	H.RDFF			:JUMP TO CONTINUE

:PREPARE CHAINING AND SEGMENTATION FOR SNA->NIO SUBCOMMAND.
H.RDF6	NHI	R6,MU.BCI!MU.ECI	:LEAVE ONLY CHAINING INFO
	SLLS	R6,2			:PUT CHAINING INFO IN RIGHT PLACE
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	NHI	R5,MU.BIU!MU.EIU	:LEAVE SEGM INFO ONLY
	SRLS	R5,2			:PUT IT IN RIGHT PLACE
	OR	R5,R6			:COMBINE CHAIN AND SEG INFO
	XHI	R5,SNDTIC!SNDTIS	:INVERT CHAIN AND SEG INFO
	OR	R0,R5			:COMPLETE SUBCOMMAND BYTE

:FOR LU TYPE 3 WITH NEGATIVE FLOW CONTROL THE RU CHAIN IS PURGED IF
:-RSP IS GENERATED.
H.RDFE	EQ	.
	IF	FCNGRP			:FOR FLOW CONTR WITH -RSP
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
	CHI	R5,LU.T3		:TYPE 3?
	JNFS	H.RDFG			:JUMP IF NOT
	THI	R4,LULUNG		:PREPARED FOR -RSP?
	JEFS	H.RDFG			:JUMP IF NOT
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO BUFFER WITH MSG
	LR	R8,R4			:COPY RSP INDICATORS
	JAL	R5,R.PBRC,,		:RELEASE BUFFER CHAIN
	J	H.RDFF			:JUMP TO CONTINUE
	EI

:THE DATA MESSAGE IS PASSED TO NIO AS END-TO-END DATA MESSAGE.
H.RDFG	OHI	R0,SNETEM^8		:PREPARE E-T-E MSG CMD
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE
	JE	H.RDFQ			:JUMP IF NO SCREEN CONTROL
	NHI	R5,@LUSCOP		:ASSUME CHAIN COMPLETE
	THI	R0,SNDTFC		:CHECK IF THE LAST IN CHAIN
	JEFS	H.RDFJ			:JUMP IF THE LAST
	OHI	R5,LUSCOP		:SHOW THAT THE CHAIN IS OPEN
H.RDFJ	NHI	R5,@LUSSOP		:ASSUME LAST SEGMENT
	THI	R0,SNDTFS		:CHECK IF LAST SEGMENT
	JEFS	H.RDFN			:JUMP IF THE LAST
	OHI	R5,LUSSOP		:SHOW THAT THE SEGEMENT IS OPEN
:H.RDFN	STB	R9,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATE
H.RDFN	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATE (2/20/86/YLH)
H.RDFQ	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG BUFFER
	LIS	R2,FID2LG		:GET LENGTH OF TH HEADER
					:(F00/02/23/87/DB/START)
					: LU_T1 IMPLEMENTATION
	LB	R5,BBUFER+MUBIUF,R10,	:GET FIRST BYTE OF TH
	THI	R5,MU.BIU		:FIRST SEGMENT?
	JE	H.RD30			:NO, WSF NOT NEEDED
	LB	R5,BBUFER+MURHF1,R10,	:GET FIRST BYTE OF RH
	THI	R5,MU.BCI		:IS THIS BEGIN CHAIN?
	JE	H.RD30			:NO, WSF NOT NEEDED
	LB	R5,LUCTAB+LUCTYP,R9,	:YES, FS AND BCI - GET LU TYPE
	CLHI	R5,LU.T1		:IS THIS AN LU_T1?
	JN	H.RD30			:NO, SCS DATA NOT POSSIBLE
	OHI	R0,SNDOFF		:YES, SCS DATA SUBCOMMAND SET
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:POINT TO TH BYTE 0
: SCS DATA FOUND - FIRST SEGEMENT, BEGIN CHAIN AND LU_T1
:	SNDOFF SUBCOMMAND IS USED TO NOTIFY NIO THAT THIS IS SCS DATA.
:	FOR SCS DATA, THIS ROUTINE BUILDS A WSF 3270 COMMAND IN FRONT OF
:	THE SCS DATA IN THE MU BUFFER. THE OFFSET OF THE WSF COMMAND IN
:	THIS BUFFER IS STORED IN THE FIRST HALF WORD OF THIS BUFFER. THE
:	EXACT LENGTH OF THE SCS DATA FIELD PLUS THE WSF COMMAND HEADER
:	IS PASSED TO "L.PTCD". WHEN  NIO DEQUEUES THIS MESSAGE FOR OUTPUT
:	THE MESSAGE LENGTH NEED NOT BE ALTERED AT ALL. THE
:	WSF COMMAND IS APPENDED SLIGHTLY DIFFERENTLY DEPENDING ON WHETHER
:	OR NOT THE SCS DATA IS PROCEEDED BY AN FMH.
: FIND OUT IF FMH-1 IS BEING USED OR NOT
	LB	R5,BBUFER+MURHF1,R10,	:GET FIRST RH BYTE
	THI	R5,MU.FI		:FMH FOLLOWS?
	JE	H.RD20			:NO
: SCS DATA PROCEEDED BY FMH-1, FORMAT IS AS FOLLOWS:
:   		    TH | RH | FMH-1 | LENGTH | SCSID | 00 | SCS DATA 
: length in bytes:   6    3    6         2      1       1   (MUCDF)-0D
:	
:	THIS ROUTINE REPLACES THE LAST BYTE OF FMH-1 WITH THE WSF COMMAND.
:	THE FIRST 2 BYTES OF THE TH WILL CONTAIN THE OFFSET OF THE WSF
:	COMMAND. 
	BBLSCB	R5,LUCTAB+LULSCB,R9,	:GET PTR TO LU-LU SCB
	LB	R5,SCBBLK+SCCLUP,R5,	:GET BYTE 6 OF BIND
	THI	R5,SC.FMH		:IS FMH ALLOWED?
	JN	H.RD10			:YES
	JAL	R10,CRASH,,		:NO, CRASH
	BC	0,0,0,CRBFMH		
H.RD10
	LHI	R2,FID2LG+RHLENG+FMH1LN-1 :GET OFFSET OF WHERE WSF WILL BE
	LHI	R8,WSFCMD		:GET 3270 WSF COMMAND (F3)
	STB	R8,BBUFER,R10,R2	:STORE WSF OVER LAST BYTE OF FMH-1
	STH	R2,BBUFER,R10,		:STORE OFFSET OF WSF 
	LHI	R2,1-RHLENG-FMH1LN	:NO. TO SUBTRACT FROM RU LENGTH TO GET
					: NEW WSF MESSAGE LENGTH
	J	H.RD30			:GO CALCULATE COMPLETE MSG LENGTH 
					: AND QUEUE MSG
: SCS DATA NOT PROCEEDED BY FMH-1, FORMAT IS AS FOLLOWS:
:   	   ---	    TH | RH | SCS DATA
: length in bytes:   6    3    (MUCDF) - 3
:	
:	THIS ROUTINE APPENDS THE COMPLETE WSF COMMAND HEADER 
:	(WSF/LENGTH/SCSID/00) TO THE SCS DATA. THE FIRST 2 BYTES OF THE TH
:	WILL CONTAIN THE OFFSET OF THE WSF COMMAND.
H.RD20
	LHI	R2,FID2LG+RHLENG-WSFHLN	:GET OFFSET OF WSF COMMAND
	LHI	R8,WSFCMD		:GET 3270 WSF COMMAND
	STB	R8,BBUFER,R3,R2	:STORE FIRST BYTE OF WSF HEADER (F3)
	LIS	R8,0			:LENGTH WILL ALWAYS BE 0000
	STB	R8,BBUFER+1,R3,R2	:STORE FIRST BYTE OF LENGTH
	STB	R8,BBUFER+2,R3,R2	:STORE SECOND BYTE OF LENGTH
	STB	R8,BBUFER+4,R3,R2	:STORE RESERVED BYTE OF HEADER
	LHI	R8,SCSID		:GET SCS ID (41)
	STB	R8,BBUFER+3,R3,R2	:STORE SCS ID INTO WSF HEADER
	STH	R2,BBUFER,R3,		:STORE OFFSET OF WSF COMMAND 
	LHI	R2,WSFHLN-RHLENG	:NO. TO SUBTRACT FROM RU LENGTH TO GET
					: NEW WSF MESSAGE LENGTH
H.RD30
					:(F00/02/23/87/DB/END)
	AH	R2,BBUFER+MUDCF,R10,	:OVERALL LENGTH OF MSG
	LR	R8,R4			:SAVE THE REGISTER
	JAL	R5,L.PTCD		:SHIP CMD TO NIO

:FOR LU TYPE 2 CHECK IF START PRINTER BIT WAS ON IN WCC.
:IF SO THIS IS THE LAST SEGMENT OF THE LAST ELEMENT CHAIN TRY TO FIND
: PRINTER AND GENERATE BSC 3270 COPY COMMAND. IF PRINTER IS BUSY OR
: NOT AVAILABLE GENERATE -RSP.
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
	CHI	R5,LU.T2		:TYPE 2?
	JN	H.RDFF			:JUMP IF NOT
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGIN ADDR
	JE	H.RDFF			:JUMP IF SSCP-LU
	JAL	R5,H.WCPT		:CHECK WCC
	LB	R5,LUCTAB+LULUW2,R9,	:GET SAVED RH INFO
	THI	R5,MU.ECI		:LAST IN CHAIN?
	JE	H.RDFF			:JUMP IF NOT
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:LAST SEGMENT?
	JE	H.RDFF			:JUMP IF NOT
	LH	R5,LUCTAB+LUADCB,R9,	:GET PRINTER INFO
	NHI	R5,LUSPRT		:LEAVE STATE INFO ONLY
	CHI	R5,LUSPRT		:START PRINTER?
	JN	H.RDFF			:JUMP IF NOT
	JAL	R5,H.ASGN		:ASSIGN PRINTER AND GEN COPY
	SIS	R0,1			:CHECK RETURN CODE
	JLFS	H.RDFF			:JUMP IF PRINTER ASSIGNED
	JGFS	H.RDFH			:JUMP IF NOT AVAILABLE
	LHI	R0,LUPSSN		:PREPARE SHORT TERM BUSY
	J	H.RDF9			:JUMP TO SEND -RSP
H.RDFH	LHI	R0,LUPLSN		:PREPARE UNAVAILABLE
	J	H.RDF9			:JUMP TO SEND -RSP

:IF NO RESPONSE IS NEEDED DISCARD MUCB.
H.RDFF	LR	R5,R8			:COPY THE REGISTER
	THI	R5,LULURP		:ANY RESPONSE NEEDED?
	JNFS	H.RDF7			:JUMP IF SO
	LR	R3,R10			:OTHERWISE COPY MUCB POINTER
	JAL	R4,PBB,,		:RELEASE MUCB BUFFER
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:GENERATE SENSE CODE IN R0 (0 FOR +RSP).
:R5 CONTINS THE FORM OF REPONSE INFORMATION.
H.RDF7	THI	R5,LULUNG		:IS IT -RSP?
	JE	H.RDF8			:JUMP IF NOT
	LB	R5,BBUFER+MUOADP,R10,	:SSCP-LU?
	JNFS	H.RDFB			:JUMP IF NOT
	BBLSCB	R5,LUCTAB+LULSCB,R9,	:SSCP-LU CONCURRENT WITH LU-LU?
	JEFS	H.RDFB			:JUMP IF NOT
	LHI	R0,LUBYSN		:GENERATE "LU BUSY" SENSE CD
	J	H.RDF9			:JUMP TO CONTINUE
H.RDFB	EQ	.
	IF	FCNGRP			:FOR PRINTER CONTL WITH -RSP
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
	CHI	R5,LU.T3		:TYPE 3?
	JNFS	H.RDFC			:JUMP IF NOT
	LHI	R0,LUIRSN		:PREPARE INTERVENTION REQUIRED
	J	H.RDF9			:JUMP TO CONTINUE
	EI
H.RDFC	LHI	R0,LUONSN		:PREPARE "PRESENT SPACE LOST"
	J	H.RDF9			:JUMP TO CONTINUE
H.RDF8	XR	R0,R0			:PREPARE 0 SENSE CODE

:IF THE HOST ALLOWS FOR A LONG TIME BETWEEN THE REQUEST AND CORRESPONDING
:RESPONSE, THE FLOW CONTROL FOR LU TYPE 3 COULD BE IMPLEMENTED BY SIMPLY
:WAITING UNTIL NIO PROCESSES SNA->NIO DATA QUEUE BEFORE SENDING +RSP
:TO THE HOST.
:RECEIVE LOGIC DOES NOT SEND ANY RSP IN THIS CASE. INSTEAD AN INTERNAL
:MESSAGE CMD IS PUT INTO THE HEAD OF NIO->SNA DATA QUEUE IF IT WAS EMPTY.
:THE SEND MODULE WILL GENERATE +RSP WHEN SNA->NIO QUEUE IS EMPTIED BY NIO.
	IF	1-FCNGRP		:FLOW CNTR WITHOUT -RSP
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
	CHI	R5,LU.T3		:TYPE 3?
	JN	H.RDF9			:JUMP IF NOT
	LR	R3,R10			:COPY MUCB POINTER
	JAL	R4,PBB,,		:RELEASE BUFFER WITH MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	LHL	R6,LUCTAB+LUCT.N,R9,	:GET REL# FOR LU
	SBT	R6,DPNWSN,,		:SHOW DATA PRESENT
	JNR	R14			:RETURN IF ALREADY NOT EMPTY
	JAL	R4,GETCL,,		:GET CMD LINK
	J	L.CLER			:JUMP IF NONE AVAILABLE
	LHL	R7,LUCTAB+LUSNDG,R9,	:GET NIO->SNA GET PTR
	STH	R6,LUCTAB+LUSNDG,R9,	:UPDATE NIO->SNA GET PTR
	STH	R7,CMDBLK+CLPTR,R6,	:LINK OLD LINK TO NEW
	LHI	R0,NSINTM^8		:PREPARE FOR INTERNAL MESSAGE
	STH	R0,CMDBLK+CLCMD,R6,	:UPDATE COMMAND BYTES
	JR	R14			:AND RETURN
	EI

:GENERATE RESPONSE AND SEND IT TO DFC.SEND.
H.RDF9	JAL	R5,L.GNRP		:GENERATE RESPONSE
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUCB WORK BYTE
	STB	R5,LURGSV,,		:SAVE IT
	NHI	R5,@LULURP&@LULUNG	:CLEAR RESPONSE TYPE BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUCB WORK BYTE
	IF	FCNGRP
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND THE RESPONSE
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
	CHI	R5,LU.T3		:LU TYPE 3?
	JNR	R14			:RETURN IF NOT

:FOR LU TYPE 3 (PRINTER) SEND LUSTAT (NOTHING TO SEND).
:LUSTAT IS NOT SENT IN BETB STATE OR IF +RSP JUST GENERATED WILL
:BRING FSM FIRST SPEAKER IN BETB STATE.
:ALSO RECEIVED CHAIN MUST INDICATE CHANGE DIRECTION.
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JER	R14			:RETURN IF NO SCB
	LB	R5,SCBBLK+SCSTAT+FSCBFP,R7, :GET FIRST SPEAKER FSM
	CHI	R5,FS.ST1		:STATE 1?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO
	LHL	R4,SCBBLK+SCTRNG,R7,	:GET POINTER TO CT
	BBLOAD	R4,CMDBLK+CLARG,R4,	:POINTER TO CT ELEMENT
	LB	R5,BBUFER+CLARG5,R4,	:GET BYTE WITH RH 3
	THI	R5,MU.CDI		:CHANGE DIRECTION?
	JER	R14			:RETURN IF NOT
	L	R5,LURGSV,,		:GET SAVED LUCB WORK BYTE
	THI	R5,LULUNG		:WAS -RSP GENERATED?
	JE	H.RDFY			:JUMP IF NOT

:FOR LU TYPE 3 WITH NEGATIVE FLOW CONTROL PUT INTERNAL MESSAGE CMD
:IN NIO->SNA DATA QUEUE IF IT WAS EMPTY AND -RSP WAS GENERATED.
:SEND LOGIC WILL GENERATE LUSTAT(NOW AVAILABLE) WHEN NIO CLEARS
:SNA->NIO DATA QUEUE.
	LHL	R6,LUCTAB+LUCT.N,R9,	:GET REL# OF LU
	STB	R6,DPNWSN		:SHOW DATA PRESENT
	JNR	R14			:RETURN IF ALREADY NOT EMPTY
	JAL	R4,GETCL,,		:GET CMD LINK
	J	L.CLER			:JUMP IF NONE AVAILABLE
	LHL	R7,LUCTAB+LUSNDG,R9,	:GET NIO->SNA GET PTR
	STH	R6,LUCTAB+LUSNDG,R9,	:UPDATE NIO->SNA GET PTR
	STH	R7,CMDBLK+CLPTR,R6,	:LINK OLD LINK TO NEW
	LHI	R0,NSINTM^8		:PREPARE FOR INTERNAL MESSAGE
	STH	R0,CMDBLK+CLCMD,R6,	:UPDATE CMD IN THE LINK
	JR	R14			:AND RETURN

:GENERATE LUSTAT(NOTHING TO SEND).
H.RDFY	LA	R8,LUCDCN,,		:GET ADDR OF LUSTAT
	LHI	R0,LUCDLG+3		:GET LENGTH OF LUSTAT
	JAL	R5,L.DFLL		:GENERATE LUSTAT
	LB	R5,BBUFER+MURHF3,R10,	:GET BYTE 3 OF RH
	OHI	R5,MU.CDI		:CHANGE DIRECTION
	STB	R5,BBUFER+MURHF3,R10,	:UPDATE BYTE 3 OF RH
	EI
H.RDFS	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND THE RESPONSE
	JR	R14			:AND RETURN

::::::::::::::::::::::::::
: FMD RESPONSE RECEIVED IN DSP MODE.
:
: DISCARD +RSP IF END-TO-END ACKNOLEDGEMENT WAS NOT REQUESTED
: OTHERWISE SEND ACK TO NIO AND DISCARD RSP.
: FOR -RSP CURRENTLY CRASH.
H.RDRP	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R5,MU.RTI		:IS IT +RSP?
	JE	H.RDR1			:JUMP IF +RSP

:IF -RSP ON LU-LU SESSION SEND CANCEL TO THE HOST AND CONTINUE
:THE SAME WAY AS FOR +RSP. THE HOST ITSELF IS SUPPOSED TO TAKE
:RECOVERY ACTIONS.
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGIN ADDR
	JE	H.RDR1			:JUMP IF SSCP-LU
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	LB	R5,SCBBLK+SCSTAT+FSCCSD,R7,	:GET CHAIN-SEND FSM
	CHI	R5,FS.ST1		:BETWEEN CHAINS?
	JE	H.RDR1			:JUMP IF SO
	STM	R0,LURGS1,,		:SAVE ALL REGISTERS
	LA	R8,CANCAN,,		:POINT TO CANNED CANCEL MSG
	LHI	R0,CANLGT+3		:LENGTH OF CANCEL RU + RH
	JAL	R5,L.DFLL		:GENERATE CANCEL MSG
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MURHF3,R10,	:GET RH BYTE 3
	OHI	R5,MU.CDI		:FORCE CHANGE DIRECTION
	STB	R5,BBUFER+MURHF3,R10,	:UPDATE RH BYTE 3
	LHI	R2,DFCSND		:DISTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND THE MESSAGE
	LM	R0,LURGS1,,		:RESTORE ALL REGISTERS
                 
:IF END-TO-END ACK WAS REQUESTED SEND ACK BACK TO NIO.
H.RDR1	LB	R5,LUCTAB+LULUWK,R9,	:GET LUCB WORK BYTE
	THI	R5,LULUAK		:WAS ACK REQUESTED?
	JE	H.RCD1			:JUMP TO DISCARD MUCB&MSG IF NOT
	NHI	R5,@LULUFA&@LULUAK	:CLEAR ACK RELATED BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUCB WORK BYTE
	LHI	R0,SNETEM^8!SNDTAK	:PREPARE ACK TO NIO
	XR	R3,R3			:THIS IS TO SHOW ACK RSP
	JAL	R5,L.PTCD		:PASS ACK TO NIO
	J	H.RCD1			:JUMP TO DISCARD MUCB&RSP

::::::::::::::::::::
:: RECEIVED MESSAGE OF NC CATEGORY. SERIOUS DESIGN PROBLEM.
H.RDNC	JAL	R10,CRASH,,
	HC	0
	BC	4*R5,CR.IMG

::::::::::::::::::::
:: RECEIVED MSG OF DFC CATEGORY IN DSP MODE.
:: FIRST DETERMINE MSG TYPE AND VECTOR THE EXECUTION.
H.RDDF	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R0,BBUFER,R5,		:GET RQ CODE
	JAL	R5,L.DFCT		:DETERMINE DFC TYPE
	LHL	R5,H.DFDB,R6,R6		:GET PTR TO PROCESSING ROUTINE
	J	L.BASE,R5		:JUMP TO PROCESSING ROUTINE

:TABLE OF POINTER OF DFC PROCESSING ROUTINES.
H.DFDB	HC	H.LUSD-L.BASE		:LUSTAT PROCESSING ROUTINE
	HC	H.RTRD-L.BASE		:RTR PROCESSING ROUTINE
	HC	H.BISD-L.BASE		:BIS PROCESSING ROUTINE
	HC	H.SBID-L.BASE		:SBI PROCESSING ROUTINE
	HC	H.QECD-L.BASE		:QEC PROCESSING ROUTINE
	HC	H.QCD-L.BASE		:QC PROCESSING ROUTINE
	HC	H.RELD-L.BASE		:RELQ PROCESSING ROUTINE
	HC	H.CAND-L.BASE		:CANCEL PROCESSING ROUTINE
	HC	H.CHAD-L.BASE		:CHASE PROCESSING ROUTINE
	HC	H.SHUD-L.BASE		:SHUTD PROCESSING ROUTINE
	HC	H.SHCD-L.BASE		:SHUTC PROCESSING ROUTINE
	HC	H.RSHD-L.BASE		:RSHUTD PROCESSING ROUTINE
	HC	H.BIDD-L.BASE		:BID PROCESSING ROUTINE
	HC	H.SIGD-L.BASE		:SIG PROCESSING ROUTINE
	HC	H.INVD-L.BASE		:INVALID DFC CODE ROUTINE

:SOME OF DFC MESSSAGES ARE VALID ONLY IF IT IS RESPONSE.
:DISCARD RESPONSE AND MUCB IN THIS CASE.
H.SHCD
H.RTRD
H.RSHD
H.LUSD	EQ	.
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JN	H.RCD1			:JUMP TO DISCARD IF RSP

:SOME OF DFC CODES ARE INVALID BECAUSE OF DIRECTION OR THEY ARE NOT
:SUPPORTED FOR LU TYPE 2.
H.SBID
H.BISD
H.QECD
H.QCD
H.RELD
H.INVD	EQ	.
	LR	R5,R10			:SAVE POINTER TO MUCB
	JAL	R10,CRASH,,		:CRASH
	HC	0
	BC	4*R5,CR.IMG		:INVALID MESSAGE CRASH CODE

:BID PROCESSING ROUTINE. DISCARD THE MESSAGE AND REPLY WITH +RSP.
H.BIDD	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JN	H.INVD			:RSP IS INVALID
	LHI	R1,BID			:PREPARE FOR BID RSP
H.BID1	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU ADDR
	JAL	R5,R.PBRC,,		:RELEASE BUFFERS WITH MSG
	XR	R0,R0			:INDICATE +RSP
	JAL	R5,L.GNRP		:GENERATE RSP
	J	H.RDFS			:GO SEND IT

:CANCEL PROCESSING ROUTINE. DISCARD IF RSP. GENERATE +RSP AND
:INFORM NIO IF RQ.
H.CAND	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JN	H.RCD1			:JUMP TO DISCARD IF RSP
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS
	NHI	R5,@LUSCOP&@LUSSOP	:CLEAR CHAIN AND SEGM OPEN
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	JAL	R4,GBB,,		:ACQUIRE A BUFFER FOR DUMMY FMD
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBR,,		:COUNT IT
:	LHI	R0,SNETEM!SNDTLC!SNDTCN	:INFORM NIO OF CANCEL(8/16/85/CHS)
	LHI	R0,SNETEM^8!SNDTLC!SNDTCN :INFORM NIO OF CANCEL(8/16/85/CHS)
	LIS	R2,FID2LG+3		:LENGTH OF RU IS 0
	JAL	R5,L.PTCD		:PASS CMD TO NIO
	LHI	R1,CANCEL		:PREPARE FOR CANCEL RSP
	J	H.BID1			:JUMP TO GEN AND SEND RSP

:SIGNAL PROCESSING ROUTINE. DISCARD IF RSP(SIG).
:REPLY WITH +RSP IF SIG RQ.
:IF SIG(REQUEST TO SEND) AND SENDING OF RH-ONLY CHANGE DIRECTION
:IS POSSIBLE, SEND IT, OTHERWISE IGNORE THE SIGNAL.
H.SIGD	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JN	H.RCD1			:DISCARD IF RSP
	BBLOAD	R8,BBUFER+MURUPT,R10,	:GET POINTER TO RU
	LHL	R8,BBUFER+1,R8,		:GET SIGNAL CODE
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO BTU
	JAL	R5,R.PBRC,,		:RELEASE BUFFER CHAIN WITH MSG
	LHI	R1,SIG			:PREPARE FOR SIGNAL RSP
	XR	R0,R0			:INDICATE +RSP
	JAL	R5,L.GNRP		:GENERATE RSP
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	JAL	R8,SEND,,		:SEND +RSP(SIG)
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	CHI	R8,LURQSG		:WAS SIGNAL REQUEST TO SEND?
	JEFS	H.SIG1			:JUMP IF SO
H.SIGB	LHI	R0,SNERR^8!SNERST	:STATUS ERROR OTHERWISE
	LR	R2,R8			:COPY SNA SIGNAL CODE
	JAL	R5,L.PTCD		:PASS CMD TO NIO
	JR	R14			:AND RETURN

:CHECK IF SENDING RH-ONLY FMD WITH CHANGE DIRECTION IS POSSIBLE.
H.SIG1	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JEBS	H.SIGB			:JUMP IF LU-LU DOES NOT EXIST
	LB	R5,SCBBLK+SCSTAT+FSCCSD,R7, :GET CHAIN-SEND FSM
	CHI	R5,FS.ST1		:BETWEEN CHAINS?
	JNR	R14			:RETURN IF NOT
:	LB	R5,SCBBLK+SCSTAT+FSCDSA,R7, :GET SDT-CLEAR FSM(8/17/84/CHS)
	LB	R5,SCBBLK+SCSTAT+FSCDRA,R7, :GET SDT-CLEAR FSM(8/17/84/CHS)
	CHI	R5,FS.ST3		:DATA TRAFFIC ALLOWED?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCBFP,R7, :GET FIRST SPEAKER FSM
	CHI	R5,FS.ST1		:BETWEEN BRACKETS?
	JER	R14			:RETURN IF SO
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX-FF FSM
	CHI	R5,FS.ST3		:STATE 3?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST6		:STATE 6?
	JER	R14			:CANNOT SEND, RETURN
:
:(03/13/86 YLH) BEGIN
:
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMM_RQ_MOD_SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:YES, CANNOT SEND
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:YES, CANNOT SEND
:
:(03/13/86 YLH) END
:
:GENERATE RH-ONLY RU WITH CHANGE DIRECTION AND SEND IT.
	JAL	R5,H.GNDS		:GENERATE DUMMY RU
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	OHI	R5,MU.CDI		:FORCE CHANGE DIRECTION
	STB	R5,BBUFER+MURHF3,R10,	:UPDATE 3RD BYTE OF RH
	LB	R5,LUCTAB+LUPRIL,R9,	:GET ADDR OF PRIMARY
	STB	R5,BBUFER+MUDADP,R10,	:DESTINATION PRIMARY LU
	LR	R1,R7			:COPY SCB POINTER
	JAL	R4,GBB,,		:ACQUIRE BUFFER FOR DQE
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	ST	R1,BBUFER+DQSCB,R3,	:STORE SCB PTR IN DQE(8/17/84/CHS)
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MUCB POINTER IN DQE
	STH	R9,BBUFER+DQLUCB,R3,	:STORE LUCB POINTER IN DQE
	J	H.RDFS			:JUMP TO SEND DQE

:IF SHUTD WAS RECEIVED SUSPEND ALL TRANSMISSION BY SETTING WAIT BIT
:IN LU-LU STATUS BYTE (IT WILL BE RESET WHEN UNBIND IS RECEIVED FROM
:THE HOST), SEND +RSP(SHUTD) AND THEN SHUTC.
H.SHUD	LB	R5,LUCTAB+LULUST,R9,	:GET LU-LU STATUS BYTE
	OHI	R5,WAITRS		:SET WAIT INDICATOR
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU-LU STATUS BYTE
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO SHUTD BTU
	JAL	R5,R.PBRC,,		:RELEASE BUFFERS WITH THE MSG
	LHI	R1,SHUTD		:GET RU CODE FOR RSP
	XR	R0,R0			:+RSP
	JAL	R5,L.GNRP		:GENERATE +RSP(SHUTD)
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	JAL	R8,SEND,,		:SEND THE MSG
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	LA	R8,SHTCAN,,		:POINT TO CANNED SHUTC RU
	LHI	R0,SHTLGT+3		:LENGTH OF SHUTC RU + RH
	JAL	R5,L.DFLL		:GENERATE SHUTC MSG
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MUBIUF,R10,	:GET TH BYTE 1
	OHI	R5,MU.EFI		:FORCE EXPEDITED FLOW
	STB	R5,BBUFER+MUBIUF,R10,	:UPDATE TH BYTE 1
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET POINTER TO LU-LU SCB
	LHL	R5,SCBBLK+SCESQN,R7,	:GET EXPEDITED SEQUENCE NUMBER
:	AIS	R5,1			:INCREASE IT BY 1
	STH	R5,BBUFER+MUSNF,R10,	:PUT IT IN MUCB
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND THE MSG
	JR	R14			:AND RETURN

:CHASE PROCESSING ROUTINE IS THE SAME AS IN LOCAL MODE FOR TERMIF.
	GL	H.CHAD

::::::::::::::::::::
:: RECEIVED MSG OF SC CATEGORY IN DSP MODE.
:  FOR BIND CHECK BIND PARMS.
:  IF THEY ARE GOOD AND IN ALL THE REST OF THE CASES GENERATE +RSP.
H.RDSC	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JEFS	H.RDS0			:JUMP IF RQ

:SC RSP SHOULDN'T HAVE HAPPENED. CRASH.
	JAL	R10,CRASH,,		:CRASH
	HC	0
	BC	4*R5,CR.IMG		:INVALID MSG CRASH CODE

:FOR UNBIND CHECK IF BIND IS FORTHCOMING AND NOTIFY NIO IF NOT.
H.RDS0	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R1,BBUFER,R5,		:GET RU CODE
	IF	VHRSUP
	LB	R5,LUCTAB+LUCVHR,R9,	:GET VHR STATE
	THI	R5,LUVHRF		:VHR FUNCTION?
	JN	H.RDVR			:JUMP IF SO
	EI
	CHI	R1,UNBIND		:UNBIND?
	JN	H.RDS1			:JUMP IF NOT
	LHL	R4,LUCTAB+LUCDCB,R9,	:GET POINTER TO DCB
	XR	R5,R5			:CLEAR THE REGISTER
	STH	R5,DCBLKS+DCBRUL,R4,	:CLEAR MAX RU SIZE
	LB	R4,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	NHI	R4,@LUSBST&@WAITRS	:CLEAR SUBST AND WAIT INFORMATION
	OHI	R4,LUDPCL		:START CLEANING
	STB	R4,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	LB	R4,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R4,LULUFA!LULUAK	:CLEAR ALL BUT ACK INFO
	STB	R4,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	XR	R4,R4			:CLEAR THE REGISTER
	STB	R4,LUCTAB+LULUW1,R9,	:CLEAR LUSVC 2ND WORK BYTE
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS
	THI	R5,LUSSCN		:NO SCREEN CONTROL OR UNOWNED?
:	JE	H.RDS2			:JUMP IF SO (11/07/86 YLH)
	JE	H.RDSZ			:JUMP IF SO (11/07/86 YLH)
	NHI	R5,@LUCLLU&@LUSSCN&@LUSCOP&@LUSSOP :NO LU-LU CLEANING&UNOWNED
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	LHI	R4,HSTINI		:HOST INITIATED
	JAL	R6,H.SNST		:SEND STATUS TO TIF
:
:BEGIN (11/07/86 YLH)
:IF UNBIND INDICATES THAT BIND IS NOT FORTHCOMING, THEN PASS AN
:ERROR COMMAND TO THE NIO TO BREAK THE CIRCUIT.
:
H.RDSZ
	IF	UNBNDS			:UNBIND REASON CODE IS MEANINGFUL
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R1,BBUFER,R5,		:GET RQ CODE
	LB	R5,BBUFER+1,R5,		:GET UNBIND TYPE
	LB	R4,UBNTBL,,		:THE # OF REASON CODES IS USED
	JE	H.RDSW			:AS A REPEAT COUNTER
H.RDSY	CLB	R5,UBNTBL,R4,		:IS THE REASON CODE MATCHED?
	JE	H.RDS2			:JUMP IF SO
	SIS	R4,1			:END OF THE TABLE REACHED?
	JGBS	H.RDSY			:NO, CONTINUE TO COMPARE
H.RDSW	LHI	R0,SNERR^8!SNERPO	:YES, NOTIFY NIO TO BREAK CIRCUIT
	JAL	R5,L.PTCD		:PASS CMD TO NIO
	EI (UNBNDS)
:
:END (11/07/86 YLH)
:
	J	H.RDS2			:JUMP (8/13/84/CHS)
:
	IF	VHRSUP
:VHR IN DSP STATE. UNBIND WILL CAUSE CIRCUIT BREAK. THEREFORE, NIO
:IS INFORMED AND LU_SVC GOES INTO PENDING LOCAL STATE IF UNBIND IS RECEIVED.
:BIND IN DSP STATE IS INVALID FOR VHR FUNCTION. OTHER SC MESSAGES
:ARE PROSCESSED IN THE SAME WAY AS REGULAR HOST DSP.
H.RDVR	CHI	R1,UNBIND		:UNBIND?
	JEFS	H.RDVU			:JUMP IF SO
	CHI	R1,BIND			:BIND?
	JN	H.RDS2			:JUMP IF NOT
	LHI	R0,SNERR^8!SNERBD	:PREPARE TO INFORM NIO OF BAD BIND
	JAL	R5,L.PTCD		:PASS CMD TO NIO
	J	H.RDSR			:JUMP TO CONTINUE
H.RDVU	LHL	R5,BBUFER+MUSNF,R10,	:GET SEQUENCE FIELD
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET SCB POINTER
	STH	R5,SCBBLK+SCRESN,R7,	:SAVE SEQUENCE NUMBER
H.RDVV	LHI	R0,SNRQLG^8!SNRQUB	:LOGOFF REQUEST TO NIO
	JAL	R5,L.PTCD		:SEND IT TO NIO
	LHI	R5,PLCSTA		:PENDING LOCAL STATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE BYTE
	J	H.RCD1			:JUMP TO DISCARD MSG&MUCB
	EI

:FOR BIND CHECK SESSION PARAMETERS.
H.RDS1	CHI	R1,BIND			:BIND?
	JN	H.RDS2			:JUMP IF NOT
	JAL	R5,H.CKBD		:CHECK BIND PARMS
	LR	R0,R0			:ARE THEY GOOD
	JEFS	H.RDSA			:JUMP IF SO
H.RDSR	LHI	R0,LUBDSN		:PREPARE -RSP FOR BIND
	J	H.RDSE			:JUMP TO CONTINUE

:FOR GOOD BIND SAVE ADDR OF PRIMARY IN LUCB. SAVE SEC->PRI RU SIZE IN DCB.
:ALSO UPDATE AND SEND TO TIF SCREEN STATUS.
H.RDSA	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATUS
	JEFS	H.RDSX			:JUMP IF NO SCREEN CONTROL
	NHI	R5,@LUSSCN&@LUCLLU&@LUSCOP&@LUSSOP :CLEAR SCRN ST@LU-LU CLEAN
	OHI	R5,LUSAPL		:STATUS APPLICATION
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE THE SCREEN CONTROL BYTE (03/10/86 YLH)
	LHI	R4,HSTINI		:HOST INITIATED
	JAL	R6,H.SNST		:SEND STATUS MESSAGE
H.RDSX	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGINATION ADDR
	STB	R5,LUCTAB+LUPRIL,R9,	:SAVE IT IN LUCB
	LHL	R4,LUCTAB+LUCDCB,R9,	:GET DCB POINTER
	BBLSCB	R5,LUCTAB+LULSCB,R9,	:GET SCB POINTER
	LB	R6,SCBBLK+SCSLUP,R5,	:GET SEC LU PROTOCOL BYTE
	THI	R6,80			:CHECK IF MULTIPLE CHAINS ALLOWED
	JNFS	H.RDSB			:JUMP IF SO
	XR	R5,R5			:PREPARE TO CLEAR RU LENGTH
:	JNFS	H.RDSU			:JUMP TO CONTINUE (11/13/86 YLH)
	JFS	H.RDSU			:JUMP TO CONTINUE (11/13/86 YLH)
H.RDSB	LB	R6,SCBBLK+SCSMRU,R5,	:GET MUX RU SIZE FOR SEC
	LR	R5,R6			:COPY IT
	NHI	R6,0F			:GET EXPONENT
	SRLS	R5,4			:GET MUPLIPLIER FOR EXPONENT
	SLL	R5,0,R6			:CALCULATE RU LENGTH
H.RDSU	STH	R5,DCBLKS+DCBRUL,R4,	:SAVE IT IN DCB

:RELEASE BUFFERS WITH RQ, GENERATE RSP AND PASS IT TO LOWER SNA LAYERS.
H.RDS2	XR	R0,R0			:INDICATE +RSP
H.RDSE	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO BTU
	JAL	R5,R.PBRC,,		:RELEASE THE BUF CHAIN WITH RQ
	JAL	R5,L.GNRP		:GENERATE RSP
	CHI	R1,BIND			:IS IT BIND?
	JEFS	H.RDS3			:JUMP IF SO
	CHI	R1,UNBIND		:IS IT UNBIND?
	JEFS	H.RDS3			:JUMP IF SO
	LHI	R2,TCSCSD		:OTHERWISE DESTINATION TC.SC
	JFS	H.RDS4			:JUMP TO CONTINUE
H.RDS3	LHI	R2,PMCSMS		:DESTINATION PU.CSC
	LHI	R1,0FF			:INIT THE REGISTER (09/26/85 MIA)
	STB	R1,LUCTAB+LULUW3,R9,	:INIT LINE # (09/26/85 MIA)
H.RDS4	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN

::::::::::::::::::::::::::::
:: NEGATIVE NOTIFICATIONS SHOULDN'T HAVE HAPPENED.
H.RDNT	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE CHECK BYTE
	JER	R14			:RETURN IF OK
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R5,CR.NCK		:NEG SENS-CHK SHOULDN'T HAPPEN

	EI

	FO	MAIN	
	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER

	EM
 	MO	.,SNAPKG

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN
	IF	HDPSUP			:(12/04/85/CHS)
	GL	L.RMTF,H.DPLH

::::::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS A CODE FOR HOST DSP SUPPORT (SEND SIDE) OF
:: LU SERVICE MANAGER.
::::::::::::::::::::::::::::::::::::::::::

	SEG	A.CODE
::::::::::::::::::::::::::::::::::
:ENTRY POINTS FOR LU SEND PROCESS FOR HOST DSP SUPPORT ARE H.DPST (STATUS
:COMMAND FORM NIO) AND H.DPET (END-TO-END MESSAGE FROM NIO).

:	IF	HDPSUP			:(12/04/85/CHS)

	LO	SHDPKG
:::::::::::::::::::::::::::::::::::::::
::STATUS COMMAND PROCESSING ROUTINE.
::PROCESSING DEPENDS ON WHETHER IT IS FORCED ERROR RECOVERY
::OR DSP STATUS.
::FOR DSP STATUS CHECK WHETHER WE CAN SEND AND GENERATE SIGNAL WITH
::REQUEST TO SEND IF WE CANNOT SEND AND LU-LU SESSION EXISTS.
::THEN CONVERT DSP STATUS CODE TO SNA AND SNED LUSTAT WITH THIS
::STATUS CODE.
::FOR FORCED ERROR RECOVERY DO THE SAME IF WE CAN SEND EXCEPT STATUS
::CODE IS ALWAYS 82B (PRESENTATION SPACE INTEGRITY LOST).
::IF WE CANNOT SEND PREPARE TO SEND -RSP(82B) FOR THE NEXT FMD.
::ALSO INDICATE CLEANING AFTER FORCED ERROR RECOVERY.
:::::::::::::::::::::::::::::::::::::::

H.DPST	CHI	R1,NSFRER		:IS IT FORCED ERROR RECOVERY?
	JE	H.DPSF			:JUMP IF SO

:PREPARE TO SEND LUSTAT.
	LH	R1,CMDBLK+CLLNG,R8,	:GET STATUS CODE FROM DSP
	LR	R9,R4			:COPY LUCB POINTER

:FOR LU TYPE 3 (PRINTER) DEVICE END STATUS COULD BE RECEIVED OCCAIONALLY.
:THROW IT AWAY, BUT FIRST DO EVERYTHING LIKE IT WERE INTERNALLY GENERATED
:MESSAGE (THIS MESSAGE IS NOT GENERATED IF ANYTHING WAS ALREADY IN
:NIO->SNA DATA QUEUE).
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
					:(F00/02/23/87/DB)
	CHI	R5,LU.T1		:TYPE 1?
	JEFS	H.DPSB			:YES
					:(F00/02/23/87/DB)
	CHI	R5,LU.T3		:TYPE 3?
	JN	H.DPSA			:JUMP IF NOT
:	(1/20/87/CHS) DEVICE END CODE FOR HITACHI IS
:		DIFFERENT FROM OTHERS
H.DPSB					:(F00/02/23/87/DB)
	LB	R5,LUCTAB+LUCSYS,R9,
	CLHI	R5,HITACHI		:HITACHI?
	JN	H.DPSX			:NO, SKIP
	CLHI	R1,DVENDH		:YES, GET C4C0
	JE	H.DPLG			:SKIP, DEVICE END
	J	H.DPSA			:ELSE,..
H.DPSX
:	(1/20/87/CHS) END
	CHI	R1,DEVEND		:DEIVCE END?
	JE	H.DPLG			:JUMP OF SO
H.DPSA	LA	R8,LUSTCN,,		:POINT TO LUSTAT CANNED MSG
	LIS	R0,LUSTLG+3		:LUSTAT LENGTH (+RH)

:WE HAVE TO SEND LUSTAT ON LU-LU SESSION.
:CHECK THAT SESSION EXISTS.
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET PTR TO LU-LU SCB
	JE	H.DPS1			:JUMP IF INVALID POINTER

:LU-LU SESSION EXISTS. CHECK SDT-CLEAR STATE.
	LB	R5,SCBBLK+SCSTAT+FSCDRA,R7,	:SDT-CLEAR FSM STATE
	CHI	R5,FS.ST3		:IS DATA TRAFFIC ALLOWED?
	JNR	R14			:RETURN IF NOT

:CHECK IF THE WHOLE BIU WAS RECEIVED.
	LB	R5,SCBBLK+SCSTAT+FSCBUA,R7,	:GET BIU_ASSEMBLY STATE
	JNR	R14			:RETURN IF NOT BETS

:CHECK WITH HDX_FF FSM THAT WE CAN SEND.
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX_FF STATE
	CHI	R5,FS.ST3		:STATE 3?
	JE	H.DPES			:CANNOT SEND, JUMP TO SEND SIGNAL
	CHI	R5,FS.ST5		:STATE 5?
	JE	H.DPES			:CANNOT SEND, JUMP TO SEND SIGNAL
	CHI	R5,FS.ST6		:STATE 6?
	JE	H.DPES			:CANNOT SEND, JUMP TO SEND SIGNAL
	CHI	R5,FS.ST8		:STATE 8?
	JE	H.DPES			:CANNOT SEND, JUMP TO SEND SIGNAL

:LU TYPE 2 HAS IMMEDIATE REQUEST MODE. IF RSP FOR PREVIOUS RQD
:WAS NOT YET RECEIVED RETURN WITHOUT DOING ANYTHING (HOPEFULLY NEXT
:TIME RSP WILL NE RECEIVED AND WE WILL BE ABLE TO SEND).
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7, :GET IMM_RCV STATE
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO

:CONVERT DSP STATUS CODE TO SNA STATUS CODE, GENERATE LUSTAT AND
:SEND IT.
	JAL	R5,H.CVLL		:CONVERT STATUS CODE
H.DPSL	STH	R1,LUSTCN+1,,		:STORE STATUS CODE IN LUSTAT
	JAL	R5,L.DFLL		:GENERATE LUSTAT
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R4,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	OHI	R4,MU.CDI		:SET CHANGE DIRECTION
	LB	R5,SCBBLK+SCSTAT+FSCBFP,R7,	:GET BSM-FIRST-SPEAKER
	CHI	R5,FS.ST1		:STATE BETB?
	JNFS	H.DPS0			:JUMP IF NOT
	OHI	R4,MU.BBI		:BEGIN BRACKET
H.DPS0	STB	R4,BBUFER+MURHF3,R10,	:UPDATE 3RD BYTE OF RH
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	NHI	R5,@LUDPSG		:RESET SIGNAL SENT BIT
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
H.DPSE	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LUSEND		:ORIGINATION LUSEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND IT
	JR	R14			:AND RETURN

:LU-LU SESSION DOES NOT EXIST.
:CHECK WHETHER SSCP-LU STATE MACHINE ALLOWS TO SEND AND SEND THE
:LUSTAT IF SO.
H.DPS1	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:POINT TO SSCP-LU SCB
	LB	R5,SCBBLK+SCSTAT+FSCBUA,R7,	:GET BIU_ASSEMBLY STATE
	JNR	R14			:RETURN IF NOT BETS

:LU TYPE 2 HAS IMMEDIATE REQUEST MODE. IF RSP FOR PREVIOUS RQD
:WAS NOT YET RECEIVED RETURN WITHOUT DOING ANYTHING (HOPEFULLY NEXT
:TIME RSP WILL NE RECEIVED AND WE WILL BE ABLE TO SEND).
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7, :GET IMM_RCV STATE
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO

	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX_FF STATE
	CHI	R5,FS.ST3		:STATE 3?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST6		:STATE 6?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST8		:STATE 8?
	JER	R14			:RETURN IF SO
	JAL	R5,H.CVSL		:CONVERT DSP STATUS CODE TO SNA
H.DPSK	STH	R1,LUSTCN+1,,		:STORE STATUS CODE IN LUSTAT
	JAL	R5,L.DFSL		:GENERATE LUSTAT
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	H.DPSE			:JUMP TO SEND IT

:FORCED ERROR RECOVERY RQUEST FROM NIO.
:AN ATTEMPT IS MADE TO INFORM THE HOST THAT PRESENTATION SPACE INTEGRITY
:WAS LOST. THIS IS DONE BY EITHER SENDING LUSTAT(82B) OR -RSP(82B)
:FOR THE NEXT FMD (DEPENDING ON WHETHER HALF-SESSION IS IN SEND
:OR RECEIVE STATE, HALF-SESSION IS LU-LU IF IT EXISTS, OTHERWISE IT
:IS SSCP-LU). HOWEVER BEFORE DOING IT WE HAVE TO INSURE THAT
:WE ARE BETWEEN SEGMENT AND CHAIN STATES.
:
:PROCESSING IS SLIGHTLY DIFFERENT FOR LU-LU AND SSCP-LU.
:FIRST INDICATE CLEANING AND CANCEL PENDING (THE LATTER TO INSURE
:THAT THE COMMAND IS NOT REMOVED BY REMOVE PROCESS UNTIL CANCEL
:PENDING IS RESET).
H.DPSF	LR	R9,R4			:COPY THE REGISTER
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	OHI	R5,LULUCN		:SET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUDPCL		:SET CLEANING PENDING
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JE	H.DPS4			:JUMP IF LU-LU DOES NOT EXIST

:LU-LU SESSION EXISTS.
:CHECK IF WE ARE BETWEEN SEGMENTS (LAST SEGMENT SENT) AND SEND
:DUMMY LAST SEGMENT IF NOT.
	LHL	R5,LUCTAB+LUCDCB,R9,	:GET DCB POINTER
	LB	R5,DCBLKS+DCBDSH,R5,	:GET DSP STATUS
	THI	R5,DSHSEG		:FIRST SEGMENT?
	JE	H.DPS2			:JUMP IF SO
	JAL	R5,H.GNDS		:GENERATE DUMMY SEGMENT
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	NHI	R5,@MU.BIU		:NOT THE 1ST SEGMENT
	STB	R5,BBUFER+MUBIUF,R10,	:UPDATE 1ST BYTE OF TH
	LB	R5,LUCTAB+LUPRIL,R9,	:GET PRIMARY ADDR
	STB	R5,BBUFER+MUDADP,R10,	:UPDATE MUCB DESTINATION
	J	H.DPEH			:JUMP TO SEND THE MSG

:LU-LU SESSION IN BETWEEN SEGMENTS STATE.
:CHECK IF HDX-FF IS IN SEND OR RECEIVE STATE.
H.DPS2	LB	R5,SCBBLK+SCSTAT+FSCDRA,R7,	:GET SDT-CLEAR FSM
	CHI	R5,FS.ST3		:DATA TRAFFIC ALLOWED?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCBUA,R7,	:GET BIU_ASSEMBLY STATE
	JNR	R14			:RETURN IF NOT BETS
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX-FF FSM
	CHI	R5,FS.ST3		:STATE 3?
	JE	H.DPSR			:CANNOT SEND, JUMP
	CHI	R5,FS.ST5		:STATE 5?
	JE	H.DPSR			:CANNOT SEND, JUMP
	CHI	R5,FS.ST6		:STATE 6?
	JE	H.DPSR			:CANNOT SEND, JUMP
	CHI	R5,FS.ST8		:STATE 8?
	JE	H.DPSR			:CANNOT SEND, JUMP

:LU TYPE 2 HAS IMMEDIATE REQUEST MODE. IF RSP FOR PREVIOUS RQD
:WAS NOT YET RECEIVED RETURN WITHOUT DOING ANYTHING (HOPEFULLY NEXT
:TIME RSP WILL NE RECEIVED AND WE WILL BE ABLE TO SEND).
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7, :GET IMM_RCV STATE
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO

:IF WE ARE WITHIN CHAIN GENERATE CANCEL.
	LHL	R5,SCBBLK+SCTSNG,R7,	:GET GET PTR TO CT
	CH	R5,SCBBLK+SCTSNR,R7,	:IS CT EMPTY?
	JEFS	H.DPS3			:JUMP IF SO
	LB	R5,BBUFER+CLARG6,R5,	:GET BYTE WITH CT ENTRY TYPE
	NHI	R5,CT.ENT		:GET CT ENTRY TYPE
	JE	H.DPEC			:JUMP TO SEND CANCEL IF BETC

:GENERATE AND SEND LUSTAT(82B). ALSO RESET CANCEL PENDING.
:STATUS COMMAND WILL BE REMOVED WHEN NOTIFICATION FOR LUSTAT IS RECEIVED.
H.DPS3	LA	R8,LUSTCN,,		:POINT TO LUSTAT CANNED MSG
	LIS	R0,LUSTLG+3		:LENGTH OF LUSTAT (+RH)
	LHI	R1,LUONSN		:82B LUSTAT CODE
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUCN		:RESET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	H.DPSL			:JUMP TO SEND LUSTAT

:LU-LU SESSION DOES NOT EXIST.
:FIRST MAKE SURE THAT WE ARE BETWEEN SEGMENTS AND GENERATE DUMMY
:LAST SEGMENT IF NOT.
H.DPS4	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET SSCP-LU SCB POINTER
	LHL	R5,LUCTAB+LUCDCB,R9,	:GET DCB POINTER
	LB	R5,DCBLKS+DCBDSH,R5,	:GET DSP STATUS
	THI	R5,DSHSEG		:FIRST SEGMENT?
	JE	H.DPS5			:JUMP IF BETS
	JAL	R5,H.GNDS		:GENERATE DUMMY RU
	LHL	R5,SCBBLK+SCSQSC,R7,	:GET PREVIOUS ID
	STH	R5,BBUFER+MUSNF,R10,	:UPDATE MUCB
	LB	R5,BBUFER+MURHF2,R10,	:GET BYTE 2 OF RH
	NHI	R5,@MU.ERI		:CLEAR ERI
	STB	R5,BBUFER+MURHF2,R10,	:UDATE BYTE 2 OF RH
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	NHI	R5,@MU.BIU		:NOT FIRST SEGMENT
	STB	R5,BBUFER+MUBIUF,R10,	:UPDATE 1ST BYTE OF TH
	J	H.DPEH			:JUMP TO SEND THE MSG

:CHECK IF WE ARE IN SEND STATE.
H.DPS5	LB	R5,SCBBLK+SCSTAT+FSCBUA,R7,	:GET B_ASSEMBLY S STATE
	JNR	R14			:RETURN IF NOT BETS
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX-FF FSM
	CHI	R5,FS.ST3		:STATE 3?
	JE	H.DPSQ			:CANNOT SEND, JUMP
	CHI	R5,FS.ST5		:STATE 5?
	JE	H.DPSQ			:CANNOT SEND, JUMP
	CHI	R5,FS.ST6		:STATE 6?
	JE	H.DPSQ			:CANNOT SEND, JUMP
	CHI	R5,FS.ST8		:STATE 8?
	JE	H.DPSQ			:CANNOT SEND, JUMP

:LU TYPE 2 HAS IMMEDIATE REQUEST MODE. IF RSP FOR PREVIOUS RQD
:WAS NOT YET RECEIVED RETURN WITHOUT DOING ANYTHING (HOPEFULLY NEXT
:TIME RSP WILL NE RECEIVED AND WE WILL BE ABLE TO SEND).
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7, :GET IMM_RCV STATE
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO

:SEND DUMMY END OF CHAIN IF WE ARE IN BETC STATE.
	LH	R5,SCBBLK+SCTSNG,R7,	:GET GET PTR TO CT
	CH	R5,SCBBLK+SCTSNR,R7,	:CT EMPTY?
	JEFS	H.DPS6			:JUMP IF SO
	LHL	R5,SCBBLK+SCTSNG,R7,	:GET GET PTR TO CT
	BBLOAD	R5,CMDBLK+CLARG,R5,	:GET POINTER TO CT ELEMENT
	LB	R5,BBUFER+CLARG6,R5,	:GET BYTE WITH CT ENTRY TYPE
	NHI	R5,CT.ENT		:GET ENTRY TYPE
	JE	H.DPEN			:JUMP TO GEN DUMMY EC IF PART CH

:SEND LUSTAT(82B) ON SSCP-LU SESSION.
:ALSO RESET CANCEL PENDING TO ALLOW REMOVAL OF STATUS COMMAND FORM NIO.
H.DPS6	LA	R8,LUSTCN,,		:POINT TO CANNED LUSTAT
	LIS	R0,LUSTLG+3		:LENGTH OF LUSTAT (+RH)
	LHI	R1,LUONSN		:STATUS CODE 82B
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUCN		:RESET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	H.DPSK			:JUMP TO SEND LUSTAT

:FSM-HDX-FF IS IN RECEIVE STATE.
:SET PENDING NEGATIVE RESPONSE IN LUCB. RECEIVE PROCESS WILL SEND -RSP(82B)
:FOR THE FIRST FMD AFTER THIS MOMENT (EXCEPTION - IF UNBIND WAS RECEIVED
:BETWEEN THIS MOMENT AND RECEPTION OF 1ST FMD).
H.DPSQ
H.DPSR	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	OHI	R5,LULUNG!LULURP	:PREPARE FOR -RSP
	NHI	R5,@LULUCN		:RESET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	H.RMD0			:JUMP TO REMOVE CMD LINK

::::::::::::::::::::::::::::::::::::::
::END-TO-END MESSAGE FROM NIO.
::CHECK IF WE CAN SEND IT. IF NOT AND LU-LU SESSION EXISTS SEND
::SIGNAL WITH REQUEST TO SEND.
::IF WE CAN SEND THE MESSAGE IS MAPPED TO SNA CANONICAL FORM.
::IF LU-LU SESSION DOES NOT EXIST IT IS ALSO CONVERTED TO SNA
::CHARACTER STREAM.
::::::::::::::::::::::::::::::::::::::

H.DPET	EQ	.
:H.DPET	LB	R5,LUCTAB+LULUST,R4,	:GET LUSVC STATE BYTE(6/25/85/CHS, START)
	BBLOAD	R5,CMDBLK+CLARG,R8,
	AIS	R5,FID2LG+3
	LB	R5,BBUFER,R5,		:GET THE AID BYTE
	CLHI	R5,AIDCLR		:CLAER KEY?
	JNFS	H.DPEX			:NO, SKIP
	LIS	R5,0			:ELSE, CLEAR LULUW3
	STB	R5,LUCTAB+LULUW3,R4,
H.DPEX	LB	R5,LUCTAB+LULUST,R4,	:GET LUSVC STATE BYTE(6/25/85/CHS, END)
	THI	R5,LUDPCL		:DO WE HAVE TO CLEAN?
	JN	H.DPCL			:JUMP TO CLEAN ROUTINE IF SO

:WE HAVE TO SEND THE MESSAGE ON LU-LU SESSION.
:CHECK THAT SESSION EXISTS.
H.DPE0	LB	R5,LUCTAB+LUCSCN,R4,	:GET SCREEN STATE
	JE	H.DPEW			:JUMP IF NO SCREEN CONTROL
	THI	R1,NSDTLS!NSDTLC	:1ST SEGMENT OF 1ST RU IN CHAIN?
	JN	H.DPEW			:JUMP IF NOT
	BBLOAD	R7,CMDBLK+CLARG,R8,	:GET POINTER TO HEAD BUFFER
	LB	R6,BBUFER+THDISP+FID2LG+3,R7,	:GET AID
	CHI	R6,SRQAID		:SYSTEM REQUEST?
	JE	H.DPRQ			:JUMP IF SO
	CHI	R6,ATTAID		:ATTENTION KEY?
	JE	H.DPAT			:JUMP IF SO
	NHI	R5,LUSSCN		:LEAVE STATE ONLY
	CHI	R5,LUSSYS		:SYSTEM?
	JE	H.DPE1			:JUMP TO SEND SSCP-LU IF SO
	CHI	R5,LUSUNW		:UNOWNED?
	JEFS	H.DPXW			:YES (03/21/86 YLH)
	CHI	R5,LUSFUW		:FORCE UNOWNED? (03/21/86 YLH)
	JNFS	H.DPEW			:NO,, NORMAL PROCESSING (03/19/86 YLH)
H.DPXW	LR	R9,R4			:YES, LOAD R9 WITH THE LUCB PTR (03/19/86 YLH)
	J	H.DPXX			:JUMP TO SEND ERROR STATUS (03/19/86 YLH)
H.DPEW	BBLSCB	R7,LUCTAB+LULSCB,R4,	:GET PTR TO LU-LU SCB
	JE	H.DPE1			:JUMP IF INVALID POINTER

:LU-LU SESSION EXISTS. CHECK SDT-CLEAR STATE.
	LB	R5,SCBBLK+SCSTAT+FSCDRA,R7,	:SDT-CLEAR FSM STATE
	CHI	R5,FS.ST3		:IS DATA TRAFFIC ALLOWED?
	JNR	R14			:RETURN IF NOT

:IF THE FIRST SEGMENT CHECK WITH HDX_FF FSM THAT WE CAN SEND.
	THI	R1,NSDTLS		:IS IT THE FIRST SEGMENT?
:	JN	H.DPE3			:JUMP IF NOT (8/16/84/CHS)
:FOR READ MODIFIED ALL SIMULATION DISCARD DUMMY INTERMEDIATE SEGMENTS
:AND DUMMY INTERMEDIATE CHAIN ELEMENTS.
	IF	RMDALL
	JE	H.DPER			:JUMP IF SO
	THI	R1,NSDTFS		:LAST SEGEMENT?
	JE	H.DPE4			:JUMP IF SO
	LHL	R5,CMDBLK+CLLNG,R8,	:GET BIU LENGTH
	SIS	R5,FID2LG		:MINUS TH LENGTH
	JG	H.DPE4			:JUMP IF NOT DUMMY
	J	H.DPCE			:OTHERWISE DISCARD IT
H.DPER	THI	R1,NSDTFS		:LAST SEGMENT?
	JNFS	H.DPEP			:JUMP IF NOT
	THI	R1,NSDTFC		:LAST IN CHAIN?
	JEFS	H.DPEP			:JUMP OF SO
	THI	R1,NSDTLC		:FIRST IN CHAIN?
	JEFS	H.DPEP			:JUMP IF SO
	LHL	R5,CMDBLK+CLLNG,R8,	:GET BIU LENGTH
	SIS	R5,FID2LG+3		:DUMMY RU?
	JLE	H.DPCE			:JUMP TO DISCARD IF SO
H.DPEP	EQ	.
	ELSE
	JN	H.DPE4			:JUMP IF NOT 1ST SEG (8/16/84/CHS)
	EI
	LB	R5,SCBBLK+SCSTAT+FSCBUA,R7,	:GET BIU_ASSEMBLY STATE
	JNR	R14			:RETURN IF NOT BETS
	LB	R5,SCBBLK+SCSTAT+FSCBFP,R7,	:GET BSM_FSP STATE
	CHI	R5,FS.ST3		:STATE 3?
	JE	H.DPES			:CANNOT SEND, JUMP
	CHI	R5,FS.ST5		:STATE 5?
	JE	H.DPES			:CANNOT SEND, JUMP
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX_FF STATE
	CHI	R5,FS.ST3		:STATE 3?
	JEFS	H.DPES			:CANNOT SEND, JUMP
	CHI	R5,FS.ST5		:STATE 5?
	JEFS	H.DPES			:CANNOT SEND, JUMP
	CHI	R5,FS.ST6		:STATE 6?
	JEFS	H.DPES			:CANNOT SEND, JUMP
	CHI	R5,FS.ST8		:STATE 8?
	JN	H.DPE3			:JUMP IF WE CAN SEND

:WE HAVE TO SEND A DATA MESSAGE BUT HDX-FF STATE MACHINE IS NOT IN
:SEND STATE. SEND SIGNAL TO THE HOST REQUESTING CHANGE OF DIRECTION.
H.DPES	EQ	.
	IF	SIGNSW
	LB	R5,SCBBLK+SCSTAT+FSCCIE,R7,	:CHECK IMMED-EXP FSM
	CHI	R5,FS.ST1		:RESET STATE?
	JNR	R14			:CANNOT SEND SIGNAL IF NOT
	LB	R5,LUCTAB+LULUST,R4,	:GET LUSVC STATE BYTE
	THI	R5,LUDPSG		:WAS SIGNAL ALREADY SEND?
	JNR	R14			:RETURN IF SO
	OHI	R5,LUDPSG		:SHOW THAT SIGNAL WAS SENT
	STB	R5,LUCTAB+LULUST,R4,	:UPDATE LUSVC STATE BYTE
	LA	R8,SIGCAN,,		:POINT TO CANNED SIGNAL (CHGR DIR)
	LHI	R0,SIGLGT+3		:LENGTH OF MSG (+RH)
	LR	R9,R4			:COPY LUCB POINTER
	JAL	R5,L.DFLL		:GENERATE SIGNAL MSG
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	OHI	R5,MU.EFI		:SHOW EXPEDITED FLOW
	STB	R5,BBUFER+MUBIUF,R10,	:UPDATE 1ST BYTE OF TH
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LUSEND		:ORIGINATION LU.SEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	EI
	JR	R14			:AND RETURN

:LU-LU SESSION DOES NOT EXIST.
:CHECK WHETHER SSCP-LU STATE MACHINE ALLOWS TO SEND AND SEND THE
:MESSAGE IF SO AFTER CONVERTING IT TO SNA CHARATER STREAM.
H.DPE1	BBLSCB	R7,LUCTAB+LUSSCB,R4,	:POINT TO SSCP-LU SCB
	THI	R1,NSDTLS		:FIRST SEGMENT?
	JN	H.DPE2			:JUMP IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCBUA,R7,	:GET BIU_ASSEMBLY STATE
	JNR	R14			:RETURN IF BETS
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX_FF STATE
	CHI	R5,FS.ST3		:STATE 3?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST6		:STATE 6?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST8		:STATE 8?
	JER	R14			:CANNOT SEND, RETURN

:LU TYPE 2 HAS IMMEDIATE REQUEST MODE. IF RSP FOR PREVIOUS RQD
:WAS NOT YET RECEIVED RETURN WITHOUT DOING ANYTHING (HOPEFULLY NEXT
:TIME RSP WILL NE RECEIVED AND WE WILL BE ABLE TO SEND).
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7, :GET IMM_RCV STATE
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO

H.DPE2	JAL	R5,H.MTSC		:MAP MSG TO SCS-CANONICAL
	LR	R0,R0			:MAP SUCCESSFUL?
	JE	H.DPEA			:JUMP IF SO

:CONVERSION TO SCS FAILED (MESSAGE TOO LONG IS ONE POSSIBLE REASON).
:GENERATE AND SEND TO DSP "COMMAND UNRECOGNAIZED" MESSAGE AND
:START ERROR RECOVERY.
	LR	R9,R4			:COPY LUCB POINTER
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET BTU POINTER
	JAL	R5,R.PBBC,,		:RELEASE BTU
:	LR	R3,R10			:COPY MUCB POINTER(3/14/86/CHS)
:	JAL	R4,R.PBB,,		:COUNT IT (3/14/86/CHS)
					:MUCB IS NOT DESTROYED YET 
	LB	R5,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE
	JEFS	H.DPEQ			:JUMP IF NO SCREEN CONTROL
	LR	R3,R10			:(3/14/86/CHS)
	JAL	R5,R.PBBC,,		:RELEASE MUCB (3/14/86/CHS)
H.DPXX	LHI	R4,HSTINI		:HOST INITIATED
	LIS	R5,LUSERR		:ERROR IN INPUT
	JAL	R6,H.SNST		:SEND STATUS MESSAGE TO TIF
	J	H.DPEJ			:JUMP TO CONTINUE
H.DPEQ
	JAL	R4,GBB,,		:GET NEW BB FOR MSG
	J	NOBUFF			:TO CRASH..
	JAL	R4,R.GBR,,		:COUNT IT
	LHL	R4,LUURMG,,		:ASSUME ENGLISH VERSION
	LB	R5,LUCTAB+LUCDIF,R9,	:SEE IF KATAKANA AND KANJI
	NHI	R5,07			:...
	CLHI	R5,4			:KATAKANA = 4, KANJI =5
	JLFS	H.DPEY			:ENGLISH VERSION, SKIP
	LHL	R4,LUURMG+2,,		:ELSE, JAPANESE VERSION
H.DPEY
	AI	R4,PSEG
	LHL	R5,0,R4			:GET MSG LENGTH
	AIS	R4,2			:R4 = ADDR OF "CMD UNRECO" MSG
	LR	R0,R5
	AIS	R0,3			:DCF 
	STH	R0,BBUFER+MUDCF,R10,	:NEW MUDCF
	BBSTOR	R3,BBUFER+MUCBTU,R10,	:NEW MUCBTU
	SIS	R5,1			:GET LENGTH-1 OF MSG
	LR	R2,R5			:COPY IT
H.DPEU	JLFS	H.DPEV			:JUMP IF FINISHED
	LB	R0,0,R5,R4		:GET CHAR FROM CANNED MSG
	STB	R0,BBUFER+THDISP+FID2LG+3,R3,R5	:COPY IT IN THE BUFFER
	SIS	R5,1			:MOVE TO PREVIOUS CHAR
	JBS	H.DPEU			:JUMP TO CONTINUE
H.DPEV
	LHI	R0,03			:SET UP MURHF1 (4/14/86/CHS)
	STB	R0,BBUFER+MURHF1,R10,	:...(4/14/86/CHS)
	LHI	R0,2C			:SET UP MUBIUF (4/14/86/CHS)
	STB	R0,BBUFER+MUBIUF,R10,	:... (4/14/86/CHS)
	JAL	R5,H.CVRT		:CONVERT TO 3270 DP
	LHI	R0,SNETEM^8!SNDTCD	:END-TO-END MSG WITH CD
:	AIS	R2,FID2LG+4		:LENGTH OF MSG + TH + RH(4/14/86/CHS)
	LHL	R2,BBUFER+MUDCF,R10,	:GET NEW MUDCF (4/14/86/CHS)
	AIS	R2,FID2LG		:LENGTH OF MSG + RH + TH (4/14/86/CHS)
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET DATA BBUF (4/14/86/CHS)
	JAL	R5,L.PTCD		:PASS CMD TO NIO
	LR	R3,R10			:RELEASE MUCB (4/14/86/CHS)
	JAL	R5,R.PBBC,,		:... (4/14/86/CHS)
H.DPEJ	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUDPCL		:START CLEANING
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	J	H.RMD0			:JUMP TO RELEASE CMD LINK

:CANCEL IS NOT ALLOWED ON SSCP-LU SESSION.
:IF WE HAVE CANCEL INDICATOR ON IGNORE IT, BUT FORCE LAST SEGMENT AND
:LAST CHAIN ELEMENT.
H.DPEA	THI	R1,NSDTCN		:WAS CANCEL REQUESTED?
	JE	H.DPEE			:JUMP IF NOT
	LB	R5,LUCTAB+LULUWK,R4,	:GET LUSVC WORK BYTE
	THI	R5,LULUCN		:CANCEL PENDING?
	JN	H.DPEL			:JUMP IF SO
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	LR	R0,R5			:SAVE IT
	OHI	R5,MU.EIU		:FORCE LAST SEGMENT
	STB	R5,BBUFER+MUBIUF,R10,	:UPDATE 1ST BYTE OF TH
	THI	R0,MU.BIU		:1ST SEGMENT?
	JEFS	H.DPEK			:JUMP IF NOT
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	OHI	R5,MU.ECI		:FORCE LAST CHAIN ELEMENT
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE 1ST BYTE OF RH
	J	H.DPEE			:JUMP TO CONTINUE

:THIS IS NOT THE 1ST SEGMENT OF SSCP-LU MSG AND CANCEL WAS REQUESTED.
:WE HAVE TO FORCE THE LAST CHAIN ELEMENT IF CORRELATION TABLES
:SHOW THAT LAST LAST ELEMENT OF THE CHAIN WAS NOT SENT.
:FIRST CHECK CORRELATION TABLE. IF NOT COMPLETE CHAIN SHOW THAT
:CANCEL IS PENDING.
H.DPEK	LHL	R5,SCBBLK+SCTSNG,R7,	:GET CT ELEMENT
	CH	R5,SCBBLK+SCTSNR,R7,	:ANYTHIG THERE
	JE	H.DPEE			:JUMP IF NOT
	LB	R5,BBUFER+CLARG6,R5,	:GET BYTE WITH CT TYPE
	NHI	R5,CT.ENT		:GET CT TYPE
	JN	H.DPEE			:JUMP IF COMPLETE CHAIN
	LB	R5,LUCTAB+LULUWK,R4,	:GET LUSVC WORK BYTE
	OHI	R5,LULUCN		:SHOW THAT CANCEL IS PENDING
	STB	R5,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
	J	H.DPEE			:JUMP TO CONTINUE

:CANCEL IS PENDING AND THIS IS SSCP-LU MSG.
:WE CANNOT GENERATE CANCEL, BUT WE MUST FORCE THE LAST CHAIN ELEMENT.
:GENERATE DUMMY (RH-ONLY) FMD AND SHOW LAST (BUT NOT FIRST) CHAIN ELEMENT.
:ALSO RESET CANCEL PENDING (REMOVE PROCESS WILL REMOVE CMD LINK WITH
:CANCEL REQUEST AFTER THAT).
H.DPEL	NHI	R5,@LULUCN		:RESET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
H.DPEN	JAL	R5,H.GNDS		:GENERATE DUMMY RU
	LB	R5,BBUFER+MURHF2,R10,	:GET BYTE 2 OF RH
	NHI	R5,@MU.ERI		:CLEAR ERI
	STB	R5,BBUFER+MURHF2,R10,	:UPDATE BYTE 2 OF RH
	LHL	R5,SCBBLK+SCSQSC,R7,	:GET PREVIOUS ID
	AIS	R5,1			:INCREASE IT BY 1
	STH	R5,SCBBLK+SCSQSC,R7,	:UPDATE ID IN SCB
	STH	R5,BBUFER+MUSNF,R10,	:UPDATE MUCB
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,@MU.BCI		:NOT 1ST CHAIN ELEMENT
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE 1ST BYTE OF RH
	J	H.DPEE			:JUMP TO CONTINUE

:LU TYPE 2 HAS IMMEDIATE REQUEST MODE. IF RSP FOR PREVIOUS RQD
:WAS NOT YET RECEIVED RETURN WITHOUT DOING ANYTHING (HOPEFULLY NEXT
:TIME RSP WILL NE RECEIVED AND WE WILL BE ABLE TO SEND).
H.DPE3	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7, :GET IMM_RCV STATE
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:RETURN IF NOT

:IF CANCEL IS PENDING AS INDICATED BY LUSVC WORK BYTE GENERATE CANCEL
:MESSAGE ANS SEND IT. THE MESSAGE ITSELF IS NOT SENT THIS TIME (IT
:WAS SENT DURING PREVIOUS EXECUTION OF LU.SEND WHEN PEND INDICATOR
:WAS SET AND LEFT IN NIO->SNA DATA QUEUE TO CAUSE THE SCHEDULER
:TO CALL LUSCV AGAIN). THE MESSAGE WILL BE REMOVED BY REMOVE ROUTINE
:WHEN IT PROCESSES CANCEL NOTIFICATION FROM LOWER SNA LAYERS.
	LB	R5,LUCTAB+LULUWK,R4,	:GET LUSVC WORK BYTE
	THI	R5,LULUCN		:CANCEL PENDING?
	JE	H.DPE4			:JUMP IF NOT
	NHI	R5,@LULUCN		:RESET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
	LR	R9,R4			:COPY LUCB POINTER
H.DPEC	LA	R8,CANCAN,,		:POINT TO CANNED CANCEL MSG
	LHI	R0,CANLGT+3		:LENGTH OF CANCEL (+RH)
	JAL	R5,L.DFLL		:GENERATE CANCEL
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	OHI	R5,MU.CDI		:CHANGE DIRECTION
	STB	R5,BBUFER+MURHF3,R10,	:UPDATE 3RD BYTE OF RH
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LUSEND		:ORIGINATION LU.SEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN

:MAP MESSAGE TO CANONICAL.
H.DPE4	JAL	R5,L.MTCN		:MAP TO CANONICAL
	BBLSCB	R5,LUCTAB+LULSCB,R4,	:GET LU-LU SCB POINTER
	LHL	R5,SCBBLK+SCSQSC,R5,	:GET LATEST SEQ NUMBER
	STH	R5,BBUFER+MUSNF,R10,	:STORE IT IN MUCB
	LB	R5,LUCTAB+LULUST,R4,	:GET LUSVC STATE BYTE
	NHI	R5,@LUDPSG		:CLEAR SIGNAL SENT INDICATOR
	STB	R5,LUCTAB+LULUST,R4,	:UPDATE LUSVC STATE BYTE

:IF CANCEL IS REQUESTED BY NIO INDICATE IT IN LUSVC WORK BYTE. ALSO
:FORCE LAST SEGMENT BUT NOT THE LAST CHAIN ELEMENT.
	THI	R1,NSDTCN		:CANCEL REQUESTED BY NIO?
	JE	H.DPEE			:JUMP IF NOT
	LB	R5,LUCTAB+LULUWK,R4,	:GET LUSVC WORK BYTE
	OHI	R5,LULUCN		:SET CANCEL PENDING
	STB	R5,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	OHI	R5,MU.EIU		:FORCE LAST SEGMENT
	STB	R5,LUCTAB+LULUWK,R10,	:UPDATE 1ST BYTE OF TH
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,@MU.ECI		:FORCE NOT THE LAST CHAIN ELEMENT
	STB	R5,LUCTAB+MURHF1,R10,	:UPDATE 1ST BYTE OF RH

:IF NIO REQUESTED END-TO-END ACK SET ACK INDICATOR IN LUSVC WORK BYTE.
H.DPEE	THI	R1,NSDTAK		:ACK REQUESTED BY NIO?
	JEFS	H.DPEF			:JUMP IF NOT
	LB	R5,LUCTAB+LULUWK,R4,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUFA		:RESET ACK TIMEOUT BIT
	OHI	R5,LULUAK		:SET ACK PENDING
	STB	R5,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE

:CREATE DQE AND FILL IT IN.
H.DPEF	LR	R9,R4			:COPY PTR TO LUCB
H.DPEH	LR	R1,R7			:SAVE SCB POINTER
	JAL	R4,GBB,,		:GET BUFFERLET FOR DQE
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	ST	R1,BBUFER+DQSCB,R3,	:FILL IN DQE SCB POINTER
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:FILL IN MUCB POINTER
	STH	R9,BBUFER+DQLUCB,R3,	:FILL IN LUCB POINTER
	LHI	R2,DFCSND		:SHOW DFC.SEND AS DEST
	LHI	R1,LUSEND		:ORIGINATION LU.SEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL

:IN MULTI-SEGMENT MESSAGE THE FIRST SEGMENT WILL BE REMOVED FROM
:NIO->SNA QUEUE ONLY AFTER POSITIVE NOTIFIACTION FROM LOWER
:SNA LAYERS. THE REST OF THE SEGMENTS ARE REMOVED IMMEDIATELY EXCEPT
:FOR THE CASE WHEN CANCEL IS PENDING.
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUCB WORK BYTE
	THI	R5,LULUCN		:CANCEL PENDING?
	JN	H.DPEG			:JUMP IF SO
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	NHI	R5,MU.BIU		:1ST SEGMENT?
	JN	H.DPEG			:JUMP IF SO
	LR	R6,R8			:COPY POINTER TO CMD LINK
	LHL	R5,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK
	JE	L.CLER			:JUMP IF EMPTY PTR
	STH	R5,LUCTAB+LUSNDG,R9,	:ADVANCE GET POINTER
	JAL	R4,RELCL,,		:RELEASE THE LINK
	LHL	R4,LUCTAB+LUSNDR,R9,	:GET RELEASE POINTER
	CR	R4,R5			:COMPARE GET AND RELEASE
	JNFS	H.DPEG			:JUMP IF NOT LAST
	LHL	R4,LUCTAB+LUCT.N,R9,	:GET REL LU #
	RBT	R4,DPNWSN,,		:REST DATA PRESENT

:SEND MU TO LOWER LAYER AND RETURN.
H.DPEG	JAL	R8,SEND,,		:SEND DQE TO LOWER LAYER
	JR	R14			:AND RETURN

:CLEAN-BIT WAS ON. IT MEANS THAT NEGATIVE RSP
:WAS RECEIVED FROM THE HOST. BEFORE WE CAN SEND ANYTHING ELSE
:WE HAVE TO PURGE ALL DATA MESSAGES (IF ANY)
:WHICH BELONG TO THE OLD CHAIN.
H.DPCL	LB	R5,LUCTAB+LULUWK,R4,	:GET LUSVC WORK BYTE
	THI	R5,LULUNG		:-RSP PENDING?
	JNR	R14			:RETURN IF SO
	THI	R1,NSDTLS		:1ST SEGMENT?
	JN	H.DPCE			:JUMP IF NOT
	THI	R1,NSDTLC		:1ST CHAIN ELEMENT?
	JN	H.DPCE			:JUMP IF NOT
	LB	R5,LUCTAB+LULUST,R4,	:GET LUSVC STATE BYTE
	NHI	R5,@LUSBST		:CLEAR SUBSTATE INFORMATION
	STB	R5,LUCTAB+LULUST,R4,	:UPDATE LUSVC STATE BYTE
	LB	R5,LUCTAB+LULUWK,R4,	:GET LUSVC WORK BYTE
	NHI	R5,LULUFA!LULUAK	:CLEAR ALL BUT ACK INFO
	STB	R5,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUW1,R4,	:CLEAR LUSVC 2ND WORK BYTE
	J	H.DPE0			:JUMP TO CONTINUE

:RELEASE CMD LINK AND ASSOCIATED BUFFERS WITH MESSAGE.
H.DPCE	LR	R9,R4			:COPY LUCB POINTER
H.DPCX	BBLOAD	R3,CMDBLK+CLARG,R8,	:GET PTR TO BUFFER CHAIN
	JAL	R5,R.PBBC,,		:RELEASE BUF CHAIN WITH MSG
	J	H.RMD0			:JUMP TO REMOVE CMD LINK

:SYS/REQ KEY WAS RECEIVED FROM TIF.
:IF ANY CHAIN OR SEGMENT ARE NOT FINISHED SEND CANCEL TO TIF.
:CHANGE THE SCREEN STATE, SEND BACK WRITE STATUS COMMAND
:AND ENTER CLEAN-UP STATE.
H.DPRQ	LR	R9,R4			:COPY LUCB POINTER
	THI	R5,LUSCOP!LUSSOP	:ANY CHAIN OR SEGMENT OPEN?
	JE	H.DPR0			:JUMP IF NOT
	STM	R0,LURGSV,,		:SAVE ALL REGISTER
	LR	R8,R5			:COPY SCREEN SCTATE
	JAL	R4,GBB,,		:GET BUFFER FOR DUMMY CANCEL
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBR,,		:COUNT IT
	LHI	R0,SNETEM^8!SNDTCD!SNDTCN	:PREPARE TO SEND CANCEL TO NIO
	THI	R8,LUSCOP		:CHAIN OPEN?
	JEFS	H.DPRA			:JUMP IF NOT
	OHI	R0,SNDTLC		:LAST, NOT THE FIRST IN CHAIN
H.DPRA	THI	R8,LUSSOP		:SEGMENT OPEN?
	JEFS	H.DPRB			:JUMP IF NOT
	OHI	R0,SNDTLS		:LAST, NOT THE FIRST SEGMENT
H.DPRB	LIS	R2,FID2LG+3		:LENGTH OF DUMMY MESSAGE
	JAL	R5,L.PTCD		:PASS IT TO NIO
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
H.DPR0	NHI	R5,LUSSCN		:LEAVE SCREEN STATE ONLY
	CHI	R5,LUSAPL		:APPLICATION?
	JNFS	H.DPR1			:JUMP IF NOT
	LIS	R5,LUSSYS		:ENTER SYSTEM STATE
	JFS	H.DPR4			:JUMP TO CONTINUE
:H.DPR1	LHL	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER (03/10/86 YLH)
H.DPR1	BBLSCB	R3,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER (03/10/86 YLH)
	JEFS	H.DPR2			:JUMP IF INVALID
	LIS	R5,LUSAPL		:IT HAD TO BE SYS, SO NOW IT IS APL
	JFS	H.DPR4			:JUMP TO CONTINUE
:NO LU-LU SESSION.
H.DPR2	CHI	R5,LUSSYS		:CURRENT STATE SYSTEM?
	JEFS	H.DPR3			:JUMP IF SO
	LIS	R5,LUSSYS		:ENTER SYSTEM STATE
	JFS	H.DPR4			:JUMP TO CONTINUE
H.DPR3	LIS	R5,LUSUNW		:ENTER UNOWNED STATE
:H.DPR4	LB	R4,BBUFER+THDISP+FID2LG,R7,	:GET SYS/REQ SEQ# (03/10/86 YLH)
H.DPR4	LB	R4,BBUFER+THDISP+FID2LG+4,R7,	:GET SYS/REQ SEQ# (03/10/86 YLH)
	JAL	R6,H.SNST		:SEND STATUS MESSAGE TO TIF
	LR	R0,R5			:SAVE R5
	OHI	R5,LUSCRN!LUCLLU!LUCLCP	:INDICATE CLEANING
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATE
	CHI	R0,LUSAPL		:STATE=APPL?
	JN	H.DPCX			:NO, JUMP TO REMOVE CMD LINK
:	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:YES, GET THE FINITE STATE
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R3,	:YES, GET THE FINITE STATE (03/10/86 YLH)
	CHI	R5,FS.ST4		:FINITE STATE=4?
	JN	H.DPCX			:NO, JUMP TO REMOVE CMD LINK
:	LR	R9,R4			:YES, SAVE SEQ# (03/13/86 YLH)
	LR	R1,R3			:SAVE SCB POINTER (03/14/86 YLH)
	BBLOAD	R3,CMDBLK+CLARG,R8,	:GET PTR TO THE BUFFER CHAIN
	JAL	R5,R.PBBC,,		:RELEASE BUFFER CHAIN WITH THE MSG.
	LA	R8,LUONCN,,		:SEND THE CANNED LUSTAT TO INFO THE
	LHI	R0,LUONLG+3		:HOST THAT THE STATE IS SWITCHED
	JAL	R5,L.DFLL		:BACK TO THE APPL
:
:BEGIN (03/14/86 YLH)
:
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	OHI	R5,MU.CDI		:SET CHANGE DIRECTION
	STB	R5,BBUFER+MURHF3,R10,	:RESTORE 3RD BYTE OF RH
	JAL	R4,GBB,,		:GET A BUFFERLET FOR DQE
	GL	NOBUFF
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	ST	R1,BBUFER+DQSCB,R3,	:FILL IN DQE SCB POINTER
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:FILL IN MUCB POINTER
	STH	R9,BBUFER+DQLUCB,R3,	:FILL IN LUCB POINTER
:
:END (03/14/86 YLH)
:
	LHI	R2,DFCSND		:DESTINATION PROCEDURE NUMBER
	LHI	R1,LUSEND		:SENDING PROCEDURE NUMBER
	LIS	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,
	JR	R14

::ATTENTION KEY WAS RECEIVED BY HIF. SEND SIGNAL IF POSSIBLE.
::ERROR IF THE SCREEN STATE IS NOT SYSTEM. WAIT IF IMM_EXP STATE IS NOT RESET.
H.DPAT	LR	R9,R4			:COPY LUCB POINTER
	NHI	R5,LUSSCN		:LEAVE SCREEN STATE ONLY
	CHI	R5,LUSSYS		:SYSTEM?
	JN	H.DPA1			:JUMP IF NOT
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET POINTER TO LU-LU SCB
	JE	H.DPA1			:SOMETHING WRONG IF NOT THERE
	LB	R5,SCBBLK+SCSTAT+FSCCIE,R7,	:CHECK IMMED-EXP FSM
	CHI	R5,FS.ST1		:RESET STATE?
	JNR	R14			:NO, WE WILL SIMPLY WAIT UNTIL
					:IT IS O.K TO SEND THE MSG
:
	LR	R9,R4			:COPY LUCB POINTER
	LR	R1,R7			:COPY SCB POINTER (03/14/86 YLH)
	BBLOAD	R3,CMDBLK+CLARG,R8,	:RELEASE BUFFER CHAIN WITH THE MSG
	JAL	R5,R.PBBC,,
	LA	R8,SIGCAN,,		:POINT TO CANNED SIGNAL (CHGR DIR)
	LHI	R0,SIGLGT+3		:LENGTH OF MSG (+RH)
	JAL	R5,L.DFLL		:GENERATE SIGNAL MSG
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:CLEAR TIMEOUT BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	OHI	R5,MU.EFI		:SHOW EXPEDITED FLOW
	STB	R5,BBUFER+MUBIUF,R10,	:UPDATE 1ST BYTE OF TH
:
:BEGIN (03/14/86 YLH)
:
	JAL	R5,GBB,,		:GET A BUFFERLET FOR DQE
	J	NOBUFF			:JUMP IF NONE AVAILABLE
	JAL	R5,R.GBB,,		:COUNT THE BUFFERLET
	ST	R1,BBUFER+DQSCB,R3,	:FILL IN DQE SCB POINTER
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:FILL IN MUCB POINTER
	STH	R9,BBUFER+DQLUCB,R3,	:FILL IN LUCB POINTER
:
:END (03/14/86 YLH)
:
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LUSEND		:ORIGINATION LU.SEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:RETURN

:ATTENTION KEY IS NOT VALID. SEND ERROR INDICATION TO TIF.
H.DPA1	LHI	R4,HSTINI		:HOST INITIATED MESSAGE
	LIS	R5,LUSERR		:ERROR INDICATION
	JAL	R6,H.SNST		:SEND IT TO TIF
	J	H.DPCX			:JUMP TO REMOVE CMD LINK

::::::::::::::::::::::::::::::::::::
:: INTERNALLY GENERATED MESSAGE FROM NIO.
:: THIS CMD IS VALID ONLY FOR LU TYPE 3 (PRINTER SUPPORT)
:: IT IS USED TO DELAY RSP OR LUSTAT UNTIL THE MOMENT WHEN NIO
:: PROCESSES ALL DATA MESSAGES IN SNA->NIO DATA QUEUE.
:: THIS DELAY IS ESSENTIAL FOR FLOW CONTROL OF PRINTED DATA.
:: IF THE PRINTER IS TEMPORARILY OUT OF SERVICE (SAY, PAPER)
:: THE BACKPRESSURE FROM THE NETWORK WILL CAUSE NIO TO HALT FURTHER
:: PROCESSING OF SNA->NIO DATA QUEUE. RECEIVE PROCESS WILL EITHER
:: DISCARD RECEIVED RU CHAIN (FCNGRP SWITCH ON) OR DELAY +RSP (THE SWITCH IS
:: OFF) IF SNA->NIO QUEUE IS NOT EMPTIED. IT WILL ALSO PUT INTERNALLY
:: GENERATED CMD IN THE HEAD OF NIO->SNA DATA QUEUE.
:: THIS ROUTINE IS REPONSIBLE FOR GENERATING LUSTAT(NOW AVAILABLE)
:: WHEN THE SNA->NIO QUEUE IS EMPTY (FCNGRP IS ON) OR
:: GENERATING +RSP AND LUSTAT(CHANGE DIRECTION) WHEN THE SAME QUEUE IS
:: EMPTY (FCNGRP IS OFF).
::::::::::::::::::::::::::::::::::::
H.DPLG	LR	R9,R4			:COPY LUCB POINTER
	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
					:(F00/02/23/87/DB/START)
	CHI	R5,LU.T1		:TYPE 1?
	JEFS	H.DPL5			:YES
					:(F00/02/23/87/DB/END)
	CHI	R5,LU.T3		:TYPE 3?
	JN	H.DPLH			:INVALID CMD IF NOT
H.DPL5					:(F00/02/23/87/DB)
	LHL	R5,LUCTAB+LUCT.N,R9,	:GET REL# OF LU
	TBT	R5,DPSNNW,,		:DATA PRESENT IN SNA->NIO QUEUE?
	JNR	R14			:RETURN IF SO
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET SCB POINTER
	JE	H.RMD0			:REMOVE CMD LINK IF NO LU-LU SCB

:IF FLOW CONTROL IS DELAYING RSP'S GENERATE THEM NOW FROM CORRELATION
:TABLE.
	IF	1-FCNGRP		:FLOW CNTR WITHOUT -RSP
	LHL	R4,SCBBLK+SCTRNG,R7,	:GET GET POINTER TO CT
H.DPL1	LHL	R5,SCBBLK+SCTRNR,R7,	:GET RELEASE PTR TO CT
	CR	R4,R5			:CT EMPTY?
	JE	H.DPL4			:JUMP TO CONTINUE
	BBLOAD	R8,CMDBLK+CLARG,R4,	:GET POINTER TO BUFFER WITH CT
	LB	R5,BBUFER+CLARG5+1,R8,	:GET RH BYTE 2
	THI	R5,MU.ERI		:EXCEPTION RSP?
	JEFS	H.DPL2			:JUMP IF SO
	LHL	R4,CMDBLK+CLPTR,R4,	:GET PTR TO NEXT CT ELEMENT
	J	H.DPL1			:JUMP TO CONTINUE
H.DPL2	JAL	R4,GBB,,		:GET BUFFERLET FOR MUCB
	J	NOBUFF			:JUMP OF NONE AVAILBLE
	JAL	R4,R.GBB,,		:COUNT IT
	LR	R10,R3			:COPY MUCB POINTER
	LB	R5,BBUFER+CLARG6,R8,	:GET BYTE WITH RU CATEGORY
	NHI	R5,MU.CTG		:LEAVE RU CATEGORY ONLY
	JEFS	H.DPL3			:JUMP IF FMD
	OHI	R5,MU.FI		:OTHERWISE SHOW FORMATTED RQ
H.DPL3	STB	R5,BBUFER+MURHF1,R10,	:STORE IT IN MUCB
	LB	R5,BBUFER+CLARG5+1,R8,	:GET BYTE CONTAINING RH BYTE 2
	STB	R5,BBUFER+MURHF2,R10,	:STORE IT IN MUCB
	LB	R1,BBUFER+CLARG4,R8,	:GET RQ CODE
	LHL	R5,BBUFER+CLARG3,R8,	:GET END SEQ #
	STH	R5,BBUFER+MUSNF,R10,	:PUT IT IN MUCB
	LHI	R5,FID2^4		:PREPARE 1ST BYTE OF TH
	STB	R5,BBUFER+MUBIUF,R10,	:PUT IT IN MUCB
	LB	R5,LUCTAB+LUCADR,R9,	:GET ADDR OF SEC LU
	LB	R4,LUCTAB+LUPRIL,R9,	:GET ADDR OF SEC LU
	STB	R5,BBUFER+MUDADP,R10,	:PUT SEC ADDR IN MUCB
	STB	R4,BBUFER+MUOADP,R10,	:PUT PRI ADDR IN MUCB
	XR	R0,R0			:+RSP (NO SENSE CODE)
	JAL	R5,L.GNRP		:GENERATE +RSP
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	OHI	R5,LULUCN		:PREVENT REMOVING OF CMD LINK
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R2,DFCSND		:SHOW DFC.SEND AS DESTINATION
	LHI	R1,LURCV		:FROM LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN
	EI

:NOW SEND LUSTAT IF HALF DUPLEX FLIP-FLOP STATE MACHINE IS IN A SEND
:STATE. OTHERWISE SIMPLY REMOVE THE CMD LINK.
H.DPL4	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,LULUCN		:ALLOW REMOVAL AFTER NOTIFICATION
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET FSM_HFF
	CHI	R5,FS.ST3		:STATE 3?
	JE	H.RMD0			:REMOVE THE LINK IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JE	H.RMD0			:REMOVE THE LINK IF SO
	CHI	R5,FS.ST6		:STATE 6?
	JE	H.RMD0			:REMOVE THE LINK IF SO
	CHI	R5,FS.ST8		:STATE 8?
	JE	H.RMD0			:REMOVE THE LINK OF SO
	IF	FCNGRP			:FOR NEGATIVE FLOW CONTROL
	LA	R8,LUAVCN,,		:POINT TO LUSTAT(AVAILABLE)
	LHI	R0,LUAVLG+3		:LENGTH OF LUSTAT (+RH)
	ELSE				:FOR FLOW CNTL WITHOUT -RSP
	LB	R5,SCBBLK+SCSTAT+FSCBFP,R7,	:GET FSM FIRST SPEAKER
	CHI	R5,FS.ST1		:BETWEEN BRACKETS?
	JE	H.RMD0			:REMOVE THE LINK IF SO
	CHI	R5,FS.ST2		:IN BRACKETS?
	JNR	R14			:WAIT IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMM-REQ FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:WAIT IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:WAIT IF SO
	LB	R5,SCBBLK+SCSTAT+FSCIRR,R7,	:GET IMM-RCV FSM
	CHI	R5,FS.ST1		:STATE 1?
	JNR	R14			:WAIT IF NOT
	LA	R8,LUCDCN,,		:POINT TO LUSTAT(NOTHING TO SEND)
	LHI	R0,LUCDLG+3		:LENGTH OF LUSTAT (+RH)
	EI
	JAL	R5,L.DFLL		:GENERATE LUSTAT
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	OHI	R5,MU.CDI		:INDICATE CHANGE DIRECTION
	STB	R5,BBUFER+MURHF3,R10,	:UPDATE 3RD BYTE OF RH
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LUSEND		:FROM LU.SEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND LUSTAT
	JR	R14			:AND RETURN

:::::::::::::::::::::::::::::::::
:: REMOVE PROCESSING ROUTINE IN DSP MODE.
:: IF SEND OPERATION WAS SUCCESSFUL THE CMD LINK IS REMOVED
:: FROM NIO->SNA DATA QUEUE IF CANCEL IS NOT PENDING.
:: IN THIS SPECAIL CASE THE LINK IS NOT REMOVED TO INDICATE
:: TO THE HIGH LEVEL SCHEDULER THAT LU.SEND MUST BE CALLED.
:
:: FIRST CHECK THAT SEND OPERATION WAS SUCCESSFUL.
H.RMDP	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE-CHECK BYTE
	JN	L.RMTF			:JUMP IF NOT OK

:	(9/18/84/CHS)	DISCARD MUCB FIRST
	LR	R3,R10			:SET UP R3
	JAL	R4,PBB,,		:REALSE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
:	(9/18/84/CHS) END OF DISCARD MUCB INSERTION

:IF CANCEL IS PENDING DO NOT REMOVE CMD LINK.
	LB	R6,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R6,LULUCN		:IS CANCEL PENDING?
	JNR	R14			:RETURN IF SO

:IF SIGNAL WAS SENT (NO DATA MSG YET) DO NOT REMOVE CMD LINK.
	LB	R6,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	THI	R6,LUDPSG		:SIGNAL PENDING?
	JNR	R14			:RETURN IF SO


:REMOVE CMD FROM NTW->SNA DATA QUEUE.
H.RMD0	LHL	R6,LUCTAB+LUSNDG,R9,	:GET NTW->SNA GET PTR
	LHL	R5,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK
	JE	L.CLER			:ERROR IF NO NEXT LINK
	STH	R5,LUCTAB+LUSNDG,R9,	:UPDATE NTW->SNA GET PTR
	JAL	R4,RELCL,,		:RELEASE THE LINK
	LHL	R4,LUCTAB+LUSNDR,R9,	:GET REL PTR
	CR	R5,R4			:COMPARE GET AND REL PTR
	JNR	R14			:RETURN IF NOT THE LAST
	LHL	R4,LUCTAB+LUCT.N,R9,	:GET REL LU #
	RBT	R4,DPNWSN,,		:RESET DATA PRESENT
	JR	R14			:AND RETURN

	FO	SHDPKG

	EI				:END OF REMOVE ROUTINES FOR DSP HOST

	FO	MAIN	
	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER

	EM
  	MO	.,SNAPKG

	LO	SNTPKG
	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	MAIN

::::::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS A CODE FRO SEND SIDE OF
:: LU SERVICE MANAGER.
::::::::::::::::::::::::::::::::::::::::::

	SEG	A.CODE
::::::::::::::::::::::::::::::::::
:ENTRY POINT FOR LU SEND PROCESS

S.LSSD
L.SEND	LHL	R12,EVPTR,RNODE,RNODE	:GET PTR TO EV VECTOR
	LB	R4,EVBLK+EVSPRO,R12,	:GET SENDING PROCESS NUMBER
	JE	L.NGT			:IF SCHEDULER LOOK AT DATA Q
	LB	R5,EVBLK+EVISIG,R12,	:CHECK IF SIGNAL
	JNR	R14			:RETURN IF SO (PROBABLY BTB)
	CHI	R4,DFCSND		:IS IT DFC SEND?
L.SND1	JE	L.RMOV			:GO TO REMOVE PROCESS IF SO
	CHI	R4,TCSCSD		:IS IT TC.SC.SEND?
	JEBS	L.SND1			:JUMP IF SO
	CHI	R4,PMCSMS		:IS IT PU.CSC.SEND?
	JEBS	L.SND1			:JUMP IF SO
	JAL	R10,CRASH,,		:OTHERWISE IT IS ILLEGAL
	HC	0
	BC	4*R4,CR.LSN		:CRASH

:LOOK AT NTW -> SNA DATA QUEUE

L.NGT	LHL	R4,EVBLK+EVLUCB,R12,	:GET POITER TO LUCB
	LB	R3,LUCTAB+LULUST,R4,	:GET LU_SVC STATUS
	RRL	R3,5			:PUT STATE IN LOW 3 BITS
	JLR	R14			:RETURN IF WAIT IS ON
	CI	R3,LUBDST^1B		:ARE WE UNABLE TO CONTINUE?
	JGER	R14			:RETURN IF SO
	LBR	R3,R3			:CLEAR EVERYTHING BUT STATE
	LHL	R8,LUCTAB+LUSNDG,R4,	:GET NTW->SNA GET POITER
	CH	R8,LUCTAB+LUSNDR,R4,	:COMPARE WITH RELEASE POINTER
	JER	R14			:RETURN IF EMPTY
	LH	R7,CMDBLK+CLCMD,R8,	:GET COMMAND CODE
	LBR	R1,R7			:SAVE SUBCOMMAND
	SRA	R7,8			:PUT COMMAND IN 1ST BYTE
	JLFS	L.NGT1			:JUMP IF COMMAND
	SIS	R7,1			:ADJUST DATA TYPE
L.NGT1	SHI	R7,0FF00!NSCMMX		:MAKE IT RELATIVE TO 0
:
:BEGIN (04/09/87 YLH)
:
	LIS	R6,LUMSTA		:INIT MAX NUMBER OF LU STATES
	LB	R9,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R9,PU.T4		:TERMINAL INTERFACE?
	JEFS	L.NGT3			:JUMP IF SO
:
:	FOR SNAHIF, IF DSP IS SUPPORTED THEN MAX NUMBER OF LU STATES
:	EQUAL TO LUMHST
:
	IF	HDPSUP
	LIS	R6,LUMHST		:GET MAX NUMBER OF LU STATES
	EI
	JFS	L.NGT4			:JUMP TO CONTINUE
:
:	FOR SNATIF, IF VTI IS SUPPORTED THEN MAX NUMBER OF LU STATES
:	EQUAL TO LUMTST
:
L.NGT3
	IF	VTISUP
	LIS	R6,LUMTST		:GET MUX NUMBER OF LU STATES
	EI
:
:END (04/09/87 YLH)
:
L.NGT4	MR	R5,R7			:BEGINNING OF ST TBL FOR CMD
	AR	R6,R3			:ENTRY NUMBER IN STATE TB
	IF	TERMIF&HOSTIF		:IF BOTH TERM AND HOST SYSGENED
	CHI	R9,PU.T4		:IS IT PU TYPE 4?
	JNFS	L.NGT2			:JUMP TO GET HOST IF JUMP TABL
	EI
	IF	TERMIF			:FOR TERMINAL INTERFACE
	LHL	R5,L.DTBL,R6,R6		:GET POINTER TO PROC ROUTINE
	J	L.BASE,R5		:AND JUMP THERE
	EI
	IF	HOSTIF			:FOR HOST INTERFACE
L.NGT2	LHL	R5,H.DTBL,R6,R6		:GET POINTER TO PROC ROUTINE
	J	L.BASE,R5		:AND JUMP THERE
	EI

:------------------
:PROCESSING ROUTINES FOR NTW->SNA COMMANDS

:REGISTER CONTENTS ON INPUT IN THESE ROUTINES
:	R12 - PTR TO EV
:	R4  - PTR TO LUCB
:	R8  - PTR TO CMD LINK WITH COMMAND BEING PROCESSED
:	R3  - LU STATE (IN 3 LOW BITS)
:	R1  - SUBCOMMAND FIELD OF CMD

	IF	TERMIF			:JUMP TABLE FOR TERM IF
L.DTBL	HC	L.TRFN-L.BASE		:FINISH COMMAND & TRANSP MODE
	HC	L.LCFN-L.BASE		:FINISH COMMAND & LOCAL MODE
	HC	L.PTFN-L.BASE		:FINISH COMMAND & PEND TR MODE
	HC	L.PLFN-L.BASE		:FINISH COMMAND & PEND LC MODE
	IF	VTISUP			: (01/12/87 YLH)
	HC	L.DPFN-L.BASE		:FINISH COMMAND & DSP MODE (01/12/87 YLH)
	EI				: (01/12/87 YLH)

	HC	L.TRST-L.BASE		:START COMMAND & TRANSP MODE
	HC	L.LCST-L.BASE		:START COMMAND & LOCAL MODE
	HC	L.PTST-L.BASE		:START COMMAND & PEND TR MODE
	HC	L.PLST-L.BASE		:START COMMAND & PEND LC MODE
	IF	VTISUP			: (01/12/87 YLH)
	HC	L.DPST-L.BASE		:START COMMAND & DSP MODE (01/12/87 YLH)
	EI				: (01/12/87 YLH)

	HC	L.TRET-L.BASE		:END-TO-END & TRANSP MODE
	HC	L.LCET-L.BASE		:END-TO-END & LOCAL MODE
	HC	L.PTET-L.BASE		:END-TO-END & PEND TRANSP MODE
	HC	L.PLET-L.BASE		:END-TO-END & PEND LOCAL MODE
	IF	VTISUP			: (01/12/87 YLH)
	HC	L.DPET-L.BASE		:END-TO-END & DSP MODE (01/12/87 YLH)
	EI				: (01/12/87 YLH)

	HC	L.TRLG-L.BASE		:LOCAL MSG & TRANSP MODE
	HC	L.LCLG-L.BASE		:LOCAL MSG & LOCAL MODE
	HC	L.PTLG-L.BASE		:LOCAL MSG & PEND TRANSP MODE
	HC	L.PLLG-L.BASE		:LOCAL MSG & PEND LOCAL MODE
	IF	VTISUP			: (01/12/87 YLH)
	HC	L.DPLG-L.BASE		:LOCAL MSG & DSP MODE (01/12/87 YLH)
	EI				: (01/12/87 YLH)
	EI				:END OF JUMP TBL FOR TERM IF

:------------------

	IF	HOSTIF			:JUMP TABLES FOR HOST IF
H.DTBL	HC	H.TRFN-L.BASE		:FINISH COMMAND & TRANSP MODE
	HC	H.LCFN-L.BASE		:FINISH COMMAND & LOCAL MODE
	HC	H.PTFN-L.BASE		:FINISH COMMAND & PEND TR MODE
	HC	H.PLFN-L.BASE		:FINISH COMMAND & PEND LC MODE
	IF	HDPSUP
	HC	H.DPFN-L.BASE		:FINISH COMMAND & DSP MODE
	EI

	HC	H.TRST-L.BASE		:START COMMAND & TRANSP MODE
	HC	H.LCST-L.BASE		:START COMMAND & LOCAL MODE
	HC	H.PTST-L.BASE		:START COMMAND & PEND TR MODE
	HC	H.PLST-L.BASE		:START COMMAND & PEND LC MODE
	IF	HDPSUP
	HC	H.DPST-L.BASE		:START COMMAND & DSP MODE
	EI

	HC	H.TRET-L.BASE		:END-TO-END & TRANSP MODE
	HC	H.LCET-L.BASE		:END-TO-END & LOCAL MODE
	HC	H.PTET-L.BASE		:END-TO-END & PEND TRANSP MODE
	HC	H.PLET-L.BASE		:END-TO-END & PEND LOCAL MODE
	IF	HDPSUP
	HC	H.DPET-L.BASE		:END-TO-END & DSP MODE
	EI

	HC	H.TRLG-L.BASE		:LOCAL MSG & TRANSP MODE
	HC	H.LCLG-L.BASE		:LOCAL MSG & LOCAL MODE
	HC	H.PTLG-L.BASE		:LOCAL MSG & PEND TRANSP MODE
	HC	H.PLLG-L.BASE		:LOCAL MSG & PEND LOCAL MODE
	IF	HDPSUP
	HC	H.DPLG-L.BASE		:LOCAL MSG & DSP MODE
	EI
	EI				:END OF JUMP TBL FOR HOST IF

:------------------

::::::::::::::::::::::::::
:: SEND PROCESSING ROUTINES FOR LU SERVICE MANAGER
::::::::::::::::::::::::::
:
:: IN SOME CASES THE CMD LINK MAY CONTAIN SOMETHING NOT COMPATIBLE WITH
:  LUSVC STATE. SEND ERROR CMD TO NIO AND PUT US IN BAD STATE.

	IF	TERMIF			:LABELS FOR TERMINAL IF
L.PLFN
L.LCST
L.PLET
L.PTET
L.PTST
L.TRLG
L.PTLG
L.PLLG	EQ	.			:COMMON ENTRY POINT FOR ROUTINES
	IF	VTISUP			: (01/12/87 YLH)
L.DPFN					: (01/12/87 YLH)
L.DPLG					: (01/12/87 YLH)
	EI				: (01/12/87 YLH)
	EI				:END OF LABELS FOR TERM IF

	IF	HOSTIF			:PROCESSING ROUTINES FOR HST
H.VRER
H.DPFN
H.DPLH
H.TRFN
H.TRST
H.LCST
H.PTST
H.LCLG
H.TRLG
H.PTLG
H.PLLG	EQ	.			:COMMON ENTRY POINT FOR ROUTINES
	EI				:END OF HOST IF LABELS

	LB	R5,LUCTAB+LULUST,R4,	:GET LUSVC STATE BYTE
	OHI	R5,LUBDST		:PREPARE BAD SUBSTATE
	STB	R5,LUCTAB+LULUST,R4,	:UPDATE LUSVC STATE BYTE
	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
	LR	R9,R4			:COPY LUCB POINTER
	LHI	R0,SNERR^8!SNERNT	:PREPARE INCPATIBLE CMD ERR
	JAL	R5,L.PTCD,,		:PASS IT TO NIO
	JR	R14			:AND CONTINUE

:: IF CIRCUIT WAS RETAINED DURING APPLICATION TIMEOUT IT IS POSSIBLE
:: TO HAVE END-TO-END MESSAGE IN LOCAL OR PENDING MODES.
:: WAIT UNTIL WE CHANGE THE MODE BEFORE THEY ARE TRANSMITTED TO THE HOST

H.LCET
H.PLET
H.PTET
:FOR VHR FUNCTION DISCARD END-TO-END MESSAGE (09/08/86 MIA)
	IF	VHRSUP
	LR	R9,R4			:COPY LUCB POINTER
	LB	R5,LUCTAB+LUCVHR,R4,	:GET VHR STATE BYTE
	THI	R5,LUVHRF		:VHR FUNCTION?
	JER	R14			:RETURN IF NOT
	BBLOAD	R3,CMDBLK+CLARG,R8,	:GET POINTER TO BUFFER CHAIN
	JE	L.RMT0			:JUMP IF NO DATA
	JAL	R5,R.PBBC,,		:RELEASE BUFFERLETS
	J	L.RMT0			:JUMP TO REMOVE THE LINK
	ELSE
:END OF INSERTION (09/08/86 MIA)
	JR	R14			:RETURN
	EI

:::::::::::::::::::::::::::::::::::::::::::
:: FINISH COMMAND RECEIVED FROM NIO.
:::::::::::::::::::::::::::::::::::::::::::
:
:: TERMINAL INTERFACE PROCESSING ROUTINES.
::
	IF	TERMIF			:TERMIF ROUTINES FOR FINISH
:
:: L.TRFN - FINISH COMMAND IN TRANSPARENT MODE.
:  RESET THE SUBSTATE AND CONTINUE.
L.TRFN	LHI	R5,TRPSTA		:PREPARE TO RESET LUSVC STATE BYTE
	STB	R5,LUCTAB+LULUST,R4,	:UPDATE IT
	J	L.RMT0			:JUMP TO REMOVE CMD LINK

:
:: L.LCFN - FINISH LOGON RECEIVED IN LOCAL MODE.
:
:: PUT LUSVC IN PENDING TRANSPARENT MODE AND RETURN.
L.LCFN	BBLSCB	R7,LUCTAB+LUSSCB,R4,	:GET SSCP-LU POINTER (03/19/86 YLH)
	LH	R5,SCBBLK+SCTRNG,R7,	:CHECK IF ANY ELEMENT ON THE (03/19/86 YLH)
	CH	R5,SCBBLK+SCTRNR,R7,	:CT_RCV_RQ_NORM QUEUE? (03/19/86 YLH)
	JNR	R14			:YES, RETURN (03/19/86 YLH)
:
	LHI	R5,PTRSTA		:NO, PREPARE PENDING TRANSP STATE
	STB	R5,LUCTAB+LULUST,R4,	:UPDATE LUSVC STATE
	LB	R5,LUCTAB+LULUWK,R4,	:GET LUSVC WORK BYTE
	NHI	R5,LULUBD		:CLEAR EVERYTHING BUT BND IND
	STB	R5,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
	JR	R14			:AND RETURN

:: L.PTFN - FINISH COMMAND IN PENDING TRANSPARENT MODE.
:
:: THE CURRENT CODE DOES NOT INCLUDE PRINTER SUPPORT. THIS
:: MEANS THAT NO END-TO-END SESSION EXISTED WHEN LOGON WAS STARTED.
:: CONSEQUENTLY WE DO NOT HAVE TO CARE ABOUT BINDING BACK THE
:: END-TO-END SESSION AND RECONCILING DIFFERENCES BETWEEN
:: PRIMARY SECONDARY. THE ONLY ACTION IS TO ISSUE UNBIND.
:
:FIRST VECTOR THE EXECUTION DEPENDING ON LUSVC SUBSTATE.
L.PTFN	LR	R9,R4			:COPY LUCB POINTER
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE
	NHI	R5,LUSBST		:GET LUSVC SUBSTATE
	LHL	R5,L.PTTB,R5,R5		:GET PTR TO PROC ROUTINE
	J	L.BASE,R5		:JUMP TO PROC ROUTINE

L.PTTB	HC	L.PTUB-L.BASE		:SEND UNBIND ROUTINE

:: SEND UNBIND ROUTINE.
L.PTUB	LA	R8,UBDCAN,,		:POINT TO UNBIND CANNED RU
	LHI	R0,UBDLGT+3		:UNBIND BIU LENGTH
	JAL	R5,L.SCRQ		:GENERATE UNBIND
	LHI	R2,PMCSMS		:DESTINATION PU.CSC.SEND
	LHI	R1,LUSEND		:ORIGINATION LUSEND
	LHI	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN
	EI				:END OF TERM IF ROUTINES FOR FINISH

:::::::::::::::::::::::::::::::::::::::::::
:: FINISH ROUTINES FOR HOST INTERFACE.
:::::::::::::::::::::::::::::::::::::::::::

	IF	HOSTIF			:ROUTINES FOR HOST IF
:
:: H.PLFN - FINISH LOGON RECEIVED IN PENDING LOCAL MODE.
:: IGNORE IT IF VHR FUNCTION. OTHERWISE AN ERROR.
H.LCST
H.PLFN	IF	VHRSUP
	LR	R9,R4			:COPY LUCB POINTER
	LB	R5,LUCTAB+LUCVHR,R4,	:GET VHR STATE BYTE
	THI	R5,LUVHRF		:VHR FUNCTION?
	JN	L.RMT0			:REMOVE LINK IF SO
	EI
	J	H.VRER			:OTHERWISE ERROR

:
:: H.LCFN - FINISH LOGON RECEIVED IN LOCAL MODE.
:
:: PUT LUSVC IN PENDING TRANSPARENT MODE AND RETURN.
H.LCFN	IF	VHRSUP
	LR	R9,R4			:COPY LUCB POINTER
	LB	R5,LUCTAB+LUCVHR,R4,	:GET VHR STATE BYTE
	THI	R4,LUVHRF		:VHR FUNCTION?
	JN	L.RMT0			:REMOVE THE CMD LINK IF SO
	EI
	BBLSCB	R7,LUCTAB+LUSSCB,R4,	:GET SSCP-LU POINTER (03/19/86 YLH)
	LH	R5,SCBBLK+SCTRNG,R7,	:CHECK IF ANY ELEMENT ON THE (03/19/86 YLH)
	CH	R5,SCBBLK+SCTRNR,R7,	:CT_RCV_RQ_NORM QUEUE? (03/19/86 YLH)
	JNR	R14			:YES, RETURN (03/19/86 YLH)
:
	LHI	R5,PTRSTA		:PREPARE PENDING TRANSP STATE
	STB	R5,LUCTAB+LULUST,R4,	:UPDATE LUSVC STATE
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
	STB	R5,LUCTAB+LULUW3,R4,	:INIT LULUW3 WORK BYTE(5/15/85/CHS)
	JR	R14			:AND RETURN

:: H.PTFN - FINISH COMMAND IN PENDING TRANSPARENT MODE.
:
:: THE CURRENT CODE DOES NOT NOTIFY PRINTER SUPPORT. THIS
:: MEANS THAT ONCE THE VIRTUAL CIRCUIT IS BUILT (FINISH CMD
:: RECEIVED FROM NIO) WE ISSUE LUSTAT(82B) ON SSCP-LU SESSION AND
:: GO INTO TRANSPARENT MODE UPON RECEIVING +RSP FROM THE HOST.
:: THIS TRANSITION FROM LOCAL TO TRANSPARENT MUST BE GOOD TO
:: SOLICIT SSCP-LU BANNER MESSAGE FROM THE HOST, BUT IT MAY NOT
:: SOLICIT BIND IF IT WAS SENT BY THE HOST HILE WE WERE IN
:: LOCAL MODE (NO VIRTAUL CIRCUIT).
:
:FIRST VECTOR THE EXECUTION DEPENDING ON LUSVC SUBSTATE.
H.PTFN	LR	R9,R4			:COPY LUCB POINTER
	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET SSCP-LU SCB POINTER
	LH	R5,SCBBLK+SCTRNG,R7,	:GET CT-RCV GET POINTER
	CH	R5,SCBBLK+SCTRNR,R7,	:CT-RCV EMPTY?
	JNR	R14			:RETURN IF NOT
	IF	VHRSUP
	LB	R5,LUCTAB+LUCVHR,R9,	:GET VHR STATE BYTE
	THI	R5,LUVHRF		:VHR FUNCTION?
	JE	H.PTF1			:JUMP IF NOT
	CHI	R1,NSBDRP		:BIND REPONSE REQUESTED?
	JN	H.VRER			:ERROR IF NOT
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JE	H.VRER			:ERROR IF NOT THERE
	XR	R0,R0			:PREPARE FOR +RSP
	LHI	R1,BIND			:RSP FOR BIND
	JAL	R8,L.GNSR		:GENERATE RSP
	LHI	R2,PMCSMS		:SEND TO SESSION CONTROL
	LHI	R1,LUSEND		:FROM LU.SEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND IT
	JR	R14			:AND RETURN
	EI
H.PTF1	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE
	NHI	R5,LUSBST		:GET LUSVC SUBSTATE
	LHL	R5,H.PTTB,R5,R5		:GET PTR TO PROC ROUTINE
	J	L.BASE,R5		:JUMP TO PROC ROUTINE

H.PTTB	HC	H.PTON-L.BASE		:SEND LUSTAT POWER ON ROUTINE

:: SEND LUSTAT(POWER ON) ROUTINE.
	IF	BNDNTF			:(4/22/85/CHS, START)
H.PTON
	LA	R8,NTFYCN,,		:POINT TO NOTIFY CANNED MSG
	LHI	R0,NTFYLG+3		:LENGHT OF NOFITY + RH
	JAL	R5,L.DFSL		:GENERATE THE MESSAGE
	LB	R5,BBUFER+MURHF1,R10,	:GET BYTE 1 OF RH
	NHI	R5,@MU.CTG		:CORRECT MU.CTG
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE BYTE 1 OF RH
	ELSE				:(4/22/85/CHS, END)
H.PTON	LB	R5,LUCTAB+LUCTYP,R9,	:GET LU TYPE
	CHI	R5,LU.T3		:TYPE 3?
	JE	H.PTOA			:JUMP IF SO
					:(F00/02/23/87/DB/START)
	CHI	R5,LU.T1		:TYPE 1?
	JE	H.PTOA			:YES
					:(F00/02/23/87/DB/END)
	LB	R5,LUCTAB+LUCSCC,R9,	:GET NON-CLEAR STORAGE BYTE
	THI	R5,LUSVCF		:-RSP(FMD) ISSUED?
	JN	H.PTOA			:JUMP IF SO
	THI	R5,LUSVCB		:-RSP(BIND) ISSUED?
	JE	H.PTO1			:JUMP IF NOT
:	NHI	R5,@LUSVCB		:CLEAR THE BIT
:	STB	R5,LUCTAB+LUCSCC,R9,	:UPDATE NON-CLEAR STORAGE BYTE
	JAL	R5,H.GNDS		:GENERATE DUMMY FMD
	LHL	R5,SCBBLK+SCSQSC,R7,	:GET PREVIOUS ID
	AIS	R5,1			:INCREASE IT BY 1
	STH	R5,SCBBLK+SCSQSC,R7,	:UPDATE ID IN SCB
	STH	R5,BBUFER+MUSNF,R10,	:UPDATE MUCB
	LB	R5,BBUFER+MURHF2,R10,	:GET BYTE 2 OF RH
	NHI	R5,@MU.ERI		:CLEAR ERI
	STB	R5,BBUFER+MURHF2,R10,	:UPDATE BYTE 2 OF RH
	JAL	R4,GBB,,		:GET A BUFFERLET FOR DQE
	J	NOBUFR			:JUMP IF NONE AVAILBLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	BBLSCB	R5,LUCTAB+LUSSCB,R9,	:GET SCB POINTER
	ST	R5,BBUFER+DQSCB,R3,	:PUT IT IN DQE
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:FILL IN MUCB POINTER
	STH	R9,BBUFER+DQLUCB,R3,	:FILL IN LUCB POINTER
	EI	(BNDNTF)		:(4/22/85/CHS)
	J	H.PTO2			:JUMP TO CONTINUE
H.PTO1	THI	R5,LUSVCF		:-RSP(FMD) ISSUED
	JE	H.PTO3			:JUMP IF NOT
:	NHI	R5,@LUSVCF		:CLEAR THE BIT
:	STB	R5,LUCTAB+LUCSCC,R9,	:UPDATE NON-CLEAR STORAGE BYTE
H.PTOA
	LB	R5,LUCTAB+LUCSYS,R9,	:IF FUJITSU HOST, CAN NOT(03/24/86/CHS)
	CLHI	R5,FUJITSU		:SEND LUSTAT (03/24/86/CHS)
	JE	H.PTO3			:SKIP.. (03/24/86/CHS)
	LA	R8,LUONCN,,		:POINT TO LUSTAT ON CANNED RU
	LHI	R0,LUONLG+3		:LUSTAT BIU LENGTH
	JAL	R5,L.DFSL		:GENERATE SSCP-LU DFC (LUSTAT)
H.PTO2	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LUSEND		:ORIGINATION LUSEND
	LHI	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN
:NOTHING TO SEND TO THE HOST. FINISH WITH PENDING MODE AND INFORM NIO.
H.PTO3	EQ	.
	IF	HDPSUP
	LHL	R5,LUCTAB+LUSNDG,R9,	:GET PTR TO NIO->SNA CMD LINK
	LB	R5,CMDBLK+CLCMDS,R5,	:GET SUBCOMMAND
	CHI	R5,NSFNDP		:DSP STATE?
	JNFS	H.PTO4			:JUMP IF NOT
	LHI	R5,DSPSTA		:PREPARE DSP STATE
	JFS	H.PTO5			:JUMP TO CONTINUE
	EI
H.PTO4	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC 2ND WORK BYTE
	LHI	R5,TRPSTA		:PREPARE TRANSPATENT STATE
H.PTO5	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R0,SNPOSR^8!SNFNLG	:PREPARE FOR +RSP FOR FINISH LOGON
	JAL	R5,L.PTCD,,		:INFORM NIO
	J	L.RMT0			:REMOVE FINISH LOGON
	EI				:END OF FINISH ROUTINES FOR HST IF

::::::::::::::::::::::::::::::::::::
:: START LOGON COMMAND RECEIVED FROM NIO.
::::::::::::::::::::::::::::::::::::
::
:: TERMINAL INTERFACE ROUTINES.

	IF	TERMIF			:START ROUTINES FOR TERM IF

:: L.TRST - START LOGON RECEIVED IN TRANSPARENT MODE.
:  THE SUBSTATE IS CHECKED AGAINST SUBCOMMAND (WAITING FOR
:  START LOGON CORRESPONDS TO "LOGON INITIATED BY TERMINAL").
:  IF THERE IS A MATCH LUSVC STATE IS CHANGED TO "PENDING LOCAL".
:  START COMMAND IS REMOVED FROM NTW->SNA QUEUE WHICH CAUSES
:  "PENDING LOCAL" STATE ROUTINES TO BE SCHEDULED.
L.TRST	LR	R9,R4			:COPY LUCB POINTER
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	XR	R1,R5			:COPMARE WITH SUBCOMMAND
	NHI	R1,LUTRLG		:LEAVE ONLY "LOGON WAIT"
	JNFS	L.TRS1			:JUMP IF THEY DO NOT MATCH

:LUSVC SUBSTATE AND SUBCOMMAND MATCH.
:CHANGE STATE TO "PENDING LOCAL" AND RETURN.
	LHI	R5,PLCSTA		:PREPARE STATE "PENDING LOCAL"
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE
	JR	R14			:AND RETURN

:LUSVC SUBSTATE AND SUBCOMMAND DO NOT MATCH.
:CLEAR WAIT LOGON SUBSTATE AND SEND "UNABLE TO EXECUTE COMMAND" TO NIO.
L.TRS1	NHI	R5,@LUSBST		:CLEAR WAIT FOR LOGON
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE
	LHI	R0,SNERR^8!SNERNT	:PREPARE ERR IN NIO CMD
	JAL	R5,L.PTCD,,		:SEND CMD TO NIO
	J	L.RMT0			:JUMP TO REMOVE CMD FROM Q

:::::::::::::::::::::::::
:: L.PLST - START COMMAND RECEIVED IN PENDING LOCAL MODE.
:: PROCESSING DEPENDS ON PENDING LOCAL SUBSTATES.
:  SUBSTATE 0 - +RSP ARE SENT TO ALL SSCP-LU OUTSTATDING RQ'S.
:  SUBSTATE 1 - CHASE IS SENT (IF LU-LU SESSION EXISTED).
:  SUBSTATE 2 - UNBIND IS SENT (IF LU-LU SESSION EXISTED).
:  SUBSTATE 3 - BIND IS SENT.
:  SUBSTATE 4 - SDT IS SENT.
: THE PROCEDURE IS SCHEDULEED BECAUSE START COMMAND IS NOT
: REMOVED FROM NTW->SNA DATA QUEUE UNTIL EITHER POSITIVE
: RESPONSE FOR SDT IS RECEIVED (NORMAL CASE) OR SOMETHING
: ABNORMAL HAPPENED IN BETWEEN.

L.PLST	LR	R9,R4			:COPY LUCB POINTER
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE
	NHI	R5,LUSBST		:GET LUSVC SUBSTATE
	LHL	R5,L.PLTB,R5,R5		:GET PTR TO PROCESSING ROUTINE
	J	L.BASE,R5		:VECTOR EXECUTION

:TABLE OF POINTERS OF PROCESSING ROUTINES FOR PENDING LOCAL
:STATES (SEND SIDE).
L.PLTB	HC	L.PLSR-L.BASE		:SEND +RSP FOR SSCP-LU
	HC	L.PLCH-L.BASE		:SEND CHASE
	HC	L.PLUB-L.BASE		:SEND UNBIND
	HC	L.PLBD-L.BASE		:SEND BIND
	HC	L.PLSD-L.BASE		:SEND SDT

	EI

:SEND +RSP FOR ALL OUTSTANDING SSCP-LU RQ'S.
:SCAN CORRELATION TABLE.
L.PLSR	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET PTR TO SSCP-LU SCB
	LHL	R8,SCBBLK+SCTRNG,R7,	:GET GET PTR TO CT TABLE
:	CH	R8,SCBBLK+SCTRNR,R7,	:IS CT TABLE EMPTY?
	LHL	R5,SCBBLK+SCTRNR,R7,	:GET REL POINTER
	CR	R8,R5			:IS CT TABLE EMPTY?
	JNFS	L.PLS1			:JUMP IF NOT

:GO TO THE NEXT SUBSTATE IF IT IS EMPTY.
L.PLS0	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	AIS	R5,1			:NEXT SUBSTATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	JR	R14			:RETURN

:GENERATE +RSP FOR SSCP-LU DFC OR FMD RQ.
:THIS IS DONE BY L.GNRP SUBROUTINE. HOWEVER BEFORE WE CALL IT
:WE HAVE TO CREATE MUCB WITH SOME OF THE INFORMATION WHICH THIS
:SUBROUTINE NEEDS. THE INFORMATION CORRESPONDS TO RQ, NOT RSP.
:ONLY THE INFORMATION USED IN L.GNRP IS FILL IN CORRECTLY.
L.PLS1	JAL	R4,GBB,,		:GET BUFFERLET FOR MUCB
	J	NOBUFR			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LR	R10,R3			:COPY BUFFERLET POINTER
	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET PTR TO BUF WITH CT
:	LB	R5,BBUFER+CLARG5,R4,	:GET BYTE WITH RU CATEGORY
:	SRLS	R5,5			:POSITION IT FOR RH BYTE 1
	LB	R5,BBUFER+CLARG6,R4,	:GET BYTE WITH RU CATEGORY
	NHI	R5,MU.CTG		:LEAVE RU CATEGORY ONLY
	JEFS	L.PLS4			:JUMP IF FMD
	OHI	R5,MU.FI		:OTHERWISE TURN ON FORMAT INDICATOR
L.PLS4	STB	R5,BBUFER+MURHF1,R10,	:STORE IT IN MUCB
	LB	R5,BBUFER+CLARG5+1,R4,	:GET BYTE CONTAINING RH BYTE 2
	STB	R5,BBUFER+MURHF2,R10,	:STORE IT IN MUCB
	LB	R1,BBUFER+CLARG4,R4,	:GET RQ CODE
	LHL	R5,BBUFER+CLARG3,R4,	:GET END SEQ #
	STH	R5,BBUFER+MUSNF,R10,	:PUT IT IN MUCB
	LHI	R5,FID2^4		:PREPARE 1ST BYTE OF TH
	STB	R5,BBUFER+MUBIUF,R10,	:PUT IT IN MUCB
	LB	R5,LUCTAB+LUCADR,R9,	:GET ADDR OF SEC LU
	XR	R0,R0			:+RSP (NO SENSE CODE)
	IF	TERMIF&HOSTIF
	LB	R3,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R3,PU.T4		:TYPE 4?
	JNFS	L.PLS2			:JUMP IF NOT
	EI
	IF	TERMIF
	STB	R5,BBUFER+MUOADP,R10,	:PUT IT IN MUCB
	STB	R0,BBUFER+MUDADP,R10,	:PRI IS SSCP
	EI
	IF	TERMIF&HOSTIF
	JFS	L.PLS3			:JUMP TO CONTINUE
	EI
	IF	HOSTIF
L.PLS2	STB	R5,BBUFER+MUDADP,R10,	:PUT SEC ADDR IN MUCB
	STB	R0,BBUFER+MUOADP,R10,	:PRI IS SSCP
	EI
L.PLS3	JAL	R5,L.GNRP		:GENERATE +RSP
	LHI	R2,DFCSND		:SHOW DFCSND AS DESTINATION
	LHI	R1,LUSEND		:FROM LUSEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN

	IF	TERMIF
:: SUBSTATE 1 IN LOCAL MODE. IF THERE IS LU-LU SESSION SEND
:  CHASE TO GET ALL RESPONSES BEFORE UNBINDING.
L.PLCH	J	L.PLS0			:GO TO NEXT STATE

:: SUBSTATE 2 IN LOCAL MODE. IF THERE IS LU-LU SESSION
:  SEND UNBIND.
L.PLUB	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET POINTER TO LU-LU SCB
	JE	L.PLS0			:JUMP TO NEXT STATE IF NOT VALID
	J	L.PTUB			:JUMP TO SEND UNBIND

:: SUBSTATE 3 OF LOCAL MODE. GENERATE BIND AND SEND IT.
L.PLBD	LHL	R8,LUCTAB+LUBNDP,R9,	:GET POINTER TO CANNED BIND
	LB	R0,PSEG,R8,		:GET BIND LENGTH
	LA	R8,PSEG+1,R8,		:POINT TO BIND RU
	AIS	R0,3			:ADJUST LENGTH FOR RH
	JAL	R5,L.SCRQ		:GENERATE BIND RQ
	LHI	R5,MU.DR1		:PREPARE DEFINITE RSP
	STB	R5,BBUFER+MURHF2,R10,	:CORRECT MUCB
	LHI	R2,PMCSMS		:DESTINATION - CSC
	LHI	R1,LUSEND		:ORIGINATION - LUSEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN

:: SUBSTATE 4 OF LOCAL MODE. GENERATE SDT AND SEND IT.
L.PLSD	LA	R8,SDTCAN,,		:POINT TO CANNED SDT RU
	LHI	R0,SDTLGT+3		:GET ITS LENGTH (BIU)
	JAL	R5,L.SCRQ		:GENERATE SDT RQ
	LHI	R2,TCSCSD		:DESTINATION TC.SC
	LHI	R1,LUSEND		:ORIGINATION - LUSEND
	LHI	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN
	EI				:END OF START ROUTINES FOR TERM IF

::::::::::::::::::::::::::::::
:: START ROUTINES FOR HOST INTERFACE.

	IF	HOSTIF

:
: H.PLST - PENDING LOCAL MODE AND START LOGON COMMAND.
: THIS SITUATION OCCURS UPON RECEIVING RESET SIGNAL.
: CURRENTLY WE TRY TO SEND RSHUTD AND TURN ON TIMEOUT ROUTINE
: TO ENTER LOCAL STATE.
: OTHER STATES COULD BE NECESSARY FOR MORE COMPLICATED
: RESET SEQUENCES.
:
: FIRST VECTOR EXECUTION DEPENDING ON LUSVC SUBSTATES.
H.PLST	LR	R9,R4			:COPY LUCB POINTER
	IF	VHRSUP
	LB	R5,LUCTAB+LUCVHR,R9,	:GET VHR STATE BYTE
	THI	R5,LUVHRF		:VHR FUNCTION?
	JE	H.PLSB			:JUMP IF NOT VHR
	CHI	R1,NSUBRP		:UNBIND RSP REQUESTED?
	JN	H.PLSB			:JUMP IF NOT
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JE	H.VRER			:JUMP IF NO LU-LU SESSION
	LHI	R1,UNBIND		:PREPARE RSP FOR UNBIND
	XR	R0,R0			:+RSP
	JAL	R8,L.GNSR		:GENERATE +RSP(UNBIND)
	LHI	R2,PMCSMS		:SEND TO SESSION CONTROL
	LHI	R1,LUSEND		:FROM LU.SEND
	LIS	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND IT OVER
	JAL	R12,V.CLEA,,		:CLEAR LU_SVC
	JR	R14			:AND RETURN
	EI
H.PLSB	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE
	NHI	R5,LUSBST		:GET SUBSTATE ONLY
	LHL	R5,H.PLTB,R5,R5		:GET PTR TO PROCESSING ROUTINE
	J	L.BASE,R5		:VECTOR EXECUTION

:TABLE OF POINTERS TO PROCESSING ROUTINES OF PENDING LOCAL MODE.
H.PLTB	HC	H.PLSR-L.BASE		:SEND SSCP-LU RSP
	HC	H.PLSH-L.BASE		:SEND TERM-SELF OR RSHUTD
	HC	H.PLCL-L.BASE		:CLEAN UP

:FOR VHR FUNCTION BIND OR UNBIND RESPONSES COULD BE OUTSTANDNING.
:OTHERWISE ONLY SSCP-LU RESPONSES MUST BE GENERATED IF NECESSARY.
H.PLSR	IF	VHRSUP
	LB	R5,LUCTAB+LUCVHR,R9,	:GET VHR STATE BYTE
	THI	R5,LUVHRF		:VHR FUNCTION
	JE	L.PLSR			:JUMP IF NOT
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JE	L.PLSR			:JUMP IF NO LU-LU SESSION
	LB	R5,SCBBLK+SCSTAT+FSCLLS,R7,	:GET SESS FSM STATE
	CHI	R5,FS.ST1		:STATE 1?
	JE	L.PLSR			:JUMP IF SO
	CHI	R5,FS.ST3		:STATE 3?
	JE	L.PLSR			:JUMP IF SO
	CHI	R5,FS.ST2		:STATE 2?
	JNFS	H.PLSU			:JUMP IF NOT
	LHI	R1,BIND			:BIND RSP OUTSTANDING
	LHI	R0,LUNNSN		:-RSP 80A
	JFS	H.PLSV			:JUMP TO CONTINUE
H.PLSU	LHI	R1,UNBIND		:UNBIND RESPONSE OUTSTANDING
	XR	R0,R0			:+RSP
H.PLSV	JAL	R8,L.GNSR		:GENERATE RSP
	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LHI	R2,PMCSMS		:SEND TO SESSION CONTROL
	LHI	R1,LUSEND		:FROM LU.SEND
	LIS	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND IT
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	EI
	J	L.PLSR			:JUMP TO CONTINUE

:SEND TERM-SELF OR RSHUTD PROCESSING ROUTINE.
:FIRST DETERMINE IF LU-LU SESSION IS ACTIVE.
H.PLSH	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET POINTER TO LU-LU SCB
:	THI	R7,LUINV		:IS IT VALID?
:	JEFS	H.PLS1			:JUMP IF SO
	JN	H.PLS1			:JUMP IF VALID SCB POINTER

:IF NO LU-LU SESSION AND NOTIFY OPTION WAS CHOSEN SEND NOTIFY(NOT READY)
:TO THE HOST AND CLEAN UP (01/07/85 MIA).
	IF	BNDNTF
	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET SSCP-LU SCB POINTER
	JE	H.PLS0			:JUMP IF NO SSCP-LU
	LB	R5,SCBBLK+SCFSMS,R7,	:GET #FSM_SESS (01/06/87 YLH)
	LB	R5,SCBBLK+SCSTAT,R5,R7	:GET FSM STATUS (01/06/87 YLH)
	CLHI	R5,FS.ST3		:IS IT IN ACTIVE STATE? (01/06/87 YLH)
	JN	H.PLS0			:NOT ACTIVE (01/06/87 YLH)
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET FSM_IMM_REQ
	CHI	R5,FS.ST2		:STATE 2?
	JE	H.PLS0			:JUMP IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JE	H.PLS0			:JUMP IF SO
	LA	R8,NTFYNC,,		:SEND NOTIFY (NOT READY)
	LHI	R0,NTFYLG+3		:CANNED NOTIFY MSG LENGTH
	JAL	R5,L.DFSL,,		:GENERATE CANNED NOTIFY
	LB	R5,BBUFER+MURHF1,R10,	:GET RH BYTE 1
	NHI	R5,@MU.CTG		:CORRECT MU.CTG
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE RH BYTE 1
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LUSEND		:ORIGINATION LU.RCV
	LHI	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND THE NOTIFY
	JAL	R12,L.CLEA,,		:CLEAN UP
	JR	R14			:AND RETURN
	EI	(BNDNTF)
:END OF INSERTION (01/07/85 MIA).

:NO LU-LU SESSION ALREADY. START TIMEOUT FOR CLEANUP AND RETURN.
H.PLS0	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULUSO		:TIMEOUT ALREADY STARTED?
	JNR	R14			:RETURN IF SO
	OHI	R5,LULUSO		:START TIMEOUT FOR CLEANUP
	NHI	R5,@LULUFN		:CLEAR TIMEOUT FINAL BIT
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	JR	R14			:AND RETURN

:CHECK IF TIMEOUT CLEANUP ALREADY STARTED AND RETURN IF SO.
H.PLS1	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULUSO		:TIMEOUT CLEANUP STARTED?
	JNR	R14			:RETURN IF SO

:SEND RSHUTD AND RETURN.
	LB	R5,SCBBLK+SCSTAT+FSCLLS,R7,	:GET SESS FSM STATE
	CHI	R5,FS.ST3		:ACTIVE?
	JN	H.PLS0			:JUMP IF NOT
	IF	RSHTSW			:IF RSHUTD SWITCH ON
	LHL	R5,SCBBLK+SCTSEG,R7,	:GET CT EXP SEND GET POINTER
	LHL	R8,SCBBLK+SCTSER,R7,	:GET CT EXP SEND REL POINTER
	CR	R5,R8			:COMPARE THEM
	JNR	R14			:WAIT IF NOT EQUAL
	LA	R8,RSHCAN,,		:GET CANNED RSHUTD RU
	LHI	R0,RSHLGT+3		:GET RSHUTD LENGTH
	JAL	R5,L.DFLL		:GENERATE LU-LU RSHUTD
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	OHI	R5,MU.EFI		:SET EXP FLOW INDICATOR
	STB	R5,BBUFER+MUBIUF,R10,	:CORRECT 1ST BYTE OF TH
	LHL	R5,SCBBLK+SCESQN,R7,	:GET EXP FLOW SEQ #
	AIS	R5,1			:INCREASE IT BY 1
	STH	R5,BBUFER+MUSNF,R10,	:PUT IT IN MUCB
	ELSE				:SEND TERM-SELF
	BBLSCB	R5,LUCTAB+LUSSCB,R9,	:GET SSCP-LU SCB POINTER
	LHL	R8,SCBBLK+SCTSNG,R5,	:GET CT NORM SEND GET POINTER
	LHL	R5,SCBBLK+SCTSNR,R5,	:GET CT NORM SEND REL POINTER
	CR	R5,R8			:COMPARE THEM
	JNR	R14			:WAIT IF CT NOT EMPTY
	LA	R8,TSFCAN,,		:POINT TO SERM-SELF CANNED MSG
	LHI	R0,TSFLGT+3		:LENGTH OF TERM-SELF + RH
	JAL	R5,L.DFSL		:GENERATE THE MESSAGE
	LB	R5,BBUFER+MURHF1,R10,	:GET BYTE 1 OF RH
	NHI	R5,@MU.CTG		:CORRECT MU.CTG
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE BYTE 1 OF RH
	EI
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LUSEND		:ORIGINATION LUSEND
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN

:UNBIND RECEIVED FROM THE HOST AND WE ARE READY TO CLEAN UP.
H.PLCL	IF	VHRSUP
	LB	R5,LUCTAB+LUCVHR,R9,	:GET VHR STATE BYTE
	THI	R5,LUVHRF		:VHR FUNCTION?
	JEFS	H.PLC1			:JUMP IF NOT
	CHI	R1,NSUBRP		:UNBIND RESPONSE REQUESTED
	JNFS	H.PLC1			:JUMP IF NOT
	JAL	R12,V.CLEA,,		:CLEAN UP
	JR	R14			:AND RETURN
	EI
H.PLC1	JAL	R12,L.CLEA,,		:CLEAN UP
	JR	R14			:AND RETURN
	EI				:END OF START ROUTINES FOR HST IF

::::::::::::::::::::::::::::::::::::::::::
:: END-TO-END MESSAGE RECEIVED FROM NIO.
::::::::::::::::::::::::::::::::::::::::::
:
:: L.TRET - TRANSPARENT MODE AND END-TO-END MESSAGE FROM NIO.
:  THE MESSAGE IS NOT REMOVED FROM NTW->SNA QUEUE EXCEPT THE CASE
:  WHEN IT WAS NOT THE FIRST SEGMENT OF THE SEGMENTED MESSAGE.
:  MUCB IS CREATED AND SENT TO DFC.SEND FOR FMD AND DFC CATEGORY.
:  FOR SC CATEGORY BIND AND UNBIND REQUESTS AND RESPONSES ARE SENT
:  TO PU.CSC AND THE REST - TO TC.SC.

H.TRET
L.TRET	JAL	R5,L.MTCN,,		:MAP TO CANONICAL
	LR	R9,R4			:SAVE POINTER TO LUCB
	JAL	R4,GBB,,		:AQUIRE BUFFERLET FOR DQE
	J	NOBUFR			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.BIU		:IS IT 1ST SEGMENT?
	JNFS	L.TREA			:JUMP IF SO
	XR	R1,R1			:OTHERWISE FAKE FMD RQ
	J	L.TRE0			:JUMP TO CONTINUE
L.TREA	LB	R5,BBUFER+MURHF1,R10,	:GET BITE 1 OF RH
	LR	R1,R5			:SAVE IT
	NHI	R5,MU.CTG		:MASK EVERYTHING BUT CATEGORY
	CLHI	R5,MU.SC		:IS IT SC RU CATEGORY?
	JN	L.TRE0			:JUMP IF NOT

:FOR SC RU CATEGORY SEPARATE ALL BUND AND UNBIND REQUESTS AND RSPS
	BBLOAD	R6,BBUFER+MURUPT,R10,	:GET POINTER TO RU
	LB	R5,BBUFER,R6,		:GET RQ OR RSP CODE
	CLHI	R5,BIND			:IS IT BIND?
	JE	L.TRBS			:JUMP IF SO
	CLHI	R5,UNBIND		:IS IT UNBIND?
	JE	L.TRBT			:JUMP IF SO

::THE REST OF SC CATEGORY MESSAGES ARE SENT TO TC.SC
	LHI	R2,TCSCSD		:INDICATE TC.SC.SEND AS DEST
	JFS	L.TRE1			:JUMP TO CONTINUE

:FOR FMD AND DFC MESSAGES DESTINATION PROCEDURE IS DFC.SEND
L.TRE0	LHI	R2,DFCSND		:INDICATE DFC.SEND AS DEST

:FILL IN SCB POINTER. IT CAN BE LU-LU OR SSCP-LU.
L.TRE1	EQ	.
	IF	TERMIF&HOSTIF
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JNFS	L.TREY
	EI
	IF	TERMIF
	LB	R5,BBUFER+MUOADP,R10,	:CHECK ORIGINATION ADDR
	EI
	IF	TERMIF&HOSTIF
	JFS	L.TREZ			:JUMP TO CONTINUE
	EI
	IF	HOSTIF
L.TREY	LB	R5,BBUFER+MUDADP,R10,	:CHECK DESTINATION ADDR
	EI
L.TREZ	JN	L.TRE3			:JUMP IF LU-LU
	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET PTR TO SSCP-LU SCB
L.TRE2	EQ	.
:	THI	R7,LUINV		:CHECK IF VALID
:	JE	L.TRE4			:JUMP IF SO
	JN	L.TRE4			:JUMP IF VALID POINTER
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATUS BYTE
	OHI	R5,LUBDST		:GO TO BAD STATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R0,SNERR^8!SNERNT	:PREPARE UNABLE TO CONTINUE
	JAL	R5,L.PTCD,,		:PASS CMD TO NIO
	JAL	R4,PBB,,		:RELEASE BUF FOR DQE
	JAL	R4,R.PBB,,		:COUNT IT
	LR	R3,R10			:COPY POINTER TO MUCB
	JAL 	R4,PBB,,		:RELEASE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN
L.TRE3	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET PTR TO LU-LU SCB
	J	L.TRE2			:JUMP TO CONTINUE

:SEPARATE REQUESTS AND RESPONSES.
L.TRE4	THI	R1,MU.RRI		:IS IT RESPONSE?
	JN	L.TRE6			:JUMP IF SO

:NOTHING TO DO WITH FMD OR DFC RQUESTS
	CHI	R2,TCSCSD		:IS THIS SC REQUEST?
	JN	L.TRE7			:JUMP IF NOT

:FOR SC REQUESTS ONLY THOSE WHICH ARE ALLOWED FOR TS TYPE 3 ARE
: CURRENTLY SUPPORTED. THE PROBLEM IS WITH STSN.
:IF CLEAR WAS RECEIVED CLEAN ALL ADJUSTMENTS FOR SEQUENCE NUMBER
: FIELDS.
	LB	R5,SCBBLK+SCTSPF,R7,	:GET TS PROFILE
	CHI	R5,3			:IS IT 3?
	JEFS	L.TRE5			:JUMP IF SO
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R5,CR.TSP		:UNSUPPORTED TS PROFILE
L.TRE5	LB	R5,BBUFER,R6,		:GET RQ CODE
	CLHI	R5,CLEAR		:IS IT CLEAR?
	JN	L.TRE7			:JUMP IF NOT
L.TRE9	XR	R5,R5			:CLEAR THE REGISTER
	STH	R5,SCBBLK+SCADJR,R7,	:CLEAN SQ # ADJUST FOR RCV
	STH	R5,SCBBLK+SCADJS,R7,	:CLEAN SQ # ADJUST FOR SEND
	J	L.TRE7			:JUMP TO CONTINUE

:ADJUST SEQUENSE NUMBER IN MUCB FOR NORMAL FLOW REPONSES
L.TRE6	LR	R5,R5			:IS IT LU-LU?
	JEFS	L.TRE7			:JUMP IF NOT
	LB	R5,BBUFER+MUBIUF,R10,	:GET FIRST BYTE OF TH
	NHI	R5,MU.EFI		:CHECK EXP FLOW INDICATOR
	JNFS	L.TRE7			:JUMP IF EXPEDITED
	LH	R5,SCBBLK+SCADJR,R7,	:GET SQ # ADJUSTMENT
	AHM	R5,BBUFER+MUSNF,R10,	:ADJUST MUCB SEQUENCE #

:PREPARE TO SEND DQE. FILL IN DQE AND REGITERS FOR SEND PROCEDURE.
L.TRE7	ST	R7,BBUFER+DQSCB,R3,	:FILL IN DQE SCB PTR
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:FILL IN DQE MUCB PTR
	STH	R9,BBUFER+DQLUCB,R3,	:FILL IN DQE LUCB PTR
	LIS	R0,SG.NOS		:SEND NO SIGNALS
	LHI	R1,LUSEND		:ORIGINATED BY LUSEND

:IN MULTI-SEGMENT MESSAGE THE FIRST SEGMENT WILL BE REMOVED FROM
: MTW->SNA QUEUE ONLY AFTER POSITIVE NOTIFICATION TO LUSEND FROM
: LOWER LEVEL SNA PROCEDURES. THE REST OF THE SEGMENTS ARE REMOVED
: IMMEDIATELY (NO NOTIFICATION FROM LOWER LEVELS IS EXPECTED).
	LB	R5,BBUFER+MUBIUF,R10,	:GET FIRST BYTE OF TH
	NHI	R5,MU.BIU		:IS IT FIRST SEGMENT?
	JN	L.TRE8			:JUMP IF SO
	LR	R6,R8			:COPY PTR TO CMD LINK
	LHL	R5,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK
	JE	L.CLER,,		:JUMP IF EMPTY PTR
	STH	R5,LUCTAB+LUSNDG,R9,	:ADVANCE GET POINER
	JAL	R4,RELCL,,		:RELEASE THE LINK
	LHL	R4,LUCTAB+LUSNDR,R9,	:GET REL PTR
	CR	R4,R5			:LAST IN QUEUE?
	JNFS	L.TRE8			:JUMP IF NOT
	LHL	R4,LUCTAB+LUCT.N,R9,	:GET LU REL #
	RBT	R4,DPNWSN,,		:RESET DATA PRESENT

:SEND MU TO LOWER LAYER AND RETURN.
L.TRE8	JAL	R8,SEND,,			:SEND DQE TO LOWER LAYER
	JR	R14			:AND RETURN
:UNBIND CAME FROM HOST INTERFACE IN TRANSPARENT MODE.
:IT COULD BE GENERATED WITHIN HOST INTERFACE TO INFORM TERMINAL INTERFACE
:THAT ACTLU OR DACTLU WAS RECEIVED DURING LU-LU SESSION. A SPECIAL REASON
:(UNBRSN) WILL BE IN UNBIND IN THIS CASE. TERMINAL INTERFACE ACTIONS ARE
:TO TO GIVE +RSP FOR ALL OUTSTANDING SSCP-LU FMD'S AND DFC'S AND THEN
:SEND UNBIND WITH REGULAR SNA REASON. THE COMMAND WILL NOT BE REMOVED
:FROM NIO->SNA DATA QUEUE UNTIL ALL THESE ACTIONS ARE COMPLETED.
L.TRBT	EQ	.
	IF	TERMIF
	IF	HOSTIF
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JN	L.TRBS			:JUMP IF SO
	EI
	LB	R5,BBUFER+1,R6,		:GET NEXT BYTE AFTER RU CODE
	CHI	R5,UBDRSN		:NON-SNA REASON?
	JN	L.TRBS			:JUMP IF NOT
	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:GET SSCP-LU SCB POINTER
	LHL	R8,SCBBLK+SCTRNG,R7,	:GET CT GET POINTER
	LHL	R5,SCBBLK+SCTRNR,R7,	:GET CT REL POINTER
	CR	R8,R5			:ANYTHING IN CT?
	JEFS	L.TRB0			:JUMP IF NOT
	LIS	R0,1			:SHOW CT NOT EMPTY
	JFS	L.TRB1			:JUMP TO CONTINUE
L.TRB0	XR	R0,R0			:SHOW CT EMPTY
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JN	L.TRB2			:JUMP IF IT IS VALID
L.TRB1	JAL	R4,PBB,,		:RELEASE DQE
	JAL	R4,R.PBB,,		:COUNT IT
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO BTU
	JAL	R5,R.PBBC,,		:RELEASE IT
	LR	R3,R10			:COPY MUCB POINTER
	JAL	R4,PBB,,		:RELEASE IT
	JAL	R4,R.PBB,,		:COUNT THE BUFFER
	LR	R0,R0			:CT EMPTY?
	JN	L.PLS1			:JUMP TO GENERATE SSCP-LU +RSP
	J	L.RMT0			:JUMP TO REMOVE CMD LINK
L.TRB2	LB	R5,SCBBLK+SCSTAT+FSCLLP,R7,	:GET FSM-SESS
	CHI	R5,FS.ST1		:STATE 1?
	JE	L.TRB1			:CANNOT SEND UNBIND, JUMP
	CHI	R5,FS.ST4		:STATE GREATER THAN 4?
	JG	L.TRB1			:CANNOT SEND UNBIND, JUMP
	LHI	R5,UBDNRM		:REPLACE UNBIND REASON FOR NORMAL
	STB	R5,BBUFER+1,R6,		:STORE IT IN THE MSG BUFFER
	LB	R5,LUCTAB+LULUW1,R9,	:GET LUSVC 2ND WORK BYTE
	OHI	R5,LULUUB		:SHOW THAT BIND WAS GENERATED
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC 2ND WORK BYTE
	EI

: BIND OR UNBIND REQUST OR RESPONSE RECEIVED FROM NETWORK
: IN TRANSPARENT MODE. IF SCB EXISTS CLEAN ADJUSTMENTS FOR
:SEQUENCE NUMBER AND SEND IT TO PU.CSC.
L.TRBS	LHI	R2,PMCSMS		:INDICATE PU.CSC AS DEST
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET PRT TO SCB
:	THI	R7,LUINV		:CHECK IF IT IS VALID PTR
:	JE	L.TRE9			:JUMP TO ADJUST SEQUENCE NMBR
:	LHR	R7,R7			:EXPAND SCB POINTER
	JN	L.TRE9			:JUMP TO ADJUST SEQUENCE NMBR
	J	L.TRE7			:SEND IT TO PU.CSC

::::::::::::::::::::::::::::::
:: TERMINAL INTERFACE ONLY.
:
	IF	TERMIF			:FOR TERMINAL INTERFACE ONLY
::::::::::::::::::::::::::
:: SEND PROCESSING ROUTINE FOR END-TO-END MESSAGES IN LOCAL MODE.
:: IT COULD HAPPEN ONLY IF END-TO-END SESSION WAS INTERRUPTED BY
:: LOCAL SESSION (PRINTER SUPPORT).
:: THIS ROUTINE IS STILL TO BE CODED.
L.LCET	JAL	R10,CRASH,,		:TEPMORARY CODE
	HC	0
	BC	4*R5,CR.TMP		:TEMPORARY CRASH CODE
	EI				:END OF TERM IF ONLY ROUTINE

::::::::::::::::::::::::::::
:: INTERNALLY GENERATED MESSAGE FROM NIO.
::::::::::::::::::::::::::::
::
:: THIS IS VALID FOR TERMINAL INTERFACE ONLY.
	IF	TERMIF

::::::::::::::::::::::::::
: SEND PROCESSING ROUTINE FOR LOCAL MESSAGES IN  LOCAL MODE.
:
: FOR TERMINAL INTERFACE ONLY 3270 DATA MESSAGES ARE ALLOWED
: TO COME AS LOACL MESSAGES FROM NIO.
: IF A NEGATIVE RESPONSE WAS RECEIVED (SUSTATES 4 OR HIGHER)
: LOCAL DATA MESSAGES FROM NIO ARE DISCARDED UNTIL WE REACH
: SUBSTATE 6 (CHANGE DIRECTION, LAST CHAIN, LAST SEGMENT FROM NIO).
: FROM THIS SUBSTATE WE GO TO SUSTATE 0 WITH THE ARRIVAL OF NEXT
: LOCAL DATA MESSAGE FROM NIO.
: IF NO NEGATIVE REPONSES WERE RECEIVED FOR THE MESSAGES OF THIS
: SCREEN SO FAR, FSM_DT_SEND_SDT_AND_CLEAR AND FSM_HDX_FF
: ARE CHECKED (LATTER ONLY FOR SEGMENTS DIFFERENT FROM FIRST),
: THE MESSAGE IS MAPPED TO CANONICAL AND SENT TO DFC.
: FIRST SEGMENTS ARE NOT REMOVED FROM NTW->SNA DATA QUEUE PENDING
: NOTIFICATION FROM DFC LAYER.

L.LCLG	LB	R5,LUCTAB+LULUST,R4,	:GET LUSVC STATE BYTE
	THI	R5,LULCCL		:DO WE HAVE TO CLEAN?
	JN	L.LCCL			:JUMP TO CLEAN ROUTINE IF SO

:WE HAVE TO SEND THE MESSAGE ON LU-LU SESSION.
:CHECK THAT SESSION EXISTS AND SDT-CLEAR FSM.
L.LCL0	BBLSCB	R7,LUCTAB+LULSCB,R4,	:GET PRT TO LU-LU SCB
:	THI	R7,LUINV		:IS IT VALID?
:	JEFS	L.LCL1			:JUMP IF SO
	JNFS	L.LCL1			:JUMP IF VALID POINTER
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R7,CR.NSE		:NO LU-LU SESSION
L.LCL1	LB	R5,SCBBLK+SCSTAT+FSCDSA,R7,	:SDT-CLEAR FSM STATE
	CHI	R5,FS.ST3		:IS DATA TRAFFIC ALLOWED?
	JEFS	L.LCL2			:JUMP IF SO
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R5,CR.NDT		:NO DATA ALLOWED

:IF THE FIRST SEGMENT CHECK WITH HDX_FF FSM THAT WE CAN SEND.
L.LCL2	THI	R1,NSDTLS		:IS IT THE FIRST SEGMENT?
	JNFS	L.LCLA			:JUMP IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX_FF STATE
	CHI	R5,FS.ST3		:STATE 3?
	JER	R14			:CAN NOT SEND, RETURN
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:CAN NOT SEND, RETURN
	CHI	R5,FS.ST6		:STATE 6?
	JER	R14			:CAN NOT SEND, RETURN

:MAP MESSAGE TO CANONICAL AND PREPARE DQE.
L.LCLA	JAL	R5,L.MTCN,,		:MAP TO CANONICAL
	LR	R9,R4			:COPY PTR TO LUCB
	LR	R1,R7			:SAVE SCB POINTER
	JAL	R4,GBB,,		:GET BUFFERLET FOR DQE
	J	NOBUFR			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LHI	R2,DFCSND		:SHOW DFC.SEND AS DEST

:IF IT WAS NOT THE LAST SEGMENT, WE HAVE TO REMEBER IT FOR ERROR
:RECOVERY.
	LB	R4,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:LAST SEGMENT?
	JE	L.LCL3			:JUMP IF NOT
	NHI	R4,@LULUSG		:CLEAR LAST SEGMENT PENDIDNG
	LB	R5,LUCTAB+LULUW1,R9,	:GET LUSVC 2ND WORK BYTE
	THI	R5,LULUDR		:DEF RSP PENDING?
	JE	L.LCL4			:JUMP TO CONTINUE IF NOT
	NHI	R5,@LULUDR		:OTHERWISE CLEAR DEF RSP PEND
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC 2ND WORK BYTE
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,WAITRS		:SET WAITING FOR RSP
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	JFS	L.LCL4			:AND CONTINUE
L.LCL3	OHI	R4,LULUSG		:SET LAST SEGMENT PENDING
L.LCL4	STB	R4,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LR	R7,R1			:COPY SCB POINTER
	J	L.TRE7			:JUMP TO SEND DQE

:SUBSTATE IS 4 OR HIGHER. IT MEANS THAT NEGATIVE RSP
:WAS RECEIVED FROM THE TERMINAL. BEFORE WE CAN REDISPLAY
:THE SCREEN WE HAVE TO PURGE ALL LOCAL DATA MESSAGES (IF ANY)
:WHICH BELONG TO THE OLD SCRREN.
:
:FIRST CHECK IF ANYTHING REMAINED TO BE CLEANED.
L.LCCL	LB	R6,LUCTAB+LULUWK,R4,	:GET LUSVC WORK BYTE
	LR	R7,R5			:COPY SUBSTATE BYTE
	NHI	R7,LUSBST		:CLEAR EVERYTHING BUT SUBSTATE
	CHI	R7,LULCCL!LULCLB	:WAS THE LST CHN AFTR CD SENT?
	JN	L.LCC0			:JUMP IF NOT
	THI	R6,LULUSG		:LAST SEGMENT PENDING?
	JN	L.LCC2			:JUMP IF SO
	NHI	R5,@LUSBST		:OTHERWISE RESET LUSVC SBST
	STB	R5,LUCTAB+LULUST,R4,	:UPDATE SUBSTATE
	NHI	R6,@LULUCD&@LULUSG	:CLEAR PEND CD & LAST SEG
	STB	R6,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
	J	L.LCL0			:GO AND SEND THE MESSAGE

:STATE WAS NOT 6, SO THERE IS SOMETHING TO PURGE.
:FIRST CHECK SUBCOMMAND IN CMD (R1) WHETHER IT INDICATES
:CHANGE DIRECTION, END OF CHAIN OR END OF SEGMENT.
L.LCC0	OHI	R5,LULCIC		:PREPARE FOR INTERMED CHN ELE
	THI	R1,NSDTCD		:IS IT CHANGE DIRECTION CMD?
	JEFS	L.LCC1			:NO CD, JUMP
	AIS	R5,LULCLB		:INDICATE CHANGE DIRECTION
L.LCC1	THI	R1,NSDTFC		:IS IT LAST ELE IN CHAIN?
	JNFS	L.LCC2			:JUMP IF NOT
	SIS	R5,LULCIC		:INDICATE LAST ELE OF CHAIN
L.LCC2	THI	R1,NSDTFS		:IS IT THE LAST SEGMENT?
	JNFS	L.LCC3			:JUMP IF NOT
	NHI	R6,@LULUSG		:INDICATE LAST SEGMENT
	JFS	L.LCC4			:AND CONTINUE
L.LCC3	OHI	R6,LULUSG		:INDICATE INTERM SEGMENT

:UPDATE STATE INFORMATION IN LUCB AND RELEASE BUFFERS AND CMD LINK.
L.LCC4	STB	R5,LUCTAB+LULUST,R4,	:UPDATE STATE BYTE
	STB	R6,LUCTAB+LULUWK,R4,	:UPDATE LUSVC WORK BYTE
	LR	R9,R4			:COPY LUCB POINTER
	LB	R5,LUCTAB+LULUW1,R9,	:GET LUSVC 2ND WORK BYTE
	NHI	R5,@LULUDR		:RESET PENDING FOR DEF RSP
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC 2ND WORK BYTE
	BBLOAD	R3,CMDBLK+CLARG,R8,	:GET PTR TO BUFFER CHAIN
	JAL	R5,R.PBBC,,		:RELEASE BUF CHAIN WITH MSG
	J	L.RMT0			:JUMP TO REMOVE CMD LINK
	EI				:END OF ROUTINES FOR TERM IF

::::::::::::::::::::::::::
:: REMOVE FROM NTW->SNA QUEUE ROUTINES
::::::::::::::::::::::::::
:  IN MOST CASES A CMD LINK WILL NOT BE REMOVED FROM NTW->SNA
:  QUEUE BY SEND PROCEDURE TO HAVE AN OPPORTUNITY TO REPEAT
: SEND OPERATIONS IF LOWER LEVEL SNA PROCEDURE CHECKS WERE NEGATIVE
: (SENSE_CHECK BYTE IS NOT 0 IN MUCB).
: TO IMPLEMENT IT LOWER LEVEL PROCEDURES WILL SEND DQE WITH
: POSITIVE OR NEGATIVE ACKNOLEDGEMENT BACK TO L.SEND AFTER
: ATTEMPTING THE SEND OPERATION. L.SEND WILL ROUTE THESE DQE'S
: TO L.RMOV.
:
: FIRST FIND THE POINTER TO LUCB (DQE INFORMATION IS NOT
: NECESSARILY VALID IF COMING FROM SNA LOWER LAYERS).
L.RMOV	LHL	R5,PUCPTR,RNODE,RNODE	:GET POINTER TO PUCB
	LHL	R9,PUCTAB+PUCLUC,R5,	:GET PTR TO 1ST LUCB FOR PU
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MUCB PTR
	IF	TERMIF&HOSTIF		:IF BOTH TERM AND HOST IF SYSGENED
	LB	R4,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R4,PU.T4		:TERMIF?
	JNFS	L.RMVA			:JUMP IF SO
	EI
	IF	TERMIF
	LB	R6,BBUFER+MUDADP,R10,	:LUCB INDEXED BY DEST LU
	EI
	IF	TERMIF&HOSTIF
	JFS	L.RMVB			:JUMP TO CONTINUE
	EI
	IF	HOSTIF
L.RMVA	LB	R6,BBUFER+MUOADP,R10,	:LUCB INDEXED BY ORIG LU
	EI
L.RMVB	AH	R6,LUCTAB+LUCT.D,R9,	:REL LU# FOR INTERFACE
	LHL	R9,LUCPTR,R6,R6		:GET POINTER TO LUCB
	THI	R9,LUINV		:IS IT VALID?
	JN	L.NOLU			:JUMP IF NOT

: VECTOR EXECUTION DEPENDING ON LUSVC STATE.
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	LR	R6,R5			:COPY IT
	NHI	R6,LUSBST		:GET SUBSTATE
	CHI	R6,LUBDST		:UNABLE TO CONTINUE?
	JE	L.RMTU			:JUMP IF SO
	SRLS	R5,5			:CLEAN EVERYTHING BUT STATE
	IF	TERMIF&HOSTIF		:IF BOTH TERM AND HOST SYSGENED
	CHI	R4,PU.T4		:PU TYPE 4?
	JNFS	L.RMV1			:HOST INTERFACE IF NOT
	EI
	IF	TERMIF			:FOR TERMINAL INTERFACE
	LHL	R5,L.RMTB,R5,R5		:GET PTR TO PROC ROUTINE
	J	L.BASE,R5		:JUMP TO PROC ROUTINE
	EI
	IF	HOSTIF			:FOR HOST INTERFACE
L.RMV1	LHL	R5,H.RMTB,R5,R5		:GET PTR TO PROC ROUTINE
	J	L.BASE,R5		:JUMP TO PROC ROUTINE
	EI

:TABLE OF REMOVE PROCESSING ROUTINES
	IF	TERMIF			:JUMP TABLES FOR TERM IF
L.RMTB	HC	L.RMTR-L.BASE		:ROUTINE FOR TRANSP MODE
	HC	L.RMLC-L.BASE		:ROUTINE FOR LOCAL MODE
	HC	L.RMPT-L.BASE		:PENDING TRANSPARENT MODE
	HC	L.RMPL-L.BASE		:PENDING LOCAL MODE
	IF	VTISUP
	HC	L.RMDP-L.BASE		:DSP MODE
	EI
	EI
	IF	HOSTIF			:JUMP TABLES FOR HOST IF
H.RMTB	HC	H.RMTR-L.BASE		:ROUTINE FOR TRANSP MODE
	HC	H.RMLC-L.BASE		:ROUTINE FOR LOCAL MODE
	HC	H.RMPT-L.BASE		:PENDING TRANSPARENT MODE
	HC	H.RMPL-L.BASE		:PENDING LOCAL MODE
	IF	HDPSUP
	HC	H.RMDP-L.BASE		:DSP MODE
	EI
	EI

:NO VALID LUCB POINTER.
L.NOLU	JAL	R10,CRASH,,		:CRASH
	HC	0
	BC	4*R6,CR.ILU		:INVALID LU

:REMOVE PROCESSING ROUTINE FOR TRANSPARENT MODE.
: IT CHECKS SENSE-CHECK IN MUCB AND REMOVES CMD IF OK.
:IF SENSE CHECK IS NOT OK IT CALLS MU SENSE CHECK ROUTINE WHICH
: LOOKS IN THE SENSE-CHECK CODE AND DECIDES WHETHER THE SEND
: OPERATION COULD BE REPEATED. IF SO IT DISCARDS DQE AND MU.
: NTW->SNA CMD REMAINS IN THE QUEUE AND WILL BE SCHEDULED FOR
: EXECUTION ON THE NEXT SCHEDULER CYCLE.
:IN CASE OF SENSE-CHECK CODE INDICATING PERMANENT PROBLEM
: LUSVC NOTIFIES NIO AND GOES IN UNABLE TO CONTINUE SUBSTATE WHICH
: CAN BE CLEARED BY CLEAR COMMAND FROM NIO.
H.RMTR
L.RMTR	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE-CHECK BYTE
	JN	L.RMT1			:JUMP IF NOT OK

:	(9/18/84/CHS)	DISCARD MUCB FIRST
	LR	R3,R10			:SET UP R3
	JAL	R4,PBB,,		:REALSE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
:	(9/18/84/CHS) END OF DISCARD MUCB INSERTION

:FOR TERMINAL INTERFACE UNBIND WITH SPECIAL REASON (SEE SEND PROCESS
:FOR UNBIND IN TRANSPARENT MODE) IS NOT REMOVED UNTIL UNBIND TO THE
:TERMINAL IS SENT. UNBIND GENERATED INDICATOR IN TURNED ON IN THIS
:CASE IN 2ND WORK BYTE OF LUSVC.
	IF	TERMIF
	IF	HOSTIF
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JN	L.RMT0			:JUMP IF NOT
	EI
	LHL	R5,LUCTAB+LUSNDG,R9,	:GET NIO->SNA GET POINTER
	LB	R6,CMDBLK+CLCMD,R5,	:GET COMMAND CODE
	CHI	R6,NSETEM		:END-TO-END MESSAGE
	JN	L.RMT0			:JUMP IF NOT
	LB	R5,LUCTAB+LULUW1,R9,	:GET LUSVC 2ND WORK BYTE
	THI	R5,LULUUB		:UNBIND GENERATED?
	JN	L.RMT0			:JUMP TO REMOVE IF SO
	BBLOAD	R6,CMDBLK+CLARG,R5,	:GET MSG POINTER
	LB	R5,BBUFER+6,R6,		:GET RH BYTE 1
	NHI	R5,MU.CTG		:GET RU CATEGORY
	CHI	R5,MU.SC		:SC?
	JN	L.RMT0			:JUMP IF NOT
	LB	R5,BBUFER+9,R6,		:GET RQ CODE
	CHI	R5,UNBIND		:UNBIND?
	JN	L.RMT0			:JUMP IF NOT
	LB	R5,BBUFER+0A,R6,	:GET UNBIND REASON
	CHI	R5,UBDRSN		:SPECIAL REASON?
	JER	R14			:DO NOT REMOVE IF SO
	EI

:IF POSITIVE ACKNOLEDGMENT FROM LOWER SNA LAYERS REMOVE
: CMD FROM NTW->SNA DATA QUEUE.
L.RMT0	LHL	R6,LUCTAB+LUSNDG,R9,	:GET NTW->SNA GET PTR
	LHL	R5,CMDBLK+CLPTR,R6,	:GET PTR TO NEXT LINK
	JE	L.CLER,,			:ERROR IF NO NEXT LINK
	STH	R5,LUCTAB+LUSNDG,R9,	:UPDATE NTW->SNA GET PTR
	JAL	R4,RELCL,,		:RELEASE THE LINK
	LHL	R4,LUCTAB+LUSNDR,R9,	:GET REL PTR
	CR	R4,R5			:LAST IN THE QUEUE?
	JNR	R14			:RETURN IF NOT
	LHL	R4,LUCTAB+LUCT.N,R9,	:GET REL LU #
	RBT	R4,DPNWSN,,		:RESET DATA PRESENT
	JR	R14			:AND RETURN

:IF NEGATIVE ACKNOLEDGMENT FROM LOWER SNA LAYER CHECK IF
: WE CAN RESEND THE MESSAGE.
:SPECIAL CASE IS IF SENSE-CHECK IF 0 ADN RSP. DISCARD THIS EXTRA RSP.
L.RMT1	:L	R5,BBUFER+MUSCKS,R10,	:GET SENSE-CHECK CODE
:	JN	L.RMTS			:JUMP TO CONTINUE
:	LB	R5,BBUFER+MURHF1,R10,	:GET RH BYTE 1
:	THI	R5,MU.RRI		:IS IT RSP?
:	JE	L.RMTS			:CONTINUE IF RQ
:	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO BTU
:	JAL	R5,R.PBBC,,		:DISCARD IT
:	LR	R3,R10			:COPY POINTER TO MUCB
:	JAL	R4,PBB,,		:DISCARD IT
:	JAL	R4,R.PBB,,		:COUNT IT
:	J	L.RMT0			:JUMP TO REVOMVE CMD LINK
L.RMTS	LB	R5,EVBLK+EVSPRO,R12,	:GET SENDING PROCEDURE #
	CHI	R5,DFCSND		:DFC.SEND
	JE	L.RMTX			:JUMP IF SO
	JAL	R5,L.RMCK,,		:CHECK SENSE-CODE
	LR	R0,R0			:CAN WE REPEAT SEND?
	JE	L.RMT2			:JUMP IF SO

:IF LUSVC IS UNABLE TO CONTINUE IT PUTS ITSELF IN THE BAD SUBSTATE
: AND NOTIFIES NIO.
L.RMTF	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUBDST		:SHOW UNABLE TO CONTINIUE
	STB	R5,LUCTAB+LULUST,R9,	:PUT IT BACK
	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R0,SNERR^8!SNERLU	:PREPARE ERR CMD TO NTW
	JAL	R5,L.PTCD,,		:PUT CMD IN SNA->NTW QUEUE

:IF LOWER SNA LAYERS NOTIFIED LUSVC OF THE FAILURE WE HAVE TO
: GET RID OF MUCB.
L.RMT2	LR	R3,R10			:COPY PTR TO MUCB
	JAL	R4,PBB,,		:RELEASE MUCB	
	JAL	R4,R.PBB,,		:COUNT THE BUFFERLET
	JR	R14			:AND RETURN

:IF SENSE-CHECK WAS RECEIVED FROM DFC LAYER IN TRANSPARENT MODE
:TRY TO SEND THE MESSAGE STRAIGHT TO CPMGR AND REMOVE CMD LINK FROM
:NIO-SNA QUEUE.
L.RMTX	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MUSCHK,R10,	:CLEAR SENSE-CHECK
	ST	R5,BBUFER+MUSCKS,R10,	:CLEAR SENSE-CODE
	JAL	R4,GBB,,		:GET BUFFERLET FOR DQE
	J	NOBUFR			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	L	R7,NCBBLK+NDSSCB,R13,	:GET SCB POINTER
	ST	R7,BBUFER+DQSCB,R3,	:STORE IT IN DQE
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:PUT MUCB POINTER IN DQE
	STH	R9,BBUFER+DQLUCB,R3,	:PUT LUCB POINTER IN DQE
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	LHI	R1,LUSEND		:ORIGINATION LUSEND
	LHI	R2,TCCMSD		:SEND TO CPMGR
	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	LB	R0,BBUFER+MURHF1,R10,	:GET RH BYTE 1 (01/14/86/CHS)
	THI	R0,MU.RRI		:SEE IF RQ OR RSP (01/14/86/CHS)
	JNFS	L.RMTY			:IF RSP, DONT BUMP SQN(01/14/86/CHS)
	LR	R9,R7			:COPY SCB POINTER
	JAL	R8,D.SSNA,,		:ASSIGN SNF
L.RMTY					:(01/14/86/CHS)
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	JAL	R8,SEND,,		:SEND DQE
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	J	L.RMT0			:JUMP TO REMOVE CMD LINK

:IF UNABLE TO CONTINUE (BAD SUBSTATE) GET RID OF MESSAGE AND MUCB.
L.RMTU
:L.RCV1	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MESSAGE(6/19/84/CHS)
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MESSAGE
	JAL	R5,R.PBBC,,		:RELEASE BUF CHAIN WITH THE MESSAGE
	LR	R3,R10			:NOW POINT TO MUCB
	JAL	R4,PBB,,		:RELEASE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:::::::::::::::::::::::::::::::::::
:: FOR THE REST OF THE MODES (ALL EXCEPT TRANSPARENT) ROMVE PROCESSING
:: IS DIFFERENT FOR TERMINAL AND HOST INTERFACES.
:::::::::::::::::::::::::::::::::::
::
:: REMOVE PROCESSING ROUTINES FOR TERMINAL INTERFACE.

	IF	TERMIF			:REMOVE ROUTINES FOR TERM IF

:::::::::::::::::::::::::::::
:: REMOVE SERVICE FOR LOCAL MODE.
:  IT INCLUDES ALL FUNCTIONS OF REMOVE SERVICE IN TRANSPARENT MODE.
:  IN ADDITION IT KEEPS TRACK OF SENDING SUBSTATES OF LOCAL MODE
:  AND SEQUENCE NUMBER ADJUSTMENT FIELD IN SEND DIRECTION.
:
:FIRST TEST SENSE-CHECK BYTE IN MUCB.
L.RMLC	LB	R5,BBUFER+MUSCHK,R10,,	:GET BYTE WITH SENSE-CHECK
	JN	L.RML5			:JUMP IF NOT OK

:SENSE CHECK WAS OK, SO THE MESSAGE WAS SENT. IT COULD BE ONLY
:THE FIRST SEGMENT OF THE MESSAGE (THE REST OF THE SEGMENTS
:ARE REMOVED IMMEDIATELY WITHOUT NOTIFICATION FROM DFC LAYER).
:CORRECT LUSVC STATE BYTE.
	LB	R4,LUCTAB+LULUST,R9,	:GET LUSVC STATE
	OHI	R4,LULCIC		:PREPARE FOR INTERM CHN ELE
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	THI	R5,MU.EBI!MU.CDI	:IS IT EB OR CD?
	JEFS	L.RML1			:JUMP IF NONE OF ABOVE
	AIS	R4,LULCLB		:SHOW CHANGE DIRECTION
L.RML1	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.ECI		:IS IT LST CHN ELE?
	JE	L.RML2			:JUMP IF NOT
	SIS	R4,LULCIC		:INDICATE LAST CHAIN ELE

:FOR LAST CHAIN ELEMENT DEFINITE RESPONSE COULD BE REQUESTED.
:IF SO PUT US IN WAIT MODE FOR THE LAST SEGMENT OR SET PENDING DEF RSP
:IF NOT THE LAST SEGMENT.
	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R5,MU.DR1!MU.DR2	:IS DEFINITE REPONSE REQUSTED?
	JE	L.RML2			:JUMP IF NOT
	LB	R5,BBUFER+MUBIUF,R10,	:GET TH BYTE 1
	THI	R5,MU.EIU		:LAST SEGMENT?
	JNFS	L.RML6			:JUMP IF SO
	LB	R5,LUCTAB+LULUW1,R9,	:GET LUSVC 2ND WORK BYTE
	OHI	R5,LULUDR		:SET DEF RSP PENDING
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC 2ND WORK BYTE
	JFS	L.RML2			:JUMP TO CONTINUE
L.RML6	OHI	R4,WAITRS		:INDICATE TO WAIT FOR RSP

:UPDATE STATE INFORMATION AND ADJUSTMENT FOR SEND SEQUENCE NUMBER.
L.RML2	STB	R4,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET SCB POINTER
:	THI	R7,LUINV		:IS IT VALID?
:	JEFS	L.RML4			:JUMP IF SO
	JNFS	L.RML4			:JUMP IF VALID POINTER
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R7,CR.NSE		:NO LU-LU SESSION
L.RML4	LCS	R5,1			:PREPARE -1
	AHM	R5,SCBBLK+SCADJS,R7,	:ADJ SEND SEQ #

:	(9/18/84/CHS)	DISCARD MUCB FIRST
	LR	R3,R10			:SET UP R3
	JAL	R4,PBB,,		:REALSE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
:	(9/18/84/CHS) END OF DISCARD MUCB INSERTION

	J	L.RMT0			:JUMP TO REMOVE CMD LINK

:THE MESSAGE WAS NOT SENT. IF UNCORRECTABLE PROBLEM DO THE SAME
:AS IN TRANSPARENT MODE.
L.RML5	JAL	R5,L.RMCK,,		:CHECK IF WE CAN CONTINUE
	LR	R0,R0			:CAN WE?
	JN	L.RMTF			:JUMP IF NOT

:WE CAN REPEAT SENDING PROCEDURE ONCE AGAIN. BEFORE DOING IT
:CORRECT SEGMENTION INFORMATION. IT CAN NOT BE PENDING
:BECAUSE NEGATIVE NOTIFICATION IS ONLY FOR THE 1ST SEGMENT.
	LB	R4,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R4,@LULUSG		:CLEAR PEND SEG
	STB	R4,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	L.RMT2			:CONTINUE AS FOR TRANSP MODE

::::::::::::::::::::::::::
:: REMOVE PROCESSING IN PENDING LOCAL AND PENDING TRANSPARENT MODES.
:  NOTHING IS ACTUALLY REMOVED FROM NTW->SNA QUEUE IN THIS MODE.
:  IN CASE OF NEGATIVE NOTIFICATION THE ACTIONS TAKEN ARE THE SAME AS
:  IN TRANSPARENT MODE, BUT ADDITIONALLY THE BUFFERS WITH THE
:  MESSAGE JUST SENT IS RELEASED.
:  IS CASE OF POSITIVE NOTIFICATION FOR REQUEST WE GO TO THE
:  NEXT STATE AND SET WAIT BIT IN LUSVC STATUS OF DEFINITE
:  RESPONSE WAS REQUESTED.
L.RMPT
L.RMPL	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE-CHECK BYTE
	JEFS	L.RMP1			:JUMP IF OK
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:OTHERWISE GET PTR TO MSG
	JAL	R5,R.PBBC,,		:RELEASE BUFFERS WITH MSG
	J	L.RMTF			:CONTINUE AS IN TRANSP MODE

:IF OK FOR OUR RSP RETURN
L.RMP1	LB	R5,BBUFER+MURHF1,R10,	:GET RH BYTE 1
	THI	R5,MU.RRI		:IS IT RSP?
:	JNR	R14			:RETURN IF SO(9/18/84/CHS)
	JN	L.RMP3			:SKIP, IF SO(9/18/84/CHS)

:FOR RQ GO TO NEXT SUBSTATE AND SET WAIT BIT IF DEFINITE RSP REQUESTED.
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	AIS	R5,1			:GO TO NEXT SUBSTATE
	LB	R4,BBUFER+MURHF2,R10,	:GET RH BYTE 2
	THI	R4,MU.DR1!MU.DR2	:DEFINITE RSP REQUESTED?
	JEFS	L.RMP2			:JUMP IF NOT
	OHI	R5,WAITRS		:SET WAIT BIT
L.RMP2	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC BYTE

:	(9/18/84/CHS)	DISCARD MUCB FIRST
L.RMP3
	LR	R3,R10			:SET UP R3
	JAL	R4,PBB,,		:REALSE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
:	(9/18/84/CHS) END OF DISCARD MUCB INSERTION

	JR	R14			:AND RETURN
	EI				:END OF REMOVE ROUTINES FOR TERM IF

:::::::::::::::::::::::::::::::
:: REMOVE PROCESSING ROUTINES FOR HOST INTERFACE.
:::::::::::::::::::::::::::::::

	IF	HOSTIF			:REMOVE ROUTINES FOR HOST IF

:::::::::::::::::::::::::::::
:: REMOVE SERVICE FOR LOCAL MODE.
:  NOTHING IS SENT IN LOCAL MODE EXCEPT RESPONSES. SO IT SHOULD NOT HAPPEN.
H.RMLC	J	H.RMP6			:GET RID OF NOTIFICATION

::::::::::::::::::::::::::
:: REMOVE PROCESSING IN PENDING TRANSPARENT MODE.
:  IN CASE OF NEGATIVE NOTIFICATION THE ACTIONS TAKEN ARE THE SAME AS
:  IN TRANSPARENT MODE, BUT ADDITIONALLY THE BUFFERS WITH THE
:  MESSAGE JUST SENT IS RELEASED.
:  IS CASE OF POSITIVE NOTIFICATION FOR REQUEST
:  CURRENT CODE GOES INTO TRNASPARENT STATE (AFTER LUSTAT POWER ON),
:  FINISH LOGON CMD LINK IS REMOVED AND NIO IS NOTIFIED.
H.RMPT	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE-CHECK BYTE
	JEFS	H.RMP1			:JUMP IF OK
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:OTHERWISE GET PTR TO MSG
	JAL	R5,R.PBBC,,		:RELEASE BUFFERS WITH MSG
	J	L.RMTF			:CONTINUE AS IN TRANSP MODE

:IF OK FOR OUR RSP RETURN
:FOR VHR GO TO DSP STATE.
H.RMP1	EQ	.
	IF	VHRSUP
	LB	R5,LUCTAB+LUCVHR,R9,	:GET VHR STATE BYTE
	THI	R5,LUVHRF		:VHR LU?
	JEFS	H.RMPN			:JUMP IF NOT
	LHI	R5,DSPSTA		:OTHERWISE PREPARE DSP STATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE BYTE
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LU_SBC WORK BYTE
	J	H.RMP5			:JUMP TO CONTINUE
H.RMPN	EQ	.
	EI
	LB	R5,BBUFER+MURHF1,R10,	:GET RH BYTE 1
	THI	R5,MU.RRI		:IS IT RSP?
:	JNR	R14			:RETURN IF SO(9/18/84/CHS)
	JN	H.RMP6			:SKIP, IF SO(9/18/84/CHS)

:FOR RQ (LUSTAT) GO INTO TRANSPARENT STATE.
	IF	1-HDPSUP
	LHI	R5,LULULU		:SHOW +RSP(LUSTAT) PENDING
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC 2ND WORK BYTE
	LHI	R5,TRPSTA		:PREPARE TRANSPARENT STATE
	ELSE

:IF THE INTERFACE SUPPORTS DSP, FINISH LOGON COMMAND CONTAINS THE
:INFORMATION WHAT IS THE NEXT MODE IN ITS SUBCOMMAND.
	LHL	R5,LUCTAB+LUSNDG,R9,	:GET PTR TO NIO->SNA CMD LINK
	LB	R5,CMDBLK+CLCMDS,R5,	:GET SUBCOMMAND
	CHI	R5,NSFNDP		:DSP STATE?
	JNFS	H.RMP3			:JUMP IF NOT
	LHI	R5,DSPSTA		:PREPARE DSP STATE
	JFS	H.RMP4			:JUMP TO CONTINUE
H.RMP3	LHI	R5,LULULU		:SHOW RSP(LUSTAT) PENDING
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC 2ND WORK BYTE
	LHI	R5,TRPSTA		:PREPARE TRANSPARENT STATE
	EI
H.RMP4	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC BYTE
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R0,SNPOSR^8!SNFNLG	:PREPARE +RSP FOR FINISH LOGON
	JAL	R5,L.PTCD,,		:INFORM NIO
:
:BEGIN (03/13/86 YLH)
:	IF THE SYS/RQ KEY IS SUPPORTED, SEND THE TIF WITH THE UNOWNED STATE
:
	IF	HDPSUP
	GL	LUSCRN,H.SNST,LUSFUW
	LB	R0,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE
	JE	H.RMP5			:JUMP IF NO SCREEN CONTROL
	LHI	R5,LUSCRN!LUSFUW	:SET FORCE UNOWNED AND RETAIN SCREEN CONTROL
	LHI	R4,HSTINI		:HOST INITIATED
	JAL	R6,H.SNST		:SEND SCREEN STATUS TO TIF
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	EI
:
:END (03/13/86 YLH)
:
:	(9/18/84/CHS)	DISCARD MUCB FIRST
H.RMP5
	LR	R3,R10			:SET UP R3
	JAL	R4,PBB,,		:REALSE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
:	(9/18/84/CHS) END OF DISCARD MUCB INSERTION

	J	L.RMT0			:REMOVE FINISH LOGON

:	(9/18/84/CHS)	DISCARD MUCB FIRST
H.RMP6
	LR	R3,R10			:SET UP R3
	JAL	R4,PBB,,		:REALSE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14
:	(9/18/84/CHS) END OF DISCARD MUCB INSERTION

:::::::::::::::::::::::::::::
:: REMOVE PROCESSING IN PENDING LOCAL STATE.
:: NOTHING IS ACTUALLY REMOVED FROM NTW->SNA QUEUE IN THIS MODE.
:: IN CASE OF NEGATIVE NOTIFICATION WE TRY TO REPEAT SEND OPERATION
:: IF THIS IS POSSIBLE. IF THE PROBLEM IS INCORRECTABLE WE START
:: TIMEOUT CLEANUP PROCEDURE. CURRENT CODE DOES THE SAME IF THE
:: RQ (RSHUTD) WAS SUCCESSFULLY SENT.
H.RMPL	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE-CHECK BYTE
	JE	H.RMP2			:JUMP IF OK

:BAD SENSE-CHECK. CHECK IF RETRY IS POSSIBLE.
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO MSG BUFFER
	JAL	R5,R.PBBC,,		:RELEASE BUFFERS WITH MSG
	JAL	R5,L.RMCK,,		:CHECK SENSE-CHECK CODE
	LR	R0,R0			:IS RETRY POSSIBLE?
	JE	L.RMT2			:JUMP IF SO

:RETRY IS IMPOSSIBLE. START TIMEOUT FOR CLEANUP.
	LHI	R5,LULUSO		:SET TIMEOUT FOR CLEANUP
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	L.RMT2			:JUMP TO RELEASE BUFFERS

:MESSAGE SUCCESSFULLY SENT.
:IF RSHUTD OR TERM-SELF WAS SENT SET TIMEOUT FOR CLEANUP AND RETURN.
:	(9/18/84/CHS)	DISCARD MUCB FIRST
H.RMP2
	LR	R3,R10			:SET UP R3
	JAL	R4,PBB,,		:REALSE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
:	(9/18/84/CHS) END OF DISCARD MUCB INSERTION

:H.RMP2	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATUS BYTE(9/18/84/CHS)
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATUS BYTE(9/18/84/CHS)
	NHI	R5,LUSBST		:GET SUBSTATE
	JER	R14			:RETURN IF SENDING RSP'S
:	LHI	R5,LULUSO		:SET TIMEOUT FOR CLEANUP
:	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	JR	R14			:AND RETURN
	EI				:END OF REMOVE ROUTINES FOR HOST IF
					:(04/13/87 YLH)
NOBUFR	J	NOBUFF,,		:NO BUFFERS ROUTINE

:	EI				:END OF REMOVE ROUTINES FOR HOST IF
					:(04/13/87 YLH)
	FO	MAIN	
	FO	SNTPKG
	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER

	EM
	MO	.,SNAPKG

	LO	SNTPKG
	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER
	LO	OSCAN			:(01/27/87 YLH)
	LO	MAIN

:::::::::::::::::::::::::::::::::::::::::::::::
:: THIS MODULE CONTAINS A CODE TO SUPPORT RECEIVE SIDE AND
:: SIGNAL PROCESSING FOR LU SEVICE MANAGER.
:::::::::::::::::::::::::::::::::::::::::::::::

	SEG	A.CODE

:::::::::::::::::::::::::::::
:: RECEIVE PROCESS FOR LUSVC.
:
: FIRST FIND THE POINTER TO LUCB (DQE INFORMATION IS NOT
: NECESSARILY VALID IF COMING FROM SNA LOWER LAYERS).
S.LSRV
L.RCV	LHL	R5,PUCPTR,RNODE,RNODE	:GET POINTER TO PUCB
	LHL	R9,PUCTAB+PUCLUC,R5,	:GET PTR TO 1ST LUCB FOR PU
	IF	TERMIF&HOSTIF		:IF BOTH TERM AND HOST IF SYSGENED
	LB	R3,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	EI
	LB	R5,EVBLK+EVISIG,R12,	:GET SIGNAL BYTE
	JN	L.RCSG			:JUMP IF GOT A SIGNAL
	BBLOAD	R10,EVBLK+EVMUPR,R12,	:GET MUCB PTR
	LB	R5,BBUFER+MUDIRE,R10,	:GET MUCB DIRECTION
	CHI	R5,RCV			:RCV?
	JNFS	L.RCVS			:JUMP IF NOT
	IF	TERMIF&HOSTIF		:IF BOTH TERM AND HOST IF SYSGENED
	CHI	R3,PU.T4		:TERMIF?
	JEFS	L.RCVA			:LUCB IND BY ORIG IF SO
	JFS	L.RCVB			:OTHERWISE BY DEST LU
	EI
	IF	TERMIF&(1-HOSTIF)	:IF TERM IF ONLY SYSGENED
	JFS	L.RCVA			:LUCB INDEXED BY ORIG
	EI
	IF	HOSTIF&(1-TERMIF)	:IF HOST IF ONLY SYSGENED
	JFS	L.RCVB			:LUCB INDEXED BY DEST
	EI
L.RCVS	EQ	.			:SEND DIRECTION, NOTIFICATION
	IF	TERMIF&HOSTIF		:IF BOTH TERM AND HOST IF SYSGENED
	CHI	R3,PU.T4		:TERMIF?
	JEFS	L.RCVB			:LUCB IN BY DEST LU IF SO
	JFS	L.RCVA			:OTHERWISE BY ORIG LU
	EI
	IF	TERMIF&(1-HOSTIF)	:IF TERM IF ONLY SYSGENED
	JFS	L.RCVB			:LUCB INDEXED BY DEST
	EI
	IF	HOSTIF&(1-TERMIF)	:IF HOST IF ONLY SYSGENED
	EI				:NOTHING TO DO
L.RCVA	LB	R6,BBUFER+MUOADP,R10,	:LUCB INDEXED BY ORIG LU
	JFS	L.RCVC			:JUMP TO CONTINUE
L.RCVB	LB	R6,BBUFER+MUDADP,R10,	:LUCB INDEXED BY DEST LU
L.RCVC	AH	R6,LUCTAB+LUCT.D,R9,	:REL LU# FOR THE INTERFACE
	LHL	R9,LUCPTR,R6,R6		:GET LUCB POINTER
	THI	R9,LUINV		:IS IT VALID?
	JN	L.NOLU			:JUMP IF NOT

: VECTOR EXECUTION DEPENDING ON LUSVC STATE.
:FOR TEMINAL INTERFACE IN BAD SUBSTATE CLEAN IT IF RECEVED RSP(UNBIND).
L.RCV0	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	LR	R4,R5			:COPY IT
	NHI	R4,LUSBST		:GET SUBSTATE
	SRLS	R5,5			:CLEAN EVERYTHING BUT STATE
	IF	TERMIF&HOSTIF		:IF BOTH TERM & HOST IF SYSGENED
	CHI	R3,PU.T4		:TERMIF?
	JN	L.RCV2			:JUMP IF NOT
	EI
	IF	TERMIF
	CHI	R4,LUBDST		:UNABLE TO CONTINUE?
	JN	L.RCVY			:JUMP IF NOT
	LB	R4,LUCTAB+LULUWK,R9,	:GET LUCB WORK BYTE
	THI	R4,LULUSO		:SC RU OUTSTANDING?
	JE	L.RCV1			:JUMP IF NOT
	LB	R4,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R4,MU.RRI		:RQ OR RSP?
	JE	L.RCV1			:JUMP IF RSP
	NHI	R4,MU.CTG		:GET RU CATEGORY
	CHI	R4,MU.SC		:SESSION CONTROL?
	JN	L.RCV1			:JUMP IF NOT
	BBLOAD	R4,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R4,BBUFER,R4,		:GET RU CODE
	CHI	R4,UNBIND		:UNBIND?
	JN	L.RCV1			:JUMP IF NOT
	JAL	R12,L.CLEA,,		:CLEAN LU
	J	L.RCV1			:JUMP TO CONTINUE
L.RCVY	LHL	R5,L.RCTB,R5,R5		:GET PTR TO PROC ROUTINE
	J	L.BASE,R5,,		:JUMP TO PROC ROUTINE
	EI
	IF	HOSTIF
L.RCV2	CHI	R4,LUBDST		:UNABLE TO CONTINUE?
	JE	L.RCV1			:JUMP IF SO
	LHL	R5,H.RCTB,R5,R5		:GET PTR TO PROC ROUTINE
	J	L.BASE,R5,,		:JUMP TO PROC ROUTINE
	EI

:IF UNABLE TO CONTINUE (BAD SUBSTATE) GET RID OF MESSAGE AND MUCB.
L.RCV1	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MESSAGE(6/19/84/CHS)
	JAL	R5,R.PBRC,,		:RELEASE BUF CHAIN WITH THE MESSAGE
	LR	R3,R10			:NOW POINT TO MUCB
	JAL	R4,PBB,,		:RELEASE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:TABLE OF RECEIVE PROCESSING ROUTINES
	IF	TERMIF
L.RCTB	HC	L.RCTR-L.BASE		:ROUTINE FOR TRANSP MODE
	HC	L.RCLC-L.BASE		:ROUTINE FOR LOCAL MODE
	HC	L.RCPT-L.BASE		:PENDING TRANSPARENT MODE
	HC	L.RCPL-L.BASE		:PENDING LOCAL MODE
	IF	VTISUP			: (01/12/87 YLH)
	HC	L.RCDP-L.BASE		:DSP MOED (01/12/87 YLH)
	EI				: (01/12/87 YLH)
	EI

	IF	HOSTIF
H.RCTB	HC	H.RCTR-L.BASE		:ROUTINE FOR TRANSP MODE
	HC	H.RCLC-L.BASE		:ROUTINE FOR LOCAL MODE
	HC	H.RCPT-L.BASE		:PENDING TRANSPARENT MODE
	HC	H.RCPL-L.BASE		:PENDING LOCAL MODE
	IF	HDPSUP
	HC	H.RCDP-L.BASE		:DSP MODE
	EI
	EI

:RECEIVE PROCESS IN TRANSPARENT MODE.
:ALL MESSAGES ARE PASSED TO SNA->NTW DATA QUEUE.
:FOR UNBIND RSP AND BIND -RSP SCB IS DESTROYED.
:FOR CLEAR THE SEQEUENCE NUMBER ADJUSTMENTS ARE CLEARED.
:IF SUBSTATE IS NORMAL EVERY FMD MESSAGE (FIRST CHAIN ELEMENT) IS
:SCANNED FOR SESSION SCREEN REQUEST PF KEY (IF SYSGEN'ED) OR
:COMMAND WORD DEPENDING ON WHETHER IT IS LU-LU OR SSCP-LU FMD.
:IF DISCOVERED THE SUBSTATE IS CHANGED FOR WAITING FOR LOGON.
:IN WAITING FOR LOGON SUBSTATE WE COUNT ALL NORMAL FLOW REQUESTS
:(IF LOGON IS STARTED THESES MESSAGES ARE DISCARDED BY NIO).
:
:ALL SEGMENTS EXCEPT 1ST ARE PASSED TO NIO WITHOUT ANY PROCESSING
H.RCTR
L.RCTR	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST TH BYTE
	NHI	R5,MU.BIU		:IS IT 1ST SEGMENT?
	JE	L.RCTE			:JUMP IF NOT

:SC CATEGORY MESSAGES ARE PROCESSED SEPARATELY
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET SCB PTR
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	LR	R1,R5			:SAVE IT FOR LATER USE
	NHI	R5,MU.CTG		:GET RU CATEGORY
	CLHI	R5,MU.SC		:IS IT SC?
	JN	L.RCTA			:JUMP IF NOT

:WE HAVE TO DESTROY SCB FOR RSP(UNBIND) AND -RSP(BIND) AND
:PROCESS CLEAR. FIRST CHECK SCB.
:	THI	R7,LUINV		:IS SCB VALID?
:	JN	L.RCTE			:JUMP IF NO SCB
	LR	R7,R7			:TEST SCB POINTER
	JE	L.RCTE			:JUMP IF NO SCB
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET POINTER TO RU
	LB	R5,BBUFER,R5,		:GET RQ CODE
	CHI	R5,CLEAR		:IS IT CLEAR?
	JNFS	L.RCT2			:JUMP IF NOT

:FOR CLEAR CLEAN SEQUENCE ADJUSTMENTS FIELDS IN SCB
L.RCT1	XR	R5,R5			:CLEAR THE REGISTER
	STH	R5,SCBBLK+SCADJR,R7,	:CLEAR SQ # ADJUST FOR RCV
	STH	R5,SCBBLK+SCADJS,R7,	:CLEAR SQ # ADJUST FOR SEND
	J	L.RCTE			:JUMP TO CONTINUE

:FOR BIND IN HOST INTERFACE WE HAVE TO SAVE PRIMARY ADDR IN LUCB.
:FOR BIND AND UNBIND WE HAVE TO PROCESS RESPONSES.
L.RCT2	THI	R1,MU.RRI		:IS IT RQ OR RSP?
	IF	HOSTIF
	JN	L.RCTY			:JUMP IF RSP
	ELSE
	JE	L.RCTE			:JUMP IF RQ
	EI
	IF	TERMIF&HOSTIF
	CHI	R3,PU.T4		:TERM IF?
	JE	L.RCTE			:JUMP IF SO
	EI
	IF	HOSTIF
	CHI	R5,BIND			:IS IT BIND?
:	JN	L.RCTE			:JUMP IF NOT (11/20/86 YLH)
	JN	L.RCTC			:JUMP IF NOT (11/20/86 YLH)
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGINATION ADDR
	STB	R5,LUCTAB+LUPRIL,R9,	:SAVE IT IN LUCB
	J	L.RCTE			:JUMP TO CONTINUE
:
:BEGIN (11/20/86 YLH)
:IF UNBIND INDICATES THAT BIND IS NOT FORTHCOMING, THEN PASS AN
:ERROR COMMAND TO THE NIO TO BREAK THE CIRCUIT.
:
L.RCTC
	IF	UNBNDS			:UNBIND REASON CODE IS MEANINGFUL
	CLHI	R5,UNBIND		:IS IT UNBIND?
	JN	L.RCTE			:JUMP IF NOT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R1,BBUFER,R5,		:GET RQ CODE
	LB	R5,BBUFER+1,R5,		:GET UNBIND TYPE
	LB	R4,UBNTBL,,		:THE # OF REASON CODES IS USED
	JE	L.RCTF			:AS A REPEAT COUNTER
L.RCTD	CLB	R5,UBNTBL,R4,		:IS THE REASON CODE MATCHED?
	JE	L.RCTE			:JUMP IF SO
	SIS	R4,1			:END OF THE TABLE REACHED?
	JGBS	L.RCTD			:NO, CONTINUE TO COMPARE
L.RCTF	LHI	R0,SNERR^8!SNERPO	:YES, NOTIFY NIO TO BREAK CIRCUIT
	JAL	R5,L.PTCD,,		:PASS CMD TO NIO
	J	H.RDS2,,		:CREATE RSP AND SEND IT
	EI (UNBNDS)
:
:END (11/20/86 YLH)
:
	EI
L.RCTY	CHI	R5,UNBIND		:IS IT UNBIND?
	JE	L.RCT3			:JUMP IF NOT
	CHI	R5,BIND			:IS IT BIND?
	JN	L.RCTE			:JUMP IF NOT
	THI	R1,MU.SDI		:IS IT -RSP(BIND)
	JE	L.RCT1			:JUMP IF +RSP(BIND)

:FOR RSP(UNBIND) AND -RSP(BIND) DESTROY SCB.
L.RCT3	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET SCB POINTER
:	THI	R7,LUINV		:IS IT VALID?
:	JN	L.RCTE			:JUMP IF NOT
	JE	L.RCTX			:JUMP IF INVALID
:	LCS	R5,1			:PREPARE -1
	XR	R5,R5			:CLEAR THE REGISTER
	BBSSCB	R5,LUCTAB+LULSCB,R9,	:SHOW NO SCB FOR LU-LU
	STM	R0,LURGSV,,		:SAVE REGISTERS
	LR	R9,R7			:COPY SCB POINTER
	JAL	R8,V.SCDS,,		:DISCARD SCB
	LM	R0,LURGSV,,		:RESTORE REGISTERS

:IF UNBIND WAS GENERATED BEFORE DISCARD RSP(UNBIND).
L.RCTX	LB	R5,LUCTAB+LULUW1,R9,	:GET LUSVC 2ND WORK BYTE
	THI	R5,LULUUB		:UNBIND GENERATED?
	JE	L.RCTE			:JUMP IF NOT
	NHI	R5,@LULUUB		:CLEAR UNBIND INDICATOR
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC 2ND WORK BYTE
	J	L.RCV1			:JUMP TO DISCARD RSP(UNBIND)

:FOR FMD AND DFC CATEGORY LU-LU NORMAL FLOW REPONSES SEQUENCE
:NUMBERS MUST BE ADJUSTED FOR THE NUMBER OF MESSAGES
:GENERATED OR DISCARDED IN LOCAL MODE.
L.RCTA	EQ	.
	IF	TERMIF&HOSTIF		:IF BOTH TERM & HOST IF SYSGENED
	CHI	R3,PU.T4		:TERMIF?
	JEFS	L.RCTT			:JUMP IF SO
	EI
	IF	HOSTIF
	THI	R1,MU.RRI		:IS IT RQ OR RSP?
	JE	L.RCTE			:JUMP IF SO
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGINATION ADDR
	JE	L.RCTJ			:JUMP IF SSCP-LU
	EI
	IF	TERMIF&HOSTIF		:IF BOTH TERM & HOST SYSGENED
	JFS	L.RCTU			:JUMP TO CONTINUE
	EI
	IF	TERMIF	
L.RCTT	THI	R1,MU.RRI		:IS IT RQ OR RSP?
	JE	L.RCT4			:JUMP TO SCAN
	LB	R5,BBUFER+MUDADP,R10,	:GET DESTINATION ADDR
	JE	L.RCTE			:JUMP IF SSCP-LU
	EI
L.RCTU	LB	R5,BBUFER+MUBIUF,R10,	:GET FIRST BYTE OF TH
	NHI	R5,MU.EFI		:IS IT EXPEDITED FLOW
	JN	L.RCTE			:JUMP IF SO
	LH	R5,SCBBLK+SCADJS,R7,	:GET SEQ # ADJUSTMENT
	AHM	R5,BBUFER+MUSNF,R10,	:ADJUST MUCB SEQ #
	J	L.RCTE			:JUMP TO CONTINUE

:FOR HOST INTERFACE DISCARD 1ST RSP(LUSTAT) OR RSP(FMD) ON SSCP-LU SESSION.
:THIS MUST BE RSP FOR LUSTAT GENERATED BY HOST INTERFACE IN
:PENDING TRANSPARENT MODE TO SOLICIT BANNER MESSAGE.
	IF	HOSTIF
L.RCTJ	LB	R5,LUCTAB+LULUW1,R9,	:GET LUSVC 2ND WORK BYTE
	THI	R5,LULULU		:RSP(LUSTAT) PENDING?
	JE	L.RCTE			:JUMP IF NOT
:	BBLOAD	R4,BBUFER+MURUPT,R10,	:GET RU POINTER
:	LB	R4,BBUFER,R4,		:GET RU CODE
:	CHI	R4,LUSTAT		:LUSTAT?
:	JN	L.RCTE			:JUMP IF NOT
	NHI	R5,@LULULU		:CLEAR RSP(LUSTAT) PENDING IND
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC 2ND WORK BYTE
	J	H.RCL1			:JUMP TO DISCARD MSG&MUCB
	EI

:FOR TERMINAL INTERFACE FMD RQ'S MUST BE SCANNED OR COUNTED
:DEPENDING ON LU.SVC SUBSTATE.
	IF	TERMIF
L.RCT4	LB	R4,LUCTAB+LULUST,R9,	:GET LU.SVC STATE BYTE
	NHI	R4,LUSBST		:GET SUBSTATE
	JN	L.RCT9			:JUMP IF WAITING FOR START LGN

:ONLY FMD'S WHICH ARE FIRST ELEMENT OF THE CHAIN ARE SCANNED.
	CLHI	R5,MU.FMD		:IS IT FMD CATEGORY?
	JN	L.RCTE			:JUMP IF NOT
	THI	R1,MU.BCI		:IS IT THE BEGINNING OF CHAIN?
	JE	L.RCTE			:JUMP IF NOT

:PREPRARE POINTERS FOR SCANNING DATAT MESSAGE FOR SERVICE SCREEN
:REQUEST.
	LHL	R6,LUCTAB+LUCT.N,R9,	:GET REL LU # FOR INTERFACE
	LHI	R4,NSMLEN		:GET LENGTH OF SCAN PTR TBL
	MR	R5,R4			:PTR TO NSMTBL IN R6
	BBLOAD	R4,BBUFER+MURUPT,R10,	:GET RU PTR

:SCANNING CRITERIA DEPEND ON WHETHER IT IS LU-LU OR SSCP-LU
	LB	R5,BBUFER+MUDADP,R10,	:GET DESTINATION ADDR
	JEFS	L.RCT5			:JUMP IF SSCP-LU

:FOR LU-LU AID MUST BE DESIGNATED PF KEY.
	LB	R5,BBUFER,R4,		:GET AID
	CLB	R5,NSMTBL+NSMKEY,R6,	:IS IT THE RIGHT PF KEY
	JE	L.RCT7			:JUMP IF SO
	J	L.RCTE			:OTHERWISE JUMP TO CONTINUE

:FOR SSCP-LU SERVICE SCREEN REQUEST IS A COMMAND WORD.
:THE STRUCTURE OF THE SYSGENED COMMAND WORD FIELD IS:
:1ST BYTE - LENGTH OF COMMAND WORD, THEN COMMAND WORD ITSELF (EBCDIC).
L.RCT5

:	(5/12/86/CHS)
:	IF	LU-LU SESSION EXISTS, IGNORE NETWORK SERVICE SCREEN REQUEST
:	THIS LIMITATION WILL BE DELETED, IF ....
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:DO WE HAVE LU-LU SCB?
	JN	L.RCTE			:YES, DONT SCAN KEYWORD
:	(5/12/86/CHS)

	LHL	R7,NSMTBL+NSMKAE,R6,	:GET TYPE CMD STRING
	LHL	R6,NSMTBL+NSMKWD,R6,	:GET PTR TO COMMAND STRING
	LHL	R5,PSEG,R6,		:GET COMMAND WORD LENGTH
L.RCT6	LB	R0,PSEG+1,R6,R5		:GET NEXT BYTE (FROM END)
	LB	R1,BBUFER-1,R4,R5	:GET IT FROM MSG
	LR	R7,R7			:IF NOT ASCII, NO CONVERSION
	JNFS	L.RCTW			:SKIP
	LB	R1,BCDASC,R1,		:CONVERT TO ASCII
L.RCTW
	XR	R0,R1			:COMPARE THEM
	NHI	R0,5F			:MASK UPPER-LOWER CASE AND PARITY
	JN	L.RCTE			:JUMP IF NO MATCH
	SIS	R5,1			:OTHERWISE CONTINUE
	JG	L.RCT6			::TO LOOP UNTIL BEGINNING

:REQUEST FOR SERVICE SCREEN WAS FOUND. NOTIFY NIO, GO TO
:WAITING FOR START LOGON SUBSTATE AND START COUNTING NORMAL
:FLOW LU-LU REQUESTS.
L.RCT7	BBLSCB	R7,LUCTAB+LULSCB,R9,	:DO WE HAVE LU-LU SCB
:	THI	R7,LUINV		:CHECK IF VALID?
:	JNFS	L.RCT8			:NOTHING TO COUNT IF NOT
	JEFS	L.RCT8			:NOTHING TO COUNT IF INVALID
	LCS	R5,1			:1 RQ COULD BE DISCARDED
	STH	R5,SCBBLK+SCLUWK,R7,	:INIT TEMP COUNTER TO -1
L.RCT8	LHI	R5,TRPSTA^8!LUTRLG	:GO TO WAITING FOR START
	STB	R5,LUCTAB+LULUST,R9,	:LOGON SUBSTATE
	LHI	R0,SNRQLG^8		:PREPARE REQUEST LOGON CMD
	JAL	R5,L.PTCD,,		:SHIP IT TO NIO
	J	L.RCTE			:JUMP TO CONTINUE

:IN WAITING FOR START LOGON SUBSTATE WE HAVE TO COUNT NORMAL
:FLOW LU-LU RU'S.
L.RCT9	LB	R5,BBUFER+MUDADP,R10,	:GET DESTINATION ADDR
	JEFS	L.RCTE			:JUMP IF SSCP-LU
	LB	R5,BBUFER+MUBIUF,R10,	:GET FIRST BYTE OF TH
	NHI	R5,MU.EFI		:IS IT NORMAL FLOW
	JNFS	L.RCTE			:JUMP IF NOT
	LCS	R5,1			:ONE MORE MESSAGE DISCARDED
	AHM	R5,SCBBLK+SCLUWK,R7,	:ADJUST TEMP COUNTER
	EI				:END OF LOGIC FOR TERM IF ONLY

:PASS THE MESSAGE TO NIO.
L.RCTE	LB	R1,BBUFER+MUBIUF,R10,	:GET FIRST BYTE OF TH
	LR	R0,R1			:COPY IT
	SRLS	R0,2			:SHIFT SEGMENTATION INFO
	NHI	R0,SNDTIS		:CLEAR EVRYTHING ELSE
	IF	TERMIF&HOSTIF		:IF BOTH TERM & HOST IF SYSGENED
	LB	R3,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R3,PU.T4		:TERMIF?
	JNFS	L.RCTH			:JUMP IF NOT
	EI
	IF	TERMIF
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	NHI	R5,LUSBST		:LEAVE SUBSTATE ONLY
	JEFS	L.RCTH			:JUMP IF NOT WAITING START LOGON
	XHI	R0,SNINTM^8!SNDTIS	:PREPARE INTERNAL CMD TO NTW
	JFS	L.RCTK			:JUMP TO CONTINUE
	EI
L.RCTH	XHI	R0,SNETEM^8!SNDTIS	:PREPARE END-TO-END CMD TO NTW
L.RCTK	AHI	R1,10			:FID IS 0 - 5 NOW
	LBR	R1,R1			:CLEAR OVERFLOW
	SRLS	R1,4			:EVRYTHIG BUT FID IS CLEARED
	LB	R2,FIDLGT,R1,		:GET TH LENGTH FOR THE FID
	AH	R2,BBUFER+MUDCF,R10,	:LENGTH OF PIU
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:POINT TO THE MESSAGE BUFFER
	JAL	R5,L.PTCD,,		:SHIP CMD TO NTW
	LR	R3,R10			:COPY MUCB POINTER
	JAL	R4,PBB,,		:RELEASE MUCB
	JAL	R4,R.PBB,,		:COUNT THE BUFFERLET
	JR	R14			:AND RETURN

::::::::::::::::::::::::::
:: RECEIVE ROUTINES FOR TERMINAL INTERFACE IN LOCAL AND PENDING MODES.
::
::::::::::::::::::::::::::
:: RECEIVE PROCESS IN LOCAL MODE
:
::
:: TERMINAL INTERFACE
::
:: ONLY ONE ELEMENT ONE SEGMENT CHAINS ARE PASSED TO NIO AS VALID
:  LU-LU FMD'S FROM THE TERMINAL. THE REST WILL BE DISCARDED AND
:  ERROR CMD WITH REDISPLAY SUBCOMMAND IS PASSED TO NIO.
:  ALL FMD'S ARE REPONDED WITH +RSP AS APPROPRIATE EXCEPT WHEN
:  NO CD IS SPECIFIED (IN THIS CASE -RSP IS SENT).
:
:  SSCP-LU FDM'S ARE DISCARDED, REPLYED WITH +RSP AND DATA MESSAGE
:  "RETURN TO LU-LU SCREEN" IS ISSUED.
:
:  LUSTAT FOR SSCP-LU IS REPLYED WITH +RSP AND DISCARDED
:
:  LUSTAT FOR LU-LU WILL BE DISCARDED AND CAUSE ERROR CMD PASSED
:  TO NIO. SUBCOMMAND COULD BE REDISLAY OR UNABLE TO CONTINUE
:  DEPENDING ON SENSE CODE IN LUSTAT.

:  +RSP WILL BE DISCARDED (CLEARS WAIT FOR LU-LU SEND PROCESS)
:
:  -RSP WILL BE DISCARDED AND FOR LU-LU CAUSES ERROR CMD TO BE ISSUED
:  TO NIO. SUBCOMMAND COULD BE REDISPLAY OR UNABLE TO CONTINUE
:  DEPENDING ON THE SENSE CODE IN -RSP.
:
:::::::::::::::::::::
:
:FIRST SEPARATE TERMINAL MESSAGES FROM NOTIFICATIONS FOR PREVIOUSLY
:GENERATED REQUESTS AND RESPONSES.
	IF	TERMIF
L.RCLC	LB	R5,BBUFER+MUDIRE,R10,	:GET MU DIRECTION
	CHI	R5,SENT			:IS IT NOTIFICATION?
	JE	L.RCNT			:JUMP IF SO

:IF A MULTISEGMENT MESSAGE RECEIVED WE ASSUME THAT IT IS PART OF
:FMD. ALL SEGMENTS EXCEPT FIRST ARE ALWAYS DISCARDED. THE RECEPTION
:OF THE LAST SEGMENT MAY REQUIRE SENDING BACK A REPSONSE (AS
:INDICATED IN FIRST SEGMENT AND REFLECTED IN LUSVC WORK BYTE
:BY PENDING REPSONSE BITS).
:
:FIRST CHECK IF IT WAS THE 1ST SEGMENT.
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.BIU		:IS IT 1ST SEGMENT?
	JN	L.RCL6			:JUMP IF SO

:NOT THE FIRST SEGMENT. IF IT IS ALSO NOT THE LAST SIMPLY
:GET RID OF THE SEGMENT AND MUCB.
	THI	R5,MU.EIU		:IS IT THE LAST SEGMENT?
	JN	L.RCL2			:JUMP IF SO
L.RCL1	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG SEGMENT
	JAL	R5,R.PBRC,,		:RELEASE BUF CHAIN
	LR	R3,R10			:COPY PTR TO MUCB
	JAL	R4,PBB,,		:RELEASE BUF WITH MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:LAST SEGMENT BUT NOT THE FIRST SEGMENT. CHECK IF THE REPONSE IS
:PENDING AND ISSUE IT IF NECESSARY. SEGMENT ITSELF IS DISCARDED.
L.RCL2	LB	R5,BBUFER+MUDADP,R10,	:GET DESTINATION ADDR
	JE	L.RCL3			:FOR SSCP-LU ALWAYS +RSP
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULURP		:IS REPONSE PENDING?
	JE	L.RCL1			:DISCARD SEG AND MUCB IF NOT
	LR	R1,R5			:COPY LUSVC WORK BYTE
	NHI	R1,@LULURP&@LULUNG	:CLEAR PEND RSP BITS
	STB	R1,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	XR	R0,R0			:CLEAR THE REGISTER
	STB	R0,BBUFER+MURHF1,R10,	:CLEAR 1ST BYTE OF RH
	LHI	R0,MU.DR1		:INDICATE DR1
	STB	R0,BBUFER+MURHF2,R10,	:UPDATE 2ND BYTE OF RH
L.RCLA	THI	R5,LULUNG		:IS PENDING RSP NEGATIVE?
	JEFS	L.RCL3			:JUMP IF NOT
	LHI	R0,LUCDSN		:PREPARE SENSE CODE
	JFS	L.RCL4			:JUMP TO CONTINUE
L.RCL3	XR	R0,R0			:NO SENSE CODE FOR +RSP
L.RCL4	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG SEGMENT
	JAL	R5,R.PBRC,,		:RELEASE BUF WITH MSG SEG
	J	L.RCF9			:KEEP MUCB FOR RSP

:FIRST SEGMENT OF A MESSAGE. EXAMINE RH AND VECTOR EXECUTION
:DEPENDING ON RU CATEGORY.
L.RCL6	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,MU.CTG		:GET RU CATEGORY
	SRLS	R5,4			:MAKE A HALF-WORD INDEX
	LHL	R5,L.RCLT,R5		:GET PTR TO PROCESSING ROUTINE
	J	L.BASE,R5,,		:VECTOR EXECUTION

:TABLE OF PROCESSING ROUTINES DEPENDING ON RU CATEGORY
L.RCLT	HC	L.RCFM-L.BASE		:PTR TO FMD PROC ROUTINE
	HC	L.RCNC-L.BASE		:PTR TO NC PROC ROUTINE
	HC	L.RCDF-L.BASE		:PTR TO DFC PROC ROUTINE
	HC	L.RCSC-L.BASE		:PTR TO SC PROC ROUTINE

:PROCESSING ROUTINE FOR THE 1ST SEGMENTS OF FMD'S.
:
:FIRST SEPARATE REQUESTS AND RESPONSES.
L.RCFM	LB	R1,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R1,MU.RRI		:IS IT A REPONSE?
	JN	L.RCRP			:JUMP IF SO

:THIS IS A REQUEST. IF IT CAME ON SSCP-LU SESSION DISCARD IT.
:IF IT IS THE LAST SEGMENT OF SSCP-LU RQ GENERATE +RSP.
	THI	R1,MU.ECI		:END OF CHAIN?
:	JE	H.RCL1			:JUMP IF NOT(12/04/85/CHS)
	JE	L.RCL1			:JUMP IF NOT(12/04/85/CHS)
	LB	R5,BBUFER+MUDADP,R10,	:GET DEST ADDR
	JNFS	L.RCF2			:JUMP IF LU-LU MSG
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:IS IT THE LAST SEGMENT?
	JE	L.RCL1			:DISCARD MSG&MUCB IF NOT
	J	L.RCL3			:DISC MSG&GEN +RSP IF SO

:THIS IS THE 1ST SEGMENT OF LU-LU FMD RU CHAIN. ADJUST SEQUENCE
:NUMBER IN RECEIVE DIRECTION (IF IT IS NOT DISCARDED IN THIS
:MODULE NIO WILL DISCARD IT ANYWAY).
L.RCF2	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB PTR
	LCS	R5,1			:PREPARE -1
	AHM	R5,SCBBLK+SCADJR,R7,	:UPDATE ADJUSTMENT TO SEQ #

:IF IT IS NOT THE LAST ELEMENT OF CHAIN WE CAN DISCARD IT (WE DO
:NOT CARE ABOUT THE TYPE OF REPONSE SPECIFIED BECAUSE IT COULD
:BE ONLY ERI AND ALL VALID ENTRIES FROM THE TERMINAL OPRATOR
:DURING LOGON ARE ONE ELEMENT CHAINS).
	THI	R1,MU.ECI		:IS IT END OF CHAIN?
	JE	L.RCL1			:DISCARD MSG&MUCB IF NOT

:THIS IS THE LAST ELEMENT OF THE CHAIN.
:PREPARE RESPONSE TYPE (IF ANY). NEGATIVE RESPONSE IF CD IS
:NOT SPECIFIED. +RSP IF THIS IS DEFINITE RESPONSE CHAIN.
:THE RESPONSE TYPE IS PREPARED IN R4.
	XR	R4,R4			:START WITH NO RESPONSE
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	THI	R5,MU.CDI		:DOES IT HAVE CDI?
	JNFS	L.RCF3			:JUMP IF SO
	LIS	R4,LULURP!LULUNG	:PREPARE FOR NEGATIVE RSP
	J	L.RCFB			:JUMP TO CONTINUE
L.RCF3	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R5,MU.DR1!MU.DR2	:IS IT DEFIN RSP CHAIN?
	JEFS	L.RCF4			:JUMP IF NOT
	THI	R5,MU.ERI		:EXP RSP CHAIN?
	JNFS	L.RCF4			:JUMP IF SO
	LIS	R4,LULURP		:PREPARE FOR +RSP

:IF THIS THIS LAST CHAIN ELEMENT IS NOT THE FIRST ONE, SEND ERROR
:CMD TO NIO WITH REDISPLAY SUBCOMMAND. DISCARD THE MESSAGE.
:ALSO IF THIS IS THE LAST SEGMENT REPLY IMMEDIATELY WITH THE
:TYPE OF REPONSE DETERMINED BY PREVIOUS LOGIC. IF NOT THE
:LAST SEGMENT INDICATE PENDING RESPONSE IN LUSVC WORK BYTE.
L.RCF4	THI	R1,MU.BCI		:IS IT 1ST CHAIN ELEMENT?
	JN	L.RCF6			:JUMP IF SO
L.RCFA	LHI	R0,SNERR^8!SNERRD	:PREPARE ERR CMD WITH REDISP
	JAL	R5,L.PTCD,,		:SHIP IT TO NIO
L.RCFB	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:IS IT THE LAST SEGMENT?
	JNFS	L.RCF5			:REPLY IF SO
	LB	R5,LUCTAB+LULUWK,R9,	:OTHERWISE GET LUSVC WORK BT
	NHI	R5,@LULURP&@LULUNG	:CLEAR PENDING RSP BITS
	OR	R5,R4			:SET NEW PENDING RSP BITS
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE PENDING REPONSES
	J	L.RCL1			:DISCARD THE MESSG&MUCB
L.RCF5	LR	R5,R4			:FOR LAST SEGMENT CHECK REPLY
	JE	L.RCL1			:DISCARD MSG&MUCB IF NO RSP
	J	L.RCLA			:GO AND SEND REPONSE IF NEEDED

:TREAT ONE RU MULTISEGMENT THE SAME WAY AS MULTIELEMENT CHAIN.
L.RCF6	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:IS IT THE LAST SEGMENT?
	JE	L.RCFA			:JUMP IF NOT

:ONE RU CHAINS CONSISTING OF ONE SEGMENT ARE PASSED TO NIO
:AS INTERNAL MESSAGE. IN LOGON MODE IT WILL BE ANALIZED AND
:DISCARDED THERE.
	LHI	R0,SNINTM^8		:PREPARE ONE-SEG INTERNAL MSG CMD
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG BUFFER
	AHI	R5,10			:MAKE FID F-4 -> 0-5
	LBR	R5,R5			:CLEAR OVERFLOW
	SRLS	R5,4			:MAKE INDEX TO LENGTH TABLE
	LB	R2,FIDLGT,R5,		:GET TH LENGTH
	AH	R2,BBUFER+MUDCF,R10,	:OVERALL LENGTH OF MSG
	LR	R8,R4			:SAVE THE REGISTER
	JAL	R5,L.PTCD,,		:SHIP CMD TO NIO

:IF NO RESPONSE IS NEEDED DISCARD MUCB.
	LR	R5,R8			:ANY RESPONSE NEEDED?
	JNFS	L.RCF7			:JUMP IF SO
	LR	R3,R10			:OTHERWISE COPY MUCB POINTER
	JAL	R4,PBB,,		:RELEASE MUCB BUFFER
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:GENERATE SENSE CODE IN R0 (0 FOR +RSP).
:R5 CONTINS THE FORM OF REPONSE INFORMATION.
L.RCF7	THI	R5,LULUNG		:IS IT -RSP?
	JEFS	L.RCF8			:JUMP IF NOT
	LHI	R0,LUCDSN		:GENERATE "CHGE DIR" SENSE CD
	JFS	L.RCF9			:JUMP TO CONTINUE
L.RCF8	XR	R0,R0			:PREPARE 0 SENSE CODE

:GENERATE RESPONSE AND SEND IT TO DFC.SEND.
L.RCF9	JAL	R5,L.GNRP,,		:GENERATE RESPONSE
L.RCFY	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND THE RESPONSE
	JR	R14			:AND RETURN

::::::::::::::::::::::::::
: FMD RESPONSE RECEIVED IN LOCAL MODE.
:
: DISCARD RSP IF SSCP-LU SESSION.
: FOR LU-LU SESSION +RSP CLEAR WAIT INDICATOR IN LU STATE BYTE
: AND NOTIFY NIO IF SCREEN FINISHED.
: FOR -RSP NOTIFY NIO WHETHER IT IS POSSIBLE TO CONTINUE (DEPENDING
: ON SENSE CODE) AND GO EITHER TO CLEAN OR UNABLE TO CONTINUE STATE.
: ALSO IN CASE OF "LU BUSY" SENSE CODE, GENERATE SSCP-LU MSG
: TO TERMINAL OPERATOR WITH REQUEST TO RETURN TO LU-LU SCREEN.
L.RCRP	LB	R5,BBUFER+MUDADP,R10,	:GET DESTINATION ADDR
	JE	L.RCL1			:DISCARD RSP&MUCB IF SSCP-LU
	LB	R5,BBUFER+MURHF2,R10,	:GET 2ND BYTE OF RH
	THI	R5,MU.RTI		:IS IT +RSP?
	JN	L.RCR2			:JUMP IF -RSP

:+RSP FOR LU-LU RQ. RESET WAIT STATE. IF LUSVC SEND SUBSTATE IS 2
: (SCREEN FINISHED) NOTIFY NIO.
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	THI	R5,WAITRS		:IS WAIT IND ON?
	JE	L.RCL1			:JMP IF NT (SHLD NOT HPPN,IGN)
	THI	R5,LULCLB		:LST CHAIN (MST BE SBSTATE 2)?
	JEFS	L.RCR1			:JUMP IF NOT
	LHI	R0,SNPOSR^8!SNSCRN	:NOTIFY NIO SCREEN FINISHED
	JAL	R5,L.PTCD,,		:SHIP CMD TO NIO
L.RCR1	LHI	R5,LOCSTA		:CLEAR ALL BUT STATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE STATE BYTE
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSG&@LULUCD	:CLEAR ALL SEND PENDING IND
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	L.RCL1			:GO DISCARD RSP&MUCB

:NEGATIVE RESPONSE FOR FMD WAS RECEIVED IN LOCAL MODE.
:FIRST CHECK IF WE CAN CONTINUE LOCAL MODE (DEPENDS ON SENSE CODE).
L.RCR2	JAL	R5,L.RCCK,,		:CHECK SENSE CODE
	LR	R0,R0			:CAN WE CONTINUE?
	JNFS	L.RCR3			:JUMP IF NOT

:WE CAN TRY TO REPEAT SEND OPERATION. GO INTO CLEAN MODE AND
:NOTIFY NIO.
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	NHI	R5,@WAITRS		:CLEAR WAIT INDICATOR
	OHI	R5,LULCCL		:INDICATE CLEAN MODE
	LHI	R0,SNERR^8!SNERRD	:PREPARE ERR WITH REDISPL CMD
	JFS	L.RCR4			:JUMP TO CONTINUE

:UNABLE TO CONTINUE BECAUSE OF SENSE CODE WHICH CAME FROM THE TERMINAL.
:GO INTO BAD SUBSTATE AND NOTIFY NIO.
L.RCR3	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:CLEAR LUSVC WORK BYTE
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUBDST		:GO INTO BAD SUBSTATE
	LHI	R0,SNERR^8!SNERST	:TERM STATE DOES NOT ALLOW CONT

:UPDATE LUSVC STATE AND SEND CMD TO NIO
L.RCR4	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE
	LB	R2,BBUFER+MURHSN,R10,	:GET 1ST BYTE OF SENSE CODE
	EXBR	R2,R2			:PUT IT IN 2ND BYTE OF REG
	LB	R5,BBUFER+MURHSN+1,R10,	:GET 2ND BYTE OF SENSE CODE
	OR	R2,R5			:PUT IT IN R2
	JAL	R5,L.PTCD,,		:SHIP CMD TO NIO

:RELEASE BUFFERLETS WITH SNA MESSAGE
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO THE MSG
	JAL	R5,R.PBRC,,		:RELEASE IT

:IF SENSE CODE IS NOT "LU BUSY" RELEASE ALSO MUCB
	LB	R5,BBUFER+MURHSN,R10,	:GET 1ST BYTE OF SENSE CODE
	LB	R6,BBUFER+MURHSN+1,R10,	:GET 2ND BYTE OF SENSE CODE
	EXBR	R5,R5			:SHIFT 1ST BYTE IN RIGTHT PL
	OR	R5,R6			:FORM SENSE CODE
	CHI	R5,LUBYSN		:IS IT "LU BUSY"?
	JEFS	L.RCR5			:JUMP IF NOT
	LR	R3,R10			:COPY POINTER TO MUCB
	JAL	R4,PBB,,		:RELEASE BUF WITH MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:"LU BUSY" WAS RECEIVED IN RESPONSE FOR LOGON SCREEN.
:IT MEANS THAT TERMINAL SCREEN IS OWNED BY SSCP-LU SESSION.
:DISPLAY "RETURN TO LU-LU SCREEN" MESSAGE IF WE CAN SEND ON SSCP-LU.
L.RCR5
	LHL	R8,LUGBMG,,		:ASSUME ENGLISH VERSION
	LB	R5,LUCTAB+LUCDIF,R9,	:SEE IF KATAKANA AND KANJI
	NHI	R5,07			:...
	CLHI	R5,4			:KATAKANA = 4, KANJI =5
	JLFS	L.RCRY			:ENGLISH VERSION, SKIP
	LHL	R8,LUGBMG+2,,		:ELSE, JAPANESE VERSION
L.RCRY
	AI	R8,PSEG
	LHL	R1,0,R8			:GET MSG LENGTH
	AIS	R8,2			:R8 = ADDR OF "GO BACK" MSG
L.RCR6	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:POINT TO SSCP-LU SCB
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX_FF STATE
	CHI	R5,FS.ST3		:STATE 3?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST6		:STATE 6?
	JER	R14			:CANNOT SEND, RETURN
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JER	R14			:RETURN IF SO
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:RETURN IF SO
	JAL	R5,L.GNMG,,		:GENERATE SSCP-LU MSG
	LHI	R2,DFCSND		:PREPARE TO SEND TO DFC.SEND
	LHI	R1,LURCV		:ORIGINATOR LU.RCV
	LIS	R0,SG.NOS		:NO SIGNALS
	JAL	R8,SEND,,		:SEND IT
	JR	R14			:AND RETURN

::::::::::::::::::::
:: RECEIVED MESSAGE OF NC CATEGORY. SERIOUS DESIGN PROBLEM.
L.RCPC
L.RCQC
L.RCNC	JAL	R10,CRASH,,
	HC	0
	BC	4*R5,CR.IMG

::::::::::::::::::::
:: RECEIVED MSG OF DFC CATEGORY IN LOCAL MODE.
:: FIRST DETERMINE MSG TYPE AND VECTOR THE EXECUTION.
L.RCDF	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R0,BBUFER,R5,		:GET RQ CODE
	JAL	R5,L.DFCT,,		:DETERMINE DFC TYPE
	LHL	R5,L.DFTB,R6,R6		:GET PTR TO PROCESSING ROUTINE
	J	L.BASE,R5,,		:JUMP TO PROCESSING ROUTINE

:TABLE OF POINTER OF DFC PROCESSING ROUTINES.
L.DFTB	HC	L.LUST-L.BASE		:LUSTAT PROCESSING ROUTINE
	HC	L.RTR-L.BASE		:RTR PROCESSING ROUTINE
	HC	L.BIS-L.BASE		:BIS PROCESSING ROUTINE
	HC	L.SBI-L.BASE		:SBI PROCESSING ROUTINE
	HC	L.QEC-L.BASE		:QEC PROCESSING ROUTINE
	HC	L.QC-L.BASE		:QC PROCESSING ROUTINE
	HC	L.RELQ-L.BASE		:RELQ PROCESSING ROUTINE
	HC	L.CANC-L.BASE		:CANCEL PROCESSING ROUTINE
	HC	L.CHAS-L.BASE		:CHASE PROCESSING ROUTINE
	HC	L.SHUD-L.BASE		:SHUTD PROCESSING ROUTINE
	HC	L.SHUC-L.BASE		:SHUTC PROCESSING ROUTINE
	HC	L.RSHT-L.BASE		:RSHUTD PROCESSING ROUTINE
	HC	L.BID-L.BASE		:BID PROCESSING ROUTINE
	HC	L.SIG-L.BASE		:SIG PROCESSING ROUTINE
	HC	L.INV-L.BASE		:INVALID DFC CODE ROUTINE

:SOME OF DFC CODES ARE INVALID BECAUSE OF DIRECTION OR THEY ARE NOT
:SUPPORTED FOR LU TYPE 2.
L.SBI
L.BIS
L.QEC
L.QC
L.RELQ

:SOME OF DFC CODES ARE NOT USED BY CURRENT LU SERVICE MANAGER AND
:RESONSES FOR THESE MESSAGES CANNOT BE RECEIVED FROM THE TERMINAL.
L.SHUD
L.SHUC
L.BID
L.INV	EQ	.
	LR	R5,R10			:SAVE POINTER TO MUCB
	JAL	R10,CRASH,,		:CRASH
	HC	0
	BC	4*R5,CR.IMG		:INVALID MESSAGE CRASH CODE

	EI

:CHASE PROCESSING ROUTINE.
:SEND +RSP FOR ALL OUTSTANDING LU-LU RQ'S.
:SCAN CORRELATION TABLE.
:IF CORRELATION TABLE IS EMPTY SEND +RSP(CHASE).
	IF	TERMIF!(HOSTIF&HDPSUP)
H.CHAD
L.CHAS	ST	R10,LURGS1,,		:SAVE MUCB POINTER
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET PTR TO LU-LU SCB
	LHL	R8,SCBBLK+SCTRNG,R7,	:GET GET PTR TO CT TABLE
:L.CHA0	CH	R8,SCBBLK+SCTRNR,R7,	:IS CT TABLE EMPTY?
L.CHA0	LHL	R5,SCBBLK+SCTRNR,R7,	:GET RELEASE PTR
	CR	R8,R5			:COMPARE POINTERS
	JN	L.CHA1			:JUMP IF NOT

:CORRELATION TABLE WAS SCANNED TO THE END. SEND +RSP(CHASE).
	L	R10,LURGS1,,		:GET POINTER TO CHASE MUCB
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO CHASE BTU
	JAL	R5,R.PBRC,,		:RELEASE BBUFER WITH CHASE RU
	XR	R0,R0			:INDICATE +RSP
	LHI	R1,CHASE		:RQ CODE CHASE
	JAL	R5,L.GNRP,,		:GENERATE RSP
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LHI	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND THE MESSAGE
	JR	R14			:AND RETURN

:GENERATE +RSP FOR LU-LU DFC OR FMD RQ.
:THIS IS DONE BY L.GNRP SUBROUTINE. HOWEVER BEFORE WE CALL IT
:WE HAVE TO CREATE MUCB WITH SOME OF THE INFORMATION WHICH THIS
:SUBROUTINE NEEDS. THE INFORMATION CORRESPONDS TO RQ, NOT RSP.
:ONLY THE INFORMATION USED IN L.GNRP IS FILLED IN CORRECTLY.
L.CHA1	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET PTR TO BUF WITH CT
	LB	R5,BBUFER+CLARG5+1,R4,	:GET BYTE WITH RH2
	THI	R5,MU.ERI		:EXCEPTION RSP?
	JN	L.CHA4			:JUMP IF SO
	LB	R5,BBUFER+CLARG6,R4,	:GET BYTE WITH RU CATEGORY
	NHI	R5,MU.CTG		:FMD?
	JEFS	L.CHAB			:JUMP IF SO
	LB	R5,BBUFER+CLARG4,R4,	:GET RQ CODE
	CHI	R5,CHASE		:CHASE?
	JE	L.CHA4			:JUMP IF SO
L.CHAB	JAL	R4,GBB,,		:GET BUFFERLET FOR MUCB
	J	L.NBUF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	LR	R10,R3			:COPY BUFFERLET POINTER
	BBLOAD	R4,CMDBLK+CLARG,R8,	:GET PTR TO BUF WITH CT
	LB	R5,BBUFER+CLARG6,R4,	:GET BYTE WITH RU CATEGORY
	NHI	R5,MU.CTG		:LEAVE RU CATEGORY ONLY
	JEFS	L.CHAA			:JUMP IF FMD
	OHI	R5,MU.FI		:OTHERWISE SHOW FORMATTED RQ
L.CHAA	STB	R5,BBUFER+MURHF1,R10,	:STORE IT IN MUCB
	LB	R5,BBUFER+CLARG5+1,R4,	:GET BYTE CONTAINING RH BYTE 2
	STB	R5,BBUFER+MURHF2,R10,	:STORE IT IN MUCB
	LB	R1,BBUFER+CLARG4,R4,	:GET RQ CODE
	LHL	R5,BBUFER+CLARG3,R4,	:GET END SEQ #
	STH	R5,BBUFER+MUSNF,R10,	:PUT IT IN MUCB
	LHI	R5,FID2^4		:PREPARE 1ST BYTE OF TH
	STB	R5,BBUFER+MUBIUF,R10,	:PUT IT IN MUCB
	LB	R5,LUCTAB+LUCADR,R9,	:GET ADDR OF SEC LU
	LB	R4,LUCTAB+LUPRIL,R9,	:GET ADDR OF SEC LU
	IF	TERMIF&HOSTIF
	LB	R3,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R3,PU.T4		:TYPE 4?
	JNFS	L.CHA2			:JUMP IF NOT
	EI
	IF	TERMIF
	STB	R5,BBUFER+MUOADP,R10,	:PUT SEC IN MUCB
	STB	R4,BBUFER+MUDADP,R10,	:PUT PRI IN MUCB
	EI
	IF	TERMIF&HOSTIF
	JFS	L.CHA3			:JUMP TO CONTINUE
	EI
	IF	HOSTIF
L.CHA2	STB	R5,BBUFER+MUDADP,R10,	:PUT SEC ADDR IN MUCB
	STB	R4,BBUFER+MUOADP,R10,	:PUT PRI ADDR IN MUCB
	EI
L.CHA3	XR	R0,R0			:+RSP (NO SENSE CODE)
	JAL	R5,L.GNRP,,		:GENERATE +RSP
	LHI	R2,DFCSND		:SHOW DFC.SEND AS DESTINATION
	LHI	R1,LURCV		:FROM LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	JAL	R8,SEND,,		:SEND DQE
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
L.CHA4	LHL	R8,CMDBLK+CLPTR,R8,	:GET NEXT ELEMENT OF CT
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET SCB POINTER
	J	L.CHA0			:CONTINUE
	EI

	IF	TERMIF
:RTR AND CANCEL PROCESSING ROUTINES.
:GET RID OF THE MSG, SEND +RSP AND GENERATE REDISPLAY COMMAND TO NIO.
:RTR ENTRY POINT.
L.RTR	LHI	R1,RTR			:GET RTR RQ CODE
	JFS	L.CAN1			:JUMP TO CONTINUE

:CANCEL ENTRY POINT.
L.CANC	LHI	R1,CANCEL		:GET CANCEL RQ CODE
L.CAN1	LHI	R0,SNERR^8!SNERRD	:PREPARE REDISPLAY CMD
	JAL	R5,L.PTCD,,		:PASS IT TO NIO
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO BTU
	JAL	R5,R.PBRC,,		:RELEASE BUFFER WITH MSG
	XR	R0,R0			:PREPARE FOR +RSP
L.CAN2	JAL	R5,L.GNRP,,		:GENERATE RSP
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	JAL	R8,SEND,,		:SEND THE MESSAGE
	JR	R14			:AND RETURN

:RSHUTD PROCESSING ROUTINE.
:REPLY WITH +RSP, GO INTO BAD STATE AND NOTIFY NIO WITH "UNABLE TO CONTINUE".
:NIO WILL RESPOND WITH CLEAR COMMAND, WHICH WILL CAUSE UNBIND TO BE
:SEND TO THE SECONDARY HALF-SESSION.
L.RSHT	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO BTU
	JAL	R5,R.PBRC,,		:RELEASE BBUFER WITH MSG
	LHI	R0,SNERR^8!SNERST	:PREPARE UNABLE TO CONTINUE
	JAL	R5,L.PTCD,,		:PASS IT TO NIO
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUBDST		:GO TO BAD SUBSTATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	XR	R0,R0			:PREPARE FOR +RSP
	STB	R0,LUCTAB+LULUWK,R9,	:CLEAR LUSVC WORK BYTE
	LHI	R1,RSHUTD		:PREPARE RSHUTD RQ CODE
	J	L.CAN2			:JUMP TO SEND +RSP

:SIGNAL PROCESSING ROUTINE. DISCARD IF RSP(SIG).
:REPLY WITH +RSP IF SIG RQ.
:IF SIG(REQUEST TO SEND) AND SENDING OF RH-ONLY CHANGE DIRECTION
:IS POSSIBLE, SEND IT, OTHERWISE IGNORE THE SIGNAL.
L.SIG	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:RQ OR RSP?
	JN	L.RCL1			:DISCARD IF RSP
	BBLOAD	R8,BBUFER+MURUPT,R10,	:GET POINTER TO RU
	LHL	R8,BBUFER+1,R8,		:GET SIGNAL CODE
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POINTER TO BTU
	JAL	R5,R.PBRC,,		:RELEASE BUFFER CHAIN WITH MSG
	LHI	R1,SIG			:PREPARE FOR SIGNAL RSP
	XR	R0,R0			:INDICATE +RSP
	JAL	R5,L.GNRP,,		:GENERATE RSP
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNAL
	STM	R0,LURGSV,,		:SAVE ALL REGISTERS
	JAL	R8,SEND,,		:SEND +RSP(SIG)
	LM	R0,LURGSV,,		:RESTORE ALL REGISTERS
	CHI	R8,LURQSG		:WAS SIGNAL REQUEST TO SEND?
	JEFS	L.SIG1			:JUMP IF SO
L.SIGB	LHI	R0,SNERR^8!SNERST	:STATUS ERROR OTHERWISE
	LR	R2,R8			:COPY SNA SIGNAL CODE
	JAL	R5,L.PTCD,,		:PASS CMD TO NIO
	JR	R14			:AND RETURN

:CHECK IF SENDING RH-ONLY FMD WITH CHANGE DIRECTION IS POSSIBLE.
L.SIG1	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JEBS	L.SIGB			:JUMP IF LU-LU DOES NOT EXIST
	LB	R5,SCBBLK+SCSTAT+FSCCSD,R7,	:GET CHAIN-SEND FSM
	CHI	R5,FS.ST1		:BETWEEN CHAINS?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCDSA,R7,	:GET SDT-CLEAR FSM
	CHI	R5,FS.ST3		:DATA TRAFFIC ALLOWED?
	JNR	R14			:RETURN IF NOT
	LB	R5,SCBBLK+SCSTAT+FSCBBI,R7,	:GET BSM-BIDDER STATE
	CHI	R5,FS.ST1		:BETWEEN BRACKETS?
	JER	R14			:RETURN IF SO
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX-FF FSM
	CHI	R5,FS.ST3		:STATE 3?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST5		:STATE 5?
	JER	R14			:CANNOT SEND, RETURN
	CHI	R5,FS.ST6		:STATE 6?
	JER	R14			:CANNOT SEND, RETURN

:GENERATE RH-ONLY RU WITH CHANGE DIRECTION AND SEND IT.
	JAL	R5,L.GNDS,,		:GENERATE DUMMY RU
	LB	R5,BBUFER+MURHF3,R10,	:GET 3RD BYTE OF RH
	OHI	R5,MU.CDI		:FORCE CHANGE DIRECTION
	STB	R5,BBUFER+MURHF3,R10,	:UPDATE 3RD BYTE OF RH
	LB	R5,LUCTAB+LUPRIL,R9,	:GET ADDR OF PRIMARY
	STB	R5,BBUFER+MUOADP,R10,	:DESTINATION PRIMARY LU
	LR	R1,R7			:COPY SCB POINTER
	JAL	R4,GBB,,		:ACQUIRE BUFFER FOR DQE
	J	L.NBUF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT IT
	BBSSCB	R1,BBUFER+DQSCB,R3,	:STORE SCB POINTER IN DQE
	BBSTOR	R10,BBUFER+DQMUPR,R3,	:STORE MUCB POINTER IN DQE
	STH	R9,BBUFER+DQLUCB,R3,	:STORE LUCB POINTER IN DQE
	J	L.RCFY			:JUMP TO SEND DQE

::::::::::::::::::::
:: LUSTAT WAS RECEIVED. ALWAYS SEND +RSP BACK. IF LUSTAT WAS FOR
:: SSCP-LU SESSION DISCARD IT.
:: FOR LU-LU LUSTAT CHECK STATUS CODE. IF CONTINUATION IS POSSIBLE
:: PASS REDISPLAY CMD TO NIO. OTHERWISE GO TO BAD SUBSTATE AND
:: PASS UNABLE TO CONTINUE TO NIO.
L.LUST	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:IS IT RQ OR RSP?
	JEFS	L.LUS1			:JUMP IF RQ

:LUSTAT RSP IS INVALID FOR TERMINAL INTERFACE.
	LR	R5,R10			:SAVE MUCB POINTER
	JAL	R10,CRASH,,		:CRASH
	HC	0
	BC	4*R5,CR.IMG		:INVALID MSG CRASH CODE

:IF THIS IS SSCP-LU LUSTAT SEND +RSP AND DISCARD IT.
L.LUS1	LB	R5,BBUFER+MUDADP,R10,	:GET DESTINATION ADDR
	JE	L.RCL3			:JUMP IF SSCP-LU

:IF LU-LU CHECK STATUS CODE.
	JAL	R5,L.LUCK,,		:CHECK STATUS CODE
	LR	R0,R0			:CAN WE CONTINUE
	JNFS	L.LUS2			:JUMP IF NOT

:WE CAN TRY TO REPEAT SEND OPERATION. GO INTO CLEAN MODE AND
:NOTIFY NIO.
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LULCCL		:INDICATE CLEAN MODE
	LHI	R0,SNERR^8!SNERRD	:PREPARE ERR CMD WITH REDISPL
	JFS	L.LUS3			:JUMP TO CONTINUE

:UNABLE TO CONTINUE BECAUSE OF TERMIANL STATUS. GO INTO BAD SUBSTATE
:AND NOTIFY NIO.
L.LUS2	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:CLEAR LUSVC WORK BYTE
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUBDST		:GO INTO BAD SUBSTATE
	LHI	R0,SNERR^8!SNERST	:TERM STATUS BAD

:UPDATE LUSVC STATE BYTE AND SEND CMD TO NIO.
L.LUS3	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET POINTER TO RU
	LB	R2,BBUFER+1,R5,		:GET 1ST BYTE OF STATUS CODE
	EXBR	R2,R2			:PUT IT IN 2ND BYTE OF REG
	LB	R5,BBUFER+2,R5,		:GET 2ND BYTE OF STATUS CODE
	OR	R2,R5			:PUT IT IN R2
	JAL	R5,L.PTCD,,

:GENERATE +RSP AND DISCARD LUSTAT.
	LHI	R1,LUSTAT		:PREPARE FOR LUSTAT RSP
	J	L.RCL3			:JUMP TO GENERATE +RSP

::::::::::::::::::::
:: RECEIVED MSG OF DFC CATEGORY IN TRANSIENT MODES.
:  DISCARD THE MSG AND SEND +RSP.
L.RCQD
L.RCPD	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET POINTER TO RU
	LB	R1,BBUFER,R1,		:GET RU CODE
	J	L.RCL3			:JUMP TO SEND +RSP

::::::::::::::::::::
:: RECEIVED MSG OF SC CATEGORY IN LOCAL MODE. IT SHOULD NOT HAVE HAPPENED.
:  PROBABLY UNBIND FROM TERMINAL. PUT US IN BAD STATE AND NOTIFY NIO.
L.RCSC	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUBDST		:PUT US IN BAD STATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R0,SNERR^8!SNERST	:PREP TERM STATUS ERROR
	JAL	R5,L.PTCD,,		:PASS COMMAND TO NIO
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET POITER TO MSG
	JAL	R5,R.PBRC,,		:RELEASE BUF WITH MSG
	LR	R3,R10			:GET PTR TO MUCB
	JAL	R4,PBB,,		:RELEASE BUF WITH MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

::::::::::::::::::::
:: RECEIVE PROCESS IN PENDING TRANSPARENT MODE.
:
:: PRINTER SUPPORT SUBSTATES WERE NOT YET CODED.
:: THE CODE CHECKS FOR LULUBD BIT IN LULUWK (LUCB). ONLY THE
:: LOGIC CORRESPONDING TO RESET STATE OF THIS BIT (NO END-TO-END
:: SESSION WAS INTERRUPTED BY LOCAL SESSION) WAS CODED.
:: FMD RQ'S ARE DISCARDED. +RSP IS SENT IF IT WAS SSCP-LU FMD 
:: FOLLOWED BY "INTERFACE NOT READY" SSCP-LU MSG.
:: FMD RESPONSES SHOULD NOT BE RECEIVED EXCEPT IN CASE WHEN
:: LOCAL SESSION INTERRUPTED END-TO-END SESSION.
:: SC RQ'S SHOULD NOT BE RECEIVED EXCEPT FOR UNBIND. THIS
:: PUTS LUSVC IN BAD SUBSTATE.
:: THE SAME HAPPENS FOR SC -RSP'S.
:: +RSP(UNBIND) IS THE ONLY RESPONSE CURRENTLY EXPECTED. IT IS FOR UNBIND
:: WHICH IS GENERATED BY SEND PROCESS IN PENDING TRANSPARENT STATE.
:: +RSP(UNBIND) CAUSES THE STATE TO BE CHANGED TO TRANSPARENT
:: (IF NO END-TO-END SESSION WAS INTERRUPTED)
:: NOTIFICATION TO BE PASSED TO NIO AND FINISH COMMAND TO BE
:: REMOVED FROM SNA->NTW QUEUE.
:
:FIRST SEPARATE NOTIFICATIONS FROM LOWER SNA LAYERS FROM RECEIVED
:MESSAGES.
L.RCPT	LB	R5,BBUFER+MUDIRE,R10,	:GET MU DIRECTION
	CHI	R5,SENT			:IS IT SEND?
	JE	L.RCPN			:NOTIFICATION IF SO

:IF MULTISEGMENT MESSAGE ASSUME THAT IT WAS FMD. DISCARD IT
:AND SEND +RSP IF THE LAST SEGMENT OF SSCP-LU MSG.
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:IS IT THE LAST SEG?
	JE	L.RCL1			:JUMP TO REL MSG&MUCB IF NOT
	THI	R5,MU.BIU		:IS IT ALSO THE FIRST SEG?
	JNFS	L.RCQ1			:JUMP IF SO
	LB	R5,BBUFER+MUDADP,R10,	:IS IT SSCP-LU
	JE	L.RCQ2			:JUMP TO GIVE +RSP IF SO
	J	L.RCL1			:OTHERWISE JMP TO REL MSG&MUCB

:THIS IS A ONE SEGMENT RU. VECTOR EXECUTION DEPENDING ON RU CATEGORY.
L.RCQ1	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,MU.CTG		:LEAVE RU CATEGORY ONLY
	SRLS	R5,4			:MAKE HALF-WORD INDEX
	LHL	R5,L.RCQT,R5		:GET PTR TO PROC ROUTINE
	J	L.BASE,R5,,		:JUMP TO PROC ROUTINE

L.RCQT	HC	L.RCQF-L.BASE		:FMD PROC ROUTINE
	HC	L.RCQC-L.BASE		:NC PROC ROUTINE
	HC	L.RCQD-L.BASE		:FMD PROC ROUTINE
	HC	L.RCQS-L.BASE		:SC PROC ROUTINE

:IF FMD REQUSET RECEIVED DISCARD IT. GENERATE +RSP IF SSCP-LU.
L.RCQF	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:IS IT RQ OR RSP
	JN	L.RCL1			:JUMP TO DISCARD IF RSP
	LB	R5,BBUFER+MUDADP,R10,	:IS IT SSCP-LU?
	JN	L.RCQ3			:JUMP IF NOT

:IF NO END-TO-END SESSION WAS INTERRUPTED SHOW THAT WE HAVE TO SEND
:"INTERFACE NOT READY" MSG AFTER UNBIND. THEN SEND +RSP.
L.RCQ2	LB	R5,BBUFER+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULUBD		:WAS E-T-E SESSION INTERRPT?
	JN	L.RCQ0			:JUMP IF SO
	OHI	R5,LULUNR		:OTHERWISE SET PEND "NOT READY"
	STB	R5,BBUFER+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	J	L.RCL3			:JUMP TO SEND +RSP

:END-TO-END SESSION WAS INTERRUPTED. THIS HAPPENS FOR PRINTER LOGON.
:THIS MUST BE CODED LATER.
L.RCQ0	JAL	R10,CRASH,,		:CRASH
	HC	0
	BC	4*R5,CR.TMP		:WITH TEMPORARY CRASH CODE

:LU-LU FMD RECEIVED. DISCARD IF IT HAPPENED BEFORE LOCAL RSP(UNBIND).
L.RCQ3	LB	R5,BBUFER+LULUST,R9,	:GET LUSVC STATE BYTE
	NHI	R5,LUSBST!WAITRS	:CLEAR STATE INFO
	JE	L.RCL1			:DISCARD IF UNBIND NOT SENT YET
	CHI	R5,LUPTUB!WAITRS	:IF +RSP(UNBIND) NOT RCV'ED
	JE	L.RCL1			:DISCARD MSG&MUCB

:WE ARE PAST +RSP(UNBIND) FOR LOCAL SESSION. SHOULD NOT HAVE HAPPENED
:IF NO END-TO-END SESSION WAS INTERRUPTED BY LOCAL SESSION.
	JAL	R10,CRASH,,		:CRASH
	HC	0
	BC	4*R5,CR.TMP		:TEMPORARY CRASH

:SC CATEGORY MESSAGE WAS RECEIVED FROM SEC LU.
:NORMALLY THIS WOULD BE +RSP(UNBIND).
:NOTIFY NIO AND GO TO BAD SUBSTATE IF SOMETHING ELSE WAS RECEIVED.
L.RCQS	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:IS IT RQ OR RSP?
	JN	L.RCQ6			:JUMP IF RSP
L.RCQ5	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATUS BYTE
	OHI	R5,LUBDST		:GO TO BAD STATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATUS BYTE
	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R0,SNERR^8!SNERST	:PREPARE TERM STATE ERROR
	JAL	R5,L.PTCD,,		:PASS CMD TO NIO
	J	L.RCV1			:GET RID OF MSG&MUCB

:RSP FOR SC CATEGORY WAS RECEIVED. IF -RSP NOTIFY NIO AND GO TO BAD STATE
L.RCQ6	THI	R5,MU.SDI		:IS IT NEGATIVE RSP?
	JN	L.RCQ5			:JUMP IF SO

:IF +RSP TURN OFF FINAL BIT FOR TIMEOUT LOGIC.
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO!@LULUFN	:NO SC OUTSTADING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE

:EXPECTED +RSP IS FOR UNBIND IF LUSVC IS IN UNBIND SENT
:SUBSTATE. PREPARE STATE IN R6, SUBSTATE IN R1 AND RQ CODE IN R5.
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET PTR TO RU
	LB	R5,BBUFER,R5,		:GET RU CODE
	LB	R6,LUCTAB+LULUST,R9,	:GET LUSVC STATE
	LR	R1,R6			:COPY IT
	NHI	R1,LUSBST		:GET LUSVC SUBSTATE

:IF UNBIND RESPONSE WAS NOT FOR UNBIND SENT GO TO BAD SUBSTATE
	CHI	R5,UNBIND		:IS IT UNBIND?
	JN	L.RCQ5			:JUMP IF NOT
	CHI	R1,LUPTUB		:IS IT UNBIND SENT STATE?
	JN	L.RCQ5			:BAD RESPONSE IF NOT

:FOR RSP(UNBIND) DESTROY SCB
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET SCB POINTER
:	THI	R7,LUINV		:IS IT VALID?
:	JN	L.RCQQ			:JUMP IF NOT
	JE	L.RCQQ			:JUMP IF INVALID
:	LCS	R5,1			:PREPARE -1
	XR	R5,R5			:CLEAR THE REGISTER
	BBSSCB	R5,LUCTAB+LULSCB,R9,	:SHOW NO SCB FOR LU-LU
	STM	R0,LURGSV,,		:SAVE REGISTERS
	LR	R9,R7			:COPY SCB POINTER
	JAL	R8,V.SCDS,,		:DISCARD SCB
	LM	R0,LURGSV,,		:RESTORE REGISTERS

:IF NO END-TO-END SESSION WAS INTERRUPTED GO INTO TRANSPARENT STATE
L.RCQQ	IF	VTISUP
	LHL	R5,LUCTAB+LUSNDG,R9,	:GET POINTER TO CMD LINK
	LHL	R2,CMDBLK+CLLNG,R5,	:PASS CONTINUE CONVERSATION TO NIO
	EI
	LHI	R0,SNPOSR^8!SNFNLG	:PREPARE +RSP FINISH LOGON
	JAL	R5,L.PTCD,,		:INFORM NIO
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	THI	R5,LULUBD		:WAS END-TO-END SESSION INTERRPT
	JN	L.RCQ0			:JUMP IF SO
	LHI	R6,TRPSTA		:OTHERWISE PREPARE TRNSP STATE
	IF	VTISUP
	LHL	R4,LUCTAB+LUSNDG,R9,	:GET POINTER TO CMD LINK
	LB	R0,CMDBLK+CLCMDS,R4,	:GET SUBCOMMAND OF FINISH LOG
	CHI	R0,NSFNDP		:DSP STATE?
	JN	L.RCQZ			:JUMP IF NOT
	XR	R6,R6			:CLEAR THE REGISTER
	STB	R6,LUCTAB+LULUW2,R9,	:CLEAR LU_SVC 2ND WORK BYTE
	LHI	R6,DSPSTA		:OTHERWISE GO TO DSP STATE
	LHL	R0,CMDBLK+CLLNG,R4,	:SESSION TO CONTINUE AFTER NSM?
	JE	L.RCQZ			:JUMP IF NOT
	STB	R6,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE
	LHI	R0,NSSTAT^8!NSSTNW	:SOLICITED START LOGON
	STH	R0,CMDBLK+CLCMD,R4,	:REPLACE CMD
	J	L.RCL1			:JUMP TO RELEASE MSG AND MUCB
L.RCQZ	EQ	.
	EI
	STB	R6,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	XR	R6,R6			:PREPARE TO CLEAR LUSVC WRK BYTE
	STB	R6,LUCTAB+LULUWK,R9,	::UPDATE LUSVC WORK BYTE

:IF SSCP-LU "INTERFACE NOT READY" MSG IS NOT PENDING
:DISCARD MSG&MUCB AND REMOVE FINISH CMD LINK FROM NTW->SNA QUEUE.
	THI	R5,LULUNR		:"NOT READY" MSG PENDING?
	JN	L.RCQ7			:JUMP IF SO
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:OTHERWISE POINT TO MSG
	JAL	R5,R.PBRC,,		:RELEASE IT
	LR	R3,R10			:COPY MUCB POINTER
	JAL	R4,PBB,,		:RELEASE IT
	JAL	R4,R.PBB,,		:COUNT IT
	J	L.RMT0			:JUMP TO REMOVE CMD LINK

:SEND "INTERFACE NOT READY" SSCP-LU MSG IF WE CAN SEND ON SSCP-LU,
:DISCARD MUCB AND REMOVE FINISH CMD LINK FROM NTW->SNA QUEUE.
L.RCQ7	BBLOAD	R3,BBUFER+MUCBTU,R10,	:POINT TO MSG
	JAL	R5,R.PBRC,,		:RELEASE BUFFERLETS
	LHL	R8,LUNRMG,,		:ASSUME ENGLISH VERSION
	LB	R5,LUCTAB+LUCDIF,R9,	:SEE IF KATAKANA AND KANJI
	NHI	R5,07			:...
	CLHI	R5,4			:KATAKANA = 4, KANJI =5
	JLFS	L.RCQY			:ENGLISH VERSION, SKIP
	LHL	R8,LUNRMG+2,,		:ELSE, JAPANESE VERSION
L.RCQY
	AI	R8,PSEG
	LHL	R1,0,R8			:GET MSG LENGTH
	AIS	R8,2			:R8 = ADDR OF "NOT READY" MSG
	BBLSCB	R7,LUCTAB+LUSSCB,R9,	:POINT TO SSCP-LU SCB
	LB	R5,SCBBLK+SCSTAT+FSCHFF,R7,	:GET HDX_FF STATE
	CHI	R5,FS.ST3		:STATE 3?
	JE	L.RMT0			:YES, JUMP TO REMOVE CMD LINK
	CHI	R5,FS.ST5		:STATE 5?
	JE	L.RMT0			:YES, JUMP TO REMOVE CMD LINK
	CHI	R5,FS.ST6		:STATE 6?
	JE	L.RMT0			:YES, JUMP TO REMOVE CMD LINK
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R7,	:GET IMMED-SEND FSM
	CHI	R5,FS.ST2		:STATE 2?
	JE	L.RMT0			:YES, JUMP TO REMOVE CMD LINK
	CHI	R5,FS.ST5		:STATE 5?
	JE	L.RMT0			:YES, JUMP TO REMOVE CMD LINK
	JAL	R5,L.GNMG,,		:GENERATE MSG AND DQE
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:SEND NO SIGNALS
	JAL	R8,SEND,,		:SEND DQE
	J	L.RMT0			:JUMP TO REMOVE CMD LINK

::::::::::::::::::::
:: RECEIVE PROCESS IN PENDING LOCAL MODE.
:
:: FMD RQ'S ARE DISCARDED. +RSP IS SENT IF IT WAS SSCP-LU FMD.
:: FMD RESPONSES SHOULD NOT BE RECEIVED EXCEPT IN CASE WHEN
:: LOCAL SESSION INTERRUPTED END-TO-END SESSION.
:: SC RQ'S SHOULD NOT BE RECEIVED EXCEPT FOR UNBIND. THIS
:: PUTS LUSVC IN BAD SUBSTATE.
:: THE SAME HAPPENS FOR SC -RSP'S.
:: +RSP(UNBIND),+RSP(BIND) AND +RSP(SDT) ARE THE EXPECTED RESPONSES
:: WHICH ARE GENERATED BY SEND PROCESS IN PENDING LOCAL STATE.
:: THEY CAUSE WAIT BIT IN LUSVC STATE TO BE RESET.
:: +RSP(SDT) CAUSES THE STATE TO BE CHANGED TO LOCAL,
:: NOTIFICATION TO BE PASSED TO NIO AND START COMMAND TO BE
:: REMOVED FROM SNA->NTW QUEUE.
:
:FIRST SEPARATE NOTIFICATIONS FROM LOWER SNA LAYERS FROM RECEIVED
:MESSAGES.
L.RCPL	LB	R5,BBUFER+MUDIRE,R10,	:GET MU DIRECTION
	CHI	R5,SENT			:IS IT SEND?
	JE	L.RCPN			:NOTIFICATION IF SO

:IF MULTISEGMENT MESSAGE ASSUME THAT IT WAS FMD. DISCARD IT
:AND SEND +RSP IF THE LAST SEGMENT OF SSCP-LU MSG.
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:IS IT THE LAST SEG?
	JE	L.RCL1			:JUMP TO REL MSG&MUCB IF NOT
	THI	R5,MU.BIU		:IS IT ALSO THE FIRST SEG?
	JNFS	L.RCP1			:JUMP IF SO
	LB	R5,BBUFER+MUDADP,R10,	:IS IT SSCP-LU
	JE	L.RCL3			:JUMP TO GIVE +RSP IF SO
	J	L.RCL1			:OTHERWISE JMP TO REL MSG&MUCB

:THIS IS A ONE SEGMENT RU. VECTOR EXECUTION DEPENDING ON RU CATEGORY.
L.RCP1	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,MU.CTG		:LEAVE RU CATEGORY ONLY
	SRLS	R5,4			:MAKE HALF-WORD INDEX
	LHL	R5,L.RCPB,R5		:GET PTR TO PROC ROUTINE
	J	L.BASE,R5,,		:JUMP TO PROC ROUTINE

L.RCPB	HC	L.RCPF-L.BASE		:FMD PROC ROUTINE
	HC	L.RCPC-L.BASE		:NC PROC ROUTINE
	HC	L.RCPD-L.BASE		:FMD PROC ROUTINE
	HC	L.RCPS-L.BASE		:SC PROC ROUTINE

:IF FMD REQUSET RECEIVED DISCARD IT. GENERATE +RSP IF SSCP-LU.
L.RCPF	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:IS IT RQ OR RSP
	JN	L.RCL1			:JUMP TO DISCARD IF RSP
	LB	R5,BBUFER+MUDADP,R10,	:IS IT SSCP-LU?
	JE	L.RCL3			:GENERATE +RSP IF SO
	J	L.RCL1			:OTHERWISE REL MSG&MUCB

:SC CATEGORY MESSAGE WAS RECEIVED FROM SEC LU.
:NORMALLY THESE WOULD BE +RSP(UNBIND), +RSP(BIND) AND +RSP(SDT).
:NOTIFY NIO AND GO TO BAD SUBSTATE IF SOMETHING ELSE WAS RECEIVED.
L.RCPS	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:IS IT RQ OR RSP?
	JN	L.RCP4			:JUMP IF RSP
L.RCP3	LHI	R0,SNERR^8!SNERST	:PREPARE TERM STATE ERROR
L.RCPI	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATUS BYTE
	OHI	R5,LUBDST		:GO TO BAD STATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATUS BYTE
	XR	R5,R5			:CLEAR REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	JAL	R5,L.PTCD,,		:PASS CMD TO NIO
	J	L.RCV1			:GET RID OF MSG&MUCB

:RSP FOR SC CATEGORY WAS RECEIVED. IF -RSP NOTIFY NIO AND GO TO BAD STATE
L.RCP4	THI	R5,MU.SDI		:IS IT NEGATIVE RSP?
	JE	L.RCPG			:JUMP IF SO
:	LHL	R5,BBUFER+MURUPT,R10,	:GET RU POINTER(9/13/84/CHS)
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER(9/13/84/CHS)
	LB	R5,BBUFER,R5,		:GET RQ CODE
	CHI	R5,BIND			:IS IT BIND?
	JN	L.RCP3			:JUMP IF NOT
	LIS	R0,0			:CLEAR LULSCB IN LUC (09/10/84/CHS)
	BBSSCB	R0,LUCTAB+LULSCB,R9,	: (09/10/84/CHS)
	LB	R4,BBUFER+MURHSN,R10,	:GET 1ST BYTE OF SENSE CODE
	LB	R5,BBUFER+MURHSN+1,R10,	:GET 2ND BYTE OF SENSE CODE
	EXBR	R4,R4			:PUT 1ST BYTE IN RIGHT PL
	OR	R5,R4			:GET SENSE CODE
	CHI	R5,LUNNSN		:POWER OFF?
	JNFS	L.RCPH			:JUMP IF NOT
	LHI	R0,SNERR^8!SNERPO	:POWER OFF CMD TO NIO
	J	L.RCPI			:JUMP TO CONTINUE
L.RCPH	LHI	R0,SNERR^8!SNERBD	:BIND FAILURE TO NIO
	J	L.RCPI			:JUMP TO CONTINUE

:IF +RSP RECEIVED TURN OFF FINAL BIT FOR TIMEOUT LOGIC.
L.RCPG	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUSO&@LULUFN	:NO SC RSP OUTSTANDING
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE

:EXPECTED +RSP'S ARE FOR UNBIND, BIND AND SDT DEPENDING ON LUSVC
:SUBSTATE. PREPARE STATE IN R6, SUBSTATE IN R1 AND RQ CODE IN R5.
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET PTR TO RU
	LB	R5,BBUFER,R5,		:GET RU CODE
	LB	R6,LUCTAB+LULUST,R9,	:GET LUSVC STATE
	LR	R1,R6			:COPY IT
	NHI	R1,LUSBST		:GET LUSVC SUBSTATE

:IF UNBIND RESPONSE FOR UNBIND SENT RESET WAIT BIT AND CONTINUE.
	CHI	R5,UNBIND		:IS IT UNBIND?
	JNFS	L.RCP5			:JUMP IF NOT
	CHI	R1,LUPLUB		:IS IT UNBIND SENT STATE?
	JN	L.RCP3			:BAD RESPONSE IF NOT
	NHI	R6,@WAITRS		:RESET WAIT BIT
	STB	R6,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE
	J	L.RCL1			:DISCARD RSP AND CONTINUE

:IF BIND REPONSE FOR BIND SENT RESET WAIT BIT AND CONTINUE.
L.RCP5	CHI	R5,BIND			:IS IT BIND?
	JNFS	L.RCP6			:JUMP IF NOT
	CHI	R1,LUPLBD		:IS IT BIND SENT SUBSTATE?
	JN	L.RCP3			:GO TO BAD SUBSTATE IF NOT
	NHI	R6,@WAITRS		:RESET WAIT BIT
	STB	R6,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE
	J	L.RCL1			:DISCARD RSP AND CONTINUE

:IF SDT RESPONSE FOR SDT SENT GO TO LOCAL MODE, NOTIFY NIO AND
:REMOVE START LOGON COMMAND FROM NTW->SNA QUEUE.
L.RCP6	CHI	R5,SDT			:IS IT SDT?
	JN	L.RCP3			:GO TO BAD SUBSTATE IF NOT
	CHI	R1,LUPLST		:IS IT SDT SENT SUBSTATE?
	JN	L.RCP3			:GO TO BAD SUBSTATE IF NOT
	BBLOAD	R3,BBUFER+MUCBTU,R10, :GET PTR TO MSG
	JAL	R5,R.PBRC,,		:RELEASE RCV BUF CHAIN
	LR	R3,R10			:COPY MUCB PTR TO R3
	JAL	R4,PBB,,		:RELASE MUCB
	JAL	R4,R.PBB,,		:COUNT AS XMT BB
	LHI	R6,LOCSTA		:PREPARE LOCAL STATE
	STB	R6,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE

:PREPARE POSITIVE RESPONSE FOR START LOGON COMMAND. IT CONTAINS
:MAXIMUM RU SIZE AND THE INDICATION WHETHER MULTIPLE RU CHAINS
:ARE ALLOWED. THIS INFORMATION IS TAKEN FROM SCB.
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	LB	R5,SCBBLK+SCPMRU,R7,	:MAX RU SZ = 2**A * B
	LR	R1,R5			:COPY IT
	NHI	R5,0F			:LEAVE 2ND HALF BYTE (B)
	SRLS	R1,4			:GET EXPONENT (A)
	SLL	R5,0,R1			:CALC MUX RU SIZE
	LB	R2,SCBBLK+SCPLUP,R7,	:GET FM USAGE PROM PRI
	XHI	R2,0F			:INVERT IT
	NHI	R2,LUCHNI		:LEAVE MULTI-CHAIN INDICATOR
	EXBR	R2,R2			:PUT IT IN RIGHT PLACE
	OR	R2,R5			:MERGE WITH RU SIZE
	LHI	R0,SNPOSR^8!SNSTLG	:PREPARE POSITIVE RSP FOR ST LG
	JAL	R5,L.PTCD,,		:PASS CMD TO NIO

:REMOVE START LOGON CMD FROM NTW->SNA QUEUE. THIS ENDS PENDING
:LOCAL STATE PROCESSING.
	J	L.RMT0			:JUMP TO REMOVE CMD LINK
	EI				:END OF RECEIVE LOGIC FOR TERM IF


::::::::::::::::::::::::::
:: RECEIVE PROCESS IN LOCAL AND PENDING MODES FOR HOST INTERFACE.
:
::
:: HOST INTERFACE
::
:: NOTHING IS PASSED TO NIO IN LOCAL MODE (NO VIRTUAL CIRCUIT)
:: OR TRANSIENT MODES.
:: THE MAIN PURPOISE OF THIS PROCESS IS TO KEEP HOST FROM DISCONNECTING
:: LOGICAL UNIT. CURRENT THINKING IS THAT IT COULD BE DONE BY
:: FAKING POWER OFF FOR THE TERMINAL (LOGICAL UNIT).
:: ONLY SSCP-LU SESSION SHOULD EXIST IN LOCAL MODE.
:: NO RQ'S ARE GENERATED IN LOCAL MODE.
:: THE ONLY LEGAL MESSAGES EXPECTED FROM THE HOST ARE SSCP-LU
:: FMD RQ'S (REJECTED WITH -RSP(831)) AND BIND (CURRENTLY REJECTED
:: WITH -RSP(BIND,80A) - SSCP WILL NOT BE NOTIFIED WHEN
:: LOGICAL UNIT IS AVAILABLE THAT IS WHEN THE VC IS BUILT).
:: HOWEVER, LU-LU FMD'S ARE ALSO REJECTED WITH -RSP(831) IN
:: CASE IF RSHUTD GENERATED WHEN RESET SIGNAL WAS RECEIVED
:: DID NOT CAUSE UNBIND (IT COULD ALSO HAPPEN IN PENDING
:: LOCAL MODE DUE TO RACE CONDITION).
:: UNBIND IS ALOS ACCEPTED AS LEGAL WITH +RSP(UNBIND).
:::::::::::::::::::::
:
	IF	HOSTIF
:FIRST SEPARATE HOST MESSAGES FROM NOTIFICATIONS FOR PREVIOUSLY
:GENERATED REQUESTS AND RESPONSES.
H.RCPT
H.RCPL
H.RCLC	LB	R5,BBUFER+MUDIRE,R10,	:GET MU DIRECTION
	CHI	R5,SENT			:IS IT NOTIFICATION?
	JE	H.RCNT			:JUMP IF SO

:IF A MULTISEGMENT MESSAGE RECEIVED WE ASSUME THAT IT IS PART OF
:FMD. ALL SEGMENTS EXCEPT FIRST ARE ALWAYS DISCARDED. THE RECEPTION
:OF THE LAST SEGMENT OF SSCP-LU FMD REQUIRES SENDING BACK A REPSONSE.
:
:FIRST CHECK IF IT WAS THE 1ST SEGMENT.
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.BIU		:IS IT 1ST SEGMENT?
	JN	H.RCL6			:JUMP IF SO

:NOT THE FIRST SEGMENT. IF IT IS ALSO NOT THE LAST SIMPLY
:GET RID OF THE SEGMENT AND MUCB.
	THI	R5,MU.EIU		:IS IT THE LAST SEGMENT?
	JN	H.RCL0			:JUMP IF SO
H.RCL1	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG SEGMENT
	JAL	R5,R.PBRC,,		:RELEASE BUF CHAIN
	LR	R3,R10			:COPY PTR TO MUCB
	JAL	R4,PBB,,		:RELEASE BUF WITH MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN

:LAST SEGMENT BUT NOT THE FIRST SEGMENT.
H.RCL0	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,BBUFER+MURHF1,R10,	:CLEAR 1ST BYTE OF RH
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGIN ADDR
	JNFS	H.RCLK			:JUMP IF LU-LU
	BBLSCB	R5,LUCTAB+LUSSCB,R9,	:GET SSCP-LU SCB POINTER
	JFS	H.RCLL			:JUMP TO CONTINUE
H.RCLK	BBLSCB	R5,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
H.RCLL	LHL	R5,SCBBLK+SCTRNG,R5,	:GET CT POINTER
	BBLOAD	R5,CMDBLK+CLARG,R5,	:GET CT BUFFER ADDR
					:(f03/12/15/87/DB/START)
:	LB	R5,BBUFER+CLARG5+1,R5,	:GET RH BYTE 2
:	STB	R5,BBUFER+MURHF2,R10,	:UPDATE 2ND BYTE OF RH
	LB	R6,BBUFER+CLARG5+1,R5,	:GET RH BYTE 2
	STB	R6,BBUFER+MURHF2,R10,	:UPDATE 2ND BYTE OF RH
	LB	R6,LUCTAB+LULUST,R9,	:GET EXR INDICATOR
	THI	R6,LUDPERP		:EXR?
	JE	H.RCL2,,		:NO
	NHI	R6,@LUDPERP		:YES
	STB	R6,LUCTAB+LULUST,R9,	:CLEAR EXR INDICATOR
	LHI	R0,LUOFSN		:GET NEW SENSE CODE
	STH	R0,BBUFER+CLARG1,R5,	:REPLACE OLD SENSE CODE IF EXR
	J	H.RCL2
					:(F03/12/15/87/DB/END)

:BANNER MESSAGE IS DISCARDED FOR VHR LOCAL MODE, BUT VHR SENDS +RSP
:ANYWAY. OTHERWISE VTR IS NOT ABLE TO SEND BIND.
H.RCLN	EQ	.
	IF	VHRSUP
	LB	R5,LUCTAB+LUCVHR,R9,	:GET VHR STATE BYTE
	THI	R5,LUVHRF		:VHR LU?
	JEFS	H.RCL2			:JUMP IF NOT
	XR	R0,R0			:OTHERWISE INDICATE +RSP
:	JFS	H.RCL4			:JUMP TO CONTINUE
	J	H.RCL4			:JUMP TO CONTINUE(3.F02/8/27/87/ACH)
	EI
:(3.F02/08/24/87/ACH/BEGIN)
H.RCL5
	LHL	R5,LUCTAB+LUCLNC,R9,
	LB	R5,LNCTAB+LNCNFG,R5,
	NHI	R5,LN.CLR		:IS THIS CLEAR?
	JN	H.RCL4
:(3.F02/08/24/87/ACH/END)

:ISSUE -RSP(831). SEGMENT ITSELF IS DISCARDED.
H.RCL2	LHI	R0,LUOFSN		:POWER OFF SENSE CODE FOR -RSP
	LB	R5,LUCTAB+LUCSCC,R9,	:GET NON-CLEAR STORAGE BYTE
	OHI	R5,LUSVCF		:SHOW -RSP(FMD) ISSUED
	STB	R5,LUCTAB+LUCSCC,R9,	:UPDATE NON-CLEAR STORAGE BYTE
H.RCL4	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG SEGMENT
	JAL	R5,R.PBRC,,		:RELEASE BUF WITH MSG SEG
	J	H.RCF9			:KEEP MUCB FOR RSP

:FIRST SEGMENT OF A MESSAGE. EXAMINE RH AND VECTOR EXECUTION
:DEPENDING ON RU CATEGORY.
H.RCL6	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,MU.CTG		:GET RU CATEGORY
	SRLS	R5,4			:MAKE A HALF-WORD INDEX
	LHL	R5,H.RCLT,R5		:GET PTR TO PROCESSING ROUTINE
	J	L.BASE,R5,,		:VECTOR EXECUTION

:TABLE OF PROCESSING ROUTINES DEPENDING ON RU CATEGORY
H.RCLT	HC	H.RCFM-L.BASE		:PTR TO FMD PROC ROUTINE
	HC	H.RCNC-L.BASE		:PTR TO NC PROC ROUTINE
	HC	H.RCDF-L.BASE		:PTR TO DFC PROC ROUTINE
	HC	H.RCSC-L.BASE		:PTR TO SC PROC ROUTINE

:PROCESSING ROUTINE FOR THE 1ST SEGMENTS OF FMD'S.
:
:FIRST SEPARATE REQUESTS AND RESPONSES.
H.RCFM	LB	R1,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R1,MU.RRI		:IS IT A REPONSE?
	JN	H.RCL1			:DISCARD IF SO

:THIS IS A REQUEST. DISCARD IT.
:IF IT IS THE LAST SEGMENT OF RQ GENERATE -RSP.
					:(F03/12/15/87/DB/START)
	THI	R1,MU.SDI		:SDI SET?
	JEFS	H.RCF3			:no
	LB	R5,LUCTAB+LULUST,R9,	:yes
	OHI	R5,LUDPER		:SET INDICATOR
	STB	R5,LUCTAB+LULUST,R9,	:...
H.RCF3
					:(F03/12/15/87/DB/END)
	LB	R5,BBUFER+MUBIUF,R10,	:GET 1ST BYTE OF TH
	THI	R5,MU.EIU		:IS IT THE LAST SEGMENT?
	JE	H.RCL1			:DISCARD MSG&MUCB IF NOT
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET RU POINTER
	L	R1,BBUFER-1,R1,		:GET 3 BYTES OF RQ CODE
	J	H.RCLN			:DISC MSG&GEN -RSP IF SO

:GENERATE RESPONSE AND SEND IT TO DFC.SEND.
H.RCF9	JAL	R5,L.GNRP,,		:GENERATE RESPONSE
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	NHI	R5,MU.CTG		:GET RU CATEGORY
	CLHI	R5,MU.SC		:SC?
	JN	H.RCFV			:JUMP IF NOT
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R5,BBUFER,R5,		:GET RU CODE
	CLHI	R5,BIND			:BIND?
	JEFS	H.RCFU			:JUMP IF SO
	CLHI	R5,UNBIND		:UNBIND?
	JEFS	H.RCFU			:JUMP IF SO
	LHI	R2,TCSCSD		:DESTINATION TC.SC.SEND
	JFS	H.RCFY			:JUMP TO CONTINUE
H.RCFU	LHI	R2,PMCSMS		:DESTINOTION PU.CSC
	JFS	H.RCFY			:JUMP TO CONTINUE
H.RCFV	LHI	R2,DFCSND		:DESTINATION DFC.SEND
H.RCFY	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LIS	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND THE RESPONSE
	JR	R14			:AND RETURN

::::::::::::::::::::
:: RECEIVED MESSAGE OF NC CATEGORY. SERIOUS DESIGN PROBLEM.
H.RCPC
H.RCQC
H.RCNC	JAL	R10,CRASH,,
	HC	0
	BC	4*R5,CR.IMG

::::::::::::::::::::
:: RECEIVED MSG OF DFC CATEGORY IN LOCAL MODE OR PENDING MODE.
:: IF RESPONSE DISCARD IT. IF RQ TRY TO REPLY WITH -RSP(831).
H.RCDF	LHI	R0,LUOFSN		:POWER OFF SENSE CODE
	BBLOAD	R1,BBUFER+MURUPT,R10,	:GET POINTER TO RU
	LB	R1,BBUFER,R1,		:GET RQ CODE
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:IS IT RQ OR RSP?
	JE	H.RCL4			:GO ISSUE -RSP IF RQ
	J	H.RCL1			:GO DISCARD IF RSP

::::::::::::::::::::
:: RECEIVED MSG OF SC CATEGORY IN LOCAL MODE OR PENDING MODES.
:  SHOULD BE BIND OR UNBIND.
:: REPLY WITH -RSP(BIND). CURRNET SENSE CODE IS 80A -
:  SSCP WILL NOT BE NOTIFIED.
:  REPLY +RSP(UNBIND).
:  TRY -RSP(831) FOR THE REST OF SC RQ'S.
:  IF RECEIVED UNBIND IN PEING LOCALAL MODE GO INTO CLEANUP SUBSTATE.
H.RCSC	IF	VHRSUP
	LB	R0,LUCTAB+LUCVHR,R9,	:GET VHR STATE
	THI	R0,LUVHRF		:VHR FUNCTION?
	JN	H.RVRS			:JUMP IF SO
	EI
	LHI	R0,LUNNSN		:PREPARE NO NOTIFICATION SENSE CD
	BBLOAD	R5,BBUFER+MURUPT,R10,	:POINT TO RU
	LB	R1,BBUFER,R5,		:GET RQ CODE
	CHI	R1,BIND			:IS IT BIND?
	JNFS	H.RCSV			:JUMP IF NOT
	IF	BNDNTF
	LHI	R0,LUNFSN		:SSCP WILL BE NOTIFIED S C (4/22/85/CHS)
	EI				:(4/22/85/CHS, END OF INSERTION)
	LB	R5,LUCTAB+LUCSCC,R9,	:GET NON-CLEAR STORAGE BYTE
	OHI	R5,LUSVCB		:SHOW -RSP(BIND) ISSUED
	STB	R5,LUCTAB+LUCSCC,R9,	:UPDATE NON-CLEAR STORAGE BYTE
	J	H.RCL4			:JUMP TO ISSUE -RSP(BIND)
H.RCSV	XR	R0,R0			:PREPARE +RSP FOR UNBIND
	CHI	R1,UNBIND		:IS IT UNBIND
:	JN	H.RCL2			:TRY -RSP(831) IF NOT
	JN	H.RCL5			:TRY -RSP(831)(3.F02/08/24/87/ACH)
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	NHI	R5,@LUSBST&@WAITRS	:LEAVE STATE INFORMATION ONLY
	CHI	R5,PLCSTA		:PENDING LOCAL?
	JN	H.RCL4			:JUMP TO SEND +RSP(UNBIND) IF NOT
	OHI	R5,LUPLCL-1		:GO TO CLEAN-UP SUBSTATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	IF	BNDNTF			:(4/29/85/CHS, START)
	BBLSCB	R3,LUCTAB+LUSSCB,R9,	:GET SCB POINTER
	LH	R5,SCBBLK+SCTSNG,R3,	:GET GET PTR OF NORM SEND CT
	CLH	R5,SCBBLK+SCTSNR,R3,	:CORRELATION TABLE EMPTY?
	JN	H.RCL4			:DO NOT SEND NOTIFY IF NOT
	BBLOAD	R3,BBUFER+MUCBTU,R10,	:GET PTR TO MSG SEGMENT
	JAL	R5,R.PBRC,,		:RELEASE BUF WITH MSG SEG
	JAL	R5,L.GNRP,,		:GENERATE RESPONSE
	LHI	R2,PMCSMS		:DESTINATION PU.CSC
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LHI	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND THE RESPONSE
					:(3.f01/07/14/87/db/start)
	BBLSCB	R3,LUCTAB+LUSSCB,R9,	:SSCP-LU SESSION ACTIVE?
	JE	H.RCS1			:NO, DON'T NOTIFY
	LB	R5,SCBBLK+SCFSMS,R3,
	LB	R5,SCBBLK+SCSTAT,R5,R3,
	CLHI	R5,FS.ST3		:ACTIVE SESSION?
	JN	H.RCS1			:NO
	LB	R5,SCBBLK+SCSTAT+FSCIRS,R3,
	CLHI	R5,FS.ST2
	JE	H.RCS1
					:(3.F01/07/14/87/DB/END)
	LA	R8,NTFYNC,,		:SEND NOTIFY (NOT READY)
	LHI	R0,NTFYLG+3		:CANNED NOTIFY MSG LENGTH
	JAL	R5,L.DFSL,,		:GENERATE CANNED NOTIFY
	LB	R5,BBUFER+MURHF1,R10,	:GET RH BYTE 1
	NHI	R5,@MU.CTG		:CORRECT MU.CTG
	STB	R5,BBUFER+MURHF1,R10,	:UPDATE RH BYTE 1
	LHI	R2,DFCSND		:DESTINATION DFC.SEND
	LHI	R1,LURCV		:ORIGINATION LU.RCV
	LHI	R0,SG.NOS		:NO SIGNAL
	JAL	R8,SEND,,		:SEND THE NOTIFY
H.RCS1					:(3.F01/07/14/87/DB)
	JR	R14			:AND RETURN
	ELSE				:(BNDNTF)
	J	H.RCL4			:JUMP TO SEND +RSP(UNBIND)
	EI	(BNDNTF)			:(4/29/85/CHS, END)
	EI				:END OF RECEIVE LOGIC FOR HOST IF

	IF	VHRSUP
::::::::::::::::::::::::::
:: RECEIVED MESSAGE OF SC CATEGORY IN LOCAL OR PENDING MODES.
:: CONTINUE AS NORMAL IF NOT BIND OR UNBIND.
H.RVRS	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
	JE	H.RCL2			:JUMP IF NO LU-LU SESSION
	BBLOAD	R5,BBUFER+MURUPT,R10,	:GET RU POINTER
	LB	R1,BBUFER,R5,		:GET RQ CODE
	CHI	R1,BIND			:BIND?
	JEFS	H.RVR0			:JUMP IF SO
	CHI	R1,UNBIND		:UNBIND?
	JN	H.RCL2			:JUMP IF NOT
H.RVR0	LB	R5,LUCTAB+LULUST,R9,	:GET LU_SVC STATE BYTE
	SRLS	R5,5			:LEAVE STATE INFO ONLY
	LHL	R5,H.RVRB,R5,R5		:GET PROCESSING ROUTINE
	J	L.BASE,R5,		:JUMP TO PROCESSING ROUTINE

:VHR BIND/UNBIND STATE PROCESSING TABLE
H.RVRB	HC	H.RVRT-L.BASE		:TRANSPARENT STATE
	HC	H.RVRL-L.BASE		:LOCAL MODE
	HC	H.RVRR-L.BASE		:PENDING TRANSPARENT
	HC	H.RVRC-L.BASE		:PENDING LOCAL

:VHR FUNCTION SHOULDN'T HAVE GOTTEN INTO TRNASPARENT STATE
H.RVRT	JAL	R10,CRASH,,
	HC	0
	HC	4*R5,CR.IMG

:FOR LOCAL MODE GIVE +RSP FOR UNBIND. FOR BIND NOTIFY NIO, GO
:INTO PENDING TRANSPARENT STATE AND WAIT WITH +RSP(BIND) UNTIL
:ACKNOLEDGEMENT FROM NIO.
H.RVRL	XR	R0,R0			:ASSUME +RSP FOR UNBIND
	CHI	R1,UNBIND		:UNBIND?
	JE	H.RCL4			:JUMP IF SO
	LHL	R5,BBUFER+MUSNF,R10,	:GET SEQUENCE NUMBER FIELD
	STH	R5,SCBBLK+SCRESN,R7,	:SAVE IT INTO SCB
	LHI	R0,SNRQLG^8!SNRQBD	:LOGON REQUEST TO NIO
	JAL	R5,L.PTCD,,		:PASS IT TO NIO
	LHI	R5,PTRSTA		:PENDING TRANSPARENT
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE BYTE
	J	H.RCL1			:JUMP TO DISCARD MESSAGE&MUCB

:PENDING TRANSPARENT. NOTHING SHOULD HAVE COME FROM THE HOST
:BECAUSE BIND RESPONSE WAS NOT SENT YET. IF SOMETHING CAME
:TRY TO SEND -RSP(BIND) WITHOUT NOTIFYING NIO THE SECOND TIME.
:IF THIS IS UNBIND NOTIFY NIO AND GO TO PENDING LOCAL STATE.
H.RVRR	STM	R0,LURGS1,,		:SAVE ALL REGISTERS
	LHI	R0,LUNNSN		:PREPARE -RSP FOR PREV BIND
	LHI	R1,BIND			:RQ CODE OF PREV BIND
	JAL	R8,L.GNSR		:GENERATE SC RSP
	LM	R0,LURGS1,,		:RESTORE ALL REGISTERS
	LHL	R5,BBUFER+MUSNF,R10,	:GET CURRENT SNF
	STH	R5,SCBBLK+SCRESN,R7,	:SAVE IT IN SCB
	CHI	R1,BIND			:BIND?
	JE	H.RCL1			:DISCARD MSG&MUCB IF SO
	J	H.RDVV			:OTHERWISE JUMP TO NOTIFY NIO

:PENDING LOCAL MODE. BIND SHOULD NOT BE RECEIVED, -RSP TO BIND.
:UNBIND WILL CAUSE GOING TO CLEANING SUBSTATE OF PENDING LOCAL MODE.
H.RVRC	LHI	R0,LUNNSN		:PREPARE -RSP FOR BIND
	CHI	R1,BIND			:BIND?
	JE	H.RCL4			:JUMP TO SEND -RSP IF SO
	LHI	R5,PLCSTA!LUPLCL-1	:CLEANING IN PENDING LOCAL MODE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LU_SVC STATE BYTE
	XR	R0,R0			:+RSP FOR UNBIND
	J	H.RCL4			:JUMP TO SEND IT
	EI

::::::::::::::::::::::::::
:: SIGNAL RECEIVED FROM LOWER SNA LAYERS.
:: VALID SIGNALS ARE RESET AND BETB.
L.RCSG	CHI	R5,SG.BTB		:IGNORE IF BETB
	JER	R14			:RETURN IN THIS CASE
	L	R7,NCBBLK+NDSSCB,R13,	:GET SCB POINTER
	IF	TERMIF&HOSTIF		:IF BOTH TERM AND HOST IF SYSGENED
	CHI	R3,PU.T4		:TERMIF?
	JNFS	L.RCSH			:JUMP IF HOST
	EI
	IF	TERMIF
	LB	R6,SCBBLK+SCOTID,R7,	:GET LOCAL ID
	EI
	IF	TERMIF&HOSTIF
	JFS	L.RCST			:JUMP TO CONTINUE
	EI
	IF	HOSTIF
L.RCSH	LB	R6,SCBBLK+SCMYID,R7,	:GET REMOTE ID
	EI
L.RCST	AH	R6,LUCTAB+LUCT.D,R9,	:REL ID # FOR THE INTERFACE
	LHL	R9,LUCPTR,R6,R6		:GET LUCB POINTER
	LB	R6,EVBLK+EVSPRO,R12,	:GET SENDING PROC ID
	STB	R6,LUCTAB+LULUW2,R9,	:STORE IT
	THI	R9,LUINV		:IS IT VALID?
	JN	L.NOLU			:JUMP IF NOT
	CHI	R5,SG.RES		:IS THE SIGNAL RESET?
	JE	L.RSET			:JUMP TO RESET ROUTINE IF SO
	CHI	R5,SG.UNB		:UNBIND SIGNAL?
	JE	L.INRS			:JUMP TO INFORM NIO AND RESET
	CHI	R5,SG.ZAP		:ZAP SIGNAL?
	JE	L.RSET			:JUMP TO RESET ROUTINE IF SO
	CHI	R5,SG.ERR		:ERROR SIGNAL?
	JE	L.ERRS			:JUMP TO ERROR RESET
	CHI	R5,SG.LDW		:LINE DOWN SIGNAL?
	JE	L.IMRS			:JUMP TO IMMEDIATE RESET
	IF	HOSTIF
	CHI	R5,SG.RTN		:RETURN SIGNAL?
	JE	L.RTRN			:JUMP IF SO
	EI
	CHI	R5,SG.BTB		:IS IT BETB?
	JER	R14			:IGNORE IT
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R5,CR.WSG		:WRONG SIGNAL CRASH CODE

::::::::::::::::::::::::::
:: NOTIFICATION PROCESSING ROUTINES FOR RECEIVE SIDE.
::
:: THE NOTIFICATIONS ARE GENERATED BY SEND PROCEDURES (DFC.SEND,
:: TC.SC.SEND AND CSC.SEND). IN TRANSPARENT MODE THE NOTIFICATIONS
:: WILL COME TO THE SENDING ROUTINES ONLY. SO THIS CODE
:: IS VALID FOR LOCAL AND PENDING MODES ONLY.
::
:: NEGATIVE NOTIFICATIONS SHOULDN'T HAVE HAPPENED.
:: POSITIVE NOTIFICATIONS ARE DISCARDED IN PENDING MODES. IN LOCAL MODE
:: POSITIVE NOTIFICATIONS ARE DISCARDED EXCEPT IN CASE OF NOTIFICATION
:: FOR POSITIVE RESPONSE FOR SSCP-LU FMD. THIS RESPONSE IS LOCALLY
:: GENERATED BY RECEIVE PROCESS IF SSCP-LU FMD WAS RECEIVED IN LOCAL
:: MODE (THE MESSAGE ITSELF IS DISCARDED BY RECEIVE ROUTINE). THIS
:: ROUTINE WILL SEND SSCP-LU DATA MESSAGE REQUESTING THE TERMINAL
:: OPEARATOR TO GO BACK TO LU-LU SCREEN.
H.RCNT
L.RCNT	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE CHECK BYTE
	IF	TERMIF&(1-HOSTIF)
	JEFS	L.RCN1			:JUMP IF OK
	EI
	IF	(1-TERMIF)&HOSTIF
	JER	R14			:RETURN IF OK
	EI
	IF	TERMIF&HOSTIF
	JNFS	L.RCN0			:CRASH IF NOT OK
	LB	R5,NCBBLK+NDPUTY,R13,	:GET NODE TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JEFS	L.RCN1			:JUMP IF SO
	JR	R14			:OTHERWISE RETURN
	EI
L.RCN0	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R5,CR.NCK		:NEG SENS-CHK SHOULDN'T HAPPEN

	IF	TERMIF
:DISCARD POSITIVE NOTIFICATION IF NOT SSCP-LU FMD RSP.
L.RCN1	BBLOAD	R5,BBUFER+MUCBTU,R10,	:CHECK PTR TO BTU
	JNFS	L.RCNA			:JUMP IF MSG NOT DISCARD
	LR	R3,R10			:OTHERWISE COPY MUCB PTR
	JAL	R4,PBB,,		:RELEASE MUCB
	JAL	R4,R.PBB,,		:COUNT IT
	JR	R14			:AND RETURN
L.RCNA	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGINATION ADDR
	JNR	R14			:RETURN IF LU-LU
	LB	R5,BBUFER+MURHF1,R10,	:GET 1ST BYTE OF RH
	THI	R5,MU.RRI		:IS IT REQUEST?
	JER	R14			:RETURN IF SO
	NHI	R5,MU.CTG		:GET RU CATEGORY
	JNR	R14			:JUMP IF NOT FMD

:IT WAS SSCP-LU FMD RESPOSE. GENERATE "GO BACK TO LU-LU" MESSAGE
:TO TERMINAL OPERATOR.
:FIRST COPY MUCB, THEN CALL SUBROUTINE GENERATING THE MESSAGE.
	JAL	R4,GBB,,		:GET BUFFERLET FOR MUCB
	J	L.NBUF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBB,,		:COUNT THE BUFFERLET
	LHI	R5,MULENG-1		:GET MUCB LENGTH - 1
L.RCN2	LB	R4,BBUFER,R10,R5	:GET NEXT BYTE OF OLD MUCB
	STB	R4,BBUFER,R3,R5		:COPY INTO NEW MUCB
	SIS	R5,1			:DECREASE COUNTER
	JGEBS	L.RCN2			:CONTINUE TO COPY UNTIL FINISHED
	LR	R10,R3			:COPY POINTER TO NEW MUCB
	LB	R5,BBUFER+MUOADP,R10,	:GET ORIGIN ADDR
	LB	R4,BBUFER+MUDADP,R10,	:GET DEST ADDR
	STB	R5,BBUFER+MUDADP,R10,	:UPDATE DEST ADDR
	STB	R4,BBUFER+MUOADP,R10,	:UPDATE ORIGIN ADDR
	LHI	R0,SNERR^8!SNERRD	:PREPARE REDISPLAY COMMAND
	JAL	R5,L.PTCD,,		:PASS IT TO NIO
	LHL	R8,LUDRMG,,		:ASSUME ENGLISH VERSION
	LB	R5,LUCTAB+LUCDIF,R9,	:SEE IF KATAKANA AND KANJI
	NHI	R5,07			:...
	CLHI	R5,4			:KATAKANA = 4, KANJI =5
	JLFS	L.RCNY			:ENGLISH VERSION, SKIP
	LHL	R8,LUDRMG+2,,		:ELSE, JAPANESE VERSION
L.RCNY
	AI	R8,PSEG
	LHL	R1,0,R8			:GET MSG LENGTH
	AIS	R8,2			:R8 = ADDR OF "DISCARDED" MSG
	J	L.RCR6			:JUMP TO GEN MSG AND RETURN

::::::::::::::::::::::::::
:: NOTIFICATION PROCESSING ROUTINE IN PENDING MODES.
:: CRASH ON NEGATIVE NOTIFICATIONS AND DISCARD POSITIVE.
L.RCPN	LB	R5,BBUFER+MUSCHK,R10,	:GET SENSE-CHECK BYTE
	JER	R14			:RETURN IF POSITIVE NOTIFICATION
	JAL	R10,CRASH,,		:OTHERWISE CRASH
	HC	0
	BC	4*R5,CR.NCK		:WITH NEG CHECK CRASH CODE
	EI

::::::::::::::::::::::::::
:: RESET ROUTINE FOR TERMINAL INTERFACE.
:: SEND UNBIND AND PUT US IN BAD SUBSTATE. ACTUAL CLEANING WILL BE
:: DONE IN TIMEOUT PROCESSING ROUTINE. THE REASON IS THAT WE
:: HAVE TO WAIT UNTIL UNBIND WAS SENT AND (POSSIBLY) UNBIND RSP WAS
:: RECEIVED BEFORE CLEANING NTW->SNA DATA QUEUE AND SCB.
:
:: FOR HOST INTERFACE THIS ROUTINE QUEUES STATR COMMAND IN FRONT OF
:: NTW->SNA DAT QUEUE AND PUTS LUSVC IN PENDING LOCAL MODE (LOCAL MODE
:: IS RESET STATE FOR HOST INTERFACE).
:: THE FOLLOWING THINGS OCCUR CURRENTLY BEFORE CLEANING NTW->SNA DATA
:: QUEUE AND SCB.
:: SEND ROUTINE IN PENDING LOCAL MODE WILL TRY TO ISSUE RSHUTD AND
:: THEN SET TIMER FOR CLEANUP PROCESS WHICH WILL DO THE ACTUAL CLEANUP
:: AND TRANSFER TO LOCAL MODE.
:
:  IF RESET SIGNAL WAS REQUEST TO UNBIND INFORM NIO FIST.
L.INRS	LHI	R0,SNERR^8!SNERST	:ERROR CMD TO NIO
	LR	R8,R5			:SAVE R5 (06/12/84/CHS)
	JAL	R5,L.PTCD,,		:INFORM NIO
	LR	R5,R8			:RESTORE R5 (06/12/84/CHS)
L.RSET	SIS	R5,1			:SIGNAL-1
	LB	R4,LUCTAB+LULUW1,R9,	:GET LUSVC WORK BYTE 1
	NHI	R4,@LULUSL		:CLEAR SIGNAL BITS
	OR	R4,R5			:SAVE SIGNAL
	STB	R4,LUCTAB+LULUW1,R9,	:UPDATE LUSVC WORK BYTE 1
	IF	TERMIF&HOSTIF
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JN	H.RSET			:JUMP IF NOT
	EI
	IF	TERMIF
	BBLSCB	R7,LUCTAB+LULSCB,R9,	:GET LU-LU SCB POINTER
:	THI	R7,LUINV		:IS IT VALID?
:	JE	L.RSE1			:JUMP IF SO
	JN	L.RSE1			:JUMP IF VALID
L.RSE0	LB	R5,LUCTAB+LULUWK,R9,	:OTHERWISE GET LUSVC WORK BYTE
	OHI	R5,LULUSO		:FAKE SC OUTSTANDING
	NHI	R5,LULUFN		:RESET FINAL BIT
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R5,LOCSTA!LUBDST	:PUT US IN BAD SUBSTATE OF LOC ST
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	JR	R14			:AND RETURN
L.RSE1	LB	R5,SCBBLK+SCSTAT+FSCLLP,R7,	:GET SESS FSM STATE
	CHI	R5,FS.ST1		:STATE 1?
	JE	L.RSE0			:CANNOT SEND UNBIND IF SO
	CHI	R5,FS.ST4		:STATE GREATER THAN 4?
	JG	L.RSE0			:CANNOT SEND UNBIND IF SO
:	CHI	R5,FS.ST8		:STATE 8
:	JE	L.RSE0			:CANNOT SEND UNBIND IF SO
	LA	R8,UBDCAN,,		:POINT TO CANNED UNBIND MSG
	LHI	R0,UBDLGT+3		:LENGTH OF UNBIND RU + RH
	JAL	R5,L.SCRQ,,		:GENERATE UNBIND
:L.RSE2	OHI	R5,LOCSTA!LUBDST	:PUT US IN BAD SUBST OF LOC ST
L.RSE2	LHI	R5,LOCSTA!LUBDST	:PUT US IN BAD SUBST OF LOC ST(06/12/84/CHS)
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	LB	R5,LUCTAB+LULUWK,R9,	:GET LUSVC WORK BYTE
	NHI	R5,@LULUFN		:RESET FINAL BIT FOR TIMEOUT
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	LHI	R2,PMCSMS		:DEST COM SESS CONT FOR UNBIND
	LHI	R1,LURCV		:ORIGINATION LURCV
	LHI	R0,SG.NOS		:SEND NO SIGNALS
	JAL	R8,SEND,,		:SEND DQE
	JR	R14			:AND RETURN
	EI

	IF	HOSTIF
H.RSET	JAL	R4,GETCL,,		:GET CMD LINK FOR START CMD
	J	L.CLRR			:JUMP IF NONE AVAILABLE
	LHL	R7,LUCTAB+LUSNDG,R9,	:GET NTW->SNA GET PTR
	STH	R6,LUCTAB+LUSNDG,R9,	:UPDATE IT WITH PTR TO NEW LNK
	STH	R7,CMDBLK+CLPTR,R6,	:LINK OLD LINK TO NEW
	LHI	R0,NSSTLG^8		:PREPARE START CMD
	STH	R0,CMDBLK+CLCMD,R6,	:PUT IT IN NEW LINK
	LHL	R6,LUCTAB+LUCT.N,R9,	:GET LUCTAB REL ID #
	SBT	R6,DPNWSN		:SET DATA CMD PRESENT
	LHI	R5,PLCSTA		:PREPARE PENDING LOCAL STATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:UPDATE LUSVC WORK BYTE
	JR	R14			:AND RETURN
	EI

::::::::::::::::::::::::
:: IMMEDIATE RESET ROUTINE. CLEANING IS PERFORMED IMMEDIATELY.
L.IMRS	SIS	R5,1			:SIGNAL-1
:	LB	R4,LUCTAB+LULUW1,R9,	:GET LUSVC WORK BYTE 1
:	OR	R4,R5			:SAVE SIGNAL
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC WORK BYTE 1
L.IMR1	JAL	R12,L.CLEA,,		:CLEAN LUSVC
	JR	R14			:AND RETURN

:::::::::::::::::::::::::::
:: RESET AFTER ERROR. CLEANING IS PERFORMED WHEN THIS SIGNAL IS RECEIVED
:: SECOND TIME IN A ROW. FIRST TIME LUSVC GOES IN BAD STATE.
:: FOR HOST INTERFACE GENERATE UNBIND-LIKE MESSAGE TO INFORM TERMINAL
:: INTERFACE THAT ERROR SITUATION (ACTLU OR DACTLU DURING LU-LU SESSION)
:: OCCURED.
L.ERRS	SIS	R5,1			:SIGNAL-1
	LB	R4,LUCTAB+LULUW1,R9,	:GET LUSVC WORK BYTE 1
	LR	R6,R4			:COPY IT
	NHI	R6,LULUSL		:GET SAVED SIGNAL
	CR	R5,R6			:SECOND TIME?
	JE	L.IMR1			:JUMP TO CLEAN IF SO
:	OR	R4,R5			:OTHERWISE SAVE SIGNAL
	STB	R5,LUCTAB+LULUW1,R9,	:UPDATE LUSVC WORK BYTE
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE BYTE
	OHI	R5,LUBDST		:GO TO BAD SUBSTATE
	STB	R5,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUWK,R9,	:CLEAR LUSVC WORK BYTE

:FOR HOST INTERFACE GENERATE UNBIND WITH UNUSABLE REASON. IT IS SENT
:TO TERMINAL INTERFACE TO INFORM IT OF THE ERROR CONDITION.
	IF	HOSTIF
	IF	TERMIF
	LB	R5,NCBBLK+NDPUTY,R13,	:GET PU TYPE
	CHI	R5,PU.T4		:TERMINAL INTERFACE?
	JER	R14			:JUMP IF SO
	EI
	LB	R5,LUCTAB+LULUST,R9,	:GET LUSVC STATE
	NHI	R5,@(LUSBST!WAITRS)	:LEAVE STATE INFORMATION ONLY
	JNR	R14			:EXIT IF NOT TRANSPARENT
	JAL	R4,GBB,,		:GET A BUFFERLET
	J	L.NBUF			:JUMP IF NONE AVAILABLE
	JAL	R4,R.GBR,,		:COUNT IT
	LHI	R5,(FID2^4!MU.EFI!MU.BIU!MU.EIU)^8	:1ST 2 BYTES OF TH
	STH	R5,BBUFER,R3,,		:STORE THEM
	STH	R5,BBUFER+4,R3,,	:DO NOT CARE OF SEQ#
	LB	R5,LUCTAB+LUCADR,R9,,	:DESTINATION IS SECONDARY
	STB	R5,BBUFER+2,R3,,	:STORE IT IN BUFFER
	LB	R5,LUCTAB+LUPRIL,R9,,	:ORIGINATION IS PRIMARY
	STB	R5,BBUFER+3,R3,,	:STORE IT IN BUFFER
	LHI	R5,(MU.SC!MU.FI!MU.BCI!MU.ECI)^8!MU.DR1	:BYTES 1&2 OF RH
	STH	R5,BBUFER+6,R3,,	:STORE THEM IN BUFFER
	LHI	R5,UNBIND		:3RD BYTE OF RH & RU CODE
	STH	R5,BBUFER+8,R3,,	:STORE THEM IN BUFFER
	LHI	R5,UBDRSN		:GET NON-SNA REASON
	STB	R5,BBUFER+0A,R3,,	:STORE IT IN BUFFER
	LIS	R2,UBDLGT+9		:OVERALL LENGTH OF BIU
	LHI	R0,SNETEM^8		:SEND IT END-TO-END
	JAL	R5,L.PTCD,,		:PASS IT TO NIO
	EI
	JR	R14			:AND RETURN

:: RETURN SIGNAL IS RECEIVED. THIS SIGNAL IS GENERATED IF APPLICATION
:: TIMEOUT IS SPECIFIED AND ACTLU WAS RECEIVED FROM THE HOST. RETURN
:: TO ORIGINAL END-TO-END STATE INDICATED IN DCB WHEN CONNECTION WAS
:: ESTABLISHED. THE CODE AND SIGNAL IS VALID FOR HOST INTERFACE ONLY.
	IF	HOSTIF
L.RTRN	XR	R5,R5			:CLEAR THE REGISTER
	STB	R5,LUCTAB+LULUW2,R9,	:PREVENT SENDING RESPONSE SIGNAL
	JAL	R12,L.CLEA,,		:CLEAN LU SERVICE
	LHL	R5,LUCTAB+LUCT.N,R9,	:GET OVERALL LU #
	TBT	R5,BDPDLU,,		:ACTLU PENDING?
	JER	R14			:RETURN IF NOT
	LHL	R4,LUCTAB+LUCDCB,R9,	:GET POINTER TO DCB
	JER	R14			:RETURN IF NO DCB
	IF	HDPSUP
	LIS	R0,D.BDSP		:POINT TO MODE BIT
	TBT	R0,DCBLKS+DCBMOD,R4,	:DSP MODE?
	JE	L.RTRT			:JUMP IF NOT
:
:BEGIN (03/17/86 YLH)
:	IF THE SYS/RQ KEY IS SUPPORTED, SEND THE TIF WITH THE UNOWNED STATE
:
	IF	HDPSUP
	GL	LUSCRN,H.SNST,LUSFUW
	LB	R0,LUCTAB+LUCSCN,R9,	:GET SCREEN STATE
	JE	L.RTN1			:JUMP IF NO SCREEN CONTROL
	LHI	R5,LUSCRN!LUSFUW	:SET FORCE UNOWNED AND RETAIN SCREEN CONTROL
	LHI	R4,HSTINI		:HOST INITIATED
	JAL	R6,H.SNST		:SEND SCREEN STATUS TO TIF
	STB	R5,LUCTAB+LUCSCN,R9,	:UPDATE SCREEN STATUS
	EI
:
:END (03/17/86 YLH)
:
L.RTN1	LHI	R4,DSPSTA		:PREPARE DSP STATE
	JFS	L.RTRR			:JUMP TO CONTINUE
	EI
L.RTRT	LHI	R4,TRPSTA		:PREPARE TRANSPARENT STATE
L.RTRR	STB	R4,LUCTAB+LULUST,R9,	:UPDATE LUSVC STATE BYTE
	JR	R14			:AND RETURN
	EI

:NO BUFFERLETS OR NO CMD LINKS.
L.CLRR	J	L.CLER,,		:JUMP
L.NBUF	J	NOBUFF,,		:JUMP

	FO	MAIN	
	FO	SNTPKG
	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER
	FO	OSCAN			:(01/27/87 YLH)

	EM
  
	SUBTTL	SNA PACKAGE(MAIN PROCESSES) - NETWORK CONTROL QUEUE HANDLER

	RA	0
	MO	.,SNAPKG

:	--------------------------------------------------------------------
:	THIS PACKAGE IS DESIGNED TO SUPPORT NETWORK CONTROL WHICH CONTAINS-
:	M.DQCR	- NM.Q_CMD_RCV (COMMAND RECEIVE QUEUE FROM NETWORK IO)
:	L.SEND	- NM.Q_DATA_RCV (DATA RECEIVE QUEUE FROM NETWORK IO)
:	-------------------------------------------------------------------

:	==============================================
:	-----NOTE FOR DATA STRUCTURE-----
:	(1)COMMAND LIST BETWEEN NIO AND SNA,
:	   CLCMD (CONTAINS COMMAND CODE,SUCH AS XINIT)
:	   CLCMDS(CONTAINS COMMAND STATUS,SUCH AS NEGATIVE RESPONSE)
:	   CLLNG (CONTAINS COMMAND INFORMATION,SUCH AS SENSE CODE)
:	   CLARG (IGNORE....)
:	===============================================

	SEG	A.CODE

	LO	CMDLST
	LO	CBKDEF
	LO	GBLDEF
	LO	BBUFER


:	M.DQCR	-(NM.Q_CMD_RCV) 
:	-----------------------------------------------------------
:	THE USAGE OF REGISTERS ---
:	INPUT	-RNODE,R12 (EV PTR)
:	LINK	-R14
:	WORKING	:R9 (COMMAND TYPE) R15 (COMMAND INF.) R10 (LUCB PTR)
M.DQCR
	LB	R1,EVBLK+EVISIG,R12,	:GET INPUT SIGNAL
	CLHI	R1,SG.OPQ		:IS IT OPEN-QUEUE?
	JN	M.CRAS			:CRASH,IF NOT NO-SIGNAL

M.DQC0
	LHL	R10,EVBLK+EVLUCB,R12,	:GET PTR TO LUCTAB FOR DESIRED LU
	LHL	R6,LUCTAB+LUSNCG,R10,	:GET GET PTR OF Q_CMD_RCV
:	CLH	R6,LUCTAB+LUSNCR,R10,	:REL PTR (01/03/85 MIA)
	LHL	R9,LUCTAB+LUSNCR,R10,	:GET REL PTR (01/03/85 MIA)
	CR	R6,R9			:COMPARE PTR (01/03/85 MIA)
	JE	M.CRAS			:Q_CMD_RCV IS EMPTY,JUMP
	LHL	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMD PTR (03/12/85 MIA)
	CR	R7,R9			:LAST ENTRY (03/12/85 MIA)
	JNFS	M.DQCA			:JUMP IF NOT (03/12/85 MIA)
	LHL	R9,LUCTAB+LUCT.N,R10,	:GET REL LU # (03/12/85 MIA)
	RBT	R9,CPNWSN,,		:RESET CMD PRESENT (03/12/85 MIA)
M.DQCA	LB	R9,CMDBLK+CLCMD,R6,	:GET CMD TYPE (03/12/85 MIA)
	JE	M.CRAS			:CRASH,IF CMD ERROR
	CLHI	R9,MXSNNW		:IS CMD OUTOF RANGE
	JG	M.CRAS			:CRASH,IF YES
	LB	R15,CMDBLK+CLCMDS,R6,	:GET COMMAND STATUS
	LHL	R8,CMDBLK+CLLNG,R6,	:GET LENGTH BYTE (OR CMD INF.)
:	LH	R7,CMDBLK+CLPTR,R6,	:GET NEXT CMD PTR (03/12/85 MIA)
:	JE	CLERR,,			:CRASH,ERROR (03/12/85 MIA)
	STH	R7,LUCTAB+LUSNCG,R10,	:UPDATE NEW GET PTR
	JAL	R4,RELCL,,		:RELEASE CMD LIST
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NODE CONTROL BLOCK PTR
	LB	R0,NCBBLK+NDPUTY,R13,	:GET PU_TYPE FOR THIS NODE
	CLHI	R0,PU.T5		:IS IT PU TYPE 5
	JE	M.DQC3			:JUMP,IF YES
	CLHI	R0,PU.T4		:IS IT PU TYPE 4
	JE	M.DQC3			:JUMP,IF YES

:	OTHER PU TYPE NEEDS TO BE COMPARED
:	ROUTINE TO HANDLE HOST INTERFACE
:	================================
	LHL	R2,M.DQC1,R9,R9		:GET ROUTINE ENTRY FOR EACH COMMAND
	J	M.DQC1,R2,		:JUMP TO ROUTINE

M.DQC1	HS
	HC	M.CRAS-M.DQC1		:CRASH,ERROR COMMAND CODE
	HC	M.DQC2-M.DQC1		:INIT COMMAND (ACTPU,ACTLU)
	HC	M.DQC2-M.DQC1		:CLOSE CMD (DACTPU,DACTLU)
	HC	M.DQC2-M.DQC1		:LINK DOWN COMMAND
	HC	M.DQC2-M.DQC1		:CIRCUIT DOWN COMMAND

M.DQC2
	LHI	R2,PMNSMS		:SET FOR PU.SVC_MGR.NS.SEND
	J	M.DQC7			:JUMP TO CALL SEND

:	TERMINAL INTERFACE (PU_TYPE 4,5)
:	================================
M.DQC3
	LHL	R2,M.DQC4,R9,R9		:GET ROUTINE ENTRY FOR EACH COMMAND
	J	M.DQC4,R2,		:JUMP TO ROUTINE

M.DQC4	HS
	HC	M.CRAS-M.DQC4		:CRASH,ERROR COMMAND CODE
	HC	M.DQC5-M.DQC4		:INIT COMMAND (ACTPU,ACTLU)
	HC	M.DQC5-M.DQC4		:CLOSE CMD (DACTPU,DACTLU)
	HC	M.DQC5-M.DQC4		:LINK DOWN COMMAND
	HC	M.DQC5-M.DQC4		:CIRCUIT DOWN COMMAND

:	ROUTINE TO HANDLE SSCP_LU,SSCP_PU COMMAND
:	-----------------------------------------
:	INIT COMMAND (ACTPU,ACTLU)
:	CLEAR COMMAND (DACTPU,DACTLU)
M.DQC5
	LHI	R2,SMCSMS		:SET FOR SSCP.SVC_MGR.CS.SEND
	J	M.DQC7			:JUMP TO CALL SEND STATEMENT
:	ROUTINE TO HANDLE LU.SVC COMMAND (INC. LOGON)
:	-----------------------------------------
:	START,TERMINATE AND LOGON COMMAND
M.DQC6
	LHI	R2,LMSSMS		:SET FOR LU.SVC_MGR.SS.SEND
	J	M.DQC7			:JUMP TO CALL SEND STATEMENT

M.DQC7
	JAL	R4,GBB,,
	J	M.CRA1
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LHI	R0,SG.NOS		:CLEAR INPUT SIGNAL
	LHI	R1,NMDQCR		:GET SENDING PROCEDURE #
	STB	R9,BBUFER+DQNWCM,R3,	:STORE COMMAND TYPE INTO DQE
	STH	R10,BBUFER+DQLUCB,R3,	:SET LUCB PTR ???
	BBSTOR	R15,BBUFER+DQPRMP,R3,	:STORE COMMAND INF. (OR DAT PTR.)
	LCS	R7,1			:LOAD -1 INTO OTHER FIELDS
	ST	R7,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R7,BBUFER+DQMUPR,R3,	:SET MUCB PTR TO 'NULL'
	ST	R7,BBUFER+DQSCB,R3,	:SET SCB PARAMETER TO 'NULL'
	STH	R7,BBUFER+DQMULN,R3,	:SET MU CONTAINTS LENGTH TO 0
	JAL	R8,SEND,,		:JUMP TO EXE. 'SEND' STATEMENT

	JR	R14			:RETURN

M.CRAS
	JAL	R10,CRASH,,
	BC	0,0,0,CRQNSN

M.CRA1
	J	NOENT5,,

	FO	CMDLST
	FO	CBKDEF
	FO	GBLDEF
	FO	BBUFER

	EM

	SUBTTL	SNA PACKAGE(DISPATCHER TO SUPPORT SNA LAYERS SCHEDULER)

:	*********************************************************
:	REVISION HISTORY --
:	12/09/83 (NCS) -- ORIGINAL DESIGN AND CODING
:	*********************************************************
:
	RA	0
	MO	.,SNAPKG

	LO	CBKDEF
	LO	CMDLST
	LO	MAIN

	GL	HLSCHD

:	THIS PACKAGE IS DESIGNED TO HANDLE THE HIGH-LEVEL DISPATCHER
:	------------------------------------------------------------

	SEG	A.DATA
	BND	4
DSPSAV	WS	10			:SAVE AREA FOR ALL REGISTERS

	SEG	A.CODE

:	THE TABLE OF PROCEDURES WHICH ARE CALLED BY DISPATCHER AS A 
:	RESULT OF A SEND DONE BY THE SCHEDULER
:	-----------------------------------------------------------
PRONAM	WS
:	WC	HLSCHD			:RESERVED FOR SCHEDULER (6/27/84/CHS)
	WC	CRASH			:NO RECURSIVE CALL, CRASH(6/27/84/CHS)
	WC	P.DQBR			:PC.DEQ_Q_BTU_RCV
	WC	P.T2RV			:PC_T2.RCV
	WC	P.T1RV			:PC_T1.RCV
	WC	P.T1SD			:PC.T1_SEND
	WC	P.T2SD			:PC_T2.SEND
	WC	P.TGRV			:PC.TGC.RCV
	WC	P.BFRV			:BF.PC.RCV
	WC	P.VRSD			:PC.VR_SEND
	WC	P.TDQR			:PC_SA.TGC.DEQ_Q_BTU_RCV
	WC	P.TDQR			:PC.TGC.DEQ_Q_BTU_RCV
	WC	P.VDQV			:PC_SA.VRC.DEQ.Q_VR_PAC
	WC	P.VRPS			:PC_SA.VRC.VRPRS_SEND
	WC	T.DQPG			:TC_OR_BF_TC.DEQUEUE.Q_PAC
	WC	T.IPRS			:TC_OR_BF_TC.IPR_SEND
	WC	T.CMRV			:TC.CPMGR.RCV
	WC	T.CMSD			:TC.CPMGR.SEND
	WC	T.SCRV			:TC.SC.RCV
	WC	T.SCSD			:TC.SC.SEND
	WC	T.BFSD			:BF.TC.SEND
	WC	T.BFRV			:BF.TC.RCV
	WC	D.DQTD			:DEQUEUE.Q_TC_TO_DFC
	WC	D.FCRV			:DFC.RCV
	WC	D.FCSD			:DFC.SEND
	WC	F.NSRV			:FMD.SNS.RCV
	WC	F.NSSD			:FMD.SNS.SEND
	WC	L.RCV			:FMD.SPS.RCV
	WC	F.PSSD			:FMD.SPS.SEND
	WC	S.PCRV			:PU.SVC_MGR.CSC_MGR.RCV
	WC	S.PCSD			:PU.SVC_MGR.CSC_MGR.SEND
	WC	S.PCON			:PU.SVC_MGR.CSC_MGR.SON
	WC	S.PNRV			:PU.SVC_MGR.NS.RCV
	WC	S.PNSD			:PU.SVC_MGR.NS.SEND
	WC	S.PRMR			:PU.SVC_MGR.PC_ROUTE_MGR.RCV
	WC	S.PCBR			:PU.SVC_MGR.CSC.MGR.BF_RCV
	WC	S.SCSD			:SSCP.SVC_MGR.CS.SEND
	WC	S.SCRV			:SSCP.SVC_MGR.CS.RCV
	WC	M.DQCR			:NM.Q_CMD_RCV
	WC	L.SEND			:NM.Q_DATA_RCV(LU.SVC_MGR.SS.SEND)
	WC	L.RCV			:LU.PS.RCV(LU.SVC_MGR.SS.RCV)

:	HLDSP	-THIS IS A DISPATCHER FOR A SUBAREA NODE HIGH-LEVEL 
:		 PROCESS. THE DISPATCHER DEQUEUES THE 1ST ENTRY FROM THE
:		 DISPATCHING QUEUE,SETS UP THE CURRENT ENVIRONMENT AND CALLS
:		 THE NAMED PROCEDURE
:	--------------------------------------------------------------
:	INPUT	-THE REGISTERS WHICH CONTAIN INFORMATION FOR THIS PROCEDURE
:		 RNODE -- CONTAINS THE NODE RELATIVE NUMBER
:		 R4    -- CONTAINS THE RETURN ADDRESS WHERE THIS PROCEDURE
:		 	  CALLED
:	OUTPUT	-RETURN TO THE HLSCHD (HIGH-LEVEL SCHEDULER) OR A CALL TO
:		 THE NEXT SENDTO PROCEDURE
:	WORKING	-R12 (PTR TO CURRENT ENVIRONMENT VECTOR) 
:		 R14 (LINK REGISTER FOR DISPATCHER TO CALL OTHER PROCEDURE)

HLDSP
	STM	R0,DSPSAV,,		:SAVE ALL REGISTERS BEFORE PROCESSING
HLDSP0
:	THIS IS FIFO QUEUE,SO WE NEED TO SERVE THE 1ST ENTRY
	LHL	R13,NCBPTR,RNODE,RNODE	:GET CURRENT NCB POINTER
	LHL	R6,NCBBLK+NDDQGP,R13,	:GET GET PTR OF DPQ
:	CLH	R6,NCBBLK+NDDQRP,R13,	:COMP TO RL PTR (01/03/85 MIA)
	LHL	R5,NCBBLK+NDDQRP,R13,	:GET REL PTR (01/03/85 MIA)
	CR	R6,R5			:COMP POINTERS (01/03/85 MIA)
	JE	HLDSP1			:DPQ IS EMPTY,JUMP
	BBLOAD	R3,CMDBLK+CLARG,R6,	:GET DQE ENTRY PTR
	LH	R5,CMDBLK+CLPTR,R6,	:GET NEXT QUEUE PTR
	JE	DSPCRA			:CRASH,IF NEXT PTR IS EMPTY
:	SET UP THE CURRENT ENVIRONMENT
:	------------------------------------------------
	L	R4,BBUFER+DQSCB,R3,	:GET SCBPTR FROM DQE
	ST	R4,NCBBLK+NDSSCB,R13,	:STORE INTO NCB
	L	R4,BBUFER+DQTGCB,R3,	:GET TGCBPTR FROM DQE
	ST	R4,NCBBLK+NDTGCB,R13,	:STORE INTO NCB
:	L	R4,BBUFER+DQERCB,R3,	:GET ERCBPTR FROM DQE
:	ST	R4,NCBBLK+NDERCB,R13,	:STORE INTO NCB
:	L	R4,BBUFER+DQVRCB,R3,	:GET VRCBPTR FROM DQE
:	ST	R4,NCBBLK+NDVRCB,R13,	:STORE INTO NCB
:	L	R4,BBUFER+DQNRCB,R3,	:GET NRCBPTR FROM DQE
:	ST	R4,NCBBLK+NDNRCB,R13,	:STORE INTO NCB
:	L	R4,BBUFER+DQDRCB,R3,	:GET DRCBPTR FROM DQE
:	ST	R4,NCBBLK+NDDRCB,R13,	:STORE INTO NCB
	L	R4,BBUFER+DQTCCB,R3,	:GET TCCBPTR FROM DQE
	ST	R4,NCBBLK+NDTCCB,R13,	:STORE INTO NCB
	LHL	R12,EVPTR,RNODE,RNODE	:GET CURRENT ENVIRONMENT VECTOR
	BBLOAD	R4,BBUFER+DQPRMP,R3,	:GET PARAMETER LIST PTR
	BBSTOR	R4,EVBLK+EVPRMP,R12,	:STORE INTO EV
	BBLOAD	R4,BBUFER+DQMUPR,R3,	:GET MUCB PTR
	BBSTOR	R4,EVBLK+EVMUPR,R12,	:STORE INTO EV
	LHL	R4,BBUFER+DQMULN,R3,	:GET MU LENGTH
	STH	R4,EVBLK+EVMULN,R12,	:STORE IT INTO EV
	LHL	R4,BBUFER+DQLUCB,R3,	:GET LU CONTROL BLOCK
	STH	R4,EVBLK+EVLUCB,R12,	:STORE IT INTO EV
	LB	R4,BBUFER+DQNWCM,R3,	:GET NIO CMD TYPE
	STB	R4,EVBLK+EVNWCM,R12,	:STORE INTO EV
	LB	R4,BBUFER+DQDPRO,R3,	:GET DESTINATION PROCEDURE #
	STB	R4,EVBLK+EVDPRO,R12,	:STORE INTO EV
	LB	R4,BBUFER+DQSPRO,R3,	:GET SENDING PROCEDURE #
	STB	R4,EVBLK+EVSPRO,R12,	:STORE INTO EV
	LB	R4,BBUFER+DQISIG,R3,	:GET INPUT SIGNAL
	STB	R4,EVBLK+EVISIG,R12,	:STORE INTO EV
:	REMOVE THE DQE FROM THE DSQ
:	---------------------------
	STH	R5,NCBBLK+NDDQGP,R13,	:SET UP NEW GET PTR
	JAL	R4,RELCL,,		:RELEASE DQE CMD LIST PTR
	JAL	R4,PBB,,		:PUT ENTITY BACK TO CHAIN
	JAL	R4,R.PBB,,		:UPDATE BBUFER CNT
:	CALL THE DESTINATION PROCEDURE 
:	--------------------------------
	LHL	R12,EVPTR,RNODE,RNODE	:GET CURRENT ENVIRONMENT VECTOR
	LB	R4,EVBLK+EVDPRO,R12,	:GET DESTINATION PROCEDURE #
	SLHLS	R4,1			:SET FULL WORD BASE
	L	R5,PRONAM,R4,R4		:GET PROCEDURE NAME ENTRY
	JALR	R14,R5			:JUMP TO PROCESS PROCEDURE
:	CONTINUE NEXT DQE
:	-----------------
	J	HLDSP0
:	RETURN TO CALLING ADDRESS (SCHEDULER)
:	-------------------------------------
HLDSP1
	LM	R0,DSPSAV,,		:GET ALL REGISTERS BACK
	JR	R4			:RETURN TO CALLING ADDRESS

DSPCRA
	JAL	R10,CRASH,,
	BC	0,0,0,CRQDSP

	FO	CBKDEF
	FO	CMDLST
	FO	MAIN

	EM
 
	SUBTTL	SNA PACKAGE(SCHEDULER FOR SNA LAYERS)

:	*******************************************************
:	REVISION HISTORY --
:	DEC. 09,1983 (NCS) -- ORIGINAL DESIGN AND CODING
:	MARCH 15, 1985 (MIA) - REDESIGNED HLSCDL TO SCAN BIT ARRAYS
:	*********************************************************

:	THIS PACKAGE IS DESIGNED TO SUPPORT HIGH_LEVEL_SCHEDULER
:	WHICH IS THE MAIN EXECUTION MODULE IN THE SNA PACKAGE
:	----------------------------------------------------------

	RA	0
	MO	.,SNAPKG

	LO	CBKDEF
	LO	GBLDEF
	LO	MAIN

	SEG	A.DATA
SCHSAV	WS	1		:SAVE AREA FOR SCB_LIST FOR SCAN PURPOSE
SCHRET	WS	1		:SAVE AREA FOR SCHEDULER RETURN ADDRESS
SC1415	WS	2		:SAVE AREA FOR R14 AND R15
HLSCPR	WS	1		:PROCESSED BIT ARRAY FOR SCHEDULER
SCHTIM	BS	1		:SAVE AREA FOR COUNTING SCB_LIST
SCHEND	BS	1		:SAVE AREA FOR SCANNING SCB_LIST

	SEG	A.CODE

:	HLVRCB	-ROUTINE TO SUPPORT SCHEDULER TO PROCESS VRCB DATA QUEUE
:	CERTAIN FUNCTIONS
:	--------------------------------------------------------------
HLVRCB
	JAL	R4,GBB,,		:CREATE NEW DQE (R3 IS NEW DQE)
	J	HLSC15			:CRASH,IF NO ENTITY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
:	ST	R10,BBUFER+DQVRCB,R3,	:SET VRCB PTR TO CURRENT
	LCS	R8,1			:LOAD -1 INTO OTHER FIELDS
	BBSTOR	R8,BBUFER+DQMUPR,R3,	:SET MU PTR TO 'NULL'
	BBSTOR	R8,BBUFER+DQPRMP,R3,	:SET PARAMETE ENTITY PTR TO 'NULL'
	ST	R8,BBUFER+DQSCB,R3,	:SET SCB PTR TO 'NULL'
	ST	R8,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	STH	R8,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO 'NULL'
	STH	R8,BBUFER+DQMULN,R3,	:SET MULN TO 'NULL'
	STB	R8,BBUFER+DQNWCM,R3,	:SET NIO CMD TO 'NULL'
	JAL	R8,SEND,,		:JUMP TO EXECUTE 'SEND' STATEMENT
	JAL	R4,HLDSP,,		:CALL DISPATCHER
	JR	R14			:RETURN TO HL SCHEDULER

:	HLSCBS	-ROUTINE TO SUPPORT SCHEDULER TO PROCESS SCB DATA QUEUE
:	CERTAIN FUNCTIONS
:	--------------------------------------------------------------
HLSCBS
	JAL	R4,GBB,,		:CREATE NEW DQE (R3 IS NEW DQE)
	J	HLSC15			:CRASH,IF NO ENTITY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	ST	R12,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO CURRENT
	ST	R10,BBUFER+DQSCB,R3,	:SET SCB PTR TO CURRENT
	LCS	R8,1			:LOAD -1 INTO OTHER FIELDS
	BBSTOR	R8,BBUFER+DQMUPR,R3,	:SET MU PTR TO 'NULL'
	BBSTOR	R8,BBUFER+DQPRMP,R3,	:SET PARAMETE ENTITY PTR TO 'NULL'
	STH	R8,BBUFER+DQMULN,R3,	:SET MULN TO 'NULL'
	STH	R8,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO 'NULL'
	STB	R8,BBUFER+DQNWCM,R3,	:SET NIO CMD TO 'NULL'
	JAL	R8,SEND,,		:JUMP TO EXECUTE 'SEND' STATEMENT
	JAL	R4,HLDSP,,		:CALL DISPATCHER
	JR	R14			:RETURN

:	HLLUCB	-ROUTINE TO SUPPORT SCHEDULER TO PROCESS LUCB DATA QUEUE
:	CERTAIN FUNCTIONS
:	--------------------------------------------------------------
HLLUCB
	JAL	R4,GBB,,		:CREATE NEW DQE (R3 IS NEW DQE)
	J	HLSC15			:CRASH,IF NO ENTITY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	STH	R12,BBUFER+DQLUCB,R3,	:SET LUCB PTR TO CURRENT
	LCS	R8,1			:LOAD -1 INTO OTHER FIELDS
	ST	R8,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO CURRENT
	BBSTOR	R8,BBUFER+DQMUPR,R3,	:SET MU PTR TO 'NULL'
	ST	R8,BBUFER+DQSCB,R3,	:SET SCB PTR TO 'NULL'
	BBSTOR	R8,BBUFER+DQPRMP,R3,	:SET PARAMETE ENTITY PTR TO 'NULL'
	STH	R8,BBUFER+DQMULN,R3,	:SET MULN TO 'NULL'
	STB	R8,BBUFER+DQNWCM,R3,	:SET NIO CMD TO 'NULL'
	JAL	R8,SEND,,		:JUMP TO EXECUTE 'SEND' STATEMENT
	JAL	R4,HLDSP,,		:CALL DISPATCHER
	JR	R14			:RETURN

:	HLSCHD	-THIS PROCEDURE SERVICES ALL SCHEDULED DATA QUEUES OF A
:		 HIGH_LEVEL PROCESS IN A SUBAREA NODE. IF THE SCHEDULED DATA
:		 QUEUE IS NOT EMPTY,THE PROCEDURE SENDS A SIGNAL TO THE 
:		 APPROPRIATE DEQUEUING PROCEDURE AND CALLS THE DISPATCHER.
:	------------------------------------------------------------------
:	INPUT	-
:	OUTPUT	-
:	LINK	-R14
:	DESTROY	-

HLSCHD
	ST	R14,SCHRET,,		:SAVE RETURN ADDRESS IN SCHRET
:	==============================================================
:	: SCAN THE LU COMMAND AND DATA QUEUE WHICH RCV. FROM NETWORK :
:	==============================================================
:	SCAN NWKC->SNA INPUT CMD-Q FIRST
	LHI	R14,NGSLU*10		:GET 1ST LU FOR A GROUP
	LHI	R15,NGSLU*2		:GET INDEX TO AFTER LAST
HLSC20
	SHI	R14,10			:TO NEXT GROUP
	SIS	R15,2			:ALL DONE FOR ALL LUS' ?
	JL	HLSC25			:YES, EXIT TO PROCESS NWKC->SNA DATA-Q
	LCS	R0,1			:INIT HLSCPR
	STH	R0,HLSCPR,,		:...
HLSC21
	LH	R1,CPNWSN,R15,		:LUS' WITH NWKC->SNA CMD
	NH	R1,HLSCPR,,		:EXCLUDE LUS' ALREADY DONE
	JFFOH	R1,HLSC22		:FIND THE 1ST 'AVAIL' LU IN THIS GROUP
	J	HLSC20			:IF NONE TO PROCESS IN THIS GROUP, SKIP
HLSC22
	RBT	R2,HLSCPR,,		:DON'T DO THIS LU AGAIN
	AR	R2,R14			:FORM THE LU #
	LHL	R12,LUBPTR,R2,R2	:R12 = LUCTAB ADDR
	LHL	R5,LUCTAB+LUSNCG,R12,	:GET GET PTR OF Q_CMD_RCV
	LHL	R0,LUCTAB+LUSNCR,R12,	:GET REL PTR (01/03/85 MIA)
	CR	R5,R0			:COMP POINTERS
	JE	HLSC21			:Q_CMD_RCV IS EMPTY,JUMP
	LB	RNODE,LUCTAB+LUCPUN,R12, :GET NODE NUMBER
	STM	R14,SC1415,,		:SAVE REGISTERS
	LHI	R0,SG.OPQ		:GET 'OPEN_QUEUE' SIGNAL
	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
	LHI	R2,NMDQCR		:GET 'NM.DEQ_Q_CMD_RCV' PROCEDURE #
	JAL	R14,HLLUCB,,		:CALL LUCB SEND ROUTINE
	LM	R14,SC1415,,		:RETSORE REGISTERS
	J	HLSC21			:CONTINUE
:	SCAN NWKC->SNA INPUT DATA-Q
HLSC25	LHI	R14,NGSLU*10		:GET 1ST LU FOR A GROUP
	LHI	R15,NGSLU*2		:GET INDEX TO AFTER LAST
HLSC26
	SHI	R14,10			:TO NEXT GROUP
	SIS	R15,2			:ALL DONE FOR ALL LUS' ?
	JL	HLSC29			:YES, EXIT TO PROCESS OTHER QUEUES
	LCS	R0,1			:INIT HLSCPR
	STH	R0,HLSCPR,,		:...
HLSC27	LH	R1,DPNWSN,R15,		:LUS' WITH NWKC->SNA DATA
	NH	R1,HLSCPR,,		:EXCLUDE LUS' ALREADY DONE
	JFFOH	R1,HLSC28		:FIND THE 1ST 'AVAIL' LU IN THIS GROUP
	J	HLSC26			:IF NONE TO PROCESS IN THIS GROUP, SKIP
HLSC28
	RBT	R2,HLSCPR,,		:DON'T DO THIS LU AGAIN
	AR	R2,R14			:FORM THE LU #
	LHL	R12,LUBPTR,R2,R2	:R12 = LUCTAB ADDR
	LHL	R5,LUCTAB+LUSNDG,R12,	:GET GET PTR OF Q_DATA_RCV
	LHL	R0,LUCTAB+LUSNDR,R12,	:GET REL PTR (01/03/85 MIA)
	CR	R5,R0			:COMP POINTERS (01/03/85 MIA)
	JE	HLSC27			:Q_DATA_RCV IS EMPTY,JUMP
	LB	RNODE,LUCTAB+LUCPUN,R12, :GET NODE NUMBER
	STM	R14,SC1415,,		:SAVE REGISTERS
	LHI	R0,SG.OPQ		:GET 'OPEN_QUEUE' SIGNAL
	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
	LHI	R2,LUSEND		:GET 'NM.DEQ_Q_DATA_RCV' PROCEDURE #
	JAL	R14,HLLUCB,,		:CALL LUCB SEND ROUTINE
	LM	R14,SC1415,,		:RETSORE REGISTERS
	J	HLSC27			:CONTINUE
HLSC29	LHI	RNODE,MAXPUN		:GET TOTAL NODE NUMBERS
HLSC00
	SIS	RNODE,1			:DECREMENT COUNTER
	JL	HLSC0F			:JUMP,IF NO MORE NODE 
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER

:	===============================================
:	: SCHEDULE THE DATA QUEUE (Q_BTU_RCV) IN PCCB :
:	===============================================
HLSC12
	LHL	R10,PCBPTR,RNODE,RNODE	:GET PCBPTR FOR THIS NODE
	LHL	R5,PCBBLK+PCQBRG,R10,	:GET GET PTR OF Q_BTU_RCV
:	CLH	R5,PCBBLK+PCQBRR,R10,	:GET REL PTR (01/03/85 MIA)
	LHL	R4,PCBBLK+PCQBRR,R10,	:GET REL PTR (01/03/85 MIA)
	CR	R5,R4			:COMP POINTERS (01/03/85 MIA)
	JE	HLSC01			:Q_BTU_RCV IS EMPTY,JUMP
	JAL	R4,GBB,,		:CREATE NEW DQE (R3 IS NEW DQE)
	J	HLSC15			:CRASH,IF NO ENTITY AVAILABLE
	JAL	R4,R.GBB,,		:UPDATE BBUFER CNT
	LHI	R0,SG.OPQ		:GET 'OPEN_QUEUE' SIGNAL
	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
	LHI	R2,PCDQBR		:GET 'PC.DEQ_Q_BTU_RCV' PROC.
	LCS	R8,1			:LOAD -1 INTO OTHER FIELDS
	BBSTOR	R8,BBUFER+DQMUPR,R3,	:SET MU PTR TO 'NULL'
	ST	R8,BBUFER+DQSCB,R3,	:SET SCB PTR TO 'NULL'
	ST	R8,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
	BBSTOR	R8,BBUFER+DQPRMP,R3,	:SET PARAMETE ENTITY PTR TO 'NULL'
	JAL	R8,SEND,,		:JUMP TO EXECUTE 'SEND' STATEMENT
	JAL	R4,HLDSP,,		:CALL DISPATCHER

:	========================================================
:	: SCAN TGCB_LIST AND CHECK DATA QUEUE (TGCB.Q_BTU_RCV) :
:	========================================================
HLSC01
:	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
:	L	R9,NCBBLK+NDTGLS,R13,	:GET DEFAULT PTR OF TGCB
:HLSC02
:	L	R10,TGLSPT+TGLCPT,R9,	:GET CURRENT TGCB PTR
:	LR	R10,R10			:CHECK TO SEE THE LIST EMPTY OR NOT
:	JN	HLSC04			:JUMP,IF LIST IS EMPTY
:	LHL	R5,TGBBLK+TGQBRG,R10,	:GET GET PTR OF Q_BTU_RCV
:	CLH	R5,TGBBLK+TGQBRR,R10,	:GET RELEASE PTR OF Q_BTU_RCV
:	JE	HLSC03			:Q_BTU_RCV IS EMPTY,JUMP
:	JAL	R4,GBB,,		:CREATE NEW DQE (R3 IS NEW DQE)
:	J	HLSC15			:CRASH,IF NO ENTITY AVAILABLE
:	LHI	R0,SG.OPQ		:GET 'OPEN_QUEUE' SIGNAL
:	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
:	LHI	R2,PTDQBR		:GET 'PC_SA.TGC.DEQ_Q_BTU_RCV' PROC. #
:	ST	R10,BBUFER+DQTGCB,R3,	:SET TGCB PTR TO CURRENT
:	LCS	R8,1			:LOAD -1 INTO OTHER FIELDS
:	BBSTOR	R8,BBUFER+DQMUPR,R3,	:SET MU PTR TO 'NULL'
:	ST	R8,BBUFER+DQSCB,R3,	:SET SCB PTR TO 'NULL'
:	ST	R8,BBUFER+DQTCCB,R3,	:SET TCCB PTR TO 'NULL'
:	BBSTOR	R8,BBUFER+DQPRMP,R3,	:SET PARAMETE ENTITY PTR TO 'NULL'
:	JAL	R8,SEND,,		:JUMP TO EXECUTE 'SEND' STATEMENT
:	JAL	R4,HLDSP,,		:CALL DISPATCHER
:HLSC03
:	LH	R2,TGLSPT+TGLNPT,R9,	:GET NEXT LIST PTR
:	LR	R2,R2			:CHECK THE NEXT PTR
:	JE	HLSC04			:JUMP,IF THIS IS THE LAST OF LIST
:	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
:	L	R9,NCBBLK+NDTGLS,R13,	:GET DEFAULT PTR OF TGCB
:	AR	R9,R2			:UPDATE THE CURRENT LIST PTR
:	J	HLSC02

:	=======================================================
:	: SCAN VRCB_LIST AND CHECK DATA QUEUE (VRCB.Q_VR_PAC) :
:	: AND SEND 'SEND_VRPRS' AND 'SEND_DACTVR_F'           :
:	=======================================================
HLSC04
:	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
:	L	R9,NCBBLK+NDVRLS,R13,	:GET LIST HEADER FOR VRCB
:HLSC05
:	L	R10,VRLSPT+VRLCPT,R9,	:GET CURRENT VCB PTR
:	LR	R10,R10			:CHECK THE CURRENT PTR
:	JN	HLSC08			:JUMP,IF LIST IS EMPTY
:	LHL	R5,VCBBLK+VCQVPG,R10,	:GET GET PTR OF Q_VR_PAC
:	CLH	R5,VCBBLK+VCQVPR,R10,	:GET RELEASE PTR OF Q_VR_PAC
:	JE	HLSC06			:Q_VR_PAC IS EMPTY,JUMP
:	LHI	R0,SG.OPQ		:GET 'OPEN_QUEUE' SIGNAL
:	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
:	LHI	R2,PVDQVP		:GET 'PC_SA.VRC.DEQ_Q_VR_PAC' PROC. #
:	JAL	R14,HLVRCB,,		:TO CALL HLDSP,SEND AND UPDATING
:HLSC06
:	LHI	R0,SG.VRP		:GET 'SEND_VRPRS' SIGNAL
:	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
:	LHI	R2,PVVRSD		:GET 'PC_SA.VRC.VRPRS_SEND' PROC. #
:	JAL	R14,HLVRCB,,		:TO CALL HLDSP,SEND AND UPDATING
:	LHI	R0,SG.VRF		:GET 'SEND_DACTVR_F' SIGNAL
:	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
:	LHI	R2,PMPRMR		:GET 'PU.SVC_MGR.PC_ROUTE_MGR.RCV'
:	JAL	R14,HLVRCB,,		:TO CALL HLDSP,SEND AND UPDATING
:HLSC07
:	LH	R2,VRLSPT+VRLNPT,R9,	:GET NEXT LIST PTR
:	LR	R2,R2			:CHECK THE NEXT PTR
:	JE	HLSC08			:JUMP,IF THIS IS THE LAST OF LIST
:	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
:	L	R9,NCBBLK+NDVRLS,R13,	:GET LIST HEADER FOR VRCB
:	AR	R9,R2			:UPDATE THE CURRENT LIST PTR
:	J	HLSC05

:	==============================================================
:	: SCAN THE SCB_LIST AND CHECK DATA QUEUE (Q_TC_TO_DFC,Q_PAC) :
:	==============================================================
HLSC08
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
	L	R1,NCBBLK+NDSCLS,R13,	:SCB_LIST (BIT#=0,FREE,BIT#=1,ASSIGNED)
	LB	R0,NCBBLK+NDDEVN,R13,	:GET DEVICE # FROM NCB
	SRHLS	R0,4			:GET MULTIPLIER OF 16
	STB	R0,SCHTIM,,		:INIT FOR FRIST SCB_LIST IND.
	LIS	R0,0
	STB	R0,SCHEND,,		:FOR END OF SCB SCANNER
HLSC18
	ST	R1,SCHSAV,,		:SAVE SCB_LIST IN SAVE AREA
	ST	R1,HLSCPR,,		:SAVE IT AGAIN
HLSC19
:	LB	R8,SCHTIM,,		:GT CUR SCB_LST (06/11/85 MIA)
	LB	R8,SCHEND,,		:GT CUR SCB_LST (06/11/85 MIA)
	SLHLS	R8,2			:MAKE FULL WORD INDEX (5/16/85/CHS)
	L	R1,NCBBLK+NDQTCP,R8,R13, :GET CORRESPONDING DATA PRESENT ARRAY
	N	R1,HLSCPR,,		:EXCLUDE ALREADY SERVICED
	JFFO	R1,HLSC0A		:JUMP,ON FINDING SCB FREE
	J	HLSC0B			:JUMP TO SCANNING TC_TO_DFC
HLSC0A
:	(4/21/86/CHS)
:	IF	FWSCB IS 1, SCBPTR'S ARE IN FULL-WORD
	IF	FWSCB
	SLHLS	RNODE,1			:MAKE FW INDEX
	L	R10,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	SRHLS	RNODE,1
	ELSE
	LHL	R10,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	EI	(FWSCB)
	RBT	R2,HLSCPR,,		:RESET CURRENT SCB INDEX IN SAVE AREA
:	SLHLS	R8,5			:FIRST SCB FOR THIS INDEX(5/19/85/CHS)
	SLHLS	R8,3			:FIRST SCB FOR THIS INDEX(5/19/85/CHS)
	AR	R2,R8			:REL # FOR SCB
	LHI	R8,SCLENG		:GET LENGTH OF SCB
	MHR	R2,R8			:DISPLACEMENT FROM 1ST SCB FOR NODE
	AR	R10,R2			:GET SCB POINTER
:	GET TCCB PTR (PTR BY TC_CB_PTR) AND CHECK TCCB.Q_PAC
:	-----------------------------------------------------
	LHL	R12,SCBBLK+SCTCCB,R10,	:GET PTR TO TCCB
	LHL	R5,TCBBLK+TCQSPG,R12,	:GET GET PTR OF Q_PAC
:	CLH	R5,TCBBLK+TCQSPR,R12,	:GET REL PTR (01/03/85 MIA)
	LHL	R0,TCBBLK+TCQSPR,R12,	:GET REL PTR (01/03/85 MIA)
	CR	R5,R0			:COMP POINTERS (01/03/85 MIA)
:	JE	HLSC19			:Q_PAC IS EMPTY,JUMP (12/17/85 MIA)
	JE	HLSC1A			:Q_PAC IS EMPTY, JUMP (12/17/85 MIA)
	LHI	R0,SG.OPQ		:GET 'OPEN_QUEUE' SIGNAL
	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
	LHI	R2,TCDQPG		:GET 'TC_OR_BF_TC.DEQUEUE.Q_PAC' PROC. 
	JAL	R14,HLSCBS,,		:TO CALL HLDSP,SEND AND UPDATING
:SCHEDULE IPR. DATA PRESENT IN NDQTCP WILL BE SET AT SESSION INITIALIZATION
:IF RCV_PACING=YES AND WILL NOT BE RESET UNTIL TERMINATION OF THE SESSION.
:(12/17/85 MIA).
HLSC1A	LHI	R0,SG.IPR		:GET 'SEND_IPR' SIGNAL
	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
	LHI	R2,TCIPSD		:GET 'TC_OR_BF_TC.IPR__SEND' PROC. #
	JAL	R14,HLSCBS,,		:TO CALL HLDSP,SEND AND UPDATING
:END OF INSERTION (12/17/85 MIA).
	J	HLSC19			:PROCESS NEXT SCB
HLSC0B
:	LB	R8,SCHTIM,,		:GT CUR SCB_LST (06/11/85 MIA)
	LB	R8,SCHEND,,		:GT CUR SCB_LST (06/11/85 MIA)
	SLHLS	R8,2			:MAKE WORD INDX (06/11/85 MIA)
	L	R1,NCBBLK+NDQTDF,R8,R13, :GET CORRESPONDING DATA PRESENT ARRAY
	N	R1,SCHSAV,,		:EXCLUDE ALREADY SERVICED
	JFFO	R1,HLSC17		:JUMP,ON FINDING SCB FREE
	J	HLSC0E			:JUMP TO END SCANNNING
HLSC17
:	(4/21/86/CHS)
:	IF FWSCB IS 1, SCBPTR'S ARE IN FULL-WORD
	IF	FWSCB
	SLHLS	RNODE,1			:MAKE FW INDEX
	L	R10,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	SRHLS	RNODE,1
	ELSE
	LHL	R10,SCBPTR,RNODE,RNODE	:GET OFFSET OF SCB FOR THIS NODE
	EI	(FWSCB)
	RBT	R2,SCHSAV,,		:RESET CURRENT SCB INDEX IN SAVE AREA
:	SLHLS	R8,5			:FIRST SCB (06/11/85 MIA)
	SLHLS	R8,3			:FIRST SCB (06/11/85 MIA)
	AR	R2,R8			:REL # FOR SCB
	LHI	R8,SCLENG		:GET LENGTH OF SCB
	MHR	R2,R8			:DISPLACEMENT FROM 1ST SCB FOR NODE
	AR	R10,R2			:GET SCB POINTER
:	LHI	R0,SG.IPR		:GET 'SEND_IPR' SIGNAL
:	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
:	LHI	R2,TCIPSD		:GET 'TC_OR_BF_TC.IPR__SEND' PROC. #
:	JAL	R14,HLSCBS,,		:TO CALL HLDSP,SEND AND UPDATING
	LB	R2,SCBBLK+SCACFG,R10,	:GET SESSION TYPE
	NHI	R2,SC.BFS		:MASK FOR HALF_SESSION BIT
	JN	HLSC0B			:JUMP,IF NOT
:	SCB_TYPE=HALF_SESS,SERVICE Q_TC_TO_DFC
:	--------------------------------------
	LHL	R5,SCBBLK+SCQTDG,R10,	:GET GET PTR OF Q.TC_TO_DFC
:	CLH	R5,SCBBLK+SCQTDR,R10,	:GET REL PTR (01/03/85 MIA)
	LHL	R0,SCBBLK+SCQTDR,R10,	:GET REL PTR (01/03/85 MIA)
	CR	R5,R0			:COMP POINTERS (01/03/85 MIA)
	JE	HLSC0B			:JUMP,IF EMPTY
	LHI	R0,SG.OPQ		:GET 'OPEN_QUEUE' SIGNAL
	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
	LHI	R2,DQTCDC		:GET 'DEQUEUE.Q_TC_TO_DFC' PROC. 
	JAL	R14,HLSCBS,,		:TO CALL HLDSP,SEND AND UPDATING
	J	HLSC0B
:	SCB_TYPE=BF_SESS,SERVICE TCCB.Q_PAC (PTR BY SEC_TO_BF_TC_CB_PTR)
:	AND SEND 'IPR_SIGNAL' TO TC_OR_BF_TC.IPR_SEND
:	----------------------------------------------------------
HLSC0C
:	L	R12,SCBBLK+SCSTBC,R10,	:GET PTR TO SEC_TO_BF_TC_CB_PTR
:	LHL	R5,TCBBLK+TCQSPG,R12,	:GET GET PTR OF Q_PAC
:	CLH	R5,TCBBLK+TCQSPR,R12,	:GET RELEASE PTR OF Q_PAC
:	JE	HLSC0D			:Q_PAC IS EMPTY,JUMP
:	LHI	R0,SG.OPQ		:GET 'OPEN_QUEUE' SIGNAL
:	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
:	LHI	R2,TCDQPG		:GET 'TC_OR_BF_TC.DEQUEUE.Q_PAC' PROC. 
:	JAL	R14,HLSCBS,,		:TO CALL HLDSP,SEND AND UPDATING
:HLSC0D
:	LHI	R0,SG.IPR		:GET 'SEND_IPR' SIGNAL
:	LHI	R1,SCHEDL		:THE SEND_PROCEDURE IS SCHEDULER
:	LHI	R2,TCIPSD		:GET 'TC_OR_BF_TC.IPR__SEND' PROC. #
:	JAL	R14,HLSCBS,,		:TO CALL HLDSP,SEND AND UPDATING
	LHL	R13,NCBPTR,RNODE,RNODE	:GET NCB POINTER
	J	HLSC0B

:	END OF SCAN FOR THIS NODE
:	-------------------------
HLSC0E
	LB	R1,SCHEND,,		:GET CURRENT STOP POINT
	CLB	R1,SCHTIM,,		:IS TIME FOR ENDING
	JGE	HLSC10			:JUMP,IF YES
	AIS	R1,1
	STB	R1,SCHEND,,		:SAVE NEW STOP POINT
	SLHLS	R1,2			:FOR NEW SCB_LIST OFFSET
	L	R1,NCBBLK+NDSCLS,R1,R13	:GET NEW SCB_LIST
	J	HLSC18			:JUMP FOR SCB_LIST SCANE
HLSC10
	JAL	R4,HLDSP,,		:GOTO CHECK DQE AGAIN
	J	HLSC00			:JUMP TO NEXT NODE

:	END OF SCAN FOR ALL THE NODES
:	-----------------------------
HLSC0F
	L	R14,SCHRET,,		:GET RETURN ADDRESS
	JR	R14

HLSC15
	J	NOENT5,,

	FO	CBKDEF
	FO	GBLDEF
	FO	MAIN

	EM


	SUBTTL	(SNA-MAIN)	INITIALIZATION AND EXEC - MAIN
:MAIN00.Z00

:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	REVISION HISTORY --
:	02/29/84 (CHS) -- Original code and design for SNA Native Mode
:	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	RA	0			:RADIX TO HEX

	LO	GBLDEF
	LO	BSUB
	LO	SNAPKG
	LO	IFCNTL
	LO	CMDLST
	LO	OSCAN

	SEG	A.DATA
BDEBUG	HC	0
FDEBUG	HC	0

:***************************************************************:
:								:
:			INITIALIZATION				:
:								:
:***************************************************************:
	SEG	A.CODE
	HS	0
START
:	DISCONNECT FOREGROUND
:	----------------------
	LIS	R0,0			:
	SVC	SYS,CFGND.		:DISCONNECT FOREGROUND

:	ZAP ANY ACTIVE PORTS
:	--------------------
	LHI	R1,NPORT-1		:PORT INDEX
	LIS	R5,0			:INIT R5 TO 0
	LO	FRNTND
	LHI	R2,ZAPMSG		:ISIS ZAPPER
	FO	FRNTND
MAIN01
	LHL	R3,PORTAB,R1,R1		:GET DCB ASSOCIATED WITH PORT
	LHL	R0,DCBLKS+DCBIPR,R3,	:GET ISIS PORT FOR THIS DCB
	JEFS	MAIN02			:SKIP, PORT NOT CONNECTED
	STH	R5,PORTAB,R1,R1		:CLEAR PORT TABLE
	LIS	R0,3			:ZAPMSG LENGTH
	JAL	R4,SLOR,,		:SATRT ISIS CONTROL MSG
	JAL	R4,ELOR,,		:END ISIS CONTROL MSG
MAIN02
	SIS	R1,1			:GO TO NEXT PORT
	JG	MAIN01			:LOOP
:	LOG/REPORT SLOT INITIAL STATRT OR RESTART
:	-----------------------------------------
	LIS	R0,0			:ASSUME SLOT INITIAL START
	LIS	R1,0			:MISCELLANEOUS EVENT
	LHL	R2,FPANEL,,		:FPANEL ZERO ?
	JEFS	MAIN03			:YES, INITIAL START, SKIP
	LIS	R0,1			:ELSE, SLOT RESTART
MAIN03
	JAL	R6,SEVLOG,,		:LOG/REPORT EVENT
:	INIT FRONT PANEL
:	----------------
	LIS	R0,0			:INIT FPANEL
	STH	R0,FPANEL,,		:....
:	REPORT HOST(S) SHUT, AND OUT OF PORTS
:	-------------------------------------
	IF	MAXHST
	JAL	R13,IZHOST		:INIT THE HOST TABLE
	EI	(MAXHST)
:	INITILIZE PROCESSORS
:	--------------------
	JAL	R0,IZT,,		:INIT TIMEOUT FREE LIST
	JAL	R0,IZFRNT,,		:INIT ISIS FRONT END
	JAL	R4,IZBB,,		:INIT BIG BUFFERLETS
	JAL	R4,IZCFL,,		:INIT COMMAND FREE LIN POOL
	JAL	R6,IZDCB,,		:INIT DCB'S
	JAL	R15,IZPORT		:INIT PORTAB
	IF	MONTOR
	LO	MONITR
	JAL	R7,IZMON		:INIT THE MONITOR PROCESS
	FO	MONITR
	EI	(MONTOR)
	JAL	R15,IZBGD		:INITIALIZE BG DATA STRUCTURES
	JAL	R13,IZNODE,,		:INIT NODE CNTL BLOCKS FOR SNA
	JAL	R5,L.INIT,,		:INIT LU.SVC MANAGER
:	INIT FORGROUND HERE
:	-------------------
	JAL	R5,IZFG,,		:INIT FOREGROUND
:	START FOREGROUND
:	----------------
      	LA	R0,FGND			:LOAD FOREGROUND START ADDRESS
 	SVC	SYS,CFGND.		:CONNECT FOREGROUND
:	START THE HALF SECOND LOGICN
:	----------------------------
	L	R1,FASTC,,		:HALF-SECOND
	LHI	R1,RATE/2,R1		:...
	LA	R0,HSEC,,		:...
	JAL	R5,TOPUT,,		:PUT HALF-SECOND LOGIC ON TIMOUT LIST

:***************************************************************:
:								:
:		BACKGROUND EXEC LOOP				:
:								:
:***************************************************************:
EXEC
	LH	R0,BDEBUG,,		:IF BACK GROUND ON
	JG	BTRAP			:IF YES, TRAP BACK GROUND CPU TIME
    	SVC	FASTD			:MAIN EXEC LOOP
	JAL	R0,INPUT,,		:ISIS INPUT HANDLER
	JAL	R0,TIMOUT,,		:TIMEOUT PROCESSOR
	JAL	R0,DLCPRO,,		:DLC LAYER PROCESSING
	JAL	R0,OSCAN,,		:SNA->NWKC OUTPUT HANDLER
	JAL	R14,HLSCHD,,		:CALL SNA SCHEDULER
	JAL	R0,IFCNTL,,		:INTERFACCE CONTROL
	LIS	R1,1			:INCREMENT EXEC LOOP COUNTER
	AHM	R1,FPANEL,,		:STORE IT
	J	EXEC			:REPEAT

:	BACK GROUND CPU TIME TRAP
:	-------------------------
BTRAP
	LH	R0,BDEBUG,,
	JLE	EXEC
	SVC	FASTD
	JBS	BTRAP


:***************************************************************:
:								:
:		FOREGROUND EXEC LOOP				:
:                                                               :
:***************************************************************:
FGND
	JAL	R10,SETMAC,,		:SWITCH MAC SET (02/18/87 YLH)
	LH	R0,FDEBUG,,		:IF FOREGROUND DEBUG ON
	JG	FTRAP			:IF YES, TRAP FOREGROUND CPU TIME
	LO	SNAEXC
	JAL	R10,DLCEXC,,		:DATA LINK LINE EXEC
	FO	SNAEXC
	SVC	FASTD			:DISMISS
	JBS	FGND			:LOOP

FTRAP
	LH	R0,FDEBUG,,
	JLE	FGND
	SVC	FASTD
	JBS	FTRAP

	SUBTTL	(SNA-MAIN)	INITIALIZATION ROUTINES


:	IZPORT:	INITIALIZE PORT TABLE
:	-----------------------------
:	INPUT:	DCB INITIALIZED
:		R15 - LINK REGISTER
:	OUTPUT:	SET UP PORT TABLE ALL POINT TO THE 1ST DCB
IZPORT
	LIS	R1,4			:SET R1 TO 1ST DCB ADDR
	LHI	R3,NPORT-1		:SET UP LOOP COUNT
IZPOR1
	STH	R1,PORTAB,R3,R3		:PUT 1ST DCB ADDR TO PORTAB
	SIS	R3,1			:NEXT PORT
	JGEBS	IZPOR1			:LOOP
	JR	R15

	IF	MAXHST
:	IZHOST:	INITIALIZE HOST TABLE ROUTINE
:	--------------------------------------
:	INPUT:	NONE
:		R13 - LINK REGISTER
:	OUTPUT: INITIALIZE HOST TABLE AND REPORT HOST STATUS
IZHOST
	LI	R7,HOSTAB+2+(MAXHST-1)*HSTLEN	:R7 = LAST HOSTAB
	LHI	R11,MAXHST-1		:HOST NUMBER COUNTER
IZHOS1
	LIS	R2,0			:START WITH NO FREE PORTS
	LB	R0,HSTUSR,R7		:IF MONITOR
	JNFS	IZHOS2			:NO, SKIP
	LHI	R2,MONPRT		:MONITOR PORTS ARE FREE
IZHOS2
	STH	R2,HSTPRT,R7		:UP PORTS
	STH	R2,HSTFPT,R7		:INIT FREE PORTS
	LIS	R2,0			:CLEAR THE
	STH	R2,HSTACT,R7		:ACTIVE PORTS
	STH	R2,HSTSPT,R7		:AND THE SHUT PORTS
	SHI	R7,HSTLEN		:NEXT HOST
	SIS	R11,1			:...
	JGE	IZHOS1			:LOOP

:	REPORT ALL HOST STATUS AND PORT AVAILABILITY TO SUP
:	---------------------------------------------------
:	REPORT HOST STATUS
:	IF SNA HOST, REPORTED WITH EXTENDED FORMAT
:	IF HOST UP PORTS = 0, THEN HOST DOWN
:	IF HOST UP PORTS > 0 AND FREE PORTS > 0, THEN HOST ANSWERED
:	IF HOST UP PORTS > 0 AND FREE PORTS = 0, THEN HOST SHUT
:	
:	REPORT HOST PORT AVAILABLILITIES
:	SOFTWARE SHUT, IF NO PORTS AVAILABLE
:
	LO	ISISC
	JAL	R6,HSTRPT,,		:REPORT ALL HOSTS STATUS
	FO	ISISC
					:AND PORT AVAILABILITY TO SUP
	JR	R13			:RETURN

	EI	(MAXHST)

:	IZBGD: INITIALIZE BACKGROUND DATA STRUCTURES
:	--------------------------------------------
:	INPUT:	NONE
:		R15 = LINK REGISTER
:	REGISTERS USAGE:
:		R14 = LNCTAB ADDR
:		R13 = PUCTAB ADDR
:		R12 = WORK REG (FOR SAVE)
:		R11 = LUCTAB ADDR
:		R10 = LINE #
:		R9  = PU REL # ON THE LINE
:		R8  = LU REL # ON THE PU
:		R1  = LINK REG FOR IZLNC
:		R2  = LINK REG FOR IZPUC
:		R3  = LINK REG FOR IZLUC
:		R6  = LINK REG FOR GETDCB
:	OUTPUT:	
IZBGD
	LIS	R10,NLINES-1		:SET UP R10
	LIS	R0,0			:SET R0 = 0
IZBGD1
	LHL	R14,LNCPTR,R10,R10	:SET R14=LNCTAB OFFSET
	AI	R14,LNCTAB		:R14 = LNCTAB ADDR
	JAL	R1,IZLNC		:INIT LNCTAB, PUCTAB, LUCTAB, ETC
	SIS	R10,1			:NEXT LINE
	JGE	IZBGD1			:IF MORE, LOOP
	JAL	R5,APRTIN		:(F00/02/10/87/DB)
					:INITIALIZE ATTPRT BIT IN LUCDIF

	JR	R15			:RETURN, IF DONE

:	IZLNC:	INIT LINE CONTROL BLOCK & SUB DATA STRUCTURES
:	------
:	INPUT & REGISTERS USAGES:	SEE IZBGD
IZLNC
	STB	R0,LNSHPU,R14
	STB	R0,LNACPU,R14
	STB	R0,LNSFLG,R14
	STB	R0,LNSTAN,R14
	LHL	R7,LNRBQA,R14
	STH	R7,LNRBUS,R14
	LHL	R7,LNXBQA,R14
	STH	R7,LNXBUS,R14
	LHI	R7,LINIT-PSEG		:INIT LINE STATE
	STH	R7,LNSTAT,R14		:...
	L	R7,SLOWC,,		:GET SLOW CLOCK
	AIS	R7,$A15			:GIVE FOREGROUND 15 SEC.
	ST	R7,LNTIME,R14		:...
	LHL	R13,LNPUTB,R14		:R13 = 1ST PUCTAB OFFSET ON THIS LINE
	AI	R13,PUCTAB		:R13 = ADDR
	LB	R9,LNMXPU,R14		:R9 = MAX # OF PU ON THIS LINE
IZLNC1
	JAL	R2,IZPUC		:INIT PUCTAB, LUCTAB, ETC
	AHI	R13,PUCLEN		:NEXT PUC
	SIS	R9,1			:ALL DONE?
	JG	IZLNC1			:NO, REPEAT
	JR	R1

:	IZPUC:	INIT PUCTAB AND ITS SUBDATA STRUCTURES
:	---------
:	INPUT:	SEE IZBGD
IZPUC
	STB	R0,PUALUN,R13
	STB	R0,PULSTA,R13
	LHL	R7,PURBQA,R13
	STH	R7,PURBUS,R13
	LHL	R7,PUXBQA,R13
	STH	R7,PUXBUS,R13
	LB	R7,LNASLK,R14
	NHI	R7,1			:SEE IF PRIMARY
	JEFS	IZPUC1			:SECONDARY , SKIP
	LO	DLCPRO
	IF	DLCPHD!DLCPFD
	LHI	R7,LPNDM-PSEG
	LHI	R6,IPNDM-PSEG
	JFS	IZPUC2
	ELSE
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
	EI
IZPUC1
	IF	DLCSHD!DLCSFD
	LHI	R7,LSNDM-PSEG
	LHI	R6,ISNDM-PSEG
	ELSE
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
	EI
	FO	DLCPRO
IZPUC2
	STH	R7,PULSNM,R13
	STH	R6,PUIFNC,R13
	STH	R0,PUCTIM,R13
	STH	R0,PUCATO,R13
	LB	R5,PUCT.N,R13
	RBT	R5,PUTFLG,,
	RBT	R5,INNWDL,,
	RBT	R5,TMNWDL,,
	RBT	R5,CLNWDL,,
:	INIT NWK->DLC Q
	JAL	R4,GETCL,,
	J	CLEMPT
	STH	RARG,PUDLCG,R13
	STH	RARG,PUDLCR,R13
	STH	RARG,PUDLCP,R13
	RBT	R5,CPNWDL,,
:	INIT DLC->NWK Q
	JAL	R4,GETCL,,
	J	CLEMPT
	STH	RARG,PUNWCG,R13
	STH	RARG,PUNWCR,R13
	STH	RARG,PUNWCP,R13
	RBT	R5,CPDLNW,,
	LB	R8,PUMLUN,R13		:R8 = MAX LU #
	LHL	R11,PUCLUC,R13
	AI	R11,LUCTAB		:R11 = LUCTAB ADDR
IZPUC3
	JAL	R3,IZLUC		:INIT LUCTAB AND SUB DATA STRUCTURES
	AHI	R11,LUCLEN		:NEXT LU
	SIS	R8,1			:ALL DONE?
	JGBS	IZPUC3			:NO, REPEAT
	JR	R2			:ELSE RETURN

:	IZLUC:	INIT LUC CONTROL BLOCK AND SUB DATA STRUCTURES
:	-----
:	INPUT:	SEE IZBGD
IZLUC
	STB	R0,LUNSTA,R11
	STB	R0,LUSSTA,R11
	STB	R0,LULSTA,R11
	STB	R0,LULUST,R11
	STB	R0,LULUWK,R11
	STB	R0,LUPSTA,R11
	STB	R0,LUCSCC,R11
	STH	R0,LUCTIM,R11
	STH	R0,LUCATO,R11
	LHL	R5,LUCT.N,R11
	RBT	R5,LUTFLG,,
	RBT	R5,STLGFL,,
	RBT	R5,FNLGFL,,
	RBT	R5,SNDFLG,,
	STH	R0,LULSCB,R11
	STH	R0,LUOSES,R11
	STH	R0,LUSSCB,R11
:	IF TERMINAL LINE, GET DCB, AND INIT
	STH	R0,LUCDCB,R11		:CLEAR LUCDCB AND LUADCB
	STH	R0,LUADCB,R11
	LB	R7,LUCMOD,R11
	LR	R7,R7			:SEE IF TERMINAL OR HOST
	JE	IZLUC2			:SKIP, IF NOT TERMINAL
	JAL	R6,GETDCB,,
	JNFS	IZLUC1			:IF NO DCB, CRASH
	JAL	R10,CRASH,,
	BC	0,0,0,0FF
IZLUC1
	STH	R12,LUCDCB,R11		:LINK DCB INTO LUC
	AI	R12,DCBLKS		:R12 = DCB ADDR
	LR	R7,R11			:GET OFFSET OF LUC
	SI	R7,LUCTAB
	STH	R7,DCBLUC,R12		:PUT LUC OFFSET INTO DCB
	LR	R7,R14			:GET OFFSET OF LNCTAB
	SI	R7,LNCTAB
	STH	R7,DCBLNC,R12		:PUT LNC OFFSET INTO DCB
	LR	R7,R13
	SI	R7,PUCTAB
	STH	R7,DCBPUC,R12		:PUT PUC OFFSET INTO DCB
	STB	R10,DCBLIN,R12		:LINE #
	LB	R6,PUPLAD,R13		:GET CU ADDR
	STB	R6,DCBCUA,R12
	LB	R6,LUCADR,R11		:GET LU ADDR
	STB	R6,DCBLUA,R12
	LB	R6,LUCFST,R11		:GET LU FST BYTE
	STB	R6,DCBFST,R12
	LB	R6,LUCDIF,R11		:GET LU DIF BYTE
	STB	R6,DCBDIF,R12
IZLUC2
	LHI	R6,FLHOSD-PSEG		:OSCAN DATA-Q PROC
	STH	R6,LUODPR,R11
	LHI	R6,FLHOSC-PSEG		:OSCAN CMD-Q PROC
	STH	R6,LUOCPR,R11
:	INIT SNA->NWK CMD Q
	JAL	R4,GETCL,,
	J	CLEMPT
	STH	RARG,LUNWCG,R11
	STH	RARG,LUNWCR,R11
	STH	RARG,LUNWCP,R11
	LHL	R5,LUCT.N,R11
	RBT	R5,CPSNNW,,
:	INIT SNA->NWK DATA Q
	JAL	R4,GETCL,,
	J	CLEMPT
	STH	RARG,LUNWDG,R11
	STH	RARG,LUNWDR,R11
	STH	RARG,LUNWDP,R11
	RBT	R5,DPSNNW,,
:	INIT NWK->SNA CMD Q
	JAL	R4,GETCL,,
	J	CLEMPT
	STH	RARG,LUSNCG,R11
	STH	RARG,LUSNCR,R11
	STH	RARG,LUSNCP,R11
	RBT	R5,CPNWSN,,
:	INIT NWK->SNA DATA Q
	JAL	R4,GETCL,,
	J	CLEMPT
	STH	RARG,LUSNDG,R11
	STH	RARG,LUSNDR,R11
	STH	RARG,LUSNDP,R11
	RBT	R5,DPNWSN,,
	JR	R3
:
:(F00/02/10/87/DB/START) CRM 4
:	APRTIN:	INITIALIZE ATTPRT BIT IN LUCDIF. ANY CRT LU WHICH HAS
:	------  THE SAME PU.LABEL/ADDRESS AND LU.LABEL/ADDRESS OF A PRT
:		LU, WILL BE ASSOCIATED WITH THAT PRT. THE ATTPRT BIT IN
:		THE CRT AND PRT LUCDIF WILL BE SET.
APRTIN
	LIS	R11,02			:GET LUCB OF FIRST LU

: ADVANCE THIS LU TO NEXT CRT LU

APRTI1
	AHI	R11,LUCLEN		:GET NEXT LUCB
	CHI	R11,MAXLUN*LUCLEN+2	:LAST LUCB?
	JGR	R5			:YES, RETURN
	LO	CBKDEF
	LB	R4,LUCTAB+LUCTYP,R11,	:GET THIS LU TYPE
	CLHI	R4,LU.T2		:IS THIS LU A CRT?
	FO	CBKDEF
	JN	APRTI1			:NO, GO TO NEXT LU
	LIS	R10,02			:YES, START CHECKING WITH FIRST LU

: ADVANCE NEXT LU TO NEXT PRT LU

APRTI2
	AHI	R10,LUCLEN		:GET LUCB OF NEXT LU
	CHI	R10,MAXLUN*LUCLEN+2	:SHOULD THIS NEXT LU BE CHECKED?
	JG	APRTI1			:NO, DONE WITH THIS CRT LU CHECK
	LO	CBKDEF
	LB	R4,LUCTAB+LUCTYP,R10,	:YES
	CLHI	R4,LU.T1		:IS THE NEXT LU LU.T1 PRINTER?
	JE	APRTI3			:YES, GO CHECK IF ASSOCIATED
	CLHI	R4,LU.T3		:NO, IS IT AN LU.T3 PRINTER?
	JN	APRTI2			:NO, GO CHECK NEXT LU
	FO	CBKDEF
: CRT LU FOUND 
: PRT LU FOUND 
: CHECK IF CRT LU HAS THE SAME LABEL/ADDRESS OF THE PRT LU
APRTI3
	IF	LABLSW
	LB	R3,LUCTAB+LUCLAB,R11,	:GET LU.LABEL OF CRT LU
	CLB	R3,LUCTAB+LUCLAB,R10,	:CRT LU.LABEL = PRT LU.LABEL?
	ELSE
	LB	R3,LUCTAB+LUCADR,R11,	:GET LU.ADDRESS OF CRT LU
	CLB	R3,LUCTAB+LUCADR,R10,	:CRT LU.ADDR = PRT LU.ADDR?
	EI
	JN	APRTI2			:NO, GO TO NEXT PRT LU

: CHECK IF CRT PU LABEL/ADDRESS MATCHES PRT PU LABEL/ADDRESS

	LHL	R4,LUCTAB+LUCPUC,R11,	:YES, GET PUCB OF CRT LU
	LHL	R3,LUCTAB+LUCPUC,R10,	:GET PUCB OF PRT LU
	IF	LABLSW
	LB	R4,PUCTAB+PUCLAB,R4,	:GET PU.LABEL OF CRT LU
	CLB	R4,PUCTAB+PUCLAB,R3,	:CRT PU.LABEL = PRT PU.LABEL?
	ELSE
					:(3.f01/07/24/87/db/start)
:	LB	R4,PUCTAB+PUCADR,R4,	:GET PU.ADDRESS OF CRT LU
:	CLB	R4,PUCTAB+PUCADR,R3,	:CRT PU.ADDR = PRT PU.ADDR?
	LB	R4,PUCTAB+PUPLAD,R4,	:GET PU.ADDR OF CRT
	CLB	R4,PUCTAB+PUPLAD,R3,	:CRT PU.ADDR = PRT PU.ADDR?
					:(3.F01/07/24/87/DB/END)
	EI
	JN	APRTI2			:NO, GO TO NEXT PRT LU

: PU.LABEL/ADDRESS AND LU.LABEL/ADDRESS OF THIS LU AND NEXT LU MATCH
: ATTACH CRT LU  TO PRT LU 
	LB	R4,LUCTAB+LUCDIF,R11,	:YES, GET DEVICE INF FOR CRT LU
	OHI	R4,ATTPRT		:ATTACH TO PRINTER
	STB	R4,LUCTAB+LUCDIF,R11,

	LB	R4,LUCTAB+LUCDIF,R10,	:GET DEVICE INF FOR PRT LU
	OHI	R4,ATTPRT		:SET ATTACH BIT
	STB	R4,LUCTAB+LUCDIF,R10,	
	J	APRTI2			:GO CHECK IF NEXT LU ALSO MATCHES

					:(F00/02/10/87/DB/END)

:	CLEMPT:	CMD LIST EMPTY
:	------
CLEMPT
	JAL	R10,CRASH,,
	BC	0,0,0,0FF


	FO	GBLDEF
	FO	BSUB
	EM
	SUBTTL	STATUS.LIB . . . .DRIVER TO PROCESS ARBITRARY COMMANDS UNDER "?STAT"
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

    IF	  1-\DB.STA		:DEFAULT DEBUG/STATUS TO ON
DB.STA	EQ	1
    EI

  IF	DB.STA				:ASSEMBLE ONLY WITH DEBUG STATUS ON

	SEG	A.CODE
	MO	.,STATUS
	RA	$00
	GL	DB.NTC

  IF	1-\DB.NTC
DB.NTC	EQ	0		: Default Network Console protocol to off
  EI

	GL	DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM,DS.BDN
	GL	DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL
  IF	DB.NTC
	GL	DS.NXT,DS.CHK
  EI

:	STATUS - User Command Handler
:
:	Version history:
:	13.3  07/11/84  The following changes were made by Romolo Raffo.
:		Network Console protocol was added. This allowed Network
:		Console to communicate with Extended DDT Operations Managers.
:		The new features are controled by the assemble switch DB.NTC.
:		The default for this switch is off, so any program can use
:		this version of STATUS.LIB without change. Network Console
:		protocol is invoked by a command composed of four unprintable
:		characters. This is so hopefully no one will inadvertently
:		enter Network Console mode. If Network Console mode, the prompt
:		is no longer output, and the request for a "\" to be typed
:		after an error is removed. All commands received in this mode
:		begin with hex 8080 followed by a halfword id. The command
:		following this header is unchanged. The response begins with
:		a hex 8081 followed by the commands halfword id. The response
:		following this header is also unchanged, consisting of multiple
:		lines, each ending with a carriage return and a linefeed. After
:		the response, a trailer of hex 8082, the command id and an
:		empty line is sent. All of this is handle by STATUS.LIB,
:		without any change to the program using this package.
:
:		To use Network Console protocol, the following changes must be
:		made.
:			1) The variable DB.NTC must be set to one. This will
:			   cause the code to handle Network Console protocol
:			   to be assembled.
:			2) All jumps to label DSTART should be replaced by
:			   jumps to DS.NXT . The label DSTART is where DDT
:			   enters from the ?STAT command. It is now used to
:			   initialize the code to not using Network Console
:			   protocol.
:			3) Commands which have indefinite and possibly unending
:			   response, and need a way to abort the command,
:			   must call DS.CHK to check if the response should
:			   should end. If Network Console protocol, this call
:			   checks for a command end message from Network
:			   Console. Otherwise, it checks if any character has
:			   been entered. In either case, it does a normal
:			   return if no termination was received, and a skip-4
:			   return if termination was found.
:
:		Note that with these changes, users will still be able to use
:		the ?STAT command directly from DDT without any change.
:	13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:		following 'QUIT' SVC to allow DDT "P" (proceede) command
:		to return the user to ":>" prompt.
:	13.1  11/17/81	<BAB>Added DNEXTK support, DS.DLM (last delimeter),
:		and fixed backspace for > 4 character entry, added the
:		command thought to be invalid to invalid command message.
:	13	08/81	<JK>Maintenance assumed by BAB from John Kopf
:
:		The Status package is intended to provide an extension to DDT,
:	invokable via the "?STAT" command in DDT.  Once invoked you may re-
:	activate it (provided you have not issued any DDT "G" (go) commands)
:	by typing "P ".
:
:		There is limited editing control built into the package:
:	ESC	aborts back to command level,
:	^W	discards partial 'token' already input (word or number),
:	^A	discards last char of token (backspace).
:	^H	discards last char of token (backspace).

:		Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:	delimiters are:
:	C/R	L/F	H/T	","	and BLANK.

:		Entry Points:
:	DSTART	Initialize STATUS.LIB on new circuit.
:	DS.NXT	Place to exit on completion of command.
:	DNEXTK  Get next token with out prompt.
:	DS.ILL	Place to exit on illegal command -- types "Illegal command"
:	DS.ERR	Place to exit on command error -- types "type '\' "
:	DS.EXI	Place to exit machine.
:	DS.QUI	Place to exit back to DDT.
:	DS.GCH	Get a character...Link on R1, char (with high-order bit forced)
:			in R0...normal return if detected ^W, skip-4 if detect
:			~A, aborts back to DS.NXT if detects ESC.
:	DS.DEL	Check for delimiter...Link on R2, Character in R0.  Skip-4
:			return unless this is a delimiter, then normal return.
:	DS.CUC	Convert to upper case...Link on R1, Character in R0.
:	DS.TOK	Get a string token...Link on R4, TOKEN returned in R3...
:			inputs up to 4 characters, returns them (in uppercase)
:			left justified, 0 fill
:	DS.NUM	Get a number...Link on R5, expects Radix in R4...
:			number returned in R0.  May ABORT if any character is
:			input other than valid digit or delimiter.
:	DS.CHK	Check if command termination entered...Link on R4. Skip-4
:			if termination entered, otherwise takes normal return.
:	DS.DLM  Location of last delimeter entered (1 byte)

:		There are two built-in commands:
:	Quit	exit back to DDT.
:	EXIt	exit machine.

:		additional commands may be defined via the DS.CMD macro:
:	 DS.CMD(TEXT,ADDR)
:	Where:	TEXT	The (UPPERCASE) target command string.
:		ADDR	The virtual address to transfer to, to service that
:				command.
:	DS.CMD generates a 12-byte discriptor for this command, at the point
:	assembly where it is invoked.  This discriptor is on a WORD boundary.



OUT	EQ	0B			:OUTPUT SVC
IN	EQ	0A			:INPUT SVC

DS.ELL	EQ	0			:NULL POINTER FOR END OF LINKED LIST

	SEG	A.DATA
DS.DLM	BS	1			:LAST DELIMETER ENCOUNTERED
  IF	DB.NTC
NC.REF	BS	1			: Nonzero if end of response sent
NC.PRO	BS	1			: Nonzero if using NTCN protocol
:	Force NC.ID data (two bytes after length) to begin on a halfword
:	boundry. This is needed for compares and stores from HDR.ID
	ORG .-1; BND 1; ORG .+1
NC.ID	SC	/00/			: Current NTCN command id
HDR.ID	HS	1			: Last message header id
  EI
R4SAV	WS	1			:SAVE AREA FOR R4 IN DS.TOK
BADSTR	SC	/'xxxx'"8D"8A/		:PLACE TO PUT BAD COMMAND
BADNUM  SC      / Bad number /
	SEG	A.CODE

:	DEFINE ELEMENTS FOR COMMAND BLOCK
C.NEXT	EQ	0			:POINTER TO NEXT ENTRY
C.ADDR	EQ	C.NEXT+4		:POINTER TO COMMAND HANDLER
C.STR	EQ	C.ADDR+4		:RELATIVE POSITION OF STRING

:	DEFINE MACRO TO GENERATE THIS COMMAND BLOCK
DS.CMD	MACRO(STR,ADDR)[
   IF	DS.ELL
Q	WS	0
	ORG	DS.ELL
	WC	Q
	ORG	Q
   EI
DS.ELL	WC	0,ADDR
	AC	/STR/
	BND	4
]


:	TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST	WS	0			:FORCE TO WORD BOUNDARY
	DS.CMD(Q,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(QUIT,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(EXIT,DS.EXI)		:EXIT 
	DS.CMD(EXI,DS.EXI)		:EXIT 
  IF	DB.NTC
	DS.CMD("80"82"84"86,DS.NTC)	: Enter Network Console Protocol
  EI

  IF	DB.NTC
:	Network Console Messages
BEGRSP	SC	/"80"81/
ENDRSP	SC	/"80"82/
CRLF	SC	/"8D"8A/
ERRMES	SC	/"80"84"00/
  EI


:	DIAGNOSTIC MESSAGES
TERR	SC	/Illegal command /
TTERR	SC	/type '\'"8D"8A/
PROMPT	SC	/"8D"8A:>/		:"CR|LF:>"
BKSPAC	SC	/"88 "88/		:BACK SPACE
	SUBTTL	COMMAND SCANNER, VERIFIER, AND BITCHER


:	COMMAND INPUT HANDLER
DOIT	L	R0,C.ADDR,R1		:GO SERVICE THIS COMMAND
	JALR	R0,R0

:	NEXT COMMAND
DSTART
	JAL	R10,SETMAC,,		:Switch to MAC set 0 (02/18/87 YLH)
  IF	DB.NTC
	LIS	R0,0
	STB	R0,NC.PRO,,		: Turn off Network Console protocol
  EI
DS.NXT
  IF	DB.NTC
	LB	R1,NC.PRO,,		: Get Network Console protocol flag
	JE	DSNXT3			: If zero, use normal protocol
	JAL	R3,NC.END		: Send end of response message
DSNXT1	JAL	R1,NC.GCH		: Get first character of message header
	CLHI	R0,80			: Is this a message header?
	JNBS	DSNXT1			: No, ignore all chars before header
	JAL	R2,NC.HDR		: Get a message header
	CLHI	R3,85			: Is it a command termination?
	JN	DSNXT2			: No, go try command begin
	LH	R3,HDR.ID,,		: Get id in message header
	CLH	R3,NC.ID+1,,		: Is it the same as in last command?
	JN	NCPER0			: No, go send error message.
	JAL	R1,NC.GCH		: Get first character of command header
	JAL	R2,NC.HDR		: Get rest of command header
DSNXT2	CLHI	R3,80			: Is it a command header?
	JN	NCPER1			: No, go send error message.
	LH	R3,HDR.ID,,		: Get id from command header
	STH	R3,NC.ID+1,,		: And save for response
	SVC	OUT,BEGRSP		: Send response header
	SVC	OUT,NC.ID,,		: Including command id
	LIS	R0,0			: Get false for response end flag
	STB	R0,NC.REF,,		: and set to response end needed
	J	DNEXTK			: Go get command token
DSNXT3
  EI
	SVC	OUT,PROMPT		:ISSUE PROMPT
DNEXTK	JAL	R4,DS.TOK		:GET COMMAND TOKEN
	LA	R1,CMDLST		:SEARCH FOR STRING MATCH
DSTAR1	CL	R3,C.STR,R1
	JE	DOIT			:PROCEED IF FIND A MATCH
	L	R1,C.NEXT,R1		:ELSE CONTINUE SCAN
	JGBS	DSTAR1
DS.ILL	SVC	OUT,TERR		:"ILLEGAL COMMAND"
	ST	R3,BADSTR+2,,		:"XXX"<CR>
	SVC	OUT,BADSTR,,
DS.ERR
  IF	DB.NTC
	LB	R1,NC.PRO,,		: Is Network Console protocol inuse?
	JN	DS.NXT			: Yes, don't bitch
  EI
	SVC	OUT,TTERR		:TELL USER TO TYPE FLUSH CHAR
BITCH	JAL	R1,DS.GCH		:FLUSH INPUT
	JBS	BITCH;	 NOPR	0			:^W...IGNOR
	JBS	BITCH;	 NOPR	0			:^A...IGNOR
	CLHI	R0,0DC			:READ UNTIL "\" IS FOUND
	JNBS	BITCH
	J	DS.NXT			:THEN EXIT

DS.BDN  SVC     OUT,BADNUM,,
        J       DS.ERR

:	BUILT-IN COMMANDS

:		Command EXIt
:		===========-
DS.EXI	SVC	KIO,0			:DISCONNECT


:		Command Quit (exit back to DDT)
:		=========---
DS.QUI	SVC	KIO,1			:RETURN TO DDT
	J	DS.NXT			:IF OPERATOR TYPED "P", GET NEXT COMMAND

  IF	DB.NTC
:		Command for entering Network Console protocol mode
:		==================================================
DS.NTC	LIS	R1,1			: Get nonzero value for protocol flag
	STB	R1,NC.PRO,,		: Store in flag
	STB	R1,NC.REF,,		: Also set response end seen flag
	J	DS.NXT			: Go start Network Console command
  EI
	SUBTTL	U T I L I T I E S

:	GET A COMMAND TOKEN...UP TO 4 CHARS LONG
:		SKIPS OVER EXTRA CHARACTERS TO NEXT DELIMITER
:	LINK ON R4
:	TOKEN RETURNED IN R3, LEFT JUSTIFIED
DS.TOK	HS	0
	ST	R4,R4SAV,,		:SAVE R4
TOKEN0	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	TOKEN0;	 NOPR	0			:^W...IGNORE
	JBS	TOKEN0;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:SKIP OVER DELIMITERS
	J	TOKEN0
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	CHI	R0,00DC			:= "\" ?
	JE	DS.NXT			:YES, PRINT PROMPT, GET NEXT COMMAND
	LBR	R3,R0			:SET UP STRING ACCUMULATOR (000000CC)
	LIS	R4,1			:1 CHAR. FOUND SO FAR
TOKEN	JAL	R1,DS.GCH		:GET ANOTHER CHAR
	J	TOKEN0			:^W...START OVER
	J	TOKEN3			:^A...TOSS LAST CHAR
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	J	TOKEN1			:GOT ONE...SKIP TO LEFT JUSTIFY IT
	CHI	R0,00DC			:= "\" ?
	JE	DS.ILL			:YES, TREAT AS ILLEGAL
	AIS	R4,1			:ONE MORE CHARACTER
	CHI	R4,4			:IF => 4 CHARS, DO NOT USE THIS ONE
	JG	TOKEN			:YES...SCAN FOR DELIMITER
	SLLS	R3,8			:NO...ACCUMULATE CHARS
	STBR	R0,R3
	J	TOKEN			:AND GET ANOTHER CHAR
TOKEN1	HS	0
	L	R4,R4SAV,,		:RESTORE R4
TOKEN2	TI	R3,0FF000000		:HAVE WE 4 CHARS ALREADY?
	JNR	R4			:YES...RETURN TOKEN IN R3
	SLLS	R3,8			:NO...JUSTIFY IT
	JBS	TOKEN2			:AND REPEAT

TOKEN3	HS	0			:HANDLE BACKSPACE IN TOKEN
	SIS	R4,1			:ONE LESS CHAR
	CHI	R4,4			:IF AFTER BACKSPACE TOKEN IS => 4
	JGE	TOKEN			: JUST DECRIMENT COUNTER
	SRLS	R3,8			:ELSE... DROP 1 CHARACTER
	J	TOKEN			:AND GET NEXT CHAR.

:	UTILITY ROUTINE TO READ A NUMBER
:	USES R0-R3
:	EXPECTS RADIX IN R4
:	LINK ON R5
:	ABORTS IF FIRST NON-DELIMITER IS NOT DIGIT
:	ELSE RETURNS NUMBER IN R0
DS.NUM	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	DS.NUM;	 NOPR	0			:^W...IGNORE
	JBS	DS.NUM;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER CHAR
	J	DS.NUM
	JAL	R2,DS.DIG		:TEST IF CHAR IS DIGIT
	J	DS.ILL			:NOT A DIGIT - GIVE ERROR MESSAGE
	CLR	R0,R4
	JGE	DS.ILL			:DIGIT IS BIGGER THAN RADIX...ABORT
	LR	R3,R0			:PUT FIRST DIGIT INTO ACCUMULATOR
NUMBER	JAL	R1,DS.GCH		:READ NEXT CHAR
	J	DS.NUM			:^W...START OVER
	J	DIVIDE			:^A...TOSS LAST DIGIT
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	LR	R0,R3;	 JR	R5	  :YES
	JAL	R2,DS.DIG		:SKIP IF DIGIT
	J	DS.ILL			:NO...ABORT
	CLR	R0,R4
	JGE	DS.ILL			:RADIX ERROR...BITCH
	MR	R2,R4			:BUILD NUMBER
	AR	R3,R0			:ADD NEW DIGIT
	J	NUMBER			:GET NEXT DIGIT
DIVIDE	LIS	R2,0			:GOT A ^A...MAKE DOUBLE-PRECISION ARG.
	DR	R2,R4			:QUOTENT INTO R3, WHERE WE WANT IT
	J	NUMBER			:NOW GO BACK FOR MORE DIGITS

:	DIGIT TEST
:	CHECK CHARACTER READ...SKIP RETURN IF DIGIT
:	THEN R0=BINARY VALUE OF HEX DIGIT
:	USES R1, LINK ON R2
DS.DIG	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	LR	R1,R0			:COPY CHAR
	SHI	R1,0B0			:IS IT "0"?
	JLR	R2			:RETURN IF LESS THAN "0"
	SIS	R1,0B9-0B0		:IS IF "9"
	JLEFS	DIGIT			:LESS THAN "9" THEN A GOOD DIGIT
	SIS	R1,0C1-0B9		:IS IT "A"?
	JLR	R2			:RETURN IF LESS THAN "A"
	SIS	R1,0C6-0C1		:IS IF "F"?
	JGR	R2			:RETURN IF GREATER THAN "F"
	SIS	R0,7			:0A - "A" (PARTIAL CONVERSION)
DIGIT	SHI	R0,0B0			:"0"
	J	4,R2			:SKIP RETURN

:	CHECK FOR DELIMITER
:	LINK	R2
:	USES	R0,R1
:	SKIP-4 RETURN UNLESS (R0) IS A DELIMITER CHARACTER
DS.DEL	LHI	R1,DLEN-1		:NUMBER OF DELIMITER CHARS
	STB	R0,DS.DLM,,		:SAVE DELIMITER
DELIM	CLB	R0,DLIST,R1		:COMPARE TO A DELIMITER
	JER	R2			:RETURN IF DELIMITER
	SIS	R1,1			:CHECK NEXT DELIMITER
	JGEBS	DELIM			:LOOP IF ANY MORE DELIMITERS
	J	4,R2			:SKIP RETURN
:	LIST OF DELIMITER CHARS
DLIST	AC	' ,'			:BLANK,","
	BC	8D,8A,89		:CR,LF,HT
DLEN	EQ	.-DLIST			:NUMBER OF DELIMITER CHARS

:	INPUT A CHARACTER
:	LINK	R1
:	NORMAL RETURN:  ^W INPUT...FLUSH ENTRY
:	SKIP-4 RETURN:  ^A or ^H INPUT...FLUSH LAST CHAR
:	SKIP-8 RETURN: CHAR IN R0 (HIGH-BIT ON)
:	ABORTS TO COMMAND SCANNER ON "ESC"
DS.GCH	SVC	IN,0F			:GET THE CHAR
	J	DS.GCH
	OHI	R0,80			:SET HIGH-ORDER BIT
	CLHI	R0,9B			:CHECK FOR ESCAPE
	 JE	DS.NXT			:ABORT, PROCEED WITH PROMPT IF SO
	CLHI	R0,97			:CHECK FOR ^W
	 JER	R1			:NORMAL RETURN
	CLHI	R0,81			:CHECK FOR ^A
	 JE	4,R1			:SKIP-4 RETURN
	CLHI	R0,88			:CHECK FOR ^H
	 JN	8,R1			:NO, SKIP-8 RETURN, CHAR IN R0

	SVC	OUT,BKSPAC		:BACK SPACE
	J	4,R1			:SKIP-4 RETURN FOR ^H

:	CONVERT CHAR IN (R0) TO UPPER CASE
:	LINK ON R1
DS.CUC	CLHI	R0,0E1			:COMPARE WITH "a"
	JLR	R1			:EXIT IF IT CAN'T BE LOWERCASE
	CLHI	R0,0FA			:COMPARE WITH "z"
	JGR	R1			:NOT LOWER CASE...JUST RETURN
	SHI	R0,20			:LOWER CASE...CONVERT TO UPPER
	JR	R1			:AND RETURN

  IF	DB.NTC
:	Check for command termination
:	Link	R4
:	Uses	R0, R1, R2, R3
:	Normal return:	Termination not found
:	Skip-4 return:	Command termination received
DS.CHK
	LB	R0,NC.PRO,,		: Is Network Console mode active?
	JN	DSCHK1			: Yes, go check for message.
	SVC	IN,00			: No, just check for any character.
	JR	R4			: Command termination not found
        BC      0,0                     : Align to word boundary
	J	4,R4			: Command termination found
DSCHK1	SVC	IN,00			: Get first character of header
	JR	R4			: Command termination header not found
        BC      0,0                     : Align to word boundary
	JAL	R2,NC.HDR		: Get a message header
	CLHI	R3,85			: Is it a command termination?
	JN	NCPER2			: No, go send error message.
	LH	R3,HDR.ID,,		: Get header id
	CLH	R3,NC.ID+1,,		: Is it the correct id?
	JN	NCPER0			: No, go send error message.
	J	4,R4			: Yes, command termination found

:	Read a Network Console message header. First character passed in R0.
:	First byte must be a hex 80.
:	Link	R2
:	Uses	R0, R1, R3
:	Returns	second byte of header in R3 and message id in HDR.ID.
NC.HDR	CLHI	R0,80			: Does message header begin with 80?
	JN	NCPER3			: No, go send error message.
	JAL	R1,NC.GCH		: Get second character of header.
	LR	R3,R0			: Save in R3
	JAL	R1,NC.GCH		: Get first character of id
	STB	R0,HDR.ID,,		: and save
	JAL	R1,NC.GCH		: Get second byte of header
	STB	R0,HDR.ID+1,,		: and also save it
	JR	R2

:	Input a character. Wait until one is received. Return character in R0.
:	Link	R1
NC.GCH	SVC	IN,0F			: Get next character of header
	J	NC.GCH			: Loop until received
	JR	R1

:	Send an protocol error message to Network Console
:
:	Code	Meaning
:	----	-------
:	0	The id in a command end message (type 85) does not match the
:		id in the command message.
:	1	Expected a command message and did not receive one.
:	2	Received a message other than command end in DS.CHK call.
:		A call to DS.CHK should only be done for commands which
:		need termination, i.e. which have not sent end of response.
:		These commands can only receive command end.
:	3	Message header does not begin with a hex 80.
:
NCPER0	LIS	R0,0			: Error code = 0
	J	NC.ERR			: Go send error message
NCPER1	LIS	R0,1			: Error code = 1
	J	NC.ERR			: Go send error message
NCPER2	LIS	R0,2			: Error code = 2
	J	NC.ERR			: Go send error message
NCPER3	LIS	R0,3			: Error code = 3
	J	NC.ERR			: Go send error message

NC.ERR	JAL	R3,NC.END		: Send response end, if needed
	SVC	OUT,ERRMES		: Send error message header
	SVC	KIO,0E			: Output error code in R0
	J	DS.NXT			: Return to command loop

:	Send end of response message, if not already sent
:	and set flag that it has been sent.
:	Link	R3
:	Uses	R1
NC.END	LB	R1,NC.REF,,		: Get response end sent flag
	JNR	R3			: No need to send, already sent
	SVC	OUT,CRLF		: Insure response has at least one line
	SVC	OUT,ENDRSP		: End previous response
	SVC	OUT,NC.ID,,		: Include command id
	SVC	OUT,CRLF		: and blank line
	LIS	R1,1			: Get true for response end sent
	STB	R1,NC.REF,,		: and set flag
	JR	R3

  EI

	EM

  EI	:(DB.STA)
 	SUBTTL	(SNA) EXTENDED SDLC DDT MODULES - STATUS
:XDDT00.F00

	SEG	A.CODE
	MO	.,STATUS
	LO	CRASH
	LO	MAIN
	LO	GBLDEF
	LO	CBKDEF

:-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
DECB.3	EQ	032A	:WIDTH= 3, BLANK FILL, BASE=10
DECB.9	EQ	092A	:WIDTH= 9, BLANK FILL, BASE=10
HEXB.3	EQ	0330	:WIDTH= 3, BLANK FILL, BASE=16
HEXZ.4	EQ	0450	:WIDTH= 4,  ZERO FILL, BASE=16
HEXB.5	EQ	0530	:WIDTH= 5, BLANK FILL, BASE=16
HEXZ.5	EQ	0550	:WIDTH= 5,  ZERO FILL, BASE=16
HEXZ.8	EQ	0850	:WIDTH= 8,  ZERO FILL, BASE=16
HEXB.9	EQ	0930	:WIDTH= 9, BLANK FILL, BASE=16
HEXB.A	EQ	0A30	:WIDTH=10, BLANK FILL, BASE=16

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	D A T A    A R E A S					  ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	SEG	A.DATA
PRICNT	HS	1
	SEG	A.CODE

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		DDT COMMANDS, 'ZZ' AND '\'			  ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	DS.CMD(CB,DS.QUI)		:QUIT IF NAD TRIES TO GO INTO
	DS.CMD(CA,DS.QUI)		: ASCII OR BINARY MODE

	IF	DB.NTC			:IF NETWORK CONSOLE
	ELSE
	DS.CMD(ZZ,DS.EXI)		:ALLOW ZZ TO LOG OFF ALSO
	EI	(DB.NTC)

	DS.CMD(\,DDTNOP)
:DDTNOP	J	DSTART			:PRINT PROMPT, LOOK FOR NEXT TOK.
DDTNOP	J	DS.NXT			:PRINT PROMPT, LOOK FOR NEXT TOK.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		HELP AND '?'					  ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	DS.CMD(HELP,DDTHLP)
	DS.CMD(?,DDTHLP)

DDTHLP	HS	0
	LA	R1,HLPDAT		:GET START OF HELP DATA
DDTHL1	HS	0
	LB	R0,0,R1			:TEST FOR DONE
	JE	DDTHL9			:ZERO = DONE
	SVC	OUT,0,R1		:OUTPUT IT
	AR	R1,R0			:GET NEXT LINE
	AIS	R1,1			:+ 1 BYTE FOR THE LENGTH
	JBS	DDTHL1			: TIL DONE
:
DDTHL9	J	DDTNOP			:WAIT FOR NEXT COMMAND
:
:
	NOLIST
HLPDAT	EQ	.
	SC	/	SNA"2FSDLC Extended DDT"8D"8A/
CRLF	SC	/"8D"8A/
	SC	/--- Syntax ---   --- Action ---------------------------------------"8D"8A/
	SC	/ALL            Foreground and Background Trace"8D"8A/
	SC	/ALLS           Foreground and Background Trace (Short Format)"8D"8A/
	SC	/DIR  <arg>     Display Dispatcher Input Ring"8D"8A/
	SC	/                 From Address <arg> or Start"8D"8A/
	SC	/DLK            Display Real-Time Link Trace"8D"8A/
	SC	/DLKO <arg>     DispLay Link Trace Offline"8D"8A/
	SC	/                 From Address <arg> or Start"8D"8A/
	SC	/DLKS           Display Real-Time Link Trace (Short Format)"8D"8A/
	SC	/DNT            Background Real-Time Trace"8D"8A/
	SC	/DNTO <arg>     Background Offline Trace Display"8D"8A/
	SC	/                 From Address <arg> or Start"8D"8A/
	SC	/DNTS           BackgRound real-Time Trace (Short Format)"8D"8A/
	SC	/DOR  <arg>     Display Dispatcher Output Ring"8D"8A/
	SC	/                 From Address <arg> or Start"8D"8A/
	SC	/DR             Display both Rings continuously"8D"8A/
	SC	/DRRG           Enable Normal Format Display for IRING and ORING"8D"8A/
	SC	/DRSF           Enable Short Format Display for IRING and ORING"8D"8A/
	SC	/EXI            Log Off"8D"8A/
	SC	/FASTC          Select the FASTC as the Clock Source"8D"8A/
	SC	/GMT            Select the GMT as the Clock Source"8D"8A/
	SC	/HELP or ?      Print This List"8D"8A/
	SC	/IFOFF          Disable INF Frame Only Trace"8D"8A/
	SC	/IFON           Enable INF Frame Only Trace"8D"8A/
	SC	/INOFF          Disable Background Input Trace"8D"8A/
	SC	/INON           Enable Background Input Trace"8D"8A/
	SC	/LINK <arg>     Specify the Line # for Link Trace Commands"8D"8A/
	SC	/OTOFF          Disable Background Output Trace"8D"8A/
	SC	/OTON           Enable Background Output Trace"8D"8A/
	SC	/Q              Back to DDT"8D"8A/
	SC	/RVOFF          DisabLe RCV link Trace for Line <arg>"8D"8A/
	SC	/RVON           Enable RCV Link Trace for Line <arg>"8D"8A/
	SC	/SYM            Print a list of symbol addresses"8D"8A/
	SC	/TMOFF          Disable Link Trace With Time Stamp"8D"8A/
	SC	/TMON           Enable Link Trace With Time Stamp"8D"8A/
	SC	/XROFF          Disable XMT"2FRCV Link Trace for Line <arg>"8D"8A/
	SC	/XRON           Enable XMT"2FRCV Link Trace for Line <arg>"8D"8A/
	SC	/XTOFF          Disable XMT Link Trace for Line <arg>"8D"8A/
	SC	/XTON           Enable XMT Link Trace for Line <arg>"8D"8A/
	IF	DB.NTC			:IF NETWORK CONSOLE
	ELSE
	SC	/ZZ             Log off"8D"8A/
	EI	(DB.NTC)
	SC	/"AF              Terminate Display"8D"8A/
	SC	/"8A/

	BC	0
	LIST

SPACE1	SC	/ /
SPACE2	SC	/  /
STAR	SC	/*/

	HS	0			:COMMAND TABLE MUST BE ALLIGNED
CMDTLI	AC	'bsbe'			:BREAK START, BREAK END

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::								::
::	SYMBOLC LIST						::
::								::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:
:  SYMBOL GENERATION MACRO
:
SYMGEN	MACRO(NAME) [
	IF	1-\SYMNAM
SYMNAM	EQ	.
SYM.NO	EQ	0
	EI
	SC	/NAME  /
SYAD|SYM.NO|	EQ	NAME
SYM.NO	EQ	SYM.NO+1
	]
:
:  SYMBOL TABLE END
:
SYMEND	MACRO [
Q	EQ	0
SYMADR	WS	0
	RE	SYM.NO
	WC	SYAD|Q|
Q	EQ	Q+1
	ER
	WC	0			:TERMINATE LIST
	]

	DS.CMD(SYM,DDTSYM)

DDTSYM
	LA	R2,SYMNAM		:POINT AT SYMBOL LIST
	LA	R3,SYMADR
DDTSY1
	L	R0,0,R3
	JE	DDTNOP			:DONE
	SVC	OUT,CRLF
	LHI	R1,HEXZ.5
	SVC	KIO,$A10
	SVC	OUT,SPACE2
	SVC	OUT,0,R2
	LB	R0,0,R2
	AR	R2,R0
	AIS	R2,1
	AIS	R3,4
	J	DDTSY1

:
:	SYMBOL TABLE
:
	SYMGEN(IRING)
	SYMGEN(ORING)
	SYMGEN(PORTAB)
	SYMGEN(BBUFER)
	SYMGEN(DCBLKS)
	LO	SFGRCV
:	SYMGEN(PTPTTB)
:	SYMGEN(PTRBIT)
:	SYMGEN(PTPTRX)
	FO	SFGRCV
	SYMGEN(CRAT)
	SYMGEN(LCBTAB)
	SYMGEN(LSCLKS)
	SYMGEN(SCBBLK)
	SYMGEN(NCBBLK)
	SYMGEN(EVBLK)
	SYMGEN(PCBBLK)
	SYMGEN(PUCTAB)
	SYMGEN(LNCTAB)
	SYMEND

	FO	CRASH
	EM
    	SUBTTL	(SNA) XDDT - ISIS RING INTERPRETER - STATUS
:RNGI00.F00


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	ISIS RING INTERPERTER					::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::								::
::	This package will decode ISIS dispatcher rings and	::
::	display them on a DDT port.  Messages thas may contain	::
::	meaningful ASCII text (data, needles, and 1DOWN) are	::
::	displayed in hex and ASCII.  All other messages are	::
::	displayed only in hex.					::
::								::
::	Requirments:						::
::		This code requires ISIS-II version 5 (or above)	::
::		and the STAT.LIB library.  It uses the message	::
::		length tables in segment F (15d) in ISIS.	::
::								::
::	Commands:						::
::		This package includes 2 commands.  With this	::
::		set of commands you may examine rings that	::
::		have, and have not wrapped.  Also any output	::
::		from these commands may be terminated by typing	::
::		any character ("\" is recomended).  All 	::
::		commands may be followed by an optional number.	::
::		This number represents the number of seconds	::
::		to wait looking for new ring activity.  This	::
::		may beused to observe rings for N seconds, in	::
::		'real time'.					::
::								::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
        MO      .,STATUS
	LO	MAIN
:
LENGTH	EQ	0F0028		:SEG E AND SEG F DATA AREAS
LP0LST	EQ	0F0026
NPORTS	EQ	0E0082
IRINGP	EQ	0E0068		:CONTAINS START OF INPUT RING
ORINGP	EQ	0E006C		:CONTAINS START OF OUTPUT RING
IMAXI	EQ	0E0084		:CONTAINS INPUT RING SIZE (HALFWORD)
OMAXI	EQ	0E0086		:CONTAINS OUTPUT RING SIZE (HALFWORD)
RING	EQ	4		:4 BYTES PAST 1ST POINTER IS RING
NFMI	EQ	0		:FILL POINTER

        SEG     A.DATA
XDIIND  HS      1               :INPUT INDEX
XDOIND  HS      1               :OUTPUT INDEX
XDCOMP	HS	1		:COMPACT FOMAT FLAG
XEBCDI	HS	(MAXPRT+0F)/10	:DISPLAYED AS EBCDIC

	SEG	A.CODE

:********************************
:
:  DISPLAY INPUT RING
:
:********************************
	DS.CMD(DIR,XDIR)		:DISPATCHER INPUT RING
:
XDIR
        JAL     R14,XDRPRI      :GET PARAMETERS
        SVC     0B,XDCRLF,,
XDIRLP
        JAL     R14,XDRKBD      :TEST KYBD INPUT
        J       DDTNOP          :DONE
        JAL     R14,XDRDIR      :INPUT RING
        SVC     DISMISS,0
        J       XDIRLP

:*******************************
:
:  DISPLAY OUTPUT RING
:
:*******************************
	DS.CMD(DOR,XDOR)		:DISPATCHER OUTPUT RING
:
XDOR
        JAL     R14,XDRPRO      :GET PARAMETERS
        SVC     0B,XDCRLF,,
XDORLP
        JAL     R14,XDRKBD      :TEST KYBD INPUT
        J       DDTNOP          :DONE
        JAL     R14,XDRDOR      :OUTPUT RINNG
        SVC     DISMISS,0
        J       XDORLP

:*******************************
:
:  DISPLAY BOTH INPUT AND OUTPUT RINGS
:
:*******************************
	DS.CMD(DR,XDR)		        :WRAPPED DISP OUTPUT RING
:
XDR
        LIS     R0,0
        STH     R0,XDIIND,,
        STH     R0,XDOIND,,
        SVC     0B,XDCRLF,,
XDRLP
        JAL     R14,XDRKBD      :TEST KYBD INPUT
        J       DDTNOP          :DONE
        JAL     R14,XDRDOR      :OUTPUT RING FIRST
        JAL     R14,XDRDIR      :INPUT RING
        SVC     DISMISS,0
        J       XDRLP

:********************************
:
:       ENABLE THE COMPACT FORMAT
:
:********************************
	DS.CMD(DRSF,XDRSF)
:
XDRSF
	LIS	R0,1
	STH	R0,XDCOMP,,	:TURN ON FLAG
	J	DDTNOP		:DONE


:********************************
:
:       DIABLE THE COMPACT FORMAT
:
:********************************
	DS.CMD(DRRG,XDRRG)
:
XDRRG
	LIS	R0,0
	STH	R0,XDCOMP,,	:TURN OFF FLAG
	J	DDTNOP		:DONE



:
:	DUMP I/O RINGS
:
RR	EQ	8		:REGISTER ADDRESS OF RING
RS	EQ	9		:REGISTER RING SIZE

:	R0  - SCRATCH
:	R1  - INDEX INTO RING
:	R10 - LINK TO SUBROUTINES
:	R12 - FLAG FOR PRINTING/NOT PRINTING
:
XDRDIR
        LA	RR,IRING,,	:HANDLE IRING
	LHI	RS,IRSIZE	:RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDIIND,,
        CLR     R0,R1
        JER     R14
:
        LHI     R0,0049         : I
        STB     R0,XRNG+1,,
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDIW
        SR      R1,RS
XDRDIW
        SVC     0B,XDCRLF,,
        STH     R1,XDIIND,,       :UPDATE OUTPUT INDEX
        JR      R14

:*******************************
:
: OUTPUT RING
:
:*******************************
XDRDOR
        LA	RR,ORING,,	:HANDLE ORING
	LHI	RS,ORSIZE	:RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDOIND,,
        CLR     R0,R1
        JER     R14             :EXIT
:
        LHI     R0,4F           : O
        STB     R0,XRNG+1,,
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDOW
        SR      R1,RS
XDRDOW
        SVC     0B,XDCRLF,,       :OUTPUT CRLF
        STH     R1,XDOIND,,       :OUTPUT INDEX
        JR      R14

:*******************************
:
: KYBD CHECK
:
:*******************************
XDRKBD
	IF	DB.NTC		:IF NETWORK CONSOL
	JAL	R4,DS.CHK	:TEST KYBD INPUT
	ELSE
        SVC     K.IN,0          :TEST KYBD INPUT
	EI	(DB.NTC)
        J       XDRKBE          :NONE, SO NORMAL RETURN
:
        JR      R14
XDRKBE
        AIS     R14,4           :NORMAL "SKIP" RETURN
        JR      R14             :NORMAL EXIT

:*******************************
:
: GET PARAMETERS
:
:*******************************
XDRPRI
        LIS     R0,0            :START AT ZERO
	LHI	R1,008D		:GET A <CR>
	CLB	R1,DS.DLM,,	:DELIMETER CHAR = <CR> ?
	JE  	XDRPI0		:YES, START AT BEGINNING
:
	LHI	R4,10   	:SET RADIX TO HEX
	JAL	R5,DS.NUM	:GET A NUMBER (IN R0)
:
	LA	RR,IRING+4,,	:GET START ADDRESS
        CLR     R0,RR           :COMPARE
        JL      DS.ALOW
:
        AI      RR,IRSIZE       :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,IRING+4      :GENERATE START ADDRESS
        NHI     R0,0FFFC        :ALIGN TO WORD
XDRPI0
        STH     R0,XDIIND,,       :IRING INDEX
        JR      R14

:*******************************
:
: GET PARAMETERS
:
:*******************************
XDRPRO
        LIS     R0,0            :START AT ZERO
	LHI	R1,008D		:GET A <CR>
	CLB	R1,DS.DLM,,	:DELIMETER CHAR = <CR> ?
	JE  	XDRPO0		:YES, START AT BEGINNING
:
	LHI	R4,10   	:SET RADIX TO HEX
	JAL	R5,DS.NUM	:GET A NUMBER (IN R0)
:
        LA      RR,ORING+4,,    :GET START ADDRESS
        CLR     R0,RR           :COMPARE
        JL      DS.ALOW
:
        AI      RR,ORSIZE       :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,ORING+4      :GENERATE START ADDRESS
        NHI     R0,0FFFC        :ALIGN TO WORD
XDRPO0
        STH     R0,XDOIND,,       :ORING INDEX
        JR      R14

:
:  ERROR ROUTINE
:
DS.ALOW
        SVC     OUT,ADRLOW
        J       DS.ERR
:
DS.AHI
        SVC     OUT,ADRHI
        J       DS.ERR

ADRLOW  SC      /Address too low"8D"8A/
ADRHI   SC      /Address too high"8D"8A/

:********************************
:
:  PROCESS ISIS MESSAGE
:
:  R1           RING INDEX
:  R8 (RR)      RING START ADDRESS
:  R9 (RS)      RING SIZE
:  R13          LINK
:
:********************************
XDRISM	LB	R2,RING+2,R1,RR	:GET MESSAGE CODE
	LHL	R3,RING,R1,RR	:GET PORT #
	JE	XDR0C0		:IF INTRANODE MESSAGE
:	CHECK FOR A VALID PORT #, KEEP INCRIMENTING TIL FOUND
	CLH	R3,NPORTS,,	:TEST AGAINST MAX PORT #
	JLEFS	XDR0A5		:OK, CONTINUE
:
	AIS	R1,4		:MOVE TO NEXT POSSIBLE PORT
	JBS	XDRISM		:LOOP LOOKING FOR A VALID PORT #
:	PORT NUMBER IS VALID
XDR0A5	LIS	R12,1		:DEFAULT PRINTING ON <*>
	LR	R2,R2		:CHECK FOR NEEDLE
	JE	XDR0F0		:IF SO
:
	CLHI	R2,9E		:DATA MESSAGE ??
	JL	XDR0B0		:IF SO
:
	RBT	R3,XEBCDI,,	:TURN OFF XEBCDI,, BIT
	JAL	R10,XPRADD	:PRINT ADDRESS
	CLHI	R2,0BF		:IS IT 'SIIX'?
	JNFS	XDR0A6		:NO, SKIP
	SBT	R3,XEBCDI,,	:ELSE, TURN ON EBCDIC BIT
XDR0A6
	SHI	R2,9E		:BIAS TO 0
	LA	R4,,R2,R2	:FOR INDEXING
	SVC	0B,XDRICA,R4,R4	:ASCII MESSAGE LABEL
	LIS	R12,0		:DO NOT PRINT ISIS CONTROL MESSAGES IN ASCII <*>
	JAL	R10,XDRISB	:GO DUMP ISIS CONTROL MESSAGE
        JR      R13             :RETURN

:
:  DATA MESSAGE
:
XDR0B0
	JAL	R10,XPRADD	:PRINT ADDRESS
	SVC	0B,XDRMS3,,	:"DATA" MESSAGE HEADER
	JAL	R10,XDRISA	:GO DUMP ISIS DATA MSG
        JR      R13             :RETURN

:
: PORT 0 INTRANODE MESSAGE
:
XDR0C0
	CLHI	R2,10		:DOUBLE CHECK MSG. CODE WITHIN RANGE
	JLEFS	XDR0OK		:O.K.
	AIS	R1,4		:OUT OF RANGE, BUMP INDEX
	J	XDRISM		:PROCESS NEXT ISIS MSG.
XDR0OK
	RBT	R3,XEBCDI,,	:TURN OFF EBCDIC BIT
	JAL	R10,XPRADD	:PRINT ADDRESS
	LA	R4,,R2,R2	:FOR INDEXING
	SVC	0B,XDRICB,R4,R4	:ASCII MESSAGE LABEL
	TBT	R2,XDRVL,,	:VARIABLE LENGTH MESSAGE ??
	JNFS	XDR0D0		:IF SO BECAUSE CAN'T HANDLE YET
	LIS	R12,0		:DO NOT PRINT CONTROL MESSAGE <*>
	JAL	R10,XDRISC	:GO DUMP ISIS INTRANODE MESSAGE
        JR      R13             :RETURN
XDR0D0	LIS	R12,1		:<*> SET TO PRINT
	CLHI	R2,8		:AUX CIRCUIT REQUEST ??
	JN	XDR0E0		:MUST BE "1-DOWN"
	LA	R4,0A,R1	:STEP TO SIZE BYTE
	CR	R4,RS		:CHECK FOR WRAP AROUND
	JLFS	XDR0D4		:IF NOT
	SR	R4,RS		:IF SO
XDR0D4	LB	R6,RING,RR,R4	:GET VARIABLE STRING SIZE
	AIS	R6,0B		:ADD CONSTANT PORTION
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E
	LR	R15,R6
	JAL	R10,XDRISE,,	:TO PUT OUT MESSAGE
        JR      R13             :RETURN
XDR0E0	LA	R4,5,R1		:STEP TO 1-DOWN STRING SIZE
	CLHI	R4,RS		:CHECK FOR WRAP AROUND
	JLFS	XDR0E4		:IF NOT
	SHI	R4,RS		:IF SO
XDR0E4	LB	R6,RING,RR,R4	:GET VARIABLE MESSAGE SIZE
	AIS	R6,6		:ADD FIXED MESSAGE LENGTH
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E
	LR	R15,R6
	JAL	R10,XDRISE,,	:TO PUT OUT MESSAGE
        JR      R13             :RETURN

:
:  NEEDLE
:
XDR0F0
	JAL	R10,XPRADD	:PRINT ADDRESS
	SVC	0B,XDRMS4,,	:NEEDLE MESSAGE
	LB	R6,RING+3,R1,RR	:GET ADDITIONAL LENGTH
	AIS	R6,4		:ADD FIXED PORTION
	LHI	R0,20		:INSERT A BLANK
	SVC	KIO,0E		:PUT IT OUT
	LR	R15,R6
	JAL	R10,XDRISE,,	:TO PUT REST OF MESSAGE
        JR      R13             :RETURN

:
: TEST LOWER CASE, MAKE UPPER CASE IF TRUE
:
CAPIT	TBT	R0,CAPITT,,	:TEST FOR LOWER CASE CHARACTER
	JER	R1		:IF NOT
	SHI	R0,20		:ADJUST TO CAPITALIZE
	JR	R1		:RETURN


:	R1 - RING INDEX
:	R2 - MSG CODE TYPE
:	R3 - PORT #
:	R4 - SCRATCH
:	R5 - BYTE TO OUTPUT
:	R6 - SCRATCH
:	R7 - LINE LENGTH COUNTER
:	RS - RING SIZE  (R8)
:	RR - RING START (R9)
:	R10- LINK TO HERE
:	R11- LINK TO XDPUT

:	DATA MESSAGE
XDRISA	LA	R15,3,R2	:MESSAGE LENGTH=MESSAGE TYPE+3
	LR	R6,R15		:ASSUME REGULAR FORMAT
	LHL	R0,XDCOMP,,	:REGULAR FORMAT?
	JEFS	.+4		:YES, SKIP
	LIS	R6,3		:ELSE, DISPLAY PORT AND LEGNTH BYTE
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E		:LETS BE TIDY
	J	XDRISE,,,
:	CONTROL MESSAGE
XDRISB	LB	R6,LENGTH+9E,R2,:MESSAGE LENGTH FROM TABLE (IN SEG F)
	AIS	R6,2
	LR	R15,R6
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E
	J	XDRISE,,,
:	INTRANODE MESSAGE TYPE
XDRISC	LHL	R6,LP0LST,,	:SEG F HAS THIS TOO
	LB	R6,NRATE,R6,R2,	:MESSAGE LENGTH FROM TABLE
	AIS	R6,2
	LR	R15,R6
	LHI	R0,20		:INSERT A SPACE
	SVC	KIO,0E
	J       XDRISE
XDRISD	HS	0
	SVC	0B,XDRASC,,	:ASCII EQUIVALENT OF LINE
	SVC	0B,XDCRLF,,	:NEW LINE
	ST	R10,SAVR10,,
	JAL	R10,XPRADD	:PRINT ADDRESS :*:
	L	R10,SAVR10,,
	SVC	0B,XDRMS5,,	:4 BLANKS FOR ALIGNMENT
XDRISE	LIS	R7,0		:LINE LENGTH COUNTER
XDRISF	LB	R0,RING,R1,RR	:NEXT BYTE FROM RING
	LR	R5,R0		:SAVE A GOOD COPY OF IT
	TBT	R3,XEBCDI,,	:ASC OR EBCDIC?
	JE	XDRIS0		:ASC, SKIP
	LB	R0,BCDASC,R5,	:GET CONVERTED ASCII
	TBT	R0,XDRECH,,	:PRINTABLE ??
	JN	XDRIS1		:YES, SKIP
	LHI	R0,2E		:ESLE, PRINT AS '.'
	J	XDRIS1		:SKIP
XDRIS0
	NHI	R0,7F		:IGNORE MSB
	TBT	R0,XDRECH,,	:PRINTABLE ??
	JNFS	XDRISH		:YES, GET ORIG. BYTE BACK
	LHI	R0,2E		:DEFAULT "." CHARACTER
	JFS	XDRISH+2	:SET CHAR TO "."
XDRISH	LR	R0,R5		:ELSE IF OK TO PRINT IT
:XDRISH+2
XDRIS1
	LR	R4,R7		:COMPUTE WHERE TO PLUG INTO LINE
	NHI	R4,0F		:16 BYTES PER LINE
	STB	R0,XDRASC+4,R4,,:PUT 'ER THERE
	JAL	R11,XDPUT,,	:PUT IT OUT
	AIS	R1,1		:BUMP RING INDEX
	CR	R1,RS		:END OF RING ??
	JLFS	XDRISG		:IF NOT
	SR	R1,RS		:FOLD TO RING START
XDRISG	AIS	R7,1		:LINE LENGTH
	SIS	R15,1
	SIS	R6,1		:CHECK FOR END OF MSG
	JLE	XDRISI		:FINISH BLANKING AND PRINT	
	THI	R7,0F		:END OF LINE
	JE	XDRISD		:IF SO
	THI	R7,1		:END OF HALFWORD
	JN	XDRISF		:IF NOT TO CONTINUE
	LHI	R0,20		:ADD A SPACE
	SVC	KIO,0E		:TO FORMAT WORDS
	J	XDRISF
XDRISI
	CR	R15,R6		:..
	JN	XDRISQ
:XDRISI	LHI	R0,20		:BLANK
	LR	R12,R12		:PRINT DATA ? (1=YES)
	JER	R10		:NO, RETURN
XDRISJ	NHI	R7,0F		:LINE LENGTH OF 16
	JEFS	XDRISK		:IF TO END OF LINE
	STB	R0,XDRASC+4,R7,,:PUT IN A BLANK
	SVC	0B,XD2BLK,,	:PRINT 2 BLANKS TO ALLIGN DATA
	THI	R7,1		:ODD ?
	JNFS	XDRISL		:YES, DO NOT PRINT BLANK
	SVC	KIO,0E		:PRINT A BLANK (REG 0)
XDRISL	HS	0
	AIS	R7,1		:COUNT ON UP
	JBS	XDRISJ		:AND SEE IF DONE
XDRISK	SVC	0B,XDRASC,,	:YES, PUT IT OUT
	JR	R10		:DONE


XDRISQ
	AIS	R1,1
	CR	R1,RS
	JLFS	XDRISR
	SR	R1,RS
XDRISR
	SIS	R15,1
	JGBS	XDRISQ
	JR	R10

:	R0 USED BY SVC FOR OUTPUT CHARACTER
:	R1-R3 SAVED
:	R4 DESTROYED
:	R5 BYTE TO BE OUTPUT
:	R11 LINK
XDPUT	LBR	4,5		:COPY IT
	SRHLS	4,4		:LEFT NIBBLE
	LB	0,SIAASC,4,	:CONVERT TO ASCII ("0" TO "F")
	SVC	KIO,0E		:PUT IT OUT TO TTY
	NHI	5,0F		:RIGHT NIBBLE
	LB	0,SIAASC,5,	:CONVERT TO ASCII ("0" TO "F")
	SVC	KIO,0E		:PUT IT OUT TO TTY
	JR	R11		:RETURN
:
:	WRITE ADDRESS AT START OF DATA/MESSAGE/NEEDLE LINE
:
:	R10 - LINK TO THIS ROUTING
:	ALL OTHERS PRESERVED!
:
XPRADD
	STM	R0,XDSAV,,
	SVC	0B,XRNG,,
	LA	R0,RING,R1,RR	:GET ADDR OF THIS MESSAGE
	LHI	R1,HEXB.5
	SVC	KIO,$A10
	LHI	R0,0020		:PRINT BLANK
	SVC	KIO,$A14
	LM	R0,XDSAV,,
	JR	R10

	SUBTTL	ISIS RING INTERPRETER (DATA AREAS) - RNGI02.Z00
	SEG	A.DATA
XDRSS0	HS	0
XDRPLU	SC	/"8D"8A"2B/	:<CR>, <LF>, "+"
SIAASC	AC	/0123456789ABCDEF/
CAPITT	HC	0,0,0,0,0,0,7FFF,0FFE0
XDRECH	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDCRLF	SC	/"8D"8A/	:<CR>, <LF>
XD2BLK	SC	/  /		:TWO BLANKS
XDRVL	HC	0082,0000	:VARIABLE LENGTH MESSAGE FLAGS
XDRMS5	SC	/    /
XDRMS4	SC	/NDL/		:NEEDLE
XDRMS3	SC	/DAT/		:DATA
XDRASC	SC	/  |                |/
XDRCEI	HS	1		:OUR CEI
XRNG	SC	/  /
XDSAV	HS	2*10		:REG SAVE AREA
SAVR10	HS	2		:REG 10 SAVE AREA

:	ISIS CONTROL MESSAGES
XDRICA	HS	0
	SC	/DET/		:DETACH MESSAGE TYPE
	SC	/ZAP/		:DISCONNECT MESSAGE
	SC	/NOS/		:APPLY BACK-PRESSURE (NO SEND)
	SC	/SND/		:RELEASE BACK-PRESSURE (SEND)
	SC	/ICM/		:FLUSH OUTPUT (GOBBLER)
	SC	/BKG/		:FLUSH INPUT (BACK GOBBLER)
	SC	/BLK/		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	SC	/GRY/		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	SC	/EDE/		:ENTER DEFERED ECHO MESSAGE
	SC	/LDE/		:LEAVE DEFERED ECHO MESSAGE
	SC	/ETM/		:ENTER TRANSPARENCY MODE
	SC	/LTM/		:LEAVE TRANSPARENCY MODE
	SC	/GB /		:GREEN BALL
	SC	/RB /		:RED BALL
	SC	/YB /		:YELLOW BALL
	SC	/OB /		:ORANGE BALL
	SC	/BRK/		:BREAK DETECTED
	SC	/HNG/		:HANG UP
	SC	/QTP/		:QUERY TERMINAL PARAMETER
	SC	/STP/		:SET TERMINAL PARAMETER
	SC	/PSN/		:PSEUDO NEEDLE
	SC	/NLC/		:NORMAL LOGON CHAR
	SC	/NLS/		:NORMAL LOGON STATUS
	SC	/LOF/		:LOG ON FAILURE
	SC	/NCC/		:NORMAL CIRCUIT COMPLETE
	SC	/ADA/		:ADDENDUM TO ACCOUNTING
	SC	/SHG/		:SUPER-HANG UP
	SC	/TLM/		:SET TRANSMIT LIMIT
	SC	/EBK/		:END OF BREAK
	SC	/ZAK/		:ZAP ACK
	SC	/EAD/		:ENTER ALTERNATE OUTPUT DEVICE MODE
	SC	/LAD/		:LEAVE ALTERNATE OUTPUT DEVICE MODE
	SC	/ZAR/		:ZAP WITH REASON
	SC	/SIX/		:START INTERFACE INFORMATION EXCHANGE
	SC	/TIX/		:TERMINATE INTERFACE INFORMATION EXCHANGE

:	INTRA NODE MESSAGES
:	-------------------

XDRICB	HS	0
	SC	/RQR/		:RESTART REQUEST
	SC	/RST/		:RESTART INTERFACE
	SC	/NTO/		:NODE HAS BEEN TAKEN OVER
	SC	/REP/		:REPORT TO SUPERVISOR'S LOG
	SC	/RHS/		:REPORT HOST STATUS (OBSOLETE)
	SC	/RAC/		:REPORT ACCOUNTING
	SC	/TIM/		:GMT TIME
	SC	/RNP/		:REQUEST FOR NORMAL PSEUDO NEEDLE
	SC	/RAP/		:REQUEST AUX PSEUDO-NEEDLE
	SC	/PSR/		:PSEUDO-NEEDLE REJECTED
	SC	/HPA/		:HOST PORT AVAILABILITY
	SC	/HNA/		:HOST NOT ACCEPTABLE
	SC	/RHC/		:REPORT HOST COST
	SC	/NSU/		:NO SUPERVISOR
	SC	/ODN/		:1-DOWN TEXT
	SC	/RAH/		:REPORT ALL HOSTS
	SC	/HSR/		:HOST STATUS REPORT
:
	EM
	SUBTTL	(SNA) XDDT - "DATA SCOPE & LINK TRACE" - STATUS
:SCOP00.F00


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	SDLC LINK PROTOCOL DATA SCOPE				::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


        MO      .,STATUS
	LO	CBKDEF			:(12/03/86 YLH)
        LO      FGGBDF
        LO      GBLDEF
        LO      MAIN


:	DEFINE LOCAL SYMBOLS
:	--------------------
HEXB.1	EQ	0130			:WIDTH=1, BLANK FILL, BASE=16
HEXB.2	EQ	0230			:WIDTH=2, BLANK FILL, BASE=16
HEXB.3	EQ	0330			:WIDTH=3, BLANK FILL, BASE=16
HEXB.8	EQ	0830			:WIDTH=8, BLANK FILL, BASE=16


:	DEFINE LOCAL STORAGE
:	-----------------------
        SEG     A.DATA
	WS	0
CDSIND  HS      1               :CURRENT ENTRY PTR FOR FG TRACE
CDXIND  HS      1               :CURRENT ENTRY PTR FOR BG TRACE
SCLINE  HC      0               :CURENT LINK # FOR LINK TRACE CMDS


	SEG	A.CODE

:
:	DEFINE CANNED MESSAGES
:	----------------------

:BIGNUM	SC	/*** Line Number too big ***/		(10/17/85/TTW)
BIGNUM	SC	/*** Line or PU Number too big ***/	(10/17/85/TTW)
XDCRLF	SC	/"8D"8A/
BLANK1	SC	/ /
BLANK2	SC	/  /
BLANK3	SC	/   /
BLANK4	SC	/    /

:	HEADER FOR SCOPE AND DTRACE COMMANDS
SCPHDR	SC	/Line# Mnemonic CC Addr CTL N(r) P"2FF N(s) Count  TIME"8D"8A/

:	HEADER FOR RECORD (COMPACT SCOPE) COMMAND
SCPHD1  SC      /LN MNEMONIC CC AD CT LNG TIME"8D"8A/

:	'X' OR 'R' FOR MNEUMONIC
SCPXMT	SC	/X/			:XMT INDICATOR
SCPRCV	SC	/R/			:RCV INDICATOR

:	PRIMARY XMT OP CODE
:	SYMBOLIC NAME TABLE
SCPDXT
	SC	/RXMT/			:0 - RE-XMT DATA
	SC	/INF /			:1 - XMT INF
	SC	/SNRM/			:2 - XMT SNRM
	SC	/UA? /			:3 - UNDEF (XMT UA)
	SC	/DISC/			:4 - XMT DISC
	SC	/DM? /			:5 - UNDEF (XMT DM)
	SC	/SIM /			:6 - XMT SIM
	SC	/XID /			:7 - XMT XID
	SC	/TEST/			:8 - XMT TEST
	SC	/FRMR/			:9 - XMT FRMR
	SC	/RR  /			:0A - XMT RR
	SC	/RNR /			:0B - XMT RNR
	SC	/REJ /			:0C - XMT REJ
	SC	/????/			:0D - XMT UNKNOW

:	SECONDARY XMT OP CODE SYMBOLIC NAME TABLE
SCSDXT
	SC	/RXMT/			:0 - RE-XMT DATA
	SC	/INF /			:1 - XMT INF
	SC	/NRM?/			:2 - UNDEF (XMT SNRM)
	SC	/UA  /			:3 - XMT UA
	SC	/RD  /			:4 - XMT RD
	SC	/DM  /			:5 - XMT DM
	SC	/RIM /			:6 - XMT RIM
	SC	/XID /			:7 - XMT XID
	SC	/TEST/			:8 - XMT TEST
	SC	/FRMR/			:9 - XMT FRMR
	SC	/RR  /			:0A - XMT RR
	SC	/RNR /			:0B - XMT RNR
	SC	/REJ /			:0C - XMT REJ
	SC	/????/			:0D - XMT UNKNOW

:	PRIMARY RCV RETURN CODE SYMBOLIC NAME TABLE
SCPDRV
	SC	/ERR /			:0 - ERROR (SHOULD NOT OCCUR)
	SC	/INF /			:1 - RCV INF
	SC	/NRM?/			:2 - RCV SNRM (ILLEGAL)
	SC	/UA  /			:3 - RCV UA
	SC	/RD  /			:4 - RCV RD
	SC	/DM  /			:5 - RCV DM
	SC	/RIM /			:6 - RCV RIM
	SC	/XID /			:7 - RCV XID
	SC	/TEST/			:8 - RCV TEST
	SC	/FRMR/			:9 - RCV FRMR
	SC	/RR  /			:0A - RCV RR
	SC	/RNR /			:0B - RCV RNR
	SC	/REJ /			:0C - RCV REJ
	SC	/C ER/			:0D - RCV 'C' FIELD UN-RECOGNIZABLE
	SC	/IPHB/			:0E - RCV 'I' FIELD PROHIBITED
	SC	/OVRN/			:0F - RCV FRAME TOO LONG (OVER RUN)
	SC	/LENG/			:10 - RCV FRAME TOO SHORT
	SC	/ADER/			:11 - RCV 'A' ERROR
	SC	/APER/			:12 - RCV 'A' NOT POLLED
	SC	/LOST/			:13 - RCV DATA LOST
	SC	/TMOT/			:14 - RCV TIMEOUT
	SC	/????/			:15 - RCV UNKNOW


:	SECONDARY RCV RETURN CODE SYMBOLIC NAME TABLE
SCSDRV
	SC	/ERR /			:0 - ERROR (SHOULD NOT OCCUR)
	SC	/INF /			:1 - RCV INF
	SC	/SNRM/			:2 - RCV SNRM
	SC	/UA? /			:3 - RCV UA (ILLEGAL)
	SC	/DISC/			:4 - RCV DISC
	SC	/DM? /			:5 - RCV DM (ILLEGAL)
	SC	/SIM /			:6 - RCV SIM
	SC	/XID /			:7 - RCV XID
	SC	/TEST/			:8 - RCV TEST
	SC	/FRMR/			:9 - RCV FRMR
	SC	/RR  /			:0A - RCV RR
	SC	/RNR /			:0B - RCV RNR
	SC	/REJ /			:0C - RCV REJ
	SC	/C ER/			:0D - RCV 'C' FIELD UN-RECOGNIZABLE
	SC	/IPHB/			:0E - RCV 'I' FIELD PROHIBITED
	SC	/OVRN/			:0F - RCV FRAME TOO LONG (OVER RUN)
	SC	/LENG/			:10 - RCV FRAME TOO SHORT
	SC	/ADER/			:11 - RCV 'A' ERROR
	SC	/APER/			:12 - RCV 'A' NOT POLLED
	SC	/LOST/			:13 - RCV DATA LOST
	SC	/TMOT/			:14 - RCV TIMEOUT
	SC	/????/			:15 - RCV UNKNOW


	BND	2
SCPTBL
	HC	SCSDRV-SCPTBL		:00 - SEC.RCV
	HC	SCPDRV-SCPTBL		:01 - PRI.RCV
	HC	SCSDXT-SCPTBL		:10 - SEC.XMT
	HC	SCPDXT-SCPTBL		:11 - PRI.XMT



SCPPFT
	SC	/P/			:00 - SEC.RCV, P BIT
	SC	/F/			:01 - PRI.RCV, F BIT
	SC	/F/			:10 - SEC.XMT, F BIT
	SC	/P/			:11 - PRI.XMT, P BIT



SCPLEN
	LO	SFGXMT
	LO	SFGRCV
	BC	RCMAXI+1		:00 - SEC.RCV
	BC	RCMAXI+1		:01 - PRI.RCV
	BC	XCMAXI+1		:10 - SEC.XMT
	BC	XCMAXI+1		:11 - PRI.XMT
	FO	SFGRCV
	FO	SFGXMT

:	HEADER FOR BACKGROUND TRACE COMMANDS
SCPHD2	SC	/Port# Mnemonic     LU #                  Count  TIME"8D"8A/
SCPHD3  SC      /PT MNEMONIC    AD    LNG TIME"8D"8A/

:	'I' OR 'O' FOR MNEMONIC
SCPINP	SC	/I/			:ISIS/INPUT INDICATOR
SCPOUT	SC	/O/			:ISIS/OUTPUT INDICATOR

:	'BEG' OR 'END' FOR MNEMONIC
SCPBEG	SC	/BEG/			:ISIS DATA TRACE BEG POINT
SCPEND	SC	/END/			:ISIS DATA TRACE END POINT


:***************************************************************:
:								:
:	DATA SCOPE AND LINK TRACE COMMAND			:
:								:
:								:
:***************************************************************:


:	LINK - TO SPECIFY THE LINK #
	DS.CMD(LINK,SLINK)

:	DLK - REAL TIME LINK TRACE DISPLAY COMMAND
	DS.CMD(DLK,DSCOPE)

:	LINK TRACE ENABLED FOR BOTH RCV/XMT
	DS.CMD(XRON,TRSON)

:	LINK TRACE DISABLED FOR BOTH RCV /XMT
	DS.CMD(XROF,TRSOFF)

:	LINK TRACE ENABLED ONLY FOR XMT
	DS.CMD(XTON,XTSON)

:	LINK TRACE DISABLED FOR XMT ONLY
	DS.CMD(XTOF,XTSOFF)

:	LINK TRACE ENABLED FOR RCV ONLY
	DS.CMD(RVON,RVSON)

:	LINK TRACE DISABLED FOR RCV ONLY
	DS.CMD(RVOF,RVSOFF)

:	RECORD LINK TRACE DATA, (DISPLAY DATA IN COMPACT FORMAT)
	DS.CMD(DLKS,CSCOPE)

:	DISPLAY TRACE DATA  OFFLINE
	DS.CMD(DLKO,DSPTRA)

:	SELCT GMT AS THE CLOCK SOURCE
	DS.CMD(GMT,GMTCLK)

:	SELECT FASTC AS THE CLOCK SOURCE
	DS.CMD(FASTC,FASTCL)

:	LINK TRACE WITH TIME STAMP ENABLED
	DS.CMD(TMON,TMSON)

:	LINK TRACE WITH TIME STAMP DISABLED
	DS.CMD(TMOF,TMSOFF)

:	LINK TRACE WITH INFORMATION FRAMES ONLY
	DS.CMD(IFON,IFTRON)

:	LINK TRACE NOT LIMITED TO INFORMATION FRAMES
	DS.CMD(IFOF,IFTROF)

:	BACKGROUND INPUT TRACE ON
	DS.CMD(INON,BGIPON)

:	BACKGROUND INPUT TRACE OFF
	DS.CMD(INOF,BGIPOF)

:	BACKGROUND OUTPUT TRACE ON
	DS.CMD(OTON,BGOPON)

:	BACKGROUND OUTPUT TRACE OFF
	DS.CMD(OTOF,BGOPOF)

:	BACKGROUND REAL-TIME TRACE
	DS.CMD(DNT,BGTRAC)

:	BACKGROUND OFFLINE TRACE DISPLAY
	DS.CMD(DNTO,BGOTRA)

:	BCAKGROUND REAL TIME TRACE - SHORT FORMAT
	DS.CMD(DNTS,BGSTRA)

:	FOREGROUND AND BACKGROUND TRACE - ALL
	DS.CMD(ALL,ALLTRA)

:	FOREGROUND AND BACKGROUND TRACE - ALL IN COMPACT FORMAT
	DS.CMD(ALLSF,ALLTSF)

:	ENABLE INFORMATION TRACE FOR A LINE(10/9/85/TTW)
	DS.CMD(ETLN,ENIFTR)

:	DISABLE INFORMATION TRACE FOR A LINE(10/9/85/TTW)
	DS.CMD(DTLN,DAIFTR)

:	ENABLE INFORMATION TRACE FOR A CU(10/9/85/TTW)
	DS.CMD(ETCU,ENIFCU)

:	DISABLE INFORMATION TRACE FOR A CU(10/9/85/TTW)
	DS.CMD(DTCU,DAIFCU)



:	DSCOPE:	DISPLAY REAL TIME TRACE DATA IN NICE FORMAT
:	----------------------------------------------------
DSCOPE
	SVC	K.OUT,SCPHDR		:PRINT DATA SCOPE HEADER
	LHL	R2,FTRSIX,,		:GET LATEST TRACE INDEX
	STH	R2,CDSIND,,		:SET CDSIND TO LATEST
DSCOP1
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	DSCOP2			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ESLE, EXIT
DSCOP2
	SVC	DISMISS,0		:DISMISS
	LHL	R2,CDSIND,,		:CHECK FOR POINTER MOVEMENT
	CLH	R2,FTRSIX,,		:...
	JEBS	DSCOP1			:NO, LOOP
	JAL	R14,DSPDTA		:DISPLAY TRACE DATA
	J	DSCOP1			:AND LOOP


:	TRSON:	ENABLE LINK TRACE FOR BOTH XMT & RCV
:	--------------------------------------------
TRSON
	LHL	R0,SCLINE,,		:GET LINK #
	SBT	R0,FTRXLN,,		:ENABLE XMT LINK TRACE
	SBT	R0,FTRRLN,,		:ENABLE RCV LINK TRACE
	J	DDTNOP			:EXIT



:	TRSOFF:	DISABLE LINK TRACE FOR BOTH XMT/RCV
TRSOFF
	LHL	R0,SCLINE,,		:GET LINK #
	RBT	R0,FTRXLN,,		:DISABLE XMT LINK TRACE
	RBT	R0,FTRRLN,,		:DISABLE RCV LINK TRACE
	J	DDTNOP			:EXIT


:	XTSON	:ENABLE XMT LINK TRACE
:	------------------------------
XTSON
	LHL	R0,SCLINE,,		:GET LINK#
	SBT	R0,FTRXLN,,		:ENABLE XMT LINK TRACE
	J	DDTNOP			:EXIT


:	XTSOFF:	DISABLE XMT LINK TRACE
:	-------------------------------
XTSOFF
	LHL	R0,SCLINE,,		:GET LINK #
	RBT	R0,FTRXLN,,		:DISABLE XMT LINK TRACE
	J	DDTNOP			:EXIT


:	RVSON:	ENABLE RCV LINK TRACE
:	-----------------------------
RVSON
	LHL	R0,SCLINE,,		:GET LINK #
	SBT	R0,FTRRLN,,		:ENABLE RCV LINK TRACE
	J	DDTNOP			:EXIT


:	RVSOFF:	DISABLE RCV LINK TRACE
:	-------------------------------
RVSOFF
	LHL	R0,SCLINE,,		:GET LINK #
	RBT	R0,FTRRLN,,		:DISABLE RCV LINK TRACE
	J	DDTNOP			:EXIT


:	CSCOPE:	COMPACT DIAPLAY FORMAT OF SCOPE
:	----------------------------------------
CSCOPE
	SVC	K.OUT,SCPHD1		:PRINT DATA RECORD HEADER
	LHL	R2,FTRSIX,,		:GET LATEST TRACE INDEX
	STH	R2,CDSIND,,		:SET CDSIND TO LATEST
CSCOP1
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	CSCOP2			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ESLE, EXIT
CSCOP2
	SVC	DISMISS,0		:DISMISS
	LHL	R2,CDSIND,,		:CHECK FOR POINTER MOVEMENT
	CLH	R2,FTRSIX,,		:...
	JEBS	CSCOP1			:NO, LOOP
	JAL	R14,DSPSDA		:DISPLAY TRACE DATA(COMPACT FORMAT)
	J	CSCOP1			:AND LOOP


:	DSPTRA:	DISPLAY TRACE DATA
:	--------------------------------------
:	COMMAND FORMAT -	DTRACE <CR>
:				DTRACE,<START ADDR>
DSPTRA
	LIS	R0,0			:ASSUME START AT ZERO
	LB	R1,DS.DLM,,		:GET THE DELIMETER CHAR
	CLHI	R1,8D			:IS IT A <CR>?
	JE	DSPTR1			:YES, START AT BEGINNING
	LHI	R4,10			:SET RADIX TO HEX
	JAL	R5,DS.NUM		:AND GET AN INPUT NUMBER IN R0
	CLHI	R0,FTRACE*FTRBFL	:VALUE OUT OF RANGE?
	JGE	DS.AHI			:OFFSET TOO HIGH, GO TO RINGINT
	NHI	R0,0FFFE		:ALIGN TO HW
DSPTR1
	STH	R0,CDSIND,,		:DISPLAY START ADDR
:	CHECK CURRENT ENTRY IS ALIGNED PROPERLY
	SVC	K.OUT,SCPHDR		:PRINT HEADER
DSPTR2
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	DSPTR3			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ELSE, EXIT
DSPTR3
	LHL	R2,CDSIND,,		:ALL DISPLAYED?
	CLH	R2,FTRSIX,,		:...
	JE	DDTNOP			:YES, EXIT
	JAL	R14,DSPDTA		:DISPLAY TRACE DATA IN NORMAL FORMAT
	J	DSPTR2			:AND CONTINUE


:	GTMCLK	:SELCT GMT AS THE CLOCK SOURCE
:	-------------------------------------
GMTCLK
	LIS	R0,1
	STH	R0,FTGMTL,,		:SELCT GMT CLOCK
	J	DDTNOP			:EXIT


:	FASTCL	:SELCT FASTC AS THE CLOCK SOURCE
:	-------------------------------------
FASTCL
	LIS	R0,0
	STH	R0,FTGMTL,,		:SELCT GMT CLOCK
	J	DDTNOP			:EXIT


:	TMSON:	ENABLE TRACE WITH TIME STAMP
:	-------------------------------------
TMSON
	LHL	R0,SCLINE,,		:GET LINK #
	SBT	R0,FTRTLN,,		:ENABLE TRACE WITH TIME STAMP
	J	DDTNOP			:EXIT


:	TMSOFF:	DISABLE TRACE WITH TIME STAMP
:	-------------------------------------
TMSOFF
	LHL	R0,SCLINE,,		:GET LINK #
	RBT	R0,FTRTLN,,		:DISABLE TRACE WITH TIME STAMP
	J	DDTNOP			:EXIT


:	IFTRON:	ENABLE TRACE WITH INFOR FRAMES ONLY
:	-------------------------------------------
IFTRON
	LHL	R0,SCLINE,,		:GET LINK #
	SBT	R0,FTRINF,,		:ENABLE TRACE WITH INF ONLY
	J	DDTNOP			:EXIT


:	IFTROF:	DISABLE TRACE WITH INFOR FRAMES ONLY
:	-------------------------------------------
IFTROF
	LHL	R0,SCLINE,,		:GET LINK #
	RBT	R0,FTRINF,,		:DISABLE TRACE WITH INF ONLY
	J	DDTNOP			:EXIT

:	BGIPON:	ENABLE BACKGROUND ISIS/INPUT TRACE
:	-------------------------------------------
BGIPON
	LIS	R0,BTRIBT		:INDICATE ISIS/INPUT TRACE
	SBT	R0,BTRIOF,,		:ENABLE TRACE WITH ISIS/INPUT
	J	DDTNOP			:EXIT

:	BGIPOF:	DISABLE BACKGROUND ISIS/INPUT TRACE
:	-------------------------------------------
BGIPOF
	LIS	R0,BTRIBT		:INDICATE ISIS/INPUT TRACE
	RBT	R0,BTRIOF,,		:DISABLE TRACE WITH ISIS/INPUT
	J	DDTNOP			:EXIT

:	BGOPON:	ENABLE BACKGROUND ISIS/OUTPUT TRACE
:	-------------------------------------------
BGOPON
	LIS	R0,BTROBT		:INDICATE ISIS/OUTPUT TRACE
	SBT	R0,BTRIOF,,		:ENABLE TRACE WITH ISIS/OUTPUT
	J	DDTNOP			:EXIT

:	BGOPOF:	DISABLE BACKGROUND ISIS/OUTPUT TRACE
:	-------------------------------------------
BGOPOF
	LIS	R0,BTROBT		:INDICATE ISIS/OUTPUT TRACE
	RBT	R0,BTRIOF,,		:DISABLE TRACE WITH ISIS/OUTPUT
	J	DDTNOP			:EXIT

:	BGTRAC:	BACKGROUND REAL-TIME TRACE
:	-----------------------------------
BGTRAC
	SVC	K.OUT,SCPHD2		:PRINT HEADER
	LHL	R2,BTRSIX,,		:GET LATEST TRACE INDEX
	STH	R2,CDXIND,,		:SET CDXIND TO LATEST
BGTRA1
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	BGTRA2			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ELSE, EXIT
BGTRA2
	SVC	DISMISS,0		:DISMISS
	LHL	R2,CDXIND,,		:CHECK FOR POINTER MOVEMENT
	CLH	R2,BTRSIX,,		:..
	JEBS	BGTRA1			:NO, LOOP
	JAL	R14,DSPBDA		:DISAPLY BG TRACE DATA
	J	BGTRA1			:AND LOOP

:	BGSTRA:	BACKGROUND REAL-TIME TRACE - SHORT  FORMAT
:	--------------------------------------------------
BGSTRA
	SVC	K.OUT,SCPHD3		:PRINT HEADER
	LHL	R2,BTRSIX,,		:GET LATEST TRACE INDEX
	STH	R2,CDXIND,,		:SET CDXIND TO LATEST
BGSTR1
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	BGSTR2			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ELSE, EXIT
BGSTR2
	SVC	DISMISS,0		:DISMISS
	LHL	R2,CDXIND,,		:CHECK FOR POINTER MOVEMENT
	CLH	R2,BTRSIX,,		:..
	JEBS	BGSTR1			:NO, LOOP
	JAL	R14,DSPBSD		:DISAPLY BG TRACE DATA - SHORT
	J	BGSTR1			:AND LOOP

:	BGOTRA:	DISPLAY BG TRACE DATA - OFFLINE
:	---------------------------------------
:	COMMAND FORMAT -	OTRACE <CR>
:				OTRACE,<START ADDR>
BGOTRA
	LIS	R0,0			:ASSUME START AT ZERO
	LB	R1,DS.DLM,,		:GET THE DELIMETER CHAR
	CLHI	R1,8D			:IS IT A <CR>?
	JE	BGOTR1			:YES, START AT BEGINING
	LHI	R4,10			:SET RADIX TO HEX
	JAL	R5,DS.NUM		:AND GET AN INPUT NUMBER IN R0
	CLHI	R0,BTRACE*BTRBFL	:VALUE OUT OF RANGE?
	JGE	DS.AHI			:OFFSET TOO HIGH, GO TO HANDLE
	NHI	R0,0FFFE		:ALIGN TO HW
BGOTR1
	STH	R0,CDXIND,,		:DISPLAY START ADDRESS
:	CHECK CURRENT ENTRY IS ALIGNE PROPERLY
	SVC	K.OUT,SCPHD2		:PRINT HEADER
BGOTR2
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	BGOTR3			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ELSE, EXIT
BGOTR3
	LHL	R2,CDXIND,,		:ALL DISPLAYED?
	CLH	R2,BTRSIX,,		:...
	JE	DDTNOP			:YES, EXIT
	JAL	R14,DSPBDA		:DISPLAY BG TRACE DATA
	J	BGOTR2			:AND LOOP

:	ALLTRA:	TRACE BACKGROUND AND FOREGROUND
:	---------------------------------------
ALLTRA
	SVC	K.OUT,SCPHDR		:PRINT HEADER
	SVC	K.OUT,SCPHD2		:PRINT HEADER
	LHL	R2,FTRSIX,,		:GET LATEST FG TRACE INDEX
	STH	R2,CDSIND,,		:SET CDSIND TO LATEST
	LHL	R2,BTRSIX,,		:GET LATEST BG TRACE INDEX
	STH	R2,CDXIND,,		:SET CDXIND TO LATEST
ALLTR1
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	ALLTR2			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ELSE, EXIT
ALLTR2
	SVC	DISMISS,0		:DISMISS
	LHL	R2,CDSIND,,		:CHECK FOR POINTER MOVEMENT
	CLH	R2,FTRSIX,,		:...
	JE	ALLTR3			:NO, CHECK BG
	JAL	R14,DSPDTA		:DISPLAY FG TRACE DATA
ALLTR3
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	ALLTR4			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ELSE, EXIT
ALLTR4
	SVC	DISMISS,0		:DISMISS
	LHL	R2,CDXIND,,		:CHECK FOR POINTER MOVEMENT
	CLH	R2,BTRSIX,,		:...
	JE	ALLTR1			:NO, CHECK FG
	JAL	R14,DSPBDA		:DISPLAY BG TRACE DATA
	J	ALLTR1			:AND LOOP TO FG 

:	ALLTSF:	TRACE BACKGROUND AND FOREGROUND IN COMPACT FORMAT
:	-----------------------------------------------------------
ALLTSF
	SVC	K.OUT,SCPHD1		:PRINT HEADER
	SVC	K.OUT,SCPHD3		:PRINT HEADER
	LHL	R2,FTRSIX,,		:GET LATEST FG TRACE INDEX
	STH	R2,CDSIND,,		:SET CDSIND TO LATEST
	LHL	R2,BTRSIX,,		:GET LATEST BG TRACE INDEX
	STH	R2,CDXIND,,		:SET CDXIND TO LATEST
ALLTS1
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	ALLTS2			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ELSE, EXIT
ALLTS2
	SVC	DISMISS,0		:DISMISS
	LHL	R2,CDSIND,,		:CHECK FOR POINTER MOVEMENT
	CLH	R2,FTRSIX,,		:...
	JE	ALLTS3			:NO, CHECK BG
	JAL	R14,DSPSDA		:DISPLAY FG TRACE DATA (SF)
ALLTS3
	IF	DB.NTC			:IF NETWORK CONSOLE SWITCH
	JAL	R4,DS.CHK		:TEST KYBD INPUT
	ELSE
	SVC	K.IN,0			:TEST KEY BOARD INPUT
	EI	(DB.NTC)
	J	ALLTS4			:NO KEY INPUT, TO CONTINUE
	J	DDTNOP			:ELSE, EXIT
ALLTS4
	SVC	DISMISS,0		:DISMISS
	LHL	R2,CDXIND,,		:CHECK FOR POINTER MOVEMENT
	CLH	R2,BTRSIX,,		:...
	JE	ALLTS1			:NO, CHECK FG
	JAL	R14,DSPBSD		:DISPLAY BG TRACE DATA (SF)
	J	ALLTS1			:AND LOOP TO FG 


:
:	SUBROUTINES
:


:	SLINK:	GET LINE NUMBER WITH RADIX DECIMAL
:	-------------------------------------------
SLINK
	LHI	R4,$A10			:GET LINE NUMBER IN DECIMAL
	JAL	R5,DS.NUM		:INTO R0
	CLHI	R0,NLINES-1		:RANGE CHECK
	JLE	SLINK1			:OK, SKIP
	SVC	OUT,BIGNUM		:ELSE OUTPUT MESSAGE
	J	DDTNOP			:AND EXIT
SLINK1
	STH	R0,SCLINE,,		:SAVE INTO SCLINE
	J	DDTNOP			:AND EXIT


:	DSPDTA:	DISPLAY TRACE DATA IN NORMAL FORMAT
:	--------------------------------------------
:	INPUT:	R2 - CURRENT ENTRY FOR DISPLAY
:		R14 - LINK REGISTER
:	OUTPUT: DISPLAY TRACE DATA IN NORMAL FORMAT
:	DESTROY:
DSPDTA
	SVC	K.OUT,BLANK2		:TWO BLANK 1ST
	LB	R3,FTRSBF,R2,		:GET THE 1ST BYTE OF DATA
	LR	R4,R3			:COPY 1ST BYTE TO R4
	SRHLS	R4,4			:GET 1ST NIBBLE (= LINE #)
	LR	R0,R4			:SET R0 = LINE #
	LHI	R1,HEXB.1		:OUTPUT LINE # AS 1 BYTE HEX
	SVC	KIO,$A10		:OUTPUT LINE #
	SVC	K.OUT,BLANK3		:3 BLANKS
	LR	R6,R3			:COPY 1ST BYTE INTO R6
	LA	R7,SCPXMT		:ASSUME XMT
	NHI	R6,FTRXMT		:GET THE XMT/RCV INDICATOR
	JNFS	DSPDT1			:HIT, SKIP
	LA	R7,SCPRCV		:ELSE, MUST BE RCV
DSPDT1
	SVC	K.OUT,,R7		:OUTPUT 'X' OR 'R'
	SVC	K.OUT,BLANK2		:2 BLANKS
	LHL	R5,LCBPTR,R4,R4		:GET LCBTAB ADDR
	LB	R5,LCBTAB+LCBP.S,R5,	:GET THE PRI/SEC INDICATOR
					:PRI = 1, SEC = 0
	SLHLS	R6,1
	OR	R5,R6			:R5 = 0 FOR SEC.RCV, 1 FOR PRI.RCV
					:     2 FOR SEC.XMT, 3 FOR PRI.XMT
	LB	R1,FTRSBF+1,R2,		:GET 2ND BYTE OF THE DATA
	LR	R6,R6
	JEFS	.+6
	NHI	R1,0F			:IF XMT, THE 1ST NIBBLE IS XMT CC
	LB	R0,SCPLEN,R5		:GET MAX LEGAL LENGTH
	CR	R1,R0			:WITHIN RANGE?
	JLFS	DSPDT2			:YES, SKIP
	LR	R1,R0			:ELSE, SET TO ILLEGAL CODE
DSPDT2
	LIS	R0,5			:GET NAME ENTRY LENGTH
	MHR	R1,R0			:CALCULTE OFFSET
	LH	R6,SCPTBL,R5,R5		:GET THE PROPER TABLE
	SVC	K.OUT,SCPTBL,R6,R1	:OUTPUT THE MNEUMONIC NAME
	SVC	K.OUT,BLANK2		:2 BLANKS
:
:BEGIN (03/28/86 YLH)
:	FOR RECEIVING THE CC IS ALWAYS ZERO
:	FOR TRANSMITTING THE CC IS THE XMT RETURN CODE
:
	LIS	R0,0			:ASSUMING RECEIVING
	THI	R5,FTRXMT^1		:IS IT TRANSMITTING?
	JEFS	DSPDTY			:NO
:
:END (03/28/86 YLH)
:
	LB	R0,FTRSBF+1,R2,
	SRHLS	R0,4			:GET THE CC CODE
DSPDTY	LHI	R1,HEXB.1		:1 BYTE HEX
	SVC	KIO,$A10		:OUTPUT CC CODE
:	SVC	K.OUT,BLANK1		:1 BLANKS
	SVC	K.OUT,BLANK3		:3 BLANKS (03/28/86 YLH)
	LB	R0,FTRSBF+2,R2,		:GET THE 'A' BYTE
	LHI	R1,HEXB.2		:2 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT THE 'A' DATA
	SVC	K.OUT,BLANK3		:3 BLANKS
	LB	R7,FTRSBF+3,R2,		:GET THE 'C' BYTE
	LR	R0,R7			:COPY INTO R0
	LHI	R1,HEXB.2		:2 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT 'C' BYTE
	SVC	K.OUT,BLANK3		:3 BLANKS
	LB	R0,FTRSBF+1,R2,		:GET THE XMT OP CODE/RCV RC CODE
	CLHI	R0,1			:DATA/INF FRAME?
	JLE	DSPDT5			:YES, SKIP
	CLHI	R0,9			:UN-NUMBERED FRAMES?
	JLE	DSPDT3			:YES, SKIP
	CLHI	R0,12			:SUPERVISORY FRAMES?
	JLE	DSPDT4			:YES, SKIP
DSPDT3
	SVC	K.OUT,BLANK1
	SVC	K.OUT,BLANK4
	LA	R4,SCPPFT
	LR	R1,R5
	SLHLS	R1,1
	SVC	K.OUT,,R4,R1		:P/F INDICATOR
	SVC	K.OUT,BLANK4		:...
	SVC	K.OUT,BLANK4		:...
	J	DSPDT7			:SKIP THE BREAKDOWN OF 'C' BYTE
DSPDT4
:	BREAK C BYTE INTO N(R) P/F
	LR	R0,R7			:GET 'C' BYTE AGAIN
	SRHLS	R0,5			:GET THE 1ST 3 BITS
	LHI	R1,HEXB.1		:1 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT IT
	SVC	K.OUT,BLANK4		:4 BLANKS
	NHI	R7,01F			:MARK OFF 1ST 3 BITS
	LR	R0,R7			:COPY INTO R0
	SRHLS	R0,3			:GET THE P/F BIT
	LA	R4,BLANK1		:ASSUME NO P/F BIT
	LIS	R1,0			:...
	LR	R0,R0			:P/F ?
	JEFS	DSPDTX			:NO, SKIP
	LA	R4,SCPPFT		:ELSE, R4 PTR TO SCPPFT
	LR	R1,R5			:COPY R5 TO R1
	SLHLS	R1,1			:MAKE HW INDEX
DSPDTX
	SVC	K.OUT,,R4,R1		:OUTPUT THE P/F INDICATOR
	SVC	K.OUT,BLANK4		:3 BLANKS
	SVC	K.OUT,BLANK4		:3 BLANKS
	J	DSPDT7
DSPDT5
:	BREAK C BYTE INTO N(R) P/F N(S)
	LR	R0,R7			:GET 'C' BYTE AGAIN
	SRHLS	R0,5			:GET THE 1ST 3 BITS
	LHI	R1,HEXB.1		:1 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT IT
	SVC	K.OUT,BLANK4		:4 BLANKS
	NHI	R7,01F			:MARK OFF 1ST 3 BITS
	LR	R0,R7			:COPY INTO R0
	SRHLS	R0,3			:GET THE P/F BIT
	LA	R4,BLANK1		:ASSUME NO P/F BIT
	LIS	R1,0			:...
	LR	R0,R0			:P/F ?
	JEFS	DSPDT6			:NO, SKIP
	LA	R4,SCPPFT		:ELSE, R4 PTR TO SCPPFT
	LR	R1,R5			:COPY R5 TO R1
	SLHLS	R1,1			:MAKE HW INDEX
DSPDT6
	SVC	K.OUT,,R4,R1		:OUTPUT THE P/F INDICATOR
	SVC	K.OUT,BLANK3		:3 BLANKS
	LR	R0,R7			:..
	NHI	R0,0F			:GET THE LAST 3 BITS
	LHI	R1,HEXB.1		:1 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT IT
	SVC	K.OUT,BLANK4		:4 BLANKS
DSPDT7
	LH	R0,FTRSBF+4,R2,		:GET THE BYTE COUNT
	LHI	R1,HEXB.3		:3 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT THE (MOD 256)BYTE COUNT
	NHI	R3,FTRTIM		:TIME STAMPED?
	JE	DSPDT8
	SVC	K.OUT,BLANK3		:3 BLANKS
	LHL	R0,FTRSBF+6,R2,		:GET THE 1ST HW OF TIME
	EXHR	R0,R0			:SHIFT INTO 1ST HW
	LHL	R3,FTRSBF+8,R2,		:GET THE 2ND HW OF THE TIME
	OR	R0,R3			:MAKE FW
	LHI	R1,HEXB.8		:OUTPUT AS 8 DIGITS HEX
	SVC	KIO,$A10		:OUTPUT THE TIME
	AIS	R2,4			:ADJUST THE INDEX PTR
DSPDT8
	SVC	K.OUT,XDCRLF		:OUTUPT <CR> <LF>
	AIS	R2,6			:ADVANCE TO NEXT ENTRY
	CLHI	R2,FTRACE*FTRBFL	:WRAP AROUND?
	JLFS	DSPDT9			:NO, SKIP
	LIS	R2,0			:ESLE, RESET INDEX PTR
DSPDT9
	STH	R2,CDSIND,,		:UPDATE CURRENT DISPLAY INDEX
	JR	R14			:RETURN


:	DSPSDA:	DISPLAY TRACE DATA IN COMPACT FORMAT
:	--------------------------------------------
:	INPUT:	R2 - CURRENT ENTRY FOR DISPLAY
:		R14 - LINK REGISTER
:	OUTPUT: DISPLAY TRACE DATA IN NORMAL FORMAT
:	DESTROY:
DSPSDA
	LB	R3,FTRSBF,R2,		:GET THE 1ST BYTE OF DATA
	LR	R4,R3			:COPY 1ST BYTE TO R4
	SRHLS	R4,4			:GET 1ST NIBBLE (= LINE #)
	LR	R0,R4			:SET R0 = LINE #
	LHI	R1,HEXB.2		:OUTPUT LINE # AS 2 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT LINE #
	SVC	K.OUT,BLANK1		:1 BLANKS
	LR	R6,R3			:COPY 1ST BYTE INTO R6
	LA	R7,SCPXMT		:ASSUME XMT
	NHI	R6,FTRXMT		:GET THE XMT/RCV INDICATOR
	JNFS	DSPSD1			:HIT, SKIP
	LA	R7,SCPRCV		:ELSE, MUST BE RCV
DSPSD1
	SVC	K.OUT,,R7		:OUTPUT 'X' OR 'R'
	SVC	K.OUT,BLANK1		:1 BLANK
	LHL	R5,LCBPTR,R4,R4		:GET LCBTAB ADDR
	LB	R5,LCBTAB+LCBP.S,R5,	:GET THE PRI/SEC INDICATOR
					:PRI = 1, SEC = 0
	SLHLS	R6,1
	OR	R5,R6			:R5 = 0 FOR SEC.RCV, 1 FOR PRI.RCV
					:     2 FOR SEC.XMT, 3 FOR PRI.XMT
	LB	R1,FTRSBF+1,R2,		:GET 2ND BYTE OF THE DATA
	LR	R6,R6
	JEFS	.+06
	NHI	R1,0F
	LB	R0,SCPLEN,R5		:GET MAX LEGAL LENGTH
	CR	R1,R0			:WITHIN RANGE?
	JLFS	DSPSD2			:YES, SKIP
	LR	R1,R0			:ELSE, SET TO ILLEGAL CODE
DSPSD2
	LIS	R0,5			:GET NAME ENTRY LENGTH
	MHR	R1,R0			:CALCULTE OFFSET
	LH	R6,SCPTBL,R5,R5		:GET THE PROPER TABLE
	SVC	K.OUT,SCPTBL,R6,R1	:OUTPUT THE MNEUMONIC NAME
:
:BEGIN (03/28/86 YLH)
:	FOR RECEIVING THE CC IS ALWAYS ZERO
:	FOR TRANSMITTING THE CC IS THE XMT RETURN CODE
:
	LIS	R0,0			:ASSUMING RECEIVING
	THI	R5,FTRXMT^1		:IS IT TRANSMITTING?
	JEFS	DSPSDY			:NO
:
:END (03/28/86 YLH)
:
	LB	R0,FTRSBF+1,R2,		:GET THE 2ND BYTE OF DATA
	SRHLS	R0,4			:GET THE CC CODE
DSPSDY	LHI	R1,HEXB.2		:2 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT CC CODE
	LB	R0,FTRSBF+2,R2,		:GET THE 'A' BYTE
	LHI	R1,HEXB.3		:3 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT THE 'A' DATA
	LB	R7,FTRSBF+3,R2,		:GET THE 'C' BYTE
	LR	R0,R7			:COPY INTO R0
	LHI	R1,HEXB.3		:3 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT 'C' BYTE
	SVC	K.OUT,BLANK1
	LH	R0,FTRSBF+4,R2,		:GET BYTE COUNT
	LHI	R1,HEXB.3		:3 DIGIT HEX
	SVC	KIO,$A10		:OUTPUT THE BYTE COUNT
	NHI	R3,FTRTIM		:TIME STAMPED?
	JEFS	DSPSD3
	LHL	R0,FTRSBF+6,R2,		:GET 1ST HW OF THE TIME
	EXHR	R0,R0			:SHIFT INTO 1ST HW
	LHL	R3,FTRSBF+8,R2,		:GET THE 2ND HW OF THE TIME
	OR	R0,R3			:MAKE FW
	LHI	R1,HEXB.9		:OUTPUT AS 8 DIGITS HEX
	SVC	KIO,$A10		:OUTPUT THE TIME
	AIS	R2,4			:ADJUST THE INDEX PTR
DSPSD3
	SVC	K.OUT,XDCRLF		:OUTUPT <CR> <LF>
	AIS	R2,6			:ADVANCE TO NEXT ENTRY
	CLHI	R2,FTRACE*FTRBFL	:WRAP AROUND?
	JLFS	DSPSD4			:NO, SKIP
	LIS	R2,0			:ESLE, RESET INDEX PTR
DSPSD4
	STH	R2,CDSIND,,		:UPDATE CURRENT DISPLAY INDEX
	JR	R14			:RETURN

:	DSPBDA:	DISPLAY BG TRACE DATA
:	------------------------------
:	INPUT:	R2 - CURRENT ENTRY FOR DISPLAY
:		R14 - LINK REGISTER
:	OUTPUT: DISPLAY BG TRACE DATA
:	DESTROY:
DSPBDA
	SVC	K.OUT,BLANK1		:ONE BLANK FIRST
	LB	R0,BTRSBF,R2,		:GET THE 1ST BYTE OF DATA 
	LHI	R1,HEXB.2		:OUTPUT ISIS PORT # AS 2 BYTE HEX
	SVC	KIO,$A10		:OUTPUT
	SVC	K.OUT,BLANK3		:3 BLANKS
	LHL	R3,BTRSBF+2,R2,		:GET THE BYTE COUNT AND OTHERS..
	LR	R0,R3			:COPY TO R0
	LA	R7,SCPINP		:ASSUME INPUT
	NHI	R0,BTROUT		:CHECK
	JEFS	DSPBD1			:HIT, SKIP
	LA	R7,SCPOUT		:ELSE, MUST BE OUTPUT
DSPBD1
	SVC	K.OUT,,R7		:OUTPUT 'I' OR 'O'
	SVC	K.OUT,BLANK2		:2 BLANKS
	LR	R0,R3			:COPY R3 TO R0 AGAIN
	LA	R7,SCPBEG		:ASSUME BEG
	NHI	R0,BTREND		:CHECK
	JEFS	DSPBD2			:HIT, SKIP
	LA	R7,SCPEND		:ELSE, MUST BE END
DSPBD2
	SVC	K.OUT,,R7		:OUTPUT 'BEG' OR 'END'
	SVC	K.OUT,BLANK4		:4 BLANKS
	SVC	K.OUT,BLANK2		:2 BLANKS (03/28/86 YLH)
	LB	R0,BTRSBF+1,R2,		:GET THE LU REL ID #
	LHI	R1,HEXB.3		:OUTPUT LU # AS 3 BYTE HEX
	SVC	KIO,$A10		:OUTPUT
	SVC	K.OUT,BLANK4		:4+4+4+4+4 BLANKS
	SVC	K.OUT,BLANK4
	SVC	K.OUT,BLANK4
	SVC	K.OUT,BLANK4
	SVC	K.OUT,BLANK4
	SVC	K.OUT,BLANK1
	LR	R0,R3
	NHI	R0,3FF			:GET THE BYTE COUNT
	LHI	R1,HEXB.3		:3 DIGIT HEXT
	SVC	KIO,$A10		:OUTPUT
	SVC	K.OUT,BLANK3		:3 BLANKS
	L	R0,BTRSBF+4,R2,		:GET THE TIME STAMP
	LHI	R1,HEXB.8		:OUTPUT AS 8 DIGITS HEXT
	SVC	KIO,$A10		:OUTPUT THE TIME
	SVC	K.OUT,XDCRLF		:OUTPUT <CR> <LF>
	AIS	R2,8			:ADJUST THE INDEX PTR
	CLHI	R2,BTRBFL*BTRACE	:WRAP AROUND?
	JLFS	DSPBD3			:NO, SKIP
	LIS	R2,0			:ELSE, RESET THE INDEX PTR
DSPBD3
	STH	R2,CDXIND,,		:UPDATE CURRENT DISPLAY INDEX
	JR	R14			:RETURN

:	DSPBSD:	DISPLAY BG TRACE DATA IN SHORT FORMAT
:	-----------------------------------------------
:	INPUT:	R2 - CURRENT ENTRY FOR DISPLAY
:		R14 - LINK REGISTER
:	OUTPUT: DISPLAY BG TRACE DATA IN SF 
:	DESTROY:
DSPBSD
	LB	R0,BTRSBF,R2,		:GET THE 1ST BYTE OF DATA 
	LHI	R1,HEXB.2		:OUTPUT ISIS PORT # AS 2 BYTE HEX
	SVC	KIO,$A10		:OUTPUT
	SVC	K.OUT,BLANK1		:1 BLANKS
	LHL	R3,BTRSBF+2,R2,		:GET THE BYTE COUNT AND OTHERS..
	LR	R0,R3			:COPY TO R0
	LA	R7,SCPINP		:ASSUME INPUT
	NHI	R0,BTROUT		:CHECK
	JEFS	DSPBS1			:HIT, SKIP
	LA	R7,SCPOUT		:ELSE, MUST BE OUTPUT
DSPBS1
	SVC	K.OUT,,R7		:OUTPUT 'I' OR 'O'
	SVC	K.OUT,BLANK1		:1 BLANKS
	LR	R0,R3			:COPY R3 TO R0 AGAIN
	LA	R7,SCPBEG		:ASSUME BEG
	NHI	R0,BTREND		:CHECK
	JEFS	DSPBS2			:HIT, SKIP
	LA	R7,SCPEND		:ELSE, MUST BE END
DSPBS2
	SVC	K.OUT,,R7		:OUTPUT 'BEG' OR 'END'
	SVC	K.OUT,BLANK4		:4 BLANKS
	SVC	K.OUT,BLANK2		:2 BLANKS (03/28/86 YLH)
	LB	R0,BTRSBF+1,R2,		:GET THE LU REL ID #
	LHI	R1,HEXB.3		:OUTPUT LU # AS 3 BYTE HEX
	SVC	KIO,$A10		:OUTPUT
	SVC	K.OUT,BLANK4		:4 BLANKS
	LR	R0,R3
	NHI	R0,3FF			:GET THE BYTE COUNT
	LHI	R1,HEXB.3		:3 DIGIT HEXT
	SVC	KIO,$A10		:OUTPUT
	L	R0,BTRSBF+4,R2,		:GET THE TIME STAMP
	LHI	R1,HEXB.9		:OUTPUT AS 8 DIGITS HEXT
	SVC	KIO,$A10		:OUTPUT THE TIME
	SVC	K.OUT,XDCRLF		:OUTPUT <CR> <LF>
	AIS	R2,8			:ADJUST THE INDEX PTR
	CLHI	R2,BTRBFL*BTRACE	:WRAP AROUND?
	JLFS	DSPBS3			:NO, SKIP
	LIS	R2,0			:ELSE, RESET THE INDEX PTR
DSPBS3
	STH	R2,CDXIND,,		:UPDATE CURRENT DISPLAY INDEX
	JR	R14			:RETURN


					:(10/9/85/TTW/BEGIN)
:	GETLN: GET LINE NUMBER                      
:	------------------------------------------------------------
:	OUTPUT: R0 = LINE NUMBER
:	LINK: R14

GETLN
	LHI	R4,$A10			:GET LINE NUMBER IN DECIMAL
	JAL	R5,DS.NUM		:INTO R0
	CLHI	R0,NLINES-1		:RANGR CHECK
	JLE	GETLN4			:OK, SKIP
	SVC	OUT,BIGNUM		:ELSE OUTPUT MSG
	J	DDTNOP			:AND EXIT
GETLN4
	JR	R14

:	GETCU: GET CU NUMBER
:	--------------------
:	THIS ROUTINE GET A RELATIVE STATION NUMBER FROM 
:	SCREEN AND CHANGE IT TO ABSOLUTE STATION NUMBER
GETCU
	LIS	R7,0			:GIVE INIT. VALUE
	LR	R6,R0			:FIRST LINE?
	JE	GETC6			:Y - SKIP
	LIS	R1,0			:START FROM FIRST LINE
GETC4	LHL	R2,LNCPTR,R1,R1		:GET LNCTAB
	LB	R3,LNCTAB+LNMXPU,R2,	:GET MAXPU#
	AR	R7,R3			:ADD IT
	AIS	R1,1			:NEXT LINE
	CR	R1,R0			:ALL DONE?
	JL	GETC4			:N- CONTINUE
GETC6	LHI	R4,$A10			:GET CU # IN DECIMAL
	JAL	R5,DS.NUM		:INTO R0
	LHL	R2,LNCPTR,R6,R6		:GET LNCTAB
	LB	R3,LNCTAB+LNMXPU,R2,	:GET MAX CU#
	CR	R0,R3			:RANGE CHECK
	JLFS	GETC8			:OK - SKIP
	SVC	OUT,BIGNUM		:ELSE REPORT ERROR
	J	DDTNOP			:AND EXIT
GETC8	AR	R0,R7			:GET ABSOLUTE STATION #
	JR	R14			:AND RETURN




:	ENIFTR: ENABLE INFORAMTION TRACE TO RECORD 10H BYTES OF DATA
:	------------------------------------------------------------

ENIFTR
	JAL	R14,GETLN		:GET LINE NUMBER
	SBT	R0,INFTLN,,		:TURN ON FLAG
	J	DDTNOP			:AND EXIT

:	DAIFTR: DISABLE INFOTMATION TRACE
:	---------------------------------

DAIFTR
	JAL	R14,GETLN		:GET LINE NUMBER
	RBT	R0,INFTLN,,		:TURN OFF FLAG
	J	DDTNOP			:AND EXIT

:	ENIFCU: ENABLE INFORMATION TRACE FOR A CU
:	-----------------------------------------

ENIFCU
	JAL	R14,GETLN		:GET LINE NUMBER
	JAL	R14,GETCU		:GET CU NUMBER
	SBT	R0,INFTCU,,		:SET FLAG
	J	DDTNOP			:EXIT

:	DAIFCU: DISABLE INFORMATION TRACE FOR A CU
:	------------------------------------------

DAIFCU
	JAL	R14,GETLN		:GET LINE NUMBER
	JAL	R14,GETCU		:GET CU NUMBER
	RBT	R0,INFTCU,,		:RESET FLAG
	J	DDTNOP			:AND EXIT
					:(10/9/85/TTW/END)

	FO	FGGBDF
	FO	GBLDEF

	EM
    	SUBTTL	PATCH AREA DEFINITIONS $ CALCULATE AREA LENGTH
:PATCH.F01
:		THIS FILE MUST BE RIGHT BEFORE THE FINISH.LIB

:**********************************************************************
:
:	This program is the sole property and confidential
:	information of TYMSHARE, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:**********************************************************************
	RA	0		:	PATCH.LIB

:	This library defines symbols, macros and areas used for patching
:	released code and keeping a history of patches in Engine memory.

:	A file containing the actual patches to the code should be
:	assembled as the last file before saving the NIB file.

:	Patches are added by ORGing to the area to patch,
:	zeroing memory for the length of the patch, writing new
:	code starting at that area.
:	Three macros have been defined to do this.
:	Each patch should start with a PATCH macro and if the
:	patch is for more than one area it should be continued
:	with a CONPATCH macro.  The patch should be ended with
:	an ENDPATCH macro.
:
:	Using these macros will cause the patch number, author
:	area patched, and reason for patch to be output during assembly.
:	Also, a history table starting at PATHIS will be created with
:	16 (10hex) byte entries.
:	Each entry will contain the date and time of patch and the author.
:	Also, the ?VERNO DDT command will indicate that patches are
:	installed by reporting a version biased by 100 octal.
:	For example, if the version is 1.13, ?VERNO will report 101.13.
:
:	If a patch must be temporarily added by hand, the
:	history area and the version (cell VERREV) should be updated.
:
:	The following symbols may be defined before assemply of PATCH.LIB.
:	If not defined they will take the default listed.
:
:	VERSION release version number, will be ORed with octal 100.
:		default: 00
:	VERREV	area in seg 0E which contains a one byte version and
:		a one byte revision.  Defined by FINISH.LIB.
:		default: none, symbol must be defined.
:	A.ERR	defines segment to use for patch history area
:		default: seg 0
:	PATHIS	defines the start of the patch history area,
:		each entry will be 16 bytes as follows,
:		19yy/mmdd/hhmm/uname(10 chars 0 filled)
:		where 19yy, mmdd and hhmm are in bcd (4 bits per decimal
:		digit) and uname is in ASCII.
:		default: an area will be defined by this library
:	PHSIZE defines the length in bytes of the PATHIS area.
:		default: 140 hex
:	PATCH0	defines the start of a Segment 0 patch area.
:		default: an area will be defined by this library
:	P0SIZE defines the length in bytes of the PATCH0 area.
:		default: 200 hex
:	PATCH1	defines the start of a code segment  patch area.
:		default: an area will be defined by this library
:	P1SIZE defines the length in bytes of the PATCH1 area.
:		default: 400 hex
:	SEGn,SnSIZE	Must be defined for the area being patched when
:		the patch is made.
:
:	The following symbols are used by the patch macros.
:	They may be read by, but should not be modified by, a patch.
:
:	PAHPTR	pointer to the next available entry in PATHIS
:	PA0PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH0 area.  It starts out
:		equal to PATCH0 and is moved up after each patch in
:		the PATCH0 area.  Use of the symbol assumes that all
:		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
:	PA1PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH1 area.  It starts out
:		equal to PATCH1 and is moved up after each patch in
:		the PATCH1 area.  Use of the symbol assumes that all
:		patches from PATCH1 to PATCH1+P0SIZE will be done in order.
:	QPATS	current patch segment number
:	QPATB	starting address of current patch
:	QPATL	length of current patch
:	QPATA	0 IF PATCH IS IN PATCH0 AREA, 1 IF IN PATCH1, ELSE -1
:	PATACT	> 0 if when a patch is active.

	KILL	.EQ.,.GT.
.NE.	MACRO(P1,P2)[(((P1)-(P2))!((P2)-(P1)))^-$A35]
.GT.	MACRO(P1,P2)[((P2)-(P1))^-$A35]


::	PATCH(yymmdd,hhmm,uname,fba,lba1,len)	grab a patch area
:
:		yymmdd	Date patch written, if patch is modified in ANY
:		way this must be updated.
:		hhmm	Time patch written, current Cupertino time.
:		If patch is modified this also must be updated.
:		uname	ONTYME username of person who authored patch.
:		Personal name, not NETMID or NET3 or such.
:	fba	adress of start of patch
:	lba1	address of next byte after end of patch
:	len	length (default hex) of patch in bytes if lba1 is missing
:
:	CONPATCH(fba,lba1,len)	continue a patch in a new area
:		Similar to PATCH but moves to a new area, must be
:		preceeded by a PATCH statement.
:
:	ENDPATCH(comment)	End a PATCH started with PATCH call.
:
:		comment	Description of patch to be output during
:			assembly.  Commas should be preceeded by `.
:
:	Example:
:	:	PATCH TO FIX HDLC ROOM CHECKING ROUTINE
:	  IF	HDLC&(LAPB!LAP)
:	PATCH(811009,1422,FRED,XROOM,,2)
:		LIS	R4,7
:	ENDPATCH(fix hdlc room checking routine)
:	  EI
:
:	:	PATCH TO FIX TRANSMITER BUG
:	PATCH(811009,1630,DDM,XSEND,XSE010)
:	  IF	FINACT	:IF INTERFRAME FILL TIMER ENABLED
:		J	PA1PTR
:	  EI
:	PATRTN	LR	R6,RSIO
:		AHI	R6,OUTSCT,RSIP
:
:	CONPATCH(PA1PTR,,0C)
:		SBT	RL,FRMTMT,,	:INDICATE FRAME TRANSMITTED
:		JNR	R7		:IF ALREADY TRANSMITTED
:		J	PATRTN		:RETURN TO PATCHED AREA
:	ENDPATCH(fix transmitter bug)

	GL	VERSIO,VERREV,A.ERR,PATHIS,PHSIZE,PATCH0,P0SIZE,PATCH1,P1SIZE
	GL	PAHPTR,PA0PTR,PA1PTR,QPATS,QPATB,QPATL,QPATA,PATACT

  IF	1-\A.ERR
A.ERR	EQ	0
  EI
  IF	1-\PHSIZE
PHSIZE	EQ	140
  ELSE
PHSIZE	EQ	(PHSIZE+0F)/10*10
  EI
  IF	1-\P0SIZE
P0SIZE	EQ	200
  EI
  IF	1-\P1SIZE
P1SIZE	EQ	400
  EI
  IF	1-\PATHIS
	SEG	A.ERR
	BND	4
PATHIS	HS	PHSIZE/2
  EI
  IF	1-\PATCH0
	SEG	0
PATCH0	HS	P0SIZE/2
  EI
  IF	1-\PATCH1
	SEG	A.CODE
PATCH1	HS	P1SIZE/2
  EI

PAHPTR	EQ	PATHIS	:INIT HISTORY POINTER TO START OF AREA
PA0PTR	EQ	PATCH0	:INIT PTR TO START OF AREA
PA1PTR	EQ	PATCH1	:INIT PTR TO START OF AREA
PATACT	EQ	0	:FLAG NO PATCH ACTIVE
QPATA	EQ	-1	:CLEAR PATCH AREA FLAG
QPATS	EQ	-1
QPATB	EQ	-1
QPATL	EQ	-1

	KILL	PATCH
PATCH	macro(day,tim,usr,fba,lba1,len)[
:  IF	\VERSION
:VERSION EQ	VERSION!$8100
:  ELSE
:VERSION EQ	$8100
:  EI
:	SEG	0E
:	ORG	VERREV
:	BC	VERSION
	SEG	A.CODE
  IF	PATACT
 REMARK %>>>> ERROR **** Previous PATCH not ended with ENDPATCH <<<<%
  ELSE
PATACT	EQ	1
  EI
 REMARK %%PATCH added on day at tim by usr`.
	SEG	A.ERR
	ORG	PAHPTR
   IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
   EI
	WC	$0 day!19000000
	HC	$0 tim
Q	AC	\usr\
Q1	HS
	ORG	Q+$a10	:skip to next history area
PAHPTR	HS
  IF	Q1-.	:IF UNAME>10 CHARARACTERS, CLEAR OVERFLOW
	RE	Q1-.
	BC	0
	ER
  EI

QPATS	EQ	((fba)&$00FF0000)^-$010
QPATB	EQ	fba
QPATC	EQ	lba1
  IF	lba1 0
QPATL	EQ	(lba1)-(fba)
  ELSE
QPATL	EQ	len 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of patch end < address of patch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK %	Starts at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK %     Starts at fba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI

	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	(.+1)-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK  overflow <<<<%
  EI
	ORG	QPATB

::	CONPAT(fba,lba1,len)	CONTINUE A PATCH
	KILL	CONPAT
CONPAT	MACRO(cfba,clba1,clen)[
PATACT	EQ	PATACT+1
  IF	2-PATACT
REMARK %>>>> ERROR **** CONPAT not preceded by a PATCH <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
QPATS	EQ	((cfba)&$00FF0000)^-$010
QPATB	EQ	cfba
QPATC	EQ	clba1
  IF	clba1 0
QPATL	EQ	(clba1)-(cfba)
  ELSE
QPATL	EQ	clen 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of conpatch end < address of conpatch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK 	Continues at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK 	Continues at cfba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI
	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	.-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK overflow <<<<$
  EI
	ORG	QPATB

::	ENDPATCH(com)	End a patch - does error checking, outputs comment
	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD CONPATCH(cfba,clba1,clen) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1````c2````c3````c4````c5 >>>
]
]

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD PATCH(day,tim,usr,fba,lba1,len) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1``c2``c3``c4``c5 >>>
]
]

	SUBTTL	CALCULATE AREA LENGTHS


::	MAKE AREAS INTO SEGMENTS.
:
:	FINISH.LIB DEFINES A BLOCK IN THE CONTROL TABLE (CTA) THAT ASSOCIATES
:	MAC PROTECTION WITH MEMORY AREAS.  UP TO 14 AREAS MAY BE DEFINED.
:	THESE AREAS ARE NOT NECESSARILY EQUIVALENT TO SEGMENTS.  HOWEVER,
:	IF THEY ARE NOT, SOME PROGRAMS (AND MOST PEOPLE) GET CONFUSED.
:	THEREFORE, THE FOLLOWING MAPS AREAS INTO SEGMENTS.
:
:	NAD ALLOWS MORE THAN 10000X TO BE PLACED IN ONE "SEG".
:	WE MUST THEREFORE GO INTO EACH SEG AND IF > 10000X ORG BACK TO
:	10000X AND THEN ENTER THE NEXT SEG TO DEPOSIT THE REMAINDER.
:	THIS, OF COURSE, ASSUMES THAT THE NEXT SEG IS EMPTY.
:	A CHECK IS MADE TO INSURE THIS AND AN ERROR IS GENERATED IF
:	THERE IS AN OVERLAP.

	LIST	R
Q1	EQ	0		:INIT TO SEG 0
	RE
	SEG	Q1
  IF	.-10000*(Q1+1)		:IF THIS SEG > 10000X
APROT|Q1+1|	EQ	APROT|Q1|
Q2	EQ	.-10000*(Q1+1)	:SAVE LENGTH OF OVERFLOW
	ORG	(Q1+1)*10000	:GO BACK TO END OF SEG
	SEG	Q1+1		:GO INTO NEXT SEG
    IF	.-(Q1+1)*10000		:IF ALREADY IN USE
 REMARK %>>>> ERROR **** SEG
 NUMBER $A Q1
 REMARK d OVERLAPS NEXT SEGMENT BY
 NUMBER $0 Q2
 REMARK X ****%
	SEG	Q1		:PUT IT BACK IN 1ST SEG SO FINISH.LIB SHOWS IT
    EI
	ORG	.+Q2
  EI
Q1	EQ	Q1+1		:LOOK AT NEXT SEG FOR OVERFLOW
  IF	Q1-$A13			:IF JUST DID SEG 13,14 STOP THE LOOP
Q1	EQ	0
  EI
	ER	Q1


PATCH2	EQ	0
	LIST	-R
           SUBTTL  Control Table Allocation and Diagnostics - FNSH02.R00
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 2.00          Release Date : 09/05/86  **
: **                                                              **
: **  File Name          : FNSH02.R00                             **
: **                                                              **
: **  File Description   : FINISH LIBRARY                         **
: **                                                              **
: **  File Abstract      :                                        **
: **                                                              **
: ******************************************************************
 

	RA	0

:	this file should always be assembled LAST!

:	This macro generates the current GMT date and time by creating
:	the following symbols:
:
:	QQQMON - current month
:	QQQDAY - current day within the month
:	QQQYR  - current year
:	QQQHRS - current hour within the day
:	QQQMIN - current minute within the hour
:	QQQSEC - current second within the minute

GENTIM	MACRO(TIME) [

	RA	$0 0A

QQQQYS	EQ	365*4+1			:quad year size in days
QQQDAZ	EQ	(TIME)/(24*60*60)+365	:days since 1/1/74 + 365
QQQNQY	EQ	QQQDAZ/QQQQYS		:# of quad yrs since 1/1/74
QQQROD	EQ	QQQDAZ-QQQNQY*QQQQYS	:remainder of days 
QQQLEA	EQ	QQQROD/365		:year in current quad yr

	IF	QQQLEA-3
QQQLEA	EQ	3
	EI

QQQYR	EQ	QQQNQY*4+QQQLEA+73
QQQDAY	EQ	QQQROD-QQQLEA*365+1

QQQM1	EQ	31
	IF	QQQLEA-2
QQQM2	EQ	29
	ELSE
QQQM2	EQ	28
	EI
QQQM3	EQ	31
QQQM4	EQ	30
QQQM5	EQ	31
QQQM6	EQ	30
QQQM7	EQ	31
QQQM8	EQ	31
QQQM9	EQ	30
QQQM10	EQ	31
QQQM11	EQ	30
QQQM12	EQ	31

QQQMON	EQ	1
QQQNOT	EQ	1

	RE	
	IF	QQQDAY-QQQM|QQQMON|
QQQDAY	EQ	QQQDAY-QQQM|QQQMON|
QQQMON	EQ	QQQMON+1
	ELSE
QQQNOT	EQ	0
	EI
	ER	QQQNOT

QQQRS1	EQ	(TIME)-((QQQDAZ-365)*(24*60*60))
QQQHRS	EQ	QQQRS1/(60*60)
QQQRS2	EQ	QQQRS1-QQQHRS*(60*60)
QQQMIN	EQ	QQQRS2/60
QQQSEC	EQ	QQQRS2-QQQMIN*60
]

: SET DEFAULTS FOR MULTI-MEG SUPPORT

  IF	\HIMEG
  ELSE
HIMEG	EQ	0
  EI

  IF	HIMEG
   IF	\NMACSS
   ELSE
NMACSS	EQ	0
   EI
NMACSS	EQ	NMACSS+1
   IF	\HIBLK
   ELSE
HIBLK	EQ	3
   EI
  EI

: SET DEFAULT PAGE SIZE

  IF	\PGSZ
  ELSE
   IF	HIMEG
	REMARK	%Page size of 100 assumed.
PGSZ	EQ	100
   ELSE
PGSZ	EQ	0
   EI
  EI

: ALLOCATE FPANEL IF USER HAS NOT

  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI

: ALLOCATE BACKPRESSURE BIT ARRAYS IF USER HAS NOT

  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

: ALLOCATE PATCH AREAS IF USER HAS NOT

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI

: SET UP DEFAULT PROTECTION CODES

	IF	\APROT0
	ELSE
APROT0	EQ	6	:EXECUTION PROTECTED
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	EI
	IF	\APROT1
	ELSE
APROT1	EQ	5	:WRITE PROTECTED
	EI
Q1	EQ	2
	RE	0C
	IF	\APROT|Q1|
	ELSE
APROT|Q1| EQ	6	:EXECUTION PROTECTED
	EI
Q1	EQ	Q1+1
	ER

:	NAD ALLOWS MORE THAN 10000X TO BE PLACED IN ONE "SEG".
:	WE MUST THEREFORE GO INTO EACH SEG AND IF > 10000X ORG BACK TO
:	10000X AND THEN ENTER THE NEXT SEG TO DEPOSIT THE REMAINDER.
:	THIS, OF COURSE, ASSUMES THAT THE NEXT SEG IS EMPTY.
:	A CHECK IS MADE TO INSURE THIS.

Q1	EQ		0
	RE		0E		:FOR Q1 = 0 TO 0E
	  SEG		Q1
Q3	  EQ		10000*(Q1+1)	:  Q3 = UPPER BOUND FOR THIS SEGMENT
	  IF		.-Q3		:  IF THIS SEGMENT OVERFLOWED
Q2	    EQ		.-Q3		:    Q2 = LENGTH OF OVERFLOW
	    ORG		Q3		:    ORG TO MAXIMUM
	    IF		0E-(Q1+1)	:    IF THE NEXT SEG IS NOT E
	      SEG	Q1+1		:      GO INTO NEXT SEG
	      IF	(.-Q3)		:      IF SEG ALREADY IN USE
	        SEG	Q1		:        RETURN TO PREVIOUS SEG
	      ELSE			:      ELSE
APROT|Q1+1|	EQ	APROT|Q1|	:        COPY PROTECTION
	      EI			:      ENDIF
	    EI				:    ENDIF
	    ORG		.+Q2		:    ADD OVERFLOW TO THE CURRENT SEG
	  EI				:  ENDIF
Q1	  EQ		Q1+1		:NEXT Q1
	ER

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	($0S|Q|SIZE-10000)$A;	REMARK	d bytes%;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY!HIMEG
:CTA     WC      CNTRL+$01000    :Control flags
CTA	WC	CNTRL+$01002	:(F00/06/17/87/DB)
      ELSE
:CTA	WC	CNTRL	:CONTROL FLAGS
CTA	WC	CNTRL+2		:(F00/06/17/87/DB)
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
  IF	HIMEG
   IF	1-\H.SG|Q|
H.SG|Q|	EQ	0
   EI
   IF	H.SG|Q|
	WC	0		:NO LO-MEG SEG IF IN HI-MEG
   ELSE
	WC	S|Q|SIZE	:AREA SIZE
   EI
  ELSE
	WC	S|Q|SIZE	:AREA SIZE
  EI
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
Q	EQ	0
	RE	0E
	BC	APROT|Q|
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id
	HS	1		:patch version #
	WS	2		:initial suspend list
QQQTIM	CURGMT			:get current GMT
	GENTIM(QQQTIM)		:output formatted GMT
	RA	$0 0
	BC	QQQMON,QQQDAY,QQQYR  :date code generated
	BC	QQQHRS,QQQMIN,QQQSEC :time code generated (GMT)

	WS	10	:RESERVED FOR FUTURE EXPANSION

    IF	((\ICTL.H)&(\ICTL.L))
ISUSHI	WC	ICTL.H	:USED BY ISIS TO KNOW WHICH SLOTS...
ISUSLO	WC	ICTL.L	:ISRM CONTROLS
	WS	10	:RESERVED FOR FUTURE EXPANSION
    ELSE
    EI

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF HIMEG
Q	EQ	0		:SEG NMBR
QQLO	EQ	0		:LOW MEM PAGE COUNTER
QQHI	EQ	0		:HI MEM PAGE COUNTER
	RE	0E
     IF S|Q|SIZE
      IF H.SG|Q|
	WC	(APROT|Q|^1C)!(HIBLK^18)!(((S|Q|SIZE-1)/PGSZ)^10)!QQHI
QQHI	EQ	QQHI+((S|Q|SIZE+(PGSZ-1))/PGSZ)
      ELSE
	WC	(APROT|Q|^1C)!(0^18)!(((S|Q|SIZE-1)/PGSZ)^10)!QQLO
QQLO	EQ	QQLO+((S|Q|SIZE+(PGSZ-1))/PGSZ)
      EI
     ELSE
	WC	0
     EI
Q	EQ	Q+1
	ER
H.SGE	EQ	0		:SEG E IS ALWAYS IN LO MEG
SESZ	EQ	.+14		:ESTIMATE LENGTH OF SEG E
     IF XMEMRY
      IF \NMACSS
SESZ	EQ	SESZ+4C*NMACSS
      EI
     EI
	WC	(4^1C)!(1^18)!(((SESZ-CTA)/PGSZ)^10)!0
	WC	(4^1C)!(2^18)!(4^10)!0
	WC	MACPSD
	WS	2
    EI

    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register set(s) allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

: MACROES TO OUTPUT RIGHT-JUSTIFIED NUMBERS (DECIMAL & HEX)

RJDEC	MACRO(NUM,WID)[
QRJ	EQ	0A
  RE	WID-1
    IF	QRJ-(NUM)
	REMARK	 
    EI
QRJ	EQ	QRJ*0A
  ER
	NUMBER	NUM$A
]

RJHEX	MACRO(NUM,WID)[
QRJ	EQ	0A
  RE	WID-1
    IF	QRJ-(NUM)
	REMARK	 
    EI
QRJ	EQ	QRJ*10
  ER
	NUMBER	NUM$0
]

: TELL MEMORY REQUIREMENTS

Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
Q5	EQ	0
	REMARK	%                                 
	REMARK	Memory Requirements in Bytes
	REMARK	%     Segment   Length   Lo/Hi    
  IF	PGSZ
QP	EQ	PGSZ
  ELSE
QP	EQ	400
	NUMBER	100
	REMARK	x byte page   
  EI
	NUMBER	QP
	REMARK	x byte page
	REMARK	%     -------   ------   -----    
  IF	1-PGSZ
	REMARK	--------------   
  EI
	REMARK	--------------
	
  RE	0F
   IF	S|Q|SIZE
	REMARK	%       
	RJDEC(Q,2)
	REMARK	      
	RJDEC(S|Q|SIZE,5)
	REMARK	d   
Q4	EQ	(S|Q|SIZE+(QP-1))&(-QP)
    IF	HIMEG
     IF	H.SG|Q|
	REMARK	HiMeg        
     ELSE
	REMARK	LoMeg        
Q5	EQ	Q5+Q4
     EI
    ELSE
	REMARK	LoMeg        
Q5	EQ	Q5+Q4
    EI
    IF	1-PGSZ
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF)
	RJHEX(Q3,5)
QQ	EQ	QQ+Q3
	REMARK	x           
    EI
	RJHEX(Q4,5)
	REMARK	x
   EI
Q	EQ	Q+1
  ER

:	GIVE FINAL SIZES
	REMARK	%                                     
  IF	1-PGSZ
	REMARK	------           
  EI
	REMARK	------
	REMARK	%            Total for low megabyte:  
  IF	1-PGSZ
Q6	EQ	(QQ+3FF)/400		:FORCE TO 1K BOUNDRY
	RJDEC(Q6,5)
	REMARK	d K-bytes   
  EI
Q7	EQ	(Q5+3FF)/400		:COMPUTE SIZE IN K
	RJDEC(Q7,5)
	REMARK	d K-bytes
  IF	HIMEG
	REMARK	%   Total for extended mem block 
	RJDEC(HIBLK,2)
	REMARK	:  
QQ	EQ	(QQHI*PGSZ+3FF)/400	:SIZE IN K
	RJDEC(QQ,5)
	REMARK	d K-bytes (
	NUMBER	QQHI
	REMARK	x pages)
  EI

	RA	$0 0A
	REMARK	%%Code Generated:  
	IF	10-QQQMON
	REMARK	0
	EI
	NUMBER	QQQMON
	REMARK	/
	IF	10-QQQDAY
	REMARK	0
	EI
	NUMBER	QQQDAY
	REMARK	/
	NUMBER	QQQYR
	REMARK	  
	IF	10-QQQHRS
	REMARK	0
	EI
	NUMBER	QQQHRS
	REMARK	:
	IF	10-QQQMIN
	REMARK	0
	EI
	NUMBER	QQQMIN
	REMARK	:
	IF	10-QQQSEC
	REMARK	0
	EI
	NUMBER	QQQSEC
	REMARK	 GMT%
	
	RA	0	:(F01/12/16/87/DB) DEFAULT BACK TO HEX RADIX FOR PATCHES

	UN		:spew out all undefined symbols

    @?