	SUBTTL	ISIS Assembly Switch Definitions	- START.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

	REMARK %Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	05;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs

:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	\MAXPRT
  ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT	EQ	NPORTT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
	SUBTTL	Engine hardware trace trapping routine
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TRACE.LIB

:	This file provides the necessary backbone for using the TYMNET-ENGINE
:	harware-trace feature.  It should be assembled IMMEDIATELY AFTER the
:	START.LIB file.  The file may be assembled directly from the library
:	version, in which case it is necessary to patch the appropriate test
:	into the assembled code, OR it may be copied and the test hard-coded.

	GL	ENTRY,CRASH	:TWO LIKELY CANDIDATES FOR SYMBOLS REQUIRED

	MO	.,TRACE
	SEG	0		:IN SEGMENT 0
	ORG	10		:AT LOCATION 10
TRPSD	WC	1000,ENTRY	:FORCE A TRANSFER TO "ENTRY"
	WC	TRACE		:ON TRAP, GO TO "TRACE"
TRSAVE	HS	22		:USEFUL AREA TO SAVE REGS, ETC

	SEG	A.CODE		:IN CODE AREA
TRACE	HS	0		:ENTRY TO TRACE LOGIC
	ST	R15,TRSAVE+4	:SAVE A REGISTER
	L	R15,TRPSD+4	:GET ADDRESS WE JUST JUMPED TO
	ST	R15,TRSAVE
	L	R15,TRSAVE+4	:RESTORE REGISTER
	UPSW	TRPSD		:INSTRUCTION TO RE-ENABLE TRACE
	HS	40		:ADDITIONAL AREA TO PATCH IN REQUIRED TEST

:	TRANSFER TO HERE TO TURN ON TRACE INITIALLY
TRBGN	UPSW	IPSD		:THIS WILL TAKE US TO "ENTRY" WITH TRACE ON
IPSD	WC	1000,ENTRY	:TRACE BIT ON, GO TO "ENTRY"
	EM

	SUBTTL	ISIS Ring Handling Routines	- FRING.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:	DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	 HS	0;	ELSE;LOOK	 HS	0;	EI
	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2	Y PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
	SUBTTL	Standard Timeout Routine Library	- TIMOUT.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TIMOUT.LIB

:	This package contains the standard timeout routines
:	The following parameters MUST be defined on entry:
:	NTOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	six symbols are declared:
:	IZT	called at initilization, link on R0
:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced:
:		R0 = routine address
:		R1 = current fast-clock time.
:	TORET	routines called by TIMOUT should exit to here
:	TOPUT	any code may call this to place an entry on timeout list:
:		link on R5...R6--R15 preserved
:		R0 = address to transfer to
:		R1 = next time to call routine
:	TOGET	called to delete an entry already on timout list
:		link on R5...R6--R15 preserved
:		R0 = routine address...entry with this address will be deleted
:	TONOW	called to flush an entry, and execute it NOW!
:		link on R5...NO registers preserved! NOW!
:		routine address in R0
:	NOTE...when a routine is called from timeout list, it is removed from list,
:	and must call TOPUT to be called again.
:	ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

	GL	IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
	MO	.,TIMOUT

	SEG	A.DATA		:PLACE IN DATA AREA

  IF	6-.
	BS	6-.		:UNUSED 
  EI
TO9	HS	2		:link for timeout processor
LSIZ	EQ	$A 15		:number of bytes in list entry
TLIST	BS	(NTOUT+1)*LSIZ	:timeout list
:				active list entry = halfword chain pointer
:				word routine address
:				word time of next activiation

:		free list pointer is at TLIST
:		active list chain pointer is at TLIST+2
:	CODE SEGMENT
	SEG	A.CODE

TORET	L	R0,TO9		:TIMEOUT ROUTINES EXIT HERE
:	CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT	LHL	R2,TLIST+2	:GET ACTIVE LIST POINTER
	JER	R0		:EXIT IF NO ACTIVE ENTRIES
	L	R1,FASTC,,	:GET CURRENT CLOCK TIME
	CL	R1,TLIST+6,R2	:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0		:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9		:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2	:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R4,TLIST,R2	:SPLICE INTO HEAD OF FREE CHAIN
	STH	R2,TLIST
	L	R0,TLIST+2,R2
	JR	R0		:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2		:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2	:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2		:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2	:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGBS	TPT1		:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH,,	:FREE LIST EXHAUSTED
	BC	0,0,4*R5,0F	:FLAG--LINK R5, TYPE 15d CRASH
TPT3	STH	R4,TLIST,R3	:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	LHL	R3,TLIST,R4
	STH	R3,TLIST	:SHORTEN FREE LIST
	STH	R2,TLIST,R4	:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4
	ST	R1,TLIST+6,R4
	JR	R5		:STORE ARGUMENTS AND RETURN

TONOW	LIS	R1,2		:SEARCH ACTIVE LIST
TONOW1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TONOW1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	ST	R5,TO9		:SAVE RETURN ADDRESS
	JR	R0		:AND GO TO ROUTINE

TOGET	LIS	R1,2		:SEARCH ACTIVE LIST
TOGET1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TOGET1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	JR	R5		:AND EXIT

IZT	LHI	R1,NTOUT*LSIZ	:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0		:0 TERMINATES LIST
	STH	R2,TLIST+2	:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1	:TERMINATE FREE LIST
	STH	R1,TLIST-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	.-6
	JR	R0
	EM
	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB
        REMARK  %CRASH.LIB    11-15-84 AWT
	REMARK	%THIS VERSION HAS AN OPTION FOR EXTENDED CRASH PROCESSING.

:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the PRODID.
:	Sep. 20, 1982 SCY.
:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID,NCRSAV,CTIME,CRTIME,EXCRSH
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRXREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:	The symbol EXCRSH, if set to 1, allows a JAL to label
:	CRSH.P out of the crash routine for extended crash processing.
:	The link is R5.  EXCRSH is defaulted to 0.
:
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI

  IF	\EXCRSH			:DEFAULT TO NO EXTENDED CRASH HANDLING
  ELSE
EXCRSH	EQ	0
  EI


CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT	HS	1		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HS	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HS	2		:WHERE CRASH OCCURED
CFROM	HS	2    		:WHERE CRASH WAS CALLED FROM
CRXREG	HS	20		:CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
CRREG   EQ      CRAT+CRXREG
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL	HS	1		:FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK
	BC	16	:WATCH FROG TIMER - - TIME OUT

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF          :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRXREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRXREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
	LCS	R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF          :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRXREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
        L       R1,CRAT+CRXREG,R2 :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
ENTRY1	LIS	R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
        LM      R0,CRAT+CRXREG,, :RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
  IF	CRSTOP
  ELSE
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
  EI	CRSTOP
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300
	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRAT+CRSHCT,,
	JAL	R4,PUTCH,,	:HW4 LOW = CRASH COUNT
	LIS	R0,0
	JAL	R4,PUTCH,,	:RESERVED BYTE
	LIS	R0,1
	JAL	R4,PUTCH,,	:REPORT TYPE = 1
	LHL	R0,CRAT+CRASHC,,
	JAL	R4,PUTCH,,	:HW3 HIGH = CRASH CODE
	LHI	R0,PRODID
	JAL	R4,PUTCH,,	:HW2 LOW IS PRODUCT ID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN


PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1      :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1
        LM      R6,CRAT+CRTLEN/2,R1
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
         
	EM



: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET.  The recipient, by receiving this program  **
: **  listing, agrees that neither this listing nor the informa-  **
: **  tion disclosed herein nor any part thereof shall be repro-  **
: **  duced or transferred to other documents or used or dis-     **
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by TYMNET.     **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 1.00		 Release Date : 09/12/86  **
: **                                                              **
: **  File Name          : PTCH01.R00                             **
: **                                                              **
: **  File Description   : ISIS PATCH.LIB                         **
: **                                                              **
: **  File Abstract      : initial release                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	PATCH AREA DEFINITIONS			PTCH01.R00
:**********************************************************************
	RA	0		:	PATCH.LIB

:	This library defines symbols, macros and areas used for patching
:	released code and keeping a history of patches in Engine memory.

:	A file containing the actual patches to the code should be
:	assembled as the last file before saving the NIB file.

:	Patches are added by ORGing to the area to patch,
:	zeroing memory for the length of the patch, writing new
:	code starting at that area.
:	Three macros have been defined to do this.
:	Each patch should start with a PATCH macro and if the
:	patch is for more than one area it should be continued
:	with a CONPATCH macro.  The patch should be ended with
:	an ENDPATCH macro.
:
:	Using these macros will cause the patch number, author
:	area patched, and reason for patch to be output during assembly.
:	Also, a history table starting at PATHIS will be created with
:	16 (10hex) byte entries.
:	Each entry will contain the date and time of patch and the author.
:	Also, the ?VERNO DDT command will indicate that patches are
:	installed by reporting a version biased by 100 octal.
:	For example, if the version is 1.13, ?VERNO will report 101.13.
:
:	If a patch must be temporarily added by hand, the
:	history area and the version (cell VERREV) should be updated.
:
:	The following symbols may be defined before assemply of PATCH.LIB.
:	If not defined they will take the default listed.
:
:	VERSION release version number, will be ORed with octal 100.
:		default: 00
:	VERREV	area in seg 0E which contains a one byte version and
:		a one byte revision.  Defined by FINISH.LIB.
:		default: none, symbol must be defined.
:	A.ERR	defines segment to use for patch history area
:		default: seg 0
:	PATHIS	defines the start of the patch history area,
:		each entry will be 16 bytes as follows,
:		19yy/mmdd/hhmm/uname(10 chars 0 filled)
:		where 19yy, mmdd and hhmm are in bcd (4 bits per decimal
:		digit) and uname is in ASCII.
:		default: an area will be defined by this library
:	PHSIZE defines the length in bytes of the PATHIS area.
:		default: 140 hex
:	PATCH0	defines the start of a Segment 0 patch area.
:		default: an area will be defined by this library
:	P0SIZE defines the length in bytes of the PATCH0 area.
:		default: 200 hex
:	PATCH1	defines the start of a code segment  patch area.
:		default: an area will be defined by this library
:	P1SIZE defines the length in bytes of the PATCH1 area.
:		default: 400 hex
:	SEGn,SnSIZE	Must be defined for the area being patched when
:		the patch is made.
:
:	The following symbols are used by the patch macros.
:	They may be read by, but should not be modified by, a patch.
:
:	PAHPTR	pointer to the next available entry in PATHIS
:	PA0PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH0 area.  It starts out
:		equal to PATCH0 and is moved up after each patch in
:		the PATCH0 area.  Use of the symbol assumes that all
:		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
:	PA1PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH1 area.  It starts out
:		equal to PATCH1 and is moved up after each patch in
:		the PATCH1 area.  Use of the symbol assumes that all
:		patches from PATCH1 to PATCH1+P0SIZE will be done in order.
:	QPATS	current patch segment number
:	QPATB	starting address of current patch
:	QPATL	length of current patch
:	QPATA	0 IF PATCH IS IN PATCH0 AREA, 1 IF IN PATCH1, ELSE -1
:	PATACT	> 0 if when a patch is active.



::	PATCH(yymmdd,hhmm,uname,fba,lba1,len)	grab a patch area
:
:		yymmdd	Date patch written, if patch is modified in ANY
:		way this must be updated.
:		hhmm	Time patch written, current Cupertino time.
:		If patch is modified this also must be updated.
:		uname	ONTYME username of person who authored patch.
:		Personal name, not NETMID or NET3 or such.
:	fba	adress of start of patch
:	lba1	address of next byte after end of patch
:	len	length (default hex) of patch in bytes if lba1 is missing
:
:	CONPATCH(fba,lba1,len)	continue a patch in a new area
:		Similar to PATCH but moves to a new area, must be
:		preceeded by a PATCH statement.
:
:	ENDPATCH(comment)	End a PATCH started with PATCH call.
:
:		comment	Description of patch to be output during
:			assembly.  Commas should be preceeded by `.
:
:	Example:
:	:	PATCH TO FIX HDLC ROOM CHECKING ROUTINE
:	  IF	HDLC&(LAPB!LAP)
:	PATCH(811009,1422,FRED,XROOM,,2)
:		LIS	R4,7
:	ENDPATCH(fix hdlc room checking routine)
:	  EI
:
:	:	PATCH TO FIX TRANSMITER BUG
:	PATCH(811009,1630,DDM,XSEND,XSE010)
:	  IF	FINACT	:IF INTERFRAME FILL TIMER ENABLED
:		J	PA1PTR
:	  EI
:	PATRTN	LR	R6,RSIO
:		AHI	R6,OUTSCT,RSIP
:
:	CONPATCH(PA1PTR,,0C)
:		SBT	RL,FRMTMT,,	:INDICATE FRAME TRANSMITTED
:		JNR	R7		:IF ALREADY TRANSMITTED
:		J	PATRTN		:RETURN TO PATCHED AREA
:	ENDPATCH(fix transmitter bug)

	GL	VERSIO,VERREV,A.ERR,PATHIS,PHSIZE,PATCH0,P0SIZE,PATCH1,P1SIZE
	GL	PAHPTR,PA0PTR,PA1PTR,QPATS,QPATB,QPATL,QPATA,PATACT

:	FIRST DEFINE SOME MACROS
	GL	.35.
.35.	EQ	$A 35
	KILL	.NE.
.NE.	MACRO(P1,P2)[(((P1)-(P2))!((P2)-(P1)))^-.35.]
	KILL	.GT.
.GT.	MACRO(P1,P2)[((P2)-(P1))^-.35.]

:	NEXT DEFINE SOME DEFAULTS
  IF	1-\A.ERR
A.ERR	EQ	0
  EI
  IF	1-\PHSIZE
PHSIZE	EQ	140
  ELSE
PHSIZE	EQ	(PHSIZE+0F)/10*10
  EI
  IF	1-\P0SIZE
P0SIZE	EQ	200
  EI
  IF	1-\P1SIZE
P1SIZE	EQ	400
  EI
  IF	1-\PATHIS
	SEG	A.ERR
	WS	0
PATHIS	HS	PHSIZE/2
  EI
  IF	1-\PATCH0
	SEG	0
PATCH0	HS	P0SIZE/2
  EI
  IF	1-\PATCH1
	SEG	A.CODE
PATCH1	HS	P1SIZE/2
  EI

PAHPTR	EQ	PATHIS	:INIT HISTORY POINTER TO START OF AREA
PA0PTR	EQ	PATCH0	:INIT PTR TO START OF AREA
PA1PTR	EQ	PATCH1	:INIT PTR TO START OF AREA
PATACT	EQ	0	:FLAG NO PATCH ACTIVE
QPATA	EQ	-1	:CLEAR PATCH AREA FLAG
QPATS	EQ	-1
QPATB	EQ	-1
QPATL	EQ	-1

	KILL	PATCH
PATCH	macro(day,tim,usr,fba,lba1,len)[
  IF	\VERSION
VERSION EQ	VERSION!$8100
  ELSE
VERSION EQ	$8100
  EI
	SEG	0E
	ORG	VERREV
	BC	VERSION
	SEG	A.CODE
  IF	PATACT
 REMARK %>>>> ERROR **** Previous PATCH not ended with ENDPATCH <<<<%
  ELSE
PATACT	EQ	1
  EI
 REMARK %%PATCH added on day at tim by usr`.
	SEG	A.ERR
	ORG	PAHPTR
   IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
   EI
	WC	$0 day!19000000
	HC	$0 tim
Q	AC	\usr\
Q1	HS
	ORG	Q+$a10	:skip to next history area
PAHPTR	HS
  IF	Q1-.	:IF UNAME>10 CHARARACTERS, CLEAR OVERFLOW
	RE	Q1-.
	BC	0
	ER
  EI

QPATS	EQ	((fba)&$00FF0000)^-$010
QPATB	EQ	fba
QPATC	EQ	lba1
  IF	lba1 0
QPATL	EQ	(lba1)-(fba)
  ELSE
QPATL	EQ	len 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of patch end < address of patch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK %	Starts at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK %     Starts at fba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI

	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	(.+1)-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK  overflow <<<<%
  EI
	ORG	QPATB

::	CONPAT(fba,lba1,len)	CONTINUE A PATCH
	KILL	CONPAT
CONPAT	MACRO(cfba,clba1,clen)[
PATACT	EQ	PATACT+1
  IF	2-PATACT
REMARK %>>>> ERROR **** CONPAT not preceded by a PATCH <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
QPATS	EQ	((cfba)&$00FF0000)^-$010
QPATB	EQ	cfba
QPATC	EQ	clba1
  IF	clba1 0
QPATL	EQ	(clba1)-(cfba)
  ELSE
QPATL	EQ	clen 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of conpatch end < address of conpatch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK 	Continues at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK 	Continues at cfba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI
	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	.-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK overflow <<<<$
  EI
	ORG	QPATB

::	ENDPATCH(com)	End a patch - does error checking, outputs comment
	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD CONPATCH(cfba,clba1,clen) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1````c2````c3````c4````c5 >>>
]
]

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD PATCH(day,tim,usr,fba,lba1,len) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1``c2``c3``c4``c5 >>>
]
]
        SUBTTL UTIL ... General macros

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 21 NOV 85|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        MO      .,UTIL                  :Delimit module
:
: This module contains the following general purpose macros:
:
:       PUSH - Push the contents of a register on the stack
:       POP - Remove the contents of a register from the stack
:       CALL - Call a subroutine
:       RETURN - Return from a subroutine
:       RSTART - Start a global routine
:       SSTART - Start a local subroutine
:       CRUNCH - Crash the slot
:       TRACK - Track the progress of the slot
:       SUS - Suspend a DCB
:       OPEN - Open output channel
:       WRITEB - Write byte to output channel
:       WRITES - Write string to output channel
:       CLOSE - Close output channel
:       READ - Read input channel
:
        SUBTTL UTIL ... General macro PUSH
:
: ----------------------------------------------------------------------
:
: Macro         PUSH
:
: Description   Push one to eight registers onto to stack
:
: Parameters    RG1 - RG8 Registers to be pushed
:
: ----------------------------------------------------------------------
:
PUSH    MACRO(RG1,RG2,RG3,RG4,RG5,RG6,RG7,RG8) [
        IF 1-\.`RG1                             : Operand given?
        ST      RG1,0,R13                       : Yes, store in stack
        AIS     R13,4                           : Stack increment
        EI
        IF 1-\.`RG2                             
        ST      RG2,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG3                             
        ST      RG3,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG4                             
        ST      RG4,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG5                             
        ST      RG5,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG6                             
        ST      RG6,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG7                             
        ST      RG7,0,R13                       
        AIS     R13,4                           
        EI
        IF 1-\.`RG8                             
        ST      RG8,0,R13                       
        AIS     R13,4                           
        EI
        IF      TSSTCK
        CI      R13,DSTCKP,R12          :Have we overflowed stack
        JLFS    .+0C                    :Jump if not
        CRUNCH(CRSTOV)                  :Crash stack overflow
        EI
]
        SUBTTL UTIL ... General macro POP
:
: ----------------------------------------------------------------------
:
: Macro         POP
:
: Description   Pop one to eight registers from stack
:
: Parameters    RG1 - RG8 Registers to be popped
:
: ----------------------------------------------------------------------
:
POP     MACRO(RG1,RG2,RG3,RG4,RG5,RG6,RG7,RG8) [
        IF 1-\.`RG1                             : Operand given?
        SIS     R13,4                           : Yes, adjust stack pointer
        L       RG1,0,R13                       : Pull off stack        
        EI
        IF 1-\.`RG2                             
        SIS     R13,4                           
        L       RG2,0,R13                       
        EI
        IF 1-\.`RG3                             
        SIS     R13,4                           
        L       RG3,0,R13                       
        EI
        IF 1-\.`RG4                             
        SIS     R13,4                           
        L       RG4,0,R13                       
        EI
        IF 1-\.`RG5                             
        SIS     R13,4                           
        L       RG5,0,R13                       
        EI
        IF 1-\.`RG6                             
        SIS     R13,4                           
        L       RG6,0,R13                       
        EI
        IF 1-\.`RG7                             
        SIS     R13,4                           
        L       RG7,0,R13                       
        EI
        IF 1-\.`RG8                             
        SIS     R13,4                           
        L       RG8,0,R13                       
        EI
        IF TSSTCK
        CI      R13,DSTCK,R12                   :Has stack underflowed
        JGEFS   .+0C                            :Jump if not
        CRUNCH(CRSTUV)                          :Crash stack underfowed
        EI
]
        SUBTTL UTIL ... General macro CALL
:
: ----------------------------------------------------------------------
:
: Macro         CALL
:
: Description   Call a subroutine using R1 as link register
:
: Parameters    RTNAME - Name of routine to be called
:
: ----------------------------------------------------------------------
:
CALL    MACRO(RTNAME) [
        JAL      R1,RTNAME,,
]


        SUBTTL UTIL ... General macro RETURN
:
: ----------------------------------------------------------------------
:
: Macro         RETURN
:
: Description   Pop link register and return
:
: Parameters    SKIP - If present return link plus 4
:
: ----------------------------------------------------------------------
:
RETURN  MACRO (SKIP) [
        POP(R1)
        IF      1-\.`SKIP
        AIS     R1,4
        EI
        JR      R1
]


        SUBTTL UTIL ... General macros RSTART and SSTART
:
: ----------------------------------------------------------------------
:
: Macro         RSTART
:
: Description   Begin a global routine. Make routine name global and push
:               link register on stack
:
: Parameters    RTNAME - Name of subroutine
:
: ----------------------------------------------------------------------
:
RSTART  MACRO(RTNAME) [
        GL      RTNAME
RTNAME  EQ      .
        PUSH(R1)
	PAUSE(RTNAME)
        TRACK(RTNAME)
]
:
: ----------------------------------------------------------------------
:
: Macro         SSTART
:
: Description   Begin a local subroutine. Push link register on stack
:
: Parameters    RTNAME - Name of subroutine
:
: ----------------------------------------------------------------------
:
SSTART  MACRO(RTNAME) [
RTNAME  EQ      .
        PUSH(R1)
	PAUSE(RTNAME)
]

        SUBTTL UTIL ... General macro CRUNCH
:
: ----------------------------------------------------------------------
:
: Macro         CRUNCH 
:
: Description   Crash slot using CRASH routine in CRASH.LIB
:
: Parameters    Y - Crash code
:
: ----------------------------------------------------------------------
:
CRUNCH  MACRO(Y) [
        JAL     R10,CRASH,,
        HC      0
        BC      4*R1,Y
]
:
: List of crash code symbols
:
: 00 - FF Tymnet interface errors
        DEFGEQ(CRIPOM,20)                       :Illegal port 0 message
        DEFGEQ(CRNAR,21)                        :No activation routine in DCB
        DEFGEQ(CRINVN,22)                       :Invalid needle received
        DEFGEQ(CRINVM,23)                       :Invalid message received
        DEFGEQ(CRINVP,24)                       :Invalid pseudo needle
: E0 - EF Internal management errors
        DEFGEQ(CRNOBF,0E0)                      :No buffers left
        DEFGEQ(CROBAA,0E1)                      :Output buffer open twice
        DEFGEQ(CROBNO,0E2)                      :Output buffer not open
        DEFGEQ(CRSTOV,0E3)                      :Stack overflowed
        DEFGEQ(CRSTUV,0E4)                      :Stack underflowed
        DEFGEQ(CRIPBF,0E5)                      :CLOSEI to non-existant port
        DEFGEQ(CRIKEY,0E6)                      :Invalid Icl control key
        DEFGEQ(CRINVD,0E7)                      :Invalid data to INOUT
: F0 - FF Miscellaneous codes for testing
        DEFGEQ(CRNOCO,0F0)                      :Code has not been written yet
:
	SUBTTL	PAUSE
:!!!
	IF TSPAUS
	GL	PSIDX
PSIDX	EQ	0
	EI
:
PAUSE	MACRO(STNG)[
	IF	TSPAUS
:
	SEG	A.BPTS
	ORG	BP.SNT
Q	SC	/STNG/
BP.SNT	EQ	.
	ORG	BP.TNT
	WC	Q
BP.TNT	EQ	.
	ORG	BP.SNT
:
	SEG	A.CODE
PSIDX	EQ	PSIDX+1
	ST	R0,TPUSR0
	ST	R1,TPUSR1
	LHI	R0,PSIDX
	JAL	R1,PPAUSE,,
	L	R0,TPUSR0
	L	R1,TPUSR1
	EI


]
	SEG	A.DATA
	GL	TPUSR1,TPUSR0
TPUSR0	WC	0
TPUSR1	WC	0
	SEG	A.CODE
:
	SUBTTL	PAUSE
:!!!!
	DEFGEQ(PPAUSE,.)
	TBT	R0,PRBITS
	JE	PLAB3
	ST	R0,S.R0
	ST	R1,S.R1
	ST	R2,S.R2
	ST	R3,S.R3
	ST 	R4,S.R4
	ST	R5,S.R5
	ST	R6,S.R6
	ST	R7,S.R7
	ST	R8,S.R8
	ST	R9,S.R9
	ST	R10,S.R10
	ST	R11,S.R11
	ST	R12,S.R12
	ST	R13,S.R13
	ST	R14,S.R14
	ST	R15,S.R15
	RBT	R0,PRBITS			: Flag paused
	ST	R0,PCFLAG
:
PLAB1	SVC	FASTD				: Dismiss slot
	L	R0,PCFLAG
	JN	PLAB1
:
	TBT	R0,PTBITS			: Test for reset
	JE	PLAB2
	SBT	R0,PRBITS			: Set for next time round
:
PLAB2	L	R0,S.R0
	L	R1,S.R1
	L	R2,S.R2
	L	R3,S.R3
	L	R4,S.R4
	L	R5,S.R5
	L	R6,S.R6
	L	R7,S.R7
	L	R8,S.R8
	L	R9,S.R9
	L	R10,S.R10
	L	R11,S.R11
	L	R12,S.R12
	L	R13,S.R13
	L	R14,S.R14
	L	R15,S.R15
PLAB3	JR	R1
:
:
	SEG	A.DATA
:
	DEFGEQ(PRBITS,.)
	WC	0,0,0,0,0,0,0,0
:
	DEFGEQ(PCFLAG,.)
	WC	0
:
	DEFGEQ(PTBITS,.)
	WC	0,0,0,0,0,0,0,0
:
	DEFGEQ(S.R0,.)
	WC	0
S.R1	WC	0
S.R2	WC	0
S.R3	WC	0
S.R4	WC	0
S.R5	WC	0
S.R6	WC	0
S.R7	WC	0
S.R8	WC	0
S.R9	WC	0
S.R10	WC	0
S.R11	WC	0
S.R12	WC	0
S.R13	WC	0
S.R14	WC	0
S.R15	WC	0

:
	SEG	A.CODE
        SUBTTL UTIL ... General macro TRACK
:
: ----------------------------------------------------------------------
:
: Macro         TRACK
:
: Description   Track progress of CMB. The address of the track call and
:               the contents of register R12 (normally DCB address) are
:               stored in a circular buffer.
:
: Parameters    ACTID - Identity of routine
:
: ----------------------------------------------------------------------
:
        GL      TRAK,TRAKR1,TRAKBP      :Make variables used by macro global
TRACK   MACRO(ACTID) [
        IF      TSTRAK
        ST      R1,TRAKR1
        JAL     R1,TRAK,,
        L       R1,TRAKR1
        EI
]
:
        SEG     A.DATA
TBSIZ   EQ      200                             :64 entries
TRAKR1  HS      2                               :Save register 1 area
TRAKR2  HS      2                               :Save register 2 area
TRAKBP  WC      0                               :Used to access buffer
        SEG     A.TRAC
TRAKB   BS      TBSIZ                           :Track buffer
        SEG     A.CODE
TRAK    ST      R2,TRAKR2                       :Save register 2
        L       R2,TRAKBP                       :Current buffer position
        ST      R1,TRAKB,R2,                    :Save link address in trace
        ST      R12,TRAKB+4,R2,                 :Save DCB address
        AIS     R2,8                            :Move down buffer
        CI      R2,TBSIZ
        JLFS    TRAK20                          :Jump if wrap not required
        LIS     R2,0
TRAK20  ST      R2,TRAKBP                       :Save new pointer
        L       R2,TRAKR2                       :Restore R2
        JR      R1                              :Return
        SUBTTL UTIL ... General macro SUS
:
: ----------------------------------------------------------------------
:
: Macro         SUS
:
: Description   Suspend a DCB activity. Save suspension type in DSUSP.
:
: Parameters    STYPE - Type of suspension 
:
: ----------------------------------------------------------------------
:
        GL      SUSPND                  :Ensure routine can be accessed
SUS     MACRO(STYPE) [
        PUSH(R1)
        LHI     R1,STYPE
        STH     R1,DSUSP,R12
        JAL     R1,SUSPND,,
        POP(R1)
]
:
: Values for STYPE
:
        DEFGEQ(SUSVD,0)                         :Voluntary dismissal
        DEFGEQ(SUSBP,1)                         :Backpressured
        DEFGEQ(SUSIP,2)                         :Awaiting input
        DEFGEQ(SUSPN,3)                         :Awaiting pseudo needle
        SUBTTL UTIL ... General Input / Output macros
:
: Input / output device types
:
        DEFGEQ(NET,0)
	DEFGEQ(IPBTRM,1)			:General ipb for user
	DEFGEQ(IPBHST,2)			:General ipb for host
:
: ----------------------------------------------------------------------
:
: Macro         READ
:
: Description   Read input. 
:                       NET - READN
:                       IPBCRD - READIA
:                       IPBPTR - READIA
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
READ    MACRO(TYPE) [
        IF      TYPE
        CALL(READIA)
        ELSE
        CALL(READN)
        EI
]
:
: ----------------------------------------------------------------------
:
: Macro         OPEN
:
: Description   Open output channel.
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
OPEN    MACRO(TYPE) [
        IF      TYPE 
        CALL(OPENI)
        ELSE
        CALL(OPENN)
        EI
]
:
: ----------------------------------------------------------------------
:
: Macro         WRITEB
:
: Description   Write byte to output channel.
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
WRITEB  MACRO(TYPE) [
        IF      TYPE
        CALL(WRITBI)
        ELSE
        CALL(WRITBN)
        EI
]
:
: ----------------------------------------------------------------------
:
: Macro         WRITES
:
: Description   Write string to output channel.
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
WRITES  MACRO(TYPE) [
        IF      TYPE
        CALL(WRITSI)
        ELSE
        CALL(WRITSN)
        EI
]
:
: ----------------------------------------------------------------------
:
: Macro         CLOSE
:
: Description   Close output channel.
:
: Parameters    TYPE - Channel type (See above)
:
: ----------------------------------------------------------------------
:
CLOSE   MACRO(TYPE) [
        IF      TYPE 
        PUSH(R5)
        LHI     R5,TYPE
        CALL(CLOSEI)
        POP(R5)
        ELSE
        CALL(CLOSEN)
        EI
]
:
        EM

	SUBTTL CBDEF ...  Control block definitions and access routines

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 OCT 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        GL      DATACT,ACTCIP           :Forward addressed global
        MO      .,CBDEF
:
: This module contains the definitions of the following  control blocks,
: bit arrays and buffers:
:
:       CCB - channel control block
:       DCB - device control block
:       PORTAB - DCB index table
:       CDB - card recode buffer
:       IOB - I/O buffer
:       RUNREQ - Run DCB process request array
:       ASCICL - ASCII to ICL translaaation table
:       ICLASC - ICL to ASCII translaaation table
:
: It also contains the following routines to initialise and access them:
:
:       IZCMT - Initialise control blocks and buffers
:       GETDCB - Get a DCB from free chain
:       GETCCB - Get a CCB from free chain
:       GETCDB - Get a card buffer from free chain
:       GETIOB - Get a IO buffer from the free chain
:       PUTDCB  - Return a DCB to free chain
:       PUTCCB  - Return a CCB to free chain
:       PUTSCB - Return a card record buffer to free chain
:       PUTIOB - Return IO buffer to free chain
:       RETBUF - Return all buffers to free chain
:
: There are no macros unique to this module.
:
: ----------------------------------------------------------------------
:
: Macro         CBHDEF
:
: Description   Create HW entries in control blocks and global the entries
:
: Parameters    SYM - Name of entry
:               HL - Size of entry in halfwords
:
CBHDEF  MACRO(SYM,HL) [
        GL      SYM                             :Make symbol global
SYM     HS      HL
]
:
: ----------------------------------------------------------------------
:
: Macro         CBBDEF
:
: Description   Create BS entries in control blocks and global the entries
:
: Parameters    SYM1 - Name of entry
:               BL - Size of entry in bytes
:
CBBDEF  MACRO(SYM1,BL) [
        GL      SYM1                    :Make symbol global
SYM1    BS      BL
]
:
: Reset the origin and save old one so that all references are from zero
:
        SEG     0
OLDORG  EQ      .                       :Save origin
:
:       The device control block
:
: The DCB contains information related to an ISI port. At initialisation
: time a DCB is allocated to every possible port number indexed by
: PORTAB. When a needle is received on a port, it's DCB is then linked
: to channel control block.
:
        ORG     0
        CBHDEF(DDCB,0)                  :Start of DCB
        CBHDEF(DDACT,1)                 :Data activation routine address
        CBHDEF(DCACT,1)                 :Control activation table address
        CBHDEF(DCBNO,1)                 :DCB number
        CBHDEF(DPORT,1)                 :Port number
        CBHDEF(DTYPE,1)                 :DCB type
        CBHDEF(DCCB,2)                  :Link to CCB
        CBHDEF(DUSR,2)                  :User routine address
        CBHDEF(DSUSP,1)                 :Reason DCB suspended
        CBHDEF(DNETIP,4)                :Network input buffer pointers
        CBHDEF(DNETOP,4)                :Network output buffer pointers
        CBHDEF(DIPBIA,4)                :IPB input buffer A pointers
        CBHDEF(DIPBOP,4)                :IPB output buffer pointers
        CBHDEF(DXLIM,1)                 :Transmit limit
        CBHDEF(DRXCNT,1)                :Receive coCnt
	CBHDEF(DCRBBF,2)                :Card buffer pointer
        CBHDEF(DMODE,1)                 :Current mode of operation
        CBHDEF(DLINE,1)                 :ICL HIF line address
        CBHDEF(DGROUP,1)                :ICL HIF group address
        CBHDEF(DSUBSD,1)                :ICL HIF subsiduary address
        CBHDEF(DBITS,1)                 :Control bits
        CBHDEF(DSTCK,60)                :Stack
        CBHDEF(DSTCKP,2)                :Stack pointer
        CBHDEF(DCBSIZ,0)                :Size of DCB
:
: Tell FRNTND where activation pointers are
:
        DEFGEQ(ACTIVD,DDACT)            :Data activation routine offset
        DEFGEQ(ACTIVC,DCACT)            :Control activation table offset
:
: DTYPE entry values
:
        DEFGEQ(DTFREE,0)                :Inactive port
	DEFGEQ(DTTPRT,1)		:Terminal Line Printer port
	DEFGEQ(DTTCRD,2)		:Terminal Card reader port
        DEFGEQ(DTHPRT,3)                :Host Line Printer port
        DEFGEQ(DTHCRD,4)                :Host Card Reader port
	DEFGEQ(DTTOPR,5)		:Terminal Console port
	DEFGEQ(DTHOPR,6)		:Host Console port
:
: DMODE entry values
:
        DEFGEQ(DMINAC,0)                :Inactive port
        DEFGEQ(DMLGST,1)                :Terminal logon start code
        DEFGEQ(DMTTYP,2)                :Determining terminal type
        DEFGEQ(DMTICL,3)                :Terminal in ICL mode
:
: Control bits in DBITS 
:
        DEFGEQ(D.PRT,1)                 :Set if this DCB is for printer
	DEFGEQ(D.ACTV,2)
	DEFGEQ(D.DACT,3)
	DEFGEQ(D.DACP,4)
	DEFGEQ(D.EOJ,5)
	DEFGEQ(D.TOKN,6)		:Set if input inhibited for PRTDCB
	DEFGEQ(D.ACKP,7)
        DEFGEQ(D.OUTN,8)                :Set if network output 'OPEN'
        DEFGEQ(D.OUTI,9)                :Set if IPB output 'OPEN'
	DEFGEQ(D.NAKP,$A 10)
	DEFGEQ(D.OPP,$A 11)
	DEFGEQ(D.NACT,$A 12)
:
:       The channel control block
:
: The CCB is the basic control block of the CMB. It is created when a
: user logs into CMB and links together all the resources required to
: service that user.
:
        ORG     0
        CBHDEF(CLINK,2)                 :Link to free CCB chain
        CBHDEF(CTDCB,2)                 :Link to terminal DCB
        CBHDEF(CHDCB,2)                 :Link to host DCB
        CBHDEF(CPDCB,2)                 :Link to printer DCB
        CBHDEF(CUPROF,2)                :Pointer to user profile table
        CBHDEF(CCRBBF,2)                :Pointer to card buffer
        CBHDEF(CBITS,2)                 :Control bits
        CBHDEF(CUNAME,4)                :First 8 bytes of terminal username
        CBHDEF(CLSTRS,1)                :Login entry offset in LSTRS
:
        CBHDEF(CVSTAT,1)                :Video status
        CBHDEF(CVQUAL,2)                :Continuation address for ALP code
:
        CBHDEF(CPSTAT,1)                :Printer status
        CBHDEF(CPQUAL,2)                :Continuation address for ALP code
        CBHDEF(CPCOL,1)                 :Current column on line
        CBHDEF(CPLINE,1)                :Current line on form
        CBHDEF(CPFORM,1)                :Current form length
        CBHDEF(CCBSIZ,0)                :Size of CCB
:
: Control bits in CBITS
:
	DEFGEQ(C.LOGN,1)		:Set while in the process of logging on
	DEFGEQ(C.TMSG,2)		:Set if processing control message
	DEFGEQ(C.PQUA,3)                :Set if printer ALP qualifier required
        DEFGEQ(C.VALP,4)                :Set if processing video data ALP 
        DEFGEQ(C.PALP,5)                :Set if processing printer data ALP
        DEFGEQ(C.PDSR,6)                :Set if waiting response to DSR
        DEFGEQ(C.PAUT,7)                :Set if printer in AUTO mode
        DEFGEQ(C.PTRM,8)                :Set if printer in TERMINAL HOLD mode
        DEFGEQ(C.PDAT,9)                :Set if printer ALP awaiting processing
	DEFGEQ(C.AKSP,0A)
	DEFGEQ(C.RIOP,0B)
	DEFGEQ(C.DC3B,0C)
:
:
: Bit settings in CPSTAT, printer status flag
:
        DEFGEQ(PS.ALL,1)                :Set if printer allocated
        DEFGEQ(PS.IOP,2)                :Set if printer inoperable
        DEFGEQ(PS.HLD,3)                :Set if printer on hold
        DEFGEQ(PS.WDA,4)                :Set if printer waiting de-allocation
        DEFGEQ(PS.CT1,5)                :Set if status to be sent at category 1
        DEFGEQ(PS.ROC,6)                :Set if report output complete awaited
: The following bits map onto bits 1 - 6 of the status report byte
	DEFGEQ(PS.IOS,7)
        DEFGEQ(PS.ERR,0A)               :Data lost if set
        DEFGEQ(PS.WRN,0B)               :Warning if set
        DEFGEQ(PS.BNA,0C)               :Buffer not available if set
        DEFGEQ(PS.NOP,0F)               :Set if printer not operable
:
:       The Card record buffer
:
: This block contains an ICL card image together with any information
: required to output that image to the users terminal
:
        ORG     0
	DEFGEQ(CRBSIZ,$A 248)
:
        CBHDEF(CRBLNK,2)                :Link to chain of free buffers
        CBHDEF(CRBBUF,CRBSIZ/2)         :Card Record buffer
:
:       The I/O block
: This is the basic input/output block used to buffer data to and from
: a DCB activity
:
        ORG     0
        CBHDEF(BLINK,2)                 :Link to chain of free buffers
        CBBDEF(BFILL,1)                 :Fill offset
        CBBDEF(BEMPTY,1)                :Empty offset
        CBBDEF(BDATA,9D)                :Space for data 
        CBHDEF(BSIZE,0)                 :Size of I/O buffer
:
:       The User Profile Table
:
: A list of valid users of the system, the number of the menu of logons
: for this user and the terminal type. Table is based at UPFLST.
:
        ORG     0
        CBBDEF(UPFUSR,8)                :8 character username
        CBHDEF(UPFMNU,1)                :Menu number for this user
        CBHDEF(UPFDEV,1)                :Device type for this user
	CBHDEF(UPFDC4,1)		:Mainframe type for this user
	CBHDEF(UPFCMP,1)		:Compression code
        CBHDEF(UPFSIZ,0)                :Size of UPF table
 :
: Restore origin
:
        ORG     OLDORG
        SEG     A.DATA
:
: Define bit map control arrays
:
        DEFGEQ(BMAPSZ,((MAXPRT/10)+1)*2) :Bit map arrays are BMAPSZ HW size
:
: Array RUNREQ - DCB waiting to be run.
:
        CBHDEF(RUNREQ,BMAPSZ/2)
:
: Pointers to access control blocks
:
	GL	FREIOB,CHNCNT
        DEFGEQ(PORTAB,.)
        WS      NPORT                   :Pointer to DCBs required by FRNTND
FREDCB  WS      4                       :Head of free DCB chain
FRECCB  WS      4                       :Head of free CCB chain
FRECRB  WS      4                       :Head of free card record buffer chain
FREIOB  WS      4                       :Head of free I/O buffer chain
: Layout of head of chain
        DEFGEQ(CHNFWD,0)                :Forward pointer in chains
        DEFGEQ(CHNBWD,CHNFWD+4)         :Backward pointer in chains
CHNCNT  EQ      CHNBWD+4                :Free count
CHNMIN  EQ      CHNCNT+2                :Minimum count
        SEG     A.CBLKS
        CBBDEF(DCBLKS,DCBSIZ*NPORT)     :Storage area for DCBs
CCBLKS  BS      CCBSIZ*NCCB             :Storage area for CCBs
CRBLKS  BS      CRBSIZ*NPORT            :Storage area for card buffers
IOBLKS  BS      BSIZE*NIOB              :Storage area for I/O buffers
:
: ASCII to ICL code translation table. This can be modified by the user
: macro CHRMAP.
:
        SEG     A.DATA
        DEFGEQ(ASCICL,.)
        BC      00,01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F
        BC      10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F
        BC      20,21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F
        BC      30,31,32,33,34,35,36,37,38,39,3A,3B,3C,3D,3E,3F
        BC      40,41,42,43,44,45,46,47,48,49,4A,4B,4C,4D,4E,4F
        BC      50,51,52,53,54,55,56,57,58,59,5A,5B,5C,5D,5E,5F
        BC      60,61,62,63,64,65,66,67,68,69,6A,6B,6C,6D,6E,6F
        BC      70,71,72,73,74,75,76,77,78,79,7A,7B,7C,7D,7E,7F
:
: ICL to ASCII code translation table. This can be modified by the user
: macro CHRMAP.
:
        SEG     A.DATA
        DEFGEQ(ICLASC,.)
        BC      00,01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F
        BC      10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F
        BC      20,21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F
        BC      30,31,32,33,34,35,36,37,38,39,3A,3B,3C,3D,3E,3F
        BC      40,41,42,43,44,45,46,47,48,49,4A,4B,4C,4D,4E,4F
        BC      50,51,52,53,54,55,56,57,58,59,5A,5B,5C,5D,5E,5F
        BC      60,61,62,63,64,65,66,67,68,69,6A,6B,6C,6D,6E,6F
        BC      70,71,72,73,74,75,76,77,78,79,7A,7B,7C,7D,7E,7F
        SUBTTL IZCMT routine ... Initialise control blocks
:
: Routine name  IZCMT
:
: Function      To set up PORTAB the DCB addressing table used by FRNTND.
:               Also initialises the DCB for inactive ports and creates
:               the free CCB, I/O and card record buffer chains
:
: Called by     EXEC
:
: On entry      Link register R1
:
: On exit       Registers are not preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SEG     A.CODE
:
: Initialise PORTAB and DCBs
:
        DEFGEQ(IZCMT,.)
        LA      R12,DCBLKS,,                    :Create inactive DCB
        LIS     R14,0
        STH     R14,DPORT,R12                   :Put port no. in DCB
        STH     R14,DCBNO,R12                   :DCB number 0
        LIS     R7,DTFREE
        STH     R7,DTYPE,R12                    :Make DCB type inactive
        LA      R7,DATACT
        STH     R7,DDACT,R12                    :Set data activation offset
        LA      R7,ACTCIP                       :Set control activation offset
        STH     R7,DCACT,R12                    : for inactive port
        LHI     R10,DMINAC                      :Set DMODE to inactive
        STH     R10,DMODE,R12
        LA      R10,DSTCK,R12
        ST      R10,DSTCKP,R12                  :Initialise stack
        LIS     R15,0                           :Offset to PORTAB entry
IZDCB   ST      R12,PORTAB,R15                  :Allocate a DCB to a port
        AIS     R15,4                           :Next PORTAB entry
        AIS     R14,1
        CHI     R14,NPORT+1
        JNBS    IZDCB                           :More entries to set up
        AI      R12,DCBSIZ                      :Next DCB
        LR      R11,R12
:
: Initialise DCB free chain
:
        LA      R12,FREDCB                      :Head of free DCB chain
        LHI     R15,NPORT-1                     :No. of DCB's
        STH     R15,CHNCNT,R12                  :Count of free buffers
        STH     R15,CHNMIN,R12                  :Count of minimum buffers
        LIS     R15,1
IZDC20  ST      R11,CHNFWD,R12                  :Point to next block in chain
        LR      R12,R11                         :Move forward
        AI      R11,DCBSIZ      
        STH     R15,DCBNO,R12                   :Put in DCB number
        AIS     R15,1
        CHI     R15,NPORT
        JNBS    IZDC20                          :Jump if not last DCB
        LA      R11,FREDCB                      :Point to head of chain
        ST      R11,CHNFWD,R12                  :Last DCB points to FREDCB
        ST      R12,CHNBWD,R11                  :Point to end of chain
:
: Initialise CCB free chain
:
IZCCB   LHI     R15,NCCB                        :No. of ccb's
        LA      R12,FRECCB                      :Head of free CCB chain
        STH     R15,CHNCNT,R12                  :Count of free buffers
        STH     R15,CHNMIN,R12                  :Count of minimum buffers
        LA      R11,CCBLKS,,                    :Start of CCB area
IZCC20  ST      R11,CHNFWD,R12                  :Point to next block in chain
        LR      R12,R11                         :Move forward
        AI      R11,CCBSIZ      
        SIS     R15,1
        JNBS    IZCC20                          :Jump if not last CCB
        LA      R11,FRECCB                      :Point to head of chain
        ST      R11,CHNFWD,R12                  :Last CCB points to FRECCB
        ST      R12,CHNBWD,R11                  :Point to end of chain
:
: Initialise card record buffer free chain
:
IZSCB   LHI     R15,NCRB                        :No. of card buffers
        LA      R12,FRECRB                      :Head of card buffer chain
        STH     R15,CHNCNT,R12                  :Count of free buffers
        STH     R15,CHNMIN,R12                  :Count of minimum buffers
        LA      R11,CRBLKS,,                    :Start of card buffers
IZSC20  ST      R11,CHNFWD,R12                  :Point to next block in chain
        LR      R12,R11                         :Move forward
        AI      R11,CRBSIZ      
        SIS     R15,1
        JNBS    IZSC20                          :Jump if not last CRB
        LA      R11,FRECRB                      :Point to head of chain
        ST      R11,CHNFWD,R12                  :Point back to start
        ST      R12,CHNBWD,R11                  :Point to last entry
:
: Initialise I/O buffer free chain
:
IZIOB   LHI     R15,NIOB                        :No. of I/O buffers
        LA      R12,FREIOB                      :Head of I/O buffer chain
        STH     R15,CHNCNT,R12                  :Count of free buffers
        STH     R15,CHNMIN,R12                  :Count of minimum buffers
        LA      R11,IOBLKS,,                    :Start of I/O buffers
IZIO20  ST      R11,CHNFWD,R12                  :Point to next block in chain
        LR      R12,R11                         :Move forward
        AI      R11,BSIZE       
        SIS     R15,1
        JNBS    IZIO20                          :Jump if not last IOB
        LA      R11,FREIOB                      :Point to head of chain
        ST      R11,CHNFWD,R12                  :Point back to start
        ST      R12,CHNBWD,R11                  :Point to last entry
:
: Initialise run request bit array
:
        LHI     R12,BMAPSZ-2                    :Size of hw entries
        LIS     R11,0
IZBA20  STH     R11,RUNREQ,R12                  :Set all bits to zero
        SIS     R12,2                           :Next hw
        JGEBS   IZBA20                          :J if not complete
        JR      R1                              :Return to caller
        SUBTTL GETBUF routine ... Get a buffer from free chain
:
: Routine name  DCBGET, GETCCB, GETCRB, GETIOB
:
: Function      Get a DCB, CCB, card or I/O buffer from a free chain.
:               DCBGET rather than GETDCB because GETDCB is a macro used
:               in FRNTND!!
:
: Called by     
:
: On entry      R12 current DCB address
:               Link register R1
:
: On exit       R5 points to buffer. 
:
: Uses          
:
: ---------------------------------------------------------------------
:
: Get a DCB from free chain
:
        RSTART(DCBGET)
        LA      R1,FREDCB,,             :Point to DCB free chain
        J       GETBUF                  :Extract a buffer
:
: Get a CCB from free chain
:
        RSTART(GETCCB)
        LA      R1,FRECCB,,             :Point to CCB free chain
        J       GETBUF                  :Extract a buffer
:
: Get a card buffer from free chain
:
        RSTART(GETCRB)
        LA      R1,FRECRB,,             :Point to CRB free chain
        J       GETBUF                  :Extract a buffer
:
: Get a I/O buffer from free chain
:
        RSTART(GETIOB)
        LA      R1,FREIOB,,             :Point to IOB free chain
:
: Common buffer accessing code
:
GETBUF  PUSH(R2)
        LHL     R5,CHNCNT,R1            :Count of buffers on chain
        JE      GETB90                  :Jump if not empty
        SIS     R5,1                    :Decrement free count
        STH     R5,CHNCNT,R1
        CLH     R5,CHNMIN,R1
        JGFS    GETB40                  :Jump if not new minimum
        STH     R5,CHNMIN,R1            :Save new minimum
GETB40  L       R5,CHNFWD,R1            :Next free block
        L       R2,CHNFWD,R5            :Following block ....
        ST      R2,CHNFWD,R1            :     becomes first in free chain
        C       R5,CHNBWD,R1
        JNFS    GETB60                  :If there are no blocks left
        ST      R1,CHNBWD,R1            :Backward ptr to head of chain
GETB60  POP(R2)
        RETURN
GETB90  CRUNCH(CRNOBF)                  :Crash no buffers
        SUBTTL PUTBUF routine ... Put a buffer on a free chain
:
: Routine name  PUTDCB, PUTCCB, PUTCRB, PUTIOB
:
: Function      Put a DCB, CCB, card or I/O buffer on a free chain
:
: Called by     
:
: On entry      R12 current DCB address
:               R5 Buffer address
:               Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
: Put a DCB on a free chain
:
        RSTART(PUTDCB)
	LIS	R1,0
	STH	R1,DTYPE,R5		:Flag as inactive
        LA      R1,FREDCB,,             :Point to DCB free chain
        J       PUTBUF                  :Extract a buffer
:
: Put a CCB on a free chain
:
        RSTART(PUTCCB)
        LA      R1,FRECCB,,             :Point to CCB free chain
        J       PUTBUF                  :Extract a buffer
:
: Put a card buffer on a free chain
:
        RSTART(PUTCRB)
        LA      R1,FRECRB,,             :Point to CRB free chain
        J       PUTBUF                  :Extract a buffer
:
: Put a I/O buffer on a free chain
:
        RSTART(PUTIOB)
        LA      R1,FREIOB,,             :Point to IOB free chain
:
: Common buffer accessing code
:
PUTBUF  PUSH(R2)
        LHL     R2,CHNCNT,R1            :Count of buffers on chain
        AIS     R2,1                    :Increment free count
        STH     R2,CHNCNT,R1
        L       R2,CHNBWD,R1            :Last block on chain
        ST      R5,CHNBWD,R1            :New block becomes last
        ST      R5,CHNFWD,R2            :Point old last on to new
        ST      R1,CHNFWD,R5            :Point new last to head
        POP(R2)
        RETURN
        SUBTTL RETBUF routine ... Put all buffers on a free chain
:
: Routine name  RETBUF
:
: Function      Return all buffers attached to a DCB to the free chains.
:
: Called by     
:
: On entry      R12 current DCB address
:               Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(RETBUF)
        PUSH(R5,R6,R7)
        LA      R6,DIPBIA,R12           :Return IPB input buffers
        L       R5,CHNFWD,R6
RETB10  CR      R5,R6
        JE      RETB20
        L       R7,CHNFWD,R5
        CALL(PUTIOB)
        LR      R5,R7
        J       RETB10
RETB20  ST      R6,CHNFWD,R6            :Mark chain as empty
        ST      R6,CHNBWD,R6
        LA      R6,DIPBOP,R12           :Return IPB output buffers
        L       R5,CHNFWD,R6
RETB50  CR      R5,R6
        JE      RETB60
        L       R7,CHNFWD,R5
        CALL(PUTIOB)
        LR      R5,R7
        J       RETB50
RETB60  ST      R6,CHNFWD,R6            :Mark chain as empty
        ST      R6,CHNBWD,R6
	LHI	R6,D.OUTI
	RBT	R6,DBITS,R12
        LA      R6,DNETOP,R12           :Return net output buffers
        L       R5,CHNFWD,R6
RETB70  CR      R5,R6
        JE      RETB80
        L       R7,CHNFWD,R5
        CALL(PUTIOB)
        LR      R5,R7
        J       RETB70
RETB80  ST      R6,CHNFWD,R6            :Mark chain as empty
        ST      R6,CHNBWD,R6
        LHI     R1,D.OUTN
        RBT     R1,DBITS,R12            :Ensure net output marked as closed
        L       R5,DCRBBF,R12
        JE      RETB90                  :J if no card buffers
        CALL(PUTCRB)
        LIS     R5,0
        ST      R5,DCRBBF,R12           :Mark that there is no buffer
RETB90  POP(R7,R6,R5)
        RETURN
:
        EM


        SUBTTL UPF ... USER PROFILE TABLES

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 25 JUL 85|  ORIGIN                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :SEGMENT TO CONTAIN THIS MODULE
:       MO      .,UPF                   :DELIMIT MODULE
:
: THIS MODULE CONTAINS ROUTINES TO CREATE THE USER PROFILE AND
: ASSOCIATED TABLES. IT ALSO CONTAINS ROUTINES TO ACCESS THESE TABLES.
:
:       FNDUPF - FIND ADDRESS OF USER PROFILE TABLE
:
: THERE ARE NO MACROS DEFINED IN THIS MODULE.
        SUBTTL FNDUPF ROUTINE ...FIND USER PROFILE TABLE ADDRESS
:
: ROUTINE NAME  FNDUPF
:
: FUNCTION      FIND THE ADDRESS OF THE APPROPRIATE USER PROFILE
:               TABLE ENTRY
:
: CALLED BY     ACTIVN IN CMTI
:
: ON ENTRY      8 CHARACTER USERNAME MUST BE AT CUNAME IN CCB
:               LINK REGISTER R1
:
: ON EXIT       R5 CONTAINS ADDRESS OF ENTRY OR ZERO IF NOT EXIST.
:               ALL REGISTERS WILL HAVE BEEN PRESERVED
:
: USES          
:
: ---------------------------------------------------------------------
:
: THIS CODE IS COPIED ALMOST (BUT NOT QUITE) VERBATIM FROM CMT/3270
:
        RSTART(FNDUPF)
        PUSH(R9,R8,R0)                  :SAVE REGISTERS
        LHI     R1,NUMUNM               :NO OF USER NAMES
        LA      R9,UPFLST
FNDU10  LCS     R8,8                    :8 CHARACTERS PER USERNAME
FNDU20  LB      R0,UPFUSR+8,R9,R8       :CHARACTER FROM USERNAME LIST
        THI     R0,80
        JEFS    FNDU30                  :JUMP IF THIS IS WILD CARD
        CLB     R0,CUNAME+8,R11,R8      :MATCH WITH LOGON USERNAME
        JNFS    FNDU40                  :JUMP IF NO MATCH
FNDU30  AIS     R8,1                    :NEXT CHARACTER OF USERNAME
        JLBS    FNDU20                  :JUMP IF THERE ARE MORE
        LR      R5,R9                   :ADDRESS OF USER PROFILE ENTRY
        J       FNDU80                  :RETURN WE HAVE FOUND A MATCH
:
FNDU40  AHI     R9,UPFSIZ               :NEXT ENTRY IN USERNAME LIST
        SIS     R1,1
        JN      FNDU10                  :JUMP IF NOT AT END
        LIS     R5,0                    :USER NOT SUPPORTED
:
FNDU80  POP(R0,R8,R9)                   :RESTORE REGISTERS
        RETURN
        SUBTTL USER PROFILE AND LOGON TABLE CREATION
:
: FUNCTION      THIS SECTION CONTAINS THE CODE WHICH GENERATES THE USER
:               PROFILE TABLES:
:               
:               UPFLST - USER PROFILE LIST
:               MENU - MENU LIST
:               MSTRS - LIST OF LOGON STRINGS FOR MENUS
:               LSTRS - LOGON STRING LIST
:               STRLST - LIST OF ELEMENTS IN LOGON STRINGS
:               ELEADR - ELEMENT ADDRESS IN SEG A.ELE
:               STRLAB - MENU ENTRY LABELS
:
: ---------------------------------------------------------------------
:
:
	DEFGEQ(NUMUNM,UN)                   :NUMBER OF USERNAMES
:
: PLACE ELEMENTS IN MEMORY. REFERENCED FROM ELEADR
:
        SEG     A.ELE
ELENO   EQ      0
        RE      EN
        DLE|ELENO|
ELENO   EQ      ELENO+1
        ER
:
: PLACE LABELS FOR LOGON ENTRIES FOR MENU IN MEMORY. REFERENCED FROM LSTRS
:
        CBHDEF(STRLAB,0)
LSTRNO  EQ      0
        RE      SN
        LBL|LSTRNO|
Q       EQ      1
        RE      5
        IF      SL|LSTRNO|N|Q|+1
Q       EQ      Q+1
        EI
        ER
CE|LSTRNO| EQ   Q-1
LSTRNO  EQ      LSTRNO+1
        ER
:
: CONSTRUCT LSTRS.
:       LSTRS IS INDEXED BY THE LOGON STRING NUMBER. IT HAS
:       THREE HALFWORDS PER ENTRY
:
:       1 BYTE COUNT OF ELEMENTS IN LOGIN STRING
:       HW INDEX INTO STRLST OF FIRST ELEMENT
:       HW ADDRESS OF LABEL STRING (RELATIVE TO STRLAB)
:
        SEG     0
        CBHDEF(LSTRS,0)
LSTRNO  EQ      0
        RE      SN
        BC      CE|LSTRNO|
        BC      0
        HC      STLS|LSTRNO|
        HC      L|LSTRNO|-STRLAB
LSTRNO  EQ      LSTRNO+1
        ER
:
: CONSTRUCT STRLST
:       STRLST IS A LIST OF ELEMENT NUMBERS IN ORDER. EACH ENTRY
:       IS A VARIABLE NUMBER OF HALFWORDS.  EACH HALFWORD IS AN ELEMENT
:       NUMBER, REFERENCED FROM LSTRS

:  
        CBHDEF(STRLST,0)
LSTRNO  EQ      0
        RE      SN
QX      HS      0
STLS|LSTRNO| EQ QX-STRLST
Q       EQ      1
        RE      CE|LSTRNO|
        HC      SL|LSTRNO|N|Q|
Q       EQ      Q+1
        ER
LSTRNO  EQ      LSTRNO+1
        ER
:
: CONSTRUCT MSTRS
:       MSTRS IS A LIST OF LOGON STRING NUMBERS FOR EACH MENU
:       THE SIZE OF AN ENTRY IS A VARIABLE NUMBER OF HALFWORDS.
:       REFERENCED FROM MENUS
:
        CBHDEF(MSTRS,0)
MENUQ   EQ      0
        RE      MN
MI|MENUQ| HS    0
Q       EQ      0
        RE      PM|MENUQ|
        HC      PU|MENUQ|N|Q|*6
Q       EQ      Q+1
        ER
MENUQ   EQ      MENUQ+1
        ER
:
: CONSTRUCT MENUS
:       MENUS IS AN INDEX TO THE LOGON STRING ENTRIES FOR A MENU AND IS
:       ITSELF INDEXED BY MENU NUMBER EACH ENTRY IS A FW LONG
:
:       1 BYTE COUNT OF LOGON STRINGS IN MENU
:       HALF WORD INDEX INTO MSTRS FOR FIRST ELEMENT
:
        CBHDEF(MENUS,0)
MENUQ   EQ      0
        RE      MN
        BC      PM|MENUQ|
        BC      0
        HC      MI|MENUQ|-MSTRS
MENUQ   EQ      MENUQ+1
        ER
:
: CONSTRUCT ELEADR
:       ELEADR IS INDEXED BY THE ELEMENT NUMBER AND GIVES THE
:       ADDRESS OF THE ELEMENT STRING. REFERNCED FROM STRLST
:	FIRST ENSURE THAT WE ARE ON A WORD BOUNDARY
	WS	0                  
        CBHDEF(ELEADR,0)
ELENO   EQ      0
        RE      EN
        WC      E|ELENO|
ELENO   EQ      ELENO+1
        ER
:
: CONSTRUCT USER PROFILE TABLE
:
	WS      0
	DEFGEQ(UPFLST,.)
Q       EQ      1
        RE      NUMUNM
        WC      80808080,80808080
QQ      EQ      .
        ORG     .-8
        USNM|Q|
        ORG     QQ
        HC      TM|Q|
        HC      DV|Q|
        HC      DC|Q|
	HC	CMP|Q|
Q       EQ      Q+1
        ER
:
        EM


	SUBTTL	ISIS Front End Handler Package	- FRNTND.LIB

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
: 
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRNTND.LIB	MFR 08/12/81
:
:	This package is an ISIS Front End interface to Tymnet. It
:	is used to service the ISIS input ring, and to activate user
:	defined routines whenever a message is found for a port and
:	optionally for output service when output requests are pending.

:	The package is designed to permit the activation routines to be
:	defined on an individual port basis if desired. It is also
:	designed so that context within a process can be indicated by 
:	dynamically changing to a different set of activation routines.
:
:			Conventions
:
:	The following symbols are to be provided by the user:
:
:	ECHO	if TRUE causes Tymsat echoing for terminals
:	AUTOBP	if TRUE causes automatic backpressure application & release
:		for a port based upon comparing number of characters
:		in input buffer and MAXCHAR.
:	PTIMEO	if TRUE port timeouts are available
:	MAXCHAR	maximum number of characters in a port's input buffer before
:		backpressure applied. (Only needed if AUTOBP is TRUE)
:	OUTPROC	if TRUE then output activation code will be included.
:	WAITZA if TRUE then ZAPPER acknowledgements will be requested from
:		ISIS and code will be included to clean up the port upon
:		receipt of the ZAP ACK message. (User will not have to reset
:		ACP.)
:
:	The following symbol is to be initialized by the user:
:
:	PECHO	a bit for each port. If set then echoing will be honored
:		for the port, otherwise defered echo mode will not be
:		honored.
:
:	The following symbols may be provided by the user:
:	(If not provided, default values will be used)
:
:	CRIPOM	crash code for invalid port zero message (default 20x)
:	CRNAR	crash code for no activation routine found (default 21x)
:	CRINVN	crash code for invalid needle received (default 22x)
:	CRINVM	crash code for invalid message received (default 23x)
:       FWPTAB  if true use a fullword port table.  (default 0)
:
:	The following data structures are to be provided and initialized
:	 by the user: (They may be located in any segment)
:
:	DCB	Device Control Block, a data structure which contains all
:		the context information for a port. There should be NPORT
:		DCB's defined starting at address DCBLKS. Within each DCB
:		the following offsets must be defined:
:			DCBICC	input character count (halfword)
:			ACTIVD	relative address in A.CODE of data
:				activation routine.
:			ACTIVC	relative address in A.CODE of a table of
:				halfword offsets in A.CODE of routines
:				for each possible control message.
:			ACTIVT	relative address in A.CODE of timeout
:				activation routine.
:			ACTIVO	relative address in A.CODE of output
:				activation routine. (Only needed if OUTPROC
:				is TRUE.)

:
:	PORTAB	Port Table, a halfword array containing entries for each
:		port which are the relative offset from DCBLKS of the
:		DCB for the port. If FWPTAB is true then the port
:		table is a fullword array containig the address of
:		the DCB for the port.  NOTE not an offset!
:
:	In addition, activation routines must be defined for port zero
:	messages (ACTIV0) to for needles (ACTIVN). These labels should
:	be the location of the actual routine not offsets in A.CODE.
:
:	Whenever a data or control message activation routine is called,
:	the following registers are set up:
:		R1	port number
:		R2	message type
:		R5	link register
:		R12	DCB pointer
:		R14	input ring pointers
:
:	The activation routines are responsible for extracting all the
:	message data for the current logical record from the input ring.
:	Upon return, this package willend the logical input record (ELIR).
:	Therefore R14 must be pointing to the end of the message
:	when this package regains control. All other registers may be
:	smashed.
:
:	Needles are handled differently. The are parsed and the following
:	registers loaded.
:		R1	port number
:		R2	number of characters in username
:		R5	link register
:		R6	invoice number
:		R7	destination host number
:		R8	originating node number
:		R9	originating host number
:		R10	originating port number
:		R11	dialect code
:		R13	TID
:		R14	input ring pointer
:
:	Upon a needle activation, everything up to and including the
:	username length will have been extracted from the input ring.
:	The ACTIVN routine is responsible for extracting the username.
:
:	If PTIMEO is true then a normal return from any activate'ed
:	process indicates that the timeout state of the port should not
:	be modified. If a skip return is taken, then R0 will be
:	examined. If R0 is non-zero, a timeout for that
:	many seconds will be set for the port. If R0 is zero then any 
:	timeout for the port will be cleared. When a timeout expires for a
:	port the timeout activation routine for the port will be called with
:	the following registers set up:
:		R1	port number
:		R5	link register
:		R12	DCB pointer
:
:	Upon return from the timeout activation routine, the same
:	skip/normal return convention is followed.
:
:	The user may also set or clear a timeout for a port directly.
:	The routines SETTO and CLRTO are used to set or clear a
:	timeout for a port respectively. They are used when a timeout
:	is to be set (or cleared) at a time other than a the return from
:	an activation. The routines should be called with R1 = port number.
:	For SETTO R0 should contain the interval, in seconds, until
:	the timeout activation routine for the DCB in activated.
:
:	The output routine searches for any ports requiring output service
:	which are not backpressured. For each such port, the output
:	activation routine found in the port's DCB will be activated
:	with the following registers set up:
:		R1	port number
:		R5	link register
:		R12	DCB pointer
:
:	Upon return from the output activation routine, the same
:	skip/normal return convention for timeouts is followed.
:
:	The following routines are to be called by the user (link R0).
:
:	IZFRNT	at initialization time, after calling IZT.
:	INPUT	from EXEC loop, to process input from ISIS.
:	OUTPUT	from EXEC loop, to process output requests.
:
:	In order to facilitate setting up the control message
:	activation routine table some symbols, routines, and macros
:	have been defined.
:
:	The following symbols have the values of the offsets from A.CODE of
:	a number of control message processing routines:
:		Symbol	Routine	Description
:		XTOSS	TOSS	tosses the message
:		XZAP	ZAP	handles zapper
:		XZACK	ZACK	handles zapper acknowledgement
:		XNOSEND	NOSEND	handles backpressure
:		XRESEND	RESEND	handles release backpressure
:		XGOBBLE	GOBBLE	handles gobbler
:		XFLBACK	FLBACK	handles flush backward
:		XEDEM	EDEM	handles enter deffered echo mode
:		XLDEM	LDEM	handles leave defered echo mode
:		XGB	GB	handles green ball
:		XRB	RB	handles red ball
:		XOB	OB	handles orange or black ball
:		XPNEED	PNEED	handles psuedo needle
:		XXLIM	XLIM	handle xmit limit
:		XINVAL	INVAL	crashes with invalid message code

:	The following macros are used to set up the tables:
:
:		HTABVT with argument table name is used to set up the 
:			process table for a typical virtual terminal port.
:
:		HTABIA with argument table name is used to set set up the
:			process table for an inactive port.
:
:		CHGTAB	with arguments table name, msg number, and routine
:			label is used to substitute for a default process
:			routine in the table.
::	Example:
:		To set up the control message activation routine table for
:		a virtual terminal handler which must call a routine to
:		release resources (RELRSC) upon losing the circuit on a port
:		the following code might be used.
:
:			SEG	A.CODE
:			MO	.,FRNTND
:
:			HTABVT(VTAB)	:GENERATE DEFAULT TABLE
:			CHGTAB(VTAB,9E,RELRSR)	:CHANGE ZAPPER HANDLER
:		RELRSC	------		:CODE TO CLEAN UP AND RELEASE
:			------		:RESOURCES USED BY PORT
:			J	ZAP	:JUMP TO ZAP PROCESSOR TO CLEAN
:					:UP ITS TABLES
:			EM
:			END
:
:	It should be noted that the above code is in the module FRNTND.
:	This is the Input Handler module. The preceeding symbols, routines
:	and macros are not global'ed so the code must be in the same
:	module or the symbols LOCAL'ed.
:	It should also be noted that the user defined processing
:	routines should jump to the default process routine or perform
:	similar processing on the input ring and status indicators.
:
:
	GL	NPORT,ECHO,DEM,PECHO,XLIMIT,ACP,TOISIS,FRISIS
	GL	IZFRNT,INPUT,RPORT,RDCB,AUTOBP,OUTPROC,PTIMEO
	GL	ACTIV0,ACTIVD,ACTIVC,ACTIVN,ACTIVT,EMPTYI,EMPTYO
	GL	CRIPOM,CRNAR,CRINVN,CRINVM
        gl      toss1
        IF      \FWPTAB
        ELSE
FWPTAB  EQ      0               :DEFAULT OFF
        EI
:
:DEFINE MACROS FOR ACCESSING PORTAB AND THE DCB
:
:
:Macros used to reference the port table and the DCB
:
:GETDCB - loads RDCB from PORTAB and RPORT
:
:DCBREF - produces a reference to the DCB entry specified
:         as a parameter to the macro.
:
	IF	FWPTAB
GETDCB	MACRO [SLLS RPORT,2
	L	RDCB,PORTAB,RPORT
	SRLS	RPORT,2
	LR	RDCB,RDCB
]
DCBREF	MACRO(REF) [REF,RDCB]
	ELSE
GETDCB	MACRO [LHL RDCB,PORTAB,RPORT,RPORT]
DCBREF	MACRO(REF) [REF+DCBLKS,RDCB,]
	EI
 IF	OUTPROC
	GL	ACTIVO,OUTPUT,OUTDAT,FLAGS
 EI
 IF	AUTOBP
	GL	AUTOBP
 EI

	MO	.,FRNTND

RPORT	EQ	R1		:PORT CURRENTLY BEING WORKED WITH
RDCB	EQ	R12		:POINTER TO DCB

	SEG	A.DATA

XLIMIT	BS	NPORT		:MAX NUMBER DATA CHARACTERS THAT CAN BE SENT
				:IN ONE MESSAGE
NGRP	EQ	(NPORT+0F)/10	:NUMBER OF PORT GROUPS TO PROCESS
ACP	HS	NGRP		:ACTIVE PORTS BIT ARRAY
TOISIS	HS	NGRP		:PORTS WE CAN SEND DATA ON
FRISIS	HS	NGRP		:PORTS WE HAVE NOT BACKPRESSURED
DEM	HS	NGRP		:PORTS IN DEFERED ECHO MODE
 IF	OUTPROC
FLAGS	HS	1		:BASE ADDRESS OF BIT ARRARYS. FIRST
				:HALFWORD WASTED TO AVOID BIT DISPLACE-
				:MENTS OF ZERO.
OUTDAT	HS	NGRP		:PORTS WITH OUTPUT REQUESTS WAITING
 EI
PECHO	HS	NGRP		:PORTS FOR WHICH ECHO SHOULD BE PERFORMED
 IF	\WAITZA
 ELSE
	REMARK %PLEASE DEFINE WAITZA SWITCH. DEFAULT OFF ASSUMED%%
WAITZA	EQ	0
 EI

 IF	WAITZA
	GL	CNTRL
  IF	\CNTRL
CNTRL	EQ	CNTRL!80	:SET ZAP ACK BIT
  ELSE
CNTRL	EQ	292
  EI
 EI

REGSAV	HS	20		:REGISTER SAVE AREA
RETPTR	HS	2		:RETURN POINTER
RETRN	HS	2		:RETURN ADDRESS FOR ACTIV ROUTINE
SPORT	HS	1		:SAVE AREA FOR PORT NUMBER
SDCB	HS	1		:SAVE AREA FOR DCB POINTER
SLOOP	HS	1		:SAVE AREA FOR OUTPUT LOOP COUNTER
 IF	OUTPROC
PRTSVC	HS	1		:PORTS ELIGIBLE FOR SERVICE INDICATOR
 EI

  IF	PTIMEO			:PORT TIMEOUT
TSAVE	HS	4		:SAVE AREA FOR TIMEOUT ACTIVATOR
PTIME	HS	NGRP		:PORTS ON ACTIVE TIMEOUT
ATIME	HS	2*NPORT		:ACTIVATION TIME
  EI

:
:	DEFINE CRASH CODES IF USER HAS NOT
:

  IF	\CRIPOM
  ELSE
CRIPOM	EQ	20	:INVALID PORT ZERO MESSAGE
  EI

  IF	\CRNAR
  ELSE
CRNAR	EQ	21	:NO ACTIVATION ROUTINE IN DCB
  EI

  IF	\CRINVN
  ELSE
CRINVN	EQ	22	:INVALID NEEDLE RECEIVED
  EI

  IF	\CRINVM
  ELSE
CRINVM	EQ	23	:INVALID MESSAGE RECEIVED
  EI


	SEG	A.CODE

:	HANDY INDEXABLE HALFWORD BIT MASKS
HMASK	HC	8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1

:	BIT ARRAY TO IDENTIFY DATA MESSAGES
DATAM	HC	07FFF,-1,-1	:00
	HC	-1,-1,-1	:30
	HC	-1,-1,-1	:60
	HC	0FFFC,0,0	:90
	HC	0,0,0		:C0
	HC	0		:F0

LENGTH	BC	0		:MESSAGE LENGTH TABLE
	RE	9D;	BC	.-LENGTH+1;	NOLIST;	ER;	LIST	:DATA TEXT STRINGS
	BC	1		: 9E	DETACH
	BC	1		: 9F	DISCONNECT
	BC	1		: A0	APPLY BACKPRESSURE
	BC	1		: A1	RELEASE BACKPRESSURE
	BC	1		: A2	FLUSH FORWARD
	BC	1		: A3	FLUSH BACKWARD
	BC	1		: A4	BLACK BALL
	BC	1		: A5	GREY BALL
	BC	1		: A6	ENTER "DEM"
	BC	1		: A7	LEAVE "DEM"
	BC	1		: A8	ENTER "TRANSPARENCY"
	BC	1		: A9	LEAVE "TRANSPARENCY"
	BC	1		: AA	GREEN BALL
	BC	1		: AB	RED BALL
	BC	1		: AC	YELLOW BALL
	BC	1		: AD	ORANGE BALL
	BC	1		: AE	"BREAK" DETECTED
	BC	1		: AF	"HANG UP"
	BC	2		: B0	QUERY TERMINAL PARAMETER
	BC	3		: B1	SET TERMINAL PARAMETER
	BC	4		: B2	PSEUDO-NEEDLE
	BC	2		: B3	LOGON CHARACTER
	BC	2		: B4	NORMAL LOGON STATUS
	BC	2		: B5	LOGON FAILURE
	BC	8		: B6	SUCCESSFUL LOGON FROM THIS PORT
	BC	6		: B7	ADDENDUM TO ACCOUNTING
	BC	1		: B8	SUPER-"HANG UP"
	BC	2		: B9	TRANSMIT LIMIT
	BC	1		: BA	BREAK END
	BC	1		: BB	ZAPPER ACKNOWLEGEMENT
	BC	1		: BC	ENTER ALTERNATE OUTPUT DEVICE MODE
	BC	1		: BD	LEAVE ALTERNATE OUTPUT DEVICE MODE
	BC	2		: BE	ZAP WITH REASON
	BC	1		: BF	START IIX
	BC	1		: CO	TERMINATE IIX

:		**INTERFACE DATA TYPES**


NEDMSG	EQ	0		:NEEDLE
FIRST	EQ	9E		:FIRST MESSAGE IN LIST
DETMSG	EQ	9E		:DETACH MESSAGE
ZAPMSG	EQ	9F		:DISCONNECT MESSAGE
NOSMSG	EQ	0A0		:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1		:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2		:FLUSH OUTPUT
BKGMSG	EQ	0A3		:FLUSH INPUT
BLKMSG	EQ	0A4		:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5		:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6		:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7		:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8		:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9		:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA		:GREEN BALL
RBMSG	EQ	0AB		:RED BALL
YBMSG	EQ	0AC		:YELLOW BALL
OBMSG	EQ	0AD		:ORANGE BALL
BRKMSG	EQ	0AE		:BREAK DETECTED
HNGMSG	EQ	0AF		:HANG UP
QTPMSG	EQ	0B0		:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1		:SET TERMINAL PARAMETER
PNDMSG	EQ	0B2		:PSEUDO NEEDLE
NLOGCH	EQ	0B3		:NORMAL LOGON CHAR
NLOGST	EQ	0B4		:NORMAL LOGON STATUS
LOGFAL	EQ	0B5		:LOGON FAILURE
LOGOK	EQ	0B6		:SUCCESSFUL LOGON
ADACTG	EQ	0B7		:ADDENDUM TO ACCOUNTING
SHGMSG	EQ	0B8		:SUPER-HANG UP
SETLIM	EQ	0B9		:SET XMIT LIMIT
BRKEND	EQ	0BA		:BREAK END
ZAPACK	EQ	0BB		:ZAPPER ACKNOWLEGEMENT
EAODM	EQ	0BC		:ENTER ALTERNATE OUTPUT DEVICE MODE
LAODM	EQ	0BD		:LEAVE ALTERNATE OUTPUT DEVICE MODE
ZAPREA	EQ	0BE		:ZAP WITH REASON
SIIX	EQ	0BF		:START IIX
TIIX	EQ	0C0		:TERMINATE IIX
MAXTYP	EQ	0C0		:MAXIMUM TYPE DEFINED

:
:	HANDLES INPUT MESSAGES FROM ISIS INPUT RING
:
INPUT	ST	R0,RETPTR	:SAVE RETURN ADDRESS
INPUT1	JAL	R4,LOOK		:IS THERE ANYTHING TO DO?
	J	RET		:NO... RETURN ALLL DONE FOR NOW
	JN	INPUT2		:TEST IF PORT 0.. SKIP IF NOT
:
:	CHECK PORT ZERO MESSAGES
:
	JAL	R4,GETCH	:GET MSG TYPE BYTE
	LR	R2,R0		:TEST MSG TYPE
	JEFS	SPEC2		:SKIP IF MSG 0
	TBT	R2,SPECL	:TEST IF VALID MESSAGE TYPE
	JEFS	SPEC1		:SKIP IF OK
	JAL	R10,CRASH	:OTHERWISE CRASH
	BC	0,0,4*R2,CRIPOM

SPECL	BC	1D,0A9,0FF	:INVALID PORT 0 MSG TYPES

SPEC1	LA	R5,ACTIV0	:SET UP CALLING ADDRESS
	JAL	R4,ACTIV	:ACTIVATE USER PORT 0 MSG ROUTINE
SPEC2	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE....
:
:	NOT A PORT ZERO MESSAGE
:
:	R1=PORT#	R2=MSG TYPE
:
INPUT2	JAL	R4,GETCH	:GET MSG TYPE
	TBT	R0,DATAM	:TEST IF DATA MESSAGE
	JE	INPUT3		:SKIP IF NOT
:
	TBT	RPORT,DEM	:TEST IF PORT IS IN DEFERED ECHO MODE
	JE	INDATA		:SKIP IF NOT
	TBT	RPORT,PECHO	:SHOULD DEM BE HONORED?
	JE	INDATA		:SKIP IF NOT
	LR	R2,R0		:COPY MSG LENGTH
	LR	R5,R0		:COPY IT AGAIN
	ST	R14,REGSAV	:SAVE INPUT RING POINTER REGISTER
:
ECHO1	JAL	R4,GETCH	:GET A CHARACTER
	STB	R0,ECHOBF,R5	:PUT IT INTO ECHO BUFFER
	SIS	R5,1		:DECREMENT COUNTER
	JGBS	ECHO1		:GO BACK IF MORE CHARS IN RECORD
	LR	R5,R2		:COPY CHAR COUNT
	LHI	R0,3,R2		:CALCULATE MSG LENGTH
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
ECHO2	LB	R0,ECHOBF,R5	:GET A CHARACTER FROM ECHO BUFFER
	JAL	R4,PUTCH	:PUT IT INTO OUTPUT RING
	SIS	R5,1		:DECREMENT COUNTER
	JGBS	ECHO2		:REPEAT IF MORE
	JAL	R4,ELOR		:ALL DONE.. END LOGICAL RECORD
:
:	NOTE THAT BACKPRESSURE AND TRANSMIT LIMIT ARE NOT CHECKED
:	IN SERVICING THE DEFERED ECHO.
:
	L	R14,REGSAV	:RESTORE INPUT RING POINTER

:
INDATA	GETDCB			:GET DCB POINTER
	JEFS	INDCR		:CRASH IF NO DCB
	LHL	R4,DCBREF(ACTIVD)      :GET DATA ACTIVATION ROUTINE FOR PORT
	JNFS	INDAT1		:TEST IF THERE IS A ROUTINE
INDCR	JAL	R10,CRASH	:CRASH IF NO ROUTINE
	BC	0,0,4*RDCB,CRNAR
:
  IF	AUTOBP
:
:	CHECK IF INPUT PORT SHOULD BE BACKPRESSURED
:
INDAT1	STH	RPORT,SPORT	:PRESERVE R1
	STH	RDCB,SDCB	:PRESERVE RDCB
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	JAL	R4,ELIR		:END THE INPUT RECORD
	LHL	RDCB,SDCB	:RESTORE DCB POINTER
	LH	R0,DCBREF(DCBICC)	:GET INPUT CHAR COUNT
	SHI	R0,MAXCHAR	:TEST IF TOO MANY CHARACTERS
	JL	INPUT1		:NO... GO BACK FOR MORE 
	LHL	RPORT,SPORT	:RESTORE PORT NUMBER
	LIS	R0,3		:GENERATE BACKPRESSURE MESSAGE
	LHI	R2,NOSMSG	:
	JAL	R4,SLOR		:START THE RECORD
	JAL	R4,ELOR		:END IT
	RBT	RPORT,FRISIS	:SET BP INDICATOR FOR PORT
	J	INPUT1		:AND GO BACK FOR MORE
  ELSE
:
INDAT1	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	JAL	R4,ELIR		:END THE INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE
  EI

	SEG	A.DATA
ECHOBF	BS	FIRST	:ECHO BUFFER

	SEG	A.CODE

:
:	PROCESS CONTROL MESSAGES
:
INPUT3	LR	R3,R0		:COPY MSG TYPE
	JN	INCNTL		:NOT A NEEDLE....SKIP
	SBT	RPORT,ACP		:TEST AND SET ACTIVE PORT BIT
	JEFS	NEEDLE		:SKIP IF PORT WAS NOT ACTIVE
	JAL	R10,CRASH	:OTHERWISE CRASH
	BC	0,0,4*RPORT,CRINVN
:
:	PROCESS NEEDLES
:
NEEDLE	LHI	R0,FIRST-1	:SET UP TRANSMIT LIMIT
	STB	R0,XLIMIT,RPORT	:STORE IT
	SBT	RPORT,TOISIS	:CLEAR BACKPRESSURE
	SBT	RPORT,FRISIS	:
 IF	OUTPROC
	RBT	RPORT,OUTDAT	:CLEAR OUTPUT DATA WAITING
 EI
  IF PTIMEO
	RBT	RPORT,PTIME	:CLEAR PORT TIMEOUT
  EI
	JAL	R4,GETCH	:SKIP LENGTH
	JAL	R4,GETW		:GET INVOICE NUMBER
	LR	R6,R0		:COPY IT
	JAL	R4,GETH		:GET DESTINATION HOST
	LR	R7,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE NODE
	LR	R8,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE HOST
	LR	R9,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE PORT
	LR	R10,R0		:COPY IT
	JAL	R4,GETW		:FUTURE EXPANSION
	JAL	R4,GETH		:GET DIALECT CODE
	LR	R11,R0		:COPY IT
	JAL	R4,GETCH	:GET TID
	LR	R13,R0		:COPY IT
:
  IF	ECHO
:		SOURCE NODE SHOULD ECHO
	THI	R13,1F		:CHECK IF TERMINAL
	JE	NEED2		:SKIP... NOT A TERM
	ST	R14,REGSAV	:SAVE INPUT RING POINTER
	THI	R13,20		:CHECK IF HALF DUPLEX
	JNFS	NEED1		:SKIP IF HDX.. DON'T SET DEM
	SBT	RPORT,DEM	:SET DEM
NEED1	LIS	R0,5		:SEND SET TERM PARM MSG
	LHI	R2,STPMSG	:
	JAL	R4,SLOR		:START THE OUTPUT RECORD
	LIS	R0,0
	JAL	R4,PUTCH	:
	LIS	R0,1		:SET ECHO ON
	JAL	R4,PUTCH	:
	JAL	R4,ELOR		:
	L	R14,REGSAV	:RESTORE INPUT RING POINTER
  EI
:
NEED2	JAL	R4,GETCH	:GET USERNAME LENGTH
	LR	R2,R0		:COPY USERNAME LENGTH
	LA	R5,ACTIVN	:SET UP NEEDLE ACTIVATION ROUTINE ADDR
	JAL	R4,ACTIV	:ACTIVATE IT
	JAL	R4,ELIR		:END THE INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE

:
:
:	PROCESS NON-NEEDLE CONTROL MESSAGES FOR PORTS
:
INCNTL	SHI	R3,FIRST		:SUBTRACT TO GET RELATIVE MSG NUMBER
	SLLS	R3,1			:FORM HALFWORD INDEX
	GETDCB			:GET DCB POINTER
	JE	INCN1			:CRASH IF NO DCB
	LHL	R4,DCBREF(ACTIVC)	:GET TABLE POINTER
	JEFS	INCN1			:SKIP IF NO TABLE ADDRESS
	LHL	R4,SEG|A.CODE|,R4,R3	:GET ROUTINE ADDRESS
	JEFS	INCN1			:SKIP IF NO ROUTINE ADDRESS
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV		:ACTIVATE
	JAL	R4,ELIR			:END THE LOGICAL RECORD
	J	INPUT1			:AND GO BACK FOR MORE
:
INCN1	JAL	R10,CRASH		:CRASH IF NO ROUTINE
	BC	0,0,4*RDCB,CRNAR

:	INITIALIZATION FOR THIS PACKAGE
:
IZFRNT	ST	R0,RETPTR	:SAVE RETURN ADDRESS
	LHI	RPORT,NPORT-1	:SET UP LOOP
IZIN1	RBT	RPORT,ACP	:SET PORT NOT ACTIVE
	SBT	RPORT,TOISIS	:SET BACKPRESSURE OFF
	SBT	RPORT,FRISIS	:
 IF	OUTPROC
	RBT	RPORT,OUTDAT	:RESET OUTPUT DATA WAITING
 EI
	RBT	RPORT,DEM	:NOT DEFERED ECHO MODE
	SIS	RPORT,1		:DECREMENT LOOP COUNTER
	JGEBS	IZIN1		:REPEAT IF MORE
:
  IF	AUTOBP			:AUTOMATIC BACKPRESSURE RELEASE CODE
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,RELBP	:PUT RELBP ON TIMEOUT LIST
	LHI	R1,RATE/2,R7	:SET HALF SECOND TIMEOUT
	JAL	R5,TOPUT	:
  EI
:
  IF	PTIMEO			:PORT TIMEOUT CODE
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,ONESEC	:PUT ONESEC ON TIMEOUT LIST
	LHI	R1,RATE,R7	:SET ONE SECOND TIMEOUT
	JAL	R5,TOPUT	:
  EI
	JFS	RET		:RETURN
:
:	GENERAL RETURN ROUTINE
RET	L	R0,RETPTR	:GET RETURN ADDRESS
	JR	R0		:AND RETURN
:
:	ACTIVATION ROUTINE
:
ACTIV	ST	R4,RETRN	:SAVE RETURN ADDRESS
  IF	PTIMEO
:		PORT TIMEOUT CODE
	STH	RPORT,SPORT	:PRESERVE PORT NUMBER
	JALR	R5,R5		:ACTIVATE
	J	ACTIV2		:NORMAL RETURN DON'T MODIFY TIMEOUT
	LHL	RPORT,SPORT	:RESTORE PORT NUMBER
	LR	R0,R0		:TEST RETURN PARAMETER
	JGFS	ACTIV1		:NONZERO... SKIP
	RBT	RPORT,PTIME	:TURN OFF PORT TIMEOUT INDICATOR
	JFS	ACTIV2		:
ACTIV1	SBT	RPORT,PTIME	:SET PORT TIMEOUT INDICATOR ON
	A	R0,SLOWC,,	:ADD TIMEOUT TO SLOW CLOCK
	SLHLS	RPORT,2		:MAKE WORD INDEX POINTER
	ST	R0,ATIME,RPORT	:STORE ACTIVATION TIME
  ELSE
	JALR	R5,R5		:ACTIVATE
  EI
ACTIV2	L	R4,RETRN	:RESTORE RETURN ADDRESS
	JR	R4		:AND RETURN
:
  IF	AUTOBP
:
:		CODE TO PERIODICALLY CHECK IF BACKPRESSURE CAN
:		BE RELEASED ON ANY PORTS
RELBP	AHI	R1,RATE/2		:
	JAL	R5,TOPUT	:PUT BACK ON TIMEOUT LIST FOR ONE SECOND
:
:	CHECK ALL PORTS FOR THOSE WITH BACKPRESSURE APPLIED
:
	LHI	R5,(NGRP-1)*2	:
	LHI	R6,(NGRP-1)*10	:SET UP POINTERS
RBP1	LCS	R7,1		:
	XH	R7,FRISIS,R5	:CHECK IF BACKPRESSURE APPLIED
	NH	R7,ACP,R5	:AND PORT ACTIVE
RBP2	LR	R1,R7		:TEST
	JNFS	RBP3		:SKIP.. SOMETHING TO DO
	SIS	R5,2		:DECREMENT POINTERS
	SHI	R6,10		:
	JGEBS	RBP1		:CHECK NEXT RING GROUP
	J	TORET		:OTHERWISE RETURN
:
RBP3	JAL	R3,BIDH		:DETERMINE WHICH PORT ON GROUP NEEDS SERVICE
	XH	R7,HMASK,R2,R2	:MARK PORT AS SERVICED
	AR	R2,R6		:FORM PORT NUMBER
	LR	RPORT,R2		:COPY IT
	SLHLS	R2,2		:FORM BUFFER NUMBER
	GETDCB			:GET DCB POINTER FROM PORT TABLE
	LH	R0,DCBREF(DCBICC)	:GET INPUT CHAR COUNT
	SHI	R0,MAXCHAR	:TEST IF LESS THAN MAXCHAR
	JG	RBP2		:NOT EMPTY ENOUGH YET
	SBT	RPORT,FRISIS	:RELEASE BACKPRESSURE
	LIS	R0,3		:FORM 3 BYTE MESSAGE
	LHI	R2,SNDMSG	:GET MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	J	RBP2		:AND CONTINUE
  EI
  IF	PTIMEO
:
:		CODE TO CHECK PERIODICALLY FOR PORT TIMEOUTS
:
ONESEC	AHI	R1,RATE		:SET UP TO RUN AGAIN IN ONE SECOND
	JAL	R5,TOPUT	:
	LHI	R15,(NGRP*2)-2	:SEARCH BY GROUPS
OS1	LH	R14,ACP,R15	:GET ACTIVE PORT INDICATORS
	NH	R14,PTIME,R15	:AND IN PORTS ON TIMEOUT
	JNFS	OS3		:JUMP IF ANY TO CHECK
OS2	SIS	R15,2		:DECREMENT GROUP INDEX
	JGEBS	OS1		:REPEAT IF MORE
	J	TORET		:OTHERWISE EXIT
:
OS3	LR	R1,R14		:COPY MASK OF PORTS TO PROCESS
	JEBS	OS2		:NONE... GO ON TO NEXT GROUP
	JAL	R3,BIDH		:FIND FIRST
	XH	R14,HMASK,R2,R2	:SET IT EXAMINED
	LR	R1,R15		:COPY GROUP INDEX
	SLHLS	R1,3		:MAKE GROUP INDEX INTO PORT OFFSET
	AR	RPORT,R2	:MAKE PORT NUMBER
	LR	R2,RPORT	:COPY PORT NUMBER
	SLHLS	R2,2		:MAKE INTO FULLWORD INDEX
	L	R0,ATIME,R2	:GET ACTIVATION TIME
	S	R0,SLOWC,,	:SUBTRACT CURRENT TIME
	JG	OS3		:NOT READY.. IGNORE FOR NOW
	GETDCB			:GET DCB POINTER
	JNFS	OS4		:SKIP IF GOT A DCB
OSCR	JAL	R10,CRASH	:CRASH
	BC	0,0,4*RDCB,CRNAR	:NO ACTIVATION ROUTINE
:
OS4	LHL	R4,DCBREF(ACTIVT)	:GET ACTIVATION ROUTINE
	JEBS	OSCR		:CRASH IF NO ROUTINE
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	STM	R14,TSAVE	:PRESERVE WORK REGISTERS
	JAL	R4,ACTIV	:ACTIVATE
	LM	R14,TSAVE	:RESTORE WORK REGISTERS
	J	OS3		:GO BACK FOR MORE
:
:	SET AND CLEAR TIMEOUT ROUTINES
:		LINK ON R4
:		EXPECT R1 = PORT NUMBER
:		       R0 = TIMEOUT INTERVAL IN SECONDS (SETTO)
:		SMASHES R0
:
	GL	SETTO,CLRTO
:
SETTO	SBT	RPORT,PTIME	:SET PORT TIMEOUT INDICATOR
	A	R0,SLOWC,,	:ADD TO CURRENT TIME
	SLHLS	RPORT,2		:MAKE INTO FULLWORD POINTER
	ST	R0,ATIME,RPORT	:STORE TIME
	SRHLS	RPORT,2		:MAKE BACK INTO PORT NUMBER
	JR	R4		:AND RETURN
:
CLRTO	RBT	RPORT,PTIME	:RESET PORT TIMEOUT INDICATIOR
	JR	R4		:AND RETURN
  EI
:

:	CONTROL MESSAGE ACTIVATION ROUTINES
:
:	TOSS A MESSAGE
TOSS	LB	R0,LENGTH,R2	:PICK UP MESSAGE LENGTH
	SIS	R0,1		:WE'VE ALREADY GOTTEN MESSAGE TYPE
toss1   AR      R14,R0          :ADVANCE POINTER TO END OF MSG
	JR	R5		:RETURN
:
:	ZAPPER ACKNOWEDGEMENT
:
ZACK	EQ	.
:
:	DISCONNECT
ZAP	JAL	R4,EMPTYI	:EMPTY INPUT BUFFER
	JAL	R4,EMPTYO	:EMPTY OUTPUT BUFFER
	RBT	RPORT,ACP	:SET PORT NOT ACTIVE
	RBT	RPORT,DEM	:SET PORT NOT IN DEM
	JR	R5		:RETURN
:
:	APPLY BACKPRESSURE
NOSEND	RBT	RPORT,TOISIS	:TURN IT OFF FOR PORT
	JR	R5		:RETURN
:
:	RELEASE BACKPRESSURE
RESEND	SBT	RPORT,TOISIS	:TURN IT ON FOR PORT
	JR	R5		:RETURN
:
:	GOBBLER
GOBBLE	JAL	R4,EMPTYI	:EMPTY INPUT BUFFER
	SBT	RPORT,FRISIS	:RELEASE BACKPRESSURE
	JR	R5		:AND RETURN
:
:	FLUSH BACKWARD
FLBACK	JAL	R4,EMPTYO	:EMPTY OUTPUT BUFFER
	LIS	R0,3		:SEND GOBBLER IN OTHER DIRECTION
	LHI	R2,GOBMSG	:CREATE MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	ENTER DEM
EDEM	SBT	RPORT,DEM	:SET INDICATOR
	JR	R5		:RETURN

:
:	LEAVE DEM
LDEM	RBT	RPORT,DEM	:CLEAR INDICATOR
	JR	R5		:RETURN
:

:	GREEN BALL
GB	LIS	R0,3		: RETURN GREEN BALL
	LHI	R2,GBMSG	:CREATE MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	RED BALL
RB	LIS	R0,3		:RETURN THE RED BALL
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	ORANGE (OR BLACK) BALL
OB	LIS	R0,3		:CREATE MESSAGE
	LHI	R2,1,R2		:CREATE OTHER BALL OF PAIR
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	PSUEDO-NEEDLE
PNEED	LB	R0,LENGTH,R2	:JUST TOSS IT
	SIS	R0,1		:WE ALREADY GOT MSG TYPE
	AR	R14,R0		:ADVANCE POINTER TO END OF MSG
	LHI	R0,FIRST-1	:SET UP DEFAULT TRANSMIT LIMIT
	STB	R0,XLIMIT,RPORT	:
	SBT	RPORT,ACP	:SET PORT ACTIVE
	SBT	RPORT,TOISIS	:CLEAR BACKPRESSURE
	SBT	RPORT,FRISIS	:
	JR	R5		:AND RETURN
:
:	TRANSMIT LIMIT
XLIM	JAL	R4,GETCH	:GET RESTRICTION
	CLHI	R0,FIRST-1	:RANGE CHECK
	JLFS	XLIM1		:OK...SKIP
	LHI	R0,FIRST-1	:OTHERWISE SET LIMIT
XLIM1	STB	R0,XLIMIT,RPORT	:SET UP RESTRICTION
	JR	R5		:AND RETURN
:
:	INVALID MESSAGE
INVAL	JAL	R10,CRASH
	BC	0,0,4*R5,CRINVM
 IF	OUTPROC

:	OUTPUT PROCESS ROUTINE
:
OUTPUT	ST	R0,RETPTR	:SAVE RETURN ADDRESS
	LHI	R11,(NGRP-1)*2	:LOOP COUNTER
OUTP1	LCS	R1,1		:SET UP MASK
	STH	R1,PRTSVC	:SAVE PORT SERVICED MASK
OUTP2	LHL	R1,ACP,R11	:GET ACTIVE PORTS INDICATOR
	NH	R1,OUTDAT,R11	:AND WITH DATA WAITING INDICATOR
	NH	R1,TOISIS,R11	:AND NOT BACKPRESSURED
	NH	R1,PRTSVC	:AND NOT ALREADY SERVICED
	JNFS	OUTP3		:SKIP IF ANYTHING TO DO
	SIS	R11,2		:DECREMENT LOOP COUNTER
	JGEBS	OUTP1		:LOOP
	J	RET		:DONE... RETURN
:
OUTP3	JAL	R3,BIDH		:FIND PORT TO SERVICE
	LR	R1,R11		:COPY PORT OFFSET
	SLHLS	R1,3		:TIMES EIGHT
	AR	RPORT,R2	:PORT NUMBER!
	RBT	R2,PRTSVC	:CLEAR PORT TO BE SERVICED BIT
	GETDCB			:GET DCB POINTER FOR PORT
	JEFS	OUTCR			:CRASH NO DCB POINTER
	LHL	R4,DCBREF(ACTIVO)	:GET OUTPUT ACTIVATION ROUTINE
	JNFS	OUTP4			:GOT A ROUTINE...SKIP
:
OUTCR	JAL	R10,CRASH
	BC	0,0,4*RDCB,CRNAR	:NO ACTIVATION ROUTINE
:
OUTP4	STH	R11,SLOOP	:SAVE LOOP COUNTER
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	LHL	R11,SLOOP	:RESTORE LOOP POINTER
	J	OUTP2		:LOOP
:
 EI
:	DEFAULT CONTROL MESSAGE ACTIVATION TABLES
:
:	CALCULATE ROUTINE OFFSETS
:
XTOSS	EQ	TOSS-SEG|A.CODE|
XZAP	EQ	ZAP-SEG|A.CODE|
XZACK	EQ	ZACK-SEG|A.CODE|
XNOSEND	EQ	NOSEND-SEG|A.CODE|
XRESEND	EQ	RESEND-SEG|A.CODE|
XGOBBLE	EQ	GOBBLE-SEG|A.CODE|
XFLBACK	EQ	FLBACK-SEG|A.CODE|
XEDEM	EQ	EDEM-SEG|A.CODE|
XLDEM	EQ	LDEM-SEG|A.CODE|
XGB	EQ	GB-SEG|A.CODE|
XRB	EQ	RB-SEG|A.CODE|
XOB	EQ	OB-SEG|A.CODE|
XPNEED	EQ	PNEED-SEG|A.CODE|
XXLIM	EQ	XLIM-SEG|A.CODE|
XINVAL	EQ	INVAL-SEG|A.CODE|
:
:	TABLE CREATION MACROS
:
HTABVT	MACRO(TABNAM)
[	SEG	A.CODE
	GL	TABNAM
TABNAM	HC	XZAP,XZAP,XNOSEND,XRESEND,XGOBBLE,XFLBACK	:9E - A3
	HC	XOB,XTOSS,XEDEM,XLDEM,XTOSS,XTOSS		:A4 - A9
	HC	XGB,XRB,XOB,XTOSS,XTOSS,XTOSS			:AA - AF
	HC	XTOSS,XTOSS,XINVAL,XINVAL,XTOSS,XTOSS		:B0 - B5
	HC	XTOSS,XINVAL,XTOSS,XXLIM,XTOSS,XZACK		:B6 - BB 
	HC	XTOSS,XTOSS,XINVAL,XTOSS,XTOSS			:BC - C0
]
:
HTABIA	MACRO(TABNAM)
[	SEG	A.CODE
	GL	TABNAM
TABNAM	HC	XZAP,XZAP	:9E - 9F
	RE	0B1-9F
	HC	XTOSS
	NOLIST
	ER
	LIST
	HC	XPNEED,XINVAL	:B2 - B3
	HC	XTOSS,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS		:B4 - B9
	HC	XTOSS,XZACK,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS	:BA - C0
]
:
CHGTAB	MACRO(TABNAM,MSGNUM,ROUTIN)
[
OLDORG	EQ	.
	ORG	TABNAM+(MSGNUM-FIRST)*2
	HC	ROUTIN-SEG|A.CODE|
	ORG	OLDORG
]
	EM
:


        SUBTTL CMTI ... CMT front end interface

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 JUL 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        GL      LENGTH                  :Table in FRNTND used in ACTIVM
        GL      LOGST                   :Log on routines
        GL      ENDIT,RESTAR            :Routines in TERM used by ACTIVZ
        SEG     A.CODE                  :Segment to contain this module
        MO      .,CMTI                  :Delimit module
:
: This module contains routines that interface with the ring input
: handling routines in FRNTND.LIB
:
:       ACTIV0 - Called by FRNTND to action port 0 messages
:       ANSHST - Send host status report
:       ACTIVN - Needle activation routine
:       ACTIVP - Pseudo needle activation routine
:       INIDCB - Initialise DCB
:       DATACT - Data activation routine
:       ACTIVM - Control message activation routine
:       ACTIVZ - Process zap messages
:       SETXLT - Process set transmit limit command
:       BPON - Process apply backpressure command
:       BPOFF - Process release backpressure command
:       SNDPNR - Send pseudo needle request
:       SNDNLC - Send normal logon character
:       ECHOFF - Send echo off, echo on
:       SNDZAP - Send zapper
:       SNDDET - Send detach
:       SNDGB - Send green ball
:       SNDRB - Send red ball
:       SNDGRB - Send grey ball
:       SNDSIX - Send start IIX
:       SNDTIX - Send end IIX
:       SNDBPO - Send apply back pressure
:       SNDBPX - Send release back pressure
:
: There are no macros unique to this module.
        SUBTTL CMTI - Control table definitions
:
: Function      Sets up control message activation tables which specify
:               the offsets of routines that will process the various
:               control messages.
:
: ---------------------------------------------------------------------
:
        LO      FRNTND                  :Make FRNTND variables local
:
: Control table for inactive ports - FRNTND handles everything except 
: pseudo needles.
:
        HTABIA(ACTCIP)                  :Create default table for inactive port
        CHGTAB(ACTCIP,0B2,ACTIVP)       :Handle pseudo needle requests
:
: Control table for terminal DCB in logon state
:
        HTABVT(ACTCLT)                  :Create default table for virtual
                                        : terminal
        CHGTAB(ACTCLT,09E,ACTIVZ)       :Detach enters zap code
        CHGTAB(ACTCLT,09F,ACTIVZ)       :Zap message
:
: Control table for terminal DCB in normal state
:
        HTABVT(ACTCNT)                  :Create default table for virtual
                                        : terminal
        CHGTAB(ACTCNT,09E,ACTIVZ)       :Detach enters zap code
        CHGTAB(ACTCNT,09F,ACTIVZ)       :Zap message
        CHGTAB(ACTCNT,0A0,BPON)         :Apply backpressure
        CHGTAB(ACTCNT,0A1,BPOFF)        :Release backpressure
        CHGTAB(ACTCNT,0A6,ACTIVM)       :Entering DEM
        CHGTAB(ACTCNT,0A7,ACTIVM)       :Leaving DEM
        CHGTAB(ACTCNT,0AA,ACTIVM)       :Green ball
        CHGTAB(ACTCNT,0AB,ACTIVM)       :Red ball
        CHGTAB(ACTCNT,0B9,SETXLT)       :Set transmit limit
:
: Control table for host DCB in logon state
:
        HTABVT(ACTCLH)                  :Create default table for virtual
                                        : terminal
        CHGTAB(ACTCLH,09E,ACTIVZ)       :Detach enters zap code
        CHGTAB(ACTCLH,09F,ACTIVZ)       :Zap message
	CHGTAB(ACTCLH,0A1,BPOFF)
                                        :All the following messages are
                                        : placed in input buffer by ACTIVM
        CHGTAB(ACTCLH,0A4,ACTIVM)       :Black ball
        CHGTAB(ACTCLH,0B4,ACTIVM)       :Normal logon status
        CHGTAB(ACTCLH,0B5,ACTIVM)       :Logon fail
        CHGTAB(ACTCLH,0B6,ACTIVM)       :Successful logon
        CHGTAB(ACTCLH,0BF,ACTIVM)       :SIIX
        CHGTAB(ACTCLH,0C0,ACTIVM)       :TIIX
:
        FO      FRNTND                  :Make FRNTND variables foriegn

        SUBTTL ACTIV0 routine ... Action port 0 messages
:
: Routine name  ACTIV0
:
: Function      Action port 0 messages received by FRNTND
:
: Called by     FRNTND
:
: On entry      Link register R5
:
: On exit       No registers will have been preserved
:
: Uses          GETCH, GETH, GETW in FRING.LIB
:               ANSHST in this module
:
: ---------------------------------------------------------------------
:
        DEFGEQ(ACTIV0,.)
        CHI     R2,10                   :Legal msg type
        JG      POM30                   :Jump if not to crash
        SLHLS   R2,2                    :Make R2 into index
        J       P0MSG,R2                :Process msg by type
: 
: P0MSG - Jump table for port 0 msgs
:
P0MSG   J       POM10                   : Type 0 restart request
        J       POM10                   : Type 1 restart response
        J       ANSHST                  : Type 2 node has been taken over
        J       POM30                   : Type 3 report to sup log
        J       POM30                   : Type 4 report host status
        J       POM30                   : Type 5 report accounting
        J       POM20                   : Type 6 tell host time
        J       POM30                   : Type 7 psuedo-needle request
        J       POM30                   : Type 8 aux circuit request
        J       POM50                   : Type 9 unable to provide
                                        :        psuedo needle
        J       POM30                   : Type A report host availability
        J       POM30                   : Type B host unacceptable
        J       POM30                   : Type C report host cost
        J       POM10                   : Type D no supervisor
        J       POM10                   : Type E 1 down
        J       POM30                   : Type F report all hosts
        J       POM30                   : Type 10 extended report host status
:
:    Discard message
:
POM10   JR      R5                      :Just return
:
:    Message type 6, read message and discard
:
POM20   JAL     R4,GETCH,,              :Skip character
        JAL     R4,GETW,,               :Skip GMT
        JR      R5                      :Return
:
:    Crash as message should not be received
:
POM30   CRUNCH(CRIPOM)          
:
:    Message type 9, read message, indicate to DCB requesting needle that
:    request has failed.
:
POM50   JAL     R4,GETCH,,              :Discard ISIS key
        JAL     R4,GETH,,               :Get local key
        LHI     R9,DCBSIZ
        MHR     R0,R9                   :Convert key into DCB address
        AI      R0,DCBLKS
        LR      R12,R0
        LHL     R0,DSUSP,R12
        CHI     R0,SUSPN                :Are we waiting for pseudo needle
        JN      POM60                   :J if not
        LIS     R0,0
        STH     R0,DPORT,R12            :Indicate no port allocated
        STH     R0,DSUSP,R12            :Clear suspension
        LHL     R0,DCBNO,R12
        SBT     R0,RUNREQ               :Mark for running
POM60   JR      R5                      :Return


        SUBTTL ANSHST routine ... Send host status report
:
: Routine name  ANSHST
:
: Function      Send an extended host status report type hex 10 to
:               slot 0
:
: Called by     ACTIV0, EXEC
:
: On entry      Link register R5
:
: On exit       No registers will have been preserved
:
: Uses          SLOR, PUTCH, PUTH, PUTW, ELOR in FRING.LIB
:
: ---------------------------------------------------------------------
:
        DEFGEQ(ANSHST,.)
        LIS     R0,$A14                 :14 byte message
        LIS     R1,0                    :For port 0
        LHI     R2,10                   :Message type hex 10 host status
        JAL     R4,SLOR                 :Start output to ORING
        LIS     R0,0                    :Null key
        JAL     R4,PUTCH
        LHI     R0,HOSTNO               :CMT host number
        JAL     R4,PUTH
        LHI     R0,NCCB                 :Number of users supported
        JAL     R4,PUTH
        LIS     R0,0                    :Relative host number 0
                                        :Status 0 - host answered
                                        :Host key 0
        JAL     R4,PUTW
        LHI     R0,PRODID	        :Product Id
        JAL     R4,PUTH
        JAL     R4,ELOR                 :End the status report
        JR      R5                      :Return
:
:

        SUBTTL ACTIVN routine ... Action needle messages
:
: Routine name  ACTIVN
:
: Function      Action needle control message. Needle received when
:               user logs to CMT. Create CCCB and allocate buffers. 
:               Find user profile. Start DCB at LOGON routine.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number in R1
:               Number of characters in username in R2
:
: On exit       No registers will have been preserved
:
: Uses          GETCH, GETH, GETW in FRING.LIB
:               GETIOB, GETCCB in CBDEF
:               INIDCB in this module
:
: ---------------------------------------------------------------------
:
        DEFGEQ(ACTIVN,.)
        TRACK(ACTIVN)
        LR      R3,R1                   :Move port number to R3
        SLLS    R1,2                    :Get inactive DCB address
        L       R12,PORTAB,R1
        L       R13,DSTCKP,R12          :Get inactive DCB stack
        PUSH(R5)
:
        CALL(GETCCB)                    :Get a CCB 
        LR      R11,R5                  :Standard is R11 equals CCB
:
: Set up CCB to initial values
:
        LIS     R1,0
        ST      R1,CHDCB,R11            :Flag no host DCB
        ST      R1,CPDCB,R11            :   or printer DCB
        ST      R1,CBITS,R11            :Clear all bit flags
        ST      R1,CUPROF,R11           :   or user profile table
	ST	R1,CCRBBF,R11
	LHI	R1,C.LOGN
	SBT	R1,CBITS,R11
:
: Now extract first 8 characters of username and save in CCB. If there are 
: less than 8 then we fill with nulls (hex 80). This code is copied from
: CMT/3270. Remember, R2 contains no of characters in username! 
:
        LCS     R6,8                    :Bring in up to 8 characters
        JAL     R4,GETCH,,              :   of the username
        OHI     R0,80                   :Ensure mark parity
        CHI     R0,0A1
        JN      ACTN10                  :J if not override logon char
        JAL     R4,GETCH,,              :Next character
        OHI     R0,80
        SIS     R2,1
:
ACTN10  CHI     R0,A.SEMI+80            :Check for terminating semicolon
        JE      ACTN20
        CHI     R0,A.CR!80              :Check for terminating CR's
        JE      ACTN20
        STB     R0,CUNAME+8,R11,R6      :Save character in CCB
        AIS     R6,1                    :Out of output space?
        JE      ACTN50
ACTN20  SIS     R2,1                    :Out of input data?
        JEFS    ACTN30
        JAL     R4,GETCH,,              :Next character
        OHI     R0,80                   :Ensure mark parity
        J       ACTN10
:
ACTN30  LHI     R0,80                   :We ran out of input data first
ACTN40  STB     R0,CUNAME+8,R11,R6      :Fill in with 80's
        AIS     R6,1
        JNBS    ACTN40
        JFS     ACTN60
ACTN50  SIS     R2,1                    :Ran out of space flush
        JLEFS   ACTN60                  :away balance of msg
        LR      R0,R2                   :and proceed
        JAL     R4,FLUSH,,
:
: Now set up an active DCB to control this port
:
ACTN60  LA      R4,LOGST,,              :Start DCB running at LOGST
        CALL(INIDCB)                    :Create and initialise DCB
	LHI	R0,DTTPRT
	STH	R0,DTYPE,R5
        ST      R5,CTDCB,R11            :R5 is DCB address from INIDCB
        LA      R0,DATACT               :Load new data activation address
        STH     R0,DDACT,R5
        LA      R0,ACTCLT               :Load new control message table
        STH     R0,DCACT,R5
        SLHLS   R3,2                    :Convert port into FW index
        ST      R5,PORTAB,R3            :Make this the DCB for port
        POP(R5)                         :Restore link register
        JR      R5                      :Return to FRNTND

        SUBTTL ACTIVP routine ... Process pseudo needle
:
: Routine name  ACTIVP
:
: Function      Action a pseudo needle message. Use local key to find
:               DCB and check that needle is still valid. If it is 
:               we must set up ACP, TOISIS, FRISIS and XLIMIT arrays
:               as FRNTND doesn't do so for pseudo needles. We then
:               re-activate DCB.
:               Otherwise zap the needle.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number in R1
:               DCB address is in R12
:
: On exit       All registers will have been preserved
:
: Uses          GETCH, GETH in FRING
:
: ---------------------------------------------------------------------
:
        DEFGEQ(ACTIVP,.)
        SBT     R1,ACP                  :Test and set active port bit
        JEFS    ACTP20                  :Jump if inactive
        CRUNCH(CRINVP)                  :Crash invalid pseudo needle
:
ACTP20  JAL     R4,GETCH,,              :Get past ISIS - Tymnet key
        JAL     R4,GETH,,               :Get local key - requesting DCB
        LHI     R9,DCBSIZ
        MHR     R0,R9                   :Convert key into DCB address
        AI      R0,DCBLKS
        LR      R12,R0
        LHL     R0,DSUSP,R12
        CHI     R0,SUSPN                :Are we waiting for pseudo needle
        JN      ACTP80                  :If not then jump to zap it
        LHI     R0,9D                   :Set default transmit limit
        STB     R0,XLIMIT,R1
        STH     R0,DXLIM,R12
        SBT     R1,TOISIS               :Clear backpressure
        SBT     R1,FRISIS
        STH     R1,DPORT,R12            :Store port number in DCB
        LA      R0,DATACT               :Load new data activation address
        STH     R0,DDACT,R12
        LA      R0,ACTCLH               :Load new control message table
        STH     R0,DCACT,R12
:
        SLHLS   R1,2                    :Convert port into index
        ST      R12,PORTAB,R1           :Link this DCB to the port
        LIS     R0,0
        STH     R0,DSUSP,R12            :Clear suspension
        LHL     R0,DCBNO,R12
        SBT     R0,RUNREQ               :Mark for running
        JR      R5                      :Return to FRNTND
:
: Deal with pseudo needle for DCB not waiting
:
ACTP80  CRUNCH(CRNOCO)

        SUBTTL INIDCB routine ... Initialise a DCB 
:
: Routine name  INIDCB
:
: Function      Initialise a DCB for a newly active port.
:
: Called by     ACTIVN in this module
:               LOGST in TERM
:
: On entry      Link register R1
:               Port number in R3
:               User code address in R4
:
: On exit       DCB address in R5
:
: Uses          DCBGET in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(INIDCB)
        CALL(DCBGET)
        LA      R1,DSTCK+$A40,R5        :Initialise stack
        ST      R1,DSTCKP,R5
        ST      R11,DCCB,R5             :DCB points to CCB
        STH     R3,DPORT,R5             :Associated port
        LIS     R1,0
        STH     R1,DBITS,R5             :Initialise control bits
        STH     R1,DSUSP,R5             :Not waiting
        ST      R1,DCRBBF,R5            :No card buffer
        STH     R1,DRXCNT,R5            :Receive buffer count zero
        LHI     R1,DMLGST
        STH     R1,DMODE,R5             :Logon start up mode
        LB      R1,XLIMIT,R3
        STH     R1,DXLIM,R5             :Transmit limit
:
        LA      R1,DNETIP,R5            :Set network input buffer ring empty
        ST      R1,CHNFWD,R1
        ST      R1,CHNBWD,R1
        LA      R1,DNETOP,R5            :Set network output buffer empty
        ST      R1,CHNFWD,R1
        ST      R1,CHNBWD,R1
        LA      R1,DIPBIA,R5            :Set IPB input buffer ring empty
        ST      R1,CHNFWD,R1
        ST      R1,CHNBWD,R1
        LA      R1,DIPBOP,R5            :Set IPB output buffer empty
        ST      R1,CHNFWD,R1
        ST      R1,CHNBWD,R1
        LHL     R1,DCBNO,R5             :DCB number
        SBT     R1,RUNREQ               :Mark for running
        ST      R4,DUSR,R5              :Save user start address
        RETURN

        SUBTTL DATACT routine ... Data activation routine
:
: Routine name  DATACT
:
: Function      Process data message received for an active port.
:               Store in input buffer and if DCB waiting input then
:               mark for running. If port is inactive we only 
:               FLUSH message.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message size in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          GETIOB in CBDEF
:               FLUSH, GETCH in FRING
:
: ---------------------------------------------------------------------
:
        DEFGEQ(DATACT,.)
        TBT     R1,ACP  
        JNFS    ACTD10                  :Jump if port is active
        LR      R0,R2                   :Count of bytes in message
        JAL     R4,FLUSH,,              :Throw message away
        J       ACTD80                  :Return
:
ACTD10  AHM     R2,DRXCNT,R12           :Increment receive buffer count
        L       R13,DSTCKP,R12          :Get stack pointer
        PUSH(R5)                        :Save link
        LA      R4,DNETIP,R12
        L       R5,CHNBWD,R4            :Have we got a buffer
        CR      R4,R5   
        JEFS    ACTD20                  :Jump if we have none
        LB      R3,BFILL,R5             :Current fill pointer
        J       ACTD40                  :Put data in buffer
:
ACTD20  CALL(GETIOB)                    :Get a buffer in R5
        L       R3,CHNBWD,R4
        ST      R5,CHNBWD,R4            :Chain it to input ring
        ST      R5,CHNFWD,R3
        ST      R4,CHNFWD,R5
        LIS     R3,0                    :Initialise pointers
        STB     R3,BFILL,R5
        STB     R3,BEMPTY,R5
:
ACTD40  LR      R2,R2
        JE      ACTD60                  :Jump if end of input
        JAL     R4,GETCH,,              :Get next character from ORING
	LHL	R1,DTYPE,R12
	CHI	R1,DTTCRD
	JG	ACTD50			:J if not terminal data otherwise
         NHI     R0,7F                   :Make sure top bit is clear
ACTD50  STB     R0,BDATA,R5,R3          :Put data in buffer
        SIS     R2,1                    :Reduce character count
        AIS     R3,1                    :Increment fill pointer
        CHI     R3,BSIZE-BDATA
        JN      ACTD40                  :Buffer not full get next character
        STB     R3,BFILL,R5             :Save fill pointer
        LA      R4,DNETIP,R12           :Head of chain
        J       ACTD20                  :Get new buffer
:
ACTD60  STB     R3,BFILL,R5             :Save fill pointer
        LHL     R5,DRXCNT,R12           :Number of characters in input buffer
        CHI     R5,BPONL
        JL      ACTD70                  :J if below back pressure limit
        LHL     R5,DPORT,R12
        RBT     R5,FRISIS
        JE      ACTD70                  :J if already backpressured
        CALL(SNDBPO)                    :Apply back pressure
ACTD70  POP(R5)                         :Restore link register
        ST      R13,DSTCKP,R12          :Save stack pointer
        LHL     R3,DSUSP,R12            :Is this DCB waiting input
        CHI     R3,SUSIP
        JN      ACTD80                  :Jump if not
        LIS     R3,0                    :Mark as not waiting
        STH     R3,DSUSP,R12
        LHL     R3,DCBNO,R12            :Mark as runnable
        SBT     R3,RUNREQ
ACTD80  JR      R5                      :Return

        SUBTTL ACTIVM routine ... Control message activation routine
:
: Routine name  ACTIVM
:
: Function      Process control messages received for an active port.
:               Store in input buffer and if DCB waiting input then
:               mark for running. Routine is completed at ACTD60 in
:               DATACT.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          GETIOB in CBDEF
:               GETCH in FRING
:
: ---------------------------------------------------------------------
:
: Note we have to take into account that first character (Message type)
: is already extracted from ring in R2. We move it to R0 and then check
: if we have space for it. We must then extract the next character,
: if one exists, before checking if we have space for it.
:
        DEFGEQ(ACTIVM,.)
ACTM10  L       R13,DSTCKP,R12          :Get stack pointer
        PUSH(R5)                        :Save link
        LR      R0,R2                   :Save message type in R0
        LB      R2,LENGTH,R2,           :Get length of message
	AHM	R2,DRXCNT,R12
        LA      R4,DNETIP,R12
        L       R5,CHNBWD,R4            :Have we got a buffer
        CR      R4,R5   
        JEFS    ACTM20                  :Jump if we have none
        LB      R3,BFILL,R5             :Current fill pointer
        J       ACTM40                  :Put message in buffer
:
ACTM20  CALL(GETIOB)                    :Get a buffer in R5
        L       R3,CHNBWD,R4
        ST      R5,CHNBWD,R4            :Chain it to input ring
        ST      R5,CHNFWD,R3
        ST      R4,CHNFWD,R5
        LIS     R3,0                    :Initialise pointers
        STB     R3,BFILL,R5
        STB     R3,BEMPTY,R5
:
ACTM40  LR      R2,R2
        JE      ACTD60                  :Jump if end of input
        STB     R0,BDATA,R5,R3          :Put message in buffer
        SIS     R2,1                    :Reduce character count
        JE      ACTM50                  :Jump if end of message
        JAL     R4,GETCH,,              :Get next character from ORING
ACTM50  AIS     R3,1                    :Increment fill pointer
        CHI     R3,BSIZE-BDATA
        JN      ACTM40                  :Buffer not full get next character
        STB     R3,BFILL,R5             :Save fill pointer
        LA      R4,DNETIP,R12           :Head of chain
        J       ACTM20                  :Get new buffer

        SUBTTL ACTIVZ routine ... Circuit zapped message
:
: Routine name  ACTIVZ
:
: Function      Process zapped circuit (9E) and detach (9F) control messages.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
ACTIVZ  SLHLS   R1,2                    :Find DCB
        L       R12,PORTAB,R1
:       LIS     R0,0
:       STH     R0,DPORT,R12            :Indicate no port
        LHL     R3,DTYPE,R12
        LA      R0,ENDIT,,              :If term zapped, go to ENDIT it TERM
:       CHI     R3,DTTCRD
:       JLE     ACTZ10                  :J if lost terminal circuit
:       LA      R0,RESTAR,,             :Restart routine in TERM
ACTZ10  ST      R0,DUSR,R12
        LIS     R0,0
        STH     R0,DSUSP,R12            :Clearing waiting state
        LHL     R9,DCBNO,R12
        SBT     R9,RUNREQ               :Mark for running
        LA      R13,DSTCK,R12           :Reset stack with zapped message on it
        LA      R4,ZAPMES
        PUSH(R0,R1,R2,R3,R4,R5,R6,R7)
        PUSH(R8,R9)
        JR      R5                      :return to FRNTND

        SUBTTL SETXLT routine ... Set transmit limit message handler
:
: Routine name  SETXLT
:
: Function      Process set transmit limit control message (B9) for
:               active port. Update the limit held in XLIMIT array and
:               DCB. 
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          GETCH in FRING
:
: ---------------------------------------------------------------------
:
        DEFGEQ(SETXLT,.)
        JAL     R4,GETCH,,              :Get limit character from ORING
        STB     R0,XLIMIT,R1            :Store in limit array
        TBT     R1,TOISIS
        JE      SETX20                  :If backpressured don't touch DCB
        STH     R0,DXLIM,R12            :Store in DCB
SETX20  JR      R5                      :Return to FRNTND

        SUBTTL BPON routine ... Process apply backpressure message
:
: Routine name  BPON
:
: Function      Process apply backpressure control message (A0) for
:               active port. Update the array TOISIS and set the transmit
:               limit in the DCB to zero. 
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        DEFGEQ(BPON,.)
        RBT     R1,TOISIS               :Mark as backpressured
        JR      R5                      :Return to FRNTND

        SUBTTL BPOFF routine ... Process release backpressure message
:
: Routine name  BPOFF
:
: Function      Process release backpressure control message (A1) for
:               active port. Update the array TOISIS and set the transmit
:               limit in the DCB to value held in XLIMIT array. If DCB
:               is suspended awaiting release of backpressure then activate
:               it.
:
: Called by     FRNTND
:
: On entry      Link register R5
:               Port number R1
:               Message type in R2
:               DCB address in R12
:
: On exit       Registers will not have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        DEFGEQ(BPOFF,.)
	PAUSE(BACKPRESSURE OFF)
        SBT     R1,TOISIS               :Mark as backpressure cleared
        LHL     R0,DSUSP,R12            :Waiting reason
        CHI     R0,SUSBP
        JN      BPOF20                  :J if not waiting release of BP
        LIS     R0,0                    :Mark as not waiting
        STH     R0,DSUSP,R12
        LHL     R0,DCBNO,R12            :Mark as runnable
        SBT     R0,RUNREQ
BPOF20  JR      R5                      :Return to FRNTND

        SUBTTL EMPTYI/EMPTYO routine ... Empty buffers on zap
:
: Routine name  EMPTYI/EMPTYO
:
: Function      Empty input I/O buffer. Called by FRNTND when it 
:               receives a zap for a circuit. Does nothing.
:
: Called by     FRNTND
:
: On entry      Link register R5
:
: On exit       No registers will have been preserved
:
: Uses          GETCH, GETH, GETW in FRING.LIB
:               
:
: ---------------------------------------------------------------------
:
EMPTYI  EQ      .
EMPTYO  JR      R4                      :No code yet so crash

        SUBTTL SNDSTP routine ... Send set terminal parameter
:
: Routine name  SNDSTP
:
: Function      To send a set terminal parameter
:
: Called by     LOGST
:
: On entry      Link register R1
:               Parameter pair as halfword in R5
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, PUTCH, ELOR in FRING
:
: ---------------------------------------------------------------------
:
        RSTART(SNDSTP)
        PUSH(R0,R2,R3,R4)               :Save registers
        LIS     R0,4                    :Message length
        LHL     R1,DPORT,R12            :Port 
        LHI     R2,0B1                  :Message type (normal logon char)
        JAL     R4,SLOR,,
        LR      R0,R5                   :Parameter pair
        SRHL    R0,8
        JAL     R4,PUTCH,,
        LR      R0,R5                   :Second parameter
        JAL     R4,PUTCH,,
        JAL     R4,ELOR,,               :End output
        POP(R4,R3,R2,R0)                :Restore registers
        RETURN

        SUBTTL SNDPNR routine ... Request pseudo needle
:
: Routine name  SNDPNR
:
: Function      To send a pseudo needle request to slot 0.
:
: Called by     LOGST
:
: On entry      Link register R1
:               Local key in R5
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, PUTCH, PUTH, ELOR in FRING
:
: ---------------------------------------------------------------------
:
        RSTART(SNDPNR)
        PUSH(R0,R2,R3,R4)               :Save registers
        LIS     R0,0B                   :Message length
        LIS     R1,0                    :Port zero
        LIS     R2,7                    :Message type (request pseudo needle)
        JAL     R4,SLOR,,               :Start output
        LIS     R0,0                    :Despatcher key
        JAL     R4,PUTCH,,
        LR      R0,R5                   :Local key
        JAL     R4,PUTH,,
        LHI     R0,8000!4000            :Intelligent & extended login status
        JAL     R4,PUTH,,
        LHI     R0,HOSTNO               :We are originating host
        JAL     R4,PUTH,,
        LHI     R0,0D1                  :Circuit characteristic type
        JAL     R4,PUTCH,,
        JAL     R4,ELOR,,               :End output
        POP(R4,R3,R2,R0)                :Restore registers
        RETURN

        SUBTTL SNDNLC routine ... Send normal logon character
:
: Routine name  SNDNLC
:
: Function      To send a normal logon character to the network
:
: Called by     LOGST
:
: On entry      Link register R1
:               Logon character in R5
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, PUTCH, ELOR in FRING
:
: ---------------------------------------------------------------------
:
        RSTART(SNDNLC)
        PUSH(R0,R2,R3,R4)               :Save registers
        LIS     R0,4                    :Message length
        LHL     R1,DPORT,R12            :Port 
        LHI     R2,0B3                  :Message type (normal logon char)
        JAL     R4,SLOR,,
        LR      R0,R5                   :Logon character
        OHI     R0,80                   :Set top bit
        JAL     R4,PUTCH,,
        JAL     R4,ELOR,,               :End output
        POP(R4,R3,R2,R0)                :Restore registers
        RETURN

        SUBTTL ECHOFF routine ... Send echo off
:
: Routine name  ECHOFF
:
: Function      Send echo off set terminal parameter messages
:
: Called by     REJECT
:
: On entry      Link register R1
:
: On exit       All registers will have been preserved
:
: Uses          SNDSTP in this module
:
: ---------------------------------------------------------------------
:
        RSTART(ECHOFF)
        PUSH(R5)
        LIS     R5,0                    :Set echo off parameter pair
        CALL(SNDSTP)                    :Send set termianl parameter
        POP(R5)                         :Restore register
        RETURN

        SUBTTL ECHON routine ... Send echo off
:
: Routine name  ECHON
:
: Function      Send echo on set terminal parameter message
:
: Called by     REJECT
:
: On entry      Link register R1
:
: On exit       All registers will have been preserved
:
: Uses          SNDSTP in this module
:
: ---------------------------------------------------------------------
:
        RSTART(ECHON)
        PUSH(R5)
        LIS     R5,1                    :Set echo on parameter pair
        CALL(SNDSTP)                    :Send set termianl parameter
        POP(R5)                         :Restore register
        RETURN

        SUBTTL SNDZAP/SNDDET routine ... Zap circuit 
:
: Routine name  SNDZAP/SNDDET
:
: Function      To send a zap for a circuit, discard input and output 
:               buffers associated with it and rest PORTAB to point to
:               idle DCB.
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, ELOR in FRING
:
: ---------------------------------------------------------------------
        RSTART(SNDDET)
        LHI     R1,09E                  :Zap code
        J       SNDZ05
:
        RSTART(SNDZAP)
        LHI     R1,09F                  :Zap code
SNDZ05  PUSH(R0,R2,R3,R4,R5)
        LR      R2,R1                   :Message type in R2 for SLOR
        LA      R4,DNETIP,R12           :Free network input buffers
        ST      R4,CHNBWD,R4
SNDZ10  L       R5,CHNFWD,R4
        CR      R5,R4
        JE      SNDZ20
        L       R1,CHNFWD,R5            :Take buffer out
        ST      R1,CHNFWD,R4
        CALL(PUTIOB)                    :Return to free chain
        J       SNDZ10
SNDZ20  LA      R4,DNETOP,R12           :Free network output buffers
        ST      R4,CHNBWD,R4
        LHI     R1,D.OUTN
        RBT     R1,DBITS,R12            :Clear output open bit
SNDZ30  L       R5,CHNFWD,R4
        CR      R5,R4
        JE      SNDZ40
        L       R1,CHNFWD,R5            :Take buffer out
        ST      R1,CHNFWD,R4
        CALL(PUTIOB)                    :Return to free chain
        J       SNDZ30
SNDZ40  LIS     R0,3                    :Message length
        LHL     R1,DPORT,R12            :Port
        JAL     R4,SLOR,,               :Start message
        JAL     R4,ELOR,,               :End message
        RBT     R1,ACP                  :Mark port as inactive
        RBT     R1,DEM
        SLHLS   R1,2
        LA      R0,DCBLKS,,             :Address of idle port DCB
        ST      R0,PORTAB,R1            
        LIS     R1,0
        STH     R1,DPORT,R12            :Set port to zero
        POP(R5,R4,R3,R2,R0)
        RETURN

        SUBTTL SND routines ... Output control messages 
:
: Routine name  SNDGB, SNDRB, SNDGRB, SNDSIX, SNDTIX, SNDBPO, SNDBPX
:
: Function      To send a control message to ORING:
:                  SNDGB - send green ball
:                  SNDRB - send red ball
:                  SNDGRB - send grey ball
:                  SNDSIX - send start IIX
:                  SNDTIX - send end IXX
:                  SNDBPO - Send back pressure on
:                  SNDBPX - Send back pressure off
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       All registers will have been preserved
:
: Uses          SLOR, ELOR in FRING
:
: ---------------------------------------------------------------------
:
: Green ball
:
        RSTART(SNDGB)
        LHI     R1,0AA                  :Green ball
        J       OUTLOR
:
: Red ball
:
        RSTART(SNDRB)
        LHI     R1,0AB                  :Red ball
        J       OUTLOR
:
: Grey ball
:
        RSTART(SNDGRB)
        LHI     R1,0A5                  :Grey ball
        J       OUTLOR
:
: Start IIX
:
        RSTART(SNDSIX)
        LHI     R1,0BF                  :SIIX
        J       OUTLOR
:
: End IIX
:
        RSTART(SNDTIX)
        LHI     R1,0C0                  :TIIX
        J       OUTLOR
:
: Back pressure on
:
        RSTART(SNDBPO)
        LHI     R1,0A0                  :Grey ball
        J       OUTLOR
:
: Back pressure off
:
        RSTART(SNDBPX)
        LHI     R1,0A1                  :Grey ball
        J       OUTLOR
:
: Common code to create the above messages
:
OUTLOR  PUSH(R0,R2,R3,R4)               :Save registers used by FRING
        LIS     R0,3                    :Message length
        LR      R2,R1                   :Message type
        LHL     R1,DPORT,R12            :Port
        JAL     R4,SLOR,,               :Start message
        JAL     R4,ELOR,,               :End message
        POP(R4,R3,R2,R0)                :Restore registers
        RETURN
:
        SEG     A.DATA
ZAPMES  SC      /Circuit to host interface lost/
:
        EM


        SUBTTL INOUT ... Input and output interface

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 DEC 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,INOUT                 :Delimit module
:
: This module contains the routines that handle the input and output
: buffers for the higher level code.
:
:       READN - Read character from network input buffer
:       READIA - Read character from IPB input buffer A
:       READIB - Read character from IPB input buffer B
:       OPENN - Open network output channel
:       OPENI - Open IPB output channel
:       WRITBN - Write byte to network output channel
:       WRITED - Write decimal value to network
:       WRITSN - Write string to network output channel
:       CLOSEN - Close network output channel
:       WRITBI - Write byte to IPB output channel
:       WRITSI - Write string to IPB output channel
:       CLOSEI - Close IPB output channel
:
: The following routines are used internally:
:
:       OUTREC - Output record to network
:
: There are no macros unique to this module.
        SUBTTL READN routine ... Read character from network input buffer
:
: Routine name  READN
:
: Function      Read a character from network input buffer. If character
:               read is in last position in buffer, return the buffer to
:               the pool
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       Character returned in R0. 
:               If data available return + 4.
:               If buffer empty then return + 0.
:
: Uses          PUTIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(READN)
        PUSH(R2,R5)
        LA      R1,DNETIP,R12           :Network buffer
        L       R5,CHNFWD,R1            :Address of input buffer
        CR      R5,R1                   :No buffers?
        JE      READ90                  :Jump if none
        LB      R2,BEMPTY,R5
        CLB     R2,BFILL,R5             :Empty offset = Fill offset?
        JE      READ90                  :Jump if buffer empty
:
        LB      R0,BDATA,R5,R2          :Remove character
        AIS     R2,1                    :Move empty pointer
        STB     R2,BEMPTY,R5
        CHI     R2,BSIZE-BDATA          :Has this buffer been used up
        JNFS    READ80                  :Jump if not
        L       R2,CHNFWD,R5            :Remove from input buffer chain
        ST      R2,CHNFWD,R1
        CR      R2,R1
        JNFS    READ70                  :J if chain not empty
        ST      R1,CHNBWD,R1            :Mark chain as empty
READ70  CALL(PUTIOB)                    :Return to free chain, address in R5
:
READ80  LHL     R1,DRXCNT,R12           :Count of data in chain
        SIS     R1,1
        STH     R1,DRXCNT,R12
        LHL     R5,DPORT,R12
        TBT     R5,FRISIS
        JN      READ85                  :J if backpressure off
        CHI     R1,BPOFFL
        JG      READ85                  :J if not less than BP off limit
        CALL(SNDBPX)                    :Send release back presssure
        SBT     R5,FRISIS               :Indicate back pressure off
READ85  POP(R5,R2)                      :Return data available
        RETURN(SKIP)
:
READ90  POP(R5,R2)                      :Return buffer empty
        RETURN
        SUBTTL READIA/READIB routine ... Read byte from IPB input buffer
:
: Routine name  READIA/READIB
:
: Function      Read a character from IPB input buffer. If buffer is
:               empty after read then return buffer to pool.
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       Character returned in R0. 
:               If data available return + 4.
:               If buffer empty then return + 0.
:
: Uses          PUTIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(READIA)
        LA      R1,DIPBIA,R12
:
        PUSH(R2,R5)
        L       R5,CHNFWD,R1            :Address of input buffer
        CR      R5,R1                   :No buffers?
        JE      REAI90                  :Jump if none
        LB      R2,BEMPTY,R5
        CLB     R2,BFILL,R5             :Empty offset = Fill offset?
        JE      REAI90                  :Jump if buffer empty
:
        LB      R0,BDATA,R5,R2          :Remove character
        AIS     R2,1                    :Move empty pointer
        STB     R2,BEMPTY,R5
        CLB     R2,BFILL,R5             :Has this buffer been used up
        JLFS    REAI80                  :Jump if not
        L       R2,CHNFWD,R5            :Remove from input buffer chain
        ST      R2,CHNFWD,R1
        CR      R2,R1
        JNFS    REAI70                  :J if chain not empty
        ST      R1,CHNBWD,R1            :Mark chain as empty
REAI70  CALL(PUTIOB)                    :Return to free chain, address in R5
:
REAI80  POP(R5,R2)                      :Return data available
        RETURN(SKIP)
:
REAI90  POP(R5,R2)                      :Return buffer empty
        RETURN
        SUBTTL OPEN routine ... Open output channel
:
: Routine name  OPENN, OPENI
:
: Function      Open an output channel.
:               OPENN - Open channel to Tymnet network.
:               OPENI - Open IPB channel. 
:               Gets a IOB buffer and initialises it.
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       IOB buffer will be chained to DCB. 
:
: Uses          GETIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(OPENN)
        PUSH(R2,R5)
        LHI     R1,D.OUTN
        SBT     R1,DBITS,R12            :First check no buffer allocated
        JN      OPEN90
        LA      R2,DNETOP,R12           :Network output buffer
        J       OPEN20
:
        RSTART(OPENI)
        PUSH(R2,R5)
        LHI     R1,D.OUTI
        SBT     R1,DBITS,R12            :First check no buffer allocated
        JN      OPEN90
        LA      R2,DIPBOP,R12           :IPB output buffer
:
OPEN20  CALL(GETIOB)                    :Get an IOB buffer, in R5
        ST      R2,BLINK,R5             :Point buffer to DCB
        ST      R5,CHNFWD,R2            :Point DCB to buffer
        ST      R5,CHNBWD,R2
        LIS     R1,0
        STB     R1,BFILL,R5             :Initialise fill
        STB     R1,BEMPTY,R5            :  and empty pointers
        POP(R5,R2)
        RETURN
:
OPEN90  CRUNCH(CROBAA)                  :Crash output buffer already allocated
:

        SUBTTL WRITBN routine ... Write byte to output channel
:
: Routine name  WRITBN
:
: Function      Write byte to a network output channel.
:               Put character in output buffer. If buffer contains the
:               maximum number of characters that can be sent on this
:               circuit then write to ORING. If backpressured then
:               will suspend.
:
: Called by     The world
:
: On entry      Link register R1
:               Character to be written in R4
:
: On exit       
:
: Uses          OUTREC in this module
:
: ---------------------------------------------------------------------
:
        RSTART(WRITBN)
        PUSH(R4,R5)
        LHI     R1,D.OUTN
        TBT     R1,DBITS,R12            :Is channel open?
        JE      WRIB90
:
        L       R5,DNETOP,R12           :Get address of output buffer
        LB      R1,BFILL,R5             :Current fill pointer
        STB     R4,BDATA,R5,R1          :Store character in buffer
        AIS     R1,1                    :Move pointer
        STB     R1,BFILL,R5
        CLH     R1,DXLIM,R12            :Is this record the largest that
        JLFS    WRIB80                  :can be sent. Jump if it is not
WRIB70  CALL(OUTREC)                    :Output record
:
WRIB80  POP(R5,R4)
        RETURN
:
WRIB90  CRUNCH(CROBNO)                  :Crash output buffer not opened

        SUBTTL WRITED routine ... Write decimal value to output channel
:
: Routine name  WRITED
:
: Function      Write decimal value to an output channel to Tymnet network. 
:               Convert binary value to two character decimal. If tens
:               are zero then they are not output.
:
: Called by     MCVT1
:
: On entry      Link register R1
:               Character to be converted in R5
:
: On exit       
:
: Uses          WRITEB in this module
:
: ---------------------------------------------------------------------
:
        RSTART(WRITED)
        PUSH(R3,R4)                     :Save registers
        LR      R3,R5
        JE      WRID80                  :Do not output if zero
        LIS     R1,$A 10
        DHR     R3,R1                   :Convert to tens and units
        LR      R4,R4                   :Are tens zero
        JEFS    WRID40                  :If so don't output
        AHI     R4,A.0                  :Convert to ASCII
        CALL(WRITBN)                    :Output
WRID40  LR      R4,R3                   :Units
        AHI     R4,A.0                  :Convert to ASCII
        CALL(WRITBN)
WRID80  POP(R4,R3)                      :Restore registers
        RETURN

        SUBTTL WRITSN routine ... Write string to output channel
:
: Routine name  WRITSN
:
: Function      Write string to an output channel to Tymnet network. Put
:               characters in output buffer. If buffer contains the
:               maximum number of characters that can be sent on this
:               circuit then write to ORING. If backpre sured then
:               will suspend.
:               **** Warning, this routine removes the top bit of each
:                    character in the string to deal with NAD SC strings.
:                    If top bit is required, for example for IIX messages,
:                    then WRITBN should be used. ************
:
: Called by     The world
:
: On entry      Link register R1
:               Address of string to be written in R4
:
: On exit       
:
: Uses          OUTREC in this module
:
: ---------------------------------------------------------------------
:
        RSTART(WRITSN)
        PUSH(R2,R3,R4,R5)               :Save registers
        LHI     R1,D.OUTN
        TBT     R1,DBITS,R12            :Is channel open?
        JE      WRIS95
:
        L       R5,DNETOP,R12           :Get address of output buffer
        LR      R2,R4                   :Pointer to string
        JE      WRIS90                  :J if empty string
        LB      R3,0,R2                 :Size of string
        LB      R1,BFILL,R5             :Current fill pointer
WRIS40  LB      R4,1,R2                 :Next character
        NHI     R4,7F                   :Remove top bit
        JE      WRIS90                  :J if invalid data
        STB     R4,BDATA,R5,R1          :Store character in buffer
        AIS     R1,1                    :Move pointer
        CLH     R1,DXLIM,R12            :Is this record the largest that
        JGEFS   WRIS60                  :can be sent. Jump if it is
WRIS50  AIS     R2,1                    :Next character in string
        SIS     R3,1                    :Reduce string count
        JNBS    WRIS40                  :Jump if more data
        STB     R1,BFILL,R5             :Tidy up buffer
        JFS     WRIS80                  :End routine
WRIS60  STB     R1,BFILL,R5
        CALL(OUTREC)                    :Output record
        LB      R1,BFILL,R5
        JBS     WRIS50                  :Continue
:
WRIS80  POP(R5,R4,R3,R2)
        RETURN
:
WRIS90  CRUNCH(CRINVD)                  :Crash invalid data or null string
WRIS95  CRUNCH(CROBNO)                  :Crash output buffer not opened
        SUBTTL CLOSEN routine ... Close output channel
:
: Routine name  CLOSEN
:
: Function      Close an output channel to Tymnet network. 
:               If buffer contains characters then these are sent
:               to the ORING. The output buffer is then released.
:               Note that if backpressured then this routine will
:               suspend.
:
: Called by     The world
:
: On entry      Link register R1
:
: On exit       
:
: Uses          OUTREC in this module
:               PUTIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(CLOSEN)
        PUSH(R5)
        LHI     R1,D.OUTN
        RBT     R1,DBITS,R12            :Is channel open?
        JE      CLOS90
:
        L       R5,DNETOP,R12           :Output buffer address
        LB      R1,BFILL,R5             :Any data in buffer
        JEFS    CLOS80                  :Jump if none
        CALL(OUTREC)                    :Output data to ORING
:
CLOS80  CALL(PUTIOB)                    :Free buffer R5 points to it
        LA      R5,DNETOP,R12
        ST      R5,CHNFWD,R5            :Write buffer chain empty
        ST      R5,CHNBWD,R5
        POP(R5)
        RETURN
CLOS90  CRUNCH(CROBNO)                  :Crash output buffer not opened
        SUBTTL OUTREC routine ... Write record to ORING
:
: Routine name  OUTREC
:
: Function      Write a record to the ORING using OCS. If backpressured
:               we must suspend until it is cleared. We only write up to
:               DXLIM of data and then do a voluntary suspend to allow 
:               data to reach  other end of circuit. We will loop until
:               all data has been sent.
:
: Called by     WRITBN, WRITSN, CLOSEN in this module
:
: On entry      Link register R1
:               Address of output buffer in R5
:
: On exit       IOB buffer will be empty.
:
: Uses          OCS in FRING
:
: ---------------------------------------------------------------------
:
:
: We now have a record to be sent to network. We use OCS to put data in
: ring which expects message in SC format (count followed by data).
: This routine assumes that BEMPTY is before BDATA and that record
: starts at BDATA. If this code appears to be hairy, you should try
: CMT/3270! The Californian wine and women are starting to get to me.
:
        RSTART(OUTREC)
        PUSH(R0,R2,R3,R4,R5)            :Save registers destroyed by OCS
OUTR10  LHL	R2,DPORT,R12		:Check if backpressured
	TBT	R2,TOISIS
        JN      OUTR20                  :Jump if not backpressured
:
	LHL	R1,DTYPE,R12
	CHI	R1,DTTPRT
	JN	OUTR15
	LHI	R1,PS.BNA
	SBT	R1,CPSTAT,R11
:
	OPEN(IPBHST)
	LHI	R4,ISUPST
	WRITEB(IPBHST)
	LHL	R4,CPSTAT,R11
	NHI	R4,09
	OHI	R4,48
	WRITEB(IPBHST)
	LHI	R4,A.ETX
	WRITEB(IPBHST)
	CLOSE(IPBHST)
:
	LHI	R1,PS.BNA
	RBT	R1,CPSTAT,R11
	LHI	R1,PS.CT1
	SBT	R1,CPSTAT,R11
OUTR15	PAUSE(DCB BACKPRESSURED)
        SUS(SUSBP)                      :Suspend until backpressure cleared
        J       OUTR10                  :Try again
:
OUTR20  LHI	R1,D.NACT
	SBT	R1,DBITS,R12
	LR      R1,R5                   :Move buffer address to R1
OUTR30  LB      R0,BFILL,R1             :Number of characters available
	LHL     R2,DXLIM,R12            :Max size of message to be sent
        CR      R2,R0
        JGEFS   OUTR40                  :Jump if less than DXLIM
        LR      R0,R2                   :Otherwise write DXLIM
OUTR40  STB     R0,BEMPTY,R1            :Set up count for OUTREC
        LHL     R2,DPORT,R12            :Port number for OCS
        LA      R3,BEMPTY,R1            :Pointer to string
        PUSH(R5)
        JAL     R5,OCS,,                :Put in ORING
        SUS(SUSVD)                      :Voluntary dismiss
        POP(R5)
        LR      R1,R5                   :Get back buffer address
        LB      R3,BFILL,R1             :If we wrote less than BFILL
        LB      R2,BEMPTY,R1
        SR      R3,R2
        STB     R3,BFILL,R1             : we must move rest to front of buffer
        JLEFS   OUTR60                  :Jump if not required
:
OUTR50  LB      R0,BDATA,R1,R2          :Move rest of data to front of buffer
        STB     R0,BDATA,R1
        AIS     R1,1                    :Move down buffer
        SIS     R3,1
        JN      OUTR50
        J       OUTR10                  :Write out rest of record
:
OUTR60  LIS     R3,0
        STB     R3,BEMPTY,R1            :Tidy up BEMPTY
	LHI	R2,D.NACT
	RBT	R2,DBITS,R12
        POP(R5,R4,R3,R2,R0)             :Restore registers after OCM
        RETURN

        SUBTTL WRITBI routine ... Write byte to interprocess buffer
:
: Routine name  WRITBI
:
: Function      Write byte to the interprocess buffer. If buffer not
:               available or full then one is obtained and chained to
:               DIPBOP. The character is added to the end of the buffer.
:
: Called by     The world
:
: On entry      Link register R1
:               Character to be written in R4
:
: On exit       
:
: Uses          GETIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(WRITBI)
        PUSH(R2,R5)
        LHI     R1,D.OUTI
        TBT     R1,DBITS,R12            :Is channel open?
        JE      PUTB90                  :J if not
:
        LA      R2,DIPBOP,R12           :Get address of output buffer
        L       R5,CHNBWD,R2
        CR      R5,R2
        JEFS    PUTB20                  :J if no buffer present
        LB      R1,BFILL,R5             :Current fill pointer
        CHI     R1,BSIZE-BDATA          :Is buffer full
        JL      PUTB40                  :J if still room
:
PUTB20  PUSH(R3)
        LR      R3,R5
        CALL(GETIOB)
        ST      R5,CHNBWD,R2            :Put this block on end of chain
        ST      R5,CHNFWD,R3            :Chain old last to this one
        ST      R2,CHNFWD,R5            :Chain this to header
        POP(R3)
        LIS     R1,0
        STB     R1,BEMPTY,R5            :Initialise empty and fill ptrs
        STB     R1,BFILL,R5
:
PUTB40  STB     R4,BDATA,R5,R1          :Store character in buffer
        AIS     R1,1                    :Move pointer
        STB     R1,BFILL,R5
:
        POP(R5,R2)
        RETURN
PUTB90  CRUNCH(CROBNO)                  :Crash output buffer not opened

        SUBTTL WRITSI routine ... Write string to interprocess buffer
:
: Routine name  WRITSI
:
: Function      Write string to an interprocess buffer. Put
:               characters in output buffer. If buffer contains the
:               maximum number of characters then get a further buffer
:               and chain it.
:               Note top bit is cleared. This is because it can be set if
:               character came from NAD preset.
:
: Called by     The world
:
: On entry      Link register R1
:               Address of string to be written in R4
:
: On exit       All registers will have been preserved
:
: Uses          GETIOB in CBDEF
:
: ---------------------------------------------------------------------
:
        RSTART(WRITSI)
        PUSH(R2,R3,R4,R5)               :Save registers
        LHI     R1,D.OUTI
        TBT     R1,DBITS,R12            :Is channel open?
        JE      PUTS90
:
        LA      R5,DIPBOP,R12           :Get address of output buffer
        L       R5,CHNBWD,R5            :Last block of chain
        LR      R2,R4                   :Pointer to string
        LB      R3,0,R2                 :Size of string
        LB      R1,BFILL,R5             :Current fill pointer
PUTS40  LB      R4,1,R2                 :Next character
        NHI     R4,7F                   :Mask off top bit 
        STB     R4,BDATA,R5,R1          :Store character in buffer
        AIS     R1,1                    :Move pointer
        CHI     R1,BSIZE-BDATA          :Is buffer full
        JN      PUTS50                  :Jump if it is not
        STB     R1,BFILL,R5
        LR      R4,R5
        CALL(GETIOB)
        LA      R1,DIPBOP,R12           :Head of chain
        ST      R5,CHNBWD,R1            :Put this block on end of chain
        ST      R5,CHNFWD,R4            :Chain old last to this one
        ST      R1,CHNFWD,R5            :Chain this to header
        LIS     R1,0
        STB     R1,BEMPTY,R5            :Initialise empty and fill ptrs
        STB     R1,BFILL,R5
:
PUTS50  AIS     R2,1                    :Next character in string
        SIS     R3,1                    :Reduce string count
        JN      PUTS40                  :Jump if more data
        STB     R1,BFILL,R5             :Tidy up buffer
:
        POP(R5,R4,R3,R2)
        RETURN
PUTS90  CRUNCH(CROBNO)                  :Crash output buffer not opened
        SUBTTL CLOSEI routine ... Close output channel
:
: Routine name  CLOSEI
:
: Function      Close an interprocess output channel. 
:               The buffer chain is taken off this DCB and 
:               placed on the IPB input chain of the appropriate DCB.
:
: Called by     The world
:
: On entry      Link register R1
:               DCB type to receive interprocess buffer in R5
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(CLOSEI)
        PUSH(R2,R4,R5)
        LHI     R1,D.OUTI
        RBT     R1,DBITS,R12            :Is channel open?
        JE      CLOX90
:
        SIS     R5,1                    :Convert parameter into DCB address
        SLHLS   R5,2
        L       R5,CTDCB,R11,R5
        JE      CLOX80                  :Invalid no such DCB
        PUSH(R5)                        :Save it
: Should really check that its active
        LA      R4,DIPBOP,R12           :Output buffer address
        LA      R5,DIPBIA,R5            :Input buffer address
        L       R1,CHNFWD,R4            :Move IPB channel to input of new DCB
        L       R2,CHNBWD,R5
        ST      R1,CHNFWD,R2
        L       R1,CHNBWD,R4
        ST      R1,CHNBWD,R5
        ST      R5,CHNFWD,R1
        ST      R4,CHNFWD,R4            :Set output IPB chain empty
        ST      R4,CHNBWD,R4
        POP(R5)
        LHL     R1,DSUSP,R5             :Is new DCB waiting for input?
        CHI     R1,SUSIP
        JNFS    CLOX50                  :J if it isn't
        LIS     R1,0
        STH     R1,DSUSP,R5             :Clear suspension
        LHL     R1,DCBNO,R5
        SBT     R1,RUNREQ               :Mark for running
:
CLOX50  POP(R5,R4,R2)
        RETURN
:
CLOX80  CRUNCH(CRIPBF)                  :Crash IPB port non-existant
CLOX90  CRUNCH(CROBNO)                  :Crash output buffer not opened
:
        EM

        SUBTTL EXEC ... Share time allocation of slot

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 19 DEC 85|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,EXEC                  :Delimit module
:
: This module contains the time sharing executive 
: The slot is entered at START which is within this module
:
: It contains the following routines which are available externally
:
:       SUSPND - Suspend a DCB activity
:
: It contains the following routines which are used internally
:
:       RUNDCB - Start a DCB activity which is marked to be run
:
:
: There are no macros unique to this module.
:
        SUBTTL START / EXECL ... Main executive code
:
: Routine name  START / EXECL
:
: Function      START is the entry point for the slot (called from
:               START.LIB). Here the slot is initialised. It then
:               enters the main executive lopp at EXECL.
:
: Called by     START.LIB
:
: On entry      
:
: On exit       
:
: Uses          IZT and TIMOUT in TIMOUT.LIB
:               IZFRNT and INPUT in FRNTND.LIB
:               IZCMT and RUNDCB in this module
:
: ---------------------------------------------------------------------
:
        DEFGEQ(START,.)                 :Slot entry point
        JAL     R0,IZT                  :Initialise TIMOUT.LIB
        JAL     R0,IZFRNT               :Initialise FRNTND.LIB
        JAL     R1,IZCMT                :Initialise our code
        JAL     R5,ANSHST               :Tell supervisor we're ready
:
:    Now for the main executive loop
:
EXECL   JAL     R0,TIMOUT               :Do timeout processing
        JAL     R0,INPUT                :Read IRING
        JAL     R0,RUNDCB               :Run DCB processes
        SVC     FASTD                   :Dismiss slot
        J       EXECL
        SUBTTL RUNDCB routine ... Run any DCB waiting to be activated
:
: Routine name  RUNDCB
:
: Function      To run any DCB's marked as waiting to be run. When
:               all DCB's have suspended then control is returned
:               to caller
:
: Called by     EXECL
:
: On entry      Bit array RUNREQ has a bit set for every waiting DCB
:               Link register R0
:
: On exit       Registers are not preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
RUNDCB	PAUSE(RUNDCB)
	ST      R0,RUNRET               :Save link register
        LHI     R2,BMAPSZ-2             :Number of bytes in port bit map
RUND20  LH      R0,RUNREQ,R2            :For DCB's waiting to be run
RUND30  JFFOH   R0,RUND40               :Jump if any. Bit no. in R1
        SIS     R2,2
        JGEBS   RUND20                  :Jump if more HWs to check
        L       R0,RUNRET               :Restore link register
        JR      R0                      :Return
:
:    We have a DCB waiting to be run
:    Restore all his registers and enter his code
:
RUND40  XH      R0,HMASK,R1,R1          :Clear the waiting bit
        STH     R0,RUNSR0               :Save register 0
        STH     R2,RUNSR2               :Save register 2
        SLLS    R2,3                    :A bit of fiddling to calc. port 
        OR      R1,R2                   :R1 now contains DCB number
        LR      R12,R1
        LHI     R0,DCBSIZ
        MHR     R12,R0                  :Convert into DCB address
        AI      R12,DCBLKS
        LHL     R11,DTYPE,R12
        JE      RUND60                  :J if DCB now inactive
        L       R11,DCCB,R12            :CCB address
        L       R13,DSTCKP,R12          :Stack pointer
        L       R1,DUSR,R12             :User code to be entered
        POP(R10,R9,R8,R7,R6,R5,R4,R3)   :Restore registers for user
        POP(R2,R0)
	PAUSE(ENTERING AN ACTIVE DCB)
        JR      R1                      :Enter user code and suspend at SUSPND
:
:    An inactive DCB has been actived because flag left on RUNREQ
:
RUND60  RBT     R1,RUNREQ               :Clear flag
        LHL     R0,RUNSR0
        LHL     R2,RUNSR2
        J       RUND30                  :Look for new DCB to run
        SUBTTL SUSPND routine ... Suspend a DCB activity
:
: Routine name  SUSPND
:
: Function      To suspend a DCB activity which is to wait for external
:               activity
:
: Called by     Several routines
:
: On entry      Link register R1
:
: On exit       Return is made thru RUNDCB. All registers are preserved.
:
: Uses          
:
: ---------------------------------------------------------------------
:
        DEFGEQ(SUSPND,.)
	PAUSE(SUSPEND)
        ST      R1,DUSR,R12             :Save DCB restart address 
        PUSH(R0,R2)                     :Save registers
        PUSH(R3,R4,R5,R6,R7,R8,R9,R10)
        ST      R13,DSTCKP,R12          :Save stack pointer
        LHL     R0,RUNSR0               :Restore register 0
        LHL     R2,RUNSR2               :Restore register 2
        LHL     R1,DSUSP,R12
        JE      SUSP30                  :J if voluntary suspend 
        LHL     R1,DCBNO,R12
        RBT     R1,RUNREQ               :Clear running bit
        J       RUND30                  :Any more DCB's to run?
:
SUSP30  LHL     R1,DCBNO,R12
        SBT     R1,RUNREQ
        J       RUND30                  :Any more DCB's to run?
:
:
        SEG     A.DATA
RUNRET  WS      1                       :Save link register area
RUNSR0  HS      1                       :Save register 0
RUNSR2  HS      1                       :Save register 2 
:

        EM        SUBTTL PRINT ... Printer handler routines

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 OCT 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,PRINT                 :Delimit module
:
: This module contains routines required to send messages (ICL ALP's)
: to the host interface. 
:
:       PRTALP - Process printer ALP fragment
:       PRTCHR - Process printer data ALP character
:       PSUPER - Process printer supervisory ALP
:       POSLIN - Position printer at specific line on form
:       POSTOF - position printer at top of form
:       PRTDAS - Send printer Data Secured Report
:       PRTSTR - Send printer status report
:       PRTSCR - Action local print key
:       INIPRT - Initialise printer
:       PRTHLD - Action printer hold key
:       PRTOPS - Handle printer operable report
:       PRTXPS - Handle printer inoperable report
:
: There is one macro unique to this module.
:
:       QUALFP - Get printer code qualifier from ALP
        SUBTTL PRINT ... Macros
:
: ----------------------------------------------------------------------
:
: Macro         QUALFP
:
: Description   Get a qualifier to an ICL control code. This is acheived by
:               setting a flag to indicate that a qualifiy is required,
:               storing the continuation address in the CCB and returning
:               to the caller of ALPCHR. This has the effect that we
:               appear to drop out of macro with qualifier byte in R0.
:
: Parameters    
:
: ----------------------------------------------------------------------
:
X       EQ      0
QUALFP  MACRO [
        LHI     R1,C.PQUA
        SBT     R1,CBITS,R11            :Set flag to indicate qualifier 
        LA      R1,ADD|X|
        ST      R1,CPQUAL,R11           :Continuation address
        RETURN
ADD|X|  EQ      .
X       EQ      X+1
]
        SUBTTL PRTALP routine ... Process printer ALP fragment
:
: Routine name  PRTALP
:
: Function      To process a printer ALP fragment. 
:
: Called by     TERMH in TERM
:
: On entry      Link register R1
:               ALP prefix in R0
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTALP)
        PUSH(R0,R5,R6,R7)
        LHL     R6,CPLINE,R11           :Current line on form
        LHL     R7,CPCOL,R11            :Current column on line
        LHI     R1,C.PALP
        SBT     R1,CBITS,R11
        JN      PRTA20                  :J if this is continuation fragment
	LHI	R1,C.RIOP
	RBT	R1,CBITS,R11
:
: This is the first fragment of an ALP
:
:	LHI	R1,PS.BNA
:	SBT	R1,CPSTAT,R11
        LHI     R1,C.PQUA
        RBT     R1,CBITS,R11            :Flag no qualifier awaited
        LR      R1,R0                   :Keep prefix
        NHI     R1,ITQMSK               :Extract text qualifier field
        CHI     R1,IALPDA
        JE      PRTA10                  :J if data ALP
        CALL(PSUPER)                    :Process supervisory
PRTA05  READ(IPBHST)
        J       PRTA07                  :J if end of data
        CHI     R0,A.ETX
        JE      PRTA07                  :J if end of ALP
        LHI     R1,C.PQUA
        TBT     R1,CBITS,R11
        JE      PRTA05                  :J if we are not awaiting qualifier
        CALL(PRTCHR)                    :Process qualifier
        J       PRTA05
PRTA07	LHL	R1,CPSTAT,R11
	NHI	R1,1
	JN	PRTA08
        CALL(PRTSTR)                    :Send status report
PRTA08	LHI	R1,C.PALP
	RBT	R1,CBITS,R11
        J       PRTA95
: 
: We have a data ALP. 
:
PRTA10  READ(IPBHST)                    :Next character of ALP
        J       PRTA90                  :J if end of fragmnet
PRTA20  LHI     R1,PS.NOP
        TBT     R1,CBITS,R11
        JN      PRTA55                  :J if printer unavailable
        OPEN(NET)                       :Open output channel
        J       PRTA40
PRTA30  READ(IPBHST)                    :Next ALP character
        J       PRTA90                  :No further data, end of fragment
PRTA40  CHI     R0,A.ETX
        JE      PRTA60                  :J if end of ALP
        LR      R5,R0                   :Note last character read
:
        CALL(PRTCHR)                    :Process character
        JBS     PRTA30                  :Next ALP character
:
: Printer unavailable so flush out ALP fragment
:
PRTA50  READ(IPBHST)
        J       PRTA57                  :J if end of fragment
PRTA55  CHI     R0,A.ETX
        JN      PRTA50                  :J if not end of ALP
        LHI     R1,C.PALP
        RBT     R1,CBITS,R11
PRTA57  CALL(PRTSTR)                    :Send status report
        J       PRTA95
:
: End of data ALP. Update physical screen, send status response and return
:
PRTA60  CHI     R5,I.DC1                :Check last character of ALP
        JL      PRTA70                  :J if not DC1 - DC4
        CHI     R5,I.DC4
        JGE     PRTA70                  :Ditto
        CALL(PRT100)                    :Process DC1 - DC4 character
PRTA70  LHI     R1,C.PALP
        RBT     R1,CBITS,R11            :Not in middle of ALP any longer
PRTA90  CLOSE(NET)                      :Close output channel
	LHI	R1,C.PALP
	TBT	R1,CBITS,R11
	JN	PRTA95
	LHL	R1,CPSTAT,R11
	NHI	R1,1
	JE	PRTA98
	LHI	R1,C.DC3B
	TBT	R1,CBITS,R11
	JN	PRTA95
PRTA98	CALL(PRTSTR)
PRTA95  STH     R6,CPLINE,R11           :Save current line
        STH     R7,CPCOL,R11            :Save current column
        POP(R7,R6,R5,R0)
        RETURN
        SUBTTL PRTCHR routine ... Process printer data ALP character
:
: Routine name  PRTCHR
:
: Function      To process a printer data ALP character. Characters in the 
:               range 20 to 7F are sent to the printer provided we have not
:               exceeded column 131. Special characters are actioned by 
:               appropiate routines. Invalid characters are ignored.
:               ASD 11, PSD 12.14.7, sections 3.4, 3.6, 3.6 refer.
:
: Called by     PRTALP in this module
:
: On entry      Link register R1
:               ALP prefix in R0
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(PRTCHR)
        LHI     R1,C.PQUA
        RBT     R1,CBITS,R11
        JEFS    PRTC10                  :J if qualifier not awaited
        L       R1,CPQUAL,R11           :Contiuation address
        JALR    R1,R1                   :Process qualifier
:
PRTC10	LR      R1,R0
        CHI     R1,20
        JL      PRTC20                  :J if control character
        CHI     R7,$A 132
        JGE     PRTC90                  :J if off end of line
        AIS     R7,1
        PUSH(R4)
        LR      R4,R0
        WRITEB(NET)                     :Write character to printer
        POP(R4)
        J       PRTC90                  :Return
:
PRTC20  SLHLS   R1,2
        J       PRTC30,R1
:
: Jump table for printer control codes
:
PRTC30  J       PRTC90                  :00 - Ignore
        J       PRTC90                  :01 - Ignore
        J       PRTC90                  :02 - Ignore
        J       PRTC90                  :03 - Ignore
        J       ENDIT                   :04 - Ignore
        J       PRTC90                  :05 - Ignore
        J       PRTC90                  :06 - Ignore
        J       PRTC90                  :07 - Ignore
        J       PRTC90                  :08 - Ignore
        J       PRT300                  :09 - Multiple space
        J       PRT450                  :0A - Newline
        J       PRTC90                  :0B - Ignore
        J       PRT200                  :0C - Form feed
        J       PRT250                  :0D - Carriage return
        J       PRT320                  :0E - Multiple space
        J       PRT400                  :0F - Multiple newline
        J       PRTC90                  :10 - Ignore
        J       PRTC90                  :11 - Ignore
        J       PRTC90                  :12 - Ignore
        J       PRTC90                  :13 - Ignore
        J       PRTC90                  :14 - Ignore
        J       PRTC90                  :15 - Ignore
        J       PRTC90                  :16 - Ignore
        J       PRTC90                  :17 - Ignore
        J       PRTC90                  :18 - Ignore
        J       PRTC90                  :19 - Ignore
        J       PRTC90                  :1A - Ignore
        J       PRTC90                  :1B - Ignore
        J       PRTC90                  :1C - Ignore
        J       PRT500                  :1D - Vertical position
        J       PRTC90                  :1E - Ignore
        J       PRTC90                  :1F - Ignore
:
PRTC90  RETURN
:
:
:        SUBTTL PSUPER routine ... Process printer supervisory ALP
:
: Routine name  PSUPER
:
: Function      To process a printer supervisory ALP. The supervisory
:               code is extracted and the appropriate routine is 
:               called to action it.
:               ASD 11, PSD 12.14.7, section 6.2 refers.
:
: Called by     PRTALP in this module
:
: On entry      Link register R1
:               ALP prefix in R0
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
S.DEOJ	EQ	84
S.EOJ	EQ	85
S.CDAL	EQ	86
S.DEAL	EQ	87
:
        SSTART(PSUPER)
        LR      R1,R0
	NHI	R1,80
	JN	PSUP70
	LR	R1,R0
        NHI     R1,1F
        CHI     R1,$A 25                :J if not valid command
        JG      PSUP70
        SHI     R1,$A 16
        JL      PSUP70                  :J if not valid command
        SLHLS   R1,2
        J       PSUP20,R1
:
: Jump table for supervisory commands
:
PSUP20  J       PRT600                  :Write parameter form depthh
        J       PRT620                  :Auto page enable
        J       PRT640                  :Auto page disable
        J       PSUP70                  :Null
        J       PRT660                  :Report output complete
        J       PRT700                  :Terminal hold on
        J       PRT720                  :Terminal hold off
        J       PSUP70                  :Null
        J       PSUP70                  :Null
        J       PRT750                  :Status level reset
:
PSUP70  RETURN                          :Ignore invalid commands
:
:       11,12,13,14 - Device controls DC1, DC2, DC3, DC4
:
: A device control is only sent as the final text character in an ALP. 
: As well as their control functions described below, these characters imply
: a CR action.
:
        SSTART(PRT100)
        LR      R7,R7
        JE      PRT110                  :Already at column 0 
        PUSH(R4)
        LHI     R4,A.CR                 :Send carriage return
        WRITEB(NET)
        POP(R4)
PRT110  LR      R1,R5
        SHI     R1,I.DC1
        SLHLS   R1,2
	PUSH(R4)
        J       PRT120,R1
:
PRT120  J       PRT130                  :DC1
        J       PRT140                  :DC2
        J       PRT150                  :DC3
        J       PRT160                  :DC4
:
:       11 - DC1
:
: Unconditional deallocate and end of document. Respond with BNA status and
: maintain this condition until all buffered data has been output to the
: printer. When all data printed deallocate the printer unconditionally.
: ASD11, PSD 12.14.7, section 7.8 refers.
:
PRT130  LHI	R4,S.DEOJ
	J       PRT170
:
:       12 - DC2
:
: End of document. Raise BNA until all buffered data has been ouput. 
: When all buffered data is printed send operable status.
: ASD11, PSD 12.14.7, sections 7.7 and 7.8 refer.
:
PRT140  LHI	R4,S.EOJ
	J       PRT170
:
:       13 - DC3
:
: Conditional deallocate.If warning is set BNA status is raised and 
: reported with warning. When all data has been printed BNA and warning 
: are cleared and the printer is deealloacted. If warning is not set on
: receipt of DC3 then no action is taken.
: ASD11, PSD 12.14.7, sections 7.7 and 7.8 refer.
:
PRT150 	LHI     R1,PS.HLD
	LHI	R4,S.CDAL
        TBT     R1,CPSTAT,R11
        JE      PRT155                  :J if warning not set
	LHI	R1,C.DC3B
	SBT	R1,CBITS,R11
	J	PRT170
PRT155	POP(R4)
        RETURN
:
:       14 - DC4
:
: Unconditional deallocate sent at end of alignment test or can be sent 
: during warning condition. Respond with BNA status and maintain this condition
: until all buffered data has been output to the printer. When all data printed
: deallocate the printer unconditionally. Clear warning condition.
: ASD11, PSD 12.14.7, sections 7.8 and 6.8.2 refer.
:
PRT160	LHI	R4,S.DEAL
	LHL	R1,UPFDC4,R8
	JE	PRT175
PRT170	LHI     R1,PS.IOP
        SBT     R1,CPSTAT,R11           :Set deallocated bit in status
	LHI	R1,PS.HLD
	RBT	R1,CPSTAT,R11
PRT175 	WRITEB(NET)
	POP(R4)
        RETURN
:
:       0C - Form feed
:
: This moves the stationary to the first line of the next form, irrespective 
: of the current line position.
:
PRT200  CALL(POSTOF)
        RETURN
:
:       0D - Carriage return
:
: This resets the printing position to the left-most position of the current
: line. Any following print data may thus overprint the preceding data already
: printed on this line. ASD 11, PSD 12.14.7, section 4.2.1 refers.
:
PRT250  PUSH(R4)
        LR      R7,R7
        JE      PRT270                  :J if already at column zero
        LR      R4,R0
        WRITEB(NET)                     :Send carriage return
        LIS     R7,0
PRT270  POP(R4)
        RETURN
:
:       09 - Multiple space
:
: This allows a number of print positions to be moved to the right. The number
: of positions is specified by the qualifier as follows
:       for 1 - 31 spaces qualifier = hex 41 - 5F
:       for 32 - 63 spaces qualifier = hex 20 - 3F
: If qualifier is out of range code is ignored. ASD 11, PSD 12.14.7, section
: 4.2.2 refers.
:
PRT300  QUALFP
        PUSH(R0,R4)
        CHI     R0,20
        JL      PRT380                  :J if qualifier invalid
        CHI     R0,40
        JL      PRT350                  :J if 32 - 63 spaces
        CHI     R0,60
        JGE     PRT380                  :J if qualifier invalid
        SHI     R0,40
        JE      PRT380                  :No spaces invalid
        J       PRT350
:
:       0E - Multiple space
:
: This allows a number of print positions to be moved to the right. The number
: of positions is specified by the qualifier as follows
:       for 1 - 95 spaces qualifier = hex 20 + no. of spaces
: If qualifier is out of range code is ignored. ASD 11, PSD 12.14.7, section
: 4.2.2 refers.
:
PRT320  QUALFP
        PUSH(R0,R4)
        SHI     R0,20
        JLE     PRT380                  :J if qualifier invalid
        CHI     R0,$A 95
        JG      PRT380                  :J if qualifier invalid
PRT350  LHI     R4,A.SP
PRT360  CHI     R7,$A 132
        JGE     PRT380                  :J if at end of line
        WRITEB(NET)                     :Write space to printer
        AIS     R7,1
        SIS     R0,1
        JG      PRT360
PRT380  POP(R4,R0)
        RETURN
:
:       0F - Multiple Newline
:
: This causes the stationary to be moved by a number of lines relative to
: the current print position. A qualifier byte specifies the number of lines
: in the form hex 20 + number of lines in range 0 - 95. Zero number of lines
: is valid and equivalent to CR.
:
PRT400  QUALFP
        PUSH(R0,R4,R5)
        SHI     R0,20
        JL      PRT440                  :J if invalid parameter
        CHI     R0,$A 95
        JG      PRT440                  :J if invalid parameter
        AR      R0,R6                   :Add current line number
        DH      R0,CPFORM,R11
        LR      R5,R1
        JE      PRT430                  :J if no form feeds required
PRT420  CALL(POSTOF)                    :Do form feeds
        SIS     R5,1
        JG      PRT420
PRT430  LR      R4,R0
        CALL(POSLIN)                    :Position at correct line
PRT440  POP(R5,R4,R0)
        RETURN  
:
:       0A - Newline
:
: This causes the print position to be moved on one line from the current 
: position with implicit CR action. ASD 11, PSD 12.14.7, section 4.3.1 refers.
:
PRT450  PUSH(R4)
        LR      R4,R6
        AIS     R4,1                    :Current line plus one
        CH      R4,CPFORM,R11
        JL      PRT460                  :J if not new form required
        CALL(POSTOF)                    :Position at top of form
        J       PRT470
:
PRT460  CALL(POSLIN)                    :Position printer
PRT470  POP(R4)
        RETURN
:
:       1D - Vertical Position
:
: This causes the print position to advance to the line specified by the
: qualifier byte,moving to the next form if necessary. If the line number is
: the current position a full form depth is thrown. The qualifier has the 
: format 20 hex + absolute line position on the form (Range 0 -95). If the
: qualifier is out of range then the code is ignored. Ref ASD 11, PSD 12.14.7,
: section 4.3.4.
:
PRT500  QUALFP                          :Get qualifier
        PUSH(R0,R4)
        SHI     R0,20
        JL      PRT520                  :J if out of range
        CLH     R0,CPFORM,R11
        JGE     PRT520                  :J if out of range ( > form length)
        CR      R0,R6
        JG      PRT510                  :J if required line > current line
        CALL(POSTOF)                    :Form feed
PRT510  LR      R4,R0
        CALL(POSLIN)                    :Position at required line
PRT520  POP(R4,R0)
        RETURN
:
: Supervisory type 16 - Write parameter form depth
:
: This code specifies a new form depth. It's parameter consists of two bytes
: with the following format
:               First byte              Second byte
:             6 5 4 3 2 1 0            6 5 4 3 2 1 0
:             1 0 0 x x x x            1 0 0 x x x x
:
: Bits 0-3 of each byte form an eight bit binary number which specifies a form
: length minus 1. ASD 11, PSD 12.14.7, sections 5.2.3.1 and 6.4 refer.
:
PRT600  QUALFP
        LR      R1,R0
        NHI     R1,1F                   :Mask out bits 0 - 3
        SLHLS   R1,4
        STH     R1,CPFORM,R11           :Save part of form length
        QUALFP                          :Get second qualifier
        LR      R1,R0
        NHI     R1,1F                   :Mask out bits 0 - 3
        AHM     R1,CPFORM,R11           :Add to first part
        RETURN
:
: Supervisory type 17 - Auto Page Enable
:
: This code switches on a facilty which modifies the action of vertical 
: format effectors so as to prevent printing immediately adjacent to sheet
: perforations. Any attempt to move to one of the last four lines of a form
: will actually cause a skip to the next line 0. ASD 11, PSD 12.14.7, section
: 6.5 refers.
:
PRT620  LHI     R1,C.PAUT
        SBT     R1,CBITS,R11            :Set auto page enabled bit
        RETURN
:
: Supervisory type 18 - Auto Page Disable
:
: This code switches off the auto page facility described above.
:
PRT640  LHI     R1,C.PAUT
        RBT     R1,CBITS,R11            :Clear auto page enabled bit
        RETURN
:
: Supervisory type 20 - Report Output Complete
:
: This code should cause the ALS to send a Data Secured Report when it beleives
: that all previously received data has been printed. We must raise BNA and
: leave it set until we can send the report. We request a device status 
: report to determine when printing has finished. We set a flag to indicate
: that a data secured report is outstanding. ASD 11, PSD 12.14.7, section 6.7
: refers.
:
PRT660  LHI     R1,PS.BNA
        SBT     R1,CPSTAT,R11           :Set buffer not avail.
        LHI     R1,PS.ROC               :Flag report output complete required
        SBT     R1,CPSTAT,R11
        RETURN
:
: Supervisory type 21 - Terminal Hold on
:
: Sets a condition where hold condition (set from keyboard) causes inoperable
: to be sent immediately but no data will be discarded. When hold is cleared
: operable status will be sent and printing continued. ASD 11, PSD 12.14.7,
: section 6.8 and 6.8.1 refer.
:
PRT700  LHI     R1,C.PTRM
        SBT     R1,CBITS,R11            :Set terminal hold mode flag
        RETURN
:
: Supervisory type 22 - Terminal Hold off
:
: Sets a condition where hold condition (set from keyboard) causes warning 
: to be sent immediately and this state will be changed to inoperable on
: receipt of a DC3. When hold is cleared operable status will be sent and
: printing continued. ASD 11, PSD 12.14.7, section 6.8 and 6.8.2 refer.
:
PRT720  LHI     R1,C.PTRM
        RBT     R1,CBITS,R11            :Set primary hold mode
        RETURN
:
: Supervisory type 25 - AL Reset
:
: Access level reset has the following effects.
:       a. Discard all buffered data and clear BNA status if set
:       b. Discard all actions due to DC1 - DC4
:       c. Disable auto page facility
:       d. Set primary hold mode
:       e. Move the paper on the printer to head of form
:       f. Set form length to default 66 lines
:
PRT750  PUSH(R4)
        LHI     R1,PS.BNA               :Clear buffer not available in status
        RBT     R1,CPSTAT,R11
        LHI     R1,C.PAUT
        RBT     R1,CBITS,R11            :Disable auto page
        LHI     R1,C.PTRM
        RBT     R1,CBITS,R11            :Set primary hold mode
        LHI     R1,PS.IOP
        TBT     R1,CPSTAT,R11
        JN      PRT760                  :J if printer inoperable
        OPEN(NET)
        CALL(POSTOF)                    :Form feed
        CLOSE(NET)
PRT760  LIS     R1,0
        STH     R1,CPLINE,R11           :Line 0
        STH     R1,CPCOL,R11            :Column 0
        LHI     R1,$A 66
        STH     R1,CPFORM,R11           :Form length 66 lines
        POP(R4)
        RETURN          
        SUBTTL POSLIN routine ... Position printer at line on form
:
: Routine name  POSLIN
:
: Function      To position the printer at a specific line within a 
:               form. If autopage is on and required line is within
:               last four lines of form then we skip to line 0 of next
:               form. If required line number is less than current then
:               a form feed is issued. ASD 11, PSD 12.14.7, section 6.5
:               refers.
:
: Called by     Several routines within this module
:
: On entry      Link register R1
:               Required line number in R4
:
: On exit       
:
: Uses          POSTOF in this module
:
: ---------------------------------------------------------------------
:
        SSTART(POSLIN)
        PUSH(R4,R5)
        LHI     R1,C.PAUT
        TBT     R1,CBITS,R11
        JE      POSL20                  :J if auto page off
        LHL     R1,CPFORM,R11
        SIS     R1,4
        CR      R4,R1
        JL      POSL20                  :J if new line not in last 4 of form
        CALL(POSTOF)                    :Send form feed
        J       POSL60
:
POSL20  CR      R4,R6                   :Current line number
        JGE     POSL30                  :J if required line >= current
        CALL(POSTOF)                    :Otherwise form feed
POSL30  LR      R5,R6                   :Current line number
        LR      R6,R4                   :Required line number
        LHI     R4,A.LFED               :Line feed
        J       POSL50
:
POSL40  WRITEB(NET)                     :Send line feeds until at req line
        AIS     R5,1                    :Increment current line number
POSL50  CR      R5,R6
        JL      POSL40
        LR      R7,R7                   :Current column
        JE      POSL60                  :J if CR not required
        LIS     R7,0
        LHI     R4,A.CR
        WRITEB(NET)                     :Send carriage return
POSL60  POP(R5,R4)
        RETURN
        SUBTTL POSTOF routine ... Position printer at top of form
:
: Routine name  POSTOF
:
: Function      To position the printer at the top of next form.
:
: Called by     Several routines within this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(POSTOF)
        PUSH(R4)
        LHI     R4,A.FF
        WRITEB(NET)                     :Send form feed to printer
        LHI     R4,A.CR
        WRITEB(NET)                     :Send CR to ensure col = 0
        LIS     R6,0                    :Line now 0
        LIS     R7,0                    :Column now 0
        POP(R4)
        RETURN
        SUBTTL PRTDAS routine ... Send data secured report
:
: Routine name  PRTDAS
:
: Function      To send a data secured report to the ICL host
:
: Called by     Several routines within this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTDAS)
        PUSH(R4)
        OPEN(IPBHST)                    :Start message to printer host DCB
        LHI     R4,ISUPDS               :Data secured report supervisory
        WRITEB(IPBHST)
        CLOSE(IPBHST)
        POP(R4)
        RETURN
        SUBTTL PRTSTR routine ... Send printer status report
:
: Routine name  PRTSTR
:
: Function      To send a printer status report to the ICL host
:
: Called by     Several routines within this module
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTSTR)
        PUSH(R4)
        LHI     R4,PS.NOP
        LHI     R1,PS.IOP
        TBT     R1,CPSTAT,R11
        JN      PRTT40                  :J if printer inoperable
        RBT     R4,CPSTAT,R11           :Flag printer available
        J       PRTT60
PRTT40  SBT     R4,CPSTAT,R11           :Flag printer as unavailable
:
PRTT60  OPEN(IPBHST)                    :Start message to printer host DCB
        LHI     R4,ISUPST               :Status report supervisory
        LHI     R1,PS.CT1
        RBT     R1,CPSTAT,R11
        JE      PRTT80                  :J if not category 1
        OHI     R4,80                   :Flag category 1
PRTT80  WRITEB(IPBHST)
        LHL     R4,CPSTAT,R11           :Printer status is bits 8 - 0F
	NHI	R4,09
        OHI     R4,40                   :Set ICL bit 7
	LHI	R1,PS.HLD
	TBT	R1,CPSTAT,R11		:Test for 'HOLD'
	JE	PRTT85
	OHI	R4,10			:If so - set warning bit in status
:
PRTT85  WRITEB(IPBHST)
	LHI	R4,A.ETX
	WRITEB(IPBHST)
        CLOSE(IPBHST)
:
	LHI	R1,PS.IOS
	RBT	R1,CPSTAT,R11
	JE	PRTT90
:
	OPEN(NET)
	LHI	R4,S.EOJ
	WRITEB(NET)
	CLOSE(NET)
PRTT90  POP(R4)
        RETURN
        SUBTTL INIPRT routine ... Initialise printer
:
: Routine name  INIPRT
:
: Function      To set up initial values for printer parameters, i.e.
:               line and column position, form length, status HW.
:
: Called by     LOGST in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(INIPRT)
        LIS     R1,0
        STH     R1,CPCOL,R11            :Column zero
        STH     R1,CPLINE,R11           :Line 0
        STH     R1,CPSTAT,R11           :Clear printer status HW
        LHI     R1,$A 66
        STH     R1,CPFORM,R11           :66 line form
        LHI     R1,PS.IOP
        SBT     R1,CPSTAT,R11           :Set inoperable status
	LHI	R1,PS.NOP
	SBT	R1,CPSTAT,R11		:Set not operable bit
:	CALL(PRTSTR)			:Get status report
        RETURN
        SUBTTL PRTHLD routine ... Action printer hold key
:
: Routine name  PRTHLD
:
: Function      To action key which replaces HOLD on printer.
:
: Called by     CMTKEY in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTHLD)
        LHI     R1,PS.HLD
        TBT     R1,CPSTAT,R11
        JE      PRTH50                  :J if not 
:
: Printer is held so user must want to cancel it
:
        RBT     R1,CPSTAT,R11           :Clear hold status
        J       PRTH90
:
: Printer is not on hold so user must want it set
:
PRTH50  SBT     R1,CPSTAT,R11           :Set hold status
PRTH90  LHI	R1,C.RIOP
	TBT	R1,CBITS,R11
	JE	PRTH95
	CALL(PRTSTR)                    :Send device status to printer
PRTH95  RETURN
        SUBTTL PRTOPS routine ... Action device status operable report
:
: Routine name  PRTOPS
:
: Function      Action a device status operable report for a printer.
:               Clear inoperable and BNA bits. If waiting to de-allocate
:               then clear allocated bit and warning. If waiting to send
:               Report output complete report then send it.
:
: Called by     CMTKEY in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTOPS)
        PUSH(R5)
        LHL     R5,CPSTAT,R11           :Take copy of current state
        LHI     R1,PS.IOP
        RBT     R1,CPSTAT,R11           :Clear inoperable bit
	JE	PRTO10
:	LHI	R1,PS.CT1
:	SBT	R1,CPSTAT,R11
PRTO10  LHI     R1,PS.WDA
        RBT     R1,CPSTAT,R11           :Clear waiting de-allocate
        JE      PRTO30                  :J if not waiting de-allocate
        LHI     R1,PS.WRN
        RBT     R1,CPSTAT,R11           :Clear warning
PRTO30  LHI     R1,PS.ROC
        RBT     R1,CPSTAT,R11
        JE      PRTO50                  :J not waiting report output complete
        CALL(PRTDAS)                    :Send report
PRTO50	LHI	R1,PS.NOP
	RBT	R1,CPSTAT,R11		:Mark as available
PRTO70  NHI     R5,3                    :Mask out NOP and BNA bits
        LHL     R1,CPSTAT,R11
        NHI     R1,3
        CR      R1,R5
:       JE      PRTO90                  :J if no change in BNA or NOP bits
	LHI	R1,C.RIOP
	SBT	R1,CBITS,R11
        CALL(PRTSTR)                    :Report chanage to mainframe
PRTO90	LHI	R1,C.DC3B
	RBT	R1,CBITS,R11
        J       PRTX90                  :Check if any printer actions o/s
        SUBTTL PRTXPS routine ... Action device status inoperable report
:
: Routine name  PRTXPS
:
: Function      Action a device status inoperable report for a printer.
:               Set inoperable bits. 
:
: Called by     CMTKEY in TERM
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(PRTXPS)
        PUSH(R5)
        LHI     R1,PS.IOP
        SBT     R1,CPSTAT,R11           :Mark printer as inoperable
        LHI     R1,PS.NOP
        SBT     R1,CPSTAT,R11           : and not available
PRTX70  LHI     R1,C.PDSR
        RBT     R1,CBITS,R11            :No longer waiting for DSR
        LHI     R1,C.RIOP
        RBT     R1,CBITS,R11
        JE      PRTX90                  :J if no data ALP available
        CALL(PRTSTR)
PRTX90  POP(R5)
        RETURN
:
        EM


       SUBTTL CARD ... Card reader Handler

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 JUL 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,CARD                  :Delimit module
:
: This module contains the Terminal interface (Consat) handler routines:
:
:       CARDH - Normal card reader handler
:       CRDDAT - Process data from network
:       CRDCTL - Process control message from network
:
: There are no macros unique to this module.
        SUBTTL CARDH routine ... Normal card reader handling rountine
:
: Routine name  CARDH
:
: Function      Normal cards reader handler. This routine loops round checking 
:               network and IPB buffers for data. If any exists then data 
:               is processed. If both are empty then DCB is suspended 
:               awaiting input.
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
:	Register usage :
:
:	R2 = Number of characters in the output buffer
:	R3 = Number of unacknowleged cards
:	R4 = space compression count
:	R5 = current input card offset
:	R6 = current compressed card offset
:	R7 = pointer to start of current compressed record
:
ACKLIM	EQ	3
:
        DEFGEQ(CARDH,.)
:
	LHI	R1,D.DACT
	SBT	R1,DBITS,R12		: Initialy flag reader deactivated
:
	LHI	R1,PS.IOP		: And inoperable
	SBT	R1,CPSTAT,R11
:
: Extract printer key character or Tymnet control message from network buffer
:
CARD30	LHI	R1,C.AKSP		: Test for ACK suspended
	TBT	R1,CBITS,R11
	JE	CARD35			: If not - get more data
	LHI	R1,FREIOB
	LH	R0,CHNCNT,R1
	CHI	R0,IOBMIN
	JG	CARD33
:
	SUS(SUSVD)
	J	CARD30
:
CARD33	LHI	R1,C.AKSP
	RBT	R1,CBITS,R11
	LIS	R3,0
	CALL(CRDACK)
:
CARD35	READ(NET)                       :Get character from network
        J       CARD50                  :J if no data available
        THI     R0,80                   :Test if control message
        JE      CARD40                  :J if it is not
        CALL(CRDCTL)                    :Process control message
        J       CARD30                  :Next message
:
CARD40  CALL(CRDDAT)                    :Process data message
        J       CARD30                  :Next message
:
: Extract ICL ALP from IPB buffer for video
:
CARD50  READ(IPBHST)                    :Get character from IPB
        J       CARD80                  :J if no data available
CARD60  THI	R0,80			: Test  for terminal message
	JE	CARD70
	THI	R0,20
	JN	CARD70
:
	OPEN(NET)
	LHI	R4,80			: Output start of message marker
	WRITEB(NET)
:
CARD65	READ(IPBHST)
	J	CARD70
	LR	R4,R0
	WRITEB(NET)
	CHI	R4,82			: Test for end of message marker
	JN	CARD65
:
	LHI	R1,C.LOGN
	RBT	R1,CBITS,R11
	CLOSE(NET)
	J	CARD50
:
CARD70	CALL(CRDALP)                    :Process IPB ALP
        J       CARD30                  :Repeat loop
:
CARD80  SUS(SUSIP)                      :Suspend awaiting input
        J       CARD30                  :Check buffers again

        SUBTTL CRDDAT routine ... Process CMT control keys
:
: Routine name  CRDDAT
:
: Function      Get a coded key from CARDinal. This routine reads a character 
:               from the input buffer. If it is data then it is translated 
:               into an ICL key code and returned in R5. If a control message
:               is found it is processed here.
:
: Called by     CARDH
:
: On entry      Link register R1
:
: On exit       R5 will contain a coded key. All registers
:               will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
:
        RSTART(CRDDAT)
	CHI	R0,1F			:Test for command code
	JG	CDM100
:
	CHI	R0,4
	JG	CDMRET			: Ignore if invalid control code
        SLHLS   R0,2
	LR	R1,R0			:Convert into index
        J       CDM010,R1
:
CDM010  J       CDM030                  : 0 - Sart of job
        J       CDM040                  : 1 - End of card
        J       CDM050                  : 2 - End of job
        J       CDM060                  : 3 - Abort
	J	CDM070			: 4 - Zap
:
: Zap - close down this card reader
:
CDM070	J	ENDIT			:End it all for this user ........
CDM060	EQ	.
	LHI	R1,D.ACTV
	TBT	R1,DBITS,R12
	JE	CDM320
:
:	CALL(CDINOP)
	J	CDM055
:
:
CDMRET	RETURN
:
:	Process card data
:
CDM100	EQ	.
	LHI	R1,D.ACTV		: Test for card reader active
	TBT	R1,DBITS,R12
	JE	CDMRET			: If not - exit
:
	LHI	R1,D.NAKP
	TBT	R1,DBITS,R12		: Test for skipping record
	JN	CDMRET
:
	LHI	R1,D.ACKP
	TBT	R1,DBITS,R12		: Test for record sent before preceding
	JN	CDM150			: records have been acknowleged
:
	CHI	R5,$A 80		: Test for o/p buffer full
	JGE	CDMRET
:
	AIS	R5,1			: Increment input charater offset
	CHI	R0,20			: Test for space character
	JN	CDM110
:
	AIS	R4,1
	J	CDMRET
:
CDM110	LR	R4,R4			: Tes6t for compressed spaces
	JE	CDM120
	JAL	R1,CMPRES		: If so - construct compression code
:
CDM120	STB	R0,3,R6,R7		: Put character in output buffer
	AIS	R6,1			: Update o/p character count
	J	CDMRET
:
CDM150	LHI	R1,D.NAKP
	SBT	R1,DBITS,R12		: Flush record then send NAK
	J	CDMRET
:
:	Start of job
:
CDM030	EQ	.
	LHI	R1,D.ACTV		: Test for already active
	SBT	R1,DBITS,R12
	JN	CDM320			: If so - exit
:
	CALL(GETCRB)			: Get card record buffer
	LR	R7,R5			: Save record pointer in R7
	ST	R7,DCRBBF,R12		: And in the DCB
	LA	R7,CRBBUF,R7
:
	LHI	R6,IALPDA		: Flag data ALP
	STB	R6,0,R7
	AIS	R7,1
:
	LIS	R6,0			: Initialise buffer offset
	LR	R5,R6			: And the current record offset
	LR	R4,R6			: And the space compression count
	LHI	R2,$A 247
:
	CALL(CDOPER)			: Report card reader operable
	LHI	R1,D.DACT
	TBT	R1,DBITS,R12		: Test for reader deactivated
	JE	CDM310			: If not - return ACK
:
	LHI	R1,D.ACKP
	SBT	R1,DBITS,R12		: Otherwise delay ACK until activated
	J	CDMRET
:
CDM310	CALL(CRDACK)			: Send ACK to user
	LIS	R3,0
	J	CDMRET
:
CDM320	CALL(CRDNAK)			: If already open - send a NAK
	J	CDMRET
:
:	End of card
:
CDM040	LHI	R1,D.ACTV
	TBT	R1,DBITS,R12		: Test for card reader active
	JE	CDM550			: If not - NAK it
:
	LHI	R1,D.NAKP
	RBT	R1,DBITS,R12		: Test for flushing record
	JN	CDM550
:
	CALL(CRDPRC)
	J	CDMRET
:
:
:	End of job
:
CDM050	LHI	R1,D.ACTV
	TBT	R1,DBITS,R12		: Test for card reader open
	JE	CDM550			: If so - NAK it
:
	LHI	R1,D.NAKP
	RBT	R1,DBITS,R12		: Test for NAK pending
	JN	CDM550
:
	LHI	R1,D.EOJ
	SBT	R1,DBITS,R12		: Flag end of job
	CALL(CRDPRC)			: Process any card record present
:
	LHI	R1,PS.IOP
	SBT	R1,CPSTAT,R11		: Flag reader as inoperable
:	LHI	R1,PS.CT1
:	RBT	R1,CPSTAT,R11
	CALL(CRDSTR)
:
CDM055	LHI	R1,D.ACTV
	RBT	R1,DBITS,R12		: Close reader
	L	R5,DCRBBF,R12		: Get buffer address
	CALL(PUTCRB)			: And free it
	LIS	R5,0
	ST	R5,DCRBBF,R12
	CALL(CRDACK)			: Inform user
	RETURN
:
CDM550	CALL(CRDNAK)
	RETURN

        SUBTTL CRDPRC routine ... Process control messages
:
: Routine name  CRDPRC
:
: Function
:
: Called by     CARDH
:
: On entry      Link register R1
:
: On exit       R5 will contain a coded key. All registers
:               will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
	RSTART(CDEACT)
	CHI	R2,$A 247
	JE	CPC100			: Test for o/p record empty
	J	CPC030
:
	RSTART(CRDPRC)
	LHI	R1,$A 80
	SR	R1,R5			: Space fill to end of record
	AR	R1,R4
	JE	CPC010
	LR	R4,R1
	JAL	R1,CMPRES		: Generate compression code
:
CPC010	LHI	R1,D.EOJ
	LHI	R4,1E
	TBT	R1,DBITS,R12
	JE	CPC020
	LHI	R4,I.DC4
CPC020	STB	R4,3,R6,R7		: Add record terminator
	LHI	R4,40
	STB	R4,0,R7			: Add length field to start of record
	AIS	R6,4
	LR	R1,R6
	SR	R2,R6			: Adjust output buffer length
	LR	R0,R6
	NHI	R0,0F0			: Mask of top 4 bits
	SR	R6,R0
	SRLS	R0,4
	OR	R0,R4
	OR	R6,R4
	STB	R0,1,R7			: Add most significant nibble
	STB	R6,2,R7
	LIS	R6,0			: Clear output record offset
	LR	R4,R6			: Clear space count
	LR 	R5,R6			: And the input record pointer
	AR	R7,R1			: Update output record pointer
:
	LHI	R1,D.DACT
	TBT	R1,DBITS,R12		: Test for reader deactivated
	JN	CPC035
:
	LHI	R1,D.EOJ
	TBT	R1,DBITS,R12		: Test for end of job
	JN	CPC030
:
	LHI	R1,D.DACP		 Test for deactivate pending
	TBT	R1,DBITS,R12
	JN	CPC030
:
	CHI	R2,$A 80		: Test for card buffer full
	JGE	CPC040
:
CPC030	OPEN(IPBHST)
	L	R7,DCRBBF,R12
	LA	R7,CRBBUF,R7		: Set up pointer to start of record
	LR	R0,R2
	LHI	R2,$A 248
 	SR	R2,R0
:
CPC050	LB	R4,0,R7
	WRITEB(IPBHST)
	AIS	R7,1
	SIS	R2,1
	JN	CPC050
	LHI	R4,A.ETX
	WRITEB(IPBHST)
	CLOSE(IPBHST)
	LIS	R4,0
:
	L	R7,DCRBBF,R12
	LA	R7,CRBBUF,R7		: Set R7 to the start of the buffer
	AIS	R7,1
	LIS	R6,0
	LHI	R2,$A 247
:
	LHI	R1,D.EOJ
	RBT	R1,DBITS,R12		: Test for end of job
	JE	CPC100
	RETURN				: If so - return
:
CPC100	LHI	R1,D.DACP		: Test for deactivate request
	TBT	R1,DBITS,R12
	JE	CPC040
:
	RBT	R1,DBITS,R12
	LHI	R1,D.DACT
	SBT	R1,DBITS,R12
:
	OPEN(IPBHST)
	LHI	R4,IALPDA		: Flag data ALP
	WRITEB(IPBHST)
	LHI	R4,I.DC4		: If so - send a DC4 in a message
	WRITEB(IPBHST)
	LHI	R4,A.ETX
	WRITEB(IPBHST)
	CLOSE(IPBHST)
	LIS R4,0
:
	CALL(CRDDAC)			: Report reader deactivated
CPC150	RETURN
:
CPC035	LHI	R1,D.OPP
	SBT	R1,DBITS,R12
	J	CPC040
:
CPC040	EQ	.
	AIS	R3,1			: Update outstanding record count
	CHI	R3,ACKLIM
	JN	CPC150
:
	LHI	R1,D.DACT		: If reached - test for deactivated
	TBT	R1,DBITS,R12
	JE	CPC060			: If not - send ACK to user
	LHI	R1,D.ACKP
	SBT	R1,DBITS,R12		: Otherwise delay until activated
	RETURN
:
CPC060	LA	R1,FREIOB
	LH	R0,CHNCNT,R1		: Get no. of IOBs left on free chain
	CHI	R0,IOBMIN
	JG	CPC061			: If above minimum - send ACK
	LHI	R1,C.AKSP
	SBT	R1,CBITS,R11		: Otherwise flag ACK suspended
	J	CDMRET
:
CPC061	LIS	R3,0			: Clear outstanding count
	CALL(CRDACK)			: And send ACK
	J	CDMRET
:
        SUBTTL CRDCTL routine ... Process control messages
:
: Routine name  CRDCTL
:
: Function      Get a coded key from CARDinal. This routine reads a character 
:               from the input buffer. If it is data then it is translated 
:               into an ICL key code and returned in R5. If a control message
:               is found it is processed here.
:
: Called by     CARDH
:
: On entry      Link register R1
:
: On exit       R5 will contain a coded key. All registers
:               will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(CRDCTL,.)
        CHI     R0,0A6                  :Entering DEM
        JE      CTLM90
        CHI     R0,0A7                  :Leaving DEM
        JE      CTLM90
        CHI     R0,0AA                  :Green ball
        JE      CTLM90
        CHI     R0,0AB                  :Red ball
        JE      CTLM70
        CRUNCH(CRNOCO)                  :We don't support this code
:
:       Red ball
:
: Red ball is sent by Consat when it wants to cancel a green ball or hasn't
: received a reply to a green or red ball. We make sure outstanding green 
: ball is cancelled and send a red ball back as response.
:
CTLM70  CALL(SNDRB)                     :Respond with red ball
:
:
CTLM90  RETURN
:
        SUBTTL CRDSTR routine ... Card reader status report
:
: Routine name  CRDSTR
:
: Function      
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
CRDSTB	EQ	40			: Card reader status response
:
	RSTART(CRDSTR)
	PUSH(R4)			: Save R4
	OPEN(IPBHST)			: Open inter process output stream
	LHI	R4,ISUPST
:	LHI	R1,PS.CT1
:	TBT	R1,CPSTAT,R11		: Test for Cat 1 status response
:	JE	CST005
:	OHI	R4,80			: Flag Cat 1 status report
:
CST005	WRITEB(IPBHST)
	LHI	R4,CRDSTB
	LHI	R1,PS.IOP		: Test for card reader inoperable
	TBT	R1,CPSTAT,R11
	JE	CST010
:
	OHI	R4,01			: Set inoperable bit in status report
:
CST010	WRITEB(IPBHST)
	LIS	R4,A.ETX
	WRITEB(IPBHST)			: Terminate message
	CLOSE(IPBHST)			: And send it
	POP(R4)
	RETURN
:
:	CDINOP
:
	RSTART(CDINOP)
	LHI	R1,PS.IOP
	SBT	R1,CPSTAT,R11
	JN	CDI010
:	LHI	R1,PS.CT1
:	SBT	R1,CPSTAT,R11
	CALL(CRDSTR)
CDI010	RETURN
:
:	CDOPER
:
	RSTART(CDOPER)
	LHI	R1,PS.IOP
	RBT	R1,CPSTAT,R11
	JE	CDO010
:	LHI	R1,PS.CT1
:	SBT	R1,CPSTAT,R11
	CALL(CRDSTR)
CDO010	RETURN
        SUBTTL CRDACK routine ... Returns acknowlegements to the user
:
: Routine name  CRDACK
:
: Function      
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
:	Status values returned
:
:	ACK	=	4 - Positive acknowlegement
:	NAK	=	5 - Negative acknowlegement
:	DAC	=	6 - Reader deactivated by host
:	ACT	=	7 - Reader activated by host
:
CR.ACK	EQ	84
CR.NAK	EQ	85
CR.DAC	EQ	86
CR.ACT	EQ	87
CR.RST	EQ	88
:
:	CRDACK
:
	RSTART(CRDACK)
	PUSH(R4)
	LHI	R4,CR.ACK
	J	CDS100
:
:	CRDNAK
:
	RSTART(CRDNAK)
	PUSH(R4)
	LHI	R4,CR.NAK
	J	CDS100
:
:	CRDDAC
:
	RSTART(CRDDAC)
	PUSH(R4)
	LHI	R4,CR.DAC
:
CDS100	OPEN(NET)
	WRITEB(NET)
	CLOSE(NET)
	POP(R4)
	RETURN
:
:
:	CRDACT
:
	RSTART(CRDACT)
	PUSH(R4)
	LHI	R4,CR.ACT
	J	CDS100
:
:	CRDRST
:
	RSTART(CRDRST)
	PUSH(R4)
	LHI	R4,CR.RST
	J	CDS100
: 
       SUBTTL CMPRES routine ... Space compression routine
:
: Routine name  CMPRES
:
: Function      
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
	RSTART(CMPRES)
	CHI	R4,1
	JN	CMP005			: If one space - dont compress
	LHI	R4,20
	STB	R4,3,R6,R7
	AIS	R6,1
	LIS	R4,0
	RETURN
:
CMP005	LH	R1,UPFCMP,R8		: Get compression code
	CHI	R1,9
	JN	CMPE00
:
: compression code = 9
:
: the sequence will represent upto 63 spaces.
:	if count > 31
:	then qualifier = count
:	else qualifier = count + X'40'
:
	PUSH(R2)
CMP930	LIS	R2,0
	CHI	R4,$A 64
	JL	CMP910			: Set R2 to the excess no. of chars
:
	LR	R2,R4
	LHI	R4,$A 63		: And R4 to the qualifier count
	SR	R2,R4
:
CMP910	STB	R1,3,R6,R7		: Save compression character
	CHI	R4,$A 32
	JGE	CMP920
:
	AHI	R4,40			: Construct qualifier
:
CMP920	STB	R4,4,R6,R7		: And save it
	AIS	R6,2
	LR	R4,R2			: Get excess
	JN	CMP930
:
	POP(R2)
	RETURN
:
: Compression code = 0E
: Qualifier = No. of spaces + X'20'
:
CMPE00	AHI	R4,20
	STB	R1,3,R6,R7
	STB	R4,4,R6,R7
	AIS	R6,2
	LIS	R4,0
	RETURN
        SUBTTL CRDALP routine ... Card reader ALP processor
:
: Routine name  CRDALP
:
: Function      
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
	RSTART(CRDALP)
	PUSH(R4)
	LR	R1,R0			: Get ALP Prefix
	NHI	R1,ITQMSK
	CHI	R1,IALPDA		: Test for data ALP
	JE	CAL050
:
	LR	R1,R0
	NHI	R1,1F			: Get operation code
	CHI	R1,$A 25			: Test for group reset
	JE	CAL100
:
	CHI	R1,$A 16			: Test for ACTIVATE
	JE	CAL200
:
	CHI	R1,$A 17			: Test for DEACTIVATE
	JE	CAL300
:
CAL050	POP(R4)
	RETURN
:
:	Command code = 25 - group reset
:
CAL100	LHI	R1,D.ACTV		: Test for card reader open
	RBT	R1,DBITS,R12
	JE	CAL120			: If not - then exit
:
	CALL(CRDRST)			: Inform user of reset
:
	LHI	R1,D.DACT
	RBT	R1,DBITS,R12
:
	LHI	R1,D.DACP
	RBT	R1,DBITS,R12
:
	LHL	R5,DCRBBF,R12
	CALL(PUTCRB)
:
CAL120	POP(R4)
	RETURN
:
:	Command code = 16 - activate
:
CAL200	EQ	.
:	LHI	R1,PS.CT1
:	SBT	R1,CPSTAT,R11
	LR	R1,R0
	THI	R0,80
	JN	CAL201
	CALL(CRDSTR)
CAL201	LHI	R1,D.DACT		: Test for reader deactivated
	RBT	R1,DBITS,R12
	JE	CAL210			: If not - ignore
:
	CALL(CRDACT)			: Inform user
	LHI	R1,D.ACKP
	RBT	R1,DBITS,R12		: Test for ACK outstanding
	JE	CAL210
:
	CALL(CRDACK)
	LIS	R3,0
:
	LHI	R1,D.OPP
	RBT	R1,DBITS,R12
	JE	CAL210
:
	OPEN(IPBHST)
	L	R7,DCRBBF,R12
	LA	R7,CRBBUF,R7		: Set up pointer to start of record
	LR	R0,R2
	LHI	R2,$A 248
 	SR	R2,R0

CAL220	LB	R4,0,R7
	WRITEB(IPBHST)
	AIS	R7,1
	SIS	R2,1
	JN	CAL220
	LHI	R4,A.ETX
	WRITEB(IPBHST)
	CLOSE(IPBHST)
	LIS	R4,0
:
	L	R7,DCRBBF,R12
	LA	R7,CRBBUF,R7		: Set R7 to the start of the buffer
	AIS	R7,1
	LIS	R6,0
	LHI	R2,$A 247
:
CAL210	POP(R4)
	RETURN
:
:	Command code = 17 - DEACTIVATE
:
CAL300	EQ	.
	LHI	R1,D.ACTV		: Test for reader open
	TBT	R1,DBITS,R12
	JE	CAL315			: If not - send DC4
:
	LHI	R1,D.DACT		: Test for already deactivated
	TBT	R1,DBITS,R12
	JN	CAL310			: If so - send DC4
:
	LHI	R1,D.DACP
	SBT	R1,DBITS,R12		: Otherwise flag deactivate pending
	LR	R5,R5			: Test for prococessing card record
	JN	CAL305
	CALL(CDEACT)			: If not - deactivate now
:
CAL305	POP(R4)
	RETURN
:
CAL315	LHI	R1,D.DACT
	SBT	R1,DBITS,R12
:
CAL310	PAUSE(DEACTIVATE RECEIVED)
	LR	R1,R0
	NHI	R1,80
	JN	CAL305
	OPEN(IPBHST)
	LHI	R4,IALPDA
	WRITEB(IPBHST)
	LHI	R4,I.DC4
	WRITEB(IPBHST)
	CLOSE(IPBHST)
	POP(R4)
	RETURN
:
        EM       SUBTTL OPER ... Operator console Handler

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 JUL 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,OPER                  :Delimit module
:
: This module contains the Terminal interface (Consat) handler routines:
:
:       OPERH - Normal Operator console handler
:       OPRDAT - Process data from network
:       OPRCTL - Process control message from network
:
: There are no macros unique to this module.
        SUBTTL OPERH routine ... Normal Operator console handling rountine
:
: Routine name  OPERH
:
: Function      Normal console handler. This routine loops round checking 
:               network and IPB buffers for data. If any exists then data 
:               is processed. If both are empty then DCB is suspended 
:               awaiting input.
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
:	Register usage :
:
:	R2 = Number of characters in the output buffer
:	R7 = pointer to start of current compressed record
:
:
        DEFGEQ(OPERH,.)
:
	LHI	R1,PS.IOP		: Flag console operable
	SBT	R1,CPSTAT,R11
	CALL(OPOPER)
:
	LHI	R1,C.PALP
	RBT	R1,CBITS,R11
:
	CALL(GETCRB)			: Get OPER record buffer
	LR	R7,R5			: Save record pointer in R7
	ST	R7,DCRBBF,R12		: And in the DCB
	LA	R7,CRBBUF,R7
:
	LHI	R6,IALPDA		: Flag data ALP
	STB	R6,0,R7
	AIS	R7,1
:
	LIS	R2,0
:
: Extract console key character or Tymnet control message from network buffer
:
OPER30  READ(NET)                       :Get character from network
        J       OPER50                  :J if no data available
        THI     R0,80                   :Test if control message
        JE      OPER40                  :J if it is not
        CALL(OPRCTL)                    :Process control message
        J       OPER30                  :Next message
:
OPER40  CALL(OPRDAT)                    :Process data message
        J       OPER30                  :Next message
:
: Extract ICL ALP from IPB buffer for video
:
OPER50  READ(IPBHST)                    :Get character from IPB
        J       OPER80                  :J if no data available
OPER60  THI	R0,80			: Test  for terminal message
	JE	OPER70
	THI	R0,20
	JN	OPER70
:
	OPEN(NET)
	LHI	R4,80			: Output start of message marker
	WRITEB(NET)
:
OPER65	READ(IPBHST)
	J	OPER75
	LR	R4,R0
	WRITEB(NET)
	CHI	R4,82			: Test for end of message marker
	JN	OPER65
:
OPER75	LHI	R1,C.LOGN
	RBT	R1,CBITS,R11
	CLOSE(NET)
	J	OPER50
:
OPER70	CALL(OPRALP)                    :Process IPB ALP
        J       OPER30                  :Repeat loop
:
OPER80  SUS(SUSIP)                      :Suspend awaiting input
        J       OPER30                  :Check buffers again

        SUBTTL OPRDAT routine ... Process CMT control keys
:
: Routine name  OPRDAT
:
: Function      Get a coded key from console. This routine reads a character 
:               from the input buffer. If it is data then it is translated 
:               into an ICL key code and returned in R5. If a control message
:               is found it is processed here.
:
: Called by     OPERH
:
: On entry      Link register R1
:
: On exit       R5 will contain a coded key. All registers
:               will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
:
        RSTART(OPRDAT)
	CHI	R0,1F			:Test for command code
	JG	OPM100
:
	CHI	R0,1
	JG	OPMRET			: Ignore if invalid control code
        SLHLS   R0,2
	LR	R1,R0			:Convert into index
        J       OPM010,R1
:
OPM010  J       OPM070                  : 0 - End of console session
        J       OPM040                  : 1 - End of console record
:
: Zap - close down this Operator console
:
OPM070	CALL(OPINOP)
	J	ENDIT			:End it all for this user ........
:
:
:	Process OPER data
:
OPM100	EQ	.
:
	CHI	R2,$A 80		: Test for o/p buffer full
	JGE	OPMRET
:
	STB	R0,0,R2,R7		: Put character in output buffer
	AIS	R2,1			: Increment input charater offset
OPMRET	RETURN
:
OPM040	LHI	R4,I.DC4
	STB	R4,0,R2,R7		: Add record terminator
	AIS	R2,2			: Increment input charater offset
 :
	OPEN(IPBHST)
	L	R7,DCRBBF,R12
	LA	R7,CRBBUF,R7		: Set up pointer to start of record
:
OPM050	LB	R4,0,R7
	WRITEB(IPBHST)
	AIS	R7,1
	SIS	R2,1
	JN	OPM050
	LHI	R4,A.ETX
	WRITEB(IPBHST)
	CLOSE(IPBHST)
	LIS	R4,0
:
	L	R7,DCRBBF,R12
	LA	R7,CRBBUF,R7		: Set R7 to the start of the buffer
	AIS	R7,1
	LIS	R2,0
	RETURN				: If so - return
:
:
        SUBTTL OPRCTL routine ... Process control messages
:
: Routine name  OPRCTL
:
: Function      Get a coded key from console. This routine reads a character 
:               from the input buffer. If it is data then it is translated 
:               into an ICL key code and returned in R5. If a control message
:               is found it is processed here.
:
: Called by     OPERH
:
: On entry      Link register R1
:
: On exit       R5 will contain a coded key. All registers
:               will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(OPRCTL,.)
        CHI     R0,0A6                  :Entering DEM
        JE      CTLM90
        CHI     R0,0A7                  :Leaving DEM
        JE      CTLM90
        CHI     R0,0AA                  :Green ball
        JE      CTLM90
        CHI     R0,0AB                  :Red ball
        JE      CTLM70
        CRUNCH(CRNOCO)                  :We don't support this code
:
:       Red ball
:
: Red ball is sent by Consat when it wants to cancel a green ball or hasn't
: received a reply to a green or red ball. We make sure outstanding green 
: ball is cancelled and send a red ball back as response.
:
CTLM70  CALL(SNDRB)                     :Respond with red ball
:
:
CTLM90  RETURN
:
        SUBTTL OPRSTR routine ... Operator console status report
:
: Routine name  OPRSTR
:
: Function      
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
OPRSTB	EQ	40			: Operator console status response
:
	RSTART(OPRSTR)
	PUSH(R4)			: Save R4
	OPEN(IPBHST)			: Open inter process output stream
	LHI	R4,ISUPST
:	LHI	R1,PS.CT1
:	TBT	R1,CPSTAT,R11		: Test for Cat 1 status response
:	JE	OPL005
:	OHI	R4,80			: Flag Cat 1 status report
:
OPL005	WRITEB(IPBHST)
	LHI	R4,OPRSTB
	LHI	R1,PS.IOP		: Test for Operator console inoperable
	TBT	R1,CPSTAT,R11
	JE	OPL010
:
	OHI	R4,01			: Set inoperable bit in status report
:
OPL010	WRITEB(IPBHST)
	LIS	R4,A.ETX
	WRITEB(IPBHST)			: Terminate message
	CLOSE(IPBHST)			: And send it
	POP(R4)
	RETURN
:
:	OPINOP
:
	RSTART(OPINOP)
	LHI	R1,PS.IOP
	SBT	R1,CPSTAT,R11
	JN	OPI010
	LHI	R1,PS.CT1
	SBT	R1,CPSTAT,R11
	CALL(OPRSTR)
OPI010	RETURN
:
:	OPOPER
:
	RSTART(OPOPER)
	LHI	R1,PS.IOP
	RBT	R1,CPSTAT,R11
	JE	OPO010
	LHI	R1,PS.CT1
	SBT	R1,CPSTAT,R11
	CALL(OPRSTR)
OPO010	RETURN
        SUBTTL OPRALP routine ... Operator console ALP processor
:
: Routine name  OPRALP
:
: Function      
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
	RSTART(OPRALP)
	PUSH(R4)
:
	LHI	R1,C.PALP		: Test for already processing ALP
	SBT	R1,CBITS,R11
	JN	OPL100
:
	LR	R1,R0			: If not - get ALP Prefix
	NHI	R1,ITQMSK
	CHI	R1,IALPDA		: Test for data ALP
	JE	OPL350
:
OPL300	READ(IPBHST)
	J	OPL050
	CHI	R0,A.ETX
	JN	OPL300
:
	LHI	R1,C.PALP
	RBT	R1,CBITS,R11
	J	OPL050
:
OPL350	READ(IPBHST)
	J	OPL050			: Exit if no data available
:
OPL100	LR	R4,R0
	OPEN(NET)
:
OPL150	CHI	R4,I.DC4
	JE	OPL200
:
	CHI	R4,1A
	JN	OPL155
	LHI	R4,20
:
OPL155	WRITEB(NET)
:
OPL200	READ(IPBHST)
	J	OPL500
	LR	R4,R0
	CHI	R4,A.ETB		: Test for end of ALP
	JE	OPL200
	CHI	R4,A.ETX
	JN	OPL150
:
	LHI	R1,C.PALP
	RBT	R1,CBITS,R11
OPL210	CALL(OPRSTR)
:
OPL500	CLOSE(NET)
	POP(R4)
	RETURN
:
OPL050	POP(R4)
	RETURN
:
:	Command code = 25 - group reset
:
        EM        SUBTTL HOST ... Host interface handler

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 OCT 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        GL      RESTAR                  :Restart code in TERM
        SEG     A.CODE                  :Segment to contain this module
        MO      .,HOST                  :Delimit module
:
: This module contains the host interface (ICL/HIF) handler routines:
:
:       LOGSH - Initial logon handler to host interface
:       HOSTH - Normal host interface handler
:       LOGONM - Manual logon handler
:       LOGONS - Stored logon handler
:       LOGNIN - Issues logon from prepared string
:       TRAIL - Removing trailing spaces from username/password
:       GETALP - Wait for response from user
:       GETNET - Wait for response from network
:
: There are no macros unique to this module.
        SUBTTL LOGSH routine ... Logon process for host DCB
:
: Routine name  LOGSH
:
: Function      This routine contains the routines to be obeyed when a
:               psuedo needle is received. This will have been requested by
:               the terminal interface when a user logs on. If
:               necessary a menu of logon options is output to the user
:               and the circuit(s) to the host interface are initiated.
:               On successful completion of these processes the DCB is
:               then handed over to HOSTH.
:
: Called by     Automatically when host DCB created
:
: On entry      DCB and CCB will have been initialised.
:
: On exit       
:
: Uses          QRYLOG, WELCOM, LOGONM in this module
:               LOGONS, CANRES, LOGMES, LOGIIX in this module
:               RESTAR in TERM
:
: ---------------------------------------------------------------------
:
        DEFGEQ(LOGSH,.)
        LIS     R7,6                    :Logging messages start on line 7
:
: Prepare to log into host interface
:
        L       R8,CUPROF,R11           :User profile entry
	LHL     R2,UPFMNU,R8            :Menu for this user
        SLLS    R2,2                    :Convert into index into MENUS
        LHL     R6,MENUS+2,R2           :Index to MSTRS of 1st logon string
	LR	R3,R6
        LHL     R4,MSTRS,R3
        STH     R4,CLSTRS,R11           :Save logon string in CCB
        LHI	R1,D.PRT
	LB	R0,UPFDEV		:Test for printer port
	CHI	R0,DVLPTR
	JN	LOGH35
        SBT     R1,DBITS,R12            :Printer host link DCB
	J	LOGH60
:
LOGH35	RBT	R1,DBITS,R12
:
: Deal with stored logon mode
:       
:
LOGH60  LHL     R2,LSTRS+2,R4           :First element string number
        LHL     R6,STRLST,R2            :Point to element address cell
        SLHLS   R6,2
        L       R6,ELEADR,R6            :Address of element
        CALL(LOGONS)                    :Send stored logon
        J       LOGH90                  :J if error and restart required
        J       LOGIIX                  :Deal with IIX startup
:
: Logon failed, invite user to restart
:
LOGH90	LHI	R0,C.LOGN		:Idle until terminal output message
	TBT	R0,CBITS,R11
	JE	LOGH95
	SUS(SUSVD)
	J	LOGH90
LOGH95	LIS     R4,0                    :Flag that no message is to be o/p
        J       ENDIT                   :Enter restart point in TERM
        SUBTTL LOGIIX routine ... Initial IIX and turkey negiotation
:
: Routine name  LOGIIX
:
: Function      This routine performs the initial IIX negiotion with HIF.
:               Check that host logged onto is intellegent. Wait for 
:               select dialague and if ICLC03 included then send response.
:               Send caller user data. Anything abnormal occurs we zap circuit
:               tell user and allow him to restart.
:
: Called by     LOGSH
:
: On entry      Circuit has been built to HIF. Successful logon received.
:
: On exit       Negiotation with HIF successfully completed
:
: Uses          GETNET, GETIIX, BEGIIX, LOGCUD, LOGMES in this module
:               CANRES, HOSTH in this module
:               SNDTIX, SNDZAP, INIDCB in CMTI
:
: ---------------------------------------------------------------------
:
        DEFGEQ(LOGIIX,.)
:
: Check we are logged on to intellegent host
:
        CALL(GETNET)                    :Get qualifier to successful logon
        LR      R5,R0                   :Save IIX character
        LIS     R4,3                    :Flush out rest of message (3 chars)
LOGI10  CALL(GETNET)
        SIS     R4,1
        JN      LOGI10                  :J if not flushed       
        NHI     R5,7F                   :Low order 7 bits of IIX char
        JE      LOGI90                  :J if not IIX capable
:
: Wait for select dialect message. If ICLC03 supported send response
:
        CALL(GETIIX)                    :Get IIX message
        CLI     R5,ISDIAL               
        JN      LOGI90                  :J if not select dialect
        LIS     R5,0                    :Flag ICL not supported
LOGI20  CALL(GETNET)
        CHI     R0,0C0
        JE      LOGI30                  :J if end of select dialect
        LR      R4,R0                   :First character of dialect
        SLHLS   R4,8
        CALL(GETNET)                    :Second character of dialect
        OR      R4,R0                   :Create dialect HW
        CLI     R4,ISDC03
        JN      LOGI20                  :J if not ICL C03
        LIS     R5,1                    :Flag ICL supported
        J       LOGI20
:
: End of select dialect, does it support ICL C03
:
LOGI30  LR      R5,R5
        JE      LOGI90                  :J if does not support ICL C03
        LHI     R5,ISDRES               :Select dialect response
        CALL(BEGIIX)                    :Begin IXX output
        LHI     R4,80                   :Selected dialect is ICL C03
        WRITEB(NET)
        LHI     R4,ISDC03               :We only use last byte of this
        WRITEB(NET)
        CLOSE(NET)
        CALL(SNDTIX)                    :End of IIX message
:
: Wait for Turkey level 1 message and respond with call user data
:
        CALL(GETIIX)                    :Get next message
        CLI     R5,ITURK1
        JN      LOGI90                  :J if not turkey level 1 message
LOGI40  CALL(GETNET)                    :Skip qualifiers
        CHI     R0,0C0
        JN      LOGI40
:
        CALL(LOGCUD)                    :Send call user data
        J       LOGI95                  :J if failed
:
: Successfully communicating to host. If we have just set up printer link
: we must now set up video link. Go to normal running code at HOSTH.
:
        LA      R4,LGONOK
        CALL(LOGMES)                    :Report logon OK
        J       HOSTH                   :Normal running
:
: Host not ICL HIF so tell user, zap circuit and invite user to restart
:
LOGI90  LA      R4,LGNHIF               :Host not HIF
        CALL(LOGMES)                    :Tell user
LOGI95  CALL(SNDZAP)                    :Close host circuit
        LIS     R4,0                    :Flag no message to o/p
        J       LOGH90
        SUBTTL HOSTH routine ... Normal host interface handler
:
: Routine name  HOSTH
:
: Function      This routine handles normal activity on an established link 
:               to the HIF. Data from HIF is passed across to the terminal DCB.
:               Data from terminal DCB is put into one IIX data message and
:               sent to HIF. Note,that currently we do not use count bytes in
:               the header. Invitation to clear from HIF causes us to enter
:               restart code in TERM which clears down circuits to HIF.
:
: Called by     LOGIIX
:
: On entry      
:
: On exit       
:
: Uses          GETNET, BEGIIX in this module
:               SNDTIX, SNDGRB in CMTI
:
: ---------------------------------------------------------------------
:
        DEFGEQ(HOSTH,.)
HOST10  READ(NET)
        J       HOST70                  :No data available
        CHI     R0,0BF
        JN      HOST50                  :J if not SIXX
        CALL(GETNET)                    :Skip over IIX code
        CALL(GETNET)
        CALL(GETNET)                    :Qualifier
        LR      R0,R0
        JN      HOST40                  :J if not data message
        CALL(GETNET)                    :Skip over data count
        CALL(GETNET)
        OPEN(IPBTRM)                    :Open IPB buffer to terminal DCB
HOST20  CALL(GETNET)                    :Read in data
        CHI     R0,0C0
        JE      HOST30                  :J if end of IIX message
        LR      R4,R0                   :Write data to IPB
        WRITEB(IPBTRM)
	CHI	R4,A.ETX
	JN	HOST20			:J if not end of alp
	LHL	R4,DTYPE,R12
	CHI	R4,DTHPRT
	JN	HOST20			:J if not printer DCB
	LHI	R1,D.TOKN
:	SBT	R1,DBITS,R12		:Flag suspended awaiting processing
        J       HOST20                  :J if further data
HOST30  CLOSE(IPBTRM)                   :Send data to terminal DCB
	J	HOST10			:J if not suspended
:
: Received invitation to clear, tell user and close host circuits
:
HOST40  LA      R4,IIXE1
        CALL(LOGMES)                    :Close down host circuit, user restart
	J	LOGH90
:
: Only other acceptable input from HIF is black ball.
: We must discard any accumulated ALP and return grey ball
:
HOST50  CHI     R0,0A4
        JN      HOST10                  :Ignore if not black ball
        OPEN(IPBTRM)                    :Send end of ALP to terminal DCB
        LHI     R4,A.ETX
        WRITEB(IPBTRM)
        CLOSE(IPBTRM)
        CALL(SNDGRB)                    :Return grey ball to HIF
        J       HOST10                  :Check for further data
:
: Check if we have any data from user. Send it on to HIF as IIX data message
:
HOST70  READ(IPBTRM)
        J       HOST90                  :No data from terminal
HOST72  LHI     R5,IDATA                :Start of IIX data block
        CALL(BEGIIX)
        LIS     R4,0                    :Normal category
        LIS     R2,3                    :Category + two dummy bytes
        LR      R1,R0
        NHI     R1,80
        JE      HOST75                  :J if normal category requested
        NHI     R0,7F                   :Remove top bit
        LIS     R4,1                    :Category 1
HOST75  WRITEB(NET)
        SIS     R2,1
        JN      HOST75
HOST80  LR      R4,R0                   :First byte of message
        WRITEB(NET)
        READ(IPBTRM)                    :Read terminal data
        J       HOST85                  :End of data
        CHI     R0,A.ETX
        JN      HOST80                  :J if just data
HOST85  LHI     R4,A.ETX
        WRITEB(NET)
        CLOSE(NET)                      :End data block
        CALL(SNDTIX)                    :End of IIX
        J       HOST10                  :Loop to check for response
:
: No data from host or terminal so suspend
:
HOST90  SUS(SUSIP)
	LHI	R1,D.TOKN
	TBT	R1,DBITS,R12
	JN	HOST70			:If input susp then only check ipb
        J       HOST10                  :Check again
        SUBTTL LOGONS routine ... Stored logon
:
: Routine name  LOGONS
:
: Function      This routine logs on to the network using a stored logon 
:               string.
:
: Called by     LOGST
:
: On entry      Link register R1
:               Stored element address in R6
:
: On exit       Return +4, successful logon message qualifier in R0.
:               Return + 0, failed
:
: Uses          LOGMES in this module
:
: ---------------------------------------------------------------------
:
        SSTART(LOGONS)
        PUSH(R0,R4,R5,R6)
        CALL(GETCRB)                    :Get a work buffer
        ST      R5,DCRBBF,R12
        LR      R10,R5
        LIS     R5,0                    :Create stored logon starting message
LOGS05  LB      R0,STLOGS+1,R5
        STB     R0,CRBBUF+1,R10,R5
        AIS     R5,1
        CLB     R5,STLOGS
        JN      LOGS05
        LHL     R4,LSTRS+4,R4           :Login string label address
        LIS     R1,0
LOGS06  LB      R0,STRLAB+1,R4,R1       :Now place logon label on screen
        STB     R0,CRBBUF+1,R10,R5
        AIS     R5,1
        AIS     R1,1
        CLB     R1,STRLAB,R4,
        JN      LOGS06
        STB     R5,CRBBUF,R10           :Save size of string
LOGS08  LIS     R4,0                    :Offset within username/host/password
LOGS10  CLB     R4,0,R6
        JN      LOGS20                  :J if not end of element
        LHI     R10,A.CR                :Supply terminator
        JFS     LOGS40  
LOGS20  LB      R5,1,R6,R4              :Logon character
        AIS     R4,1                    :Move through string
        NHI     R5,7F                   :Mask off top bit
LOGS40  STB     R5,CRBBUF,R10,R4        :Store in work buffer
        CHI     R5,A.CR
        JE      LOGS60                  :J if carriage return
        CHI     R5,A.SEMI
        JN      LOGS10                  :J if not semicolon
        CLB     R4,0,R6
        JE      LOGS10                  :J if end of string
        LB      R5,1,R6,R4
        JN      LOGS20                  :J if not wild card
        STB     R4,CRBBUF,R10
        LHI     R0,A.CR
LOGS45  AIS     R4,1                    :Skip to carriage return or end
        CLB     R4,0,R6
        JE      LOGS80                  :J if not end of element
        CLB     R0,1,R6,R4
        JN      LOGS45
        CLB     R4,0,R6
        JN      LOGS20                  :J if not end of element
	J	LOGS80			:Else failed
:
LOGS60  STB     R4,CRBBUF,R10           :Save string size
LOGS70  LR      R4,R6                   :Save contents of R6
        CALL(LOGNIN)                    :Network login
        J       LOGS90                  :Successful
:
LOGS80  L       R5,DCRBBF,R12           :Irrecoverable error??
        CALL(PUTCRB)                    :Return buffer
	LHI	R5,0			:And clear pointer
	ST	R5,DCRBBF,R12
        POP(R6,R5,R4,R0)
        RETURN                          :Return + 0, failed
LOGS90  L       R5,DCRBBF,R12
        CALL(PUTCRB)                    :Return buffer
	LIS	R5,0
	ST	R5,DCRBBF,R12		:And clear pointer
        POP(R6,R5,R4,R0)
        RETURN(SKIP)                    :Return + 4, successful
        SUBTTL LOGNIN routine ... Stored logon
:
: Routine name  LOGNIN
:
: Function      This routine logs on to the network using a specified logon 
:               string.
:
: Called by     LOGST
:
: On entry      Link register R1
:
: On exit       Return +4, successful logon message qualifier in R0.
:               Return + 0, failed
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(LOGNIN)
        PUSH(R0,R2,R4,R5)
        LHL     R5,DCBNO,R12            :DCB number is local key
        CALL(SNDPNR)                    :Send pseudo needle request
        SUS(SUSPN)                      :Wait needle
        LIS     R6,3
        LHL     R1,DPORT,R12
        JN      LOGN05                  :J if ports available
        LIS     R6,3
        LA      R4,LGPNRJ               :Pseudo needle rejected
        CALL(LOGMES)
        J       LOGN85                  :Return
:
LOGN05  LIS     R6,0                    :Null response  
        LIS     R2,0                    :Count of string
LOGN10  CLB     R2,CRBBUF,R10
        JLE     LOGN20                  :J if string not empty
        LHI     R5,A.SEMI               :Otherwise send semicolon
        J       LOGN30
LOGN20  LB      R5,CRBBUF+1,R10,R2      :Next char from string
        AIS     R2,1                    :Increase count
        CHI     R5,A.CR
        JN      LOGN30  
        LHI     R5,A.SEMI               :Convert carriage return to semicolon
LOGN30  CALL(SNDNLC)                    :Send logon char
        SUS(SUSVD)                      :Voluntary suspend
        NHI     R5,7F                   :Mask out top bit
        CHI     R5,A.SEMI
        JE      LOGN40                  :J if terminator
LOGN35  READ(NET)                       :Any response
        J       LOGN10                  :J if none
        J       LOGN50                  :Response available
LOGN40  CALL(GETNET)                    :Wait for response
LOGN50  CHI     R0,7F
        JG      LOGN70                  :J if not data
        OPEN(IPBTRM)
        LR      R4,R0
        WRITEB(IPBTRM)                  :Send to user
        LHI     R4,A.ETX
        WRITEB(IPBTRM)                  :End of ALP
        CLOSE(IPBTRM)
LOGN60  CHI     R5,A.SEMI
        JE      LOGN40                  :J if waiting for response
        J       LOGN35
:
LOGN70  CHI     R0,0B6
        JE      LOGN90                  :J if successful logon
        CHI     R0,0B4
        JN      LOGN60                  :J if not normal logon status
        READ(NET)                       :Get qualifier
        J       LOGN60                  :J if no qualifier
        NHI     R0,1F                   :Mask out status message code
        JE      LOGN10                  :J if continue - send password
        LR      R1,R0                   :Can't use R0 as index
        SIS     R1,1
        SLHLS   R1,2
        L       R4,LGERMS,R1            :Pick up error message
        CALL(LOGMES)                    :Output to user
        LIS     R6,2                    :Password error?
        CHI     R0,3
        JE      LOGN80                  :Password in error
        CHI     R0,5
        JE      LOGN80                  :Password not supplied
        LIS     R6,1                    :Username error
:
LOGN80  CALL(SNDZAP)                    :Zap this circuit
LOGN85  POP(R5,R4,R2,R0)
        RETURN(SKIP)                    :Return + 4
:
LOGN90  POP(R5,R4,R2,R0)
        RETURN                          :Return + 0, logon successful
        SUBTTL LOGCUD routine ... Send call user data to HIF
:
: Routine name  LOGCUD
:
: Function      This routine logs on to the network using a specified logon 
:               string.
:
: Called by     LOGST
:
: On entry      Link register R1
:
: On exit       Return +4, successful logon message qualifier in R0.
:               Return + 0, failed
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(LOGCUD)
        PUSH(R0,R4,R5)
LOGC20  LHL     R4,CLSTRS,R11         :Pointer to logon string
        LHL     R2,LSTRS+2,R4             :pointer to first element
        AIS     R2,2                    :CUD element
        LHL     R6,STRLST,R2            :Point to element address cell
        SLHLS   R6,2
        L       R6,ELEADR,R6            :Address of element
        LB      R1,1,R6                 :First character is line
        STH     R1,DLINE,R12
        LB      R1,2,R6                 :Second character is group
        STH     R1,DGROUP,R12
        LB      R1,3,R6                 :Third character is subsidiary
        STH     R1,DSUBSD,R12
LOGC40  LHI     R5,ICUD
        CALL(BEGIIX)                    :Begin call user data IIX message
	LIS	R4,5
	WRITEB(NET)
        LIS     R4,0
        WRITEB(NET)                     :Two unused bytes
        WRITEB(NET)
        LHL     R4,DLINE,R12            :Send line number
        WRITEB(NET)
        LHL     R4,DGROUP,R12           :Send group number
        WRITEB(NET)
        LHL     R4,DSUBSD,R12           :Send subsidiary number
        WRITEB(NET)
        CLOSE(NET)
        CALL(SNDTIX)                    :End IXX message
        CALL(GETIIX)                    :Get response
        CLI     R5,ICALLA
        JN      LOGC80                  :J if not call accept
        CALL(GETNET)                    :Skip to line, group ,etc data
        CALL(GETNET)
        CALL(GETNET)                    :Line number
        STH     R0,DLINE,R12
        CALL(GETNET)
        STH     R0,DGROUP,R12           :Group number
        CALL(GETNET)
        STH     R0,DSUBSD,R12           :subsidiary
LOGC70  CALL(GETNET)                    :Skip to end
        CHI     R0,0C0
        JN      LOGC70
        POP(R5,R4,R0)
        RETURN(SKIP)                    :Return successful
:
: Call user data rejected, tell user and restart this routine if manual
:
LOGC80  CLI     R5,IDATA
        JN      LOGC90                  :J if not invitation to clear
        LIS     R4,6                    :Skip to reason
LOGC85  CALL(GETNET)
        SIS     R4,1
        JN      LOGC85
        CHI     R0,3
        JG      LOGC90                  :Unrecognised reason for rejection
        LR      R4,R0
        JE      LOGC90                  :Unrecognised reason for rejection
        SIS     R4,1
        SLHLS   R4,2                    :Convert reason into index
        L       R4,IIXERR,R4            :Pick up error message address
        CALL(LOGMES)
        J       LOGC95
LOGC90  LA      R4,LGPROE               :Protocol error
	CALL(LOGMES)
LOGC95  POP(R5,R4,R0)
        RETURN                          :Return failed
        SUBTTL GETALP routine ... Get response from user
:
: Routine name  GETALP
:
: Function      This routine gets a response data ALP skipping over 
:               supervisory ALPs.
:
: Called by     
:
: On entry      Link register R1
:
: On exit       
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(GETALP)
        PUSH(R0)
GETA10  READ(IPBTRM)                    :Read IPB buffer
        J       GETA60                  :No data available
        CHI     R0,IALPDA
        JE      GETA80                  :J if data ALP
:
GETA30  READ(IPBTRM)                    :Skip over supervisory ALP
        J       GETA10                  :No data available
        CHI     R0,A.ETX
        JE      GETA10                  :J if end of ALP
        J       GETA30
:
GETA60  SUS(SUSIP)                      :Suspend awaiting response
        J       GETA10                  :Try again
:
GETA80  POP(R0)
        RETURN
        SUBTTL GETNET routine ... Get response from network
:
: Routine name  GETNET
:
: Function      This routine gets a response from the network 
:
: Called by     LOGONM in this module
:
: On entry      Link register R1
:
: On exit       R0 contains response character
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(GETNET)
GETN10  READ(NET)                       :Read IPB buffer
        J       GETN60                  :No data available
        J       GETN80                  :J if data available
:
:
GETN60  SUS(SUSIP)                      :Suspend awaiting response
        J       GETN10                  :Try again
:
GETN80  RETURN
        SUBTTL GETIIX routine ... Get response from network
:
: Routine name  GETIIX
:
: Function      This routine gets an IIX response from the network 
:
: Called by     LOGIIX in this module
:
: On entry      Link register R1
:
: On exit       R5 contains response IIX code of message
:
: Uses          
:
: ---------------------------------------------------------------------
:
        RSTART(GETIIX)
        PUSH(R0)
GETI10  CALL(GETNET)
        CHI     R0,0BF
        JN      GETI10                  :J if not start IIX
        CALL(GETNET)                    :First character of IIX code
        LR      R5,R0
        SLHLS   R5,8                    :Top part of half word
        CALL(GETNET)
        OR      R5,R0                   :Bottom half
        POP(R0)
        RETURN
        SUBTTL BEGIIX routine ... Start IIX message output
:
: Routine name  BEGIIX
:
: Function      This routine starts an output IIX message, SIIX and
:               IIX code.
:
: Called by     
:
: On entry      Link register R1
:               IIX code in R5
:
: On exit       Network output channel will be open
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(BEGIIX)
        PUSH(R4)
        CALL(SNDSIX)                    :Send SIIX control message
        OPEN(NET)
        LR      R4,R5                   :IIX code
        SRHLS   R4,8                    :First byte
        WRITEB(NET)
        LR      R4,R5                   :Second byte
        WRITEB(NET)
        POP(R4)
        RETURN
:
        SUBTTL LOGMES routine ... Output message to screen
:
: Routine name  LOGMES
:
: Function      This routine appends a message to the screen. If the
:               message is on the last line then the screen is racked up
:               two lines.
:
: Called by     RESTAR in this module
:
: On entry      Link register R1
:               Address of message in SC format in R4
:               Current logging line number in R7
:
: On exit       
:
: Uses          OPEN, WRITEB, WRITES, CLOSE in INOUT
:
: ---------------------------------------------------------------------
:
        SSTART(LOGMES)
	PUSH(R0,R4)
        OPEN(IPBTRM)                    :Start IPB message
	PUSH(R4)
	LHI	R4,80
	WRITEB(IPBTRM)
	POP(R4)
	WRITES(IPBTRM)
	LHI	R0,C.LOGN
	SBT	R0,CBITS,R11		:Flag terminal output
	LHI	R4,82
	WRITEB(IPBTRM)
:	LHI	R4,A.ETX
:	WRITEB(IPBTRM)
        CLOSE(IPBTRM)                   :Send to terminal DCB
	POP(R4,R0)
        RETURN
:
        SEG     A.DATA
STLOGS  SC      /Logging in to /
LGPNRJ  SC      /"01CMT out of ports, please try again later/
LGNHIF  SC      /"01Accessed host is not ICL HIF/
LGPROE  SC      /"01Protocol error/
LGICUD  SC      /"01Invalid parameter/
LGONOK  SC      /"00Logon successful/
LOGE1   SC      /"01Error in username/
LOGE3   SC      /"01Error in password/
LOGE8   SC      /"01Port timed out or too many errors/
LOGE9   SC      /"01Bad MUD/
LOGEA   SC      /"01Circuits busy/
LOGEB   SC      /"01Host not available through net/
LOGEC   SC      /"01Host out of ports/
LOGED   SC      /"01Host down/
LOGEE   SC      /"01Host shut/
LOGEF   SC      /"01Try again in 2 minutes/
LOGE10  SC      /"01Access not permitted/
LOGE11  SC      /"01No host specified/
LOGE12  SC      /"01Bad host number/
LOGE13  SC      /"01MUD error/
LOGEU   SC      /"01Unrecognised error/
LGERMS  WC      LOGE1
        WC      LOGE1
        WC      LOGE3
        WC      LOGE1
        WC      LOGE3
        WC      LOGEU
        WC      LOGEU
        WC      LOGE8
        WC      LOGE9
        WC      LOGEA
        WC      LOGEB
        WC      LOGEC
        WC      LOGED
        WC      LOGEE
        WC      LOGEF
        WC      LOGE10
        WC      LOGE11
        WC      LOGE12
        WC      LOGE13
ISDIAL  EQ      8080                    :Select dialect
ISDRES  EQ      8081                    :Select dialect response
ISDC03  EQ      8092                    :ICL C03 dialect code
ITURK1  EQ      0C093                   :Turkey level 1
ICUD    EQ      0C089                   :Call user data
ICALLA  EQ      0C092                   :Call accept
IDATA   EQ      0C094                   :Invitation to clear
IIXE1   SC      /"01ICL system not responding to this device/
IIXE2   SC      /"01Requested device not supported/
IIXE3   SC      /"01Requested device not available at present/
IIXERR  WC      IIXE1
        WC      IIXE2
        WC      IIXE3
LGCER1  SC      /"01Line parameter invalid/
LGCER2  SC      /"01Group parameter invalid/
LGCER3  SC      /"01subsidiary parameter invalid/
LGCERR  WC      LGCER1
        WC      LGCER2
        WC      LGCER3
:
        EM

        SUBTTL TERM ... Terminal handler

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  1 JUL 86|  Origin                   |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SEG     A.CODE                  :Segment to contain this module
        MO      .,TERM                  :Delimit module
:
: This module contains the terminal interface (Consat) handler routines:
:
:       LOGST - Action needle received when user logs to CMT
:       PRTRH - Normal printer handler
:       DATMES - Process data from network
:       CTLMES - Process control message from network
:       REJECT - Discard error input
:       QRYTRM - Query terminal type from user
:
: There are no macros unique to this module.
        SUBTTL LOGST routine ... Logon process for terminal DCB
:
: Routine name  LOGST
:
: Function      This routine contains the routines to be obeyed when a
:               terminal logs into CMT. The terminal type is determined
:               either from the user profile table or from the user. 
:               The terminal is initialised and a screen buffer obtained. If
:               necessary a menu of logon options is output to the user
:               and the circuit(s) to the host interface are initiated.
:               On successful completion of these processes the DCB is
:               then handed over to PRTRH.
:
: Called by     ACTIVN
:
: On entry      DCB and CCB will have been initialised.
:
: On exit       All registers will have been preserved
:
: Uses          OPEN, WRITES, CLOSE, READ in INOUT
:
: ---------------------------------------------------------------------
:
TRMCTL	HC	2
	BC	0,0,1,0,7,0,8,0
:	
        DEFGEQ(LOGRST,.)                :Restart terminal entry
        J       LOGT50
        DEFGEQ(LOGST,.)                 :Start terminal entry
:
: Determine user profile. If not valid user then close him down.
:
        CALL(FNDUPF)                    :Get user profile table entry
        ST      R5,CUPROF,R11           :Store in CCB
        LR      R8,R5
        JN      LOGT10                  :J if valid user
:       LA      R4,EBADUS               :Error message, invalid username
        J       ENDIT                   :Close user down
:
: Determine terminal type and profile table address
:
LOGT10  EQ	.
	LH	R0,UPFDEV,R8
	LHI	R1,DTTPRT		;:Set up device type in DCB
	CHI	R0,DVLPTR
	JE	LOGT15
	LHI	R1,DTTCRD
	CHI	R0,DVCRDR
	JE	LOGT15
	LHI	R1,DTTOPR
:
LOGT15	STH	R1,DTYPE,R12
LOGT50  LA      R1,ACTCNT,,             :Control message table for terminal
        STH     R1,DCACT,R12
        LA      R6,TRMCTL,,
        LHL     R7,0,R6                 :Size of terminal parameters
LOGT60  AIS     R6,2                    :Point to first/next parameter
        LHL     R5,0,R6                 :Parameter no and value
        CALL(SNDSTP)                    :Send terminal parameter
        SIS     R7,2
        JG      LOGT60                  :Jump if more parameters
        CALL(INIPRT)                    :Initialise printer parameters
:
: Start another DCB to initiate logon to host
:
        LIS     R3,0                    :No port number associated with it
        IF      TSHDCB
        GL      TSTMEN
        LA      R4,TSTMEN,,             :Test user code address
        ELSE
        LA      R4,LOGSH,,              :Live user code address
        EI
        CALL(INIDCB)                    :Create and start DCB
        ST      R5,CHDCB,R11            :Store address in CCB
:
	LH	R0,UPFDEV,R8		:Get device type
        LHI     R1,DTHPRT
	CHI	R0,DVLPTR
	JE	LOGT80
:
	LHI	R1,DTHCRD
	CHI	R0,DVCRDR
	JN	LOGT85
	STH	R1,DTYPE,R5
	J	CARDH
:
LOGT85	LHI	R1,DTHOPR
	STH	R1,DTYPE,R5
	J	OPERH
:
LOGT80  STH     R1,DTYPE,R5             :Mark as host video DCB
        J       PRTRH                   :Main terminal handler routine

        SUBTTL PRTRH routine ... Normal printer handling rountine
:
: Routine name  PRTRH
:
: Function      Normal printer handler. This routine loops round checking 
:               network and IPB buffers for data. If any exists then data 
:               is processed. If both are empty then DCB is suspended 
:               awaiting input.
:
: Called by     LOGST
:
: On entry      
:
: On exit       
:
: Uses          READ in INOUT
:
: ---------------------------------------------------------------------
:
        DEFGEQ(PRTRH,.)
:
: Extract printer key character or Tymnet control message from network buffer
:
TERM30  READ(NET)                       :Get character from network
        J       TERM50                  :J if no data available
        THI     R0,80                   :Test if control message
        JE      TERM40                  :J if it is not
        CALL(CTLMES)                    :Process control message
        J       TERM30                  :Next message
:
TERM40  CALL(DATMES)                    :Process data message
        J       TERM30                  :Next message
:
: Extract ICL ALP from IPB buffer for video
:
TERM50  READ(IPBHST)                    :Get character from IPB
        J       TERM80                  :J if no data available
	THI	R0,80
	JE	TERM60			:Test for control message
	THI	R0,20
	JN	TERM60
	OPEN(NET)
	LHI	R4,80
	WRITEB(NET)
:
TERM55	READ(IPBHST)
	J	TERM56			:If end of message - output
	LR	R4,R0
	WRITEB(NET)
	CHI	R4,82
	JN	TERM55
TERM56	LHI	R1,C.LOGN
	RBT	R1,CBITS,R11
	CLOSE(NET)
	J	TERM50
TERM60  CALL(PRTALP)                    :Process IPB ALP
        J       TERM30                  :Repeat loop
:
TERM80  SUS(SUSIP)                      :Suspend awaiting input
        J       TERM30                  :Check buffers again

        SUBTTL DATMES routine ... Process CMT control keys
:
: Routine name  DATMES
:
: Function      Get a coded key from terminal. This routine reads a character 
:               from the input buffer. If it is data then it is translated 
:               into an ICL key code and returned in R5. If a control message
:               is found it is processed here.
:
: Called by     PRTRH
:
: On entry      Link register R1
:
: On exit       R5 will contain a coded key. All registers
:               will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(DATMES)
        PUSH(R5)
	LR	R5,R0
	CHI	R5,4			:Test for invalid command
	JG	CMTK99
:
        SLHLS   R5,2			:Convert into index
        J       CMTK10,R5
:
CMTK10  J       CMTK30                  : 0 - Zap
        J       CMTK70                  : 1 - Printer operable
        J       CMTK80                  : 2 - Printer inoperable
        J       CMTK90                  : 3 - Printer hold switch
	J	CMTK85
:
: Zap - close down this printer
:
:CMTK30	LA	R4,EUSER		:Close down message
CMTK30	J	ENDIT			:End it all for this user ........
:
: Printer operable report
:
CMTK70  CALL(PRTOPS)                    :Flag printer as operable
        J       CMTK99
:
: Printer inoperable report
:
CMTK85	LHI	R1,PS.IOS
	SBT	R1,CPSTAT,R11
:
CMTK80  CALL(PRTXPS)                    :Flag printer as inoperable
	J	CMTK99
:
: Printer hold
:
CMTK90	CALL(PRTHLD)
:
CMTK99  POP(R5)
        RETURN
        SUBTTL CTLMES routine ... Process control messages
:
: Routine name  CTLMES
:
: Function      Get a coded key from terminal. This routine reads a character 
:               from the input buffer. If it is data then it is translated 
:               into an ICL key code and returned in R5. If a control message
:               is found it is processed here.
:
: Called by     TERMH
:
: On entry      Link register R1
:
: On exit       R5 will contain a coded key. All registers
:               will have been preserved
:
: Uses          
:
: ---------------------------------------------------------------------
:
        SSTART(CTLMES,.)
        CHI     R0,0A6                  :Entering DEM
        JE      CTLM90
        CHI     R0,0A7                  :Leaving DEM
        JE      CTLM90
        CHI     R0,0AA                  :Green ball
        JE      CTLM90
        CHI     R0,0AB                  :Red ball
        JE      CTLM70
        CRUNCH(CRNOCO)                  :We don't support this code
:
:       Red ball
:
: Red ball is sent by Consat when it wants to cancel a green ball or hasn't
: received a reply to a green or red ball. We make sure outstanding green 
: ball is cancelled and send a red ball back as response.
:
CTLM70  CALL(SNDRB)                     :Respond with red ball
:
:
CTLM90  RETURN

        SUBTTL ENDIT routine ... Close down user
:
: Routine name  ENDIT
:
: Function      This routine closes down a user for one of the following
:               reasons:
:                       the user has requested it
:                       The user does not have access to CMT
:
: Called by     KBDH,ALPH
:
: On entry      Link register R1
:               Address of error message in R4
: On exit       Terminal type in R9. All registers
:               will have been preserved
:
: Uses          OPEN, WRITE, CLOSE, READ in INOUT
:
: ---------------------------------------------------------------------
:
        RSTART(ENDIT)                   :Close down entry point
        LIS     R6,1                    :End it flag
        J       ENDI05
:
        RSTART(RESTAR)                  :Restart entry point
        LIS     R6,0                    :Restart flag
ENDI05  L	R4,CHDCB,R11
	LHI	R2,D.NACT
	TBT	R2,DBITS,R4
	JE	ENDI08
	SUS(SUSVD)
	J	ENDI05
:
ENDI08	ST      R13,DSTCKP,R12
        L       R12,CPDCB,R11
        JE      ENDI20                  :J if no printer host DCB
        L       R13,DSTCKP,R12
        LHL     R1,DPORT,R12
        JE      ENDI10                  :J if no circuit
:
        CALL(SNDDET)                    :Close circuit
ENDI10  CALL(RETBUF)                    :Return all buffers
        LR      R5,R12
        CALL(PUTDCB)                    :Return DCB
        LIS     R1,0
        ST      R1,CPDCB,R11            :Flag no printer host DCB
ENDI20  L       R12,CHDCB,R11
        JE      ENDI40                  :J if no video host DCB
        L       R13,DSTCKP,R12
        LHL     R1,DPORT,R12
        JE      ENDI30                  :J if no circuit
        CALL(SNDDET)                    :Close circuit
ENDI30  CALL(RETBUF)                    :Return all buffers
        LR      R5,R12
        CALL(PUTDCB)                    :Return DCB
        LIS     R1,0
        ST      R1,CHDCB,R11            :Flag no video host DCB
ENDI40  L       R12,CTDCB,R11           :Back to terminal DCB
	LA	R13,DSTCK,R12
        ST      R13,DSTCKP,R12          :Restore stack
        LHL     R1,DPORT,R12
	CALL(RETBUF)			:Tidy up DCB
        L       R5,CCRBBF,R11
        JE      ENDI60                  :J if no screen buffer in CCB
        CALL(PUTCRB)                    :Return screen buffer
        LIS     R5,0
        ST      R5,CCRBBF,R11
ENDI60  LR      R6,R6                   :Is it an end or restart
        JE      ENDI80                  :J if restart
        LHL     R1,DPORT,R12            :Do we still have a circuit
        JE      ENDI70                  :J if not
        CALL(SNDDET)                    :Close circuit
ENDI70  LR      R5,R11
        CALL(PUTCCB)                    :Return CCB to free chain
        LR      R5,R12
        CALL(PUTDCB)                    :Return DCB to free chain
        SUS(SUSIP)                      :Dummy susp to return to EXEC
:
ENDI80  LA      R13,DSTCK,R12
        ST      R13,DSTCKP,R12          :Reset stack
        LHL     R1,DCBNO,R12
        SBT     R1,RUNREQ               :Flag this DCB as runable
        LIS     R1,0
        STH     R1,DSUSP,R12            :Not waitng for anything
        J       LOGRST                  :Restart terminal DCB
:
        EM


	SUBTTL STATUS ... Extended DDT code

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  9 JAN 86|  Modified BISYNC COM      |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:
        SUBTTL USER COMMAND HANDLER (DDT COMMAND ?STAT)

  IF    1-\DB.STA                       : DEFAULT DEBUG/STATUS TO ON
DB.STA  EQ      1
  EI

  IF    DB.STA                          : ASSEMBLE ONLY WITH DEBUG STATUS ON

        SEG     A.CODE
        RA      $00
        GL      DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM,R4SAV
        GL      DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL
        GL      HMASK

:       STATUS - User Command Handler
:
:       Version history:
:       13.3  08/19/83  <JOK>Changed DS.TOK to return first 8 chars of
:               TOKEN, changed DS.CMD to retain first 8 chars of command,
:               and changed DSTART to accept up to 8-character commands.
:       13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:               following 'QUIT' SVC to allow DDT "P" (proceede) command
:               to return the user to ":>" prompt.
:       13.1  11/17/81  <BAB>Added DNEXTK support, DS.DLM (last delimiter),
:               and fixed backspace for > 4 character entry, added the
:               command thought to be invalid to invalid command message.
:       13      08/81   <JK>Maintenance assumed by BAB from John Kopf
:
:               The Status package is intended to provide an extension to DDT,
:       invokable via the "?STAT" command in DDT.  Once invoked you may re-
:       activate it (provided you have not issued any DDT "G" (go) commands)
:       by typing "P ".
:
:               There is limited editing control built into the package:
:       ESC     aborts back to command level,
:       ^W      discards partial 'token' already input (word or number),
:       ^A      discards last char of token (backspace).
:       ^H      discards last char of token (backspace).

:               Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:       delimiters are:
:       C/R     L/F     H/T     ","     and BLANK.

:               Entry Points:
:       DSTART  Place to exit on completion of command.
:       DNEXTK  Get next token with out prompt.
:       DS.ILL  Place to exit on illegal command -- types "Illegal command"
:       DS.ERR  Place to exit on command error -- types "type '\' "
:       DS.EXI  Place to exit machine.
:       DS.QUI  Place to exit back to DDT.
:       DS.GCH  Get a character...Link on R1, char (with high-order bit forced)
:                       in R0...normal return if detected ^W, skip-4 if detect
:                       ^A, aborts back to DSTART if detects ESC.
:       DS.DEL  Check for delimiter...Link on R2, Character in R0.  Skip-4
:                       return unless this is a delimiter, then normal return.
:       DS.CUC  Convert to upper case...Link on R1, Character in R0.
:       DS.TOK  Get a string token...Link on R4, TOKEN returned in R3/R2...
:                       inputs up to 4 characters, returns them (in uppercase)
:                       left justified, 0 fill
:       DS.NUM  Get a number...Link on R5, expects Radix in R4...
:                       number returned in R0.  May ABORT if any character is
:                       input other than valid digit or delimiter.
:       DS.DLM  Location of last delimeter entered (1 byte)

:               There are two built-in commands:
:       Quit    exit back to DDT.
:       EXIt    exit machine.

:               additional commands may be defined via the DS.CMD macro:
:        DS.CMD(TEXT,ADDR)
:       Where:  TEXT    The (UPPERCASE) target command string.
:               ADDR    The virtual address to transfer to, to service that
:                               command.
:       DS.CMD generates a 16-byte descriptor for this command, at the point
:       assembly where it is invoked.  This descriptor is on a WORD boundary.



OUT     EQ      0B                      : Output SVC
IN      EQ      0A                      : Input SVC

DS.ELL  EQ      0                       : Null pointer for end-of-linked-list

        SEG     A.DATA
DS.DLM  BS      1                       : Last delimiter encountered
R4SAV   WS      1                       : Save-area for R4 in DS.TOK
	DEFGEQ(BADSTR,.)
	SC      /'xxxxxxxx'"8D"8A/      : Place to put bad command
STOKEN  EQ      BADSTR+2                : String-buffer for token
        SEG     A.CODE

:       Define elements for command-block
C.NEXT  EQ      0                       : Pointer to next command-block
C.ADDR  EQ      C.NEXT+4                : Pointer to command-handler
C.STR   EQ      C.ADDR+4                : Relative position of string

:       Define macro to generate this command-block
DS.CMD  MACRO(STR,ADDR)[ WS     0
   IF   DS.ELL
Q       WS      0
        ORG     DS.ELL
        WC      Q
        ORG     Q
   EI
DS.ELL  WC      0,ADDR
        AC      /STR/
        WS      0
 IF     DS.ELL+10-. ; WC 0; EI
]


:       TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST  DS.CMD(Q,DS.QUI)                : Exit back to DDT
        DS.CMD(QUIT,DS.QUI)             : Exit back to DDT
        DS.CMD(EXIT,DS.EXI)             : Exit
        DS.CMD(EXI,DS.EXI)              : Exit




:       Diagnostic messages
	DEFGEQ(TERR,.)
	SC      /Illegal command /
	DEFGEQ(TTERR,.)
	SC      /type '\'"8D"8A/
HLPMSG  SC      /"8D"8A"8D"8ATYPE '?' FOR MENU/
PROMPT  SC      /"8D"8ACOM:>/           : "CR|LF:>"
BKSPAC  SC      /"88 "88/               : Back-space
        SUBTTL  Command-scanner, Verifier, and Bitcher

:       Command-input Handler
DOIT    L       R0,C.ADDR,R1            : Go service this command
        JALR    R0,R0

:       Next Command
DSTART  SVC     OUT,HLPMSG
        SVC     OUT,PROMPT              : Issue Prompt
DNEXTK  JAL     R4,DS.TOK               : Get command-token
        LA      R1,CMDLST               : Search for string-match
DSTAR1  CL      R3,C.STR,R1             : check first-word
        JNFS    DSTAR2                  : no match
        CL      R2,C.STR+4,R1           : second-word
        JE      DOIT                    : Proceed if find a match

DSTAR2  L       R1,C.NEXT,R1            : Else continue scan
        JGBS    DSTAR1

DS.ILL  SVC     OUT,TERR                : "ILLEGAL COMMAND"
        SVC     OUT,BADSTR,,

DS.ERR  SVC     OUT,TTERR               : Tell user to type Flush-char

BITCH   JAL     R1,DS.GCH               : Flush input
         JBS    BITCH;   NOPR   0                       : ^W...Ignore
          JBS   BITCH;    NOPR  0                       : ^A...Ignore
        CLHI    R0,0DC                  : Read until "\" is found
        JNBS    BITCH
        J       DSTART                  : Then exit


:       Built-in Commands

:               Command EXIt
:               ===========-
DS.EXI  SVC     KIO,0                   : Disconnect


:               Command Quit (exit back to DDT)
:               =========---
DS.QUI  SVC     KIO,1                   : Return to DDT
        J       DSTART                  : If operator typed "P", get next cmd
        SUBTTL  U T I L I T I E S

:       Get a Command-token...Up to 8 chars long
:               Skips over extra characters to next delimiter
:       Link on R4
:       Token returned in R3/R2, Left justified, 0-fill
DS.TOK  ST      R4,R4SAV,,              : save R4

TOKEN0  LIS     R0,0                    : clear token buffer
        LA      R3,STOKEN,,             : set char-pointer
        ST      R0,0,R3
        ST      R0,4,R3

:       Scan for first character of TOKEN
TOKEN1  JAL     R1,DS.GCH               : Get next char
        JBS     TOKEN1   
        NOPR    0                       : ^W...Ignore
        JBS     TOKEN1
        NOPR    0                       : ^A...Ignore
        JAL     R2,DS.DEL               : Skip over delimiters
         J      TOKEN1
        JAL     R1,DS.CUC               : Convert to Upper-case
        CHI     R0,00DC                 : = "\" ?
        JE      DSTART                  : YES.  Print Prompt, get next command
        STB     R0,0,R3                 : no...start TOKEN accumulation
        AIS     R3,1                    : advance pointer
        LIS     R4,1                    : 1 char. found so far

TOKEN2  JAL     R1,DS.GCH               : Get another char
         J      TOKEN0                  : ^W...Start over
          J     TOKEN4                  : ^A...Toss last char
        JAL     R1,DS.CUC               : Convert to upper-case
        JAL     R2,DS.DEL               : Check for delimiter
         J      TOKEN3                  : Got one...skip to clean up
        CHI     R0,00DC                 : = "\" ?
        JE      DS.ILL                  : YES.  Treat as Illegal
        AIS     R4,1                    : one more character
        CHI     R4,8                    : If >= 8 chars, do not use this one
        JG      TOKEN2                  : YES...Scan for delimiter
        STB     R0,0,R3                 : NO...Accumulate chars
        AIS     R3,1                    : advance cursor
        J       TOKEN2                  : ..and get another char

TOKEN3  L       R4,R4SAV,,              : Restore R4
        L       R3,STOKEN,,             : place TOKEN into Registers
        L       R2,STOKEN+4,,
        JR      R4                      : Return TOKEN in R2/R3


:       Handle backspace in TOKEN
TOKEN4  SIS     R4,1                    : one less char
        JLE     TOKEN0                  : re-initialize if none left
        CHI     R4,8                    : If after backspace TOKEN is >= 8
        JGE     TOKEN2                  : then just decrement counter
        LIS     R0,0                    : else... drop one character
        SIS     R3,1                    :   back-up pointer
        STB     R0,0,R3
        J       TOKEN2                  : and get next char

:       Utility routine to read a number
:       uses R0-R3
:       Expects RADIX in R4
:       Link on R5
:       Aborts if first non-delimiter is not digit
:       Else returns number in R0
DS.NUM  JAL     R1,DS.GCH               : get next char
         JBS    DS.NUM;  NOPR   0                       : ^W...ignore
          JBS   DS.NUM;  NOPR   0                       : ^A...Ignore
        JAL     R2,DS.DEL               : check for delimiter char
         J      DS.NUM
        JAL     R2,DS.DIG               : test if char is digit
         J      DS.ILL                  : not a digit - give error-message
        CLR     R0,R4
        JGE     DS.ILL                  : digit is bigger than RADIX...Abort
        LR      R3,R0                   : put first digit into accumulator
NUMBER  JAL     R1,DS.GCH               : read next char
         J      DS.NUM                  : ^W...Start over
          J     DIVIDE                  : ^A...Toss last digit
        JAL     R2,DS.DEL               : Check for delimiter
         LR     R0,R3;   JR     R5        :YES
        JAL     R2,DS.DIG               : skip if digit
        J       DS.ILL                  : NO...Abort
        CLR     R0,R4
        JGE     DS.ILL                  : RADIX error...Bitch
        MR      R2,R4                   : build number
        AR      R3,R0                   : add new digit
        J       NUMBER                  : get next digit

DIVIDE  LIS     R2,0                    : got a ^A...Make double-precision arg.
        DR      R2,R4                   : Quotent into R3, where we want it
        J       NUMBER                  : now go back for more digits

:       Digit test
:       Check character read...Skip return if digit
:       Then R0=Binary value of HEX digit
:       uses R1, Link on 
	DEFGEQ(DS.DIG,.)
	JAL     R1,DS.CUC               : Convert to upper-case
        LR      R1,R0                   : Copy char
        SHI     R1,0B0                  : is it "0"?
        JLR     R2                      : return if less than "0"
        SIS     R1,0B9-0B0              : is it "9"
        JLEFS   DIGIT                   : less than "9", then a good digit
        SIS     R1,0C1-0B9              : is it "A"?
        JLR     R2                      : return if less than "A"
        SIS     R1,0C6-0C1              : is it "F"?
        JGR     R2                      : return if greater than "F"
        SIS     R0,7                    : 0A - "A" (partial conversion)

DIGIT   SHI     R0,0B0                  : "0"
        J       4,R2                    : skip-return

:       Check for delimiter
:       Link    R2
:       Uses    R0,R1
:       Skip-4 return unless (R0) is a delimiter-character
DS.DEL  LHI     R1,DLEN-1               : number of delimiter chars
        STB     R0,DS.DLM,,             : save delimiter

DELIM   CLB     R0,DLIST,R1             : compare to a delimiter
        JER     R2                      : return if delimiter
        SIS     R1,1                    : check next delimiter
        JGEBS   DELIM                   : loop if any more delimiters
        J       4,R2                    : skip-return

:       List of delimiter chars
DLIST   AC      ' ,'                    : Blank,","
        BC      8D,8A,89                : CR,LF,HT
DLEN    EQ      .-DLIST                 : Number of delimiter chars

:       Input a Character
:       Link    R1
:       Normal-return:   ^W Input...Flush entry
:       Skip-4 return:  ^A or ^H Input...flush last char
:         SKIP-8 return: Char in R0 (high-bit on)
:       Aborts to command-scanner on "ESC"
DS.GCH  SVC     IN,0F                   : get the char
         J      DS.GCH
        OHI     R0,80                   : set high-order bit
        CLHI    R0,9B                   : check for escape
         JE     DSTART                  : abort, proceed with prompt if so
        CLHI    R0,97                   : check for ^W
         JER    R1                      : normal-return
        CLHI    R0,81                   : check for ^A
         JE     4,R1                    : Skip-4 return
        CLHI    R0,88                   : check for ^H
         JN     8,R1                    : No, skip-8 return, Char in R0

        SVC     OUT,BKSPAC              : Back-space
        J       4,R1                    : skip-4 return for ^H

:       Convert char in (R0) to upper-case
:       Link on R1
DS.CUC  CLHI    R0,0E1                  : Compare with "a"
        JLR     R1                      : Exit if it can't be lower-case
        CLHI    R0,0FA                  : Compare with "z"
        JGR     R1                      : Not lower-case...Just return
        SHI     R0,20                   : Lower-case...Convert to upper-case
        JR      R1                      : and return


        EI

        SUBTTL  ?STAT Command Handlers  
:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     | 10 JAN 86|  Modified BISYNC COM      |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:

:       CMT OPERATION MONITOR: COM

:       Valid commands accepted are:

:       EXIT or EXI - log off
:       QUIT or Q - exit ?STAT (back to DDT)
:       HELP or ? - print this list
:       INS or INST - Instructions
:       STATE - Slot status
:       VERSION - Description of the slot
:       NAMES - Displays table of user namer to slot
:       MENU username - Screen menu and logon strings associated w/username
:       USER username OR port XX - Numeric lock status and circuits
:       PORTS - Ports associated with each username
:       CRASH - Crash information
:       IRING port1  port2 port3 OR address - Iring associated with each port
:       ORING port1 port2 port3 OR address  - Oring associated with each port
:       RINGS port1 port2 port3 - Alternate rings displayed
        IF      DB.STA

:       Some globals
        GL      CTA,ASMTIM


        SEG     A.CODE
        MO      .,COM

:************************************************************
:       Define some MACROs to make the code more readable!
:************************************************************

        KILL    IFERR,GETNUM,PRINT,DPRINT       : Insure no conflicts

:       MACRO to input a number (into R0):
:       ARG -   radix to be used

GETNUM  MACRO(RAD)[
 IF     $A RAD-15
        LHI     R4,$A RAD
 ELSE
        LIS     R4,$A RAD
 EI
        JAL     R5,DS.NUM,,
]

:       MACRO to print a number (in R0) on terminal
:       ARG     Use
:        1      Number of Digits
:        2      Any sum of:     .S, .B, .Z, one of [ .D, .H, or .O]

.S      EQ      80                      : Signed output
.B      EQ      20                      : Blank fill
.Z      EQ      40                      : Zero fill
.D      EQ      0A                      : Decimal
.O      EQ      08                      : Octal
.H      EQ      10                      : Hexidecimal

DPRINT  MACRO(ND,M2)[
        LHI     R1,(ND*100)!M2
        SVC     KIO,$A 10
]

:       MACRO to print a line of text on terminal
:       ARG -   address of line of text (SC format)

PRINT   MACRO(LINE)[
        SVC     K.OUT,LINE
]

:       MACRO to perform test, print MSG if false
IFERR   MACRO(CND,MSG)[
        J`CND`FS        .+8
        LA      R1,MSG
        J       PERR
]

:       MACRO to see if last delimiter was a carriage return, jumps to ADR
:       if not carriage return to process following argument
ANYARG  MACRO(ADR)[
        LHI     R0,8D
        CLB     R0,DS.DLM,,
        JN      ADR
]
:************************************************************
:       command block
:************************************************************

        DS.CMD(HELP,HELPC)               : Print Command List
        DS.CMD(?,HELPC)                  : Print Command List
        DS.CMD(INS,INSTR)               : Print instructions
        DS.CMD(INST,INSTR)              : Print instructions
        DS.CMD(STATE,STATE)             : Print status of slot
        DS.CMD(VERSION,VERSN)           : Print description of the slot
        DS.CMD(NAMES,NAMES)             : Print table of usernames
        DS.CMD(DEBUG,PSTART)            : Print screen menu and logon strings
        DS.CMD(USER,CUSER)              : Print user options and circuits
        DS.CMD(PORTS,CPORTS)            : Print active port info
        DS.CMD(CRASH,CCRASH)            : Print infor about crashes
        DS.CMD(IRING,CIRING)            : Display of iring
        DS.CMD(IR,CIRING)               : Display of iring
        DS.CMD(ORING,CORING)            : Display of oring
        DS.CMD(OR,CORING)               : Display of oring
        DS.CMD(RINGS,CRINGS)            : Display of alternating rings

:************************************************************
:       INSTR - Print editing characters and delimiters
:************************************************************

INSTR   HS      0
        JAL     R2,BANNER               : display banner
        PRINT(NL)
        PRINT(INSTM1)                   : display text
        PRINT(INSTM2)
        PRINT(INSTM3)
        PRINT(INSTM4)
        PRINT(INSTM5)
        PRINT(INSTM6)
        PRINT(INSTM7)
        PRINT(NL)
        PRINT(INSTM8)
        J       DSTART
:********************
:       help
:********************

HELPC   JAL     R2,BANNER               :PRINT BANNER
        PRINT(NL)
        PRINT(HELP01)
        PRINT(HELP02)
        PRINT(HELP03)
        PRINT(HELP04)
        PRINT(HELP05)
        PRINT(HELP06)
        PRINT(HELP08)
        PRINT(HELP09)
        PRINT(HELP0A)
        PRINT(HELP0B)
        PRINT(HELP07)
        PRINT(HELP0C)
        PRINT(HELP0D)
        PRINT(HELP0E)
        PRINT(HELP0F)
        PRINT(HELP10)
        J       DSTART
:********************
:       version
:********************

VERSN   JAL     R2,BANNER               :Print banner
        PRINT(NL)
        PRINT(ASSM)                     :print date and time of assembly
        LI      R3,ASMTIM
        LHI     R4,10
        LA      R5,DATTMS,,
        JAL     R6,DATIME
        SVC     K.OUT,PDATE,,           :output date and time
        J       DSTART
:************************************************************
:       STATE -  Displays the status of the slot
:************************************************************

STATE   JAL     R2,BANNER               :DISPLAY BANNER
        PRINT(NL)
        PRINT(STATTL)                   :DISPLAY STATUS HEADER
        PRINT(MUSRTL)                   :DISPLAY MAX # USERS
        LHI     R0,HPRT0
        DPRINT(3,.D!.B)
        PRINT(MPRTTL)                   :DISPLAY MAX # PRINTERS
        LHI     R0,NPRINT
        DPRINT(3,.D!.B)
        PRINT(NL)                       :DISPLAY # ACTIVE TPORTS

        LHI     R3,0                    :INIT PORT COUNTERS
        LHI     R4,0
        LHI     R6,0
        LHI     R2,((MAXPRT)/10)*2
NXHW1   LH      R0,ACP,R2               :CHECK FOR ACTIVE PORTS
DOAGN1  JFFOH   R0,TOTCNT               :LOOK FOR FIRST BIT ON 
                                        :WITHIN HALF WORD
        SIS     R2,2                    :NEXT HALF WORD GROUP
        JGEBS   NXHW1
        J       TOTLS
TOTCNT  JAL     R5,TRNOFF               :GO TURN OFF BIT
        AHI     R3,1                    :OTHERWISE THIS IS A CPDCB
        J       DOAGN1

TTCNT   AHI     R4,1
        J       DOAGN1
THCNT   AHI     R6,1
        J       DOAGN1
TOTLS   PRINT(NTPTTL)
        LHR     R0,R4                   :OUTPUT TOTAL TPORTS
        DPRINT(3,.B!.D)
        PRINT(NHPTTL)
        LHR     R0,R6                   :OUTPUT TOTAL HPORTS
        DPRINT(3,.B!.D)
        PRINT(NPPTTL)
        LHR     R0,R3                   :OUTPUT TOTAL PPORTS
        DPRINT(3,.B!.D)
        J       DSTART

:************************************************************
: TRNOFF- SUBROUTINE TO TURN OFF BIT
:************************************************************

TRNOFF  XH      R0,HMASK,R1,R1
        SLLS    R2,3                    :COMPUTE PORT NUMBER
        OR      R1,R2
        SRLS    R2,3
        SLLS    R1,2                    :MAKE FULLWORD POINTER
        L       R12,PORTAB,R1           :LOCATE DCB
        L       R11,DCCB,R12
        JR      R5

:************************************************************
:       NAMES - Prints list of tymfile usernames
:************************************************************

NAMES   JAL R2,BANNER                   :OUTPUT BANNER
        PRINT(NL)
        PRINT(TYMNAM)                   :OUTPUT NAME HEADER
        LHI     R1,NUMUNM               :Number of usernames
        LA      R9,UPFLST
NXNAM   PRINT(NL)
        LCS     R8,8                    :INDEX WITHIN NAME
CKNAM   LB      R0,UPFUSR+8,R9,R8
        THI     R0,80                   :WILDCARD?
        JNFS    OKCHAR                  :NO,OUTPUT CHAR
        LHI     R0,A.PND                :YES,SUBSTITUTE #       
OKCHAR  SVC     KIO,$A14                :OUTPUT CHAR
        AIS     R8,1                    :GET NEXT CHAR
        JLBS    CKNAM                   
        AHI     R9,UPFSIZ
        SIS     R1,1
        JG      NXNAM                   :GO TO NEXT NAME
        J       DSTART

:************************************************************
:       MENU - Prints screen menu and logon strings
:               associated with the username
:************************************************************
OUT	EQ	0B
:
C.NEXT	EQ	0
C.ADDR	EQ	C.NEXT+4
C.STR	EQ	C.ADDR+4
:
P.DOIT	L       R0,C.ADDR,R1            : Go service this command
        JALR    R0,R0
:
:       Next Command
:
PSTART  SVC     OUT,PHLPMS
        SVC     OUT,PPRMPT              : Issue Prompt
PNEXTK  JAL     R4,DS.TOK               : Get command-token
        LA      R1,P.CMND               : Search for string-match
PSTAR1  CL      R3,C.STR,R1             : check first-word
        JNFS    PSTAR2                  : no match
        CL      R2,C.STR+4,R1           : second-word
        JE      P.DOIT                  : Proceed if find a match
:
PSTAR2  L       R1,C.NEXT,R1            : Else continue scan
        JGBS    PSTAR1
:
PS.ILL	SVC     OUT,TERR                : "ILLEGAL COMMAND"
        SVC     OUT,BADSTR,,
:
	SVC     OUT,TTERR               : Tell user to type Flush-char
:
PITCH   JAL     R1,DS.GCH               : Flush input
        JBS     PITCH;   NOPR   0                       : ^W...Ignore
        JBS	PITCH;    NOPR  0                       : ^A...Ignore
        CLHI    R0,0DC                  : Read until "\" is found
        JNBS    PITCH
        J       PSTART                  : Then exit
:
PS.NUM  JAL     R1,DS.GCH               : get next char
        JBS     PS.NUM;  NOPR   0                       : ^W...ignore
        JBS     PS.NUM;  NOPR   0                       : ^A...Ignore
        JAL     R2,DS.DEL               : check for delimiter char
        JR	R6
	NOPR	0
        JAL     R2,DS.DIG               : test if char is digit
        J       PS.ILL                  : not a digit - give error-message
        CLR     R0,R4
        JGE     PS.ILL                  : digit is bigger than RADIX...Abort
        LR      R3,R0                   : put first digit into accumulator
P.NUM  JAL     R1,DS.GCH               : read next char
        J       PS.NUM                  : ^W...Start over
        J       P.DIVD                  : ^A...Toss last digit
        JAL     R2,DS.DEL               : Check for delimiter
        LR      R0,R3
	JR      R5        :YES
        JAL     R2,DS.DIG               : skip if digit
        J       PS.ILL                  : NO...Abort
        CLR     R0,R4
        JGE     PS.ILL                  : RADIX error...Bitch
        MR      R2,R4                   : build number
        AR      R3,R0                   : add new digit
        J       P.NUM                  : get next digit

P.DIVD  LIS     R2,0                    : got a ^A...Make double-precision arg.
        DR      R2,R4                   : Quotent into R3, where we want it
        J       P.NUM                  : now go back for more digits

:
:	PSET
:
PSET	ANYARG(PSET1)
PSL2	PRINT(NOARG)
	J	PSTART
:
PSET1	EQ	.
	LHI	R4,$A 10		: Get break point number
	LA	R6,PSL2
	JAL	R5,PS.NUM
:
	LR	R7,R0			: Save breakpoint number
	ANYARG(PSET2)
:
PSL1	SBT	R7,PRBITS
	J	PSTART
:
PSET2	JAL	R4,DS.TOK
	SRL	R3,$A 24
	NHI	R3,7F
	CHI	R3,52			: Test for 'R'
	JN	PS.ILL
:
	SBT	R7,PTBITS
	J	PSL1
:
PUSET	EQ	.
	ANYARG(PUSET1)
	LIS	R2,0
	LHI	R3,32			: Set up clear count
	LIS	R4,0			: And word offset
:
PUSALL	STB	R2,PRBITS,R4		: Clear break and repeat flags
	STB	R2,PTBITS,R4
	AIS	R4,4
	SIS	R3,1
	JN	PUSALL
	J	PSTART
:
PUSET1	EQ	.
	LHI	R4,$A 10		: Get break point number
	LA	R6,PSL2
	JAL	R5,PS.NUM
:
	LR	R7,R0			: Save breakpoint number
:
	RBT	R7,PRBITS
	RBT	R7,PTBITS
	J	PSTART
:
PHELP	EQ	.
	PRINT(NL)
	PRINT(HELP01)
	PRINT(HELP04)
	PRINT(PMENU1)
	PRINT(PMENU2)
	PRINT(PMENU3)
	PRINT(PMENU4)
	PRINT(PMENU5)
	PRINT(PMENU6)
	PRINT(PMENU7)
	PRINT(PMENU8)
	PRINT(PMENU9)
	PRINT(PMENUA)
	PRINT(NL)
	J	PSTART
:
PQUIT	EQ	.
	J	DSTART
:
PMON	EQ	.
	L	R0,PCFLAG
	JN	PMON1				: Test for break point reached
:
	SVC	FASTD
	JAL	R14,XDRKBD			: Test for K/B input
	J	PSTART
	J	PMON
:
:
PMON1	PRINT(PMONST)
	L	R0,PCFLAG		: If reached - output breakpoint number
	DPRINT(3,.B!.D)
	PRINT(NL)
:
	L	R4,PCFLAG
	SLLS	R4,2
	AI	R4,S4BASE-4		: Get pointer to message table entry
	L	R3,0,R4
	JE	PSTART			: Exit if no message
	LB	R4,0,R3			: Get message count
	AIS	R3,1
:
PMON4	LB	R0,0,R3
	SVC	KIO,$A 14		: Output message
	AIS	R3,1
	SIS	R4,1
	JN	PMON4
	PRINT(NL)
	J	PSTART
:
:	REGS - displays the contents of the registers
:
PREGS	LHI	R5,$A 14
	LIS	R4,8
	LIS	R9,2
:
	PRINT(R0HDR)
	L	R0,TPUSR0
	DPRINT(8,.Z!.H)
:
	PRINT(R1HDR)
	L	R0,TPUSR1
	DPRINT(8,.Z!.H)
	PRINT(NL)
:
PREGS1	LHI	R0,52			: /R/
	SVC	KIO,$A 14
:
	LR	R0,R9
	CHI	R9,$A 9
	JG	PREGS2
	DPRINT(1,.Z!.D)
	J	PREGS3
PREGS2	DPRINT(2,.Z!.D)
PREGS3	LHI	R0,20
	SVC	KIO,$A 14
	SVC	KIO,$A 14
	L	R0,S.R0,R4
	DPRINT(8,.Z!.H)
	PRINT(NL)
	AIS	R4,4
	AIS	R9,1
:
	SIS	R5,1
	JN	PREGS1
:
	PRINT(NL)
	J	PSTART
:
:	RSET0 - 	updates the contents of the specified register
:
PRSET	ANYARG(PRSET1)
PRSL1	PRINT(NOARG)
	J	PSTARTP
:
PRSET1	LA	R6,PRSL1
	LHI	R4,$A 10
	JAL	R5,PS.NUM
:
	CHI	R0,$A 16
	JGE	PS.ILL
:
	LR R7,R0
	ANYARG(PRSET2)
	PRINT(NOARG)
	J	PSTART
:
PRSET2	LHI	R4,$A 16
	JAL	R5,PS.NUM
:
	LR	R7,R7
	JE	PRSET3
	CHI	R7,1
	JE	PRSET4
:
	SLLS	R7,2
	ST	R0,S.R0,R7
	J	PSTART
:
PRSET3	ST	R0,TPUSR0
	J	PSTART
:
PRSET4	ST	R0,TPUSR1
	J	PSTART
:
:	DUMP - displays memory
:
MAC.PR	EQ	10
MAC.WP	EQ	20
MAC.EP	EQ	80
:
PDUMP	ANYARG(PDMP1)
PDMP2	PRINT(NOARG)
	J	PSTART
:
PDMP1	LA	R6,PDMP2
	LHI	R4,$A 16
	JAL	R5,PS.NUM		: Get main memory address	
:
	LR	R7,R0
	LA	R6,PDMP3
	JAL	R5,PS.NUM		: Get read length
:
	AIS	R0,3
	NHI	R0,7FFC
	LR	R9,R0
:
PDMP7A	LR	R1,R7
	NI	R1,0F0000			: Get segment number
	SRL	R1,$A 16
	LR	R0,R1
	SVC	SYS,$A 15		: Get MAC register for the segment
	LR	R2,R0
:
	THI	R0,MAC.PR
	JE	MERR1
:
	LR	R0,R2
	NI	R2,0FF00000		: And the segment length field
	SRLS	R2,$A 12
	AHI	R2,0FF
	LR	R3,R7
	NI	R3,0F0000
	AR	R2,R3
:
	CR	R7,R2
	JG	MERR3
:
	LR	R3,R7
	AR	R3,R9
	CR	R3,R2
	JG	MERR4
:
PDMP7	LIS	R8,4
	LR	R0,R7
	DPRINT(8,.Z!.H)			: Print address
	PRINT(PDHMS)
:
	LR	R10,R7
PDMP6	L	R0,0,R7			: Get data word
	DPRINT(8,.Z!.H)			: And display it
:
	AIS	R7,4			: Update data pointer
	SIS	R9,4			: And output count
	JE	PDMP5			: Exit if all output
:
	SIS	R8,1			: Update values per line count
	JE	PDMP5
:
	PRINT(PDSPS)
	J	PDMP6
:
PDMP5	PRINT(PDSPS)
PDMP5A	LB	R0,0,R10
	NHI	R0,7F
	CHI	R0,20
	JGE	PDMP5B
:
	LHI	R0,2D
:
PDMP5B	SVC	KIO,$A 14
	AIS	R10,1
	CR	R10,R7
	JN	PDMP5A
:
	PRINT(NL)
	LR	R9,R9
	JE	PSTART
	J	PDMP7
:
PDMP3	LIS	R9,4
	J	PDMP7A
:
MERR1	PRINT(MERMS1)
	J	PSTART
:
MERR2	PRINT(MERMS2)
	J	PSTART
:
MERR3	PRINT(MERMS3)
	J	PSTART
:
MERR4	PRINT(MERMS4)
	J	PSTART
:
MERR5	PRINT(MERMS5)
	J	PSTART
:
:	MODIFY - modifies memory locations
:
PMOD	ANYARG(PMOD1)
PMOD2	PRINT(NOARG)
	J	PSTART
:
PMOD1	LA	R6,PMOD2
	LHI	R4,$A 16
	JAL	R5,PS.NUM
:
	LR	R7,R0
	LR	R1,R7
	NI	R1,0F0000			: Get segment number
	SRL	R1,$A 16
	LR	R0,R1
	SVC	SYS,$A 15		: Get MAC register for the segment
	LR	R9,R0
:
	THI	R0,MAC.PR
	JE	MERR1
:
	THI	R0,MAC.WP
	JN	MERR5
:
	NI	R9,0FF00000		: And the segment length field
	SRLS	R9,$A 12
	AHI	R9,0FF
	LR	R3,R7
	NI	R3,0F0000
	AR	R9,R3
:
	CR	R7,R9
	JG	MERR3
:
	PRINT(NL)
:
PMOD4	LR	R0,R7
	CR	R0,R9
	JG	PMOD3
:
	DPRINT(8,.Z!.H)
	PRINT(PDSPS)
	L	R0,0,R7
	DPRINT(8,.H!.Z)
	PRINT(PDSPS)
:
	LA	R6,PMOD3
	LHI	R4,$A 16
	JAL	R5,PS.NUM
:
	ST	R0,0,R7
	AIS	R7,4
	J	PMOD4
:
PMOD3	PRINT(NL)
	J	PSTART

:
:	LIST
:
S4BASE 	EQ	40000
:
PLIST 	EQ	.
	PRINT(PLSHDR)
	LIS	R8,1			: Set up break point number
	LI	R3,S4BASE
:
PLAB3	L	R4,0,R3			: Get message pointer
	JE	PLAB1
:
	LR	R0,R8
	DPRINT(4,.D!.B)			: Output break number
	PRINT(PDSPS)
:
	LB	R7,0,R4			: Get message length
	AIS	R4,1
:
PLAB2	LB	R0,0,R4			: Get data byte
	SVC	KIO,$A 14
	AIS	R4,1
	SIS	R7,1
	JN	PLAB2
:
	PRINT(NL)
	AIS	R8,1
	AIS	R3,4			:  Update pointer to next message
	J	PLAB3
:
PLAB1	PRINT(NL)
	J	PSTART
:
:	GO
:
PGO	EQ	.
	LIS	R0,0
	ST	R0,PCFLAG
	J	PSTART



:************************************************************
:       USER -  If username input, all circuits associated with name
:               displayed, otherwise,only circuits associated
:               with user whose port# is given are displayed.  
:************************************************************

CUSER   ANYARG(CUSER1)                  :CHECK FOR ARGUMENT
        PRINT(NOARG)                    :NONE,SEND ERROR MSG AND RET COM
        J       DSTART


CUSER1  JAL     R4,DS.TOK               :GET ARGUMENT   
        L       R1,CPORT        
        CR      R3,R1                   :COMPARE 1ST WORD W/PORT
        JE      RDPRT                   :GO READ PORT NUMBERS

:ARGUMENT IS A USERNAME

        LIS     R9,1                    :SET USER NAME ARG FLAG
        OI      R2,80808080             :TURN HI BITS OF CHARS ON
        OI      R3,80808080
        LR      R7,R2                   :SAVE TOKENS
        LR      R8,R3
        LIS     R2,3
        RBT     R2,B.FLAGS              :INITIALIZE BIT 3 FLAG
        JAL     R2,BANNER

        LHI     R2,((MAXPRT)/10)*2
NXHW3   LH      R0,ACP,R2               :CHECK FOR ACTIVE PORTS
DOAGN3  JFFOH   R0,CMPNM1               :LOOK FOR FIRST BIT ON 
                                        :WITHIN HALF WORD
        SIS     R2,2                    :NEXT HALF WORD GROUP
        JGEBS   NXHW3
        LIS     R2,3
        RBT     R2,B.FLAGS              :WAS THE USERNAME FOUND?
        JN      DOAGN4
        PRINT(NOTACT)                   :NO..USERNAME NOT ACTIVE
DOAGN4  J       DSTART          :NO MORE PORTS...RETURN

CMPNM1  JAL     R5,TRNOFF
        LHL     R5,DTYPE,R12
:        CHI     R5,DTTERM               :IS THIS A TDCB?
        JN      DOAGN3                  :NO,FIND NEXT PORT      
        L       R6,CUNAME,R11
        CR      R8,R6                   :COMPARE NAME(FIRST 4 CHAR)     
        JN      DOAGN3                  :GO TO NEXT PORT
        L       R6,CUNAME+4,R11         :COMPARE NAME(NEXT 4 CHAR)
        CR      R7,R6
        JN      DOAGN3
        ST      R0,PSAV1
        ST      R2,PSAV2
        LIS     R2,3
        SBT     R2,B.FLAGS              :FLAG USERNAME FOUND
        J       NLK                     :OK...OUTPUT INFO

: PORT # GIVEN SO INDEX TO THE CORRECT PORT
 
RDPRT   ANYARG(RDPRT1)
        PRINT(NOARG)
        J       DSTART

RDPRT1  LIS     R9,0                    :FLAG AS PORT ARG
        LHI     R4,10                   :SET RADIX TO HEX
        JAL     R5,DS.NUM               :GET NUMBER IN R0       

: LOCATE THE PROPER DCB

        SLLS    R0,2
        LR      R5,R0
        L       R12,PORTAB,R5
        L       R11,DCCB,R12

: NOW START OUTPUTING SOME INFORMATION

NLK     ST      R0,PSAV1
        ST      R2,PSAV2
        JAL     R2,BANNER

: OUTPUT TERMINAL PORT NUMBER

TRM0    PRINT(NL)
        PRINT(TPTTL)
        LH      R0,DPORT,R12
        JE      NCTMSG                  :IF 0=NO CIRCUIT
        DPRINT(3,.B!.H)

: OUTPUT TERMINAL LOGON STRING

        PRINT(LSTTL1)
        LCS     R3,8
TRM1    LB      R0,CUNAME+8,R11,R3
        SVC     KIO,$A14                :OUTPUT BYTE OF USERNAME
        AIS     R3,1                    :INCREMENT NAME CHAR COUNTER
        JLBS    TRM1
        LI      R0,A.COLN               :ADD A COLON IF DONE
        SVC     KIO,$A14
        LHI     R0,HOST0                :OUTPUT HOST LNUMBER
        DPRINT(5,.D!.B)

:GET HOST INFO

        L       R12,CHDCB,R11
        JE      PLUTTL
        PRINT(NL)
        PRINT(HPTTL)
        JAL     R5,GTLGST       

: GET PRINTER INFO

PLUTTL  L       R12,CPDCB,R11
        JE      PLUTT2

        PRINT(NL)
        PRINT(PPTTL)
        JAL     R5,GTLGST
PLUTT2  L       R0,PSAV1
        L       R2,PSAV2
        LR      R4,R9           :WAS IT A USERNAME ARG?
        JE      DSTART
        J       DOAGN3

: NO PORTS ACTIVIATED

NCTMSG  PRINT(NOCRT)
        L       R0,PSAV1
        L       R2,PSAV2
        LR      R4,R9                   :WAS THIS A USERNAME?
        JN      DOAGN3                  :GO LOOK AT NEXT PORT
        J       DSTART  

: GET LOGON STRING

GTLGST  LH      R0,DPORT,R12            :GET HPORT
        JE      NCTMSG                  :NO CIRCUIT
        DPRINT(3,.B!.H)
        PRINT(LSTTL1)
        LHL     R6,CLSTRS,R11           :GET INDEX TO SELECTED LOGON
        LB      R0,LSTRS,R6             :GET # ELEM IN STRING
        AR      R0,R0                   :DOUBLE # ELEM FOR COMPW/HALFWD
        CLHI    R0,2                    :MANUAL LOGON?
        JG      GTLG1                   :NO
        PRINT(MANLOG)                   :PRINT MANUAL LOGON MSG
        JR      R5                      :RETURN TO NEXT CIRCUIT
GTLG1   LHL     R1,LSTRS+2,R6           :GETINDEX TO 1ST ELEM
        LHL     R3,DTYPE,R12
        CHI     R3,DTHPRT               :J if not printer
        JN      GTLG2
        AIS     R1,4
GTLG2   LHL     R3,STRLST,R1
        SLLS    R3,2                    :MAKE FULLWORD INDEX
        L       R3,ELEADR,R3            :GET ADDR OF STRING
        LB      R4,0,R3                 :GET COUNT OF CHAR
        LA      R6,TMPNAM
        LIS     R2,0
NXBYT0  LB      R0,0,R3,R2              :LOAD A CHAR
        STB     R0,0,R6,R2              :STORE IT                       
        AIS     R2,1
        CR      R4,R2
        JN      NXBYT0
        LHI     R2,0
NXBYT1  AIS     R2,1
        LB      R0,TMPNAM,R2            :GET A BYTE FROM THE ELEM
        JN      NXBYT2                  :J if not wild card
        LHI     R0,A.QUE                :Replace wild card by ?
NXBYT2  CHI     R0,8D                   :IS THIS A CR?
        JE      GTDSP                   :GET THE DSP LOGON NEXT
        SVC     KIO,$A14                :,OUTPUT CHAR   
        CR      R4,R2                   :DONE WITH ELEM?
        JN      NXBYT1

: GET CUA CIRCUIT INFORMATION

GTDSP   PRINT(LINTTL)                   :PRINT HEADER
        LHL     R0,DLINE,R12            :GET LINE
        DPRINT(2,.B!.D)
        PRINT(GRPTTL)                   :PRINT HEADER
        LHL     R0,DGROUP,R12           :GET GROUP
        DPRINT(2,.Z!.H)
        PRINT(SUBTTL)                   :GET HEADER
        LHL     R0,DSUBSD,R12           :GET SUBSD
        DPRINT(2,.Z!.H)
        JR      R5
        
:************************************************************
:       PORTS - displays information about all the active ports
:               associated with each username in the slot.
:************************************************************

CPORTS  JAL     R2,BANNER               :PRINT BANNER

        LHI     R2,((MAXPRT)/10)*2
NXHW4   LH      R0,ACP,R2               :CHECK FOR ACTIVE PORTS
DOAGN4  JFFOH   R0,OUTINF               :LOOK FOR FIRST BIT ON 
                                        :WITHIN HALF WORD
        SIS     R2,2                    :NEXT HALF WORD GROUP
        JGEBS   NXHW4
        J       DSTART

OUTINF  JAL     R5,TRNOFF
        LHL     R5,DTYPE,R12
:        CHI     R5,DTTERM               :IS IT A TERMINAL DCB
        JE      PRTNAM                  :GO PRINT USERNAME
        J       DOAGN4

: OUTPUT USERNAME INFORMATION

PRTNAM  ST      R0,PSAV1
        ST      R2,PSAV2
        PRINT(NL)
        PRINT(UNMTL)                    :PRINT HEADER
        LCS     R3,8                    :NEGATIVE INDEXING
PRTN1   LB      R0,CUNAME+8,R11,R3
        THI     R0,80                   :IS THIS  AWILD CARD?
        JNFS    PRTN2
        LHI     R0,A.PND                :INSERT A #
PRTN2   SVC     KIO,$A14                :OUTPUT THE CHAR
        AIS     R3,1
        JLBS    PRTN1
        
: PRINT THE PORT #

        PRINT(TPTTL)
        LHL     R0,DPORT,R12            :GET PORT NUMBER
        JE      NCIRT                   :0=NO CIRCUIT
        DPRINT(3,.B!.H)
        PRINT(HPTTL)
        L       R5,CHDCB,R11            :ACTIVE HOST PORT?
        JE      NCIRT                   :NO,SEND MSGAND GET NEXT PORT
        LHL     R0,DPORT,R5             :DISPLAY PORT NO.
        DPRINT(3,.B!.H)

: OUTPUT PRINTER PORT INFORMATION

        PRINT(NL)
        PRINT(PPTTL)                    :PRINT HEADER
        LH      R5,CPDCB,R11            :ACTIVE PRINTER PORT?
        JE      NCIRT                   :NO,SEND MSGAND GET NEXT PORT
        LHL     R0,DPORT,R12
        DPRINT(3,.B!.H)


NXPT    l       r0,psav1
        l       r2,psav2
        J       DOAGN4
NCIRT   PRINT(NOCRT)
        l       r0,psav1
        l       r2,psav2
        J       DOAGN4

        
:************************************************************
:
:       DCB - displays detailed information about contents of
:             DCB.
:
:************************************************************

DCBINF  JAL     R2,BANNER               :Display banner
        ANYARG(DCB100)                  :Get user parameter
        PRINT(NOARG)                    :Error - no parameter
        J       DSTART
DCB100  JAL     R4,DS.TOK               :Get arguement
        L       R1,CPORT
        CR      R1,R3                   :Does it start with port
        
        J       DSTART

:************************************************************
:       CRSH.R - Prints information about the last crash.  This 
:       includes crash time, crash point, crash code, crash
:       called from and crash registers.
:************************************************************

        LO      CRASH
CCRASH  JAL     R2,BANNER               :display banner
        LIS     R8,0
        LIS     R7,0
NXCRSH  AIS     R7,1                    :counterfor # crashes displayed
        PRINT(NL)
        PRINT(CCNT)                     :display crash count
        LHL     R0,CRAT,R8              :get count
        DPRINT(4,.B!.H)                 :display it
        SIS     R0,1
        JLE     CRSHND                  :stop here if only one crash

        PRINT(CCODE)                    :display crash code
        LHL     R0,CRAT+CRASHC,R8
        DPRINT(4,.B!.H)

CSHR20  PRINT(CPNT)                     :display crash point
        L       R0,CRAT+CPOINT,R8
        DPRINT(8,.Z!.H)

        PRINT(CRFRM)
        LHL     R0,CRAT+CFROM,R8                :display crash from
        DPRINT(8,.Z!.H)

        PRINT(TIME)                     :display time in GMT of last crash
        L       R3,CTIME,R8
        JGFS    CSHR23
        PRINT(NOTAVL)                   :not avail if zero or neg
        JFS     CSHR24
CSHR23  LHI     R4,10
        LA      R5,DATTMS,,
        JAL     R6,DATIME               :convert time to character string
        SVC     K.OUT,PDATE,,           :print it
CSHR24  PRINT(NL)
        PRINT(REGS)                     :display registers at time of crash
        PRINT(NL)
        LIS     R2,0
        LIS     R3,4
CSHR25  L       R0,CRAT+CRXREG,R2,R8    :get register
        DPRINT(8,.Z!.H)                 :and display it
        AIS     R2,4
        CHI     R2,4*10                 :are we done
        JGEFS   CSHR30                  :if yes, jump
        SIS     R3,1                    :time for new line
        JEFS    CSHR26                  :if so, do it
        PRINT(SPACE2)                   :else, print 2 spaces
        J       CSHR25                  :and do next
CSHR26  PRINT(NL)                       :new line
        LIS     R3,4
        J       CSHR25                  :and do next

: DISPLAY ADDITIONAL SAVED TABLES
        
CSHR30  LHI     R1,NCRSAV               :HOW MANY TABLES SAVED?
        CR      R7,R1
CRSHND  JE      DSTART

:DISPLAY NEXT TABLE


        AI      R8,CRTLEN               :GO GET NEXT TABLE
        J       NXCRSH  

        SEG     1
        FO      CRASH
:************************************************************
:       IRING - Prints real time display of iring
:************************************************************
        SEG     A.DATA
PSAV1   WS      1
PSAV2   WS      1
PSAV3   WS      1
TMPNAM  WS      5
RSAVE   HS      20
        SEG     A.CODE


CIRING  LI      R14,-1                  :REINITIALIZE PORTSAVE AREAS
        ST      R14,PSAV1
        ST      R14,PSAV2
        ST      R14,PSAV3
        ANYARG(IRING1)                  :CHECK FOR ARGUMENT
        JAL     R2,BANNER
        PRINT(RNGTL1)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDIR                 :NO, GO OUTPUT IRING    
        J       DSTART
IRING1  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV1                :SAVE PORT NUMBER       
        ANYARG(IRING2)
        JAL     R2,BANNER
        PRINT(RNGTL1)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDIR                 :NO, GO OUTPUT IRING    
        J       DSTART
IRING2  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV2                :SAVE PORT #
        ANYARG(IRING3)
        JAL     R2,BANNER
        PRINT(RNGTL1)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDIR                 :NO, GO OUTPUT IRING    
        J       DSTART
IRING3  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV3                :SAVE PORT #
        JAL     R2,BANNER
        PRINT(RNGTL1)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDIR
        J       DSTART


:************************************************************
:    ORING : REAL TIME DISPLAY OF ORING
:************************************************************
CORING  LI      R14,-1                  :REINITIALIZE PORTSAVE AREAS
        ST      R14,PSAV1
        ST      R14,PSAV2
        ST      R14,PSAV3
        ANYARG(ORING1)                  :CHECK FOR ARGUMENT
        JAL     R2,BANNER
        PRINT(RNGTL2)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDOR                 :NO, GO OUTPUT ORING    
        J       DSTART
ORING1  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV1                :SAVE PORT #
        ANYARG(ORING2)
        JAL     R2,BANNER
        PRINT(RNGTL2)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDOR                 :NO, GO OUTPUT ORING    
        J       DSTART
ORING2  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV2                :SAVE PORT #
        ANYARG(ORING3)
        JAL     R2,BANNER
        PRINT(RNGTL2)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDOR                 :NO, GO OUTPUT ORING    
        J       DSTART
ORING3  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV3                :SAVE PORT #
        JAL     R2,BANNER
        PRINT(RNGTL2)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDOR
        J       DSTART

:************************************************************
:    RINGS : REAL TIME DISPLAY OF  ALTERNATING RINGS
:************************************************************
CRINGS  LI      R14,-1                  :REINITIALIZE PORTSAVE AREAS
        ST      R14,PSAV1
        ST      R14,PSAV2
        ST      R14,PSAV3
        ANYARG(RINGS1)                  :CHECK FOR ARGUMENT
        JAL     R2,BANNER
        PRINT(RNGTL3)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDRA                 :NO, GO OUTPUT RINGS    
        J       DSTART
RINGS1  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV1                :SAVE PORT #
        ANYARG(RINGS2)
        JAL     R2,BANNER
        PRINT(RNGTL3)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDRA                 :NO, GO OUTPUT RINGS    
        J       DSTART
RINGS2  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV2                :SAVE PORT #
        ANYARG(RINGS3)
        JAL     R2,BANNER
        PRINT(RNGTL3)                   :PRINT HEADER AND
        PRINT(RNGNOT)                   : INSTRUCTIONS
        JAL     R2,XDRA                 :NO, GO OUTPUT RINGS    
        J       DSTART
RINGS3  GETNUM(16)              :GO GET ARGUMENT
        ST      R0,PSAV3                :SAVE PORT #
        JAL     R2,BANNER
        PRINT(RNGTL3)                   :PRINT HEADER AND
        JAL     R2,XDRA
        J       DSTART


:************************************************************
:       string texts
:************************************************************

HELP01  SC      /"8D"8AValid commands are:/
HELP02  SC      /"8D"8AEXIT or EXI - log off/
HELP03  SC      /"8D"8AQUIT or Q - exit ?STAT (back to DDT)/
HELP04  SC      /"8D"8AHELP or ? - print this list/
HELP05  SC      /"8D"8AINS or INST - Editing Instructions/
HELP06  SC      /"8D"8ASTATE - Slot state/
HELP08  SC      /"8D"8AVERSION - Description of the slot/
HELP09  SC      /"8D"8ANAMES - Table of usernames from tymfile/
HELP0A  SC      /"8D"8ADEBUG - Enters the CMB debugger/
HELP0B  SC      /"8D"8AUSER username (or) port XX - circuits and options/
HELP07  SC      /"8D"8Afor this currently active username or port/ 
HELP0C  SC      /"8D"8APORTS - Ports associated with each username/
HELP0D  SC      /"8D"8ACRASH - Information about slot crashes/
HELP0E  SC      /"8D"8AIRING port1 port2 port3 (or) address - Iring display/
HELP0F  SC      /"8D"8AORING port1 port2 port3 (or) address - Oring display/
HELP10  SC      /"8D"8ARINGS port1 port2 port3 - Alternate rings displayed/

INSTM1  SC      /"8D"8AEditing characters are:/
INSTM2  SC      /"8D"8AESC   - abort back to command level/
INSTM3  SC      /"8D"8A^W    - discards partial token/
INSTM4  SC      /"8D"8A^A    - discards last char of token (backspace)/
INSTM5  SC      /"8D"8A^H    - discards last char of token (backspace)/
INSTM6  SC      /"8D"8A"8AValid delimiters are:/
INSTM7  SC      /"8D"8A LF  HT  ' ' and ','./
INSTM8  SC      /"8A"8DCR terminates command line./

NL      SC      /"8D"8A/                : new-line (CR/LF)
SPACE1  SC      / /                     : 1 space
SPACE2  SC      /  /                    : 2 spaces
SPACE3  SC      /   /                   : 3 spaces
SPACE4  SC      /    /                  : 4 spaces
SPACE5  SC      /     /                 : 5 spaces
DOT     SC      /./                     : dot
COLON   SC      /:/                     : colon

STATTL  SC      /"8A"8DCMT SLOT STATUS"8D"8A/
TYMNAM  SC      /"8A"8DTYMFILE USERNAMES"8D"8A/

TRMVER  SC      /    VERSION:/
KNODE   SC      /"8A"8DNODE:/
SLTID   SC      /    SLOT:/
KHOST   SC      /    HOST:/
ASSM    SC      /"8A"8DASSM:/

MUSRTL  SC      /"8A"8D    MAXUSR:/
MPRTTL  SC      /    MAXPRINT:/
NTPTTL  SC      /"8A"8D#TERM PORTS:/
NHPTTL  SC      /    #CRT PORTS:/
NPPTTL  SC      /    #PRINT PORTS:/

NAMTTL  SC      /"8A"8DTYMFILE DEFINED USERNAMES"8D"8A/

MNUTTL  SC      /"8A"8DSCREEN MENU"8D"8A/
NOUSR   SC      /"8A"8DUSERNAME NOT FOUND IN TYMFILE"8D"8A/
LSTTL   SC      /"8A"8DLOGON STRINGS"8D"8A/
INVNAM  SC      /"8A"8DUSER NAME INVALID"8D"8A/
NOARG   SC      /"8D"8ANO ARGUMENT GIVEN"8D"8A/
        WS      0
CPORT   AC      /PORT/
NOTACT  SC      /"8D"8AUSERNAME NOT ACTIVE"8D"8A/
TPTTL   SC      /  TPRT:/
LSTTL1  SC      /  LSTR:/
MANLOG  SC      / MANUAL LOGON/
TTYTTL  SC      /  TRMTYP:/
ONDTT  SC      /  ORIGNOD:/
HPTTL   SC      /  HPRT:/
PPTTL   SC      /  PPRT:/
DESTTL  SC      /    DEST:/
NODEST  SC      /NO DESTINATION INTERFACE ADDRESS"8D"8A/
LINTTL  SC      /  LINE:/
GRPTTL  SC      /  GRP:/
SUBTTL  SC      /  SUB:/
NOCRT   SC      /NO CIRCUIT ESTABLISHED/

UNMTL   SC      /"8D"8AUSRNAM:/

TIME    SC      /"8A"8DCRASH TIME:  /
CRFRM   SC      /"8A"8DCRASH CALLED FROM:  /
CPNT    SC      /"8A"8DCRASH POINT:  /
CCODE   SC      /"8A"8DCRASH CODE:  /
CCNT    SC      /"8A"8DCRASH COUNT:  /
REGS    SC      /"8A"8DREGISTERS"8A"8D/
NOTAVL  SC      /"8A"8DNOT AVAILABLE"8A"8D/

RNGTL1  SC      /"8A"8DA REAL TIME DISPLAY OF THE IRING FOLLOWS/
RNGNOT  SC      /"8D"8APLEASE TYPE A "AF TO TERMINATE DISPLAY"8D"8A/
RNGTL2  SC      /"8D"8AA REAL TIME DISPLAY OF THE ORING FOLLOWS/
RNGTL3  SC      /"8D"8AA REAL TIME ALTERNATING DISPLAY OF THE RINGS FOLLOWS/

:
: Break point monitor commands
:

DS.ELL	EQ	0

P.CMND	DS.CMD(?,PHELP)
	DS.CMD(HELP,PHELP)
	DS.CMD(SET,PSET)
	DS.CMD(UNSET,PUSET)
	DS.CMD(MONITOR,PMON)
	DS.CMD(QUIT,PQUIT)
	DS.CMD(REGS,PREGS)
	DS.CMD(RSET,PRSET)
	DS.CMD(DISPLAY,PDUMP)
	DS.CMD(MODIFY,PMOD)
	DS.CMD(LIST,PLIST)
	DS.CMD(GO,PGO)

:
PMENU1	SC	/"8D"8ASET n - sets break point n/
PMENU2	SC	/"8D"8AUNSET n - unsets break point n/
PMENU3	SC	/"8D"8AMONITOR - monitors break points/
PMENU4	SC	/"8D"8AQUIT - returns to ?STAT/
PMENU5	SC	/"8D"8AREGS - displays the register contents at a break point/
PMENU6	SC	/"8D"8ARSET - updates the contents of a register/
PMENU7	SC	/"8D"8ADISPLAY - displays memory locations/
PMENU8	SC	/"8D"8AMODIFY - modifies memory locations/
PMENU9	SC	/"8D"8ALIST - lists available breakpoints/
PMENUA	SC	/"8D"8AGO - releases the background task/

PPRMPT	SC	/"8D"8A++/
PHLPMS	SC	/"8D"8ABREAKPOINT monitor/

PMONST	SC	/"8D"8APaused at breqkpoint /
PLSHDR	SC	/"8D"8AAvailable breakpoints"8D"8A"8D"8A/
R0HDR	SC	/"8D"8AR0  /
R1HDR	SC	/"8D"8AR1  /

PDHMS	SC	/ :  /
PDSPS	SC	/  /

MERMS1	SC	/Segment not accessible"8D"8A/
MERMS2	SC	/Invalid start address"8D"8A/
MERMS3	SC	/Invalid start address (1) "8D"8A/
MERMS4	SC	/Invalid length"8D"8A/
MERMS5	SC	/Segment write protected"8A"8D/


        SUBTTL STATUS ... Extended DDT code

:
:|--------------------------------------------------------------------|
:|                           H I S T O R Y                            | 
:|--------------------------------------------------------------------|
:| NSR NUMBER | INIT | VERSION |   DATE   |         REASON            |
:|------------|------|---------|----------|---------------------------|
:|            | PHH  | V01     |  9 JAN 86|  Modified BISYNC COM      |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|            |      |         |          |                           |
:|--------------------------------------------------------------------|
:

        SUBTTL  Utility Routines

:       CHKSYN - Check for Syntax errors.  Looks to see if carriage return
:       was entered before all required arguments were entered.  If so, it
:       prints message 'syntax error!' and does error return.

CHKSYN  LHI     R0,8D                   :was last delimiter a CR
        CLB     R0,DS.DLM,,
        JE      BADSYN                  :if CR, error
        JR      R7                      :else, just return

BADSYN  LA      R1,BSYNTX               :PRINT SYNTAX ERROR MS
        J       PERR

:       PERR(MSG)
:       Print ERRor:
:       NL/MSG/NL
:       R1 -    Pointer to message
:       Exits to DSTART

PERR    PRINT(NL)                       : New-line
        PRINT(0`,R1)                    : MSG
        PRINT(NL)                       : New-line
        J       DS.ERR,,                : ...and Error-exit


:       BANNER - prints BANNER for each COM command includes node
:       number, host number, slot number, code version number
:       and current dat and time in GMT.
:       R2      Link register

BANNER  PRINT(BANNR)                    :COM -- CMT Operations Monitor
        PRINT(SPACE4)                   :put in some spaces
        L       R3,GMT,,                :get GMT
        JLFS    NOTIME                  :jump if GMT not available
        LHI     R4,10                   :DATIME to output 16d characters
        LA      R5,DATTMS,,             :address of where to output date from
        JAL     R6,DATIME               :convert GMT to date and time
        SVC     K.OUT,PDATE,,           :output date and time
        PRINT(NL)
        JFS     PNOD
NOTIME  PRINT(NOGMT)
        PRINT(NL) 
PNOD    PRINT(NODE)                     :NODE followed by node number
        LHL     R0,NODEX,,
        DPRINT(4,.O)
        PRINT(HOST)                     :HOSTfollowed by host number
        LHI R0,HOST0
        DPRINT(5,.D!.B)
        PRINT(SLOT)                     :SLOT followed by slot number
        LHL     R0,SLOTNO,,
        DPRINT(2,.H!.B)
        PRINT(VSNTTL)
        LHI     R0,VERSION
        DPRINT(2,.H!.B)
        PRINT(DOT)
        LHI     R0,REVLEV
        DPRINT(2,.H!.Z)
        JR      R2

BANNR   SC      /"8A"8D"8ACOM -- CMT Operations Monitor   /
NOGMT   SC      /Date and time not available/
VSNTTL  SC      /   VERSION:/
NODE    SC      /"8D"8ANODE:/
SLOT    SC      /    SLOT:/
HOST    SC      /    HOST:/
BSYNTX  SC      /Syntax Error!/
        SEG     A.DATA
PDATE   BC      10                      :followed by 16d characters
DATTMS  BS      10


        SEG     A.CODE


        SUBTTL  Data Conversion Routines

:       These routines were taken from (isis2)convrt.lib and then
:       modified for use in the COM.

        RA      0

:*****************************************************************
:
:       BINDEC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:       DATA TO ASCII DECIMAL CHARACTERS.
:
:       ARGUMENTS: R9 CONTAINS THE BINARY NUMBER
:                  R10 CONTAINS NUMBER OF DIGITS OF OUTPUT
:                  R11 POINTS TO OUTPUT AREA
:       LINK ON R4
:
:****************************************************************
:
        SEG     A.DATA
:
RSAVEC  HS      10      :REGISTER SAVE AREA
:
        SEG     A.CODE
:
DIGASC  AC      /0123456789ABCDEF/
:
:       FIRST CHECK FOR A NEGATIVE NUMBER
:               IF FOUND, PUT A LEADING '-' (MINUS SIGN) IN FIELD
BINDEC  STM     R8,RSAVEC,,     :PRESERVE REGISTERS
        LR      R9,R9           : TEST FOR NEGATIVE NUMBER
        JGEFS   NOTNEG          :JUMP IF NOT NEGATIVE
        LHI     R12,$0 00AD     :'ASCII '-'
        STB     R12,0,R11
        SIS     R10,1           : ROOM FOR ONE LESS DIGIT
        AIS     R11,1           : DITTO
        JLE     RTRN            :NO ROOM FOR DIGIT AFTER MINUS SINE
:       COMPLEMENT THE NUMBER TO POSITIVE
        XI      R9,-1
        AIS     R9,1
NOTNEG  SIS     R11,1
        LIS     R12,$A 10       : DIVISOR
DIV     SR      R8,R8           : CLEAR HI ORDER BITS OF DIVIDEND
        DR      R8,R12          :GET LOW DIGIT IN R9
        LB      R13,DIGASC,R8   :GET ASCII EQUIVALENT OF DEC NUMBER
        STB     R13,0,R10,R11   :STORE IN REVERSE ORDER
        SIS     R10,1           :DECREMENT COUNTER
        JGBS    DIV             : KEEP LOOPING
RTRN    LM      R8,RSAVEC,,     :RESTORE THE REGISTERS
        JR      R4              :AND RETURN


        SUBTTL  GMT Clock Conversion Routines

:       These routines were taken from (isis2)datime.lib and then
:       modified for use in the COM.

        RA      $0 0A

:
:***************************************************************
:
:       THIS PROCEDURE CONVERTS THE GMT CLOCK
:       RELATIVE TO 1/1/74 FROM SECONDS TO
:       DDMMMYY HH:MM (GMT) OR
:       DDMMMYY HH:MM:SS (GMT)
:
:       PARMS
:               R3 = # OF SECONDS SINCE 1/1/74 (BEYOND1/1/76)
:               R4 = CHARACTERS OF OUTPUT (13 OR 16)
:               R5 = ADDRESS OF OUTPUT STRING
:               R6 = LINK REGISTER
:       ALL REGISTERS ARE PRESERVED
:
:**************************************************************
:
        SEG     A.DATA
:
RSAVE   HS      $020    :REGISTER SAVE AREA
:
        SEG     A.CODE
DATIME  STM     R0,RSAVE,,      :PRESERVE THE REGISTERS
        S       R3,SEC745       
:       MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:       A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:       YEAR + 3 REGULAR YEARS.  THERE ARE
:       24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
        SR      R2,R2           : CLEAR HI ORDER BYTES
        D       R2,SECDAY       :QUOTIENT IS # OF DAYS
:                               :REMAINDER IS TIME
        LR      R14,R2          :COPY TIME OF DAY
        SR      R2,R2           :CLEAR HI ORDER BYTES
        D       R2,QUADAY       :DIVIDE BY DAYS IN A QUAD
:
:       QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:       REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
        LHI     R8,76           :BASE YEAR
        SLLS    R3,2            :QUAD YEAR * 4
        AR      R8,R3           :ADD TO BASE YEAR
        LA      R7,LEPYEA       :POINT TO DAYS IN MONTH
        C       R2,W366         :IS IT IN CURRENT YEAR?
        JL      MONTHD          :JUMP IF SO
        S       R2,W366         :SUBTRACT DAYS IN YEAR
        AIS     R8,1            :ADD 1 TO YEAR
        LR      R11,R2          :GET REMAIN DAYS IN QUAD
        SR      R10,R10
        D       R10,W365        :AND DIVIDE BY REGYEAR
:       R11 HAS ADDTL YEARS
:       R10 HAS DAYS IN YEAR
        LR      R2,10
        AR      R8,R11
        LI      R7,REGYER       :POINT TO DAYS IN MONTHS
:
:       DAYS IN R2
:       YEAR IN R8
MONTHD  SR      R6,R6           :MONTH COUNTER
        AIS     R2,1            :MAKE 1/1/76 = DAY 1
MONLOP  LR      R9,R2           :SAVE DAYS
        LB      R3,0,R6,R7      :GET DAYS IN MONTH
        SR      R2,R3           :AND SUBTRACT FROM DAYS IN YEAR
        JLEFS   DAZE            :IF MINUS OR ZERO WE'RE IN THE MONTH
        AIS     R6,1            :INCREMENT INDEX
        JBS     MONLOP
:
:       DAYS IN R3
:       MONTH NUMBER - 1 IN R6
:       YEAR IN R8
:
:       SAVE R4 AND R5
DAZE    SIS     R4,8            :SUBTRACT OUT DATE LENGTH
        LR      R13,R4          :PRESERVE IT
        LR      R11,R5          :COPY OUPUT AREA POINTER
:
:       CONVERT DAY
        LIS     R10,2           :# OF OUTPUT CHARACTERS
        JAL     R4,BINDEC       :CONVERT TO DECIMAL ASCII
:
:       MOVE IN MONTH
        AIS     R11,2
        SLHLS   R6,2            :MULTIPLY MONTH NUMBER BY 4
        L       R4,MONTHS,R6    :GET THE NAME IN R4
        STB     R4,2,R11
        SRLS    R4,8
        STB     R4,1,R11
        SRLS    R4,8
        STB     R4,0,R11
        AIS     R11,3
:
:       CONVERT YEAR
        LR      R9,R8
        LIS     R10,2
        JAL     R4,BINDEC       :CONVERT TO CHARACTERS
        LHI     R3,$00A0        :ASCII SPACE
        STB     R3,2,R11        :PUT IT AFTER DATE
        LHI     R5,3,R11        :SET UP OUTPUT POINTER
        LR      R4,R13          :COPY LENGTH ARGUEMENT
        LR      R3,R14          :COPY TIME OF DAY
        JFS     TIME1           :JUMP
:*************************************************************
:
:       GET THE TIME STAMP
:
:       TIME STAMP ROUTINE
:               THIS ROUTINE CONVERTS THE FULLWORD GMT TIME OF DAY
:       TO HH:MM OR HH:MM:SS
:
:       PARAMETERS:
:               R3 = FULLWORD TIME OF DAY (GMT CLOCK)
:               R4 = 5 OR 8 (# OF CHARACTERS TO OUTPUT)
:               R5 = FULLWORD ADDRESS OF OUTPUT
:               R6 = LINK REGISTER
:
:       DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:       IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:       ROUTINE IS ALL ABOUT
:
:****************************************************************
TMSTMP  STM     R0,RSAVE,,      :PRESERVE THE REGISTERS
  IF \TIMZON
        AHI     R3,TIMZON*$A3600        :TIME ZONE CONVERSION
  EI
TIME1   SR      R8,R8           :INDEX FOR OUTPUT AREA
:
        SR      R2,R2           :CLEAR HI-ORDER BITS
        D       R2,SECDAY
:               SECONDS NOW IN R2
        LR      R3,R2           :GET READY FOR
        SR      R2,R2           :ANOTHER DIVIDE
        D       R2,TENOUR       :GET TENS OF HOURS
        JAL     R6,ASCOUT       :PRINT IT OUT IN ASCII
        DH      R2,OURS         :GET HOURS
:               R2 HAS REMAINDER, R3 HAS QUOTIENT
        JAL     R6,ASCOUT       :PRINT IT OUT
        LHI     R3,$00BA        :COLON
        JAL     R6,PRTOUT
        DH      R2,TENMIN
        JAL     R6,ASCOUT
        DH      R2,MIN
        JAL     R6,ASCOUT
:       THE CONDITION CODE HAS BEEN SET -
:       SET IF ANY MORE CHARACTER WANTED
        JE      RETN90          :JUMP IF ONLY 5 CHAR
:
:       PUT IN COLON BEFORE SECONDS
        LHI     R3,$00BA
        JAL     R6,PRTOUT
        DH      R2,TENSEC
        JAL     R6,ASCOUT
        LR      R3,R2           :GET SECONDS IN R3
        JAL     R6,ASCOUT
RETN90  LM      R0,RSAVE,,      :RESTORE THE REGISTERS
        JR      R6              :RETURN
:
:
ASCOUT  AHI     R3,$00B0
PRTOUT  STB     R3,0,R8,R5
        AIS     R8,1    : UPDATE INDEX
        SIS     R4,1
        JR      R6

:
DECMAL  XC      0001020304050607080910111213141516171819202122232425262728293031
SECDAY  WC      24*60*60        :SECONDS IN A DAY
TENOUR  WC      10*60*60        :TENS OF HOURS
OURS    HC      60*60           :HOURS
TENMIN  HC      10*60           :TENS OF MINS
MIN     HC      60              :MIN
TENSEC  HC      10              :TENS OF SECS
  IF    \TIMZON
SEC745  WC      24*60*60*365*2-TIMZON*60*60     :SECONDS IN 74 & 75 PLUS 
                                                :TIME-ZONE CORRECTION
  ELSE
SEC745  WC      24*60*60*365*2  :SECONDS IN 74 AND 75
  EI
W365    WC      365
W366    WC      366
QUADAY  WC      4*365+1
LEPYEA  BC      31,29,31,30,31,30,31,31,30,31,30,31
REGYER  BC      31,28,31,30,31,30,31,31,30,31,30,31
        WS      0
MONTHS  AC      / Jan/
        AC      / Feb/
        AC      / Mar/
        AC      / Apr/
        AC      / May/
        AC      / Jun/
        AC      / Jul/
        AC      / Aug/
        AC      / Sep/
        AC      / Oct/
        AC      / Nov/
        AC      / Dec/


        RA      0       :RADIX TO HEX




::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                      ISIS RING INTERPERTER                   ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                                                              ::
::      This package will decode ISIS dispatcher rings and      ::
::      display them on a DDT port.  Messages that may contain  ::
::      meaningful ASCII text (data, needles, and 1DOWN) are    ::
::      displayed in hex and ASCII.  All other messages are     ::
::      displayed only in hex.                                  ::
::                                                              ::
::      Requirments:                                            ::
::              This code requires ISIS-II version 5 (or above) ::
::              and the STAT.LIB library.  It uses the message  ::
::              length tables in segment F (15d) in ISIS.       ::
::                                                              ::
::      Commands:                                               ::
::              This package includes 4 commands.  With this    ::
::              set of commands you may examine rings that      ::
::              have, and have not wrapped.  Also any output    ::
::              from these commands may be terminated by typing ::
::              any character ("\" is recomended).  All         ::
::              commands may be followed by an optional number. ::
::              This number represents the number of seconds    ::
::              to wait looking for new ring activity.  This    ::
::              may be used to observe rings for N seconds, in  ::
::              'real time'.                                    ::
::                                                              ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        SEG     A.CODE

DECB.3  EQ      032A    :WIDTH= 3, BLANK FILL, BASE=10
DECB.9  EQ      092A    :WIDTH= 9, BLANK FILL, BASE=10
HEXB.3  EQ      0330    :WIDTH= 3, BLANK FILL, BASE=16
HEXZ.4  EQ      0450    :WIDTH= 4,  ZERO FILL, BASE=16
HEXB.5  EQ      0530    :WIDTH= 5, BLANK FILL, BASE=16
HEXZ.5  EQ      0550    :WIDTH= 5,  ZERO FILL, BASE=16
HEXZ.8  EQ      0850    :WIDTH= 8,  ZERO FILL, BASE=16
HEXB.9  EQ      0930    :WIDTH= 9, BLANK FILL, BASE=16
HEXB.A  EQ      0A30    :WIDTH=10, BLANK FILL, BASE=16

LENGTH  EQ      0F0028          :SEG E AND SEG F DATA AREAS
LP0LST  EQ      0F0026
NPORTS  EQ      0E0082          :NUMBER OF PORTS THIS PROCESS
IRINGP  EQ      0E0068          :START OF INPUT RING
ORINGP  EQ      0E006C          :START OF OUTPUT RING
IMAXI   EQ      0E0084          :INPUT RING SIZE  (HALFWORD)
OMAXI   EQ      0E0086          :OUTPUT RING SIZE (HALFWORD)
RING    EQ      4               :4 BYTES PAST 1ST POINTER IS RING
NFMI    EQ      0               :FILL POINTER

        SEG     A.DATA

PORTSAV HS      1               :FOR FLIP/FLOP DECISION (DR COMMAND)
B.FLAGS BC      0               :BIT 1 ON: DOING IRING  (DR COMMAND)
                                :BIT 2 ON: OUTPUT...YES
                                :BIT 3 ON: VALID PORT: OUTPUT MSG       

XDIIND  HS      1               :INPUT INDEX
XDOIND  HS      1               :OUTPUT INDEX

RR      EQ      8               :REGISTER ADDRESS OF RING
RS      EQ      9               :REGISTER RING SIZE
OUT     EQ      0B

        SEG     A.CODE

:
: DISPLAY INPUT RING
:


XDIR    LIS     R14,4                   :INIT ADDR OR PORT ARG 
        RBT     R14,B.FLAGS
        L       R0,PSAV1
        JL      XDIR1                   :WAS AN ARG INPUT?
        CI      R0,1000
        JL      XDIR1                   :THIS WAS A PORT # ARG
        LIS     R14,4
        SBT     R14,B.FLAGS             :ARG WAS AN ADDRESS
        LA      RR,IRING+4,,            :GET START ADDRESS
        CLR     R0,RR                   :COMPARE
        JL      DS.ALOW
:
        AI      RR,IRSIZE               :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,IRING+4              :GENERATE START ADDRESS
        NHI     R0,0FFFC                :ALIGN TO WORD

        STH     R0,XDIIND               :IRING INDEX
        J       XDIR2
XDIR1   LIS     R0,0                    :START AT BEGINNING OF RING
        STH     R0,XDIIND
XDIR2   SVC     0B,XDCRLF
XDIRLP
        LIS     R0,3                    :INITIALIZE FLAG
        RBT     R0,B.FLAGS
        JAL     R14,XDRKBD              :TEST KEYBOARD INPUT
        J       DDTNOP                  :NON SKIP RETURN ENDS RING READ
        JAL     R14,XDRDIR              :SKIP,GO DO INPUT RING
        SVC     DISMISS,0
        J       XDIRLP

:
: DISPLAY OUTPUT RING
:

 
XDOR    LIS     R14,4
        RBT     R14,B.FLAGS             :INIT ADDRESS ARG FLAG  
        L       R0,PSAV1                :WAS AN ARG INPUT?
        JL      XDOR1                   :NO
        CI      R0,1000                 :YES..WAS IT A PORT# OR ADDR
        JL      XDOR1
        LIS     R14,4
        SBT     R14,B.FLAGS             :THIS IS AN ADDRESS
        LA      RR,ORING+4,,            :GET START ADDRESS
        CLR     R0,RR                   :COMPARE
        JL      DS.ALOW
:
        AI      RR,ORSIZE               :GENERATE END ADDRESS
        CLR     R0,RR
        JG      DS.AHI
:
        SI      R0,ORING+4              :GENERATE START ADDRESS
        NHI     R0,0FFFC                :ALIGN TO WORD

        STH     R0,XDOIND               :ORING INDEX
        J       XDOR2
XDOR1   LIS     R0,0                    :START AT BEGINNING OF RING
        STH     R0,XDOIND
XDOR2   SVC     0B,XDCRLF
XDORLP
        LIS     R0,3                    :INITIALIZE FLAG
        RBT     R0,B.FLAGS
        JAL     R14,XDRKBD              :TEST KEYBOARD INPUT
        J       DDTNOP                  :IF ANY THEN DONE
        JAL     R14,XDRDOR              :OUTPUT RING
        SVC     DISMISS,0
        J       XDORLP

:
: DISPLAY BOTH INPUT AND OUTPUT RINGS - ALTERNATING BETWEEN THEM
:

 
XDRA    LIS     R0,0
        STH     R0,XDIIND
        STH     R0,XDOIND
        SVC     0B,XDCRLF
XDRALP
        LIS     R0,3                    :INITIALIZE FLAG
        RBT     R0,B.FLAGS      
        JAL     R14,XDRKBD              :TEST KEYBOARD INPUT
        J       DDTNOP                  :IF ANY THEN DONE
        JAL     R14,XDRDIR              :DISPLAY IRING
        LIS     R0,3                    :INITIALIZE FLAG
        RBT     R0,B.FLAGS      
        JAL     R14,XDRDOR              :DISPLAY ORING
        SVC     DISMISS,0
        J       XDRALP

:
: DISPLAY BOTH INPUT AND OUTPUT RINGS - FOLLOW PORT SEQUENCE: DISPLAY FROM
:     SAME RING UNTIL PORT NUMBER CHANGES, IN WHICH CASE FLIP OVER TO THE 
:     OTHER RING AND DO THE SAME THERE.
:

        DS.CMD(DR,XDR)                  :INPUT & OUTPUT RINGS COMMAND 
 
XDR
        LIS     R0,0
        STH     R0,XDIIND
        STH     R0,XDOIND
        SVC     0B,XDCRLF
XDRLP
        JAL     R14,XDRKBD              :TEST KEYBOARD INPUT
        J       DDTNOP                  :IF ANY THEN DONE

        LIS     R3,2                    :PREPARE INDEX
        RBT     R3,B.FLAGS              :SET DEFAULT-NO OUTPUT THIS PASS
        LIS     R3,1                    :PREPARE INDEX
        TBT     R3,B.FLAGS              :DOING IRING?
        JE      XDRIRI                  :YES, GO CALL OUTPUT
        JAL     R14,XDRDOR              :DISPLAY ORING
        J       XDRCHK                  :GO CHECK NEXT PORT #
XDRIRI  JAL     R14,XDRDIR              :DISPLAY IRING

XDRCHK  LIS     R3,2                    :PREPARE INDEX
        TBT     R3,B.FLAGS              :ANY OUTPUT THIS PASS?
        JEFS    XDRRES                  :NO, FLIP TO OTHER RING
        LHL     R3,RING,R1,RR           :GET NEXT PORT#
        CLH     R3,NPORTS,,             :VALID=0 THRU NPORT
        JLEFS   XDRCH1                  :YES,CONTINUE
        AIS     R1,4                    :ADDR NEXT POSS. PORT#
        JBS     XDRCHK                  :TRY AGAIN
XDRCH1  CLH     R3,PORTSAV,,            :SAME PORT#?
        JEFS    XDRDIS                  :YES, CONTINUE CURRENT RING
XDRRES  LIS     R3,1                    :PREPARE INDEX
        CBT     R3,B.FLAGS              :COMPLEMENT FLAG-->OTHER RING
XDRDIS  SVC     DISMISS,0               
        J       XDRLP                   :CONTINUE LOOP

:
: DUMP I/O RINGS
:
:       R0  - SCRATCH
:       R1  - INDEX INTO RING
:       R10 - LINK TO SUBROUTINES
:       R12 - FLAG FOR PRINTING/NOT PRINTING
:
 
:
: OUTPUT IRING MESSAGE
:
 
XDRDIR
        LA      RR,IRING,,      :HANDLE IRING
        LHI     RS,IRSIZE       :RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDIIND
        CLR     R0,R1
        JER     R14
:
        LHI     R0,0049         : I
        STB     R0,XRNG+1
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDIW
        SR      R1,RS
XDRDIW  LIS     R10,3           :DID WE PRINT A RING MSG?
        TBT     R10,B.FLAGS
        JEFS    XDRDI1          :NO...SKIP THE NL
        SVC     0B,XDCRLF
XDRDI1  STH     R1,XDIIND       :UPDATE OUTPUT INDEX
        JR      R14

:
: OUTPUT ORING MESSAGE
:

XDRDOR
        LA      RR,ORING,,      :HANDLE ORING
        LHI     RS,ORSIZE       :RING SIZE
        LH      R0,NFMI,RR      :GET RING INDEX
        LH      R1,XDOIND
        CLR     R0,R1
        JER     R14             :EXIT
:
        LHI     R0,4F           : O
        STB     R0,XRNG+1
:
        JAL     R13,XDRISM
        AIS     R1,3
        NHI     R1,-4
        CR      R1,RS           :TEST FOR WRAP
        JLFS    XDRDOW
        SR      R1,RS
XDRDOW  LIS     R10,3           :DID WE SEND A RING MSG OUT?
        TBT     R10,B.FLAGS
        JEFS    XDRDO1          :NO..DON'T SEND A NL    
        SVC     0B,XDCRLF       :OUTPUT CRLF
XDRDO1  STH     R1,XDOIND       :OUTPUT INDEX
        JR      R14

:
: KEYBOARD CHECK
:

XDRKBD
        SVC     K.IN,0          :TEST KYBD INPUT
        J       XDRKBE          :NONE, SO NORMAL RETURN
        JR      R14

XDRKBE
        AIS     R14,4           :NORMAL "SKIP" RETURN
        JR      R14             :NORMAL EXIT

: ERROR ROUTINE
:

DS.ALOW
        SVC     0B,ADRLOW
        J       DS.ERR
:
DS.AHI
        SVC     0B,ADRHI
        J       DS.ERR

ADRLOW  SC      /Address too low"8D"8A/
ADRHI   SC      /Address too high"8D"8A/

:
:  PROCESS ISIS MESSAGE
:
:  R1           RING INDEX
:  R8 (RR)      RING START ADDRESS
:  R9 (RS)      RING SIZE
:  R13          LINK
:

XDRISM  LIS     R3,2                    :PREPARE INDEX
        SBT     R3,B.FLAGS              :INDICATE A MSG THIS PASS
        LB      R2,RING+2,R1,RR         :GET MESSAGE CODE
        LHL     R3,RING,R1,RR           :GET PORT #
        JE      XDR0C0                  :IF INTRANODE MESSAGE

:
: CHECK FOR A VALID PORT #, KEEP INCREMENTING UNTIL FOUND
:

        CLH     R3,NPORTS,,             :TEST AGAINST MAX PORT #
        JG      XDR0A0                  :NOT VALID
        L       R4,PSAV1                :WAS AN ARGUMENT SAVED?
        JGE     XDR0                    :YES
        LIS     R12,3
        SBT     R12,B.FLAGS             :OK TO PRINT MSGS
        J       XDR0A5
XDR0    LIS     R12,4
        TBT     R12,B.FLAGS             :WAS ARG AN ADDRESS?
        JE      XDR00
        LIS     R12,3
        SBT     R12,B.FLAGS             :OK TO PRINT MSGS
        J       XDR0A5
XDR00   CLR     R3,R4                   :IS THIS A PORT WE WANT?
        JN      XDR000                  :GO READ RING
        LIS     R12,3
        SBT     R12,B.FLAGS             :OK TO PRINT MSGS
        J       XDR0A5
XDR000  L       R4,PSAV2
        JL      XDR0A5
        CLR     R3,R4
        JN      XDR001
        LIS     R12,3
        SBT     R12,B.FLAGS
        J       XDR0A5
XDR001  L       R4,PSAV3
        JL      XDR0A5
        CLR     R3,R4
        JN      XDR0A5
        LIS     R12,3
        SBT     R12,B.FLAGS
        J       XDR0A5
:
XDR0A0  AIS     R1,4                    :MOVE TO NEXT POSSIBLE PORT
        J       XDRISM                  :LOOP FOR VALID PORT #
:
XDR0A5  STH     R3,PORTSAV              :PORT VALID SO SAVE IT
        LIS     R12,1                   :DEFAULT PRINTING ON <*>
        LR      R2,R2                   :CHECK FOR NEEDLE
        JE      XDR0F0                  :IF SO
:
        CLHI    R2,9E                   :DATA MESSAGE ??
        JL      XDR0B0                  :IF SO
:
        LIS     R4,3
        TBT     R4,B.FLAGS              :CHECK IF OK TO OUTPUT MSG
        JN      XDRB1                   :FLAG SET GO OUTPUT
        SHI     R2,9E
        LB      R6,LENGTH+9E,R2,        :MESSAGE LENGTH FROM TABLE (IN SEG F)
        AIS     R6,2
        AR      R1,R6                   :BUMP INDEX FOR MSG LENGTH
        CR      R1,RS                   :END OF RING?
        JL      XDRB0
        SR      R1,RS
XDRB0   JR      R13
XDRB1   JAL     R10,XPRADD              :PRINT ADDRESS
        SHI     R2,9E                   :BIAS TO 0
        LA      R4,,R2,R2               :FOR INDEXING
        SVC     0B,XDRICA,R4,R4         :ASCII MESSAGE LABEL
        LIS     R12,0   :DO NOT PRINT ISIS CONTROL MESSAGES IN ASCII <*>
        JAL     R10,XDRISB              :GO DUMP ISIS CONTROL MESSAGE
        JR      R13                     :RETURN
:
: DATA MESSAGE
:

XDR0B0  LIS     R4,3
        TBT     R4,B.FLAGS              :IS THIS A VALID PORT #?
        JN      XDR0B1                  :YES,CONTINUE
        LA      R6,3,R2                 :ADD MESSAGE LENGTH
        AR      R1,R6                   :BUMP RING INDEX PAST DATA LENGTH
        CR      R1,RS                   :WRAP?
        JL      XDR0B2                  :NO
        SR      R1,RS
XDR0B2  JR      R13
XDR0B1  JAL     R10,XPRADD              :PRINT ADDRESS
        SVC     0B,XXDATA,,             :"DATA" MESSAGE HEADER
        JAL     R10,XDRISA              :GO DUMP ISIS DATA MSG
        JR      R13                     :RETURN

:
: PORT 0 INTRANODE MESSAGE
:

XDR0C0  LIS     R12,3
        SBT     R12,B.FLAGS             :OK TO PRINT MSG        
        JAL     R10,XPRADD              :PRINT ADDRESS
        LA      R4,,R2,R2               :FOR INDEXING
        SVC     0B,XDRICB,R4,R4         :ASCII MESSAGE LABEL
        TBT     R2,XDRVL,,              :VARIABLE LENGTH MESSAGE ??
        JNFS    XDR0D0                  :IF SO BECAUSE CAN'T HANDLE YET
        LIS     R12,0                   :DO NOT PRINT CONTROL MESSAGE <*>
        JAL     R10,XDRISC              :GO DUMP ISIS INTRANODE MESSAGE
        JR      R13                     :RETURN
XDR0D0  LIS     R12,1                   :<*> SET TO PRINT
        CLHI    R2,8                    :AUX CIRCUIT REQUEST ??
        JN      XDR0E0                  :MUST BE "1-DOWN"
        LA      R4,0A,R1                :STEP TO SIZE BYTE
        CR      R4,RS                   :CHECK FOR WRAP AROUND
        JLFS    XDR0D4                  :IF NOT
        SR      R4,RS                   :IF SO
XDR0D4  LB      R6,RING,RR,R4           :GET VARIABLE STRING SIZE
        AIS     R6,0B                   :ADD CONSTANT PORTION
        LHI     R0,20                   :INSERT A SPACE
        SVC     KIO,0E
        JAL     R10,XDRISE,,            :TO PUT OUT MESSAGE
        JR      R13                     :RETURN
XDR0E0  LA      R4,5,R1                 :STEP TO 1-DOWN STRING SIZE
        CLHI    R4,RS                   :CHECK FOR WRAP AROUND
        JLFS    XDR0E4                  :IF NOT
        SHI     R4,RS                   :IF SO
XDR0E4  LB      R6,RING,RR,R4           :GET VARIABLE MESSAGE SIZE
        AIS     R6,6                    :ADD FIXED MESSAGE LENGTH
        LHI     R0,20                   :INSERT A SPACE
        SVC     KIO,0E
        JAL     R10,XDRISE,,            :TO PUT OUT MESSAGE
        JR      R13                     :RETURN

:
: NEEDLE
:

XDR0F0  LB      R6,RING+3,R1,RR         :GET LENGTH+FIXED PORTION
        AIS     R6,4
        LIS     R4,3
        TBT     R4,B.FLAGS              :VALID PORT?
        JN      XDR0F1                  :YES
        AR      R1,R6
        CR      R1,RS                   :WRAP?
        JL      XDR0F2
        SR      R1,RS
        JR      R13
XDR0F1  JAL     R10,XPRADD              :PRINT ADDRESS
        SVC     0B,needle,,             :NEEDLE MESSAGE
        LHI     R0,20                   :INSERT A BLANK
        SVC     KIO,0E                  :PUT IT OUT
        JAL     R10,XDRISE,,            :TO PUT REST OF MESSAGE
XDR0F2  JR      R13                     :RETURN

:
: TEST LOWER CASE, MAKE UPPER CASE IF TRUE
:

CAPIT   TBT     R0,CAPITT,,             :TEST FOR LOWER CASE CHARACTER
        JER     R1                      :IF NOT
        SHI     R0,20                   :ADJUST TO CAPITALIZE
        JR      R1                      :RETURN
        
:
:       R1 - RING INDEX
:       R2 - MSG CODE TYPE
:       R3 - PORT #
:       R4 - SCRATCH
:       R5 - BYTE TO OUTPUT
:       R6 - SCRATCH
:       R7 - LINE LENGTH COUNTER
:       RS - RING SIZE  (R8)
:       RR - RING START (R9)
:       R10- LINK TO HERE
:       R11- LINK TO XDPUT
:
: DATA MESSAGE
:

XDRISA  LA      R6,3,R2         :MESSAGE LENGTH=MESSAGE TYPE+3
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E          :LETS BE TIDY
        J       XDRISE,,,

:
: CONTROL MESSAGE
:

XDRISB  LB      R6,LENGTH+9E,R2,:MESSAGE LENGTH FROM TABLE (IN SEG F)
        AIS     R6,2
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E
        J       XDRISE,,,

:
: INTRANODE MESSAGE TYPE
:

XDRISC  LHL     R6,LP0LST,,     :SEG F HAS THIS TOO
        LB      R6,NRATE,R6,R2, :MESSAGE LENGTH FROM TABLE
        AIS     R6,2
        LHI     R0,20           :INSERT A SPACE
        SVC     KIO,0E
        J       XDRISE
XDRISD  HS      0
        SVC     0B,XDRASC,,     :ASCII EQUIVALENT OF LINE
        SVC     0B,XDCRLF,,     :NEW LINE
        ST      R10,SAVR10,,
        JAL     R10,XPRADD      :PRINT ADDRESS :*:
        L       R10,SAVR10,,
        SVC     0B,BLANK9,,     :9 BLANKS FOR ALIGNMENT
        LIS     R7,2            :ADJUST LINE COUNTER-as if 2 char done 
        JFS     XDRISF          :SKIP AROUND COUNTER INIT
        LIS     R4,3            :IS IT OK TO OUTPUT MSG?
        TBT     R4,B.FLAGS
        JN      XDRISE
        AR      R1,R6           :ADD MSG LENGTH TO RING INDEX
        CR      R1,RS
        JL      XDEND

XDRISE  LIS     R7,0            :LINE LENGTH COUNTER
XDRISF  LB      R0,RING,R1,RR   :NEXT BYTE FROM RING
        LR      R5,R0           :SAVE A GOOD COPY OF IT
        NHI     R0,7F           :IGNORE MSB
        TBT     R0,XDRECH,,     :PRINTABLE ??
        JNFS    XDRISH          :YES, GET ORIG. BYTE BACK
        LHI     R0,2E           :DEFAULT "." CHARACTER
        JFS     XDRISH+2        :SET CHAR TO "."
XDRISH  LR      R0,R5           :ELSE IF OK TO PRINT IT
:XDRISH+2
        LR      R4,R7           :COMPUTE WHERE TO PLUG INTO LINE
        NHI     R4,0F           :16 BYTES PER LINE
        STB     R0,XDRASC+4,R4,,:PUT 'ER THERE
        JAL     R11,XDPUT,,     :PUT IT OUT
        AIS     R1,1            :BUMP RING INDEX
        CR      R1,RS           :END OF RING ??
        JLFS    XDRISG          :IF NOT
        SR      R1,RS           :FOLD TO RING START
XDRISG  AIS     R7,1            :LINE LENGTH
        SIS     R6,1            :CHECK FOR END OF MSG
        JLE     XDRISI          :FINISH BLANKING AND PRINT      
        THI     R7,0F           :END OF LINE
        JE      XDRISD          :IF SO
        THI     R7,1            :END OF HALFWORD
        JN      XDRISF          :IF NOT TO CONTINUE
        LHI     R0,20           :ADD A SPACE
        SVC     KIO,0E          :TO FORMAT WORDS
        J       XDRISF
XDRISI  LHI     R0,20           :BLANK
        LR      R12,R12         :PRINT DATA ? (1=YES)
        JER     R10             :NO, RETURN
XDRISJ  NHI     R7,0F           :LINE LENGTH OF 16
        JEFS    XDRISK          :IF TO END OF LINE
        STB     R0,XDRASC+4,R7,,:PUT IN A BLANK
        SVC     0B,BLANK2,,     :PRINT 2 BLANKS TO ALLIGN DATA
        THI     R7,1            :ODD ?
        JNFS    XDRISL          :YES, DO NOT PRINT BLANK
        SVC     KIO,0E          :PRINT A BLANK (REG 0)
XDRISL  HS      0
        AIS     R7,1            :COUNT ON UP
        JBS     XDRISJ          :AND SEE IF DONE
XDRISK  SVC     0B,XDRASC,,     :YES, PUT IT OUT
XDEND   JR      R10             :DONE

:       KEYBOARD INPUT ENDS READ RING CMD

DDTNOP  J       DSTART          :IF ANY THEN DONE

:
:       R0 USED BY SVC FOR OUTPUT CHARACTER
:       R1-R3 SAVED
:       R4 DESTROYED
:       R5 BYTE TO BE OUTPUT
:       R11 LINK
:
XDPUT   LBR     4,5             :COPY IT
        SRHLS   4,4             :LEFT NIBBLE
        LB      0,SIAASC,4,     :CONVERT TO ASCII ("0" TO "F")
        SVC     KIO,0E          :PUT IT OUT TO TTY
        NHI     5,0F            :RIGHT NIBBLE
        LB      0,SIAASC,5,     :CONVERT TO ASCII ("0" TO "F")
        SVC     KIO,0E          :PUT IT OUT TO TTY
        JR      R11             :RETURN

:
: WRITE ADDRESS AT START OF DATA/MESSAGE/NEEDLE LINE
:
:       R10 - LINK TO THIS ROUTING
:       ALL OTHERS PRESERVED!
:

XPRADD
        STM     R0,XDSAV,,
        SVC     0B,XRNG
        LA      R0,RING,R1,RR   :GET ADDR OF THIS MESSAGE
        LHI     R1,HEXB.5
        SVC     KIO,$A10
        LHI     R0,0020         :PRINT BLANK
        SVC     KIO,$A14
        LM      R0,XDSAV,,
        JR      R10

        SUBTTL  ISIS RING INTERPRETER (DATA AREAS)

        SEG     0

XDRSS0  HS      0
XDRPLU  SC      /"8D"8A"2B/             :<CR>, <LF>, "+"
SIAASC  AC      /0123456789ABCDEF/
CAPITT  HC      0,0,0,0,0,0,7FFF,0FFE0
XDRECH  HC      0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDCRLF  SC      /"8D"8A/        :<CR>, <LF>
BLANK2  SC      /  /            :TWO BLANKS
XDRVL   HC      0082,0000       :VARIABLE LENGTH MESSAGE FLAGS
BLANK9  SC      /         /     :9 blanks for alignment
NEEDLE  SC      /NDL/           :NEEDLE
XXDATA  SC      /DAT/           :DATA
XDRASC  SC      /  |                |/
XDRCEI  HS      1               :OUR CEI
XRNG    SC      /  /
XDSAV   HS      2*10            :REG SAVE AREA
SAVR10  HS      2               :REG 10 SAVE AREA

:
: ISIS CONTROL MESSAGES
:

XDRICA  HS      0
        SC      /DET/   :DETACH MESSAGE TYPE
        SC      /ZAP/   :DISCONNECT MESSAGE
        SC      /SBP/   :SET     BACK-PRESSURE (NO SEND)
        SC      /RBP/   :RELEASE BACK-PRESSURE (SEND)
        SC      /FLO/   :FLUSH OUTPUT (GOBBLER)
        SC      /FLI/   :FLUSH INPUT  (BACK GOBBLER)
        SC      /BLK/   :DATA LOST IN THIS DIRECTION     (BLACK BALL)
        SC      /GRY/   :DATA LOST IN OPPOSITE DIRECTION (GREY  BALL)
        SC      /EDE/   :ENTER DEFERED ECHO MESSAGE
        SC      /LDE/   :LEAVE DEFERED ECHO MESSAGE
        SC      /ETM/   :ENTER TRANSPARENCY MODE
        SC      /LTM/   :LEAVE TRANSPARENCY MODE
        SC      /GB /   :GREEN BALL
        SC      /RB /   :RED BALL
        SC      /YB /   :YELLOW BALL
        SC      /OB /   :ORANGE BALL
        SC      /BRK/   :BREAK DETECTED
        SC      /HNG/   :HANG UP
        SC      /QTP/   :QUERY TERMINAL PARAMETER
        SC      /STP/   :SET   TERMINAL PARAMETER
        SC      /PSN/   :PSEUDO NEEDLE
        SC      /NLC/   :NORMAL LOGON CHARACTER
        SC      /NLS/   :NORMAL LOGON STATUS
        SC      /LOF/   :LOGON FAILURE
        SC      /NCC/   :NORMAL CIRCUIT COMPLETE
        SC      /ADA/   :ADDENDUM TO ACCOUNTING
        SC      /SHG/   :SUPER-HANG UP
        SC      /TLM/   :SET TRANSMIT LIMIT
        SC      /EBK/   :END OF BREAK
        SC      /ZAK/   :ZAP ACK
        SC      /EAD/   :ENTER ALTERNATE OUTPUT DEVICE MODE
        SC      /LAD/   :LEAVE ALTERNATE OUTPUT DEVICE MODE
        SC      /ZAR/   :ZAP WITH REASON
        SC      /SIX/   :START     INTERFACE INFORMATION EXCHANGE
        SC      /TIX/   :TERMINATE INTERFACE INFORMATION EXCHANGE

:
: INTRA NODE MESSAGES
:

XDRICB  HS      0
        SC      /RQR/   :RESTART REQUEST
        SC      /RST/   :RESTART INTERFACE
        SC      /NTO/   :NODE HAS BEEN TAKEN OVER
        SC      /REP/   :REPORT TO SUPERVISOR'S LOG
        SC      /RHS/   :REPORT HOST STATUS (OBSOLETE)
        SC      /RAC/   :REPORT ACCOUNTING
        SC      /TIM/   :GMT TIME
        SC      /RNP/   :REQUEST FOR NORMAL PSEUDO NEEDLE
        SC      /RAP/   :REQUEST AUX PSEUDO-NEEDLE
        SC      /PSR/   :PSEUDO-NEEDLE REJECTED
        SC      /HPA/   :HOST PORT AVAILABILITY
        SC      /HNA/   :HOST NOT ACCEPTABLE
        SC      /RHC/   :REPORT HOST COST
        SC      /NSU/   :NO SUPERVISOR
        SC      /ODN/   :1-DOWN TEXT
        SC      /RAH/   :REPORT ALL HOSTS
        SC      /HSR/   :HOST STATUS REPORT
        EM              :COM
        EI              :DB.STA 


        SUBTTL  Control Table Allocation and Diagnostics - FINISH.LIB
 
:**********************************************************************
:                                                                     *
:       This program is the sole property and confidential            *
:       information of Tymshare, Inc., and may not be copied          *
:       in whole or in part or disclosed to any third party           *
:       without the prior written consent of Tymshare.                *
:                                                                     *
:**********************************************************************

	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI

	IF	\APROT0
	ELSE
APROT0	EQ	6	:EXECUTION PROTECTED
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	EI
	IF	\APROT1
	ELSE
APROT1	EQ	5	:WRITE PROTECTED
	EI
Q1	EQ	2
	RE	0C
	IF	\APROT|Q1|
	ELSE
APROT|Q1| EQ	6	:EXECUTION PROTECTED
	EI
Q1	EQ	Q1+1
	ER

:	NAD ALLOWS MORE THAN 10000X TO BE PLACED IN ONE "SEG".
:	WE MUST THEREFORE GO INTO EACH SEG AND IF > 10000X ORG BACK TO
:	10000X AND THEN ENTER THE NEXT SEG TO DEPOSIT THE REMAINDER.
:	THIS, OF COURSE, ASSUMES THAT THE NEXT SEG IS EMPTY.
:	A CHECK IS MADE TO INSURE THIS.

Q1	EQ		0
	RE		0E		:FOR Q1 = 0 TO 0E
	  SEG		Q1
Q3	  EQ		10000*(Q1+1)	:  Q3 = UPPER BOUND FOR THIS SEGMENT
	  IF		.-Q3		:  IF THIS SEGMENT OVERFLOWED
Q2	    EQ		.-Q3		:    Q2 = LENGTH OF OVERFLOW
	    ORG		Q3		:    ORG TO MAXIMUM
	    IF		0E-(Q1+1)	:    IF THE NEXT SEG IS NOT E
	      SEG	Q1+1		:      GO INTO NEXT SEG
	      IF	(.-Q3)		:      IF SEG ALREADY IN USE
	        SEG	Q1		:        RETURN TO PREVIOUS SEG
	      ELSE			:      ELSE
APROT|Q1+1|	EQ	APROT|Q1|	:        COPY PROTECTION
	      EI			:      ENDIF
	    EI				:    ENDIF
	    ORG		.+Q2		:    ADD OVERFLOW TO THE CURRENT SEG
	  EI				:  ENDIF
Q1	  EQ		Q1+1		:NEXT Q1
	ER

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	($0S|Q|SIZE-10000)$A;	REMARK	d bytes%;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA	WC	CNTRL	:CONTROL FLAGS
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
Q	EQ	0
	RE	0E
	BC	APROT|Q|
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id

	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register sets allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols
    })yP!