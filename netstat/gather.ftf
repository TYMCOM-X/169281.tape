***********************************************************************
*                                                                     *
*       GATHER.FTF  VERSION 12.0 MIKE AGNE    MAR. 1992               *
*                   ADDED FOUR FIELDS                                 *
*                   SESSION NUMBER INCREASE TO 15 NUMERIC             *
*       GATHER.FTF  VERSION 11.0 MIKE AGNE    NOV. 1991               *
*                   TWO FIELDS ADDED TO NETSTAT                       *
*       GATHER.FTF  VERSION 10.0 MIKE AGNE    OCT. 1989               *
*                   NETSTAT FILE DEFINITION CHANGE                    *
*                   ADDED ABILITY TO LOOK FOR BOTH TYPES              *
*                   OUTPUT FORMAT SAME FOR BOTH TYPES                 *
*       GATHER.FTF  VERSION 9.0  MIKE AGNE    JAN. 1987               *
*                   ADDED 'D' FILE                                    *
*       GATHER.FTF  VERSION 8.0   S.YOUNG         OCT. 1984           *
*                   ADDED UUN TO KEYED ATTRIBUTES, AND TO             *
*                   SELECTIONS.                                       *
*       GATHER.FTF  VERSION 7.0   S.YOUNG         MAR. 1984           *
*                   USER CAN SELECT ON ALL KEYED ATTRIBUTES IN        *
*                   NETSTAT DAILY FILES.                              *
*       GATHER.FTF  VERSION 6.0   S.YOUNG         FEB. 1984           *
*                   ADDS A 6TH SELECTION OPTION OVER VERSION 5.0      *
*       GATHER.FTF  VERSION 5.0   R.ROSKILLY      FEB. 1984           *
*                   ADDS 3RD FILE OVER VERSION 4.0                    *
*       GATHER.FTF  VERSION 4.0   J.JOELS         DEC. 1982           *
*                                                                     *
*       THIS PROGRAM 'GATHERS' SESSIONS FROM THE DAILY NETWORK        *
*       STATISTICS FILES BASED ON THE FOLLOWING USER DEFINED          *
*       CRITERIA: ORIGNODE, ORIGHOST, TERMHOST, ORIGNODE-ORIGPORT     *
*       PAIRS.  THE SESSIONS ARE GATHERED OVER A USER DEFINED RANGE   *
*       OF DAYS WITH ALL DAYS HAVING TO BE WIHIN THE SAME MONTH.      *
*                                                                     *
***********************************************************************

        CALL DBSTRT(1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0)

        INTEGER SDAY(6),EDAY(6),NUMDAY,IDAY(2),SCR(10),FLENAM(5)
     X  ,DATA(37),USRNAM(5),VALNAM(3),CHAR,NEWNAM(5),OUTFLE(5)
     X  ,DAY1,DAY2,RECNO,TOTREC,TYPE,INFLE(5),PNUM(70),PORTS(150,65)
     X  ,PORT,NODE,DASH,FLAG,COUNT,SCR2(5),PT1,PT2,END,IARR(3)
        INTEGER IARR2(260),PRTCNT,YEAR1,YEAR2,MONTH1,MONTH2,RNGFLG
     X  ,TOTDAY,PROMPT(2),IATTS(27),JDMSTY,INPNUM(7)

        COMMON SCR2,PORTS



*       ** INIT SOME ARRAYS

        NEWNAM(1)='(NETS'
        NEWNAM(2)='TAT)D'
        NEWNAM(3)='ONOT.'
        NEWNAM(4)='DEL  '
        NEWNAM(5)='     '

        DO 40 I=1,5
        OUTFLE(I)='     '
        INFLE(I)='     '
40      CONTINUE

*       ** PORTS ARRAY IS INITIALIZED TO -1'S BECAUSE '0' IS A VALID
*          PORT NUMBER.

        DO 50 I=1,150
        DO 50 J=1,64
        PORTS(I,J)=-1
50      CONTINUE

*       OUTPUT VERSION AND GET COMMAND

51      TYPE 52
52      FORMAT (//,1X,'VERSION 12.0',/,1X,' GATHER
     X  HAS BEEN CHANGED AS OF 3/1/92.',/,
     X  1X,' PLEASE SEE FILE YYMMDD.DMD FOR FORMAT CHANGES.',/)
53      TYPE 54
54      FORMAT (1X,': ',$)
        ACCEPT 55,ICOM
55      FORMAT(A1)
        IF (ICOM.EQ.'R'.OR.ICOM.EQ.'A') GO TO 95
        TYPE 60
60      FORMAT (/,1X,'VALID COMMANDS ARE: RUN, APPEND',/)
        GO TO 53

95      TYPE 100
100     FORMAT (1X,'ENTER START DATE AS YYMMDD: ',$)
        ACCEPT 105,(SDAY(I),I=1,6)
105     FORMAT (6I1)

*       CK IF START DATE IS A VALID DATE

        YEAR1=SDAY(1)*10+SDAY(2)
        MONTH1=SDAY(3)*10+SDAY(4)
        DAY1=SDAY(5)*10+SDAY(6)

*       ** FIRST CHECK VALIDITY OF MONTH

        IF (MONTH1.LT.13) GO TO 110
        TYPE 107,(SDAY(I),I=1,6)
107     FORMAT (1X,'BAD DATE: ',6I1,/)
        GO TO 55

*       ** NOW CHECK DAY

110     IF (DAY1.LT.32) GO TO 115
        TYPE 107,(SDAY(I),I=1,6)
        GO TO 55

*       INPUT END DATE AND CK IF VALID

115     TYPE 120
120     FORMAT (1X,'ENTER END DATE AS YYMMDD: ',$)
        ACCEPT 105,(EDAY(I),I=1,6)
        YEAR2=EDAY(1)*10+EDAY(2)
        MONTH2=EDAY(3)*10+EDAY(4)
        DAY2=EDAY(5)*10+EDAY(6)

*       ** CHECK VALIDITY OF MONTH

        IF (MONTH2.LT.13) GO TO 122
        TYPE 107,(EDAY(I),I=1,6)
        GO TO 115

*       ** CHECK VALIDITY OF DAY

122     IF (DAY2.LT.32) GO TO 124
        TYPE 107,(EDAY(I),I=1,6)
        GO TO 115

*       ** DATES MUST BE IN SAME YEAR

124     IF (YEAR1.EQ.YEAR2) GO TO 126
        TYPE 125
125     FORMAT (1X,'BOTH DATES MUST BE IN THE SAME YEAR-REENTER',/)
        GO TO 55

*       ** DATES MUST BE IN SAME MONTH

126     IF (MONTH1.EQ.MONTH2) GO TO 128
        TYPE 127
127     FORMAT (1X,'DATES CAN NOT CROSS MONTH BOUNDARIES-REENTER',/)
        GO TO 55

*       DETERMINE # OF DAYS TO PROCESS

128     NUMDAY=DAY2-DAY1+1

*       ** DETERMINE IF DATE IS BEFORE 3/1/1992.
*       ** THIS IS DATE FORMAT CHANGED FOR NETSTAT FILE
*       ** IF PRIOR TO 3/1/92  IDMSTY = 0
*       ** IF AFTER 3/1/92  IDMSTY = 1

        IF (YEAR1.LT.92) GO TO 2100
        IF (YEAR1.GT.92) GO TO 2200
        IF (MONTH1.LT.3) GO TO 2100
        GO TO 2200
2100    IDMSTY=0
        GO TO 2300
2200    IDMSTY=1
2300    CONTINUE
*       ** INIT ARRAY: IDAY TO (1ST DATE OF DATE RANGE) -1

        IDAY(1)=SDAY(1)*10000+SDAY(2)*1000+SDAY(3)*100+SDAY(4)*10
     X  +SDAY(5)
        IDAY(2)=SDAY(6)-1

*       CK TO SEE OF DATE RANGE EXISTS

        RNGFLG=0
        ENCODE (20,910,FLENAM) (SDAY(I),I=2,6)
910     FORMAT (9H(NETSTAT),5I1,5HA.DMS)

*       ** OPEN FILE FOR 1ST DATE IN RANGE. IF CAN'T OPEN PRINT ERROR
*          MESSAGE
        OPEN (21,FLENAM,INPUT,ERR=945)
        CLOSE(21)

*       ** OPEN FILE FOR LAST DATE IN RANGE. IF FILE EXISTS
*          ASSUME WHOLE RANGE EXISTS.

920     ENCODE(20,910,FLENAM) (EDAY(I),I=2,6)
        OPEN (21,FLENAM,INPUT,ERR=940)
        CLOSE(21)

*       ** CHECK TO SEE IF SOME FILE WAS NOT AVAILABLE

        IF (RNGFLG.NE.0) GO TO 930

*       ** ALL FILES IN RANGE ARE AVAILABLE.

        TYPE 925
925     FORMAT (1X,'DATE RANGE IS AVAILABLE',/)
        GO TO 129

*       ** WHOLE RANGE IS NOT AVAILABLE.

930     TYPE 935,(EDAY(I),I=1,6)
935     FORMAT (1X,'DATA IS AVAILABLE THROUGH DAY ',6I1,/,1X,'DO YOU
     X  WISH TO CONTINUE?(Y OR N): ',$)
        ACCEPT 960,ANS
        IF (ANS.NE.'Y') GO TO 700
        DAY2=EDAY(5)*10+EDAY(6)
        NUMDAY=DAY2-DAY1+1
        GO TO 129

*       ** A FILE IN THE GIVEN RANGE IS NOT AVAILABLE. SUBTRACT
*          ONE FROM THE DATE OF THE FILE THAT WAS NOT AVAILABLE
*          AND TRY TO OPEN THIS NEW FILE.  CONTINUE THIS PROCESS
*          GOING BACKWARDS FROM LAST DATE IN RANGE TO FIRST UNTIL
*          FIND THE NEXT AVAILABLE FILE.

940     RNGFLG=1
        EDAY(6)=EDAY(6)-1
        IF(EDAY(6).GE.0) GO TO 920
        EDAY(5)=EDAY(5)-1
        EDAY(6)=9
        GO TO 920

*       ** FILE FOR 1ST DATE IN RANGE IS NOT AVAILABLE

945     TYPE 950,(FLENAM(I),I=1,4)
950     FORMAT (1X,'FILE: ',4A5,' IS UNAVAILABLE.',/,1X,' DO YOU WISH TO
     X  REENTER DATE RANGE?(Y OR N): ',$)
        ACCEPT 960,ANS
960     FORMAT (A1)
        IF (ANS.EQ.'N') GO TO 700
        GO TO 55



*       INPUT: OUTPUT FILE NAME

129     IF (ICOM.EQ.'R') TYPE 130
        IF (ICOM.EQ.'A') TYPE 131
130     FORMAT (1X,'OUTPUT TO: ',$)
131     FORMAT (1X,'APPEND TO FILE: ',$)
        ACCEPT 132,(OUTFLE(I),I=1,5)
132     FORMAT (5A5)

*       ** CHECK TO SEE IF FILE ALREADY EXISTS

        CALL RENAM(OUTFLE,NEWNAM,IERR)
        IF (IERR.EQ.0) GO TO 1000

*       ** CK IF COMMAND IS RUN OR APPEND
        IF (ICOM.EQ.'R') GO TO 140

*       ** COMMAND = APPEND. CK IF FILE TO APPEND TO EXISTS.
        IF (IERR.NE.3) GO TO 1020
        TYPE 133
133     FORMAT (1X,'UNABLE TO LOCATE FILE',/)
        GO TO 129

*       ** COMMAND = RUN, OUTPUT MESSAGE TELLING WHETHER FILE IS
*          OLD OR NEW AND ASK FOR CONFIRMATION.

140     IF (IERR.EQ.3) TYPE 141
        IF (IERR.NE.3) TYPE 143
141     FORMAT (1X,'NEW FILE: OK?(Y OR N): ',$)
143     FORMAT (1X,'OLD FILE: OK?(Y OR N): ',$)
        ACCEPT 960,ANS

*       ** IF FILE STATUS IS UNACCEPTABLE QUIT. OTHERWISE, GO
*          AND OPEN OUTPUT FILE.

        IF (ANS.EQ.'N') GO TO 700

*       ** IF OUTPUT FILE ALREADY EXISTS DELETE IT.
        IF (IERR.EQ.3) GO TO 1020
        CALL DELET(OUTFLE,IERR)
        IF (IERR.EQ.0) GO TO 1020
        TYPE 134,IERR
134     FORMAT (1X,'ERROR IN DELETE ROUTINE. ERROR # ',I2,/)
        GO TO 700

*       ** ERROR IN RENAMING

1000    TYPE 1010
1010    FORMAT (1X,'ERROR IN RENAME ROUTINE.',/)

*       ** OPEN THE OUTPUT FILE

1020    OPEN (22,OUTFLE,RANDOUT(270),ERR=600)

*       ** SET UP APPROPRIATE FILE POSITION
        IF (ICOM.EQ.'R') IPOS=1
        IF (ICOM.EQ.'A') IPOS=SIZE(22)+1

*       ** SEE IF USER ONLLY WANTS BILLABLE SESSIONS.
1021    TYPE 1022
1022    FORMAT (1X,'SELECT WHICH SESSIONS? ALL OR BILLABLE? ',
     -  '(A OR B): ',$)
        ACCEPT 1023,IBILL
1023    FORMAT (A1)
        IF (IBILL.NE.'A'.AND.IBILL.NE.'B') GO TO 1021

*       ** SEE IF USER WANTS THE PROJECT CODE STRIPPED FROM THE USERNAME
1025    TYPE 1026
1026    FORMAT (1X,'STRIP PROJECT CODE FROM USERNAME? (Y OR N): ',$)
        ACCEPT 1023,IUSER
        IF (IUSER.NE.'Y'.AND.IUSER.NE.'N') GO TO 1025

*       INPUT: TYPE OF SEARCH

144     TYPE 145
145     FORMAT (1X,'ENTER OPTION NUMBER TO SELECT BY:',/
     X          5X,'1 = ORIGNODE',/
     X          5X,'2 = TERMHOST',/
     X          5X,'3 = ORIGHOST',/
     X          5X,'4 = ORIGNODE-ORIGPORT (TYMNET-1 NODES)',/
     X          5X,'5 = ORIGHOST-ORIGPHYPORT (TYMNET-2 NODES ONLY)',/
     X          5X,'6 = TERMINAL IDENTIFIER',/
     X          5X,'7 = DISCONNECT TYPE',/
     X          5X,'8 = ERROR TYPE',/
     X          5X,'9 = UUN',//
     X          1X,'OPTION? ',$)
        ACCEPT 146,TYPE
146     FORMAT(I1)

*       ** CHECK VALIDITY OF OPTION

        IF (TYPE.GE.1.AND.TYPE.LE.9) GO TO 971
        GO TO 144

*       ** BRANCH TO APPROPRIATE CODE ON OPTION TYPE.
*          SET UP PROMPTS.

971     GO TO (147,148,149,151,151,153,3000,3010,3020),TYPE

*       ** TYPE = 1 (ORIGNODE)

147     PROMPT(1)='ORIGN'
        PROMPT(2)='ODE  '
        GO TO 151

*       ** TYPE = 2 (TERMHOST)

148     PROMPT(1)='TERMH'
        PROMPT(2)='OST  '
        GO TO 151

*       ** TYPE = 3 (ORIGHOST)

149     PROMPT(1)='ORIGH'
        PROMPT(2)='OST  '
        GO TO 151

153     PROMPT(1)='TERM '
        PROMPT(2)='ID   '
        GO TO 151

3000    PROMPT(1)='DISC '
        PROMPT(2)='TYPE '
        GO TO 151

3010    PROMPT(1)='ERROR'
        PROMPT(2)='TYPE '
        GO TO 151

3020    PROMPT(1)='UUN'
        PROMPT(2)=' '
        GO TO 151

*       INPUT: INPUT FILE NAME

151     TYPE 150
150     FORMAT (1X,'INPUT FILE: ',$)
        ACCEPT 152,(INFLE(I),I=1,5)
152     FORMAT(5A5)

*       ** IF INPUT IS FROM TERMINAL STAY HERE

        IF (INFLE(1).NE.'     ') GO TO 800
*       ** IF NOT INPUTING PORTS STAY HERE

        IF (TYPE.EQ.4.OR.TYPE.EQ.5) GO TO 160

*       ***************INPUT FROM TERMINAL**********


*       INPUT: ORIGHOST, TERMHOST, ORIGNODE, TERMID,
*       DISCTYP, ERRTYP, OR UUN NUMBERS

        I=1
        TYPE 154,(PROMPT(IX),IX=1,2)
154     FORMAT (1X,'INPUT',1X,A5,A3,1X,'NUMBERS: ',/)

*       ** ACCEPT NUMBERS UNTIL USER TYPES A C.R. AT THE '?' PROMPT


155     TYPE 156
156     FORMAT (1X,'? ',$)
        ACCEPT 157,INUM
157     FORMAT(I)
        IF (INUM.EQ.0) GO TO 200

*       ** PUT NUMBER INTO 1ST WORD OF CURRENT ELEMENT  OF PORTS ARRAY

        PORTS(I,1)=INUM

*       ** MAX. OF 10 NUMBERS CAN BE INPUT FROM TERMINAL.

2010    IF (I.EQ.10) GO TO 200
        I=I+1
        NODE=NODE+1
        GO TO 155

*       INPUT: ORIGNODE/ORIGHOST-PORT COMBINATIONS

160     IF (TYPE.EQ.4) TYPE 162
        IF (TYPE.EQ.5) TYPE 970
162     FORMAT (1X,'INPUT ORIGNODE-ORIGPORT PAIRS: NODE,PORT(OR PORT-',
     X  'PORT)')
970     FORMAT (1X,'INPUT ORIGHOST-ORIGPHYPORT PAIRS: HOST,PORT',
     X  '(OR PORT-PORT)')

*       ** INIT SOME VARIABLES:  COUNT = NUMBER OF DIGITS IN NUMBER
*          BEING BUILT. DASH = FLAG: SET TO 1 IF CURRENT CHAR. EQ '-'
*          FLAG = FLAG: SET TO 1 AFTER FIRST NUMBER IS BUILT
*          NODE = POINETER TO CURRENT ELEMENT IN PORTS ARRAY
*          PORT = POINTER TO NEXT WORD TO PLACE A PORT IN CURRENT
*                 ELEMENT IN PORTS ARRAY
*          END = FLAG: SET TO 1 HAVE REACHED END OF CHAR. STRING

        COUNT =1
        DASH=0
        FLAG=0
        NODE=1
        PORT=2
        END=0

*       ** OUTPUT '?' PROMPT AND ACCEPT NOE/HOST-PORT PAIRS UNTIL A 
*          C.R. IS TYPED AT THE PROMPT.

*       ** OUTPUT '?' PROMPT AND ACCEPT NOD/HOST-PORT PARIS UNTIL A
*          C.R. IS TYPED AT THIS PROMPT

        DO 193 N=1,10
163     TYPE 156
        ACCEPT 164,(PNUM(J),J=1,70)
        IF (PNUM(1).EQ.' ') GO TO 200
164     FORMAT (70A1)


*       ***SEARCH STRING AND BREAK OUT NODE/HOST AND PORT NUMBERS***
*       ************************************************************

166     DO 190 II=1,70

*       ** IF CHAR. IS NON-BLANK GO PROCESS THE CHAR.

        IF (PNUM(II).NE.' ') GO TO 165

*       ** IF 1ST CHAR. IS A BLANK  GO PROCESS NEXT CHAR. STRING.
*          ELSE, THIS BLANK SIGNALS END OF CHAR. STRING. SET END FLAG.
        IF (II.EQ.1) GO TO 195
        END=1

*       ** IF CHAR . IS NOT A DELIMENTER STAY HERE

165     IF (PNUM(II).EQ.','.OR.PNUM(II).EQ.'-'.OR.PNUM(II).EQ.' ')
     X  GO TO 169

*       PLACE CHAR. INTO SCR2 ARRAY.  THIS ARRAY IS BEING USED TO
*       BUILD A NUMBER.


        SCR2(COUNT)=PNUM(II)
        COUNT=COUNT+1
        GO TO 190

*       ** CHAR. IS A DELIMETER. THIS SIGNALS END OF A NUMBER.
*          THEREFORE, DECREMENT DIGIT COUNTER.

169     COUNT=COUNT-1

*       ** STAY HERE IS DELIMETER = '-'

        IF (PNUM(II).EQ.','.OR.PNUM(II).EQ.' ') GO TO 175

*       SET DASH FLAG-THIS MEANS THAT THIS PORT IS 1ST OF A RANGE
*       AND THAT THE NEXT PORT WILL BE THE LAST OF A RANGE

        DASH=1

*       ** GO PUT PORT NUMBER JUST BUILT INTO PORTS ARRAY

        CALL CODE(N,PORT,COUNT)

*       ** RESET SOME VARIABLES AND GO PROCESS NEXT CHAR.

        COUNT=1
        GO TO 190

*       ** DELIMETER = ','
*       IF FLAG = 0, THEN THIS IS THE NODE NUMBER. ELSE, THIS IS A
*       PORT NUMBER

175     IF(FLAG.NE.0) GO TO 177

*       ** GO PUT NUMBER INTO 1ST WORD OF CURRENT ELEMENT OF PORTS ARRAY

        IXPRT=1
        CALL CODE(N,IXPRT,COUNT)

*       ** RESET SOME VARIABLES AND GO PROCESS NEXT CHAR.

        COUNT=1
        FLAG=1
        NODE=N
        GO TO 190

*       ** NUMBER JUST BUILT IS A PORT
*       IF DASH = 0, THEN THIS IS A SINGLE PORT AND NOT
*       PART OF A RANGE.

177     IF (DASH.NE.0) GO TO 180

*       ** PORT IS NOT PART OF A RANGE. GO PUT PORT INTO PORTS ARRAY

        CALL CODE(N,PORT,COUNT)

*       ** IF AT END OF CHAR. STRING GO PROCESS NEXT CHAR. STRING.
*          ELSE, INCREMENT PORT POINTER AND GO PROCESS
*          NEXT CHAR. IN THIS STRING.

        IF (END.NE.O) GO TO 191
        COUNT=1
        PORT=PORT+1
        GO TO 190

*       THIS PORT IS LAST OF A RANGE OF PORTS
*       FIND 1ST OF RANGE AND FILL IN BETWEEN.

180     PT1=PORTS(N,PORT)
        L=PORT+1

*       ** PLACE LAST PORT OF RANGE INTO NEXT AVAILABLE WORD IN PORTS
*          ARRAY.  CURRENT ELEMENT NOW CONTAINS NODE OR HOST NUMBER
*          IN WORD 1, 1ST PORT OF RANGE IN WORD 2, LAST PORT OF RANGE
*          IN WORD 3.

        CALL CODE(N,L,COUNT)

*       ** PUT 1ST PORT OF RANGE INTO SCR2 ARRAY. THIS ARRAY WILL BE USED
*          TO BUILD THE PORT NUMBERS BETWEEN 1ST AND LAST PORTS OF RANGE.

        ENCODE (3,181,LL) PT1
        DECODE (3,186,LL)(SCR2(J),J=1,3)
181     FORMAT (I3)
186     FORMAT(3I1)

*       PT1=1ST PORT OF RANGE, PT2=(LAST PORT OF RANGE) - 1
        PT2=PORTS(N,L)-1
*
*       ** FIND PORTS BETWEEN 1ST AND LAST PORTS IN RANGE

        DO 185 KK=PT1,PT2
        PORT=PORT+1

*       ** ADD ONE TO LAST DIGIT OF PORT NUMBER. SINCE PORTS ARE OCTAL
*          IF LAST DIGIT NOW = 8 THEN INCREMENT NEXT TO LAST DIGIT
*          BY ONE AND SET LAST DIGIT TO 0.

        SCR2(3)=SCR2(3)+1
        IF (SCR2(3).NE.8) GO TO 184
 
183     SCR2(2)=SCR2(2)+1
        SCR2(3)=0
        IF (SCR2(2).NE.8) GO TO 184
        SCR2(1)=SCR2(1)+1
        SCR2(2)=0

*       ** PLACE NEW PORT NUMBER INTO APPROPRIAE WORD IN PORTS ARRAY

184     ENCODE (3,186,LL) (SCR2(J),J=1,3)
        DECODE (3,181,LL) PORTS(N,PORT)

*       ** CHECK IF TIME TO STOP

        IF (PORTS(N,PORT).EQ.PT2+1) GO TO 188
185     CONTINUE

*       ** CHECK IF HAVE REACHED END OF CURRENT CHAR. STRING

188     IF (END.NE.0) GO TO 191

*       ** GO PROCESS NEXT CHAR. IN STRING

        PORT=PORT+1
        DASH=0
        COUNT=1
190     CONTINUE

*       ** REACHED END OF CURRENT CHAR. STRING. GO PROCESS NEXT ONE

191     IF(PORT.LE.64) GO TO 192
        TYPE 885,INFLE,PNUM
885     FORMAT (/,1X,'MORE THAN 64 PORTS SPECIFIED ON FOLLOWING LINE',
     -  ' OF ',5A5,/,1X,70A1,//)
        GO TO 700

192     COUNT=1
        DASH=0
        FLAG=0
        PORT=2
        END=0

*       ** IF CHAR. STRINGS ARE BEING READ FROM A FILE GO READ 
*          ANOTHER ONE.

195     IF(INPUT.EQ.'FILE') GO TO 830
193     CONTINUE

*       ** FINISHED WITH ALL CHAR. STRINGS. GO START FINDING RECORDS.

        GO TO 200


*       ***************INPUT FROM A FILE****************

*       ** OPEN INPUT FILE

800     OPEN (21,INFLE,INPUT,ERR=670)
*       IF INPUTTING ORIGNODE, TET, OR ORIGHOST NUMBERS STAY HERE

        IF (TYPE.EQ.4.OR.TYPE.EQ.5) GO TO 825

*       ** INPUT NUMBERS. INPUT UNTIL END OF FILE IS REACHED OR A BLANK
*          RECORD IS FOUND, THEN GO AND START FINDING RECORDS.

805     I=1
810     READ (21,820,END=200) PORTS(I,1)
820     FORMAT (I)
        IF (PORTS(I,1).EQ.0) GO TO 200
        NODE=NODE+1
        I=I+1

*       ** CHECK IF EXCEEDING ARRAY SIZE.

        IF (I.GT.150) GO TO 880
        GO TO 810

*       INPUT NODE-PORT COMBINATIONS

825     N=0
        PORT=2
        COUNT=1
        DASH=0
        FLAG=0
        END=0
830     INPUT='FILE'
        COUNT=1
        READ (21,840,END=200) (PNUM(I),I=1,70)
840     FORMAT (70A1)

*       ** CHECK IF EXCEEDING ARRAY SIZE

        N=N+1
        IF (N.GT.150) GO TO 880

*       ** GO SEARCH CHAR. STRING AND BREAK OUT NODE/HOST AND PORT
*         NUMBERS.

        GO TO 166

*       EXCEEDED ARRAY SIZE

880     TYPE 890
890     FORMAT (1X,'THIS SEARCH IS LIMITED TO 150 NODES OR HOSTS.',/)
        GO TO 700

*       *************** PROCESS EACH DAY ***************

*       ** IDAY AT THIS POINT = (1ST DATE OF RANGE) - 1
*          IDAY(1) = YYMMD. IDAY(2) = LAST DIGIT OF DATE.  
*          THIS ARRAY WILL BE USED TO BUILD THE FILE NAMES FOR EACH
*          DAY TO BE PROCESSED.

200     DO 500 I=1,NUMDAY

*       INIT DAY2 FLAG TO 0, THAT IS THE 2ND FILE FOR THE DAY HAS
*       NOT BEEN PROCESSED.
        IDAY2=0

*       BUILD THE FILE NAME
201     FORMAT (I5)
202     FORMAT (5I1)
203     FORMAT (I1)
205     FORMAT (9H(NETSTAT),5I1,5HA.DMS)

*       ** INCREMENT 2ND DIGIT OF DAY. IF 2ND DIGIT NOW IS GT 9
*          THEN INCREMENT REST OF DATE BY ONE AND SET 2ND DIGIT OF DAY 
*          TO 0.

        IDAY(2)=IDAY(2)+1
        IF (IDAY(2).LE.9) GO TO 250
        IDAY(2)=0
        IDAY(1)=IDAY(1)+1

*       ** OUTPUT DATE BEING PROCESSED

250     ENCODE (5,201,LL)IDAY(1)
        DECODE (5,202,LL)(SCR(J),J=1,5)
        ENCODE (1,203,LL)IDAY(2)
        DECODE (1,203,LL) SCR(6)
        ENCODE (20,205,FLENAM)(SCR(J),J=2,6)
        TYPE 252,(SCR(J),J=1,6)
252     FORMAT (/,1X,'PROCESSING ',6I1,$)

*       OPEN THE CURRENT FILE

253     CALL DBOPEN(FLENAM)

*       ** ON FIRST DAY OF RANGE GET ATTRIBUTE NUMBERS FOR USE IN
*          CALLS TO 1022

        IF (I.NE.1) GO TO 210
        CALL DBINFO ('ORIGNODE',IATTS)
        INATT=IATTS(7)
        CALL DBINFO('ORIGPORT',IATTS)
        IPATT=IATTS(7)
        CALL DBINFO('TERMHOST',IATTS)
        ITATT=IATTS(7)
        CALL DBINFO('ORIGHOST',IATTS)
        IOATT=IATTS(7)
        CALL DBINFO ('ORIGPHYPORT',IATTS)
        IPPATT=IATTS(7)
        CALL DBINFO ('TERMID',IATTS)
        ITIATT=IATTS(7)
        CALL DBINFO ('DISCTYPE',IATTS)
        IDATT=IATTS(7)
        CALL DBINFO ('ERRTYP',IATTS)
        IEATT=IATTS(7)
        CALL DBINFO('UUN',IATTS)
        IUUATT=IATTS(7)

*       CREATE THE ARRAYS TO PASS ARGUMENTS THROUGH THE DBFIND
*       COMMAND TO 1022.

210     DO 400 N=1,NODE

*       ** COUNT THE NUMBER OF PORTS ASSOCIATED WITH CURRENT ELEMENT
*          OF PORTS ARRAY.

        PRTCNT=0
        DO 255 JJ=2,65
        IF (PORTS(N,JJ).EQ.-1) GO TO 257
        PRTCNT=PRTCNT+1
255     CONTINUE

*       ** SET PRIMARY SELECTION TO ORIGNODE, ORIGHOST, OR TERMHOST

257     IARR(1)=INATT
        IF (TYPE.EQ.2) IARR(1)=ITATT
        IF (TYPE.EQ.3.OR.TYPE.EQ.5) IARR(1)=IOATT
        IF (TYPE.EQ.6) IARR(1)=ITIATT
        IF (TYPE.EQ.7) IARR(1)=IDATT
        IF (TYPE.EQ.8) IARR(1)=IEATT
        IF (TYPE.EQ.9) IARR(1)=IUUATT
        IARR(2)='EQ'
        IARR(3)=PORTS(N,1)

*       IF SEARCH IS FOR NODE/HOST-PORT COMBINATIONS CONTINUE

        IF (TYPE.NE.4.AND.TYPE.NE.5) GO TO 265

*       ** SET SECONDARY SELECTION TO ORIGPORT OR ORIGPHYPORT

        ICPORT=IPATT
        IF (TYPE.EQ.5) ICPORT=IPPATT

*       ** PUT INFO ON FIRST PORT INTO SELECTION ARRAY
261     IARR2(1)='LAST'
        IARR2(2)='SAV.'
        IARR2(3)=1
        IARR2(4)=ICPORT
        IARR2(5)='EQ'
        IARR2(6)=PORTS(N,2)

*       ** IF MORE THAN ONE PORT STAY HERE

        II=7
        IF (PRTCNT.EQ.1) GO TO 263

*       ** PLACE REST OF PORTS INTO SELECTION ARRAY

        DO 260 KK=3,PRTCNT+1
        IARR2(II)='OR'
        IARR2(II+1)=ICPORT
        IARR2(II+2)='EQ'
        IARR2(II+3)=PORTS(N,KK)
        II=II+4
260     CONTINUE

*       ** COMBINE THIS SELECTION OF PORTS WITH THE PRIMARY SELECTION BY
*          ORIGNODE/ORIGHOST/TERMHOST.

263     IARR2(II)='AND'
        IARR2(II+1)='REF.'
        IARR2(II+2)=1
        DAYFLG=1

*       ISSUE FIND COMMANDS TO 1022

*       ** DO PRIMARY SELECTION

265     CALL DBFIND ('FIX.',1,3,IARR)

*       ** IF NECESSARY DO SECONDARY SELECTION

        IF (TYPE.NE.4.AND.TYPE.NE.5) GO TO 270
        CALL DBFIND ('FIX.',1,4*(PRTCNT)+5,IARR2)

*       ** IF USER WANTS ONLY BILLABLE SESSIONS , THEN SELECT
*          ONLY BILLABLE SESSIONS

270     IF (IBILL.EQ.'B') CALL DBFIND('LAST','AND','ERRTYP','NE',1)

*       ** DETERMINE NUMBER OF RECORDS FOUND. INCREMENT THE DAY
*          TOTAL AND GRAND TOTAL

        CALL DBNREC(RECNO)
272     TOTREC=TOTREC+RECNO
        TOTDAY=TOTDAY+RECNO

*       ***PROCESS EACH RECORD***

*       ** GET A RECORD

300     CALL DBGREC($400)

*       ** GET 1ST 19 NUMERIC ATTRIBUTES

        DO 310 J=1,19
        CALL DBVAL(J,DATA(J))
310     CONTINUE

*       READ USERNAM INTO ARRAY

        CALL DBVAL('USRNAM',USRNAM)

*       ** CK IF NEED TO STRIP PROJECT CODE
        IF (IUSER.EQ.'Y') CALL STRIPP(USRNAM)


*       ** GET REST OF ATTRITBUTES
*       ** CHECK NETSTAT FILE FORMAT
        IF (IDMSTY.EQ.0) GO TO 3200
        DO 30000 J=21,35
        CALL DBVAL(J,DATA(J-1))
30000   CONTINUE
        CALL DBVAL('INPNUM',INPNUM)
        DO 31000 J=37,39
31000   CALL DBVAL(J,DATA(J-2))
        CONTINUE
        GO TO 3300
3200    DO 320 J=21,35
        CALL DBVAL(J,DATA(J-1))
320     CONTINUE
        DO 32000 J=1,7
32000   INPNUM(J)='     '
        CONTINUE
        DATA(35)=0
        DATA(36)=0
        DATA(37)=0
3300    CONTINUE
*       ** WRITE SESSION TO OUTPUT FILE

370     WRITE (22#IPOS,380)(DATA(K),K=1,19),(USRNAM(L),L=1,5),(DATA(IK),
     X  IK=20,34),(INPNUM(M),M=1,7),(DATA(JK),JK=35,37)
380     FORMAT(I15,I5,I3,I2,I5,I3,I5,I3,I6,I4,2I12,I13,I6,I4,I7,I2,I2,
     X  I6,5A5,I5,I3,2I8,2I1,I4,2I5,I1,I5,I1,I8,I7,I15,6A5,A2,I6,I6,I2)
        IPOS=IPOS+1

*       ** GO GET ANOTHER RECORD

        GO TO 300

*       ** FINISHED PROCESSING CURRENT ELEMENT OF PORTS ARRAY. 
*          GO PROCESS NEXT.

400     CONTINUE

*       ** FINISHED WITH SELECTION FOR THIS DAY. CLOSE INPUT FILE.

        CALL DBCLOS

*       ** CK IF THE 2ND FILE FOR THE DAY HAS ALREADY BEEN PROCESSED.
        IF (IDAY2.EQ.1) GO TO 403
        IF (IDAY2.EQ.2) GO TO 405
        IF (IDAY2.EQ.3) GO TO 4050
        IF (IDAY2.EQ.4) GO TO 407

*       ** NOW CK IF THERE IS A 2ND FILE FOR THIS DAY
        ENCODE(20,402,FLENAM)(SCR(J),J=2,6)
402     FORMAT (9H(NETSTAT),5I1,5HB.DMS)
        OPEN (3,FLENAM,INPUT,ERR=407)

*       ** 2ND FILE IS THERE. GO AND PROCESS IT.
        CLOSE(3)
        IDAY2=1
        GO TO 253

*       NOW CK IF THERE IS A 3RD FILE FOR THIS DAY

403     IF (IDAY2.EQ.2) GO TO 407
        ENCODE(20,404,FLENAM)(SCR(J),J=2,6)
404     FORMAT (9H(NETSTAT),5I1,5HC.DMS)
        OPEN (3,FLENAM,INPUT,ERR=407)

*       3RD FILE IS THERE, GO AND PROCESS IT.
        CLOSE (3)
        IDAY2=2
        GO TO 253

*       NOW CK IF THERE IS A 4TH FILE FOR THIS DAY

405     IF (IDAY2.EQ.3) GO TO 407
        ENCODE(20,406,FLENAM)(SCR(J),J=2,6)
406     FORMAT (9H(NETSTAT),5I1,5HD.DMS)
        OPEN (3,FLENAM,INPUT,ERR=407)

*       4TH FILE IS THERE, GO AND PROCESS IT.
        CLOSE (3)
        IDAY2=3
        GO TO 253
*       NOW CK IF THERE IS A 5TH FILE FOR THIS DAY

4050    IF (IDAY2.EQ.4) GO TO 407
        ENCODE(20,4060,FLENAM)(SCR(J),J=2,6)
4060    FORMAT (9H(NETSTAT),5I1,5HE.DMS)
        OPEN (3,FLENAM,INPUT,ERR=407)

*       5TH FILE IS THERE, GO AND PROCESS IT.
        CLOSE (3)
        IDAY2=4
        GO TO 253
407     TYPE 410,TOTDAY
410     FORMAT (1H+,10X,'SESSIONS PROCESSED=',I10)
        TOTDAY=0

*       ** GO PROCESS ANOTHER DAY

500     CONTINUE

*       ** FINISHED PROCESSING ALL DAYS. CLOSE OUTPUT FILE
        CLOSE (22)

*       ** OUTPUT TOTAL RECORDS PROCESSED AND QUIT

        TYPE 550,TOTREC
550     FORMAT(//,1X,'TOTAL SESSIONS PROCESSED= ',I10)
        GO TO 700

*       UNABLE TO OPEN OUTPUT FILE
600     TYPE 650
650     FORMAT(1X,'UNABLE TO OPEN OUTPUT FILE')
        GO TO 700

670     TYPE 680,(INFLE(I),I=1,5)
680     FORMAT (1X,'UNABLE TO OPEN FILE: ',5A5)

        GO TO 151


*       ** QUIT

700     CALL DBEND

        END


        SUBROUTINE CODE(NODE,PORT,COUNT)

        COMMON SCR2(5),PORTS(150,65)
        INTEGER NODE,PORT,COUNT
*       ** BRANCH TO APPROPRIATE CODE ACCORDING TO NUMBER OF DIGITS
*          IN NUMBER

        GO TO (100,200,300,400,500),COUNT
        GO TO 500

        
100     ENCODE (1,110,LL)SCR2(1)
        DECODE (1,111,LL)PORTS(NODE,PORT)
110     FORMAT (A1)
111     FORMAT (I1)
        RETURN

200     ENCODE(2,210,LL) (SCR2(J),J=1,2)
        DECODE(2,211,LL) PORTS(NODE,PORT)
210     FORMAT (2A1)
211     FORMAT (I2)
        RETURN

300     ENCODE (3,310,LL) (SCR2(J),J=1,3)
        DECODE (3,311,LL)PORTS(NODE,PORT)
310     FORMAT(3A1)
311     FORMAT(I3)
        RETURN

400     ENCODE (4,410,LL) (SCR2(J),J=1,4)
        DECODE (4,411,LL)PORTS(NODE,PORT)
410     FORMAT (4A1)
411     FORMAT (I4)
        RETURN

500     ENCODE (5,510,LL) (SCR2(J),J=1,5)
        DECODE (5,511,LL)PORTS(NODE,PORT)
510     FORMAT (5A1)
511     FORMAT (I5)
        RETURN
        END
   5~$t§