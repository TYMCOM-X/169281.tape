.PS 58,77
.AP
.C;MAC80 User's guide
.b
.c;Bruce Tanner
.b
.i 30
Cerritos College
.i 30
11110 Alondra Blvd.
.i 30
Norwalk, CA 90650
.i 30
Cerritos@USC-ECL.ARPA
.CH Introduction

MAC80 is an 8085/Z80 cross assembler for the DECsystem-10, which also
runs on the DECSYSTEM-20 under the compatability package.  This document
describes the use of the assembler and the syntax of the source file
to be used by the assembler. Some attempt has been made to make MAC80
compatible with Macro-80 from Microsoft and MAC/RMAC from Digital
Research; the differences between MAC80 and these other assemblers are
described in appendix A.

.HL 1 MAC80 source

MAC80 is made from three files,
.list "o"
.le;M80UNV.MAC - The universal file containing symbol definitions
.le;MAC80.MAC - The command scanner
.le;MAC80A.MAC - The parser/code generator
.els
some of the macros require MACTEN.UNV which in turn requires JOBDAT.UNV.

.HL 1 Output

MAC80 can generate an object file, a list file and a symbol file.
.list "o"
.le;The object (.HEX) file is an Intel hex format file.
.le;The list (.LST) file shows the code generated by the source lines. A
cross-reference listing may optionally be included.
.le;The symbol (.SYM) file contains a list of the symbols defined in the
source file for use with SID/ZSID.
.end list

Like ASM and MAC, MAC80 generates absolute location code. Macro-80 programs
that use ASEG will generate compatible code.

.ch Running MAC80
After invoking MAC80 (.R MAC80 or @MAC80), it will display an asterisk prompt.
The command line for MAC80 consists of four fields, labeled:
.B
.i 10
Object,List=Source/Switch

.HL 1 Source

The source field has the format Device:Filename.Ext[Proj,Prog].
The Device and Filename are limited to 6 characters, the Ext to 3 characters,
SFDs are not supported. If the device is omitted, DSK: is used,
if the extension is omitted, .M80 is used, if the PPN is omitted,
your current path is used.

.hl 1 Object

The Object field has the format Device:Filename.Ext (6:6.3). If the device
is omitted DSK: is used, if the filename is omitted the source filename is
used, if the extension is omitted .HEX is used.

.HL 1 List

The List field has the format Device:Filename.Ext (6:6.3). If the Device
is omitted DSK: is used, if the filename is omitted the source filename is
used, if the extension is omitted .LST is used.

.hl 1 Switch

The switch field(s) may be placed anywhere in the command line. There
are two switches:
.list "o"
.le;/C - Add a cross-reference listing to the List file.
.le;/S - Generate a Symbol file with the Source filename and a .SYM ext.
.els
/C will create a List file if none was requested.

.hl 1 Command line syntax

To assemble the source with an object file of the same name, you only need
to enter the source file name:
.B
.i 10
*Source  or  *=Source

To assemble the source with an object file of the same name and a list file
of the same name, you may enter:
.B
.i 10
*,=Source

.hl 1 CCL mode

MAC80 can be invoked with the COMPILE command if the line
.i 10
X MAC80,M80,MAC80,,HEX,,=
is placed in the language definition macro in COMPIL.MAC. Tops-20 users
will need to modify the EXEC.

.ch Source file syntax
.hl 1 Source lines
Each line of the source consists of the following fields:
.B
Label:	Operator  Arg,Arg...Arg		;Comment
.B
each of the fields is optional. If the operator is an EQU or MACRO,
the label must not have a colon.  Some examples:
.B
.lit
FALSE	EQU	0

START:	LXI	SP,STACK	;SET UP THE STACK

	DB	1,2,3,4

	NOP			;NOOP
.END LIT

Labels must be followed by a colon. For compatibility with Macro-80,
two colons may be used, but the label is not treated any differently.



.hl 1 Comments

Comments begin with a semicolon and end with a carriage return. Long
comments can be contained in the .COMMENT pseudo-op.

.hl 1 Symbols

.list 0
.le;Symbols may be any length, but only the first twelve characters are
significant.
.le;The legal symbol characters are A-Z a-z 0-9 $ . ? @ __
.le;A symbol must not start with a digit.
.le;Lower case characters are automatically converted to upper case.
.els

.hl 1 Opcodes

MAC80 supports two instruction sets: 8085 and Z80. By default, MAC80
starts in 8085 mode; the .Z80 pseudo-op must be used before any Z80
opcodes will be understood.

Opcodes may also be macro names. See chapter 5 for information about macros.

.hl 1 Expressions

MAC80 opcodes and pseudo-ops will accept arbitrary expressions as their
arguments. Expressions are one or more operands (symbols, numbers, character
constants or 8085 opcodes) seperated by operators (arithmetic or logical).

.hl 2 Operands

Operands (except strings) generate 16 bits of data. They may be numbers,
strings, character constants, symbols, 8085 opcodes or expressions.

.hl 2 Numbers

A number is always evaluated as decimal	unless one of the following
notations are used:
.B
.i 10
nnnnB	Binary
.i 10
nnnnO	Octal
.i 10
nnnnQ	Octal
.i 10
nnnnH	Hexadecimal

Hexadecimal numbers must start with a digit. A dollar sign may be imbedded
in a number for legibility.  For example:
.B
.i 10
1100$1010B
.B
generates 0CA hex.

.hl 2 Strings

The DB or DEFB pseudo-ops will accept zero or more characters delimited
by quotation marks. Either single (') or double (") quotes may be used,
but they are not interchangeable.  For example:
.B
.i 10
DB  "'Howdy', he said"
.B
generates the string
.B
.i 10
'Howdy', he said

To be compatible with Macro-80, two quotes in a row will generate
a single occurrence of that quote.  For example:
.B
.i 10
DB  """Howdy"", he said"
.B
generates the string
.B
.i 10
"Howdy", he said

.hl 2 Character constants

Character constants are zero, one or two characters between quote marks.
They generate a 16 bit value and may be used in expressions.  For example:
.b
.i 10
LXI  B,'AB'+1
.b
generates
.b
.i 10
01 43 41

However, only single character constants are allowed in the DB (DEFB) pseudo-op
(where two character constants aren't necessary).

Quoted character strings are character constants only if the expression
has more than one operand.

.hl 2 Symbols

A symbol may be used as an operand in an expression. The value of the symbol
is used when the expression is evaluated.

There is one special symbol that may not be defined by the source program.
The dollar sign ($) is the current program counter symbol. When used in an
expression, the current PC symbol is evaluated to be the address of the
next instruction or data byte to be assembled.

.hl 2 8085 Opcodes

An 8085 opcode may be used as as operand. Only opcodes that generate
one byte may be used. If the opcode uses more than one symbol, the opcode
must be enclosed in parentheses. 8085 opcodes are not legal in Z80 mode.

.hl 2 Expressions

Parenthesized expressions may be used as operands in expressions.
Expression evaluation will always be performed on parenthesized sub-expressions
before an operator is used.

Because the Z80 instruction mnemonics use parentheses to distinguish
between addresses and immediate values, parentheses may not be used at the
start of expressions in Z80 mode. Instead, angle brackets <> may be used to
form sub-expressions.

.hl 2 Operators

The following operators are allowed in expressions.

Unary operators use the next operand as their argument. HIGH, LOW, NOT,
NUL and unary minus are unary operators.
.b 2
HIGH	Returns the high byte of the next operand. It is equivalent to
.lm 8
(<operand> AND 0FF00H) SHR 8.
.lm 0
.b
LOW	Returns the low byte of the next operand. It is equivalent to
.lm 8
<operand> and 0FFH.
.b
.lm 0
NOT	Complements the value of the next operand.
.b
NUL	Returns true (0FFFFH) if the next operand was not specified
.lm 8
when the macro was invoked, otherwise it returns false (0). This operator
is only applicable in macro definitions.
.lm 0
.b
-	Unary minus. Returns the negative value of the next operand.
.b

The rest of the operators are binary; that is, they are placed between two
operands.
.b2
+	Returns the sum of the two operands.
.b
-	Returns the difference of the two operands.
.b
*	Returns the product of the two operands.
.b
/	Returns the integer part of the quotient of the two operands.
.b
MOD	Returns the remainder (modulo) part of the quotient.
.b
AND	Returns a bitwise logical AND of the two operands.
.b
OR	Returns a bitwise logical OR of the two operands.
.b
XOR	Returns a bitwise logical Exclusive OR of the two operands.
.b
SHR	Shift right the value of the previous operand by the integer
.lm 8
value specified by the next operand.
.lm 0
.b
SHL	Shift left the value of the previous operand by the integer
.lm 8
value specified by the next operand.
.lm 0
.B

The rest of the operators return true (0FFFFH) or false (0).
.b 2
EQ	Returns true if the two operands are equal.
.b
NE	Returns true if the two operands are not equal.
.b
LT	Returns true if the previous operand is less than the next operand.
.b
LE	Returns true if the previous operand is less than or equal
.lm 8
to the next operand.
.lm 0
.b
GT	Returns true if the previous operand is greater than
.LM 8
the next operand.
.LM 0
.b
GE	Returns true if the previous operand is greater than or equal
.lm 8
to the next operand.
.lm 0
.B 2
The order of precedence for the operators is:
.list
.le;NUL
.le;NOT, Unary minus
.le;*, /, MOD, SHR, SHL
.le;+, -
.le;EQ, NE, LT, LE, GT, GE
.LE;AND
.LE;OR, XOR
.LE;HIGH, LOW
.els

.CH Pseudo-ops

Pseudo-ops direct the assembler to perform some function. Below are the MAC80
pseudo-ops:
.B2
ASEG
.LM 10

This pseudo-op does nothing. It is for compatibility with Macro-80 programs.
.b
.LM 0
<name> SET <expr>
.i 0
<name> ASET <expr>
.LM 10

<name> is set to the value of <expr>. SET may not be used in Z80 mode because
SET is a Z80 instruction.
.b
.LM 0
<name> EQU <expr>
.LM 10

<name> is set to the value of <expr>. If <name> already has a value other
than <expr>, an error will be generated.
.b
.LM 0
DB  <expr>[,<expr>...]
.i 0
DEFB  <expr>[,<expr>...]
.LM 10

DB stores the least eight bits value(s) of the expression(s) in memory at
the current PC location.  <expr> may also be a string.
.b
.LM 0
DW  <expr>[,<expr>...]
.i 0
DEFW  <expr>[,<expr>...]
.LM 10

DW stores the value(s) of the expressions(s) in memory at the current PC
location.  Each <expr> is evaluated as a 16 bit value, and is stored with
the low byte first, then the high byte.
.b
.LM 0
DS  <expr>
.i 0
DEFS  <expr>
.LM 10

DS reserves <expr> bytes in memory.  The contents of this space are undefined.
.b
.LM 0
END  [<expr>]
.LM 10

The END pseudo-op specifies that the end of the program has been reached.
If <expr> is present, its value is placed in the last record (01 type)
in the object file.  If END is found in a MACLIB or INCLUDEd file, it is
ignored.
.b
.LM 0
OCT
.i 0
HEX
.LM 10

OCT causes the listing to be printed with octal numbers to be printed
in the address and code fields.  HEX switches it back to hexadecimal.
HEX is the default.
.b
.LM 0
INCLUDE <filename>
.i 0
MACLIB <filename>
.LM 10

INCLUDE inserts the source from an alternate file into the source file.
MACLIB is the same as Include except that neither the inserted text nor
its generated code is listed.
The file is assumed to be on DSK: in your default path.  If the extension
is omitted, .LIB is assumed.
.b
.LM 0
ORG  <expr>
.LM 10

ORG changes the value of the location counter to be <expr>.  CP/M programs
should start with an ORG 100H.
.b
.LM 0
_.PHASE  <expr>
.LM 10

_.PHASE tells the assembler to assemble the code as if it were at <expr>,
but to leave the code at the current location counter.
.b
.LM 0
PAGE  [<expr>]
.LM 10

PAGE will cause a form feed to be placed in the list file. If <expr> is
included, the current page size is changed to be <expr>. The default page size
is 60.
.b
.LM 0
TITLE  <text>
.LM 10

TITLE specifies a title to be used in each page heading of the list file.
.b
.LM 0
SUBTTL	<text>
.LM 10

SUBTTL specifies the subtitle to be used after the title in each page heading
of the list file.
.b
.LM 0
_.Z80
.i 0
_.8080
.LM 10

_.Z80 specifies that the assembler be placed in Z80 mode.  .8080 is used
to place the assembler back in 8085 mode.  8085 mode is the default.
.b
.LM 0
_.COMMENT <delim> <text> <delim>
.LM 10

_.COMMENT is used to make long comments. Anything between the delimiters
is ignored.
.b
.LM 0
_.LALL
.i 0
_.SALL
.i 0
_.XALL
.i 0
_.XLIST
.i 0
_.XMAC
.lm 10

These pseudo-ops are for listing control:
.b
.lit
.LALL   list everything.

.XALL   don't list code generated after the first line (6 bytes)
        of a DB or DW.  This is the default.

.XMAC   XALL plus don't list the text expansion of macros.

.SALL   XMAC plus don't list code generated by macros.

.XLIST  shut off listing.

.end lit
.lm 0
.b
_.PRINTX  <text>
.LM 10

_.PRINTX will list the text on the terminal during the second pass.
.lm 0
.b
IF  <expr>
.i 0
IFN  <expr>
.lm 10

If <expr> is non-zero, the statements within the conditional block are
assembled.
.lm 0
.b
IFE  <expr>
.lm 10

If <expr> is zero, the statements within the conditional block are
assembled.
.lm 0
.b
ELSE
.lm 10

ELSE will toggle the assembly state of the current conditional block.
If it is off, ELSE will start assembly. If it is on, ELSE will turn
off assembly.
.lm 0
.b
ENDIF
.lm 10

ENDIF terminates the conditional block started by IF, IFN or IFE.
.lm 0
.CH Macros

Macro definition allows you to invoke a block of text with parameter
substitution. The macro text is started with either the macro definition
pseudo-op or the repeat pseudo-op and ends with the ENDM pseudo-op.
Macros may be nested.

.hl 1 Macro definition

Macros are defined with the MACRO pseudo-op.
.b
.lit
<name>	MACRO	[<dummy>[,<dummy>...]]
	.
	.
	.
	ENDM

.end lit

<name> is the name of the macro and is used to invoke the macro after
it has been defined. <name> has the same limitations as any other symbol.
<dummy> is a place holder that is replaced by an actual parameter when
the macro is invoked. Dummy parameters must be seperated by commas.

.hl 1 Macro invocation

To use a macro, use the macro name as if it were a pseudo-op:
.b
.i10
<name>  [<parameter>[,<parameter>...]]
.b
Each <parameter> is substituted for the corresponding <dummy> in the
macro definition. If a parameter is enclosed by angle brackets (<>),
everything within the angle brackets will be passed as one parameter.

.hl 1 Repeat

The repeat pseudo-op specifies a block of text that is to be repeated
for the number of times specified. Repeated blocks don't have names
and don't do parameter substitution.

Repeated blocks are defined with the REPT pseudo-op.
.b
.lit
	REPT	<expr>
	.
	.
	.
	ENDM

.end lit

The text between the REPT and the ENDM is repeated <expr> times.

.hl 1 Macro termination

.hl 2 ENDM

ENDM tells the assembler to end the definition of a macro or a repeat.

.hl 2 EXITM

The EXITM pseudo-op is used inside a macro or repeat block to terminate the
expansion of the macro or repeat before the end of the macro or repeat
block has been reached. EXITM is usually used in conjunction with a
conditional pseudo-op. If an EXITM is encountered inside a nested macro,
the outer macro continues to be expanded.

.HL 1 Local symbols

The LOCAL pseudo-op is used inside a macro or repeat block to declare
certain symbols to be local to each expansion of the macro. Each time
the local symbol is defined in an expansion, it is given a unique
symbol starting with ..0000. A LOCAL statement must precede the use of
the local symbol.

EXAMPLE:
.b
.lit

FOO	MACRO	X,Y
	LOCAL	SKIP
	JMP	SKIP
X:	DB	Y
SKIP:
	ENDM


FOO DATA,<10,20,30>

will generate:


	JMP	..0000
DATA:	DB	10,20,30
..0000:

.end lit

.hl 1 Special symbols
;;
.lm 10
Comments preceded by two semicolons is not saved as part of
the macro expansion. A comment preceded by one semicolon will be included
as part of the macro expansion.
.lm 0
.b
_&
.lm 10
Ampersand concatenates text or symbols (including dummy parameters)
inside macro expansions.
.lm 0
.b
%
.lm 10
If a percent sign precedes a parameter of a macro invocation,
the expression is evaluated and the numeric string of its value is
passed to the macro expansion.
.lm 0
.lit

EXAMPLE:

FOO	MACRO	X
	DB	X
	ENDM

SYM	EQU	100Q


	FOO	SYM

will generate

	DB	SYM


	FOO	%SYM

will generate

	DB	64
.end lit
.ax Differences between MAC80 and Macro-80

This is just a quick list of some of the more obvious differences between
MAC80 and Microsoft's Macro-80.

MAC80 cannot generate Macro-80 .REL files. There are no PUBLIC, EXTERNAL,
ENTRY, COMMON, DSEG or CSEG pseudo-ops.

MAC80 checks for opcodes and pseudo-ops before macros.  Macro-80 checks
for macros before opcodes/pseudo-ops.

Macro-80 allows X'nnnn' as a hexadecimal number. MAC80 only allows nnnnH.

MAC80 doesn't have the TYPE operator and the operator precedence is slightly
different.

MAC80 does not have the DC, .RADIX, .REQUEST, .SFCOND, .LFCOND, .TFCOND,
_.CREF, .XCREF pseudo-ops.

MAC80 does not have the IRP and IRPC repeat pseudo-ops.

MAC80 does not have the IFT, COND, IFF, IF1, IF2, IFDEF, IFNDEF, IFB, IFNB,
IFIDN, IFDIF or ENDC conditional pseudo-ops.
    