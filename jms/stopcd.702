DIE::	AOSE	.CPDWD##	;INTERLOCK STOPCD CODE
	STOPCD	.,HALT,REH,	;++RECURSION IN ERROR HANDLER
	CONI	PI,.CPCPI##	;SAVE STATE OF MACHINE
	CONO	PI,PI.TFP+177	; ..
IFN FTKLP,<
	MOVEM	M,.CPSPC##+1
	MOVE	M,@(P)
	EXCH	M,.CPSPC##+1
	XSFM	.CPSPC##	;FLAGS
	JRST	@[0,,.+1]	;MUST BE IN SECTION 0
>
	JSR	.CPSVA##	;SAVE ALL AC SETS
IFE FTKLP,<
	MOVE	T1,.UPMP+.UPMUO
	MOVE	M,@(P)		;M=FLAG WORD
>
IFN FTKLP,<
	HRLZ	T1,.UPMP+.UPMUO
	IOR	T1,.UPMP+.UPMUE
	MOVE	M,.CPSPC##+1
>
	MOVEM	T1,.CPTRP##
	POP	P,T1		;GET PC OF STOPCD
	MOVEM	T1,%SYSPC##	;STORE IN TRADITIONAL WORD
	MOVEM	T1,.CPSUP##	; AND IN CDB
	MOVE	P,.CPEPD##	;SETUP PDL FOR THIS CPU
	PUSHJ	P,RCDSTB##	;READ CPU AND DEVICE STATUS BLOCKS
IFN FTKL10,<
	PUSHJ	P,CSDMP##	;MAKE SURE IT'S ALL IN CORE
	PUSHJ	P,SKPMRN##	;SKIP IF MASTER -11 IS RUNNING
	STOPCD	.,HALT,MNR,	;++MASTER -11 NOT RUNNING
	PUSHJ	P,DIE1		;PROCESS STORAGE
	JRST	RESRET		;RESTORE & RETURN
DIE1:	PUSHJ	P,SVPPC##	;SAVE PROTOCOL
>
IFN FTKS10,<
	PUSHJ	P,DISKAL##	;DISABLE KEEP ALIVE FUNCTION
>
IFN FTMP,<
DIE2:	AOSN	INTDIE##	;GET DIE INTERLOCK
	JRST	DIE3		;GOT IT, CONTINUE
	SKIPN	CRSHWD##	;RELOADING?
	JRST	DIE2		;NO, LOOP FOR INTERLOCK
	PJRST	REBOOT##	;YES
DIE3:
IFN FTKI10,<
	CONI	PAG,INODIE##	;MAKE ME THE OWNER OF THE INTERLOCK
>
IFN FTKL10,<
	APRID	INODIE##	;MAKE ME THE OWNER OF THE INTERLOCK
>
>
;THE FOLLOWING CODE IS EXPLICITLY TO MAKE IT EASIER TO AUTOMATICALLY MAP IN
;A CRASH. THE USUAL SEQUENCE WOULD BE TO USE A DDT FILE WHICH (FOR KL PAGING)
;WOULD SAY:
;	DIECDB[$Q+.CPEPT-.CPCDB[$Q'1000$U
;	DIECDB[$Q+.CPSPT$6U
;	DIECDB[$Q+.CPACA-.CPCDB[$Q$5U

	MOVE	T2,.CPSLF##	;GET PHYSICAL POINTER TO THE CDB
	MOVEM	T2,DIECDB##	;SAVE WHERE FILDDT WILL BE ABLE TO FIND IT
	PUSH	P,.CPTOA##	;SAVE ADDRESS OF TYPEOUT ROUTINE
	MOVEI	T1,CTYWAT##	;REPLACE IT WITH ONE THAT DOESN'T USE PI'S
	MOVEM	T1,.CPTOA##	;MODIFY SCNSER
	MOVEI	T2,^D10		;SEND 10 BELLS
	PUSHJ	P,BELLS		;..
	PUSHJ	P,INLMES##	;PRINT MESSAGE
	ASCIZ	/
?/
	MOVE	T2,.CPLOG##
	PUSHJ	P,PRNAME
	PUSHJ	P,INLMES##
	ASCIZ	/ monitor error. Stopcode name is /
	HRLZ	T2,M		;GET CODE
	TLNE	M,(Z 10,0)	;LONG FORM
	HRLZ	T2,0(M)		;YES, GET CODE
	HLLM	T2,%SYSPC##	;SAVE NAME
	HLLM	T2,.CPSNM##
	PUSHJ	P,PRNAME	;PRINT IT OUT
	PUSHJ	P,CRLF##	;ADD A CRLF
	MOVE	J,.CPJOB##
	MOVEI	S,PI.IPA	;GET PI ON MASK
	AND	S,.CPCPI##	;MASK OUT ALL ELSE
	SKIPN	S		;INTERRUPT LEVEL?
	PUSHJ	P,WHATJB	;NO--GIVE INFO
	TLZ	F,-1		;CLEAR LH BITS
	PUSHJ	P,CHKDDB	;MAKE SURE THAT F POINTS TO A DDB
	  JRST	NODDB		;IT DOESN'T, DON'T PRINT THE INFORMATION
	LDB	T1,PJOBN##	;GET JOB #
	CAILE	T1,JOBMAX##	;TOO BIG?
	JRST	NODDB		;YES--NOT A DDB
	JUMPE	T1,NODDB	;WANT REAL JOB #
	PUSHJ	P,INLMES##
	ASCIZ	/File /
	PUSHJ	P,PRTDDB##	;PRINT DDB STUFF
	PUSHJ	P,CRLF##	;ADD CRLF
	JUMPE	S,NODDB		;UUO LEVEL-SAID THIS
	LDB	J,PJOBN##	;GET JOB #
	PUSHJ	P,WHATJB	;PRINT IT
NODDB:	TLZN	M,(Z 10,0)	;ADDITIONAL INFORMATION
	JRST	NOTYPE		;NO, PRESS ON
	HLRZ	T1,0(M)		;TYPE OUT ROUTINE
	HRR	M,0(M)		;PUT STOPCD NAME INTO RH OF M
	JUMPE	T1,NOTYPE	;REALLY SHOULD BE ONE
	PUSHJ	P,0(T1)		;CALL IT
	PUSHJ	P,CRLF##	;TERMINATE LINE
NOTYPE: MOVSI	T1,(DF.RIP)	;IS A RELOAD IN PROGRESS?
	TDNE	T1,DEBUGF##
	JRST	NOCSB		;YES, DON'T TYPE OUT MEANINGLESS CSB
	SKIPGE	DEBUGF##	;WANT DDT?
	JRST	DIEADP		;YES
	PUSHJ	P,TYPCSB##	;TYPE CPU STATUS BLOCK INFO ON THE CTY
NOCSB:  LDB	T1,PUUOAC##	;GET ERROR TYPE
	CAIL	T1,1		;BE SURE IT'S IN RANGE
	CAILE	T1,4		;JUST SUPER CAUTIOUS
	JRST	RELOAD		;BAD. DON'T MAKE IT WORSE
	JRST	@[EXP RELOAD,ZAPJOB,BUGCHK,CPUSTP]-1(T1)
;HERE ON A DEBUG STOPCD

BUGCHK:	PUSHJ	P,STCLIM	;EXCEED STOPCD LIMIT?
	  JRST	SCLEXC		;YES
	MOVSI	T1,(DF.RDC)	;DO WE WANT TO
	TDNE	T1,DEBUGF##	; RELOAD?
	JRST	RELOAD		;YES--GO RELOAD
	AOS	%SYNDS##	;COUNT BUG
	AOS	.CPSND##
IFN FTMBTS,<
	MOVSI	T1,(DF.DDC)	;WANT TO DUMP ON
	TDNN	T1,DEBUGF##	;  THIS TYPE OF STOPCD?
	PUSHJ	P,CRSDMP	;DUMP SYSTEM AND RETURN
>
	PUSHJ	P,INLMES##	;NO--CONTINUE
	ASCIZ	/[Continuing system]
/
DIEADP:	MOVE	T3,.CPACA##	;GET ADDRESS OF SAVED AC BLOCK
	MOVE	T1,P(T3)	;GET OLD STACK POINTER
	LDB	T2,[POINT 4,M,17]	;GET RETURN TYPE
	XCT	CONTAB(T2)	;FIX UP PDP
	MOVEM	T1,P(T3)	;SAVE BACK
	JRST	DIERS0		;RESTORE STATE OF MACHINE


;HERE ON A JOB ERROR STOPCD

ZAPJOB:	PUSHJ	P,STCLIM	;STOPCD LIMIT EXCEEDED?
	  JRST	SCLEXC		;YES
	MOVSI	T1,(DF.RJE)	;IS RELOAD ON JOB ERROR
	TDNN	T1,DEBUGF##	; REQUESTED?
	SKIPE	S		; OR PI LEVEL?
	JRST	RELOAD		;YES--GO RELOAD
	SKIPE	.UPMP+.UPJOB	;CAN'T STOP THE NULL JOB
	SKIPE	.CPISF##	;IN SCHEDULER CONTEXT?
	JRST	RELOAD		;YES, CAN'T REALLY STOP A JOB
	AOS	%SYNJS##	;COUNT BUG
	AOS	.CPSNJ##
IFN FTMBTS,<
	MOVSI	T1,(DF.DJE)	;WANT TO DUMP ON
	TDNN	T1,DEBUGF##	;  THIS TYPE OF STOPCD?
	PUSHJ	P,CRSDMP	;DUMP SYSTEM AND RETURN
>
	PUSHJ	P,INLMES##	;NO--ZAP JOB
	ASCIZ	/[Aborting job]
/
	PUSHJ	P,GIVLOK##	;GIVE BACK LOCKS THIS CPU OWNS
	MOVE	T2,.CPACA##	;GET ADDRESS OF AC BLOCK
	MOVEI	T1,BUGSTP	;ADJUST SAVED STACK
	MOVE	T2,P(T2)	;SO THIS JOB GETS
	MOVEM	T1,(T2)		;KILLED
	JRST	DIERS0		;RESTORE STATE OF SYSTEM
;HERE ON A CPU STOPCD

IFN FTMP,<
CPUSTP:	PUSHJ	P,STCLIM	;STOPCD LIMIT EXCEEDED?
	  JRST	SCLEXC		;YES
	MOVSI	T2,(DF.CP1)	;BIT FORCING CPU STOPCDS TO CAUSE RELOAD
	PUSHJ	P,LSTCPU##	;LAST OR ONLY CPU RUNNING IN SYSTEM?
	TDNE	T2,DEBUGF##	;NO, WANT TO RELOAD ON CPU STOPCDS?
	JRST	RELOAD		;YES, RELOAD THE SYSTEM
	AOS	.CPSNC##	;COUNT BUG
IFN FTMBTS,<
	MOVSI	T1,(DF.DCP)	;WANT TO DUMP ON
	TDNN	T1,DEBUGF##	;  THIS TYPE OF STOPCD?
	PUSHJ	P,CRSDMP	;DUMP SYSTEM AND RETURN
>
	PUSHJ	P,INLMES##	;TELL OF OUR ACTION
	ASCIZ	/[Stopping CPU]
/
	PUSHJ	P,KILUSR	;INSURE THAT THE CURRENT JOB IS STOPPED
				;  TO AVOID A REPEAT OF THE STOPCD IF
				;  HE STARTS TO RUN ON ANOTHER CPU
	POP	P,.CPTOA##	;RESTORE SCNSER TYPOUT ADDRESS
	SETOM	.CPOK##		;INSURE THAT BECOM0 WILL BE CALLED
	DIENLK			;NO LONGER HAVE INTERLOCK
	MOVEI	T1,SR.DIE	;TELL CP1CRS THAT WE WANT THE OPERATOR
	IORM	T1,.CPSBR##	;  TO MANUALLY RESTART THIS CPU
	SKPCPU	(1)		;IF ON THE BOOT CPU, WAIT FOR SOMEONE
	JRST	.-1		;  TO ASSUME THE ROLE
	PJRST	REBOOT##	;SAVE STATE OF THE MACHINE
>
;HERE IF WE EXCEEDED ONE OF THE STOPCD-PER-UNIT-TIME LIMITS TO RELOAD
;THE SYSTEM.

SCLEXC:	PUSHJ	P,INLMES##	;TELL WHAT HAPPENED
	ASCIZ/?Stopcode limit exceeded
/


;HERE TO RELOAD THE SYSTEM

IFE FTMP,<
CPUSTP:
>
RELOAD:	HRRZM	M,CRSWHY##	;SAVE REASON FOR ONCE ATER RELOAD
	PUSHJ	P,INLMES##
	ASCIZ	/Reload monitor
/
	MOVEI	T2,^D20		;20 BELLS
	PUSHJ	P,BELLS		;..
	MOVE	P,.CPACA##	;GET ADDRESS OF AC BLOCK
	MOVE	P,P(P)		;RESTORE PDP
	POP	P,CRSHWD##	;SAVE PC
	SOS	CRSHWD##	;FOR SYSTAT/X
	PJRST	REBOOT##	;YES, RELOAD NOW


;HERE TO RESTORE THE STATE OF THE MACHINE

DIERS0:	POP	P,.CPTOA##	;RESTORE SCNSER
IFN FTKL10,<
	POPJ	P,		;RETURN ON A KL
>

RESRET:
IFN FTDAEM,<
	PUSHJ	P,DAEEST##	;TELL DAEMON OF STOPCD
>
	MOVEI	T1,177		;ALL PI BITS
	AND	T1,.CPCPI##	;TURN ON ONLY
	IORI	T1,PI.TNP	;ONES WHICH WERE ON
	MOVEM	T1,.CPCPI##	;SAVE FOR CONO
	HRLZ	17,.CPACA##	;WHERE TO RESTORE THE AC'S FROM
	BLT	17,17		;RESTORE THEM ALL
	DIENLK			;NO LONGER THE OWNER OF THE INTERLOCK
	CONO	PI,@.CPCPI##	;TURN ON PI SYSTEM
	SKIPGE	DEBUGF##	;WANT DDT?
	XCT	SYSDDT##	;YES
DIECON::SETOM	.CPDWD##	;ALLOW STOPCD'S
IFN FTKS10,<
	PUSHJ	P,ENAKAL##	;ENABLE KEEP ALIVE FUNCTION
>
	SETZM	SYSSNP##	;THIS COULD BE WHY WE GOT HERE.
IFE FTKLP,<
	POPJ	P,
>
IFN FTKLP,<
	EXCH	T1,(P)
	TLZ	T1,777740
	EXCH	T1,(P)
	POP	P,.CPSPC##+1
	XJRSTF	.CPSPC##	;RETURN TO CALLER IN PROPER SECTION
>
;HERE TO STOP AN ILL FATED USER
BUGSTP:	MOVE	J,.UPMP+.UPJOB	;JOB NUMBER
	PUSHJ	P,ZAPUSR	;GIVE UP LOCKS AND DEVICES
	JSP	T1,ERRPTU	;PRINT MESSAGE
	ASCIZ	/Monitor error/
	PJRST	UUOPCP		;PRINT SOME PC'S


;ROUTINE TO KILL THE CURRENT JOB RUNNING ON THIS CPU TO MAKE SURE
;THAT IT DOESN'T CONTINUE TO CAUSE THE SAME CRASH OVER AND OVER AGAIN.
;MUST NOT BE CALLED WITH A UUO LEVEL STACK SINCE ZAPPGM WILL GIVE
;BACK THE PAGE MAP.

KILUSR:	PUSHJ	P,GIVLOK##	;RETURN INTERLOCKS OWNED BY THIS CPU
	SKIPN	J,.CPJOB##	;ANY JOB RUNNING ON THIS CPU?
	POPJ	P,		;NO, JUST RETURN
ZAPZAP::PUSHJ	P,ZAPHER	;GIVE UP LOCKS AND DEVICES
	PUSH	P,JBTSTS##(J)	;SAVE CURRENT STATE OF JBTSTS
	MOVSI	T1,JLOG		;CLEAR JLOG TEMPORARILY SO THAT
	ANDCAM	T1,JBTSTS##(J)	;  ZAPPGM WILL GIVE BACK ALL OF THE
	ANDM	T1,0(P)		;  USER'S CORE.  I KNOW IT'S UGLY BUT...
	PUSHJ	P,ZAPPGM##	;GIVE BACK ALL OF HIS CORE
	POP	P,T1		;GET BACK STATE OF JLOG BIT
	IORM	T1,JBTSTS##(J)	;SET IT IF IT WAS SET BEFORE
	POPJ	P,		;RETURN
;SUBROUTINE TO SEND C(T2) BELLS
;CLOBBERS T1, T2, T3, T4
BELLS::	MOVEI	T3,"G"-100	;BELL
BELOOP:	PUSHJ	P,COMTYO##	;DING
	MOVEI	T1,200000
	LSH	T1,-2*FTKL10-FTKI10
	SOJG	T1,.
	SOJG	T2,BELOOP	;LOOP FOR ALL
	POPJ	P,		;RETURN


;ROUTINE TO CHECK A DDB ADDRESS BEFORE USING IT TO TYPE FILE INFORMATION
;DURING DIE PROCESSING.
;CALL:	MOVEI	F,ADDRESS
;	PUSHJ	P,CHKDDB
;	  RETURN HERE IF ADDRESS IS ILLEGAL FOR SOME REASON
;	RETURN HERE IF ADDRESS IS OK

CHKDDB:	CAMGE	F,SYSSIZ##	;LARGER THAN THE LOW SEG?
	CAIG	F,1000		;OR TOO SMALL?
	CAIA			;YES, MAY STILL BE IN FUNNY SPACE
	JRST	CPOPJ1##	;GIVE SKIP RETURN
	CAIL	F,.FPMC		;LEGAL ADDRESS IN
	CAIL	F,.FPMC+NWMCP	;  FUNNY SPACE?
	POPJ	P,		;NO, BAD DDB ADDRESS
	MAP	T1,(F)		;MAP THE ADDRESS
	PUSHJ	P,FLTCHK##	;WILL REFERENCE FAULT?
	  POPJ	P,		;YES, BAD ADDRESS
	MAP	T1,DEVSFD##(F)	;LAST ADDRESS IN DDB REFERENCED BY PRTDDB
	PJRST	FLTCHK##	;CHECK ADDRESS AND RETURN
;ROUTINE TO SEE IF THIS STOPCD HAS CAUSED US TO EXCEED ON OF THE
;STOPCDS-PER-UNIT-TIME LIMITS.
;CALL:	PUSHJ	P,STCLIM
;	  RETURN HERE IF A LIMIT HAS BEEN EXCEEDED
;	  RETURN HERE IF NOT

STCLIM:	SKIPGE	DEBUGF##	;IF DEBUGGING
	JRST	CPOPJ1##	;THEN NOSTOPCD LIMITS
	MOVSI	T1,-SCCTBL##	;BUILD AOBJN POINTER TO TABLE
STCLI1:	AOS	T2,SCCTAB##(T1)	;INCREMENT NEXT COUNT
	HRRZ	T3,SCLTAB##(T1)	;GET THE LIMIT
	CAIL	T2,(T3)		;EXCEED THE LIMIT?
	POPJ	P,		;YES
	AOBJN	T1,STCLI1	;NO,0
	LSH	T1,-2*FTKL10-FTKI10
	SOJG	T1,.
	SOJG	T2,BELOOP	;LOOP FOR ALL
	POPJ	P,		;RETURN


;ROUTINE TO CHECK A DDB ADDRESS BEFORE USING IT TO TYPE FILE INFORMATION
;DURING DIE PROCESSING.
;CALL:	MOVEI	F,ADDRESS
;	PUSHJ	P,CHKDDB
;	  RETURN HERE IF ADDRESS IS ILLEGAL FOR SOME REASON
;	RETURN HERE IF ADDRESS IS OK

CHKDDB:	CAMGE	F,SYSSIZ##	;LARGER THAN THE LOW SEG?
	CAIG	F,1000		;OR TOO SMALL?
	CAIA			;YES, MAY STILL BE IN FUNNY SPACE
	JRST	CPOPJ1##	;GIVE SKIP RETURN
	CAIL	F,.FPMC		;LEGAL ADDRESS IN
	CAIL	F,.FPMC+NWMCP	;  FUNNY SPACE?
	POPJ	P,		;NO, BAD DDB ADDRESS
	MAP	T1,(F)		;MAP THE ADDRESS
	PUSHJ	P,FLTCHK##	;WILL REFERENCE FAULT?
	  POPJ	P,		;YES, BAD ADDRESS
	MAP	T1,DEVSFD##(F)	;LAST ADDRESS IN DDB REFERENCED BY PRTDDB
	PJRST	FLTCHK##	;CHECK ADDRESS AND RETURN
;ROUTINE TO SEE IF THIS STOPCD HAS CAUSED US TO EXCEED ON OF THE
;STOPCDS-PER-UNIT-TIME LIMITS.
;CALL:	PUSHJ	P,STCLIM
;	  RETURN HERE IF A LIMIT HAS BEEN EXCEEDED
;	  RETURN HERE IF NOT

STCLIM:	SKIPGE	DEBUGF##	;IF DEBUGGING
	JRST	CPOPJ1##	;THEN NOSTOPCD LIMITS
	MOVSI	T1,-SCCTBL##	;BUILD AOBJN POINTER TO TABLE
STCLI1:	AOS	T2,SCCTAB##(T1)	;INCREMENT NEXT COUNT
	HRRZ	T3,SCLTAB##(T1)	;GET THE LIMIT
	CAIL	T2,(T3)		;EXCEED THE LIMIT?
	POPJ	P,		;YES
	AOBJN	T1,STCLI1	;NO, LOOP FOR NEXT
	HLRZ	T1,SCLTAB##+0	;GET PERIOD OF LOWEST ENTRY IN TABLE
	IMUL	T1,TICSEC##	;SETUP CLOCK REQUEST TO DECREMENT THE
	HRLI	T1,DECSCC	;  1 MINUTE STOPCD COUNT. DECSCC WILL,
	MOVEI	T2,0		;  IN TURN, PUT IN A CLOCK REQUEST TO DECREMENT
	IDPB	T1,CLOCK##	;  THE NEXT ONE, AND SO ON, UNTIL ALL
	IDPB	T2,CLOCK##	;  LEVELS OF COUNTS HAVE BEEN DECREMENTED.
	SETOM	CLKNEW##	;I REALIZE THE CLOCK QUEUE HASN'T BEEN
				;  INTERLOCKED WITH SYSPIF BUT BY THE
				;  TIME THE FIRST CHARACTER OF THE STOPCD
				;  MESSAGE HAS TYPED ON THE CTY, ALL OTHER
				;  CPU'S SHOULD HAVE SEEN INTDIE GO NON-ZERO
	JRST	CPOPJ1##	;GIVE SKIP RETURN


;ROUTINE TO DECREMENT A STOPCD COUNT AND RESUBMIT A CLOCK QUEUE REQUEST
;FOR THE NEXT HIGHER COUNT, IF ONE EXISTS.
;CALL:	MOVEI	T1,INDEX INTO SCCTAB
;	PUSHJ	P,DECSCC
;	  RETURN HERE ALWAYS


DECSCC::SOSGE	SCCTAB##(T1)	;DECREMENT COUNT
	SETZM	SCCTAB##(T1)	;LEAVE ZERO IF IT WAS ZERO
	AOS	T1		;INCREMENT LEVEL
	CAIL	T1,SCCTBL##	;DONE THE LAST LEVEL?
	POPJ	P,		;YES, RETURN NOW
	MOVE	T2,SCLTAB##(T1)	;GET WORD WITH NEW PERIOD
	SUB	T2,SCLTAB##-1(T1) ;SUBTRACT OLD PERIOD
	HLRZS	T2		;KEEP JUST DIFFERENCE IN PERIODS
	IMUL	T2,TICSEC##	;CONVERT TO TICKS
	HRLI	T2,DECSCC	;WANT TO COME BACK HERE
	SYSPIF			;INTERLOCK THE QUEUE
	IDPB	T2,CLOCK##	;STORE REQUEST
	IDPB	T1,CLOCK##	;  AND DATA
	SETOM	CLKNEW##	;FLAG A NEW REQUEST
	PJRST	ONPOPJ##	;RETURN INTERLOCK AND POPJ
;ROUTINES FOR STOPCODE MACRO TYPE OUT
;ALL ROUTINES WILL HAVE THE FORM DIE???::
;WHERE ??? ARE 3 LETTERS DESCRIPTIVE OF THE ROUTINE
;AN AUTOMATIC CARRIAGE RETURN/LINE FEED IS DONE BY CALLER

;ROUTINE TO TYPE OUT UNINAM(U) DURING STOPCD
DIEUNI::PUSHJ	P,INLMES##	;START THE OUTPUT
	ASCIZ	\Unit = \
	MOVE	T2,.CPACA##	;GET ADDRESS OF AC SET
	MOVE	T2,U(T2)	;GET "U" AT CRASH
	MOVE	T2,UNINAM##(T2)	;GET THE NAME
	PJRST	PRNAME		;PRINT OUT SIXBIT AND RETURN


; ROUTINE TO TYPE OUT STRNAM(P2) DURING A STOPCODE
DIESTR::PUSHJ	P,INLMES##	;TYPE INTRODUCTION
	ASCIZ	|Structure = |
	MOVE	T2,STRNAM##(P2)	;GET STR NAME
	PJRST	PRNAME		;TYPE IT AND RETURN


IFN FTMBTS,<
;ROUTINE TO CALL BUGDMP TO TAKE A CONTINUABLE STOPCD DUMP
;AND THEN SET DF.RQC IN DEBUGF WHICH WILL CAUSE CRSCPY
;TO BE CALLED BY THE BOOT CPU AT THE NEXT TICK.  WE
;CAN'T CALL CRSCPY DIRECTLY BECAUSE THE SCNSER INTERLOCK
;MAY NOT BE FREE.
;ENTER AT FRCCPY TO JUST SET DF.RQC (FROM ADDSDL)
;CALL:	PUSHJ	P,CRSDMP
;	RETURN HERE ALWAYS

CRSDMP:	PUSH	P,JOBSYM##	;KEEP DAEMON FROM THINKING THIS IS A
	SETZM	JOBSYM##	;^^RELOAD BY ZEROING THE FLAG THAT IT LOOKS AT
	PUSH	P,MBTCOM##	;DO THE SAME FOR THE SYSTEM
	SETZM	MBTCOM##	; SLEEP COMMUNICATION WORD
	PUSHJ	P,BUGDMP##	;TAKE DUMP
	  JFCL			;IGNORE ERROR RETURN
	POP	P,MBTCOM##	;RESTORE SYSTEM SLEEP COMMUNICATION WORD
	POP	P,JOBSYM##	;RESTORE SYMBOL TABLE POINTER
FRCCPY::MOVSI	T1,(DF.RQC)	;IF THE CRSCPY REQUEST HAS NOT BEEN
	MOVSI	T2,(DF.DCC)	; DISABLED VIA THE /NOCOPY STARTUP
	TDNN	T2,DEBUGF##	; SWITCH, SET DF.RQC IN DEBUGF WHICH
	IORM	T1,DEBUGF##	; WILL CAUSE CRSCPY TO BE CALLED ON
	ANDCAM	T2,DEBUGF##	; THE NEXT CLOCK TICK
	POPJ	P,		;RETURN


;ROUTINE TO START UP THE CRASH COPY PROGRAM TO COPY
;A DUMP.
;CALL:	PUSHJ	P,CRSCPY
;	RETURN HERE ALWAYS

CRSCPY::SKIPGE	DEBUGF##	;DON'T DO ANYTHING
	POPJ	P,		; IF DEBUGGING
	PUSHJ	P,FRCSET##	;SETUP TO STORE CHARACTERS IN FRCLIN
	MOVE	T2,CCPNAM##	;GET NAME OF PROGRAM TO RUN
	PUSHJ	P,PRNAME	;STORE NAME
	PJRST	CRLF##		;ADD CRLF AND RETURN
>;END IFN FTMBTS

;CONTINUE TABLE. T1 IS STACK POINTER FOR PROCESS WHICH DID STOPCD.
;CALLED BY XCT CONTAB(CONT)
CONTAB:	JFCL			;(0) .
	JFCL			;(1) .+1
	POP	T1,(T1)		;(2) CPOPJ
	PUSHJ	P,[POP T1,(T1)
		   AOS (T1)
		   POPJ P,]	;(3) CPOPJ1
	JFCL			;(4)
	JFCL			;(5)
	JFCL			;(6)
	JFCL			;(7)
	JFCL			;(10)
	JFCL			;(11)
	JFCL			;(12)
	JFCL			;(13)
	JFCL			;(14)
	JFCL			;(15)
	JFCL			;(16)
	AOS	(T1)		;(17) SPECIAL RETURN
WHATJB:	JUMPLE	J,CPOPJ##	;GET JOB NUMBER
	CAILE	J,JOBMAX##	;RANGE CHECK IT.
	POPJ	P,		;IGNORE IF FUNNY.
	PUSHJ	P,INLMES##	;GIVE THE JOB NUMBER
	ASCIZ	/Job /	; ..
	MOVE	T1,J		; ..
	MOVEM	T1,%SYSJN##
	MOVEM	T1,.CPSJN##
	PUSHJ	P,RADX10	;IN DECIMAL
	PUSHJ	P,INLMES##	;PRINT OUT THE
	ASCIZ	/ on /		; TTY NAME
	MOVE	T2,@TTYTAB##(J)	;GET TTY NAME
	MOVEM	T2,%SYSTN##
	MOVEM	T2,.CPSTN##
	PUSHJ	P,PRNAME	; AND PRINT IT.
	PUSHJ	P,INLMES##	;PRINT OUT
	ASCIZ	/ running /	; THE CUSP NAME
	MOVE	T2,JBTPRG##(J)	; SO OPERATOR
	MOVEM	T2,%SYSPN##
	MOVEM	T2,.CPSPN##
	PUSHJ	P,PRNAME	; CAN FIND HIS JOBS
	PUSHJ	P,INLMES##
	ASCIZ/ User /
	MOVE	T2,JBTPPN##(J)	;GET USER'S PPN
	MOVEM	T2,%SYSPP##	;AND SAVE FOR DAEMON
	MOVEM	T2,.CPSPP##
	PUSHJ	P,PRTPPN##	;PRINT PPN
	JUMPN	S,CRLF##
	PUSHJ	P,INLMES##	;NEW LINE
	ASCIZ	/
UUO is /
	MOVE	T1,.CPTRP##	;PICK UP UUO
	MOVEM	T1,%SYSUU##
	MOVEM	T1,.CPSUU##
	PUSHJ	P,PRTDI8	;PRINT IN OCTAL
	GETPC	T2,.JDAT+JOBPD1## ;GET PC FROM PUSH DOWN LIST
	MOVEM	T2,%SYSUP##
	MOVEM	T2,.CPSUP##
	PUSHJ	P,PCP		;LIST THE LOCATION
	PJRST	CRLF##		;RETURN ON A NEW LINE

  