	TITLE LINK80 - linking loader for MAC80 .HEX files
	; Bruce Tanner - Cerritos College 12/16/83

L80VER=1	;VERSION INFO
L80MIN=0
L80EDT=2
L80WHO=0
	LOC 137
	BYTE(3)L80WHO(9)L80VER(6)L80MIN(18)L80EDT
	RELOC



T1=1
T2=2
T3=3
T4=4
I=5
O=6
PC=7	;BYTE OF MODULE
CNT=10
CHK=11
PTR=12
BASE=13	;LOC OF START OF MODULE
MEM=14	;LOC OF START OF FREE MEMORY
S=15
SYMB=16
P=17

SYMSIZ==^D500	;SPACE FOR 250 INSTANCES OF A GLOBAL SYMBOL
FFFF==177777

COM==1
HEX==2

S.INT==1
S.EXT==2

START:	RESET
	MOVE	P,[IOWD 20,STACK]
	RESCAN			;RESCAN THE COMMAND LINE FOR "LINK80 FOO"
	SETZ	T1,
ANOTHR:	SETZM	HEXFIL
	MOVE	T2,[POINT 6,HEXFIL]
	PUSHJ	P,GETSIX	;GET 1ST ARG
	MOVE	T3,HEXFIL
	JUMPE	T3,ASK		;NO ARG, ASK FOR NAME
	CAME	T3,[SIXBIT/R/]
	CAMN	T3,[SIXBIT/RUN/]
	JRST	ANOTHR		;IGNORE R AND RUN
	CAMN	T3,[SIXBIT/LINK80/]
	JRST	ANOTHR		;IGNORE HEXIFY
	JRST	RDNAME

ASK:	SETZ	T1,
	OUTSTR	[ASCIZ/File name: /]
	PUSHJ	P,GETSIX
RDNAME:	CAIN	T1,"."		;EXT?
	JRST	RDEXT
	JRST	OPNFIL

RDEXT:	MOVE	T2,[POINT 6,HEXFIL+1]
	PUSHJ	P,GETSIX
	JRST	OPNFIL

GETSIX:	CAIN	T1,12		;LAST FIELD ENDED WITH CR?
	POPJ	P,
	INCHWL	T1
	CAIN	T1,15
	INCHWL	T1
	CAIE	T1,"."		;EXIT IF CR OR PERIOD
	CAIN	T1,12
	POPJ	P,
	CAIE	T1,40
	CAIN	T1,11
	SKIPA
	JRST	GETSX1
	SKIPN	HEXFIL		;LEADING SPACE?
	JRST	GETSIX		;YES, IGNORE
	POPJ	P,		;NO, EXIT

GETSX1:	CAIL	T1,140
	SUBI	T1,40		;LC TO UC
	SUBI	T1,40		;ASCII TO SIXBIT
	JUMPLE	T1,CPOPJ	;CONTROL CHAR
	TLNE	T2,770000	;IF SPACE LEFT
	IDPB	T1,T2		;STICK IT
	JRST	GETSIX

OPNFIL: CLRBFI
	MOVE	T1,HEXFIL	;OUTPUT FILE IS SAME AS INPUT FILE
	MOVEM	T1,COMFIL
	MOVSI	T1,'COM'	;BUT WITH A .COM EXT
	MOVEM	T1,COMFIL+1
	MOVSI	T1,'HEX'
	SKIPN	HEXFIL+1	;.HEX BY DEFAULT
	MOVEM	T1,HEXFIL+1
	OPEN	HEX,HEXSPC	;OPEN THE FILES
	 HALT
	OPEN	COM,COMSPC
	 HALT
	LOOKUP	HEX,HEXFIL
	 JRST	NOFILE
	ENTER	COM,COMFIL
	 JRST	BADFIL
	MOVSI	T1,(POINT 8,0)	;.COM FILE IS 8 BIT BYTES
	MOVEM	T1,OBUF+1
	INPUT	HEX,		;MAKE INPUT BUFFERS
	OUTPUT	COM,		;MAKE OUTPUT BUFFERS
	MOVE	MEM,.JBFF##	;GET FIRST FREE
	SETO	BASE,		;INIT BASE (ABS START OF MODULE) WILL BE 0 OR 400
	SUBI	MEM,400		;MAKE MEM POINT TO 1ST WORD OF .COM FILE
INITPC:	CAIN	BASE,400	;IF BASE = 400 (REL)
	SETZ	PC,		;START AT PC 0
	SKIPN	BASE		;IF BASE = 0 (ABS)
	MOVEI	PC,400		;PC = 100H
LOOP:	PUSHJ	P,INCH		;READ SOME BYTES
	 JRST	WRTCOM		;EOF, WRITE COM FILE
	CAIE	I,":"
	CAIN	I,"$"		;SEARCH FOR RECORD HEADER
	 CAIA
	  JRST	LOOP
	SETZ	CHK,		;RESET CHECKSUM
	PUSHJ	P,READ6		;READ 6 CHAR FROM HEX FILE & PUT IN SYMB
				;PUT 1ST 2 HEX DIGITS IN CNT, NEXT 4 IN T4
	PUSHJ	P,HEXBYT	;GET RECORD TYPE
	JUMPE	CNT,DOEOF	;ZERO SIZE IS EOF
	JUMPE	T1,DOCODE	;TYPE 0 (CODE)?
	CAIN	T1,1		;TYPE 1 (EOF)
	JRST	DOEOF
	CAIN	T1,2		;TYPE 2	(INT)
	JRST	DOINT
	CAIN	T1,3		;TYPE 3 (EXT)
	JRST	DOEXT
	CAIN	T1,4 		;TYPE 4 (RELOC)
	JRST	DOREL
	OUTSTR	[ASCIZ/?Illegal record type at PC /]
	PUSHJ	P,PRNTPC
	EXIT

READ6:	MOVE	T1,[POINT 6,SYMB]
READ7:	TLNN	T1,770000	;ALL 6?
	JRST	READ8		;YES
	PUSHJ	P,INCH		;GET A CHAR
	 JRST	EOF
	SUBI	I,40		;TO 6BIT
	IDPB	I,T1		;STORE IT
	JRST	READ7

READ8:	MOVE	T1,[POINT 6,SYMB]
	ILDB	T2,T1
	PUSHJ	P,NYBLI		;NYBBLIZE T2
	MOVE	T4,T2
	LSH	T4,4		;SHIFT TO HIGH NYBBLE
	ILDB	T2,T1
	PUSHJ	P,NYBLI
	OR	T4,T2
	ADD	CHK,T4		;UPDATE CHECKSUM
	MOVEM	T4,CNT		;NEW COUNT

	ILDB	T2,T1
	PUSHJ	P,NYBLI
	MOVE	T4,T2
	ILDB	T2,T1
	PUSHJ	P,NYBLI
	LSH	T4,4
	OR	T4,T2
	ADD	CHK,T4		;UPDATE CHK

	ILDB	T2,T1
	PUSHJ	P,NYBLI
	MOVE	T3,T2
	ILDB	T2,T1
	PUSHJ	P,NYBLI
	LSH	T3,4
	OR	T3,T2
	ADD	CHK,T3		;UPDATE CHK

	LSH	T4,10
	OR	T4,T3
	POPJ	P,

NYBLI:	SUBI	T2,'0'		;TO BINARY
	CAIL	T2,^D10		;SKIP IF NUMERIC
	SUBI	T2,"A"-"9"-1	;ELSE MAKE 10 THRU 15
	POPJ	P,

DOCODE:	SKIPGE	BASE		;1ST DATA BYTE?
	PUSHJ	P,INIBSE       	;YES, INIT BASE & PC
	CAMLE	PC,T4		;OVERLAP PC?
	JRST	OVRLAP		;YES
	CAME	PC,T4		;AT RIGHT PC?
	MOVE	PC,T4		;NO, POINT TO RIGHT SPOT
	JRST	DODATA		;YES

INIBSE:	JUMPE	T4,RELHEX	;JUMP IF REL HEX FILE
	OUTSTR	[ASCIZ/[Absolute Hex file]
/]
	SETZM	BASE		;BASE OF ABSOLUTE FILE IS ZERO
	MOVEI	PC,400		;PC START AT 100H
	POPJ	P,

RELHEX:	MOVEI	BASE,400	;REL FILE, BASE = 100H
	SETZ	PC,		;PC = 0
	POPJ	P,

DOEOF:	JUMPE	T4,.+3		;START ADDRESS IS 0?
	CAIE	T4,FFFF		;START ADDRESS IS FFFF?
	OUTSTR	[ASCIZ/[Start address not used]
/]
	SKIPLE	BASE		;IF RELOCATING
	ADD	BASE,PC		;RESET BASE ADDRESS
	JRST	INITPC		;RESET PC & LOOP


DODATA:	PUSHJ	P,HEXBYT	;GET A BYTE
	PUSHJ	P,PUTBYT	;STORE (T1) IN MEMORY
	CAMLE	PC,HIGHPC	;HIGHEST PC?
	MOVEM	PC,HIGHPC	;YES, SAVE IT
	AOJ	PC,
	SOJG	CNT,DODATA	;LOOP
	PUSHJ	P,HEXBYT	;READ CHECKSUM
	ANDI	CHK,377		;MASK 8 BITS
	JUMPE	CHK,LOOP	;CHECKSUM CORRECT, DO ANOTHER RECORD
	OUTSTR	[ASCIZ/?Bad checksum at PC /]
	PUSHJ	P,PRNTPC
	EXIT

PUTBYT:	MOVE	T2,MEM		;GET FIRST FREE
	ADD	T2,BASE		;GET BASE OF MODULE
	ADD	T2,PC		;GET ABS BYTE OF MODULE
	CAMLE	T2,.JBREL##	;LEGAL ADDRESS?
	 JRST	[PUSH	P,T2
		CORE	T2,	;GET MORE CORE
		 HALT
		POP	P,T2
		JRST	.+1]
	MOVEM	T1,(T2)		;STORE BYTE
	POPJ	P,

DOREL:	PUSHJ	P,HEXBYT	;GET HIGH BYTE
	MOVE	T4,T1
	LSH	T4,10
	PUSHJ	P,HEXBYT	;GET LOW BYTE
	OR	T4,T1		;ADDR IN T4
	SOJ	CNT,		;COUNT DOWN ONE OF THE BYTES
	ADD	T4,BASE		;MAKE ABS ADDR
	ADD	T4,MEM		;IN OUR MEM
	MOVE	T1,(T4)		;GET LOW BYTE
	MOVE	T2,1(T4)	;GET HIGH BYTE
	LSH	T2,10		;SHIFT HIGH BYTE
	OR	T1,T2		;FULL ADDR IN T1
	CAIE	T1,FFFF		;IF NOT FFFF
	ADD	T1,BASE		;RELOCATE ADDR
	MOVE	T2,T1		;SAVE IN T2
	ANDI	T1,377		;MASK OFF LOW BYTE
	MOVEM	T1,(T4)		;PUT BACK
	LSH	T2,-10		;GET HIGH BYTE
	MOVEM	T2,1(T4)	;PUT BACK
	SOJG	CNT,DOREL	;LOOP
	PUSHJ	P,HEXBYT	;READ CHECKSUM
	ANDI	CHK,377		;MASK 8 BITS
	JUMPE	CHK,LOOP	;CHECKSUM CORRECT, DO ANOTHER RECORD
	OUTSTR	[ASCIZ/?Bad checksum at PC /]
	PUSHJ	P,PRNTPC
	EXIT

WRTCOM:	PUSHJ	P,FIXUP		;RESOLVE THE EXTERNAL REFERENCES
	MOVEI	T1,400(MEM)	;GET START ADDRESS
	MOVE	T2,MEM		;GET END ADDRESS
	ADD	T2,BASE
	SKIPN	BASE		;IF BASE = 0
	ADD	T2,HIGHPC	;ADD HIGH PC
WRTLOP:	MOVE	O,(T1)		;GET BYTE
	PUSHJ	P,OUCH
	CAME	T1,T2
	AOJA	T1,WRTLOP	;INC & LOOP
	RELEAS	HEX,
	RELEAS	COM,
	EXIT

DOINT:	PUSHJ	P,HEXBYT	;GET HIGH BYTE
	MOVE	T4,T1
	LSH	T4,10
	PUSHJ	P,HEXBYT	;GET LOW BYTE
	OR	T4,T1		;ADDR IN T4
	CAMN	SYMB,[SIXBIT/$MODUL/]	;END OF MODULE SYMBOL?
	JRST	[MOVE	PC,T4	;RESET PC TO END OF MODULE
		JRST	DOINTX]	;FINISHED
	ADD	T4,BASE		;RELOCATE ADDRESS TO ABS
	PUSHJ	P,SRCHIN	;SEARCH SYMBOL TABLE FOR INTERN DEF OF SYMB
	 JRST	DOINT1 		;NOT FOUND
	OUTSTR	[ASCIZ/?Multiply defined symbol /]
	PUSHJ	P,PRTSYM	;PRINT SYMB
	OUTSTR	[ASCIZ/
/]
	JRST	DOINTX

DOINT1:	OR	T4,[S.INT,,0]	;FLAG AS INTERNAL SYMBOL
	MOVEM	T4,SYMTAB+1(S)		;SAVE FLAG,ADDR
	MOVEM	SYMB,SYMTAB(S)		;SAVE SYMBOL
DOINTX:	PUSHJ	P,HEXBYT	;READ CHECKSUM
	ANDI	CHK,377		;MASK 8 BITS
	JUMPE	CHK,LOOP	;CHECKSUM CORRECT, DO ANOTHER RECORD
	OUTSTR	[ASCIZ/?Bad checksum at symbol /]
	PUSHJ	P,PRTSYM
	EXIT

PRTSYM:	MOVE	T1,[POINT 6,SYMB]
	TLNN	T1,770000
CPOPJ:	POPJ	P,
	ILDB	T2,T1
	JUMPE	T2,CPOPJ
	ADDI	T2,40
	OUTCHR	T2
	JRST	PRTSYM+1

DOEXT:	PUSHJ	P,HEXBYT	;GET HIGH BYTE
	MOVE	T4,T1
	LSH	T4,10
	PUSHJ	P,HEXBYT	;GET LOW BYTE
	OR	T4,T1		;ADDR IN T4
	CAIN	T4,FFFF		;IF FFFF (DECLARED EXTERN, BUT NOT REFERENCED)
	JRST	DOINTX		;DON'T BOTHER, NOT USED
	ADD	T4,BASE		;RELOCATE ADDRESS TO ABS
	PUSHJ	P,SRCHEX	;SEARCH SYMBOL TABLE FOR EXTERN DEF OF SYMB
	 JRST	DOEXT1 		;NOT FOUND
	AOBJN	S,.+1
	AOBJN	S,.+1		;TRY AGAIN
	PUSHJ	P,SRCHE0
	 JRST	DOEXT1
	JRST	.-4

DOEXT1:	OR	T4,[S.EXT,,0]
	MOVEM	T4,SYMTAB+1(S)		;SAVE VALUE
	MOVEM	SYMB,SYMTAB(S)       	;SAVE SYMBOL
	JRST	DOINTX		;DO CHECKSUM & EXIT

FIXUP:	MOVE	SYMB,[SIXBIT/$MEMRY/]
	PUSHJ	P,SRCHIN	;SEARCH SYMBOL TABLE FOR INTERN DEF OF SYMB
	 JRST	FIX0		;NONE THERE, PUNT
	HRRZ	T4,SYMTAB+1(S)	;GET ADDRESS OF $MEMRY
	ADD	T4,MEM		;IN OUR MEM
	MOVE	T1,BASE		;GET THE NEW BASE
	ANDI	T1,377		;MASK OFF LOW BYTE
	MOVEM	T1,(T4)		;SAVE LOW BYTE OF ADDRESS
	HRRZ	T1,SYMTAB+1(S)	;GET ADDRESS AGAIN
	LSH	T1,-10		;GET HIGH BYTE
	MOVEM	T1,1(T4)	;SAVE HIGH BYTE OF ADDRESS
FIX0:	MOVSI	S,-SYMSIZ	;SET UP POINTER
FIX1:	PUSHJ	P,FINDIN	;FIND AN INTERN SYMBOL
	 JRST	CHKEXT		;NO INTERNALS LEFT, CHECK FOR UNDEFINED SYMBOLS
	MOVE	T4,S		;SAVE S
FIX1A:	PUSHJ	P,SRCHEX	;FIND AN EXTERN TO MATCH
	 JRST	FIX3		;NO MORE
	HRRZ	T2,SYMTAB+1(S)	;GET LAST ADDRESS OF REFERENCE
FIX2:	CAIN	T2,FFFF		;END OF CHAIN?
	JRST	FIX4		;YES
	ADD	T2,MEM		;IN OUR MEMORY
	MOVE	T1,1(T2)	;GET HIGH BYTE
	LSH	T1,10		;SHIFT UP
	OR	T1,(T2)		;OR IN LOW BYTE GIVING NEXT ADDRESS OF REFERENCE
	HRRZ	T3,SYMTAB+1(T4)	;GET VALUE OF SYMBOL
	ANDI	T3,377		;MAKE LOW BYTE
	MOVEM	T3,(T2)		;PUT IT IN PROGRAM
	HRRZ	T3,SYMTAB+1(T4)	;GET VALUE OF SYMBOL
	LSH	T3,-10		;MAKE HIGH BYTE
	MOVEM	T3,1(T2)       	;PUT IT IN PROGRAM
	MOVE	T2,T1		;SAVE NEXT ADDRESS IN T2
	JRST	FIX2

FIX3:	MOVE	S,T4
	AOBJN	S,.+1		;LOOK FOR ANOTHER INTERNAL SYMBOL
	AOBJN	S,FIX1
	JRST	OVERR

FIX4:	SETZM	SYMTAB+1(S)	;SAY WE'RE DONE WITH THIS ONE
	AOBJN	S,.+1
	AOBJN	S,FIX1A		;LOOK FOR ANOTHER OCCURANCE OF THE EXTERNAL
	JRST	OVERR


CHKEXT:	MOVSI	S,-SYMTAB
	SKIPN	SYMTAB(S)
	 POPJ	P,		;ALL DONE
	MOVE	T1,SYMTAB+1(S)	;GET FLAGS
	TLNE	T1,S.EXT	;EXTERNAL?
	PUSHJ	P,CHKEX1       	;YES, UNDEFINED
	AOBJN	S,.+1
	AOBJN	S,CHKEXT+1
OVERR:	OUTSTR	[ASCIZ/?Symbol table overflow
/]
	EXIT

CHKEX1:	MOVE	SYMB,SYMTAB(S)	;GET SYMBOL
	OUTSTR	[ASCIZ/?Undefined global symbol /]
	PUSHJ	P,PRTSYM
	OUTSTR	[ASCIZ/
/]
	POPJ	P,

FINDIN:	SKIPN	SYMTAB(S)
	 POPJ	P,
	MOVE	T1,SYMTAB+1(S)	;GET FLAGS
	TLNN	T1,S.INT
	JRST	FINDI2
	MOVE	SYMB,SYMTAB(S)	;GET SYMBOL
	AOS	(P)
	POPJ	P,

FINDI2:	AOBJN	S,.+1
	AOBJN	S,FINDIN
	JRST	OVERR

SRCHIN:	MOVSI	S,-SYMSIZ
SRCHI0:	SKIPN	SYMTAB(S)		;EMPTY?
	POPJ	P,		;YES, NOT THERE
	CAMN	SYMB,SYMTAB(S)	;FOUND IT?
	JRST	SRCHI3		;MAYBE
SRCHI2:	AOBJN	S,.+1
	AOBJN	S,SRCHI0	;TRY AGAIN
	OUTSTR	[ASCIZ/?Symbol table overflow at symbol /]
	PUSHJ	P,PRTSYM
	EXIT

SRCHI3:	MOVE	T1,SYMTAB+1(S)		;GET FLAGS
	TLNN	T1,S.INT	;INTERN?
	JRST	SRCHI2		;NO, LOOP
	JRST	CPOPJ1		;YES, SKIP RETURN


SRCHEX:	MOVSI	S,-SYMSIZ
SRCHE0:	SKIPN	SYMTAB(S)		;EMPTY?
	POPJ	P,		;YES, NOT THERE
	CAMN	SYMB,SYMTAB(S)	;FOUND IT?
	JRST	SRCHE3		;MAYBE
SRCHE2:	AOBJN	S,.+1
	AOBJN	S,SRCHE0	;TRY AGAIN
	OUTSTR	[ASCIZ/?Symbol table overflow at symbol /]
	PUSHJ	P,PRTSYM
	EXIT

SRCHE3:	MOVE	T1,SYMTAB+1(S) 	;GET FLAGS
	TLNN	T1,S.EXT	;EXTERN?
	JRST	SRCHE2		;NO, LOOP
CPOPJ1:	AOS	(P)
	POPJ	P,

OVRLAP:	OUTSTR	[ASCIZ/?Code overlap
/]
	EXIT

EOF:	OUTSTR	[ASCIZ/?Encountered EOF inside a record
/]
	EXIT

HEXBYT:	PUSHJ	P,NYBBLE
	MOVE	T1,I
	LSH	T1,4		;SHIFT TO HIGH NYBBLE
	PUSHJ	P,NYBBLE
	OR	T1,I
	ADD	CHK,T1		;UPDATE CHECKSUM
	POPJ	P,

NYBBLE:	PUSHJ	P,INCH		;GET HEX DIGIT
	 JRST	EOF		;SHOULD ONLY GET EOF OUTSIDE OF RECORD
	SUBI	I,"0"		;TO BINARY
	CAIL	I,^D10		;SKIP IF NUMERIC
	SUBI	I,"A"-"9"-1	;ELSE MAKE 10 THRU 15
	POPJ	P,

PRNTPC:	MOVE	T1,PC
	LSH	T1,-10
	PUSHJ	P,DOBYTE
	MOVE	T1,PC
DOBYTE: PUSH	P,T1
	ADD	CHK,T1		;UPDATE CHECKSUM
	LSH	T1,-4		;HIGH NYBBLE
	PUSHJ	P,DONYBB
	POP	P,T1
DONYBB: ANDI	T1,17		;JUST 4 BITS
	MOVE	O,T1
	CAIL	O,^D10		;IF NUMERIC
	JRST	.+3
	ADDI	O,"0"		;JUST MAKE ASCII
	JRST	.+2		;AND OUTPUT
	ADDI	O,"A"-^D10	;ELSE MAKE A THRU F
	OUTCHR	O		;TYPE IT
	POPJ	P,

OUCH:	SOSGE	OBUF+2		;OUTPUT A CHAR IN O
	JRST	OUCH1
	IDPB	O,OBUF+1
	POPJ	P,

OUCH1:	OUTPUT	COM,
	JRST	OUCH


INCH:	SOSGE	IBUF+2		;INPUT A CHAR IN I
	JRST	INCH1
	ILDB	I,IBUF+1
	AOS	(P)
	POPJ	P,

INCH1:	IN	HEX,
	JRST	INCH
	POPJ	P,

NOFILE: OUTSTR	[ASCIZ/?File not found
/]
	EXIT

BADFIL: OUTSTR	[ASCIZ/?Enter error
/]
	EXIT


HEXSPC: 0
	SIXBIT	/DSK/
	IBUF

COMSPC: 14
	SIXBIT	/DSK/
	OBUF,,0

COMFIL: 0
	0
	0
	0

HEXFIL: EXP 0,0,0,0
HIGHPC:	0
IBUF:	BLOCK	3
OBUF:	BLOCK	3
BUFFER: BLOCK	50
STACK:	BLOCK	20
SYMTAB:	BLOCK	SYMSIZ

	END	START
  