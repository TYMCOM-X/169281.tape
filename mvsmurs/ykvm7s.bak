PROCEDURE NEW.UPDATER
BEGIN
%****************************************

Modified 09-11-84 by Dan Baigent.

Features added:
Will time-out after 300 seconds (5 min) at
   the ">" or "*" prompts and after 60 seconds
   at any other prompt. (see PAUSE.FOR.INPUT
   statements)

Features removed:
Will no longer use the BUSY. except to lock out
   users during MUR store.

****************************************%

FIELDS

ANSWER  AS "C",
C.CLASS.ID               SAME AS CLASS.ID,
C.CODE.ID                SAME AS CODE.ID,
C.FT.FLAG                SAME AS FT.FLAG,
C.HW.ID                  SAME AS HW.ID,
C.PRIME.START            SAME AS PRIME.START,
C.PRIME.STOP             SAME AS PRIME.STOP,
C.SITE.ID                SAME AS SITE.ID,
CC.HW.ID                 SAME AS HW.ID,
CHG.COD                       AS "C",
CHG.FT                        AS "C",
CHG.HW                        AS "C",
CHG.PF                        AS "C",
CHG.SF                        AS "C",
CHG.SIT                       AS "C",
CLASS.INPUT              SAME AS ABBREV,
CODE.INPUT                    AS "3Z",
CODE.TYPE                SAME AS ABBREV,
CONSOLIDATED.STOP.TIME   SAME AS STOP.TIME,
CONSOLIDATE.SWITCH            AS "C",
CURRENT.DATE             SAME AS DATE.,
DATE.INPUT               SAME AS DATE.,
DEL.SYSNO                SAME AS SYSNO,
ENDING.DATE              SAME AS DATE.,
ELAPSED.TIME                  AS "4Z",
FLAG                          AS "Z",
GAP.FLAG                      AS "N",
HARDWARE.ID.INPUT        SAME AS HW.ID,
HIGH.TIME                SAME AS START.TIME,
HW.ID.FLAG                    AS "N",
INPUT.COMMAND                 AS "24C",
INPUT.ENDING.DATE        SAME AS DATE.,
INPUT.STARTING.DATE      SAME AS DATE.,
L.START.TIME             SAME AS START.TIME,
MESSAGE.FLAG		      AS 'C',
NEW.CODE                 SAME AS CODE,
NEW.CODE.ID              SAME AS CODE.ID,
NEW.FT                   SAME AS FT.FLAG,
NEW.FT.FLAG                   AS "C",
NEW.HW.ID                SAME AS HW.ID,
NEW.PF                   SAME AS PRIME.FLAG,
NEW.PRIME.FLAG                AS "C",
NEW.SCHED.DN             SAME AS SCHED.DN,
NEW.SCHED.FLAG                AS "C",
NEW.SCHED.UP             SAME AS SCHED.UP,
NEW.SF                   SAME AS SCHED.FLAG,
NEW.SITE                 SAME AS ABBREV,
NEW.SITE.ID              SAME AS SITE.ID,
NEW.STOP.TIME            SAME AS STOP.TIME,
NORMAL.SCHEDULE               AS "C",
OLD.CODE.ID              SAME AS CODE.ID,
OLD.FT.FLAG              SAME AS FT.FLAG,
OLD.HW.ID                SAME AS HW.ID,
OLD.SITE.ID              SAME AS SITE.ID,
OLD.SCHED.FLAG           SAME AS SCHED.FLAG,
OLD.START.TIME           SAME AS START.TIME,
OLD.STOP.TIME            SAME AS STOP.TIME,
OLD.SYSTEM.ID            SAME AS SYSTEM.ID,
OLD.PRIME.FLAG           SAME AS PRIME.FLAG,
OVER.FLAG                     AS "N",
OVERLAP.FOUND                 AS "C",
PREVIOUS.DATE            SAME AS DATE.,
PREVIOUS.STOP.TIME       SAME AS STOP.TIME,
PREVIOUS.SYSTEM.ID       SAME AS SYSTEM.ID,
RECORD.START             SAME AS START.TIME,
RECORD.STOP              SAME AS STOP.TIME,
SITE.INPUT               SAME AS ABBREV,
STARTING.DATE            SAME AS DATE.,
SYS.CLASS.ID             SAME AS CLASS.ID,
SYS.END.DATE             SAME AS END.DATE,
SYS.START.DATE           SAME AS START.DATE,
SYSNO.INPUT              SAME AS SYSNO,
ZERO.STOP                SAME AS STOP.TIME

CONTROLS FOR RELATIONS CONCURRENT UPDATE

RELATION L.TIME. SAME AS TIME.
RELATION DELETED.RECORDS. SAME AS TIME.
RELATION ADD.TIME. IS KEY DATE.INPUT,SYSTEM.ID
RELATION L.NORMAL.SCHEDULE. SAME AS NORMAL.SCHEDULE.
RELATION CHANGE.SCHEDULE. IS KEY SYSTEM.ID
RELATION SPECIAL.SCHEDULE. SAME AS NORMAL.SCHEDULE.
RELATION CHANGE.SYSTEM. IS
 KEY  SYSTEM.ID
 DATA HW.ID
RELATION HARDWARE.ID. IS
KEY     CLASS.ID,
        HW.ID


%CHECK TO SEE IF BUSY. HAS A 0 IN IT (MEANING THE MUR STORE IS BEING DONE)%

SELECT BUSY. VIA BUSY=0 THEN BEGIN
   TYPE @CR,"MUR IS UNDER GOING ITS DAILY BACKUP.  PLEASE TRY AGAIN LATER.",@CR
   ABORT
   END
ELSE NOTHING

%**********************************************

PLACE USERNAME AND TIME THAT UPDATE PROCEDURE
BEGAN INTO UPDATE.RECORD. RELATION

***********************************************%
LET UPDATE.DATE = TODAY
LET UPDATE.TIME = TIME
INSERT INTO UPDATE.RECORD.

LET MESSAGE.FLAG = 'N'

ENTIRE.PROCEDURE:
BEGIN
CLEAR TERMINAL INPUT
TYPE @CR,"> "
PAUSE.FOR.INPUT 300 THEN ACCEPT FROM TERMINAL INPUT.COMMAND
   ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF INPUT.COMMAND='QUIT' OR 'QUI' OR 'QU' OR 'Q' OR 'EXIT' OR 'EXI' OR 'EX'
     THEN FINISH ENTIRE.PROCEDURE

IF INPUT.COMMAND='HELP' OR 'HEL' OR 'HE' OR 'H' THEN
   BEGIN
   TYPE @CR,"VALID COMMANDS:",@CR,@CR
   TYPE "ADD            ENTER MACHINE USAGE INTO DATA BASE",@CR
   TYPE "CHG COD        CHANGE CODE FOR A RECORD OR RECORDS",@CR
   TYPE "CHG SIT        CHANGE SITE FOR A RECORD OR RECORDS",@CR
   TYPE "CHG FT         CHANGE FIELD TEST FLAG...",@CR
   TYPE "CHG HW         CHANGE HARDWARE ID...",@CR
   TYPE "CHG PF         CHANGE PRIME TIME FLAG...",@CR
   TYPE "CHG SF         CHANGE SCHEDULED TIME FLAG...",@CR
   TYPE "CHG ST         CHANGE STOP TIME FOR A GIVEN RECORD",@CR
   TYPE "DEL REC        DELETES A SINGLE RECORD FOR A GIVEN SYSTEM FOR A GIVEN DAY",@CR
   TYPE "DELETE OR DEL  DELETE RECORDS FOR A GIVEN SYSTEM FOR A GIVEN DAY",@CR
   TYPE "CHECK SW       CHECKS SOFTWARE SYSTEMS RECORDS FOR TIME GAPS,ETC.",@CR
   TYPE "CHECK HW       CHECKS HARDWARE SYSTEMS RECORDS FOR GAPS,OVERLAP,AND DUPLICATES",@CR
   TYPE "LIST SW        TYPES RECORDS FOR A GIVEN DAY FOR A GIVEN SYSTEM NUMBER",@CR
   TYPE "LIST HW        TYPES RECORDS FOR A GIVEN DAY FOR A GIVEN HARDWARE ID",@CR
   TYPE "QUIT,EXIT,OR Q RETURNS TO MAGNUM COMMAND LEVEL",@CR
   TYPE "HELP OR ?      RETYPES THIS LIST",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END %HELP COMMAND%
%%
IF INPUT.COMMAND="ADD" THEN
ADD.COMMAND:
BEGIN

GET.DATE:
BEGIN
TYPE @CR,"DATE OF INPUT: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL DATE.INPUT
				ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF DATE.INPUT>TODAY THEN REPEAT GET.DATE

HOLIDAY.INPUT.CHECK:
BEGIN

FOR EACH HOLIDAY. WHERE HOLIDAY>=DATE.INPUT FINISH HOLIDAY.INPUT.CHECK
TYPE @CR,"THE HOLIDAY SCHEDULE MUST BE BROUGHT UP TO DATE"
TYPE @CR,"BEFORE ENTERING TIME FOR THIS OR LATER DATES",@CR
REPEAT ENTIRE.PROCEDURE
END %HOLIDAY.INPUT.CHECK%

END %GET.DATE%

TYPE "SYSTEM NUMBER: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL SYSNO.INPUT ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END

CHECK.SYSNO:
BEGIN
 FOR EACH SYSTEM. WHERE SYSNO=SYSNO.INPUT AND
     NOT (DATE.INPUT<START.DATE OR DATE.INPUT>END.DATE)
  BEGIN
  LET SYSTEM.ID=ID
  LET C.HW.ID=HW.ID
      SELECT CHANGE.SYSTEM. VIA KEY THEN LET C.HW.ID=HW.ID
  LET C.SITE.ID=SITE.ID
  LET C.CLASS.ID=CLASS.ID
  LET SYS.CLASS.ID=CLASS.ID
  LET C.PRIME.START=PRIME.START
  LET C.PRIME.STOP=PRIME.STOP
  LET SYS.START.DATE=START.DATE
  LET SYS.END.DATE=END.DATE
  FINISH CHECK.SYSNO
  END
 TYPE @CR,"NO SUCH SYSTEM",@CR
 REPEAT ADD.COMMAND
END %CHECK.SYSNO%

LET HW.ID=C.HW.ID
LET SITE.ID=C.SITE.ID
LET CLASS.ID=C.CLASS.ID
LET PRIME.START=C.PRIME.START
LET PRIME.STOP=C.PRIME.STOP

CHECK.DATE:
BEGIN

LET ELAPSED.TIME=0

SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=0) THEN
       IF STOP.TIME=0 THEN FINISH CHECK.DATE

FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    SELECT DELETED.RECORDS. VIA KEY THEN NOTHING ELSE
       ADD STOP.TIME-START.TIME TO ELAPSED.TIME

IF ELAPSED.TIME>0 THEN FINISH CHECK.DATE

FOR EACH TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    SELECT DELETED.RECORDS. VIA KEY THEN NOTHING ELSE
       ADD STOP.TIME-START.TIME TO ELAPSED.TIME

END %CHECK.DATE%

IF ELAPSED.TIME>1440 THEN
   BEGIN
   TYPE @CR,"MORE THAN 24 HOURS ENTERED FOR THIS SYSTEM FOR THIS DAY"
   TYPE @CR,"USE THE CHANGE COMMAND TO ELIMINATE OVERLAPPING RECORDS",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END

IF ELAPSED.TIME=1440 THEN
   BEGIN
   TYPE @CR,"24 HOURS ALREADY ENTERED FOR THIS DATE FOR THIS SYSTEM",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END

VERIFY.HW.ID:
BEGIN
TYPE "IS HW.ID ","<",TRIM(HW.ID),">","? "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF ANSWER="Y" OR "N" THEN NOTHING ELSE REPEAT VERIFY.HW.ID
END %VERIFY HW.DI%

IF ANSWER ="N" THEN
   BEGIN
   TYPE "ENTER HW.ID: "
   PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL C.HW.ID ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
    MHWP:
    BEGIN
    TYPE "MAKE NEW HARDWARE PERMANENT? " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER
						ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
    IF ANSWER ="Y" OR "N" THEN NOTHING ELSE REPEAT MHWP
    END %MHWP%
    IF ANSWER ="Y" THEN
    SELECT CHANGE.SYSTEM. VIA KEY THEN
     ALTER CHANGE.SYSTEM. USING (C.HW.ID FOR HW.ID) ELSE
     INSERT INTO CHANGE.SYSTEM. USING (C.HW.ID FOR HW.ID)
  END %IF ANSWER=N%

%CHECK FOR DUPLICATE HARDWARE ID SITUATION AND WARN USER%

FOR EACH SYSTEM.
    BEGIN
    LET CC.HW.ID=HW.ID
    IF SYSTEM.ID#ID THEN
    SELECT CHANGE.SYSTEM. VIA SYSTEM.ID=ID THEN LET CC.HW.ID=HW.ID
    IF CLASS.ID=C.CLASS.ID AND
       CC.HW.ID=C.HW.ID AND
       SYSTEM.ID#ID AND
       NOT (DATE.INPUT>END.DATE OR <START.DATE) THEN
           BEGIN
           TYPE @CR,TRIM(TITLE(SITE. VIA ID=SITE.ID))," "
           TYPE TRIM(ABBREV(CLASS. VIA ID=CLASS.ID))," SYSTEM "
           TYPE SYSNO," IS ALSO ASSIGNED TO HARDWARE ",TRIM(CC.HW.ID),@CR
           DUP.HW:
           BEGIN
           TYPE "DO YOU WISH TO CONTINUE? " PAUSE.FOR.INPUT 60 THEN 
						ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
           IF ANSWER ="Y" OR "N" THEN NOTHING ELSE REPEAT DUP.HW
           END %DUP.HW%
           IF ANSWER="N" THEN
              BEGIN
              TYPE @CR,"THE NEW HARDWARE HAS BEEN MADE PERMANET",@CR
              REPEAT ENTIRE.PROCEDURE
              END
           END
       END %DUPLICATE HW CHECK%

LET HW.ID=C.HW.ID

LET FLAG=0
FOR EACH NORMAL.SCHEDULE. VIA SYSTEM.ID
 BEGIN
 IF FLAG=0 THEN TYPE "NORMAL SCHEDULE:",@CR
 LET FLAG=1
 TYPE (((SCHED.UP/60)*100)+(SCHED.UP-((SCHED.UP/60)*60))) AS "4N","-",
      (((SCHED.DN/60)*100)+(SCHED.DN-((SCHED.DN/60)*60))) AS "4N",@CR
 END
IF FLAG=0 THEN
BEGIN
 TYPE @CR,"THERE IS NO SCHEDULE ON RECORD FOR THIS SYSTEM",@CR
NO.SCHED:
BEGIN
  TYPE "DO YOU WISH TO CONTINUE? "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
 IF ANSWER="Y" OR "N" THEN NOTHING ELSE REPEAT NO.SCHED
 END %NO.SCHED%
 IF ANSWER ="N" THEN
    BEGIN
    TYPE @CR
    REPEAT ENTIRE.PROCEDURE
    END
 END %BEGIN BEFORE NO SCHEDULE MESSAGE%

SPEC.SCHED:
BEGIN
TYPE "SPECIAL SCHEDULE? "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF ANSWER ="Y" OR "N" THEN NOTHING ELSE REPEAT SPEC.SCHED

SET.SCHED:
BEGIN
 IF ANSWER="N" THEN
    BEGIN
    LET NORMAL.SCHEDULE="Y"
    FINISH SET.SCHED
    END

LET NORMAL.SCHEDULE="N"
DELETE FROM SPECIAL.SCHEDULE. ALL
INPUT.SCHEDULE:
BEGIN
 TYPE "INPUT SCHED.UP,SCHED.DN: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL NEW.SCHED.UP,NEW.SCHED.DN ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
  IF NEW.SCHED.UP<0 OR >2400 THEN REPEAT INPUT.SCHEDULE
  IF NEW.SCHED.DN<0 OR >2400 THEN REPEAT INPUT.SCHEDULE
  TEST.FOR.0.0:
  BEGIN
  IF NEW.SCHED.UP=0 AND NEW.SCHED.DN=0 THEN FINISH TEST.FOR.0.0
  IF NEW.SCHED.UP>=NEW.SCHED.DN THEN REPEAT INPUT.SCHEDULE
  END %TEST.FOR.0.0%
  IF NEW.SCHED.UP-((NEW.SCHED.UP/100)*100)>59 THEN REPEAT INPUT.SCHEDULE
  IF NEW.SCHED.DN-((NEW.SCHED.DN/100)*100)>59 THEN REPEAT INPUT.SCHEDULE
 LET NEW.SCHED.UP=((NEW.SCHED.UP/100)*60)+(NEW.SCHED.UP-(NEW.SCHED.UP/100)*100)
 LET NEW.SCHED.DN=((NEW.SCHED.DN/100)*60)+(NEW.SCHED.DN-(NEW.SCHED.DN/100)*100)
  CHECK.SCHEDULE:
   BEGIN
   FOR EACH SPECIAL.SCHEDULE.
    IF NEW.SCHED.UP>SCHED.DN OR NEW.SCHED.DN<SCHED.UP THEN NOTHING ELSE
     BEGIN
     TYPE "LAST INPUT CONFLICTS WITH PREVIOUS INPUT AND IS IGNORED",@CR
     FINISH CHECK.SCHEDULE
     END
   INSERT INTO SPECIAL.SCHEDULE. USING
    (NEW.SCHED.UP FOR SCHED.UP,NEW.SCHED.DN FOR SCHED.DN)
   END %CHECK SCHEDULE%
  MSI:
   BEGIN
    TYPE "MORE SCHEDULE INPUT? "
    PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
    IF ANSWER="Y" OR "N" THEN NOTHING ELSE REPEAT MSI
   END %MSI%
   IF ANSWER="Y" THEN REPEAT INPUT.SCHEDULE
  END %INPUT.SCHEDULE%
 SPEC.COR:
 BEGIN
  TYPE "IS SPECIAL SCHEDULE CORRECT? "
  PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
  IF ANSWER ="Y" OR "N" THEN NOTHING ELSE REPEAT SPEC.COR
  IF ANSWER="N" THEN
     BEGIN
     TYPE @CR,"RE-ENTER ENTIRE SPECIAL SCHEDULE",@CR
     REPEAT SPEC.SCHED
     END
 END %SPEC.COR%
% MAKE.PERM:  this section of code disabled 9/4/79 by ed gauci
 BEGIN
  TYPE "MAKE SPECIAL SCHEDULE PERMANENT? "
  PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
  IF ANSWER="Y" OR "N" THEN NOTHING ELSE REPEAT MAKE.PERM
 END %%MAKE.PERM%%
  IF ANSWER ="Y" THEN
  BEGIN
  DELETE FROM L.NORMAL.SCHEDULE. VIA SYSTEM.ID
  FOR EACH SPECIAL.SCHEDULE. INSERT INTO L.NORMAL.SCHEDULE.
  SELECT CHANGE.SCHEDULE. VIA KEY THEN NOTHING ELSE INSERT INTO CHANGE.SCHEDULE.
  END %%IF PERM%%
%

END %SET.SCHEDULE%
%END SPEC.SCHED%

%BRING OVER ANY RECORDS ALREADY IN%

NEXT.DAY:
BEGIN
   FOR EACH TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
       SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME)
              THEN NOTHING %KEEP LOCAL RECORD%
              ELSE SELECT DELETED.RECORDS. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME)
                   THEN NOTHING ELSE INSERT INTO L.TIME.

SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=0) THEN
       IF STOP.TIME=0 THEN DELETE FROM L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)

DELETE FROM DELETED.RECORDS. VIA (SYSTEM.ID,DATE.=DATE.INPUT)

SELECT ADD.TIME. VIA KEY THEN NOTHING ELSE INSERT INTO ADD.TIME.

TYPE "ENTER CODE,STOP TIME:",@CR
LET STOP.TIME=0
NEXT.INPUT:
BEGIN
LET OLD.STOP.TIME=STOP.TIME

NEXT.TIME:
IF ELAPSED.TIME>0 THEN
   BEGIN
SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=OLD.STOP.TIME)
 THEN BEGIN
      TYPE "[ ",CODE(CODE. VIA ID=CODE.ID),","
      TYPE (((STOP.TIME/60)*100)+(STOP.TIME-((STOP.TIME/60)*60))) AS "4N","]",@CR
      IF STOP.TIME=1440 THEN FINISH NEXT.INPUT
      LET OLD.STOP.TIME=STOP.TIME
      REPEAT NEXT.TIME
      END
   END %IF ELAPSED.TIME>0%

LET STOP.TIME=OLD.STOP.TIME

NEXT.CODE:
BEGIN

LET START.TIME=STOP.TIME
TYPE "* "
PAUSE.FOR.INPUT 300 THEN ACCEPT FROM TERMINAL CODE.INPUT,STOP.TIME ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF STOP.TIME-((STOP.TIME/100)*100)>59 THEN
   BEGIN
   TYPE "BAD STOP TIME",@CR
   LET STOP.TIME=START.TIME
   REPEAT NEXT.CODE
   END
LET STOP.TIME=((STOP.TIME/100)*60)+(STOP.TIME-(STOP.TIME/100)*100)
IF STOP.TIME=START.TIME THEN
   BEGIN
   TYPE "STOP TIME=START TIME, RE-ENTER CODE,STOP TIME",@CR
   LET STOP.TIME=START.TIME
   REPEAT NEXT.CODE
   END
IF STOP.TIME<START.TIME THEN
   BEGIN
   TYPE "STOP TIME MUST BE GREATER THEN START TIME, RE-ENTER",@CR
   LET STOP.TIME=START.TIME
   REPEAT NEXT.CODE
   END
IF STOP.TIME>1440 THEN
   BEGIN
   TYPE "STOP TIME GREATER THAN 2400, RE-ENTER CODE,STOP TIME",@CR
   LET STOP.TIME=START.TIME
   REPEAT NEXT.CODE
   END


IF CODE.INPUT>399 THEN
   BEGIN
   TYPE "ADD 100 FOR FIELD TEST, 200 FOR A HW.ID CHANGE",@CR
   TYPE "ADD 300 FOR FIELD TEST AND A HW.ID CHANGE",@CR
   TYPE "RE-ENTER CODE,STOP TIME",@CR
   LET STOP.TIME=START.TIME
   REPEAT NEXT.CODE
   END
IF (CODE.INPUT>100 AND <200) OR CODE.INPUT>300 THEN
   BEGIN
   SUBTRACT 100 FROM CODE.INPUT
   LET FT.FLAG=1
   END
 ELSE
   LET FT.FLAG=2
IF CODE.INPUT>200 THEN
   BEGIN
   LET HW.ID.FLAG=1
   SUBTRACT 200 FROM CODE.INPUT
   END
  ELSE
   LET HW.ID.FLAG=0

CHECK.CODE:
BEGIN
FOR EACH CODE. WHERE CLASS.ID=SYS.CLASS.ID AND
    CODE=CODE.INPUT AND DATE.INPUT>=START.DATE AND DATE.INPUT<=END.DATE
    BEGIN
    LET CODE.ID=ID
    LET CODE.TYPE=TYPE.ABBREV
    FINISH CHECK.CODE
    END
TYPE "CODE ",CODE.INPUT," NOT VALID, RE-ENTER CODE,STOP TIME",@CR
LET STOP.TIME=START.TIME
REPEAT NEXT.CODE
END %CHECK.CODE%

IF HW.ID.FLAG=1 THEN
   BEGIN
   TYPE "HW.ID: "
   PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL C.HW.ID ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   LET HW.ID=C.HW.ID
%CHECK IF NEW HARDWARE IS A DUPLICATE AND WARN USER%

LET OLD.SYSTEM.ID=SYSTEM.ID

FOR EACH SYSTEM.
    BEGIN
    LET CC.HW.ID=HW.ID
    IF SYSTEM.ID#ID THEN
    SELECT CHANGE.SYSTEM. VIA SYSTEM.ID=ID THEN LET CC.HW.ID=HW.ID
    IF CLASS.ID=C.CLASS.ID AND
        CC.HW.ID=C.HW.ID AND
        SYSTEM.ID#ID AND
       NOT (DATE.INPUT>END.DATE OR <START.DATE) THEN
           BEGIN
           TYPE @CR,TRIM(TITLE(SITE. VIA ID=SITE.ID))," "
           TYPE TRIM(ABBREV(CLASS. VIA ID=CLASS.ID))," SYSTEM "
           TYPE SYSNO," IS ALSO ASSIGNED TO HARDWARE ",TRIM(CC.HW.ID),@CR
           DUP.HW2:
           BEGIN
           TYPE "DO YOU WISH TO CONTINUE? " PAUSE.FOR.INPUT 60 THEN 
						ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
           IF ANSWER ="Y" OR "N" THEN NOTHING ELSE REPEAT DUP.HW2
           END %DUP.HW2%
           IF ANSWER="N" THEN
              BEGIN
              TYPE @CR,"NEW HARDWARE NOT ENTERED",@CR
              REPEAT ENTIRE.PROCEDURE
              END
           END
    END %FOR EACH SYSTEM%

   LET SYSTEM.ID=OLD.SYSTEM.ID
   MHWP1:
   BEGIN
   TYPE "MAKE PERMANENT? " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER 
				ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE E  IF ANSWER ="Y" OR "N" THEN NOTHING ELSE REPEAT MHWP1
   END %MHWP1%
   IF ANSWER ="Y" THEN
   SELECT CHANGE.SYSTEM. VIA KEY THEN ALTER CHANGE.SYSTEM. USING (C.HW.ID FOR HW.ID)
          ELSE INSERT INTO CHANGE.SYSTEM. USING (C.HW.ID FOR HW.ID)
   END %IF FLAG ON%

LET RECORD.START=START.TIME
LET RECORD.STOP=STOP.TIME

NEXT.RECORD:
BEGIN

LET SCHED.FLAG=2
LET PRIME.FLAG=2

PRIME.CHECK:
BEGIN

IF (DATE.INPUT AS DATE "WWW") AS "3C"="SAT" OR "SUN" THEN
   BEGIN
   LET PRIME.FLAG=2 %NOT PRIME TIME ON SAT OR SUN%
   FINISH PRIME.CHECK
   END

SELECT HOLIDAY. VIA HOLIDAY=DATE.INPUT THEN
       BEGIN
       LET PRIME.FLAG=2 %HOLIDAYS ARE NOT PRIME TIME%
       FINISH PRIME.CHECK
       END

IF RECORD.START<PRIME.STOP AND RECORD.STOP>PRIME.START THEN
   BEGIN
   IF RECORD.START<PRIME.START THEN
      BEGIN
      LET RECORD.STOP=PRIME.START
      FINISH PRIME.CHECK
      END
   LET PRIME.FLAG=1
   IF RECORD.STOP>PRIME.STOP THEN
      BEGIN
      LET RECORD.STOP=PRIME.STOP
      FINISH PRIME.CHECK
      END
   END
END %PRIME CHECK%

SCHED.CHECK:
BEGIN

SPEC.SCHEDULE:
BEGIN
IF NORMAL.SCHEDULE="Y" THEN FINISH SPEC.SCHEDULE
FOR EACH SPECIAL.SCHEDULE.
    IF RECORD.START<SCHED.DN AND RECORD.STOP>SCHED.UP THEN
       BEGIN
       IF RECORD.START<SCHED.UP THEN
          BEGIN
          LET RECORD.STOP=SCHED.UP
          FINISH SCHED.CHECK
          END
       LET SCHED.FLAG=1
       IF RECORD.STOP>SCHED.DN THEN
          BEGIN
          LET RECORD.STOP=SCHED.DN
          FINISH SCHED.CHECK
          END
       END
FINISH SCHED.CHECK
END %WORK SCHEDULE%

%IF NORMAL SCHEDULE PREVAILS%

FOR EACH NORMAL.SCHEDULE. VIA SYSTEM.ID
    IF RECORD.START<SCHED.DN AND RECORD.STOP>SCHED.UP THEN
       BEGIN
       IF RECORD.START<SCHED.UP THEN
          BEGIN
          LET RECORD.STOP=SCHED.UP
          FINISH SCHED.CHECK
          END
       LET SCHED.FLAG=1
       IF RECORD.STOP>SCHED.DN THEN
          BEGIN
          LET RECORD.STOP=SCHED.DN
          FINISH SCHED.CHECK
          END
       END
END %SCHED.CHECK%

IF RECORD.STOP<=PRIME.START OR RECORD.START>=PRIME.STOP THEN LET PRIME.FLAG=2

SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=RECORD.START)
       THEN NOTHING %WOULD BE A DUPLICATE RECORD%
        ELSE
INSERT INTO L.TIME. USING (
 DATE.INPUT FOR DATE.,
 SYS.CLASS.ID FOR CLASS.ID,
 RECORD.START FOR START.TIME,
 RECORD.STOP FOR STOP.TIME)

IF RECORD.STOP=STOP.TIME THEN
   BEGIN
   LET OLD.STOP.TIME=STOP.TIME
   LET NEW.STOP.TIME=STOP.TIME
   LET OLD.START.TIME=START.TIME
   LET OVERLAP.FOUND="N"
   FIX.OVERLAP:
   BEGIN
       IF ELAPSED.TIME=0 THEN FINISH FIX.OVERLAP
       FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
           IF START.TIME>OLD.START.TIME AND <OLD.STOP.TIME THEN
              BEGIN
              LET NEW.STOP.TIME=START.TIME
              SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,
                                  START.TIME=OLD.START.TIME)
                     THEN BEGIN
                          ALTER L.TIME. USING (NEW.STOP.TIME FOR STOP.TIME)
                          IF ELAPSED.TIME>0 THEN
                           BEGIN
                          TYPE "STOP TIME CHANGED TO "
                          TYPE (((NEW.STOP.TIME/60)*100)+
                               (NEW.STOP.TIME-((NEW.STOP.TIME/60)*60))) AS "4N",@CR
                           LET OVERLAP.FOUND="Y"
                           END
                          FINISH FIX.OVERLAP
                          END
              END %FOR EACH TIME%
   END %FIX.OVERLAP%
IF RECORD.STOP=1440 THEN FINISH NEXT.INPUT
IF OVERLAP.FOUND="Y" THEN LET STOP.TIME=NEW.STOP.TIME
REPEAT NEXT.INPUT
END %IF RECORD.STOP=STOP.TIME%

LET RECORD.START=RECORD.STOP
LET RECORD.STOP=STOP.TIME
REPEAT NEXT.RECORD

END %NEXT.RECORD%
END %NEXT.CODE%
END %NEXT.INPUT%
   BEGIN
LET OLD.STOP.TIME=0
LET OLD.START.TIME=0
LET OLD.CODE.ID=0
LET OLD.SITE.ID=0
LET OLD.SCHED.FLAG=0
LET OLD.PRIME.FLAG=0
LET OLD.FT.FLAG=0
LET OLD.HW.ID=""
LET CONSOLIDATE.SWITCH=""

CONSOLIDATE.RECORDS:
BEGIN

FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
 CURRENTRECORD:
 BEGIN
  IF OLD.CODE.ID=CODE.ID AND
     OLD.SITE.ID=SITE.ID AND
     OLD.SCHED.FLAG=SCHED.FLAG AND
     OLD.PRIME.FLAG=PRIME.FLAG AND
     OLD.FT.FLAG=FT.FLAG AND
     OLD.HW.ID=HW.ID
      THEN
       BEGIN
       DELETE FROM L.TIME. VIA KEY
       IF STOP.TIME=1440
          THEN
           BEGIN
           LET OLD.STOP.TIME=STOP.TIME
           SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=OLD.START.TIME)
              THEN ALTER L.TIME. USING (OLD.STOP.TIME FOR STOP.TIME)
              ELSE TYPE @CR,"*PROGRAM ERROR*",@CR
          FINISH CONSOLIDATE.RECORDS
          END
         LET CONSOLIDATE.SWITCH="Y"
         FINISH CURRENTRECORD
       END

   IF CONSOLIDATE.SWITCH="Y"
      THEN
       BEGIN
       LET OLD.STOP.TIME=START.TIME
       SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=OLD.START.TIME)
        THEN ALTER L.TIME. USING (OLD.STOP.TIME FOR STOP.TIME)
        ELSE
         BEGIN
         TYPE @CR,"**PROGRAM ERROR**",@CR
         FINISH CONSOLIDATE.RECORDS
         END
       END

 IF STOP.TIME=1440 THEN FINISH CONSOLIDATE.RECORDS

  LET OLD.START.TIME=START.TIME
  LET OLD.STOP.TIME=STOP.TIME
  LET OLD.SITE.ID=SITE.ID
  LET OLD.CODE.ID=CODE.ID
  LET OLD.SCHED.FLAG=SCHED.FLAG
  LET OLD.PRIME.FLAG=PRIME.FLAG
  LET OLD.FT.FLAG=FT.FLAG
  LET OLD.HW.ID=HW.ID

END %CURRENT RECORD%

END %CONSOLIDATE.RECORDS%

   TYPE @CR
   NEXTDAY:
   BEGIN
   IF DATE.INPUT+1>TODAY THEN
      BEGIN
      TYPE @CR
      REPEAT ENTIRE.PROCEDURE
      END
   TYPE "DO NEXT DAY? "
   PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   IF ANSWER="Y" OR "N" OR "S" THEN NOTHING ELSE
      BEGIN
      TYPE "Y=GO TO NEXT DAY, USE NORMAL SCHEDULE",@CR
      TYPE "S=GO TO NEXT DAY, GET SPECIAL SCHEDULE",@CR
      TYPE "N=RETURN TO COLON, END INPUT",@CR
      REPEAT NEXTDAY
      END
  IF ANSWER="Y" OR "S" THEN
     BEGIN
     ADD 1 TO DATE.INPUT
     CHECK.NEXT.DATE:
     BEGIN
      IF DATE.INPUT GT SYS.END.DATE THEN BEGIN
	TYPE @CR,"SYSTEM NOT VALID FOR ",DATE.INPUT,@CR
	SUBTRACT 1 FROM DATE.INPUT
	REPEAT NEXTDAY
	END
      LET ELAPSED.TIME=0
      SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=0) THEN
             IF STOP.TIME=0 THEN FINISH CHECK.NEXT.DATE
      FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
          SELECT DELETED.RECORDS. VIA KEY THEN NOTHING ELSE
             ADD STOP.TIME-START.TIME TO ELAPSED.TIME
      IF ELAPSED.TIME>0 THEN FINISH CHECK.NEXT.DATE
      FOR EACH TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
          SELECT DELETED.RECORDS. VIA KEY THEN NOTHING ELSE
             ADD STOP.TIME-START.TIME TO ELAPSED.TIME
     END %CHECK.NEXT.DATE%
     IF ELAPSED.TIME>1440 THEN
        BEGIN
        TYPE @CR,"MORE THAN 24 HOURS ENTERED FOR THIS SYSTEM FOR THIS DAY"
        TYPE @CR,"USE THE CHANGE COMMAND TO ELIMINATE OVERLAPPING RECORDS",@CR,@CR
        REPEAT NEXTDAY
        END
     IF ELAPSED.TIME=1440 THEN
        BEGIN
        TYPE @CR,"24 HOURS ALREADY ENTERED FOR THIS DATE FOR THIS SYSTEM",@CR,@CR
        REPEAT NEXTDAY
        END

     TYPE @CR,DATE.INPUT AS DATE "WWW MMM ZD, YYYY",@CR
     IF ANSWER="S" THEN REPEAT SPEC.SCHED
     IF ANSWER="Y" THEN
        BEGIN
        LET NORMAL.SCHEDULE="Y"
        DELETE FROM SPECIAL.SCHEDULE. ALL
        REPEAT NEXT.DAY
        END
     END
  END %NEXTDAY%
  IF ANSWER="N" THEN
     BEGIN
     TYPE @CR
     REPEAT ENTIRE.PROCEDURE
     END

END %NEXT.DAY%
END %SPEC.SCHED%
END %ADD.COMMAND%
END
%%
IF INPUT.COMMAND= "CHG COD" OR
                  "CHG SIT" OR
                  "CHG FT"  OR
                  "CHG HW"  OR
                  "CHG PF"  OR
                  "CHG SF"  OR
                  "CHG ST"  THEN

CHANGE.COMMAND:
BEGIN
LET CHG.COD, CHG.SIT, CHG.FT, CHG.HW, CHG.PF, CHG.SF = "N"

GETDATE:
BEGIN
TYPE @CR,"DATE TO CHANGE: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL DATE.INPUT
				ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF DATE.INPUT>TODAY THEN REPEAT GETDATE
END %GETDATE%

TYPE "SYSTEM NUMBER: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL SYSNO.INPUT ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END

GET.SYSNO:
BEGIN

FOR EACH SYSTEM. WHERE SYSNO=SYSNO.INPUT
    AND NOT (DATE.INPUT<START.DATE OR DATE.INPUT>END.DATE)
    BEGIN
    LET SYSTEM.ID=ID
    LET SYS.CLASS.ID=CLASS.ID
    LET SYS.START.DATE=START.DATE
    LET SYS.END.DATE=END.DATE
    FINISH GET.SYSNO
    END
   TYPE @CR,"NO SUCH SYSTEM",@CR
   REPEAT ENTIRE.PROCEDURE
END %GET.SYSNO%

SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=0) THEN
       IF STOP.TIME=0 THEN
          BEGIN
          TYPE @CR,"NO TIME ENTERED",@CR,@CR
          REPEAT ENTIRE.PROCEDURE
          END

FIND.RECORDS:
BEGIN
LET FLAG=0
FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    SELECT DELETED.RECORDS. VIA KEY THEN NOTHING ELSE FINISH FIND.RECORDS
FOR EACH TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    BEGIN
    LET FLAG=1
    INSERT INTO L.TIME.
    END
IF FLAG=1 THEN FINISH FIND.RECORDS
TYPE @CR,"NO TIME ENTERED",@CR,@CR
REPEAT ENTIRE.PROCEDURE
END %FIND RECORDS%

SELECT ADD.TIME. VIA KEY THEN NOTHING ELSE INSERT INTO ADD.TIME.

GAP.CHECK:
BEGIN
LET GAP.FLAG=0
LET OVER.FLAG=0
LET OLD.STOP.TIME=0
FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
 BEGIN
 IF START.TIME<OLD.STOP.TIME THEN
    BEGIN
    IF OVER.FLAG=0 THEN TYPE @CR,"A TIME OVERLAP EXISTS"
    LET OVER.FLAG=1
    END
 IF START.TIME>OLD.STOP.TIME THEN
    BEGIN
    IF GAP.FLAG=0 THEN TYPE @CR,"A TIME GAP EXISTS"
    LET GAP.FLAG=1
    END
 LET OLD.STOP.TIME=STOP.TIME
 END %FOR EACH%
END %GAP.CHECK%
IF OLD.STOP.TIME#1440 OR GAP.FLAG=1 OR OVER.FLAG=1 THEN
   BEGIN
   IF OLD.STOP.TIME#1440 THEN TYPE @CR,"NO RECORD CONTAINING STOP TIME OF 2400 EXISTS"
  CKGAPA:
  BEGIN
   TYPE @CR,"DO YOU WISH TO CONTINUE? "
   PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   IF ANSWER ="Y" OR "N" THEN NOTHING ELSE REPEAT CKGAPA
  END %CKGAPA%
   IF ANSWER ="N" THEN REPEAT ENTIRE.PROCEDURE
   END %IF GAP OR OVERLAP%

GET.TIME:
BEGIN

TYPE @CR,"START, STOP TIME: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL RECORD.START,RECORD.STOP ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END

IF RECORD.START-((RECORD.START/100)*100)>59 THEN REPEAT GET.TIME
IF RECORD.STOP-((RECORD.STOP/100)*100)>59 THEN REPEAT GET.TIME
IF RECORD.START>=RECORD.STOP THEN
   BEGIN
   TYPE @CR,"START TIME MUST BE LESS THAN STOP TIME",@CR
   REPEAT GET.TIME
   END
IF RECORD.START>2400 OR RECORD.START-((RECORD.START/100)*100)>59 THEN
   BEGIN
   TYPE "BAD START TIME",@CR
   REPEAT GET.TIME
   END
IF RECORD.STOP>2400 OR RECORD.STOP-((RECORD.STOP/100)*100)>59 THEN
   BEGIN
   TYPE "BAD STOP TIME",@CR
   REPEAT GET.TIME
   END

LET RECORD.START=((RECORD.START/100)*60)+(RECORD.START-(RECORD.START/100)*100)
LET RECORD.STOP=((RECORD.STOP/100)*60)+(RECORD.STOP-(RECORD.STOP/100)*100)

LET OLD.STOP.TIME=0
FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    BEGIN
    IF START.TIME>OLD.STOP.TIME THEN
       BEGIN
       IF NOT (RECORD.STOP<=OLD.STOP.TIME OR RECORD.START>=START.TIME) THEN
          BEGIN
          TYPE @CR,"CHANGES NOT ALLOWED DURING TIME GAPS",@CR,@CR
          REPEAT ENTIRE.PROCEDURE
          END
       END
    LET OLD.STOP.TIME=STOP.TIME
    END %FOR EACH%

IF OLD.STOP.TIME<1440 AND RECORD.START>OLD.STOP.TIME THEN
   BEGIN
   TYPE @CR,"CHANGES NOT ALLOWED DURING TIME GAPS",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END

GET.CHG:
BEGIN

IF INPUT.COMMAND="CHG ST" THEN
   BEGIN
   SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=RECORD.START)
          THEN IF STOP.TIME<=RECORD.STOP THEN
               BEGIN
               TYPE @CR,"NEW STOP TIME MUST BE LESS THAN OLD STOP TIME",@CR
               TYPE "USE THE ADD COMMAND TO FILL IN TIME GAPS",@CR,@CR
               REPEAT ENTIRE.PROCEDURE
               END
          ELSE ALTER L.TIME. USING (RECORD.STOP FOR STOP.TIME)
          ELSE BEGIN
               TYPE @CR,"TO CHANGE A STOP TIME, THE START TIME MUST"
               TYPE @CR,"COINCIDE WITH AN EXISTING RECORD",@CR,@CR
               REPEAT ENTIRE.PROCEDURE
               END
   END %CHG ST%

 IF INPUT.COMMAND="CHG COD" THEN
    GET.COD:
    BEGIN
    TYPE "NEW CODE: "
    PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL NEW.CODE ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
CODE.CHECK:
BEGIN
FOR EACH CODE. WHERE CLASS.ID=SYS.CLASS.ID AND
    CODE=NEW.CODE AND DATE.INPUT>=START.DATE AND DATE.INPUT<=END.DATE
    BEGIN
    LET NEW.CODE.ID=ID
    LET CODE.TYPE=TYPE.ABBREV
    FINISH CODE.CHECK
    END
TYPE "INVALID CODE",@CR
REPEAT GET.COD
END %CODE.CHECK%
LET CHG.COD="Y"
END %GET.CODE%

IF INPUT.COMMAND="CHG SIT" THEN
  GET.SITE:
   BEGIN
   TYPE "NEW SITE: "
   PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL NEW.SITE ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   CHECK.SITE:
   BEGIN
   FOR EACH SITE.
       IF ABBREV=NEW.SITE THEN
          BEGIN
          LET NEW.SITE.ID=ID
          FINISH CHECK.SITE
          END
   TYPE "NO SUCH SITE",@CR
   REPEAT GET.SITE
   END %CHECK.SITE%
LET CHG.SIT="Y"
END %GET.SITE%

IF INPUT.COMMAND="CHG HW" THEN
   GET.HW:
   BEGIN
   TYPE "NEW HW.ID: "
   PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL NEW.HW.ID ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   LET CHG.HW="Y"
   END %GET.HW%

IF INPUT.COMMAND="CHG FT" THEN
GET.FT:
BEGIN
TYPE "NEW FT.FLAG: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL NEW.FT.FLAG ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF NEW.FT.FLAG="Y" OR "N" THEN NOTHING ELSE REPEAT GET.FT
IF NEW.FT.FLAG="Y" THEN LET NEW.FT=1 ELSE LET NEW.FT=2
LET CHG.FT="Y"
END %GET.FT%

IF INPUT.COMMAND="CHG SF" THEN
GET.SF:
BEGIN
TYPE "NEW SCHED.FLAG: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL NEW.SCHED.FLAG ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF NEW.SCHED.FLAG="Y" OR "N" THEN NOTHING ELSE REPEAT GET.SF
IF NEW.SCHED.FLAG="Y" THEN LET NEW.SF=1 ELSE LET NEW.SF=2
LET CHG.SF="Y"
END %GET.SF%

IF INPUT.COMMAND="CHG PF" THEN
GET.PF:
BEGIN
TYPE "NEW PRIME.FLAG: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL NEW.PRIME.FLAG ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF NEW.PRIME.FLAG="Y" OR "N" THEN NOTHING ELSE REPEAT GET.PF
IF NEW.PRIME.FLAG="Y" THEN LET NEW.PF=1 ELSE LET NEW.PF=2
LET CHG.PF="Y"
END %GET.PF%

MCQ:
BEGIN
ACF:
BEGIN
IF INPUT.COMMAND="" THEN
   BEGIN
   LET ANSWER ="Y"
   FINISH ACF
   END
TYPE "ANOTHER CHANGE FOR THIS START,STOP TIME? "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
END %ACF%
IF ANSWER ="Y" OR "N" THEN NOTHING ELSE REPEAT MCQ
IF ANSWER ="Y" THEN
   BEGIN
   TYPE "CHANGE COMMAND: "
   PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL INPUT.COMMAND ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   IF INPUT.COMMAND = "CHG COD" OR
                      "CHG SIT" OR
                      "CHG FT"  OR
                      "CHG HW"  OR
                      "CHG PF"  OR
                      "CHG SF"  OR
                      "CHG ST"   THEN REPEAT GET.CHG
   ELSE
    BEGIN
    TYPE "BAD COMMAND",@CR
    REPEAT MCQ
    END
   END %IF ANOTHER CHANGE DESIRED%
   END %MCQ%
END %GET.CHG%

TIME.ADJUSTMENT:
BEGIN

FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)

 IF RECORD.STOP>START.TIME AND RECORD.START<STOP.TIME THEN
  BEGIN

  IF CHG.COD="N" THEN LET NEW.CODE.ID=CODE.ID
  IF CHG.SIT="N" THEN LET NEW.SITE.ID=SITE.ID
  IF CHG.HW="N"  THEN LET NEW.HW.ID=HW.ID
  IF CHG.FT="N"  THEN LET NEW.FT=FT.FLAG
  IF CHG.SF="N"  THEN LET NEW.SF=SCHED.FLAG
  IF CHG.PF="N"  THEN LET NEW.PF=PRIME.FLAG

  IF RECORD.START>START.TIME AND RECORD.STOP<STOP.TIME THEN
   BEGIN
   ALTER L.TIME. USING (RECORD.START FOR STOP.TIME)
   INSERT INTO L.TIME. USING (
    RECORD.START FOR START.TIME,
    RECORD.STOP FOR STOP.TIME,
    NEW.CODE.ID FOR CODE.ID,
    NEW.SITE.ID FOR SITE.ID,
    NEW.HW.ID FOR HW.ID,
    NEW.FT FOR FT.FLAG,
    NEW.PF FOR PRIME.FLAG,
    NEW.SF FOR SCHED.FLAG)
   INSERT INTO L.TIME. USING (RECORD.STOP FOR START.TIME)
   FINISH TIME.ADJUSTMENT
   END

  IF RECORD.STOP<STOP.TIME THEN
   BEGIN
   INSERT INTO L.TIME. USING (RECORD.STOP FOR START.TIME)
   ALTER L.TIME. USING (
    RECORD.STOP FOR STOP.TIME,
    NEW.CODE.ID FOR CODE.ID,
    NEW.SITE.ID FOR SITE.ID,
    NEW.HW.ID FOR HW.ID,
    NEW.FT FOR FT.FLAG,
    NEW.PF FOR PRIME.FLAG,
    NEW.SF FOR SCHED.FLAG)
   FINISH TIME.ADJUSTMENT
   END

  IF RECORD.START=START.TIME AND RECORD.STOP=STOP.TIME THEN
   BEGIN
   ALTER L.TIME. USING (
    NEW.CODE.ID FOR CODE.ID,
    NEW.SITE.ID FOR SITE.ID,
    NEW.HW.ID FOR HW.ID,
    NEW.FT FOR FT.FLAG,
    NEW.PF FOR PRIME.FLAG,
    NEW.SF FOR SCHED.FLAG)
   FINISH TIME.ADJUSTMENT
   END

  IF RECORD.START=START.TIME AND RECORD.STOP>STOP.TIME THEN
   BEGIN
   ALTER L.TIME. USING (
    NEW.CODE.ID FOR CODE.ID,
    NEW.SITE.ID FOR SITE.ID,
    NEW.HW.ID FOR HW.ID,
    NEW.FT FOR FT.FLAG,
    NEW.PF FOR PRIME.FLAG,
    NEW.SF FOR SCHED.FLAG)
   LET RECORD.START=STOP.TIME
   REPEAT TIME.ADJUSTMENT
   END

  IF RECORD.START>START.TIME AND RECORD.STOP=STOP.TIME THEN
   BEGIN
   ALTER L.TIME. USING (RECORD.START FOR STOP.TIME)
   INSERT INTO L.TIME. USING (
    RECORD.START FOR START.TIME,
    NEW.CODE.ID FOR CODE.ID,
    NEW.SITE.ID FOR SITE.ID,
    NEW.HW.ID FOR HW.ID,
    NEW.FT FOR FT.FLAG,
    NEW.PF FOR PRIME.FLAG,
    NEW.SF FOR SCHED.FLAG)
   FINISH TIME.ADJUSTMENT
   END

  IF RECORD.START>START.TIME AND RECORD.STOP>STOP.TIME THEN
   BEGIN
   ALTER L.TIME. USING (RECORD.START FOR STOP.TIME)
   INSERT INTO L.TIME. USING (
    RECORD.START FOR START.TIME,
    NEW.CODE.ID FOR CODE.ID,
    NEW.SITE.ID FOR SITE.ID,
    NEW.HW.ID FOR HW.ID,
    NEW.FT FOR FT.FLAG,
    NEW.PF FOR PRIME.FLAG,
    NEW.SF FOR SCHED.FLAG)
   LET RECORD.START=STOP.TIME
   REPEAT TIME.ADJUSTMENT
   END

  END %IF RECORD IS AFFECTED%
  END %FOR EACH TIME%

AMC:
BEGIN
TYPE @CR,"ANY MORE CHANGES FOR THIS DATE FOR THIS SYSTEM? "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL ANSWER ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF ANSWER ="Y" OR "N" THEN NOTHING ELSE REPEAT AMC
IF ANSWER ="Y" THEN
   BEGIN
   LET INPUT.COMMAND=""
   LET CHG.COD,CHG.SIT,CHG.FT,CHG.HW,CHG.PF,CHG.SF="N"
   REPEAT GET.TIME
   END

LET OLD.STOP.TIME=0

%DO NOT CONSOLIDATE IF OVERLAPS EXIST%

FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    BEGIN
    IF OLD.STOP.TIME>START.TIME THEN
       BEGIN
       TYPE @CR,"A TIME OVERLAP STILL EXISTS",@CR,@CR
       REPEAT ENTIRE.PROCEDURE
       END
     IF START.TIME>OLD.STOP.TIME THEN
      BEGIN
      TYPE @CR,"A TIME GAP STILL EXISTS",@CR,@CR
      REPEAT ENTIRE.PROCEDURE
      END
   LET OLD.STOP.TIME=STOP.TIME
   END %FOR EACH L.TIME.%

IF OLD.STOP.TIME<1440 THEN
   BEGIN
   TYPE @CR,"A TIME GAP STILL EXISTS",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END
IF OLD.STOP.TIME>1440 THEN
   BEGIN
   TYPE @CR,"A TIME OVERLAP STILL EXISTS",@CR
   REPEAT ENTIRE.PROCEDURE
   END


LET OLD.STOP.TIME=0
LET OLD.START.TIME=0
LET OLD.CODE.ID=0
LET OLD.SITE.ID=0
LET OLD.SCHED.FLAG=0
LET OLD.PRIME.FLAG=0
LET OLD.FT.FLAG=0
LET OLD.HW.ID=""
LET CONSOLIDATE.SWITCH=""

CONSOLIDATE:
BEGIN

FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
 CURRENT.RECORD:
 BEGIN
  IF OLD.CODE.ID=CODE.ID AND
     OLD.SITE.ID=SITE.ID AND
     OLD.SCHED.FLAG=SCHED.FLAG AND
     OLD.PRIME.FLAG=PRIME.FLAG AND
     OLD.FT.FLAG=FT.FLAG AND
     OLD.HW.ID=HW.ID
      THEN
       BEGIN
       DELETE FROM L.TIME. VIA KEY
       IF STOP.TIME=1440
          THEN
           BEGIN
           LET OLD.STOP.TIME=STOP.TIME
           SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=OLD.START.TIME)
              THEN ALTER L.TIME. USING (OLD.STOP.TIME FOR STOP.TIME)
              ELSE TYPE @CR,"*PROGRAM ERROR*",@CR
          FINISH CONSOLIDATE
          END
         LET CONSOLIDATE.SWITCH="Y"
         FINISH CURRENT.RECORD
       END

   IF CONSOLIDATE.SWITCH="Y"
      THEN
       BEGIN
       LET OLD.STOP.TIME=START.TIME
       SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=OLD.START.TIME)
        THEN ALTER L.TIME. USING (OLD.STOP.TIME FOR STOP.TIME)
        ELSE
         BEGIN
         TYPE @CR,"**PROGRAM ERROR**",@CR
         FINISH CONSOLIDATE
         END
       END

 IF STOP.TIME=1440 THEN FINISH CONSOLIDATE

  LET OLD.START.TIME=START.TIME
  LET OLD.STOP.TIME=STOP.TIME
  LET OLD.SITE.ID=SITE.ID
  LET OLD.CODE.ID=CODE.ID
  LET OLD.SCHED.FLAG=SCHED.FLAG
  LET OLD.PRIME.FLAG=PRIME.FLAG
  LET OLD.FT.FLAG=FT.FLAG
  LET OLD.HW.ID=HW.ID

END %CURRENT RECORD%

END %CONSOLIDATE%
TYPE @CR
REPEAT ENTIRE.PROCEDURE
END %AMC%

END %GET.TIME%

END %CHANGE.COMMAND%
%%
IF INPUT.COMMAND="DELETE" OR "DEL" THEN
DELETE.COMMAND:
BEGIN

DATECHECK:
BEGIN
TYPE @CR,"DATE TO DELETE: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL DATE.INPUT
				ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF DATE.INPUT>TODAY THEN REPEAT DATECHECK
END %DATECHECK%

TYPE "SYSTEM NUMBER: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL DEL.SYSNO ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END

CHECK.SYS:
BEGIN
FOR EACH SYSTEM. WHERE SYSNO=DEL.SYSNO
    AND NOT (DATE.INPUT<START.DATE OR DATE.INPUT>END.DATE)
    BEGIN
    LET SYSTEM.ID=ID
    FINISH CHECK.SYS
    END
TYPE @CR,"NO SUCH SYSTEM",@CR
REPEAT ENTIRE.PROCEDURE
END %CHECK.SYS%

DELETE FROM ADD.TIME. VIA KEY

DELETE FROM L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)

DELETE FROM DELETED.RECORDS. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
INSERT INTO L.TIME.
 USING (DATE.INPUT FOR DATE.,ZERO.STOP FOR START.TIME,ZERO.STOP FOR STOP.TIME)

TYPE @CR
REPEAT ENTIRE.PROCEDURE

END %DELETE.COMMAND%
%%
IF INPUT.COMMAND="LIST HW" THEN
BEGIN

LIST.HW:
BEGIN
TYPE @CR,"DATE TO LIST: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL DATE.INPUT
				ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF DATE.INPUT>TODAY THEN REPEAT LIST.HW
END %LIST.HW%

TYPE "HARDWARE ID: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL C.HW.ID ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END

LH.GETCLS:
BEGIN
TYPE "CLASS: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL CLASS.INPUT ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
FOR EACH CLASS. WHERE ABBREV=CLASS.INPUT
    BEGIN
    LET SYS.CLASS.ID=ID
    FINISH LH.GETCLS
    END
TYPE @CR,"NO SUCH CLASS",@CR
REPEAT LH.GETCLS
END %LH.GETCLS%

TYPE @CR,"SIT CLS  SN  COD  STR STOP S P",@CR
FOR EACH L.TIME. WHERE HW.ID=C.HW.ID AND DATE.=DATE.INPUT AND CLASS.ID=SYS.CLASS.ID
 BEGIN
 LET L.START.TIME=START.TIME
 SELECT L.TIME. VIA (SYSTEM.ID,DATE.,START.TIME=0) THEN
  IF STOP.TIME#0 THEN SELECT DELETED.RECORDS. VIA KEY THEN NOTHING ELSE
       SELECT L.TIME. VIA (SYSTEM.ID,DATE.,START.TIME=L.START.TIME) THEN
       BEGIN
       TYPE ABBREV(SITE. VIA ID=SITE.ID)," ",
       ABBREV(CLASS. VIA ID=CLASS.ID)," ",
       SYSNO(SYSTEM. VIA ID=SYSTEM.ID),"  ",
       CODE(CODE. VIA ID=CODE.ID)," ",
       (((START.TIME/60)*100)+(START.TIME-((START.TIME/60)*60))) AS "4N"," ",
       (((STOP.TIME/60)*100)+(STOP.TIME-((STOP.TIME/60)*60))) AS "4N"," "
       IF SCHED.FLAG=1 THEN TYPE "Y " ELSE TYPE "N "
       IF PRIME.FLAG=1 THEN TYPE "Y " ELSE TYPE "N "
       %IF FT.FLAG=1 THEN TYPE "Y" ELSE TYPE "N"%
       TYPE @CR
       END
  END %FOR EACH L.TIME.%

FOR EACH HW.TIME. VIA (HW.ID=C.HW.ID,DATE.=DATE.INPUT)
 SELECT TIME. VIA KEY THEN
    TYPE.HW:
    BEGIN

    IF CLASS.ID#SYS.CLASS.ID THEN FINISH TYPE.HW

    FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.) FINISH TYPE.HW

    TYPE
    ABBREV(SITE. VIA ID=SITE.ID)," ",
    ABBREV(CLASS. VIA ID=CLASS.ID)," ",
    SYSNO(SYSTEM. VIA ID=SYSTEM.ID),"  ",
    CODE(CODE. VIA ID=CODE.ID)," ",
    (((START.TIME/60)*100)+(START.TIME-((START.TIME/60)*60))) AS "4N"," ",
    (((STOP.TIME/60)*100)+(STOP.TIME-((STOP.TIME/60)*60))) AS "4N"," "
    IF SCHED.FLAG=1 THEN TYPE "Y " ELSE TYPE "N "
    IF PRIME.FLAG=1 THEN TYPE "Y " ELSE TYPE "N "
    %IF FT.FLAG=1 THEN TYPE "Y" ELSE TYPE "N"%
    TYPE @CR
   END %TYPE.HW%

   TYPE @CR
 REPEAT ENTIRE.PROCEDURE
END %LIST HW COMMAND%
%%
IF INPUT.COMMAND ="LIST SW" THEN
BEGIN

GETDATE.LIST:
BEGIN
TYPE @CR,"DATE TO LIST: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL DATE.INPUT
				ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF DATE.INPUT>TODAY THEN REPEAT GETDATE.LIST
END %GETDATE.LIST%

CHECK.SYSTEM.LIST:
BEGIN
TYPE "SYSTEM NUMBER: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL SYSNO.INPUT ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
FOR EACH SYSTEM. WHERE SYSNO=SYSNO.INPUT
    AND NOT (DATE.INPUT<START.DATE OR DATE.INPUT>END.DATE)
        BEGIN
        LET SYSTEM.ID=ID
        FINISH CHECK.SYSTEM.LIST
        END
TYPE @CR,"NO SUCH SYSTEM",@CR
REPEAT ENTIRE.PROCEDURE
END %CHECK.SYSTEM.LIST%

SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=0) THEN
       IF STOP.TIME=0 THEN
          BEGIN
          TYPE @CR
          REPEAT ENTIRE.PROCEDURE
          END



%********************

PRINT HEADINGS

*********************%
TYPE @CR, @TAB TO 43,"**EFFECTIVE DURING**",@CR
TYPE "SITE  CLASS  HARDWARE  CODE  START  STOP    SCHEDULED  PRIME",@CR
TYPE @TAB TO 17,"ID",@TAB TO 31,"TIME  TIME      TIME      TIME",@CR,@CR
LET FLAG=0

%********************
SELECT DATA AND PRINT IT
*********************%

FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    IF STOP.TIME#0 THEN SELECT DELETED.RECORDS. VIA KEY THEN NOTHING ELSE
       BEGIN
       TYPE ABBREV(SITE. VIA ID=SITE.ID),"    ",
       ABBREV(CLASS. VIA ID=CLASS.ID),"      ",
       HW.ID,"     ",
       CODE(CODE. VIA ID=CODE.ID),"    ",
       (((START.TIME/60)*100)+(START.TIME-((START.TIME/60)*60))) AS "4N","  ",
       (((STOP.TIME/60)*100)+(STOP.TIME-((STOP.TIME/60)*60))) AS "4N","        "
       IF SCHED.FLAG=1 THEN TYPE "Y          " ELSE TYPE "N          "
       IF PRIME.FLAG=1 THEN TYPE "Y " ELSE TYPE "N "
       %IF FT.FLAG=1 THEN TYPE "Y" ELSE TYPE "N"%
       TYPE @CR
       LET FLAG=1
       END

IF FLAG=1 THEN
   BEGIN
   TYPE @CR
   REPEAT ENTIRE.PROCEDURE
   END

FOR EACH TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    SELECT L.TIME. VIA KEY THEN NOTHING ELSE
       BEGIN
       TYPE ABBREV(SITE. VIA ID=SITE.ID),"    ",
       ABBREV(CLASS. VIA ID=CLASS.ID),"      ",
       HW.ID,"     ",
       CODE(CODE. VIA ID=CODE.ID),"    ",
       (((START.TIME/60)*100)+(START.TIME-((START.TIME/60)*60))) AS "4N","  ",
       (((STOP.TIME/60)*100)+(STOP.TIME-((STOP.TIME/60)*60))) AS "4N","        "
       IF SCHED.FLAG=1 THEN TYPE "Y          " ELSE TYPE "N          "
       IF PRIME.FLAG=1 THEN TYPE "Y " ELSE TYPE "N "
        %IF FT.FLAG=1 THEN TYPE "Y" ELSE TYPE "N"    %
       TYPE @CR
     END

   TYPE @CR
 REPEAT ENTIRE.PROCEDURE
END %LIST SW COMMAND%
%%
IF INPUT.COMMAND="CHECK SW" THEN
BEGIN

FOR EACH L.TIME.
    BEGIN
    TYPE @CR,"PLEASE RE-CALL THE UPDATE PROGRAM BEFORE USING THIS COMMAND",@CR
    FINISH ENTIRE.PROCEDURE
    END

CKSYS.GET.DATE:
BEGIN
TYPE @CR,"START,END DATES: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL INPUT.STARTING.DATE,INPUT.ENDING.DATE
	ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF INPUT.STARTING.DATE>TODAY THEN REPEAT CKSYS.GET.DATE
IF INPUT.ENDING.DATE<INPUT.STARTING.DATE OR >TODAY THEN REPEAT CKSYS.GET.DATE
END %CKSYS.GET.DATE%

TYPE "SYSTEM NUMBER: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL SYSNO.INPUT
			ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END

CKSYS:
BEGIN
IF SYSNO.INPUT=0 THEN FINISH CKSYS
FOR EACH SYSTEM. WHERE SYSNO=SYSNO.INPUT AND
    NOT (START.DATE>INPUT.ENDING.DATE OR END.DATE<INPUT.STARTING.DATE)
    BEGIN
    LET SYSTEM.ID=ID
    FINISH CKSYS
    END
TYPE @CR,"NO SUCH SYSTEM",@CR,@CR
REPEAT ENTIRE.PROCEDURE
END %CKSYS%

IF SYSNO.INPUT=0 THEN
   BEGIN

   CKSW.GET.SITE:
   BEGIN
   TYPE "SITE: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL SITE.INPUT ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   IF SITE.INPUT="ALL" THEN FINISH CKSW.GET.SITE
   FOR EACH SITE. WHERE ABBREV=SITE.INPUT FINISH CKSW.GET.SITE
   TYPE @CR,"NO SUCH SITE",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END %CKSW.GET.SITE%

   CKSW.GET.CLASS:
   BEGIN
   TYPE "CLASS: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL CLASS.INPUT ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   IF CLASS.INPUT="ALL" THEN FINISH CKSW.GET.CLASS
   FOR EACH CLASS. WHERE ABBREV=CLASS.INPUT FINISH CKSW.GET.CLASS
   TYPE @CR,"NO SUCH CLASS",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END %CKSW.GET.CLASS%

END %IF SYSNO=0%

TYPE @CR

FOR EACH SYSTEM.
    WHERE NOT (START.DATE>INPUT.ENDING.DATE OR END.DATE<INPUT.STARTING.DATE)
    SORTED ON SITE.ID,CLASS.ID,SYSNO,START.DATE
    THIS.SYSTEM:
    BEGIN

    IF SYSNO.INPUT#0 AND SYSNO.INPUT#SYSNO THEN FINISH THIS.SYSTEM

    IF SYSNO.INPUT=0 THEN
       BEGIN
       IF SITE.INPUT="ALL" THEN NOTHING ELSE
          IF SITE.INPUT#ABBREV(SITE. VIA ID=SITE.ID)
             THEN FINISH THIS.SYSTEM
       IF CLASS.INPUT="ALL" THEN NOTHING
          ELSE IF CLASS.INPUT#ABBREV(CLASS. VIA ID=CLASS.ID)
               THEN FINISH THIS.SYSTEM
       END %IF SYSNO.INPUT=0%

LET STARTING.DATE=INPUT.STARTING.DATE
LET ENDING.DATE=INPUT.ENDING.DATE
IF START.DATE >STARTING.DATE THEN LET STARTING.DATE=START.DATE
IF END.DATE <ENDING.DATE THEN LET ENDING.DATE=END.DATE
LET CURRENT.DATE=STARTING.DATE
LET PREVIOUS.DATE=STARTING.DATE-1
LET PREVIOUS.STOP.TIME=1440

WHILE CURRENT.DATE<=ENDING.DATE DO
      BEGIN
      FOR EACH TIME. VIA (SYSTEM.ID=ID OF SYSTEM.,DATE.=CURRENT.DATE)
          CKSYS.RECORD:
          BEGIN

          IF DATE.=PREVIOUS.DATE AND START.TIME=PREVIOUS.STOP.TIME THEN
             BEGIN
             LET PREVIOUS.STOP.TIME=STOP.TIME
             FINISH CKSYS.RECORD
             END

          IF DATE.=PREVIOUS.DATE+1 AND PREVIOUS.STOP.TIME=1440 THEN
             IF START.TIME=0 THEN
             BEGIN
             LET PREVIOUS.DATE=DATE.
             LET PREVIOUS.STOP.TIME=STOP.TIME
             FINISH CKSYS.RECORD
             END
           ELSE BEGIN
                TYPE SYSNO," ",DATE. AS DATE "ZD MMM YY ","0000 TO "
                TYPE (((START.TIME/60)*100)+
                     (START.TIME-((START.TIME/60)*60))) AS "4N",@CR
                LET PREVIOUS.DATE=DATE.
                LET PREVIOUS.STOP.TIME=STOP.TIME
                FINISH CKSYS.RECORD
                END

          IF DATE.=PREVIOUS.DATE THEN
             BEGIN
             TYPE SYSNO," ",DATE. AS DATE "ZD MMM YY "
             TYPE (((PREVIOUS.STOP.TIME/60)*100)+
                  (PREVIOUS.STOP.TIME-((PREVIOUS.STOP.TIME/60)*60))) AS "4N"
             TYPE " TO "
             TYPE (((START.TIME/60)*100)+(START.TIME-((START.TIME/60)*60))) AS "4N",@CR
             LET PREVIOUS.STOP.TIME=STOP.TIME
             FINISH CKSYS.RECORD
             END

         IF PREVIOUS.DATE=DATE.-2 AND PREVIOUS.STOP.TIME=1440 AND
            START.TIME=0 THEN
            BEGIN
            LET DATE.=DATE.-1
            TYPE SYSNO," ",DATE. AS DATE "ZD MMM YY",@CR
            LET PREVIOUS.DATE=DATE.+1
            LET PREVIOUS.STOP.TIME=STOP.TIME
            FINISH CKSYS.RECORD
            END

      IF PREVIOUS.STOP.TIME=1440 THEN
         BEGIN
         ADD 1 TO PREVIOUS.DATE
         TYPE SYSNO," ",PREVIOUS.DATE AS DATE "ZD MMM YY "
         SUBTRACT 1 FROM PREVIOUS.DATE
         TYPE "0000"
         END
         ELSE BEGIN
              TYPE SYSNO," ",PREVIOUS.DATE AS DATE "ZD MMM YY "
              TYPE (((PREVIOUS.STOP.TIME/60)*100)+
                   (PREVIOUS.STOP.TIME-((PREVIOUS.STOP.TIME/60)*60))) AS "4N"
                   END
      TYPE " TO "
      IF START.TIME=0 THEN
         BEGIN
         SUBTRACT 1 FROM DATE.
         TYPE DATE. AS DATE "ZD MMM YY "
         ADD 1 TO DATE.
         TYPE "2400",@CR
         END
       ELSE BEGIN
            TYPE DATE. AS DATE "ZD MMM YY "
            TYPE (((START.TIME/60)*100)+
                  (START.TIME-((START.TIME/60)*60))) AS "4N",@CR
            END

      LET PREVIOUS.DATE=DATE.
      LET PREVIOUS.STOP.TIME=STOP.TIME

     END %CKSYS.RECORD%

     ADD 1 TO CURRENT.DATE
END %WHILE LOOP%

IF PREVIOUS.DATE=ENDING.DATE AND PREVIOUS.STOP.TIME=1440 THEN NOTHING
   ELSE IF PREVIOUS.DATE=ENDING.DATE-1 AND PREVIOUS.STOP.TIME=1440
           THEN TYPE SYSNO," ",ENDING.DATE AS DATE "ZD MMM YY",@CR
        ELSE BEGIN
        IF PREVIOUS.STOP.TIME=1440 THEN
           BEGIN
           ADD 1 TO PREVIOUS.DATE
           LET PREVIOUS.STOP.TIME=0
           END
        TYPE SYSNO," ",PREVIOUS.DATE AS DATE "ZD MMM YY "
        TYPE (((PREVIOUS.STOP.TIME/60)*100)+
             (PREVIOUS.STOP.TIME-((PREVIOUS.STOP.TIME/60)*60))) AS "4N"
        TYPE " TO "
        TYPE ENDING.DATE AS DATE "ZD MMM YY ","2400",@CR
        END

END %FOR EACH SYSTEM%

TYPE @CR
REPEAT ENTIRE.PROCEDURE
END %CKSYS COMMAND%
%%
IF INPUT.COMMAND="CHECK HW" THEN
BEGIN

FOR EACH L.TIME.
    BEGIN
    TYPE @CR,"PLEASE RE-CALL THE UPDATE PROGRAM BEFORE USING THIS COMMAND",@CR
    FINISH ENTIRE.PROCEDURE
    END

CKHW.GET.DATE:
BEGIN
TYPE @CR,"START,END DATES: "
PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL STARTING.DATE,ENDING.DATE ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF STARTING.DATE>TODAY THEN REPEAT CKHW.GET.DATE
IF ENDING.DATE<STARTING.DATE OR >TODAY THEN REPEAT CKHW.GET.DATE
END %CKHW.GET.DATE%

TYPE "HARDWARE ID: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL HARDWARE.ID.INPUT
			ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END

IF HARDWARE.ID.INPUT="" THEN
   CKHW.GET.SITE:
   BEGIN
   TYPE "SITE: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL SITE.INPUT ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   IF SITE.INPUT="ALL" THEN FINISH CKHW.GET.SITE
   FOR EACH SITE. WHERE ABBREV=SITE.INPUT FINISH CKHW.GET.SITE
   TYPE @CR,"NO SUCH SITE",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END %CKHW.GET.SITE%

   CKHW.GET.CLASS:
   BEGIN
   TYPE "CLASS: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL CLASS.INPUT ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
   IF HARDWARE.ID.INPUT#"" AND CLASS.INPUT="ALL" THEN
      BEGIN
      TYPE @CR,"INPUT A SPECIFIC CLASS",@CR
      REPEAT CKHW.GET.CLASS
      END
   IF CLASS.INPUT="ALL" THEN FINISH CKHW.GET.CLASS
   FOR EACH CLASS. WHERE ABBREV=CLASS.INPUT
       BEGIN
       LET CLASS.ID=ID
       FINISH CKHW.GET.CLASS
       END
   TYPE @CR,"NO SUCH CLASS",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END %CKHW.GET.CLASS%

DELETE FROM HARDWARE.ID. ALL
IF HARDWARE.ID.INPUT#"" THEN INSERT INTO HARDWARE.ID.
   USING (HARDWARE.ID.INPUT FOR HW.ID) ELSE
   BEGIN
   FOR EACH SYSTEM.
       WHERE NOT (START.DATE>ENDING.DATE OR END.DATE<STARTING.DATE)
       IF (SITE.INPUT="ALL" OR SITE.INPUT=ABBREV(SITE. VIA ID=SITE.ID)) THEN
       IF (CLASS.INPUT="ALL" OR CLASS.INPUT=ABBREV(CLASS. VIA ID=CLASS.ID)) THEN
     SELECT HARDWARE.ID. VIA KEY THEN
       TYPE @CR,"HARDWARE ",TRIM(HW.ID)," ASSIGNED TO MORE THAN 1 ",TRIM(ABBREV(CLASS. VIA ID=CLASS.ID))," SYSTEM",@CR
    ELSE INSERT INTO HARDWARE.ID.
  END %IF HARDWARE.ID.INPUT=""%

TYPE @CR

FOR EACH HARDWARE.ID.
    BEGIN
LET PREVIOUS.DATE=STARTING.DATE-1
LET PREVIOUS.STOP.TIME=1440
LET PREVIOUS.SYSTEM.ID=0

LET CURRENT.DATE=STARTING.DATE
WHILE CURRENT.DATE<=ENDING.DATE DO
BEGIN
 FOR EACH HW.TIME. VIA (HW.ID=HW.ID OF HARDWARE.ID.,DATE.=CURRENT.DATE)
  SELECT TIME. VIA KEY THEN IF CLASS.ID=CLASS.ID OF HARDWARE.ID. THEN
          CKHW.RECORD:
          BEGIN

          IF DATE.=PREVIOUS.DATE AND START.TIME<PREVIOUS.STOP.TIME THEN
             BEGIN
             TYPE HW.ID," ",ABBREV(CLASS. VIA ID=CLASS.ID)," ",
                  SYSNO(SYSTEM. VIA ID=PREVIOUS.SYSTEM.ID)," ",
                  SYSNO(SYSTEM. VIA ID=SYSTEM.ID)," ",
                  DATE. AS DATE "ZD MMM YY "
             TYPE (((PREVIOUS.STOP.TIME/60)*100)+
                  (PREVIOUS.STOP.TIME-((PREVIOUS.STOP.TIME/60)*60))) AS "4N"
             TYPE " TO "
             TYPE (((START.TIME/60)*100)+(START.TIME-((START.TIME/60)*60))) AS "4N",@CR
             END

             LET PREVIOUS.STOP.TIME=STOP.TIME
             LET PREVIOUS.DATE=DATE.
             LET PREVIOUS.SYSTEM.ID=SYSTEM.ID

           END %CKHW.RECORD%

ADD 1 TO CURRENT.DATE
END %WHILE%

END %FOR EACH HARDWARE ID%

TYPE @CR
REPEAT ENTIRE.PROCEDURE
END %CHECK HW%
%%
IF INPUT.COMMAND="DELETE RECORD" OR "DEL REC" THEN
BEGIN

DR.GET.DATE:
BEGIN
TYPE @CR,"DATE TO DELETE: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL DATE.INPUT
				ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
IF DATE.INPUT>TODAY THEN REPEAT DR.GET.DATE
END %DR.GET.DATE%

TYPE "SYSTEM NUMBER: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL SYSNO.INPUT
			ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END

DR.GET.SYS:
BEGIN
FOR EACH SYSTEM. WHERE SYSNO=SYSNO.INPUT AND
    NOT (DATE.INPUT>END.DATE OR <START.DATE)
         BEGIN
         LET SYSTEM.ID=ID
         FINISH DR.GET.SYS
         END
TYPE @CR,"NO SUCH SYSTEM",@CR,@CR
REPEAT ENTIRE.PROCEDURE
END %DR.GET.SYS%

TYPE "START TIME: " PAUSE.FOR.INPUT 60 THEN ACCEPT FROM TERMINAL START.TIME
			ELSE BEGIN LET MESSAGE.FLAG = 'Y' FINISH ENTIRE.PROCEDURE END
LET START.TIME=((START.TIME/100)*60)+(START.TIME-(START.TIME/100)*100)
LET OLD.START.TIME=START.TIME

SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=0) THEN
       IF STOP.TIME=0 THEN
          BEGIN
          TYPE @CR,"ALL RECORDS FOR THAT SYSTEM FOR THAT DATE ARE DELETED",@CR,@CR
          REPEAT ENTIRE.PROCEDURE
          END

DR.CK.L.TIME:
BEGIN

FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    BEGIN
    SELECT L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=OLD.START.TIME)
           THEN BEGIN
                DELETE FROM L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT,START.TIME=OLD.START.TIME)
                INSERT INTO DELETED.RECORDS.
                TYPE @CR
                REPEAT ENTIRE.PROCEDURE
                END
           ELSE BEGIN
                TYPE @CR,"NO SUCH RECORD",@CR,@CR
                REPEAT ENTIRE.PROCEDURE
                END
    END %IF ANY L.TIME. RECORDS%

LET FLAG=0
FOR EACH TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    BEGIN
    LET FLAG=1
    INSERT INTO L.TIME.
    END

IF FLAG=0 THEN
   BEGIN
   TYPE @CR,"NO RECORDS FOR THAT SYSTEM FOR THAT DATE",@CR,@CR
   REPEAT ENTIRE.PROCEDURE
   END

SELECT ADD.TIME. VIA KEY THEN NOTHING ELSE INSERT INTO ADD.TIME.
REPEAT DR.CK.L.TIME %GO BACK AND DO THE DELETE%
END %DR.CK.L.TIME%

END %DELETE RECORD COMMAND%
%%
TYPE "?",@CR
REPEAT ENTIRE.PROCEDURE
END %ENTIRE.PROCEDURE%



IF MESSAGE.FLAG = 'Y' THEN BEGIN
	TYPE @CR,@CR,"INPUT TIMED OUT !!!",@CR,@CR
	TYPE "SOME OF YOUR UPDATES MAY HAVE BEEN LOST,",@CR,
	     "PLEASE RE-CALL THE UPDATER PROCEDURE AND CHECK YOUR DATA!",@CR,@CR
END

FOR EACH ADD.TIME.
    BEGIN
    FOR EACH TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
        DELETE FROM HW.TIME. VIA KEY
    DELETE FROM TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
    FOR EACH L.TIME. VIA (SYSTEM.ID,DATE.=DATE.INPUT)
     SELECT DELETED.RECORDS. VIA KEY
      THEN NOTHING
      ELSE BEGIN
           INSERT INTO TIME.
           SELECT HW.TIME. VIA KEY
            THEN ALTER HW.TIME.
            ELSE INSERT INTO HW.TIME.
           END
    END

FOR EACH L.TIME. WHERE STOP.TIME=0
 BEGIN
 FOR EACH TIME. VIA (SYSTEM.ID,DATE.) DELETE FROM HW.TIME. VIA KEY
 DELETE FROM TIME. VIA (SYSTEM.ID,DATE.)
 END

FOR EACH CHANGE.SYSTEM. SELECT SYSTEM. VIA ID=SYSTEM.ID THEN
    ALTER SYSTEM. USING (HW.ID OF CHANGE.SYSTEM. FOR HW.ID)

FOR EACH CHANGE.SCHEDULE.
    BEGIN
    DELETE FROM NORMAL.SCHEDULE. VIA SYSTEM.ID
    FOR EACH L.NORMAL.SCHEDULE. VIA SYSTEM.ID INSERT INTO NORMAL.SCHEDULE.
    END

TYPE @CR,@CR,"Done.",@CR


END
 	 K