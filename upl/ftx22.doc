
        THE FOLLOWING DOCUMENTS THE NEW RELEASE OF THE X22 FORTRAN
LIBRARY.  THE NEW LIBRARY GIVES THE USER THE ABILITY TO HAVE MULTIPLE X22
DATA SETS, X22 FILES, OPEN AT THE SAME TIME.

        FIRST THINGS FIRST, WHERE IS THE NEW LIBRARY, AND HOW DO I
LOAD IT?

                WHERE: IN THE UPL ON ALL TYMCOM 10'S
                LIBRARY NAME: FTX22.REL
                LOAD COMMAND: -LOAD PROG,...,(UPL)FTX22/LIB (CR)
                            : -LOAD PROG,...,@(UPL)FTX22 (CR)


        THE FOLLOWING IS A LIST OF THE NEW ROUTINES ADDED TO THE LIBRARY
AND A BREIF DESCRIPTION:

DBMOD           ALLOWS THE USER TO CHANGE THE NAME OR ABBREVIATION OF AN
                ATTRIBUTE

DBGET           RETRIEVES A RECORD FROM A DATA SET AND PLACES ALL THE VAL-
                UES IN AN INTEGER ARRAY

DBSET           TELLS X22 WHICH DATA SET TO WORK WITH

DBNSET          RETURNS THE NUMBER OF DATA SETS WE ARE WORKING WITH

DBCSET          RETURNS THE CURRENT NUMBER OF THE DATA SET WE ARE
                WORKING WITH

DBOPEN          MODIFIED TO ACCEPT A LIST OF SEVERAL DATA SETS


----------------------------------------------------------------------------


SUBROUTINE DBMOD
----------------

DESC: DBMOD ALLOWS A USER TO CHANGE THE NAME OR ABBREVIATION OF AN ATT-
RIBUTE

CALL SEQUENCE: CALL DBMOD(IATT,IOPT,NEWNAME)

WHERE:
        IATT IS EITHER THE ATTRIBUTE NAME,  ABBREVIATION, OR NUMBER
        IOPT IS EITHER 'NAME' OR 'ABBRE'
        NEWNAME IS EITHER THE ATTRIBUTE'S NEW NAME OR NEW ABBREVIATION

EXAMPLE:

        A DATA SET HAS THE FOLLOWING ATTRIBUTES:
        ATT DAY_ONE ABB DAY1
        ATT DAY_TWO ABB DAY2

        CALL DBMOD('DAY_ONE','NAME','DAY')   ; CHANGES THE NAME FROM
                                               DAY_ONE TO DAY

        CALL DBMOD('DAY2','ABBRE','D2')      ; CHANGES THE ABBRE
                                               OF ATT DAY_TWO TO D2

        CALL DBMOD(2,'ABBRE','D2')           ; SAME AS ABOVE


SUBROUTINE DBGET
----------------

DESC: RETRIEVES AN ENTIRE RECORD FROM A DATA SET AND PLACES IT IN AN INTEGER
ARRAY THAT HAS THE STANDARD RECORD FORMAT.  IN THIS FORMAT, EACH ATTRIBUTE
BEGINS ON A NEW WORD BOUNDARY WITHIN THE ARRAY. ATTRIBUTE NUMBER 1 STARTS
THE ARRAY, THEN NUMBER 2, ETC.

CALLING SEQUNCE: CALL DBGET(IARR,$LABEL,[IRECNO])

WHERE:
        IARR IS AN INTEGER ARRAY TO RECIEVE THE X22 RECORD
        $LABEL IS WHERE TO GO WHEN AN END OF GROUP IS REACHED
        IRECNO IS THE OPTIONAL RECORD NUMBER FOR RANDOM RETRIEVAL IN
                       THE GROUP

NOTE:  SINCE ALL VALUES ARE RETURNED INTO A INTEGER ARRAY, A USER
MUST EQUIVALANCE A REAL VARIABLE TO THE ARRAY POSTION WHICH WILL HOLD
THE REAL VALUE.

EXAMPLE:

A DATA SET IS DEFINED AS FOLLOWS:

ATT PARTNO INTEGER
ATT COST REAL
ATT DESC TEXT LEN 22
ATT QOH INTEGER

THE USER MUST FIRST DEFINE AN INTEGER ARRAY OF 8 WORDS AS FOLLOWS:

        1 WORD FOR PARTNO
        1 WORD FOR COST
        5 WORDS FOR DESC
        1 WORD FOR QOH

FOR A TOTAL OF 8 WORDS.

THE ARRAY IARR HAS THE FOLLOWING STANDARD RECORD
FORMAT:

        IARR(1) -- THE VALUE OF PARTNO
        IARR(2) -- THE VALUE OF COST
        IARR(3) THRU IARR(7) -- THE CHARACTERS FOR DESC
        IARR(8) -- THE VALUE OF QOH

THE FOLLOWING PROGRAM WILL RETRIEVE THE FIRST RECORD  FROM THE DATA SET
INV.DMS AND PRINT IT OUT:

        DIMENSION IARR(8)               ; ARRAY DECLARATION
        EQUIVALANCE (COST,IARR(2))      ; SET COST TO BE THE SAME AS IARR(2)
        CALL DBSTRT(-1,1)              ; SET DBSTRT FOR TYPE STATEMENT
        CALL DBOPEN('INV')             ; OPEN DATA SET INV.DMS
        CALL DBFIND('SYSID','EQ',1)    ; LOCATE THE FIRST RECORD
1       CALL DBGET(IARR,$100)          ; GET THE RECORD & GO TO 100
                                         AT THE END OF THE GROUP

        TYPE 10, IARR(1),COST,(IARR(J),J=3,8) 
10      FORMAT('PART= ',I,/,' COST= ',F,/,' DESC= ',4A5,A2,/
     +  ' QOH= ',I)
100     CALL DBEND                     ; CLOSE THE X22 DATA SET
        END                            ; THE END

DBGET AND COBOL
---------------

THE DBGET ROUTINE CAN BE ESPECIALLY USEFUL TO THE COBOL PROGRAMMER.
IF ONE SETS UP A COBOL RECORD EQUAL TO THE STANDARD RECORD FORMAT OF X22,
THE COBOL PROGRAMMER CAN THEN REFER TO THE X22 ATTRIBUTES BY
NAME.  IN THE ABOVE EXAMPLE, THE X22 RECORD DESCRIPTION WOULD BE:

        01 X22RECORD.
           02 PARTNO, COMP, PIC S9(9).
           02 COST , COMP, PIC S999V99.
           02 DESC , DISPLAY-7, PIC X(22).
           02 QOH, COMP, PIC S9(9).

THE FOLLOWING WILL RETRIEVE A WHOLE RECORD:

        ENTER MACRO DBGET USING X22RECORD NOMORERECS.

DBGET AND DBINFO
----------------

        THE 20TH POSITION OF THE INF ARRAY OF DBINFO NOW CONTAINS
THE INDEX INTO THE 'STANDARD RECORD FORMAT' ARRAY . THUS:

        CALL DBINFO('PART',INF)       ; INF(20) = 1
        CALL DBINFO('DESC',INF)       ; INF(20) = 3
        CALL DBINFO('QOH',INF)       ; INF(20) = 8

SUBROUTINE DBOPEN
-----------------

DESC: OPENS ONE OR MULTIPLE DATA SETS
CALLING SEQUENCE: CALL DBOPEN(IDS1,IDS2,....,IDSN)

WHERE:
        IDSN IS DEFINED AS FOLLOWS:
                FILENAME,['PASSWORD',PASSWORD,'ACCESS',ACCESSCODE]

                WHERE: FILE NAME IS THE DATA SET NAME

                THE FOLLOWING ARE OPTIONAL:

                       'PASSWORD' IS A KEY WORD FOR THE PASSWORD

                       PASSWORD IS OPTIONAL AND IS THE PASSWORD FOR
                       DATA SET IF NEEDED.

                       'ACCESS' IS THE KEY WORD FOR ACCESS

                       ACCESSCODE IS THE ACCESS CODE, IF NON ZERO
                       THE DATA SET IS OPENED READ ONLY

EXAMPLE:

        CALL DBOPEN('INV','PARTS')   ; OPENS DATA SETS INV.DMS AND PARTS.DMS

        NOTE: THAT DATA SET INV.DMS IS GIVEN THE DATA SET NUMBER OF 1 AND
              DATA SET PARTS.DMS IS GIVEN THE DATA SET NUMBER OF 2


        CALL DBOPEN('TEST','PASSWORD','XYZ','ACCESS','RO')

        OPENS DATA SET TEST.DMS WITH THE PASSWORD OF XYZ AND FOR
        READ ONLY


NOTE:  THE CURRENT DATA SET NUMBER AFTER A DBOPEN IS THE NUMBER OF
THE LAST DATA SET OPEN


SUBROUTINE DBSET
----------------

DESC: TELL X22 WHAT DATA SET TO WORK WITH.

CALLING SEQUENCE: CALL DBSET(N)

WHERE:
        N IS EQUAL TO THE DATA SET NUMBER

EXAMPLE:

        CALL DBOPEN('INV','PART')     ; INV = DATA SET 1
                                      ; PART = DATA SET 2
        .
        .
        .
        .
        CALL DBSET(1)     ; TELLS X22 TO WORK WITHINV, DATA SET 1
        CALL DBFIND(...)  ; THE FIND COMMAND APPLIES TO DATA SET INV
        .
        .
        .
        .
        CALL DBSET(2)    ; NOW WE WILL BE WORKING WITH DATA SET 2 = PART
        CALL DBFIND(..)  ; THE FIND COMMAND APPLIES TO DATA SET PART


SUBROUTINE DBCSET
-----------------

DESC: RETURNS THE CURRENT DATA SET NUMBER

CALL SEQUENCE: CALL DBCSET(N)

WHERE:
        N WOULD CONTAIN THE CURRENT DATA SET NUMBER


SUBROUTINE DBNSET
-----------------

DESC: RETURNS THE TOTAL NUMBER OF DATA SETS BEING WORKED ON "OPENED"

CALLING SEQUENCE: CALL DBNSET(N)

WHERE:
        N WOULD CONTAIN THE CURRECT DATA SET NUMBER



THE FOLLOWING IS AN EXAMPLE OF USING MULTIPLE DATA SETS:

        ASSUME WE HAVE TWO DATA SETS:

        EMP.DMS
        SKILL.DMS

        DATA SET EMP.DMS HAS THE FOLLWOING STRUCTURE:

        ATT EMPNO INT KEYED
        ATT EMPNAME TEXT LEN 25
        ATT SALARY REAL

        DATA SET SKILL.DMS HAS THE FOLLOWING STRUCTURE:

        ATT EMPNO INT KEYED
        ATT SKILL TEXT 20

NOTE: THAT THE COMMON LINK BETWEEN THE DATA SET EMP AND THE DATA SET
      SKILL IS THE EMPLOYEE NUMBER

        INTEGER EMPREC(7), SKILL(4)
        EQUIVALENCE (SAL,EMPREC(2))               ; MUST DO IT BECAUSE
                                                  SALARY IS REAL

        CALL DBSTRT(-1,1)                     ; FOR TYPE STATEMENT

        CALL DBOPEN('EMP','SKILL')            ; REMEBER EMP = DATA SET 1
                                               SKILL = DATA SET 2

        CALL DBSET(1)                           ; SET DATA SET TO EMP
        CALL DBFIND('ALL')                      ; LOCATE ALL THE RECORDS

1       CALL DBGET(EMPREC,$100)   ; READ A RECORD FOR EMP  GO TO 100
                                    AT END OF THE GROUP

        TYPE 10, (EMPREC(J),J=1,6), SAL   ; PRINT THE EMPLOYEES REC

        CALL DBSET(2)        ; NOW WORK WITH DATA SET 2

        CALL DBFIND('EMPNO','EQ',EMPREC(1))  ; FIND THE EMPLOYEE IN DATA
                                             SET SKILL

3       CALL DBGREC($2)   ; GET THE EMPLOYEE'S SKILL RECORD
        CALL DBVAL('SKILL',SKILL)  ; THE EMPLOYEES SKILL
        TYPE 11, SKILL             ; PRINT IT

        GO TO 3                    ; GET HIS NEXT SKILL

2       CALL DBSET(1)              ; OK WE ARE THROUGH WITH THAT EMP
                                  ; TELL X22 TO WORK WITH DATA SET 1

        GO TO 1

100     CONTINUE                  ; OK ALL DONE SO CLOSE X22 DATA SETS
        CALL DBEND                ; DBEND WILL CLOSE ALL THE X22 DATA SETS
